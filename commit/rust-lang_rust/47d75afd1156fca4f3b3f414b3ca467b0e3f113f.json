{"sha": "47d75afd1156fca4f3b3f414b3ca467b0e3f113f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDc1YWZkMTE1NmZjYTRmM2IzZjQxNGIzY2E0NjdiMGUzZjExM2Y=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-03-06T03:43:43Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-03-09T18:53:35Z"}, "message": "Complete re-implementation of 2-phase borrows\n\nSee #48431 for discussion as to why this was necessary and what we hoped to\naccomplish. A brief summary:\n   - the first implementation of 2-phase borrows was hard to limit in the way we\n   wanted. That is, it was too good at accepting all 2-phase borrows rather than\n   just autorefs =)\n   - Numerous diagnostic regressions were introduced by 2-phase borrow support\n   which were difficult to fix", "tree": {"sha": "df08c85cf256f4dc8ef06ad2170129eaa34aab4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df08c85cf256f4dc8ef06ad2170129eaa34aab4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d75afd1156fca4f3b3f414b3ca467b0e3f113f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d75afd1156fca4f3b3f414b3ca467b0e3f113f", "html_url": "https://github.com/rust-lang/rust/commit/47d75afd1156fca4f3b3f414b3ca467b0e3f113f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d75afd1156fca4f3b3f414b3ca467b0e3f113f/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "047bec69b9ec54d400b1e255c8757bff8a5a854d", "url": "https://api.github.com/repos/rust-lang/rust/commits/047bec69b9ec54d400b1e255c8757bff8a5a854d", "html_url": "https://github.com/rust-lang/rust/commit/047bec69b9ec54d400b1e255c8757bff8a5a854d"}], "stats": {"total": 65, "additions": 32, "deletions": 33}, "files": [{"sha": "3d50b9467c132c7105228df1f95311344d3947a6", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/47d75afd1156fca4f3b3f414b3ca467b0e3f113f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d75afd1156fca4f3b3f414b3ca467b0e3f113f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=47d75afd1156fca4f3b3f414b3ca467b0e3f113f", "patch": "@@ -450,8 +450,10 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n \n                 // Perform the DFS.\n                 // `stack` is the stack of locations still under consideration\n+                // `visited` is the set of points we have already visited\n                 // `found_use` is an Option that becomes Some when we find a use\n                 let mut stack = vec![start_location];\n+                let mut visited = FxHashSet();\n                 let mut found_use = None;\n                 while let Some(curr_loc) = stack.pop() {\n                     let block_data = &self.mir.basic_blocks()\n@@ -467,6 +469,11 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                         continue;\n                     }\n \n+                    if !visited.insert(curr_loc) {\n+                        debug!(\"  Already visited {:?}\", curr_loc);\n+                        continue;\n+                    }\n+\n                     if self.location_contains_use(curr_loc, assigned_place) {\n                         // TODO: Handle this case a little more gracefully. Perhaps collect\n                         // all uses in a vector, and find the point in the CFG that dominates\n@@ -529,19 +536,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<ReserveOrActivateIndex>,\n                                            location: Location) {\n-        /*\n-         XXX: bob_twinkles  reintroduce this\n-        let block_data = &self.mir[location.block];\n-        if location.statement_index != block_data.statements.len() {\n-            let statement = &block_data.statements[location.statement_index];\n-            if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n-                for &borrow_index in &self.region_map[&ReScope(region_scope)] {\n-                    sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n-                }\n-            }\n-        }\n-        */\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n             // NOTE: The state associated with a given `location`\n             // reflects the dataflow on entry to the statement. If it\n@@ -575,6 +569,20 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                           .map(|b| ReserveOrActivateIndex::active(*b)));\n         }\n     }\n+\n+    /// Performs the activations for a given location\n+    fn perform_activations_at_location(&self,\n+                                       sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                       location: Location) {\n+        // Handle activations\n+        match self.activation_map.get(&location) {\n+            Some(&activated) => {\n+                debug!(\"activating borrow {:?}\", activated);\n+                sets.gen(&ReserveOrActivateIndex::active(activated))\n+            }\n+            None => {}\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n@@ -605,13 +613,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n-        // Handle activations\n-        match self.activation_map.get(&location) {\n-            Some(&activated) => {\n-                sets.gen(&ReserveOrActivateIndex::active(activated))\n-            }\n-            None => {}\n-        }\n+        self.perform_activations_at_location(sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n \n         match stmt.kind {\n             // EndRegion kills any borrows (reservations and active borrows both)\n@@ -643,15 +646,17 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n+                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n+                        panic!(\"could not find BorrowIndex for location {:?}\", location);\n+                    });\n+\n                     if let RegionKind::ReEmpty = region {\n-                        // If the borrowed value is dead, the region for it\n-                        // can be empty. Don't track the borrow in that case.\n+                        // If the borrowed value dies before the borrow is used, the region for\n+                        // the borrow can be empty. Don't track the borrow in that case.\n+                        sets.kill(&ReserveOrActivateIndex::active(*index));\n                         return\n                     }\n \n-                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n-                        panic!(\"could not find BorrowIndex for location {:?}\", location);\n-                    });\n                     assert!(self.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n@@ -714,14 +719,9 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n         });\n \n         let term = block.terminator();\n+        self.perform_activations_at_location(sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n \n-        // Handle activations\n-        match self.activation_map.get(&location) {\n-            Some(&activated) => {\n-                sets.gen(&ReserveOrActivateIndex::active(activated))\n-            }\n-            None => {}\n-        }\n \n         match term.kind {\n             mir::TerminatorKind::Resume |"}, {"sha": "90933c6b31fa868b8ce7bffe37ce552130639be9", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47d75afd1156fca4f3b3f414b3ca467b0e3f113f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d75afd1156fca4f3b3f414b3ca467b0e3f113f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=47d75afd1156fca4f3b3f414b3ca467b0e3f113f", "patch": "@@ -53,7 +53,6 @@ fn not_ok() {\n     *y += 1;\n     //[lxl_beyond]~^   ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n     //[nll_beyond]~^^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    //[nll_target]~^^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n     read(z);\n }\n "}]}