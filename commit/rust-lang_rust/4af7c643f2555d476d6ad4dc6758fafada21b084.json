{"sha": "4af7c643f2555d476d6ad4dc6758fafada21b084", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjdjNjQzZjI1NTVkNDc2ZDZhZDRkYzY3NThmYWZhZGEyMWIwODQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-01-31T18:32:57Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-01T07:05:12Z"}, "message": "more cleanup", "tree": {"sha": "26553f51a10c57dc594afc36948cc9e03c3895aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26553f51a10c57dc594afc36948cc9e03c3895aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af7c643f2555d476d6ad4dc6758fafada21b084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af7c643f2555d476d6ad4dc6758fafada21b084", "html_url": "https://github.com/rust-lang/rust/commit/4af7c643f2555d476d6ad4dc6758fafada21b084", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af7c643f2555d476d6ad4dc6758fafada21b084/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53688addaa4484f1a317bb0938cf453381810427", "url": "https://api.github.com/repos/rust-lang/rust/commits/53688addaa4484f1a317bb0938cf453381810427", "html_url": "https://github.com/rust-lang/rust/commit/53688addaa4484f1a317bb0938cf453381810427"}], "stats": {"total": 128, "additions": 69, "deletions": 59}, "files": [{"sha": "4330bf8e33b2baa34f86fb7e7368246766e49487", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4af7c643f2555d476d6ad4dc6758fafada21b084/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af7c643f2555d476d6ad4dc6758fafada21b084/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4af7c643f2555d476d6ad4dc6758fafada21b084", "patch": "@@ -1456,96 +1456,105 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, ex);\n     }\n \n-\n+    // parse an expression of binops\n     fn parse_binops() -> @expr {\n-        return self.parse_more_binops(self.parse_prefix_expr(), 0);\n+        self.parse_more_binops(self.parse_prefix_expr(), 0)\n     }\n \n+    // parse an expression of binops of at least min_prec precedence\n     fn parse_more_binops(lhs: @expr, min_prec: uint) ->\n         @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n         let peeked = self.token;\n         if peeked == token::BINOP(token::OR) &&\n             (self.restriction == RESTRICT_NO_BAR_OP ||\n              self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n-            return lhs;\n-        }\n-        if peeked == token::OROR &&\n+            lhs\n+        } else if peeked == token::OROR &&\n             self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP {\n-            return lhs;\n-        }\n-        let cur_opt   = token_to_binop(peeked);\n-        match cur_opt {\n-          Some(cur_op) => {\n-            let cur_prec = operator_prec(cur_op);\n-            if cur_prec > min_prec {\n-                self.bump();\n-                let expr = self.parse_prefix_expr();\n-                let rhs = self.parse_more_binops(expr, cur_prec);\n-                self.get_id(); // see ast_util::op_expr_callee_id\n-                let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n-                                        expr_binary(cur_op, lhs, rhs));\n-                return self.parse_more_binops(bin, min_prec);\n+            lhs\n+        } else {\n+            let cur_opt = token_to_binop(peeked);\n+            match cur_opt {\n+                Some(cur_op) => {\n+                    let cur_prec = operator_prec(cur_op);\n+                    if cur_prec > min_prec {\n+                        self.bump();\n+                        let expr = self.parse_prefix_expr();\n+                        let rhs = self.parse_more_binops(expr, cur_prec);\n+                        self.get_id(); // see ast_util::op_expr_callee_id\n+                        let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                                               expr_binary(cur_op, lhs, rhs));\n+                        self.parse_more_binops(bin, min_prec)\n+                    } else {\n+                        lhs\n+                    }\n+                }\n+                None => {\n+                    if as_prec > min_prec && self.eat_keyword(~\"as\") {\n+                        let rhs = self.parse_ty(true);\n+                        let _as = self.mk_expr(lhs.span.lo,\n+                                               rhs.span.hi,\n+                                               expr_cast(lhs, rhs));\n+                        self.parse_more_binops(_as, min_prec)\n+                    } else {\n+                        lhs\n+                    }\n+                }\n             }\n-          }\n-          _ => ()\n-        }\n-        if as_prec > min_prec && self.eat_keyword(~\"as\") {\n-            let rhs = self.parse_ty(true);\n-            let _as =\n-                self.mk_expr(lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n-            return self.parse_more_binops(_as, min_prec);\n         }\n-        return lhs;\n     }\n \n-    // parse an arbitrary expression.\n+    // parse an assignment expression....\n+    // actually, this seems to be the main entry point for\n+    // parsing an arbitrary expression.\n     fn parse_assign_expr() -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match copy self.token {\n-          token::EQ => {\n-            self.bump();\n-            let rhs = self.parse_expr();\n-            return self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs));\n+            token::EQ => {\n+                self.bump();\n+                let rhs = self.parse_expr();\n+                self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs)) \n           }\n           token::BINOPEQ(op) => {\n-            self.bump();\n-            let rhs = self.parse_expr();\n-            let mut aop;\n-            match op {\n-              token::PLUS => aop = add,\n-              token::MINUS => aop = subtract,\n-              token::STAR => aop = mul,\n-              token::SLASH => aop = div,\n-              token::PERCENT => aop = rem,\n-              token::CARET => aop = bitxor,\n-              token::AND => aop = bitand,\n-              token::OR => aop = bitor,\n-              token::SHL => aop = shl,\n-              token::SHR => aop = shr\n-            }\n-            self.get_id(); // see ast_util::op_expr_callee_id\n-            return self.mk_expr(lo, rhs.span.hi,\n-                                expr_assign_op(aop, lhs, rhs));\n+              self.bump();\n+              let rhs = self.parse_expr();\n+              let mut aop;\n+              match op {\n+                  token::PLUS => aop = add,\n+                  token::MINUS => aop = subtract,\n+                  token::STAR => aop = mul,\n+                  token::SLASH => aop = div,\n+                  token::PERCENT => aop = rem,\n+                  token::CARET => aop = bitxor,\n+                  token::AND => aop = bitand,\n+                  token::OR => aop = bitor,\n+                  token::SHL => aop = shl,\n+                  token::SHR => aop = shr\n+              }\n+              self.get_id(); // see ast_util::op_expr_callee_id\n+              self.mk_expr(lo, rhs.span.hi,\n+                           expr_assign_op(aop, lhs, rhs))\n           }\n           token::LARROW => {\n               self.obsolete(copy self.span, ObsoleteBinaryMove);\n               // Bogus value (but it's an error)\n               self.bump(); // <-\n               self.bump(); // rhs\n               self.bump(); // ;\n-              return self.mk_expr(lo, self.span.hi,\n-                                  expr_break(None));\n+              self.mk_expr(lo, self.span.hi,\n+                           expr_break(None))\n           }\n           token::DARROW => {\n             self.bump();\n             let rhs = self.parse_expr();\n-            return self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs));\n+            self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs))\n+          }\n+          _ => {\n+              lhs\n           }\n-          _ => {/* fall through */ }\n         }\n-        return lhs;\n     }\n \n     fn parse_if_expr() -> @expr {\n@@ -1560,7 +1569,7 @@ pub impl Parser {\n             hi = elexpr.span.hi;\n         }\n         let q = {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n-        return self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n+        f.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els))\n     }\n \n     fn parse_fn_expr(proto: Proto) -> @expr {\n@@ -1571,8 +1580,9 @@ pub impl Parser {\n         let decl = self.parse_fn_decl(|p| p.parse_arg_or_capture_item());\n \n         let body = self.parse_block();\n-        return self.mk_expr(lo, body.span.hi,\n-                            expr_fn(proto, decl, body, @()));\n+\n+        self.mk_expr(lo, body.span.hi,\n+                            expr_fn(proto, decl, body, capture_clause));\n     }\n \n     // `|args| { ... }` like in `do` expressions"}]}