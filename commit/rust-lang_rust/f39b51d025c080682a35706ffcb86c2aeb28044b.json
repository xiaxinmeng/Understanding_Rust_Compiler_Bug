{"sha": "f39b51d025c080682a35706ffcb86c2aeb28044b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOWI1MWQwMjVjMDgwNjgyYTM1NzA2ZmZjYjg2YzJhZWIyODA0NGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-01T17:29:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-01T17:29:09Z"}, "message": "Merge #3809\n\n3809: Less config r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e7304aecbf57fbcbf5cc31bcc29d7b0df729786f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7304aecbf57fbcbf5cc31bcc29d7b0df729786f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f39b51d025c080682a35706ffcb86c2aeb28044b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehM9lCRBK7hj4Ov3rIwAAdHIIACOSLW7hkAjpxsXEjB/KjRSD\n8jKUOzDzDZzzDTEtvN3vquGZDioaavRavnjLdLkQUoyxdyKHT2vZTQPVd8GY6JgQ\nL7K9hiKv0CAEbluP0SLJ2rN28WkSoefWNtJSI9p6xIyIKSV8TJ5SeMRY6ZIrNil/\nkZgoRbiFJGU5jXZOfuQ6tYvu7PwOS9D20iI6CbyPYeVxoKv9mGQgFIiKgTPPtgEw\nV9pfLN0G9NV7/AM3z+PxleIOUGIE/OTW+vy/Sw/Lr8rBwy0OvPf4evlN6jaQWcAh\n+YF8SKZjoDemvahc69RdJwVZFYfO+3aJB30/KdrcC+YrXYUcjCghPd1kyBzYilg=\n=9z/e\n-----END PGP SIGNATURE-----\n", "payload": "tree e7304aecbf57fbcbf5cc31bcc29d7b0df729786f\nparent aaf100fcab2ef6fb398547330bd5dfb068b5c90f\nparent 1225f719fe920587ebbe4170fc5aee1d87eadc22\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585762149 +0000\ncommitter GitHub <noreply@github.com> 1585762149 +0000\n\nMerge #3809\n\n3809: Less config r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f39b51d025c080682a35706ffcb86c2aeb28044b", "html_url": "https://github.com/rust-lang/rust/commit/f39b51d025c080682a35706ffcb86c2aeb28044b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f39b51d025c080682a35706ffcb86c2aeb28044b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaf100fcab2ef6fb398547330bd5dfb068b5c90f", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf100fcab2ef6fb398547330bd5dfb068b5c90f", "html_url": "https://github.com/rust-lang/rust/commit/aaf100fcab2ef6fb398547330bd5dfb068b5c90f"}, {"sha": "1225f719fe920587ebbe4170fc5aee1d87eadc22", "url": "https://api.github.com/repos/rust-lang/rust/commits/1225f719fe920587ebbe4170fc5aee1d87eadc22", "html_url": "https://github.com/rust-lang/rust/commit/1225f719fe920587ebbe4170fc5aee1d87eadc22"}], "stats": {"total": 570, "additions": 196, "deletions": 374}, "files": [{"sha": "b54a30ab85f87e912ff5ab7f2a3887981a71b683", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -22,7 +22,7 @@ use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n pub use crate::conv::url_from_path_with_drive_lowercasing;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand { command: String, all_targets: bool, extra_args: Vec<String> },\n     CustomCommand { command: String, args: Vec<String> },"}, {"sha": "c1b6e1ddc382a0db2e84778625a15e09a91e8736", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -13,7 +13,6 @@ use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId}\n use ra_arena::{Arena, Idx};\n use ra_db::Edition;\n use rustc_hash::FxHashMap;\n-use serde::Deserialize;\n \n /// `CargoWorkspace` represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n@@ -43,9 +42,8 @@ impl ops::Index<Target> for CargoWorkspace {\n     }\n }\n \n-#[derive(Deserialize, Clone, Debug, PartialEq, Eq)]\n-#[serde(rename_all = \"camelCase\", default)]\n-pub struct CargoFeatures {\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct CargoConfig {\n     /// Do not activate the `default` feature.\n     pub no_default_features: bool,\n \n@@ -60,9 +58,9 @@ pub struct CargoFeatures {\n     pub load_out_dirs_from_check: bool,\n }\n \n-impl Default for CargoFeatures {\n+impl Default for CargoConfig {\n     fn default() -> Self {\n-        CargoFeatures {\n+        CargoConfig {\n             no_default_features: false,\n             all_features: true,\n             features: Vec::new(),\n@@ -141,7 +139,7 @@ impl PackageData {\n impl CargoWorkspace {\n     pub fn from_cargo_metadata(\n         cargo_toml: &Path,\n-        cargo_features: &CargoFeatures,\n+        cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n         meta.manifest_path(cargo_toml);\n@@ -275,7 +273,7 @@ pub struct ExternResources {\n \n pub fn load_extern_resources(\n     cargo_toml: &Path,\n-    cargo_features: &CargoFeatures,\n+    cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n     let mut cmd = Command::new(cargo_binary());\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n@@ -293,9 +291,8 @@ pub fn load_extern_resources(\n \n     let mut res = ExternResources::default();\n \n-    let stdout = String::from_utf8(output.stdout)?;\n-    for line in stdout.lines() {\n-        if let Ok(message) = serde_json::from_str::<cargo_metadata::Message>(&line) {\n+    for message in cargo_metadata::parse_messages(output.stdout.as_slice()) {\n+        if let Ok(message) = message {\n             match message {\n                 Message::BuildScriptExecuted(BuildScript { package_id, out_dir, .. }) => {\n                     res.out_dirs.insert(package_id, out_dir);"}, {"sha": "dd9c80691f3de78016456d5cc038fbbade75cb36", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -19,7 +19,7 @@ use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n pub use crate::{\n-    cargo_workspace::{CargoFeatures, CargoWorkspace, Package, Target, TargetKind},\n+    cargo_workspace::{CargoConfig, CargoWorkspace, Package, Target, TargetKind},\n     json_project::JsonProject,\n     sysroot::Sysroot,\n };\n@@ -78,14 +78,14 @@ impl PackageRoot {\n }\n \n impl ProjectWorkspace {\n-    pub fn discover(path: &Path, cargo_features: &CargoFeatures) -> Result<ProjectWorkspace> {\n+    pub fn discover(path: &Path, cargo_features: &CargoConfig) -> Result<ProjectWorkspace> {\n         ProjectWorkspace::discover_with_sysroot(path, true, cargo_features)\n     }\n \n     pub fn discover_with_sysroot(\n         path: &Path,\n         with_sysroot: bool,\n-        cargo_features: &CargoFeatures,\n+        cargo_features: &CargoConfig,\n     ) -> Result<ProjectWorkspace> {\n         match find_rust_project_json(path) {\n             Some(json_path) => {"}, {"sha": "608f4f67b2c8cbb7ecf6ad4c310cd2bfb26626cc", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -4,8 +4,7 @@\n mod args;\n \n use lsp_server::Connection;\n-\n-use rust_analyzer::{cli, from_json, show_message, Result, ServerConfig};\n+use rust_analyzer::{cli, config::Config, from_json, Result};\n \n use crate::args::HelpPrinted;\n \n@@ -78,24 +77,18 @@ fn run_server() -> Result<()> {\n         .filter(|workspaces| !workspaces.is_empty())\n         .unwrap_or_else(|| vec![root]);\n \n-    let server_config = initialize_params\n-        .initialization_options\n-        .and_then(|v| {\n-            from_json::<ServerConfig>(\"config\", v)\n-                .map_err(|e| {\n-                    log::error!(\"{}\", e);\n-                    show_message(lsp_types::MessageType::Error, e.to_string(), &connection.sender);\n-                })\n-                .ok()\n-        })\n-        .unwrap_or_default();\n+    let config = {\n+        let mut config = Config::default();\n+        if let Some(value) = &initialize_params.initialization_options {\n+            config.update(value);\n+        }\n+        if let Some(caps) = &initialize_params.capabilities.text_document {\n+            config.update_caps(caps);\n+        }\n+        config\n+    };\n \n-    rust_analyzer::main_loop(\n-        workspace_roots,\n-        initialize_params.capabilities,\n-        server_config,\n-        connection,\n-    )?;\n+    rust_analyzer::main_loop(workspace_roots, config, connection)?;\n \n     log::info!(\"shutting down IO...\");\n     io_threads.join()?;"}, {"sha": "2c0bde920bef68d5c74e09103aa73e022c7da912", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -8,7 +8,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{\n-    get_rustc_cfg_options, CargoFeatures, PackageRoot, ProcMacroClient, ProjectWorkspace,\n+    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectWorkspace,\n };\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -29,7 +29,7 @@ pub(crate) fn load_cargo(\n     let root = std::env::current_dir()?.join(root);\n     let ws = ProjectWorkspace::discover(\n         root.as_ref(),\n-        &CargoFeatures { load_out_dirs_from_check, ..Default::default() },\n+        &CargoConfig { load_out_dirs_from_check, ..Default::default() },\n     )?;\n \n     let mut extern_dirs = FxHashSet::default();"}, {"sha": "3c8f55f1e490befd9ac8c005d2618feb0749ec23", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 118, "deletions": 134, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -7,24 +7,36 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use rustc_hash::FxHashMap;\n-\n use lsp_types::TextDocumentClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n-use ra_ide::InlayHintsConfig;\n-use ra_project_model::CargoFeatures;\n-use serde::{Deserialize, Deserializer};\n+use ra_ide::{CompletionConfig, InlayHintsConfig};\n+use ra_project_model::CargoConfig;\n+use serde::Deserialize;\n \n #[derive(Debug, Clone)]\n pub struct Config {\n+    pub client_caps: ClientCapsConfig,\n     pub publish_decorations: bool,\n-    pub supports_location_link: bool,\n-    pub line_folding_only: bool,\n+    pub publish_diagnostics: bool,\n+    pub notifications: NotificationsConfig,\n     pub inlay_hints: InlayHintsConfig,\n+    pub completion: CompletionConfig,\n+    pub call_info_full: bool,\n     pub rustfmt: RustfmtConfig,\n     pub check: Option<FlycheckConfig>,\n     pub vscode_lldb: bool,\n     pub proc_macro_srv: Option<String>,\n+    pub lru_capacity: Option<usize>,\n+    pub use_client_watching: bool,\n+    pub exclude_globs: Vec<String>,\n+    pub cargo: CargoConfig,\n+    pub with_sysroot: bool,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct NotificationsConfig {\n+    pub workspace_loaded: bool,\n+    pub cargo_toml_not_found: bool,\n }\n \n #[derive(Debug, Clone)]\n@@ -39,148 +51,120 @@ pub enum RustfmtConfig {\n     },\n }\n \n-impl Default for RustfmtConfig {\n-    fn default() -> Self {\n-        RustfmtConfig::Rustfmt { extra_args: Vec::new() }\n-    }\n+#[derive(Debug, Clone, Default)]\n+pub struct ClientCapsConfig {\n+    pub location_link: bool,\n+    pub line_folding_only: bool,\n }\n \n-pub(crate) fn get_config(\n-    config: &ServerConfig,\n-    text_document_caps: Option<&TextDocumentClientCapabilities>,\n-) -> Config {\n-    Config {\n-        publish_decorations: config.publish_decorations,\n-        supports_location_link: text_document_caps\n-            .and_then(|it| it.definition)\n-            .and_then(|it| it.link_support)\n-            .unwrap_or(false),\n-        line_folding_only: text_document_caps\n-            .and_then(|it| it.folding_range.as_ref())\n-            .and_then(|it| it.line_folding_only)\n-            .unwrap_or(false),\n-        inlay_hints: InlayHintsConfig {\n-            type_hints: config.inlay_hints_type,\n-            parameter_hints: config.inlay_hints_parameter,\n-            chaining_hints: config.inlay_hints_chaining,\n-            max_length: config.inlay_hints_max_length,\n-        },\n-        check: if config.cargo_watch_enable {\n-            Some(FlycheckConfig::CargoCommand {\n-                command: config.cargo_watch_command.clone(),\n-                all_targets: config.cargo_watch_all_targets,\n-                extra_args: config.cargo_watch_args.clone(),\n-            })\n-        } else {\n-            None\n-        },\n-        rustfmt: RustfmtConfig::Rustfmt { extra_args: config.rustfmt_args.clone() },\n-        vscode_lldb: config.vscode_lldb,\n-        proc_macro_srv: None, // FIXME: get this from config\n+impl Default for Config {\n+    fn default() -> Self {\n+        Config {\n+            publish_decorations: false,\n+            publish_diagnostics: true,\n+            notifications: NotificationsConfig {\n+                workspace_loaded: true,\n+                cargo_toml_not_found: true,\n+            },\n+            client_caps: ClientCapsConfig::default(),\n+            inlay_hints: InlayHintsConfig {\n+                type_hints: true,\n+                parameter_hints: true,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n+            completion: CompletionConfig {\n+                enable_postfix_completions: true,\n+                add_call_parenthesis: true,\n+                add_call_argument_snippets: true,\n+            },\n+            call_info_full: true,\n+            rustfmt: RustfmtConfig::Rustfmt { extra_args: Vec::new() },\n+            check: Some(FlycheckConfig::CargoCommand {\n+                command: \"check\".to_string(),\n+                all_targets: true,\n+                extra_args: Vec::new(),\n+            }),\n+            vscode_lldb: false,\n+            proc_macro_srv: None,\n+            lru_capacity: None,\n+            use_client_watching: false,\n+            exclude_globs: Vec::new(),\n+            cargo: CargoConfig::default(),\n+            with_sysroot: true,\n+        }\n     }\n }\n \n-/// Client provided initialization options\n-#[derive(Deserialize, Clone, Debug, PartialEq, Eq)]\n-#[serde(rename_all = \"camelCase\", default)]\n-pub struct ServerConfig {\n-    /// Whether the client supports our custom highlighting publishing decorations.\n-    /// This is different to the highlightingOn setting, which is whether the user\n-    /// wants our custom highlighting to be used.\n-    ///\n-    /// Defaults to `false`\n-    #[serde(deserialize_with = \"nullable_bool_false\")]\n-    pub publish_decorations: bool,\n+impl Config {\n+    #[rustfmt::skip]\n+    pub fn update(&mut self, value: &serde_json::Value) {\n+        log::info!(\"Config::update({:#})\", value);\n \n-    pub exclude_globs: Vec<String>,\n-    #[serde(deserialize_with = \"nullable_bool_false\")]\n-    pub use_client_watching: bool,\n+        let client_caps = self.client_caps.clone();\n+        *self = Default::default();\n+        self.client_caps = client_caps;\n \n-    pub lru_capacity: Option<usize>,\n+        set(value, \"/publishDecorations\", &mut self.publish_decorations);\n+        set(value, \"/excludeGlobs\", &mut self.exclude_globs);\n+        set(value, \"/useClientWatching\", &mut self.use_client_watching);\n+        set(value, \"/lruCapacity\", &mut self.lru_capacity);\n \n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub inlay_hints_type: bool,\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub inlay_hints_parameter: bool,\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub inlay_hints_chaining: bool,\n-    pub inlay_hints_max_length: Option<usize>,\n-\n-    pub cargo_watch_enable: bool,\n-    pub cargo_watch_args: Vec<String>,\n-    pub cargo_watch_command: String,\n-    pub cargo_watch_all_targets: bool,\n-\n-    /// For internal usage to make integrated tests faster.\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub with_sysroot: bool,\n+        set(value, \"/inlayHintsType\", &mut self.inlay_hints.type_hints);\n+        set(value, \"/inlayHintsParameter\", &mut self.inlay_hints.parameter_hints);\n+        set(value, \"/inlayHintsChaining\", &mut self.inlay_hints.chaining_hints);\n+        set(value, \"/inlayHintsMaxLength\", &mut self.inlay_hints.max_length);\n \n-    /// Fine grained feature flags to disable specific features.\n-    pub feature_flags: FxHashMap<String, bool>,\n+        if let Some(false) = get(value, \"cargo_watch_enable\") {\n+            self.check = None\n+        } else {\n+            if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets }) = &mut self.check\n+            {\n+                set(value, \"/cargoWatchArgs\", extra_args);\n+                set(value, \"/cargoWatchCommand\", command);\n+                set(value, \"/cargoWatchAllTargets\", all_targets);\n+            }\n+        };\n+\n+        set(value, \"/withSysroot\", &mut self.with_sysroot);\n+        if let RustfmtConfig::Rustfmt { extra_args } = &mut self.rustfmt {\n+            set(value, \"/rustfmtArgs\", extra_args);\n+        }\n \n-    pub rustfmt_args: Vec<String>,\n+        set(value, \"/cargoFeatures/noDefaultFeatures\", &mut self.cargo.no_default_features);\n+        set(value, \"/cargoFeatures/allFeatures\", &mut self.cargo.all_features);\n+        set(value, \"/cargoFeatures/features\", &mut self.cargo.features);\n+        set(value, \"/cargoFeatures/loadOutDirsFromCheck\", &mut self.cargo.load_out_dirs_from_check);\n \n-    /// Cargo feature configurations.\n-    pub cargo_features: CargoFeatures,\n+        set(value, \"/vscodeLldb\", &mut self.vscode_lldb);\n \n-    /// Enabled if the vscode_lldb extension is available.\n-    pub vscode_lldb: bool,\n-}\n+        set(value, \"/featureFlags/lsp.diagnostics\", &mut self.publish_diagnostics);\n+        set(value, \"/featureFlags/notifications.workspace-loaded\", &mut self.notifications.workspace_loaded);\n+        set(value, \"/featureFlags/notifications.cargo-toml-not-found\", &mut self.notifications.cargo_toml_not_found);\n+        set(value, \"/featureFlags/completion.enable-postfix\", &mut self.completion.enable_postfix_completions);\n+        set(value, \"/featureFlags/completion.insertion.add-call-parenthesis\", &mut self.completion.add_call_parenthesis);\n+        set(value, \"/featureFlags/completion.insertion.add-argument-snippets\", &mut self.completion.add_call_argument_snippets);\n+        set(value, \"/featureFlags/call-info.full\", &mut self.call_info_full);\n \n-impl Default for ServerConfig {\n-    fn default() -> ServerConfig {\n-        ServerConfig {\n-            publish_decorations: false,\n-            exclude_globs: Vec::new(),\n-            use_client_watching: false,\n-            lru_capacity: None,\n-            inlay_hints_type: true,\n-            inlay_hints_parameter: true,\n-            inlay_hints_chaining: true,\n-            inlay_hints_max_length: None,\n-            cargo_watch_enable: true,\n-            cargo_watch_args: Vec::new(),\n-            cargo_watch_command: \"check\".to_string(),\n-            cargo_watch_all_targets: true,\n-            with_sysroot: true,\n-            feature_flags: FxHashMap::default(),\n-            cargo_features: Default::default(),\n-            rustfmt_args: Vec::new(),\n-            vscode_lldb: false,\n-        }\n-    }\n-}\n+        log::info!(\"Config::update() = {:#?}\", self);\n \n-/// Deserializes a null value to a bool false by default\n-fn nullable_bool_false<'de, D>(deserializer: D) -> Result<bool, D::Error>\n-where\n-    D: Deserializer<'de>,\n-{\n-    let opt = Option::deserialize(deserializer)?;\n-    Ok(opt.unwrap_or(false))\n-}\n+        fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n+            value.pointer(pointer).and_then(|it| T::deserialize(it).ok())\n+        }\n \n-/// Deserializes a null value to a bool true by default\n-fn nullable_bool_true<'de, D>(deserializer: D) -> Result<bool, D::Error>\n-where\n-    D: Deserializer<'de>,\n-{\n-    let opt = Option::deserialize(deserializer)?;\n-    Ok(opt.unwrap_or(true))\n-}\n+        fn set<'a, T: Deserialize<'a> + std::fmt::Debug>(value: &'a serde_json::Value, pointer: &str, slot: &mut T) {\n+            if let Some(new_value) = get(value, pointer) {\n+                *slot = new_value\n+            }\n+        }\n+    }\n \n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn deserialize_init_options_defaults() {\n-        // check that null == default for both fields\n-        let default = ServerConfig::default();\n-        assert_eq!(default, serde_json::from_str(r#\"{}\"#).unwrap());\n-        assert_eq!(\n-            default,\n-            serde_json::from_str(r#\"{\"publishDecorations\":null, \"lruCapacity\":null}\"#).unwrap()\n-        );\n+    pub fn update_caps(&mut self, caps: &TextDocumentClientCapabilities) {\n+        if let Some(value) = caps.definition.as_ref().and_then(|it| it.link_support) {\n+            self.client_caps.location_link = value;\n+        }\n+        if let Some(value) = caps.folding_range.as_ref().and_then(|it| it.line_folding_only) {\n+            self.client_caps.line_folding_only = value\n+        }\n     }\n }"}, {"sha": "57c4c8ce55c87f9bdf21b56265ab073bbf1075da", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -579,7 +579,7 @@ impl TryConvWith<&WorldSnapshot> for (FileId, RangeInfo<Vec<NavigationTarget>>)\n             .into_iter()\n             .map(|nav| (file_id, RangeInfo::new(range, nav)))\n             .try_conv_with_to_vec(world)?;\n-        if world.config.supports_location_link {\n+        if world.config.client_caps.location_link {\n             Ok(links.into())\n         } else {\n             let locations: Vec<Location> = links"}, {"sha": "dbb3f50a0956be9cc3f4d2bbf5c746c1a6cd6455", "filename": "crates/rust-analyzer/src/feature_flags.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/aaf100fcab2ef6fb398547330bd5dfb068b5c90f/crates%2Frust-analyzer%2Fsrc%2Ffeature_flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf100fcab2ef6fb398547330bd5dfb068b5c90f/crates%2Frust-analyzer%2Fsrc%2Ffeature_flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffeature_flags.rs?ref=aaf100fcab2ef6fb398547330bd5dfb068b5c90f", "patch": "@@ -1,77 +0,0 @@\n-//! See docs for `FeatureFlags`.\n-\n-use rustc_hash::FxHashMap;\n-\n-// FIXME: looks like a much better design is to pass options to each call,\n-// rather than to have a global ambient feature flags -- that way, the clients\n-// can issue two successive calls with different options.\n-\n-/// Feature flags hold fine-grained toggles for all *user-visible* features of\n-/// rust-analyzer.\n-///\n-/// The exists such that users are able to disable any annoying feature (and,\n-/// with many users and many features,  some features are bound to be annoying\n-/// for some users)\n-///\n-/// Note that we purposefully use run-time checked strings, and not something\n-/// checked at compile time, to keep things simple and flexible.\n-///\n-/// Also note that, at the moment, `FeatureFlags` also store features for\n-/// `rust-analyzer`. This should be benign layering violation.\n-#[derive(Debug)]\n-pub struct FeatureFlags {\n-    flags: FxHashMap<String, bool>,\n-}\n-\n-impl FeatureFlags {\n-    fn new(flags: &[(&str, bool)]) -> FeatureFlags {\n-        let flags = flags\n-            .iter()\n-            .map(|&(name, value)| {\n-                check_flag_name(name);\n-                (name.to_string(), value)\n-            })\n-            .collect();\n-        FeatureFlags { flags }\n-    }\n-\n-    pub fn set(&mut self, flag: &str, value: bool) -> Result<(), ()> {\n-        match self.flags.get_mut(flag) {\n-            None => Err(()),\n-            Some(slot) => {\n-                *slot = value;\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    pub fn get(&self, flag: &str) -> bool {\n-        match self.flags.get(flag) {\n-            None => panic!(\"unknown flag: {:?}\", flag),\n-            Some(value) => *value,\n-        }\n-    }\n-}\n-\n-impl Default for FeatureFlags {\n-    fn default() -> FeatureFlags {\n-        FeatureFlags::new(&[\n-            (\"lsp.diagnostics\", true),\n-            (\"completion.insertion.add-call-parenthesis\", true),\n-            (\"completion.insertion.add-argument-snippets\", true),\n-            (\"completion.enable-postfix\", true),\n-            (\"call-info.full\", true),\n-            (\"notifications.workspace-loaded\", true),\n-            (\"notifications.cargo-toml-not-found\", true),\n-        ])\n-    }\n-}\n-\n-fn check_flag_name(flag: &str) {\n-    for c in flag.bytes() {\n-        match c {\n-            b'a'..=b'z' | b'-' | b'.' => (),\n-            _ => panic!(\"flag name does not match conventions: {:?}\", flag),\n-        }\n-    }\n-}"}, {"sha": "02953be303910c1798d392bdfdfcb5ad23f49639", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -33,18 +33,16 @@ mod conv;\n mod main_loop;\n mod markdown;\n pub mod req;\n-mod config;\n+pub mod config;\n mod world;\n mod diagnostics;\n mod semantic_tokens;\n-mod feature_flags;\n \n use serde::de::DeserializeOwned;\n \n pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;\n pub use crate::{\n     caps::server_capabilities,\n-    config::ServerConfig,\n     main_loop::LspError,\n     main_loop::{main_loop, show_message},\n };"}, {"sha": "45ae0ad9d17078874cf4ffdeecc4bc4c752bfe1b", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 19, "deletions": 60, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -17,9 +17,8 @@ use std::{\n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n-    ClientCapabilities, NumberOrString, TextDocumentClientCapabilities, WorkDoneProgress,\n-    WorkDoneProgressBegin, WorkDoneProgressCreateParams, WorkDoneProgressEnd,\n-    WorkDoneProgressReport,\n+    NumberOrString, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressCreateParams,\n+    WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n use ra_flycheck::{url_from_path_with_drive_lowercasing, CheckTask};\n use ra_ide::{Canceled, FileId, LibraryData, SourceRootId};\n@@ -31,16 +30,15 @@ use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n-    config::get_config,\n+    config::Config,\n     diagnostics::DiagnosticTask,\n-    feature_flags::FeatureFlags,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n     req,\n     world::{WorldSnapshot, WorldState},\n-    Result, ServerConfig,\n+    Result,\n };\n use req::ConfigurationParams;\n \n@@ -66,29 +64,8 @@ impl fmt::Display for LspError {\n \n impl Error for LspError {}\n \n-fn get_feature_flags(config: &ServerConfig, connection: &Connection) -> FeatureFlags {\n-    let mut ff = FeatureFlags::default();\n-    for (flag, &value) in &config.feature_flags {\n-        if ff.set(flag.as_str(), value).is_err() {\n-            log::error!(\"unknown feature flag: {:?}\", flag);\n-            show_message(\n-                req::MessageType::Error,\n-                format!(\"unknown feature flag: {:?}\", flag),\n-                &connection.sender,\n-            );\n-        }\n-    }\n-    log::info!(\"feature_flags: {:#?}\", ff);\n-    ff\n-}\n-\n-pub fn main_loop(\n-    ws_roots: Vec<PathBuf>,\n-    client_caps: ClientCapabilities,\n-    config: ServerConfig,\n-    connection: Connection,\n-) -> Result<()> {\n-    log::info!(\"server_config: {:#?}\", config);\n+pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection) -> Result<()> {\n+    log::info!(\"initial config: {:#?}\", config);\n \n     // Windows scheduler implements priority boosts: if thread waits for an\n     // event (like a condvar), and event fires, priority of the thread is\n@@ -109,19 +86,16 @@ pub fn main_loop(\n         SetThreadPriority(thread, thread_priority_above_normal);\n     }\n \n-    let text_document_caps = client_caps.text_document.as_ref();\n     let mut loop_state = LoopState::default();\n     let mut world_state = {\n-        let feature_flags = get_feature_flags(&config, &connection);\n-\n         // FIXME: support dynamic workspace loading.\n         let workspaces = {\n             let mut loaded_workspaces = Vec::new();\n             for ws_root in &ws_roots {\n                 let workspace = ra_project_model::ProjectWorkspace::discover_with_sysroot(\n                     ws_root.as_path(),\n                     config.with_sysroot,\n-                    &config.cargo_features,\n+                    &config.cargo,\n                 );\n                 match workspace {\n                     Ok(workspace) => loaded_workspaces.push(workspace),\n@@ -131,7 +105,7 @@ pub fn main_loop(\n                         if let Some(ra_project_model::CargoTomlNotFoundError { .. }) =\n                             e.downcast_ref()\n                         {\n-                            if !feature_flags.get(\"notifications.cargo-toml-not-found\") {\n+                            if !config.notifications.cargo_toml_not_found {\n                                 continue;\n                             }\n                         }\n@@ -180,8 +154,7 @@ pub fn main_loop(\n             config.lru_capacity,\n             &globs,\n             Watch(!config.use_client_watching),\n-            get_config(&config, text_document_caps),\n-            feature_flags,\n+            config,\n         )\n     };\n \n@@ -224,7 +197,6 @@ pub fn main_loop(\n                 &task_sender,\n                 &libdata_sender,\n                 &connection,\n-                text_document_caps,\n                 &mut world_state,\n                 &mut loop_state,\n                 event,\n@@ -335,7 +307,6 @@ fn loop_turn(\n     task_sender: &Sender<Task>,\n     libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    text_document_caps: Option<&TextDocumentClientCapabilities>,\n     world_state: &mut WorldState,\n     loop_state: &mut LoopState,\n     event: Event,\n@@ -389,28 +360,16 @@ fn loop_turn(\n                     log::debug!(\"config update response: '{:?}\", resp);\n                     let Response { error, result, .. } = resp;\n \n-                    match (\n-                        error,\n-                        result.map(|result| serde_json::from_value::<Vec<ServerConfig>>(result)),\n-                    ) {\n+                    match (error, result) {\n                         (Some(err), _) => {\n                             log::error!(\"failed to fetch the server settings: {:?}\", err)\n                         }\n-                        (None, Some(Ok(new_config))) => {\n-                            let new_config = new_config\n-                                .first()\n-                                .expect(\n-                                    \"the client is expected to always send a non-empty config data\",\n-                                )\n-                                .to_owned();\n-                            world_state.update_configuration(\n-                                new_config.lru_capacity,\n-                                get_config(&new_config, text_document_caps),\n-                                get_feature_flags(&new_config, connection),\n-                            );\n-                        }\n-                        (None, Some(Err(e))) => {\n-                            log::error!(\"failed to parse client config response: {}\", e)\n+                        (None, Some(configs)) => {\n+                            if let Some(new_config) = configs.get(0) {\n+                                let mut config = world_state.config.clone();\n+                                config.update(&new_config);\n+                                world_state.update_configuration(config);\n+                            }\n                         }\n                         (None, None) => {\n                             log::error!(\"received empty server settings response from the client\")\n@@ -441,8 +400,8 @@ fn loop_turn(\n         });\n     }\n \n-    let show_progress = !loop_state.workspace_loaded\n-        && world_state.feature_flags.get(\"notifications.workspace-loaded\");\n+    let show_progress =\n+        !loop_state.workspace_loaded && world_state.config.notifications.workspace_loaded;\n \n     if !loop_state.workspace_loaded\n         && loop_state.roots_scanned == loop_state.roots_total\n@@ -930,7 +889,7 @@ fn update_file_notifications_on_threadpool(\n     subscriptions: Vec<FileId>,\n ) {\n     log::trace!(\"updating notifications for {:?}\", subscriptions);\n-    let publish_diagnostics = world.feature_flags.get(\"lsp.diagnostics\");\n+    let publish_diagnostics = world.config.publish_diagnostics;\n     pool.execute(move || {\n         for file_id in subscriptions {\n             if publish_diagnostics {"}, {"sha": "23e48c089660f024171a40c9a44a6808d6717370", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -19,8 +19,8 @@ use lsp_types::{\n     TextEdit, WorkspaceEdit,\n };\n use ra_ide::{\n-    Assist, AssistId, CompletionConfig, FileId, FilePosition, FileRange, Query, RangeInfo,\n-    Runnable, RunnableKind, SearchScope,\n+    Assist, AssistId, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind,\n+    SearchScope,\n };\n use ra_prof::profile;\n use ra_syntax::{AstNode, SyntaxKind, TextRange, TextUnit};\n@@ -426,15 +426,7 @@ pub fn handle_completion(\n         return Ok(None);\n     }\n \n-    let config = CompletionConfig {\n-        enable_postfix_completions: world.feature_flags.get(\"completion.enable-postfix\"),\n-        add_call_parenthesis: world.feature_flags.get(\"completion.insertion.add-call-parenthesis\"),\n-        add_call_argument_snippets: world\n-            .feature_flags\n-            .get(\"completion.insertion.add-argument-snippets\"),\n-    };\n-\n-    let items = match world.analysis().completions(position, &config)? {\n+    let items = match world.analysis().completions(position, &world.config.completion)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n@@ -458,7 +450,7 @@ pub fn handle_folding_range(\n     let ctx = FoldConvCtx {\n         text: &text,\n         line_index: &line_index,\n-        line_folding_only: world.config.line_folding_only,\n+        line_folding_only: world.config.client_caps.line_folding_only,\n     };\n     let res = Some(folds.into_iter().map_conv_with(&ctx).collect());\n     Ok(res)\n@@ -471,7 +463,7 @@ pub fn handle_signature_help(\n     let _p = profile(\"handle_signature_help\");\n     let position = params.try_conv_with(&world)?;\n     if let Some(call_info) = world.analysis().call_info(position)? {\n-        let concise = !world.feature_flags.get(\"call-info.full\");\n+        let concise = !world.config.call_info_full;\n         let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n         if concise && call_info.signature.has_self_param {\n             active_parameter = active_parameter.map(|it| it.saturating_sub(1));"}, {"sha": "5674f42ef3f800f3b4f29f0795a12b0133772d4e", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -11,7 +11,7 @@ use std::{\n use crossbeam_channel::{unbounded, Receiver};\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_flycheck::{url_from_path_with_drive_lowercasing, Flycheck};\n+use ra_flycheck::{url_from_path_with_drive_lowercasing, Flycheck, FlycheckConfig};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData, SourceRootId,\n };\n@@ -23,17 +23,14 @@ use stdx::format_to;\n use crate::{\n     config::Config,\n     diagnostics::{CheckFixes, DiagnosticCollection},\n-    feature_flags::FeatureFlags,\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n     vfs_glob::{Glob, RustPackageFilterBuilder},\n     LspError, Result,\n };\n use ra_db::ExternSourceId;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(workspaces: &[ProjectWorkspace], config: &Config) -> Option<Flycheck> {\n-    let check_config = config.check.as_ref()?;\n-\n+fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n     workspaces\n         .iter()\n@@ -43,7 +40,7 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &Config) -> Option<F\n         })\n         .map(|cargo| {\n             let cargo_project_root = cargo.workspace_root().to_path_buf();\n-            Some(Flycheck::new(check_config.clone(), cargo_project_root))\n+            Some(Flycheck::new(config.clone(), cargo_project_root))\n         })\n         .unwrap_or_else(|| {\n             log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n@@ -59,7 +56,6 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &Config) -> Option<F\n #[derive(Debug)]\n pub struct WorldState {\n     pub config: Config,\n-    pub feature_flags: Arc<FeatureFlags>,\n     pub roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n@@ -73,7 +69,6 @@ pub struct WorldState {\n /// An immutable snapshot of the world's state at a point in time.\n pub struct WorldSnapshot {\n     pub config: Config,\n-    pub feature_flags: Arc<FeatureFlags>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n@@ -89,7 +84,6 @@ impl WorldState {\n         exclude_globs: &[Glob],\n         watch: Watch,\n         config: Config,\n-        feature_flags: FeatureFlags,\n     ) -> WorldState {\n         let mut change = AnalysisChange::new();\n \n@@ -191,13 +185,12 @@ impl WorldState {\n             });\n         change.set_crate_graph(crate_graph);\n \n-        let flycheck = create_flycheck(&workspaces, &config);\n+        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n         WorldState {\n             config: config,\n-            feature_flags: Arc::new(feature_flags),\n             roots: folder_roots,\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n@@ -209,15 +202,13 @@ impl WorldState {\n         }\n     }\n \n-    pub fn update_configuration(\n-        &mut self,\n-        lru_capacity: Option<usize>,\n-        config: Config,\n-        feature_flags: FeatureFlags,\n-    ) {\n-        self.feature_flags = Arc::new(feature_flags);\n-        self.analysis_host.update_lru_capacity(lru_capacity);\n-        self.flycheck = create_flycheck(&self.workspaces, &config);\n+    pub fn update_configuration(&mut self, config: Config) {\n+        self.analysis_host.update_lru_capacity(config.lru_capacity);\n+        if config.check != self.config.check {\n+            self.flycheck =\n+                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n+        }\n+\n         self.config = config;\n     }\n \n@@ -275,7 +266,6 @@ impl WorldState {\n     pub fn snapshot(&self) -> WorldSnapshot {\n         WorldSnapshot {\n             config: self.config.clone(),\n-            feature_flags: Arc::clone(&self.feature_flags),\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),"}, {"sha": "63881331123ef2a08a131b4d6b9dc4c50d69ea1c", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -615,7 +615,7 @@ fn main() { message(); }\n \"###,\n     )\n     .with_config(|config| {\n-        config.cargo_features.load_out_dirs_from_check = true;\n+        config.cargo.load_out_dirs_from_check = true;\n     })\n     .server();\n     server.wait_until_workspace_is_loaded();"}, {"sha": "7eebedff7ad49f77679669def92219cbf032ec7a", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39b51d025c080682a35706ffcb86c2aeb28044b/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=f39b51d025c080682a35706ffcb86c2aeb28044b", "patch": "@@ -11,23 +11,25 @@ use lsp_server::{Connection, Message, Notification, Request};\n use lsp_types::{\n     notification::{DidOpenTextDocument, Exit},\n     request::Shutdown,\n-    ClientCapabilities, DidOpenTextDocumentParams, GotoCapability, TextDocumentClientCapabilities,\n-    TextDocumentIdentifier, TextDocumentItem, Url, WorkDoneProgress,\n+    DidOpenTextDocumentParams, TextDocumentIdentifier, TextDocumentItem, Url, WorkDoneProgress,\n };\n use serde::Serialize;\n use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, parse_fixture};\n \n use req::{ProgressParams, ProgressParamsValue};\n-use rust_analyzer::{main_loop, req, ServerConfig};\n+use rust_analyzer::{\n+    config::{ClientCapsConfig, Config},\n+    main_loop, req,\n+};\n \n pub struct Project<'a> {\n     fixture: &'a str,\n     with_sysroot: bool,\n     tmp_dir: Option<TempDir>,\n     roots: Vec<PathBuf>,\n-    config: Option<Box<dyn Fn(&mut ServerConfig)>>,\n+    config: Option<Box<dyn Fn(&mut Config)>>,\n }\n \n impl<'a> Project<'a> {\n@@ -50,7 +52,7 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub fn with_config(mut self, config: impl Fn(&mut ServerConfig) + 'static) -> Project<'a> {\n+    pub fn with_config(mut self, config: impl Fn(&mut Config) + 'static) -> Project<'a> {\n         self.config = Some(Box::new(config));\n         self\n     }\n@@ -78,8 +80,11 @@ impl<'a> Project<'a> {\n \n         let roots = self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect();\n \n-        let mut config =\n-            ServerConfig { with_sysroot: self.with_sysroot, ..ServerConfig::default() };\n+        let mut config = Config {\n+            client_caps: ClientCapsConfig { location_link: true, ..Default::default() },\n+            with_sysroot: self.with_sysroot,\n+            ..Config::default()\n+        };\n \n         if let Some(f) = &self.config {\n             f(&mut config)\n@@ -105,7 +110,7 @@ pub struct Server {\n impl Server {\n     fn new(\n         dir: TempDir,\n-        config: ServerConfig,\n+        config: Config,\n         roots: Vec<PathBuf>,\n         files: Vec<(PathBuf, String)>,\n     ) -> Server {\n@@ -116,26 +121,7 @@ impl Server {\n \n         let _thread = jod_thread::Builder::new()\n             .name(\"test server\".to_string())\n-            .spawn(move || {\n-                main_loop(\n-                    roots,\n-                    ClientCapabilities {\n-                        workspace: None,\n-                        text_document: Some(TextDocumentClientCapabilities {\n-                            definition: Some(GotoCapability {\n-                                dynamic_registration: None,\n-                                link_support: Some(true),\n-                            }),\n-                            ..Default::default()\n-                        }),\n-                        window: None,\n-                        experimental: None,\n-                    },\n-                    config,\n-                    connection,\n-                )\n-                .unwrap()\n-            })\n+            .spawn(move || main_loop(roots, config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");\n \n         let res ="}]}