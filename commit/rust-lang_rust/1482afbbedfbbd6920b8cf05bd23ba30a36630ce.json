{"sha": "1482afbbedfbbd6920b8cf05bd23ba30a36630ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ODJhZmJiZWRmYmJkNjkyMGI4Y2YwNWJkMjNiYTMwYTM2NjMwY2U=", "commit": {"author": {"name": "Fenrir", "email": "fenrirwolf@gmail.com", "date": "2018-01-15T06:07:51Z"}, "committer": {"name": "Fenrir", "email": "fenrirwolf@gmail.com", "date": "2018-01-15T06:09:53Z"}, "message": "Remove leftover Rand stuff", "tree": {"sha": "84b48c1f994b8b3b62e4e46e0ea56bf1adf2be6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b48c1f994b8b3b62e4e46e0ea56bf1adf2be6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1482afbbedfbbd6920b8cf05bd23ba30a36630ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1482afbbedfbbd6920b8cf05bd23ba30a36630ce", "html_url": "https://github.com/rust-lang/rust/commit/1482afbbedfbbd6920b8cf05bd23ba30a36630ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1482afbbedfbbd6920b8cf05bd23ba30a36630ce/comments", "author": {"login": "FenrirWolf", "id": 8870156, "node_id": "MDQ6VXNlcjg4NzAxNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8870156?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FenrirWolf", "html_url": "https://github.com/FenrirWolf", "followers_url": "https://api.github.com/users/FenrirWolf/followers", "following_url": "https://api.github.com/users/FenrirWolf/following{/other_user}", "gists_url": "https://api.github.com/users/FenrirWolf/gists{/gist_id}", "starred_url": "https://api.github.com/users/FenrirWolf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FenrirWolf/subscriptions", "organizations_url": "https://api.github.com/users/FenrirWolf/orgs", "repos_url": "https://api.github.com/users/FenrirWolf/repos", "events_url": "https://api.github.com/users/FenrirWolf/events{/privacy}", "received_events_url": "https://api.github.com/users/FenrirWolf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FenrirWolf", "id": 8870156, "node_id": "MDQ6VXNlcjg4NzAxNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8870156?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FenrirWolf", "html_url": "https://github.com/FenrirWolf", "followers_url": "https://api.github.com/users/FenrirWolf/followers", "following_url": "https://api.github.com/users/FenrirWolf/following{/other_user}", "gists_url": "https://api.github.com/users/FenrirWolf/gists{/gist_id}", "starred_url": "https://api.github.com/users/FenrirWolf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FenrirWolf/subscriptions", "organizations_url": "https://api.github.com/users/FenrirWolf/orgs", "repos_url": "https://api.github.com/users/FenrirWolf/repos", "events_url": "https://api.github.com/users/FenrirWolf/events{/privacy}", "received_events_url": "https://api.github.com/users/FenrirWolf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfba0d446e8ab90f0c81aa0942819d05621c8b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfba0d446e8ab90f0c81aa0942819d05621c8b8e", "html_url": "https://github.com/rust-lang/rust/commit/cfba0d446e8ab90f0c81aa0942819d05621c8b8e"}], "stats": {"total": 108, "additions": 0, "deletions": 108}, "files": [{"sha": "08bc809ed4d4632ac29dc8f5422487ce2dacfa1a", "filename": "src/libstd/rand/reader.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cfba0d446e8ab90f0c81aa0942819d05621c8b8e/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba0d446e8ab90f0c81aa0942819d05621c8b8e/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=cfba0d446e8ab90f0c81aa0942819d05621c8b8e", "patch": "@@ -1,108 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A wrapper around any Read to treat it as an RNG.\n-\n-#![allow(dead_code)]\n-\n-use io::prelude::*;\n-use rand::Rng;\n-\n-/// An RNG that reads random bytes straight from a `Read`. This will\n-/// work best with an infinite reader, but this is not required.\n-///\n-/// # Panics\n-///\n-/// It will panic if it there is insufficient data to fulfill a request.\n-pub struct ReaderRng<R> {\n-    reader: R\n-}\n-\n-impl<R: Read> ReaderRng<R> {\n-    /// Create a new `ReaderRng` from a `Read`.\n-    pub fn new(r: R) -> ReaderRng<R> {\n-        ReaderRng {\n-            reader: r\n-        }\n-    }\n-}\n-\n-impl<R: Read> Rng for ReaderRng<R> {\n-    fn next_u32(&mut self) -> u32 {\n-        // This is designed for speed: reading a LE integer on a LE\n-        // platform just involves blitting the bytes into the memory\n-        // of the u32, similarly for BE on BE; avoiding byteswapping.\n-        let mut bytes = [0; 4];\n-        self.fill_bytes(&mut bytes);\n-        unsafe { *(bytes.as_ptr() as *const u32) }\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        // see above for explanation.\n-        let mut bytes = [0; 8];\n-        self.fill_bytes(&mut bytes);\n-        unsafe { *(bytes.as_ptr() as *const u64) }\n-    }\n-    fn fill_bytes(&mut self, mut v: &mut [u8]) {\n-        while !v.is_empty() {\n-            let t = v;\n-            match self.reader.read(t) {\n-                Ok(0) => panic!(\"ReaderRng.fill_bytes: EOF reached\"),\n-                Ok(n) => v = t.split_at_mut(n).1,\n-                Err(e) => panic!(\"ReaderRng.fill_bytes: {}\", e),\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::ReaderRng;\n-    use rand::Rng;\n-\n-    #[test]\n-    fn test_reader_rng_u64() {\n-        // transmute from the target to avoid endianness concerns.\n-        let v = &[0, 0, 0, 0, 0, 0, 0, 1,\n-                  0, 0, 0, 0, 0, 0, 0, 2,\n-                  0, 0, 0, 0, 0, 0, 0, 3][..];\n-        let mut rng = ReaderRng::new(v);\n-\n-        assert_eq!(rng.next_u64(), 1u64.to_be());\n-        assert_eq!(rng.next_u64(), 2u64.to_be());\n-        assert_eq!(rng.next_u64(), 3u64.to_be());\n-    }\n-    #[test]\n-    fn test_reader_rng_u32() {\n-        let v = &[0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3][..];\n-        let mut rng = ReaderRng::new(v);\n-\n-        assert_eq!(rng.next_u32(), 1u32.to_be());\n-        assert_eq!(rng.next_u32(), 2u32.to_be());\n-        assert_eq!(rng.next_u32(), 3u32.to_be());\n-    }\n-    #[test]\n-    fn test_reader_rng_fill_bytes() {\n-        let v = [1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut w = [0; 8];\n-\n-        let mut rng = ReaderRng::new(&v[..]);\n-        rng.fill_bytes(&mut w);\n-\n-        assert!(v == w);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_reader_rng_insufficient_bytes() {\n-        let mut rng = ReaderRng::new(&[][..]);\n-        let mut v = [0; 3];\n-        rng.fill_bytes(&mut v);\n-    }\n-}"}]}