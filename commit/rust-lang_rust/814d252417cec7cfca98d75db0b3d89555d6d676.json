{"sha": "814d252417cec7cfca98d75db0b3d89555d6d676", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNGQyNTI0MTdjZWM3Y2ZjYTk4ZDc1ZGIwYjNkODk1NTVkNmQ2NzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-20T15:39:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-20T15:39:06Z"}, "message": "Auto merge of #75562 - oli-obk:const_prop_no_aggregates, r=wesleywiser\n\nCheck that we don't use `Rvalue::Aggregate` after the deaggregator\n\nfixes #75481\n\nr? @wesleywiser\n\ncc @RalfJung (modified the validator)", "tree": {"sha": "0c5515d7a7944517862fb78b170df61b7541a797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c5515d7a7944517862fb78b170df61b7541a797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/814d252417cec7cfca98d75db0b3d89555d6d676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/814d252417cec7cfca98d75db0b3d89555d6d676", "html_url": "https://github.com/rust-lang/rust/commit/814d252417cec7cfca98d75db0b3d89555d6d676", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/814d252417cec7cfca98d75db0b3d89555d6d676/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fff3824bc77cd7052e2515f82259e32f8ad1486", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fff3824bc77cd7052e2515f82259e32f8ad1486", "html_url": "https://github.com/rust-lang/rust/commit/5fff3824bc77cd7052e2515f82259e32f8ad1486"}, {"sha": "dcc202723a10612061b3c55cdbad0c2d63f2b712", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc202723a10612061b3c55cdbad0c2d63f2b712", "html_url": "https://github.com/rust-lang/rust/commit/dcc202723a10612061b3c55cdbad0c2d63f2b712"}], "stats": {"total": 357, "additions": 274, "deletions": 83}, "files": [{"sha": "f01c9ae4471d42beb40ec7a2d8c3316951bbe252", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -73,15 +73,35 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n \n /// The various \"big phases\" that MIR goes through.\n ///\n+/// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n+/// dialects forbid certain variants or values in certain phases.\n+///\n+/// Note: Each phase's validation checks all invariants of the *previous* phases' dialects. A phase\n+/// that changes the dialect documents what invariants must be upheld *after* that phase finishes.\n+///\n /// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n     Build = 0,\n+    // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n+    // We used to have this for pre-miri MIR based const eval.\n     Const = 1,\n-    Validated = 2,\n-    DropElab = 3,\n-    Optimized = 4,\n+    /// This phase checks the MIR for promotable elements and takes them out of the main MIR body\n+    /// by creating a new MIR body per promoted element. After this phase (and thus the termination\n+    /// of the `mir_promoted` query), these promoted elements are available in the `promoted_mir`\n+    /// query.\n+    ConstPromotion = 2,\n+    /// After this phase\n+    /// * the only `AggregateKind`s allowed are `Array` and `Generator`,\n+    /// * `DropAndReplace` is gone for good\n+    /// * `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop` terminator\n+    ///   means that the auto-generated drop glue will be invoked.\n+    DropLowering = 3,\n+    /// After this phase, generators are explicit state machines (no more `Yield`).\n+    /// `AggregateKind::Generator` is gone for good.\n+    GeneratorLowering = 4,\n+    Optimization = 5,\n }\n \n impl MirPhase {"}, {"sha": "7a6e4a90683ff00203a3e9480dda1ebd2a168c02", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -247,7 +247,7 @@ rustc_queries! {\n             desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n         }\n \n-        query mir_validated(key: ty::WithOptConstParam<LocalDefId>) ->\n+        query mir_promoted(key: ty::WithOptConstParam<LocalDefId>) ->\n             (\n                 &'tcx Steal<mir::Body<'tcx>>,\n                 &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n@@ -281,6 +281,11 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n+        /// The `DefId` is the `DefId` of the containing MIR body. Promoteds do not have their own\n+        /// `DefId`. This function returns all promoteds in the specified body. The body references\n+        /// promoteds by the `DefId` and the `mir::Promoted` index. This is necessary, because\n+        /// after inlining a body may refer to promoteds from other bodies. In that case you still\n+        /// need to use the `DefId` of the original body.\n         query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n             desc { |tcx| \"optimizing promoted MIR for `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }"}, {"sha": "ee9b203b151804390860599744f6fafdd88d676c", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -133,7 +133,7 @@ rustc_query_append! { [define_queries!][<'tcx>] }\n /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n /// everything we need to re-run the query.\n ///\n-/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// Take the `mir_promoted` query as an example. Like many other queries, it\n /// just has a single parameter: the `DefId` of the item it will compute the\n /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`"}, {"sha": "a61af5c3f0523605f2a27e37abe7091aeeb822c5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -106,7 +106,7 @@ fn mir_borrowck<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> &'tcx BorrowCheckResult<'tcx> {\n-    let (input_body, promoted) = tcx.mir_validated(def);\n+    let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "606be7cad2ba04036ada09257e36cb0e3c8e8bec", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -7,7 +7,8 @@ use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n-use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n+use rustc_middle::ty::{self, layout::TyAndLayout, query::TyCtxtAt, Ty};\n+use rustc_target::abi::Size;\n \n use rustc_ast::Mutability;\n \n@@ -430,3 +431,25 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         }\n     }\n }\n+\n+impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    /// A helper function that allocates memory for the layout given and gives you access to mutate\n+    /// it. Once your own mutation code is done, the backing `Allocation` is removed from the\n+    /// current `Memory` and returned.\n+    pub(crate) fn intern_with_temp_alloc(\n+        &mut self,\n+        layout: TyAndLayout<'tcx>,\n+        f: impl FnOnce(\n+            &mut InterpCx<'mir, 'tcx, M>,\n+            MPlaceTy<'tcx, M::PointerTag>,\n+        ) -> InterpResult<'tcx, ()>,\n+    ) -> InterpResult<'tcx, &'tcx Allocation> {\n+        let dest = self.allocate(layout, MemoryKind::Stack);\n+        f(self, dest)?;\n+        let ptr = dest.ptr.assert_ptr();\n+        assert_eq!(ptr.offset, Size::ZERO);\n+        let mut alloc = self.memory.alloc_map.remove(&ptr.alloc_id).unwrap().1;\n+        alloc.mutability = Mutability::Not;\n+        Ok(self.tcx.intern_const_alloc(alloc))\n+    }\n+}"}, {"sha": "56479b047fa38f437461231394b9fbdc9f82e104", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -14,9 +14,9 @@ use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc_middle::mir::{\n-    AggregateKind, AssertKind, BasicBlock, BinOp, Body, ClearCrossCrate, Constant, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, Rvalue, SourceInfo, SourceScope,\n-    SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BasicBlock, BinOp, Body, ClearCrossCrate, Constant, Local, LocalDecl, LocalKind,\n+    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n+    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutError, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -28,9 +28,9 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n-    self, compile_time_machine, truncate, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n-    LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n-    Pointer, ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, Frame, ImmTy, Immediate,\n+    InterpCx, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand,\n+    PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -824,44 +824,57 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     ));\n                 }\n                 Immediate::ScalarPair(\n-                    ScalarMaybeUninit::Scalar(one),\n-                    ScalarMaybeUninit::Scalar(two),\n+                    ScalarMaybeUninit::Scalar(_),\n+                    ScalarMaybeUninit::Scalar(_),\n                 ) => {\n-                    // Found a value represented as a pair. For now only do cont-prop if type of\n-                    // Rvalue is also a pair with two scalars. The more general case is more\n-                    // complicated to implement so we'll do it later.\n-                    // FIXME: implement the general case stated above ^.\n-                    let ty = &value.layout.ty.kind;\n+                    // Found a value represented as a pair. For now only do const-prop if the type\n+                    // of `rvalue` is also a tuple with two scalars.\n+                    // FIXME: enable the general case stated above ^.\n+                    let ty = &value.layout.ty;\n                     // Only do it for tuples\n-                    if let ty::Tuple(substs) = ty {\n+                    if let ty::Tuple(substs) = ty.kind {\n                         // Only do it if tuple is also a pair with two scalars\n                         if substs.len() == 2 {\n-                            let opt_ty1_ty2 = self.use_ecx(|this| {\n+                            let alloc = self.use_ecx(|this| {\n                                 let ty1 = substs[0].expect_ty();\n                                 let ty2 = substs[1].expect_ty();\n                                 let ty_is_scalar = |ty| {\n                                     this.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n                                         == Some(true)\n                                 };\n                                 if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n-                                    Ok(Some((ty1, ty2)))\n+                                    let alloc = this\n+                                        .ecx\n+                                        .intern_with_temp_alloc(value.layout, |ecx, dest| {\n+                                            ecx.write_immediate_to_mplace(*imm, dest)\n+                                        })\n+                                        .unwrap();\n+                                    Ok(Some(alloc))\n                                 } else {\n                                     Ok(None)\n                                 }\n                             });\n \n-                            if let Some(Some((ty1, ty2))) = opt_ty1_ty2 {\n-                                *rval = Rvalue::Aggregate(\n-                                    Box::new(AggregateKind::Tuple),\n-                                    vec![\n-                                        self.operand_from_scalar(one, ty1, source_info.span),\n-                                        self.operand_from_scalar(two, ty2, source_info.span),\n-                                    ],\n-                                );\n+                            if let Some(Some(alloc)) = alloc {\n+                                // Assign entire constant in a single statement.\n+                                // We can't use aggregates, as we run after the aggregate-lowering `MirPhase`.\n+                                *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n+                                    span: source_info.span,\n+                                    user_ty: None,\n+                                    literal: self.ecx.tcx.mk_const(ty::Const {\n+                                        ty,\n+                                        val: ty::ConstKind::Value(ConstValue::ByRef {\n+                                            alloc,\n+                                            offset: Size::ZERO,\n+                                        }),\n+                                    }),\n+                                })));\n                             }\n                         }\n                     }\n                 }\n+                // Scalars or scalar pairs that contain undef values are assumed to not have\n+                // successfully evaluated and are thus not propagated.\n                 _ => {}\n             }\n         }"}, {"sha": "e2f22c115d0792dccf791a74fec4da14e22b5eab", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -57,6 +57,7 @@ use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n use crate::util::dump_mir;\n+use crate::util::expand_aggregate;\n use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n@@ -66,7 +67,7 @@ use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n-use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::GeneratorSubsts;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n@@ -236,10 +237,28 @@ struct TransformVisitor<'tcx> {\n }\n \n impl TransformVisitor<'tcx> {\n-    // Make a GeneratorState rvalue\n-    fn make_state(&self, idx: VariantIdx, val: Operand<'tcx>) -> Rvalue<'tcx> {\n-        let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None, None);\n-        Rvalue::Aggregate(box adt, vec![val])\n+    // Make a GeneratorState variant assignment. `core::ops::GeneratorState` only has single\n+    // element tuple variants, so we can just write to the downcasted first field and then set the\n+    // discriminant to the appropriate variant.\n+    fn make_state(\n+        &self,\n+        idx: VariantIdx,\n+        val: Operand<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> impl Iterator<Item = Statement<'tcx>> {\n+        let kind = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None, None);\n+        assert_eq!(self.state_adt_ref.variants[idx].fields.len(), 1);\n+        let ty = self\n+            .tcx\n+            .type_of(self.state_adt_ref.variants[idx].fields[0].did)\n+            .subst(self.tcx, self.state_substs);\n+        expand_aggregate(\n+            Place::return_place(),\n+            std::iter::once((val, ty)),\n+            kind,\n+            source_info,\n+            self.tcx,\n+        )\n     }\n \n     // Create a Place referencing a generator struct field\n@@ -325,13 +344,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         if let Some((state_idx, resume, v, drop)) = ret_val {\n             let source_info = data.terminator().source_info;\n             // We must assign the value first in case it gets declared dead below\n-            data.statements.push(Statement {\n-                source_info,\n-                kind: StatementKind::Assign(box (\n-                    Place::return_place(),\n-                    self.make_state(state_idx, v),\n-                )),\n-            });\n+            data.statements.extend(self.make_state(state_idx, v, source_info));\n             let state = if let Some((resume, resume_arg)) = resume {\n                 // Yield\n                 let state = 3 + self.suspension_points.len();"}, {"sha": "0db5bd662ca39a01393ffee0892af83874549f1a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -60,7 +60,7 @@ pub(crate) fn provide(providers: &mut Providers) {\n         mir_const_qualif_const_arg: |tcx, (did, param_did)| {\n             mir_const_qualif(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n         },\n-        mir_validated,\n+        mir_promoted,\n         mir_drops_elaborated_and_const_checked,\n         optimized_mir,\n         optimized_mir_of_const_arg,\n@@ -189,7 +189,7 @@ pub fn run_passes(\n     }\n \n     if validate {\n-        validate::Validator { when: format!(\"input to phase {:?}\", mir_phase) }\n+        validate::Validator { when: format!(\"input to phase {:?}\", mir_phase), mir_phase }\n             .run_pass(tcx, source, body);\n     }\n \n@@ -210,8 +210,11 @@ pub fn run_passes(\n         run_hooks(body, index, true);\n \n         if validate {\n-            validate::Validator { when: format!(\"after {} in phase {:?}\", pass.name(), mir_phase) }\n-                .run_pass(tcx, source, body);\n+            validate::Validator {\n+                when: format!(\"after {} in phase {:?}\", pass.name(), mir_phase),\n+                mir_phase,\n+            }\n+            .run_pass(tcx, source, body);\n         }\n \n         index += 1;\n@@ -225,8 +228,8 @@ pub fn run_passes(\n \n     body.phase = mir_phase;\n \n-    if mir_phase == MirPhase::Optimized {\n-        validate::Validator { when: format!(\"end of phase {:?}\", mir_phase) }\n+    if mir_phase == MirPhase::Optimization {\n+        validate::Validator { when: format!(\"end of phase {:?}\", mir_phase), mir_phase }\n             .run_pass(tcx, source, body);\n     }\n }\n@@ -240,7 +243,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n     }\n \n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n-    // cannot yet be stolen), because `mir_validated()`, which steals\n+    // cannot yet be stolen), because `mir_promoted()`, which steals\n     // from `mir_const(), forces this query to execute before\n     // performing the steal.\n     let body = &tcx.mir_const(def).borrow();\n@@ -311,12 +314,12 @@ fn mir_const<'tcx>(\n     tcx.alloc_steal_mir(body)\n }\n \n-fn mir_validated(\n+fn mir_promoted(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n     if let Some(def) = def.try_upgrade(tcx) {\n-        return tcx.mir_validated(def);\n+        return tcx.mir_promoted(def);\n     }\n \n     // Ensure that we compute the `mir_const_qualif` for constants at\n@@ -351,7 +354,7 @@ fn mir_validated(\n         &mut body,\n         InstanceDef::Item(def.to_global()),\n         None,\n-        MirPhase::Validated,\n+        MirPhase::ConstPromotion,\n         &[promote, opt_coverage],\n     );\n \n@@ -367,15 +370,15 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n         return tcx.mir_drops_elaborated_and_const_checked(def);\n     }\n \n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+    // (Mir-)Borrowck uses `mir_promoted`, so we have to force it to\n     // execute before we can steal.\n     if let Some(param_did) = def.const_param_did {\n         tcx.ensure().mir_borrowck_const_arg((def.did, param_did));\n     } else {\n         tcx.ensure().mir_borrowck(def.did);\n     }\n \n-    let (body, _) = tcx.mir_validated(def);\n+    let (body, _) = tcx.mir_promoted(def);\n     let mut body = body.steal();\n \n     run_post_borrowck_cleanup_passes(tcx, &mut body, def.did, None);\n@@ -420,7 +423,7 @@ fn run_post_borrowck_cleanup_passes<'tcx>(\n         body,\n         InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id())),\n         promoted,\n-        MirPhase::DropElab,\n+        MirPhase::DropLowering,\n         &[post_borrowck_cleanup],\n     );\n }\n@@ -431,16 +434,24 @@ fn run_optimization_passes<'tcx>(\n     def_id: LocalDefId,\n     promoted: Option<Promoted>,\n ) {\n-    let optimizations: &[&dyn MirPass<'tcx>] = &[\n+    let mir_opt_level = tcx.sess.opts.debugging_opts.mir_opt_level;\n+\n+    // Lowering generator control-flow and variables has to happen before we do anything else\n+    // to them. We run some optimizations before that, because they may be harder to do on the state\n+    // machine than on MIR with async primitives.\n+    let optimizations_with_generators: &[&dyn MirPass<'tcx>] = &[\n         &unreachable_prop::UnreachablePropagation,\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n         &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n         &inline::Inline,\n-        // Lowering generator control-flow and variables has to happen before we do anything else\n-        // to them. We do this inside the \"optimizations\" block so that it can benefit from\n-        // optimizations that run before, that might be harder to do on the state machine than MIR\n-        // with async primitives.\n         &generator::StateTransform,\n+    ];\n+\n+    // Even if we don't do optimizations, we still have to lower generators for codegen.\n+    let no_optimizations_with_generators: &[&dyn MirPass<'tcx>] = &[&generator::StateTransform];\n+\n+    // The main optimizations that we do on MIR.\n+    let optimizations: &[&dyn MirPass<'tcx>] = &[\n         &instcombine::InstCombine,\n         &match_branches::MatchBranchSimplification,\n         &const_prop::ConstProp,\n@@ -456,28 +467,45 @@ fn run_optimization_passes<'tcx>(\n         &simplify::SimplifyLocals,\n     ];\n \n+    // Optimizations to run even if mir optimizations have been disabled.\n     let no_optimizations: &[&dyn MirPass<'tcx>] = &[\n-        // Even if we don't do optimizations, we still have to lower generators for codegen.\n-        &generator::StateTransform,\n         // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n         &const_prop::ConstProp,\n     ];\n \n+    // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n     let pre_codegen_cleanup: &[&dyn MirPass<'tcx>] = &[\n         &add_call_guards::CriticalCallEdges,\n         // Dump the end result for testing and debugging purposes.\n         &dump_mir::Marker(\"PreCodegen\"),\n     ];\n \n-    let mir_opt_level = tcx.sess.opts.debugging_opts.mir_opt_level;\n+    // End of pass declarations, now actually run the passes.\n+    // Generator Lowering\n+    #[rustfmt::skip]\n+    run_passes(\n+        tcx,\n+        body,\n+        InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id())),\n+        promoted,\n+        MirPhase::GeneratorLowering,\n+        &[\n+            if mir_opt_level > 0 {\n+                optimizations_with_generators\n+            } else {\n+                no_optimizations_with_generators\n+            }\n+        ],\n+    );\n \n+    // Main optimization passes\n     #[rustfmt::skip]\n     run_passes(\n         tcx,\n         body,\n         InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id())),\n         promoted,\n-        MirPhase::Optimized,\n+        MirPhase::Optimization,\n         &[\n             if mir_opt_level > 0 { optimizations } else { no_optimizations },\n             pre_codegen_cleanup,\n@@ -534,7 +562,7 @@ fn promoted_mir<'tcx>(\n     } else {\n         tcx.ensure().mir_borrowck(def.did);\n     }\n-    let (_, promoted) = tcx.mir_validated(def);\n+    let (_, promoted) = tcx.mir_promoted(def);\n     let mut promoted = promoted.steal();\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {"}, {"sha": "d7c9ecd0655c0c04b83d34a4f7c2fef837ab2747", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -4,8 +4,8 @@ use super::{MirPass, MirSource};\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::{\n     mir::{\n-        BasicBlock, Body, Location, Operand, Rvalue, Statement, StatementKind, Terminator,\n-        TerminatorKind,\n+        AggregateKind, BasicBlock, Body, Location, MirPhase, Operand, Rvalue, Statement,\n+        StatementKind, Terminator, TerminatorKind,\n     },\n     ty::{\n         self,\n@@ -23,12 +23,19 @@ enum EdgeKind {\n pub struct Validator {\n     /// Describes at which point in the pipeline this validation is happening.\n     pub when: String,\n+    /// The phase for which we are upholding the dialect. If the given phase forbids a specific\n+    /// element, this validator will now emit errors if that specific element is encountered.\n+    /// Note that phases that change the dialect cause all *following* phases to check the\n+    /// invariants of the new dialect. A phase that changes dialects never checks the new invariants\n+    /// itself.\n+    pub mir_phase: MirPhase,\n }\n \n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let param_env = tcx.param_env(source.def_id());\n-        TypeChecker { when: &self.when, source, body, tcx, param_env }.visit_body(body);\n+        let mir_phase = self.mir_phase;\n+        TypeChecker { when: &self.when, source, body, tcx, param_env, mir_phase }.visit_body(body);\n     }\n }\n \n@@ -130,6 +137,7 @@ struct TypeChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n+    mir_phase: MirPhase,\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -226,16 +234,16 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(\n                         location,\n                         format!(\n-                            \"encountered `Assign` statement with incompatible types:\\n\\\n+                            \"encountered `{:?}` with incompatible types:\\n\\\n                             left-hand side has type: {}\\n\\\n                             right-hand side has type: {}\",\n-                            left_ty, right_ty,\n+                            statement.kind, left_ty, right_ty,\n                         ),\n                     );\n                 }\n-                // The sides of an assignment must not alias. Currently this just checks whether the places\n-                // are identical.\n                 match rvalue {\n+                    // The sides of an assignment must not alias. Currently this just checks whether the places\n+                    // are identical.\n                     Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n                         if dest == src {\n                             self.fail(\n@@ -244,6 +252,28 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n+                    // The deaggregator currently does not deaggreagate arrays.\n+                    // So for now, we ignore them here.\n+                    Rvalue::Aggregate(box AggregateKind::Array { .. }, _) => {}\n+                    // All other aggregates must be gone after some phases.\n+                    Rvalue::Aggregate(box kind, _) => {\n+                        if self.mir_phase > MirPhase::DropLowering\n+                            && !matches!(kind, AggregateKind::Generator(..))\n+                        {\n+                            // Generators persist until the state machine transformation, but all\n+                            // other aggregates must have been lowered.\n+                            self.fail(\n+                                location,\n+                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n+                            )\n+                        } else if self.mir_phase > MirPhase::GeneratorLowering {\n+                            // No more aggregates after drop and generator lowering.\n+                            self.fail(\n+                                location,\n+                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n+                            )\n+                        }\n+                    }\n                     _ => {}\n                 }\n             }\n@@ -288,6 +318,12 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::DropAndReplace { target, unwind, .. } => {\n+                if self.mir_phase > MirPhase::DropLowering {\n+                    self.fail(\n+                        location,\n+                        \"`DropAndReplace` is not permitted to exist after drop elaboration\",\n+                    );\n+                }\n                 self.check_edge(location, *target, EdgeKind::Normal);\n                 if let Some(unwind) = unwind {\n                     self.check_edge(location, *unwind, EdgeKind::Unwind);\n@@ -326,6 +362,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n+                if self.mir_phase > MirPhase::GeneratorLowering {\n+                    self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n+                }\n                 self.check_edge(location, *resume, EdgeKind::Normal);\n                 if let Some(drop) = drop {\n                     self.check_edge(location, *drop, EdgeKind::Normal);"}, {"sha": "125d150d3d8a2977ed1d5723ce4f66ec0d0c6d78", "filename": "src/test/mir-opt/const_prop/checked_add.main.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -13,7 +13,13 @@\n           StorageLive(_1);                 // scope 0 at $DIR/checked_add.rs:5:9: 5:10\n -         _2 = CheckedAdd(const 1_u32, const 1_u32); // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n -         assert(!move (_2.1: bool), \"attempt to compute `{} + {}` which would overflow\", const 1_u32, const 1_u32) -> bb1; // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n-+         _2 = (const 2_u32, const false); // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n++         _2 = const (2_u32, false);       // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n++                                          // ty::Const\n++                                          // + ty: (u32, bool)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [2, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/checked_add.rs:5:18: 5:23\n++                                          // + literal: Const { ty: (u32, bool), val: Value(ByRef { alloc: Allocation { bytes: [2, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}` which would overflow\", const 1_u32, const 1_u32) -> bb1; // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n       }\n   "}, {"sha": "e37d0a3ed960f5043e64b7011cbd089ec8150bdf", "filename": "src/test/mir-opt/const_prop/indirect.main.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -17,7 +17,13 @@\n -         _3 = CheckedAdd(_2, const 1_u8); // scope 0 at $DIR/indirect.rs:5:13: 5:29\n -         assert(!move (_3.1: bool), \"attempt to compute `{} + {}` which would overflow\", move _2, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:5:13: 5:29\n +         _2 = const 2_u8;                 // scope 0 at $DIR/indirect.rs:5:13: 5:25\n-+         _3 = (const 3_u8, const false);  // scope 0 at $DIR/indirect.rs:5:13: 5:29\n++         _3 = const (3_u8, false);        // scope 0 at $DIR/indirect.rs:5:13: 5:29\n++                                          // ty::Const\n++                                          // + ty: (u8, bool)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [3, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/indirect.rs:5:13: 5:29\n++                                          // + literal: Const { ty: (u8, bool), val: Value(ByRef { alloc: Allocation { bytes: [3, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}` which would overflow\", const 2_u8, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:5:13: 5:29\n       }\n   "}, {"sha": "0550627c0df834d2cba445c3c430e3cbf58b0ac3", "filename": "src/test/mir-opt/const_prop/issue_67019.main.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -14,7 +14,13 @@\n           (_3.0: u8) = const 1_u8;         // scope 0 at $DIR/issue-67019.rs:11:11: 11:17\n           (_3.1: u8) = const 2_u8;         // scope 0 at $DIR/issue-67019.rs:11:11: 11:17\n -         (_2.0: (u8, u8)) = move _3;      // scope 0 at $DIR/issue-67019.rs:11:10: 11:19\n-+         (_2.0: (u8, u8)) = (const 1_u8, const 2_u8); // scope 0 at $DIR/issue-67019.rs:11:10: 11:19\n++         (_2.0: (u8, u8)) = const (1_u8, 2_u8); // scope 0 at $DIR/issue-67019.rs:11:10: 11:19\n++                                          // ty::Const\n++                                          // + ty: (u8, u8)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [1, 2], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/issue-67019.rs:11:10: 11:19\n++                                          // + literal: Const { ty: (u8, u8), val: Value(ByRef { alloc: Allocation { bytes: [1, 2], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n           StorageDead(_3);                 // scope 0 at $DIR/issue-67019.rs:11:18: 11:19\n           _1 = const test(move _2) -> bb1; // scope 0 at $DIR/issue-67019.rs:11:5: 11:20\n                                            // mir::Constant"}, {"sha": "204c1acecf548a99e2a9206fcdc7025fe069c63d", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate.main.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -19,7 +19,13 @@\n           (_1.1: i32) = const 99_i32;      // scope 1 at $DIR/mutable_variable_aggregate.rs:6:5: 6:13\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:7:9: 7:10\n -         _2 = _1;                         // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n-+         _2 = (const 42_i32, const 99_i32); // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++         _2 = const (42_i32, 99_i32);     // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++                                          // ty::Const\n++                                          // + ty: (i32, i32)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [42, 0, 0, 0, 99, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n++                                          // + literal: Const { ty: (i32, i32), val: Value(ByRef { alloc: Allocation { bytes: [42, 0, 0, 0, 99, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n           _0 = const ();                   // scope 0 at $DIR/mutable_variable_aggregate.rs:4:11: 8:2\n           StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:8:1: 8:2\n           StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:8:1: 8:2"}, {"sha": "2c8e7ada39b0a18514e34640e7bf57b6690d808d", "filename": "src/test/mir-opt/const_prop/optimizes_into_variable.main.ConstProp.diff.32bit", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.diff.32bit", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.diff.32bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.diff.32bit?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -26,7 +26,13 @@\n           StorageLive(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:12:9: 12:10\n -         _2 = CheckedAdd(const 2_i32, const 2_i32); // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n -         assert(!move (_2.1: bool), \"attempt to compute `{} + {}` which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n-+         _2 = (const 4_i32, const false); // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n++         _2 = const (4_i32, false);       // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n++                                          // ty::Const\n++                                          // + ty: (i32, bool)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/optimizes_into_variable.rs:12:13: 12:18\n++                                          // + literal: Const { ty: (i32, bool), val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}` which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n       }\n   "}, {"sha": "2c8e7ada39b0a18514e34640e7bf57b6690d808d", "filename": "src/test/mir-opt/const_prop/optimizes_into_variable.main.ConstProp.diff.64bit", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.diff.64bit", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.diff.64bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.diff.64bit?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -26,7 +26,13 @@\n           StorageLive(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:12:9: 12:10\n -         _2 = CheckedAdd(const 2_i32, const 2_i32); // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n -         assert(!move (_2.1: bool), \"attempt to compute `{} + {}` which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n-+         _2 = (const 4_i32, const false); // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n++         _2 = const (4_i32, false);       // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n++                                          // ty::Const\n++                                          // + ty: (i32, bool)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/optimizes_into_variable.rs:12:13: 12:18\n++                                          // + literal: Const { ty: (i32, bool), val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}` which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n       }\n   "}, {"sha": "d61a04d1e03226c52e0b3d4502d9f93fb277f689", "filename": "src/test/mir-opt/const_prop/return_place.add.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.add.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.add.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.add.ConstProp.diff?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -8,7 +8,13 @@\n       bb0: {\n -         _1 = CheckedAdd(const 2_u32, const 2_u32); // scope 0 at $DIR/return_place.rs:6:5: 6:10\n -         assert(!move (_1.1: bool), \"attempt to compute `{} + {}` which would overflow\", const 2_u32, const 2_u32) -> bb1; // scope 0 at $DIR/return_place.rs:6:5: 6:10\n-+         _1 = (const 4_u32, const false); // scope 0 at $DIR/return_place.rs:6:5: 6:10\n++         _1 = const (4_u32, false);       // scope 0 at $DIR/return_place.rs:6:5: 6:10\n++                                          // ty::Const\n++                                          // + ty: (u32, bool)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/return_place.rs:6:5: 6:10\n++                                          // + literal: Const { ty: (u32, bool), val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}` which would overflow\", const 2_u32, const 2_u32) -> bb1; // scope 0 at $DIR/return_place.rs:6:5: 6:10\n       }\n   "}, {"sha": "c4c6d82856f273b4cf24f53e003ecbf379b254bb", "filename": "src/test/mir-opt/const_prop/tuple_literal_propagation.main.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -17,7 +17,13 @@\n           StorageLive(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:5: 5:15\n           StorageLive(_3);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n -         _3 = _1;                         // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n-+         _3 = (const 1_u32, const 2_u32); // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++         _3 = const (1_u32, 2_u32);       // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++                                          // ty::Const\n++                                          // + ty: (u32, u32)\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [1, 0, 0, 0, 2, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // mir::Constant\n++                                          // + span: $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++                                          // + literal: Const { ty: (u32, u32), val: Value(ByRef { alloc: Allocation { bytes: [1, 0, 0, 0, 2, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n           _2 = const consume(move _3) -> bb1; // scope 1 at $DIR/tuple_literal_propagation.rs:5:5: 5:15\n                                            // mir::Constant\n                                            // + span: $DIR/tuple_literal_propagation.rs:5:5: 5:12"}, {"sha": "64fbdc9ded13950469c494ad1c25c134c269b153", "filename": "src/test/mir-opt/fn-ptr-shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmir-opt-level=0 -Zvalidate-mir\n+// compile-flags: -Zmir-opt-level=0\n \n // Tests that the `<fn() as Fn>` shim does not create a `Call` terminator with a `Self` callee\n // (as only `FnDef` and `FnPtr` callees are allowed in MIR)."}, {"sha": "527618cef3e798bc8b15f1a3cfac04ffd6a66501", "filename": "src/test/mir-opt/generator_tiny.main-{{closure}}.generator_resume.0.mir", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7B%7Bclosure%7D%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7B%7Bclosure%7D%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7B%7Bclosure%7D%7D.generator_resume.0.mir?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -41,7 +41,8 @@ fn main::{{closure}}#0(_1: std::pin::Pin<&mut [generator@$DIR/generator-tiny.rs:\n     bb2: {\n         StorageLive(_6);                 // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         StorageLive(_7);                 // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n-        _0 = std::ops::GeneratorState::<(), ()>::Yielded(move _7); // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n+        ((_0 as Yielded).0: ()) = move _7; // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n+        discriminant(_0) = 0;            // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         discriminant((*(_1.0: &mut [generator@$DIR/generator-tiny.rs:19:16: 25:6 {u8, HasDrop, ()}]))) = 3; // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         return;                          // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n     }"}, {"sha": "8318a0a5ad0451328409226b2a6bb0b74c65d30e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814d252417cec7cfca98d75db0b3d89555d6d676/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=814d252417cec7cfca98d75db0b3d89555d6d676", "patch": "@@ -1942,6 +1942,7 @@ impl<'test> TestCx<'test> {\n                 rustc.args(&[\n                     \"-Zdump-mir=all\",\n                     \"-Zmir-opt-level=3\",\n+                    \"-Zvalidate-mir\",\n                     \"-Zdump-mir-exclude-pass-number\",\n                 ]);\n "}]}