{"sha": "b9686416c63117db3832e8015b609cbc83f11e4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5Njg2NDE2YzYzMTE3ZGIzODMyZTgwMTViNjA5Y2JjODNmMTFlNGI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-02-05T04:09:23Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-02-05T04:09:23Z"}, "message": "Remove some unnecessary `ast::` and `fold::` qualifiers.", "tree": {"sha": "1cd6dbff89b0bc6ac7593ced783b0ff071e1387c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cd6dbff89b0bc6ac7593ced783b0ff071e1387c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9686416c63117db3832e8015b609cbc83f11e4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9686416c63117db3832e8015b609cbc83f11e4b", "html_url": "https://github.com/rust-lang/rust/commit/b9686416c63117db3832e8015b609cbc83f11e4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9686416c63117db3832e8015b609cbc83f11e4b/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ae730a442cc8af6a487a137ae9ba78f89edbba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae730a442cc8af6a487a137ae9ba78f89edbba6", "html_url": "https://github.com/rust-lang/rust/commit/8ae730a442cc8af6a487a137ae9ba78f89edbba6"}], "stats": {"total": 83, "additions": 37, "deletions": 46}, "files": [{"sha": "957187ec71c61bb9e726808c92f5aca4ffd4b987", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9686416c63117db3832e8015b609cbc83f11e4b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9686416c63117db3832e8015b609cbc83f11e4b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b9686416c63117db3832e8015b609cbc83f11e4b", "patch": "@@ -9,7 +9,6 @@ use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use ext::placeholders::{placeholder, PlaceholderExpander};\n use feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n-use fold;\n use fold::*;\n use parse::{DirectoryOwnership, PResult, ParseSess};\n use parse::token::{self, Token};\n@@ -1395,7 +1394,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.check_attributes(&attrs);\n                 self.collect_bang(mac, span, AstFragmentKind::TraitItems).make_trait_items()\n             }\n-            _ => fold::noop_fold_trait_item(item, self),\n+            _ => noop_fold_trait_item(item, self),\n         }\n     }\n \n@@ -1414,14 +1413,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.check_attributes(&attrs);\n                 self.collect_bang(mac, span, AstFragmentKind::ImplItems).make_impl_items()\n             }\n-            _ => fold::noop_fold_impl_item(item, self),\n+            _ => noop_fold_impl_item(item, self),\n         }\n     }\n \n     fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         let ty = match ty.node {\n             ast::TyKind::Mac(_) => ty.into_inner(),\n-            _ => return fold::noop_fold_ty(ty, self),\n+            _ => return noop_fold_ty(ty, self),\n         };\n \n         match ty.node {"}, {"sha": "d8afad5e3791283cae821e57565026aa368cf37d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b9686416c63117db3832e8015b609cbc83f11e4b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9686416c63117db3832e8015b609cbc83f11e4b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b9686416c63117db3832e8015b609cbc83f11e4b", "patch": "@@ -9,7 +9,6 @@\n //! that are created by the expansion of a macro.\n \n use ast::*;\n-use ast;\n use syntax_pos::Span;\n use source_map::{Spanned, respan};\n use parse::token::{self, Token};\n@@ -785,31 +784,26 @@ pub fn noop_fold_where_predicate<T: Folder>(\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     match pred {\n-        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bound_generic_params,\n-                                                                     bounded_ty,\n-                                                                     bounds,\n-                                                                     span}) => {\n-            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+        WherePredicate::BoundPredicate(WhereBoundPredicate { bound_generic_params,\n+                                                             bounded_ty,\n+                                                             bounds,\n+                                                             span }) => {\n+            WherePredicate::BoundPredicate(WhereBoundPredicate {\n                 bound_generic_params: fld.fold_generic_params(bound_generic_params),\n                 bounded_ty: fld.fold_ty(bounded_ty),\n                 bounds: bounds.move_map(|x| fld.fold_param_bound(x)),\n                 span: fld.new_span(span)\n             })\n         }\n-        ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{lifetime,\n-                                                                       bounds,\n-                                                                       span}) => {\n-            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+        WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, span }) => {\n+            WherePredicate::RegionPredicate(WhereRegionPredicate {\n                 span: fld.new_span(span),\n                 lifetime: noop_fold_lifetime(lifetime, fld),\n                 bounds: bounds.move_map(|bound| noop_fold_param_bound(bound, fld))\n             })\n         }\n-        ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n-                                                               lhs_ty,\n-                                                               rhs_ty,\n-                                                               span}) => {\n-            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{\n+        WherePredicate::EqPredicate(WhereEqPredicate { id, lhs_ty, rhs_ty, span }) => {\n+            WherePredicate::EqPredicate(WhereEqPredicate{\n                 id: fld.new_id(id),\n                 lhs_ty: fld.fold_ty(lhs_ty),\n                 rhs_ty: fld.fold_ty(rhs_ty),\n@@ -821,15 +815,13 @@ pub fn noop_fold_where_predicate<T: Folder>(\n \n pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n     match vdata {\n-        ast::VariantData::Struct(fields, id) => {\n-            ast::VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n-                                     fld.new_id(id))\n+        VariantData::Struct(fields, id) => {\n+            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n         }\n-        ast::VariantData::Tuple(fields, id) => {\n-            ast::VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n-                                    fld.new_id(id))\n+        VariantData::Tuple(fields, id) => {\n+            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n         }\n-        ast::VariantData::Unit(id) => ast::VariantData::Unit(fld.new_id(id))\n+        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id))\n     }\n }\n \n@@ -839,14 +831,14 @@ pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n         path,\n         ref_id: _,\n     } = p;\n-    ast::TraitRef {\n+    TraitRef {\n         path: fld.fold_path(path),\n         ref_id: id,\n     }\n }\n \n pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n-    ast::PolyTraitRef {\n+    PolyTraitRef {\n         bound_generic_params: fld.fold_generic_params(p.bound_generic_params),\n         trait_ref: fld.fold_trait_ref(p.trait_ref),\n         span: fld.new_span(p.span),\n@@ -932,7 +924,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n         ItemKind::Enum(enum_definition, generics) => {\n             let generics = folder.fold_generics(generics);\n             let variants = enum_definition.variants.move_map(|x| folder.fold_variant(x));\n-            ItemKind::Enum(ast::EnumDef { variants }, generics)\n+            ItemKind::Enum(EnumDef { variants }, generics)\n         }\n         ItemKind::Struct(struct_def, generics) => {\n             let generics = folder.fold_generics(generics);\n@@ -991,7 +983,7 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T) -> SmallVec\n                 TraitItemKind::Type(folder.fold_bounds(bounds),\n                               default.map(|x| folder.fold_ty(x)))\n             }\n-            ast::TraitItemKind::Macro(mac) => {\n+            TraitItemKind::Macro(mac) => {\n                 TraitItemKind::Macro(folder.fold_mac(mac))\n             }\n         },\n@@ -1009,18 +1001,18 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)-> SmallVec<[I\n         generics: folder.fold_generics(i.generics),\n         defaultness: i.defaultness,\n         node: match i.node  {\n-            ast::ImplItemKind::Const(ty, expr) => {\n-                ast::ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n+            ImplItemKind::Const(ty, expr) => {\n+                ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n             }\n-            ast::ImplItemKind::Method(sig, body) => {\n-                ast::ImplItemKind::Method(noop_fold_method_sig(sig, folder),\n+            ImplItemKind::Method(sig, body) => {\n+                ImplItemKind::Method(noop_fold_method_sig(sig, folder),\n                                folder.fold_block(body))\n             }\n-            ast::ImplItemKind::Type(ty) => ast::ImplItemKind::Type(folder.fold_ty(ty)),\n-            ast::ImplItemKind::Existential(bounds) => {\n-                ast::ImplItemKind::Existential(folder.fold_bounds(bounds))\n+            ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n+            ImplItemKind::Existential(bounds) => {\n+                ImplItemKind::Existential(folder.fold_bounds(bounds))\n             },\n-            ast::ImplItemKind::Macro(mac) => ast::ImplItemKind::Macro(folder.fold_mac(mac))\n+            ImplItemKind::Macro(mac) => ImplItemKind::Macro(folder.fold_mac(mac))\n         },\n         span: folder.new_span(i.span),\n         tokens: i.tokens,\n@@ -1042,28 +1034,28 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, items, inline}: Mod, folder: &mut T)\n \n pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n                                   folder: &mut T) -> Crate {\n-    let mut items = folder.fold_item(P(ast::Item {\n+    let mut items = folder.fold_item(P(Item {\n         ident: keywords::Invalid.ident(),\n         attrs,\n-        id: ast::DUMMY_NODE_ID,\n-        vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Public),\n+        id: DUMMY_NODE_ID,\n+        vis: respan(span.shrink_to_lo(), VisibilityKind::Public),\n         span,\n-        node: ast::ItemKind::Mod(module),\n+        node: ItemKind::Mod(module),\n         tokens: None,\n     })).into_iter();\n \n     let (module, attrs, span) = match items.next() {\n         Some(item) => {\n             assert!(items.next().is_none(),\n                     \"a crate cannot expand to more than one item\");\n-            item.and_then(|ast::Item { attrs, span, node, .. }| {\n+            item.and_then(|Item { attrs, span, node, .. }| {\n                 match node {\n-                    ast::ItemKind::Mod(m) => (m, attrs, span),\n+                    ItemKind::Mod(m) => (m, attrs, span),\n                     _ => panic!(\"fold converted a module to not a module\"),\n                 }\n             })\n         }\n-        None => (ast::Mod {\n+        None => (Mod {\n             inner: span,\n             items: vec![],\n             inline: true,\n@@ -1155,7 +1147,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 let pth = folder.fold_path(pth);\n                 let fs = fields.move_map(|f| {\n                     Spanned { span: folder.new_span(f.span),\n-                              node: ast::FieldPat {\n+                              node: FieldPat {\n                                   ident: folder.fold_ident(f.node.ident),\n                                   pat: folder.fold_pat(f.node.pat),\n                                   is_shorthand: f.node.is_shorthand,"}]}