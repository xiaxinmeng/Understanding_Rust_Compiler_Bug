{"sha": "a4151ff3c4179587e5601bb529543cf1de5e91d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTUxZmYzYzQxNzk1ODdlNTYwMWJiNTI5NTQzY2YxZGU1ZTkxZDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T21:34:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-11T18:52:26Z"}, "message": "add a WF obligation if a type variable appears in bivariant position", "tree": {"sha": "ca3a5bd4094788ce4738c7b40d230c4bc14f215b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca3a5bd4094788ce4738c7b40d230c4bc14f215b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4151ff3c4179587e5601bb529543cf1de5e91d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4151ff3c4179587e5601bb529543cf1de5e91d8", "html_url": "https://github.com/rust-lang/rust/commit/a4151ff3c4179587e5601bb529543cf1de5e91d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4151ff3c4179587e5601bb529543cf1de5e91d8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a950c37394cf45428c4852359c803e5a3c194ee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a950c37394cf45428c4852359c803e5a3c194ee6", "html_url": "https://github.com/rust-lang/rust/commit/a950c37394cf45428c4852359c803e5a3c194ee6"}], "stats": {"total": 124, "additions": 106, "deletions": 18}, "files": [{"sha": "82578f6aa61d5a78ca3fb793cc582a1179c2ff87", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 69, "deletions": 18, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a4151ff3c4179587e5601bb529543cf1de5e91d8/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4151ff3c4179587e5601bb529543cf1de5e91d8/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=a4151ff3c4179587e5601bb529543cf1de5e91d8", "patch": "@@ -43,7 +43,7 @@ use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n+use traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -206,11 +206,16 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         // `'?2` and `?3` are fresh region/type inference\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n-        let b_ty = self.generalize(a_ty, b_vid, dir)?;\n+        let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n         debug!(\"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n                a_ty, dir, b_vid, b_ty);\n         self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n \n+        if needs_wf {\n+            self.obligations.push(Obligation::new(self.trace.cause.clone(),\n+                                                  ty::Predicate::WellFormed(b_ty)));\n+        }\n+\n         // Finally, relate `b_ty` to `a_ty`, as described in previous comment.\n         //\n         // FIXME(#16847): This code is non-ideal because all these subtype\n@@ -229,10 +234,9 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n \n     /// Attempts to generalize `ty` for the type variable `for_vid`.\n     /// This checks for cycle -- that is, whether the type `ty`\n-    /// references `for_vid`. If `is_eq_relation` is false, it will\n-    /// also replace all regions/unbound-type-variables with fresh\n-    /// variables. Returns `TyError` in the case of a cycle, `Ok`\n-    /// otherwise.\n+    /// references `for_vid`. The `dir` is the \"direction\" for which we\n+    /// a performing the generalization (i.e., are we producing a type\n+    /// that can be used as a supertype etc).\n     ///\n     /// Preconditions:\n     ///\n@@ -241,7 +245,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   dir: RelationDir)\n-                  -> RelateResult<'tcx, Ty<'tcx>>\n+                  -> RelateResult<'tcx, Generalization<'tcx>>\n     {\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n@@ -261,9 +265,12 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n             span: self.trace.cause.span,\n             for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n             ambient_variance: ambient_variance,\n+            needs_wf: false,\n         };\n \n-        generalize.relate(&ty, &ty)\n+        let ty = generalize.relate(&ty, &ty)?;\n+        let needs_wf = generalize.needs_wf;\n+        Ok(Generalization { ty, needs_wf })\n     }\n }\n \n@@ -272,6 +279,41 @@ struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     span: Span,\n     for_vid_sub_root: ty::TyVid,\n     ambient_variance: ty::Variance,\n+    needs_wf: bool, // see the field `needs_wf` in `Generalization`\n+}\n+\n+/// Result from a generalization operation. This includes\n+/// not only the generalized type, but also a bool flag\n+/// indicating whether further WF checks are needed.q\n+struct Generalization<'tcx> {\n+    ty: Ty<'tcx>,\n+\n+    /// If true, then the generalized type may not be well-formed,\n+    /// even if the source type is well-formed, so we should add an\n+    /// additional check to enforce that it is. This arises in\n+    /// particular around 'bivariant' type parameters that are only\n+    /// constrained by a where-clause. As an example, imagine a type:\n+    ///\n+    ///     struct Foo<A, B> where A: Iterator<Item=B> {\n+    ///         data: A\n+    ///     }\n+    ///\n+    /// here, `A` will be covariant, but `B` is\n+    /// unconstrained. However, whatever it is, for `Foo` to be WF, it\n+    /// must be equal to `A::Item`. If we have an input `Foo<?A, ?B>`,\n+    /// then after generalization we will wind up with a type like\n+    /// `Foo<?C, ?D>`. When we enforce that `Foo<?A, ?B> <: Foo<?C,\n+    /// ?D>` (or `>:`), we will wind up with the requirement that `?A\n+    /// <: ?C`, but no particular relationship between `?B` and `?D`\n+    /// (after all, we do not know the variance of the normalized form\n+    /// of `A::Item` with respect to `A`). If we do nothing else, this\n+    /// may mean that `?D` goes unconstrained (as in #41677).  So, in\n+    /// this scenario where we create a new type variable in a\n+    /// bivariant context, we set the `needs_wf` flag to true. This\n+    /// will force the calling code to check that `WF(Foo<?C, ?D>)`\n+    /// holds, which in turn implies that `?C::Item == ?D`. So once\n+    /// `?C` is constrained, that should suffice to restrict `?D`.\n+    needs_wf: bool,\n }\n \n impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n@@ -332,17 +374,26 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                         }\n                         None => {\n                             match self.ambient_variance {\n-                                ty::Invariant => Ok(t),\n-\n-                                ty::Bivariant | ty::Covariant | ty::Contravariant => {\n-                                    let origin = variables.origin(vid);\n-                                    let new_var_id = variables.new_var(false, origin, None);\n-                                    let u = self.tcx().mk_var(new_var_id);\n-                                    debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n-                                           vid, u);\n-                                    Ok(u)\n-                                }\n+                                // Invariant: no need to make a fresh type variable.\n+                                ty::Invariant => return Ok(t),\n+\n+                                // Bivariant: make a fresh var, but we\n+                                // may need a WF predicate. See\n+                                // comment on `needs_wf` field for\n+                                // more info.\n+                                ty::Bivariant => self.needs_wf = true,\n+\n+                                // Co/contravariant: this will be\n+                                // sufficiently constrained later on.\n+                                ty::Covariant | ty::Contravariant => (),\n                             }\n+\n+                            let origin = variables.origin(vid);\n+                            let new_var_id = variables.new_var(false, origin, None);\n+                            let u = self.tcx().mk_var(new_var_id);\n+                            debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n+                                   vid, u);\n+                            return Ok(u);\n                         }\n                     }\n                 }"}, {"sha": "d014382ca39b6cb10680c6df4b36ccada6a1b63d", "filename": "src/test/run-pass/issue-41677.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a4151ff3c4179587e5601bb529543cf1de5e91d8/src%2Ftest%2Frun-pass%2Fissue-41677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4151ff3c4179587e5601bb529543cf1de5e91d8/src%2Ftest%2Frun-pass%2Fissue-41677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41677.rs?ref=a4151ff3c4179587e5601bb529543cf1de5e91d8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #41677. The local variable was winding up with\n+// a type `Receiver<?T, H>` where `?T` was unconstrained, because we\n+// failed to enforce the WF obligations and `?T` is a bivariant type\n+// parameter position.\n+\n+#![allow(unused_variables, dead_code)]\n+\n+use std::marker::PhantomData;\n+\n+trait Handle {\n+    type Inner;\n+}\n+\n+struct ResizingHandle<H>(PhantomData<H>);\n+impl<H> Handle for ResizingHandle<H> {\n+    type Inner = H;\n+}\n+\n+struct Receiver<T, H: Handle<Inner=T>>(PhantomData<H>);\n+\n+fn channel<T>(size: usize) -> Receiver<T, ResizingHandle<T>> {\n+    let rx = Receiver(PhantomData);\n+    rx\n+}\n+\n+fn main() {\n+}"}]}