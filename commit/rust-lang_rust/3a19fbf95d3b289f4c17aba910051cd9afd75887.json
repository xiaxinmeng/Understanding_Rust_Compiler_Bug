{"sha": "3a19fbf95d3b289f4c17aba910051cd9afd75887", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMTlmYmY5NWQzYjI4OWY0YzE3YWJhOTEwMDUxY2Q5YWZkNzU4ODc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-12-23T19:00:58Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-18T20:09:10Z"}, "message": "Add Rvalue::AddressOf to MIR\n\nThis operator creates a raw pointer to a Place directly, without first\ncreating a reference. See RFC #2582 for motivation.\n\nThe Rvalue is currently unused.", "tree": {"sha": "79cf3df79e4705fe3390ef27ec54c609c88c9893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79cf3df79e4705fe3390ef27ec54c609c88c9893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a19fbf95d3b289f4c17aba910051cd9afd75887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a19fbf95d3b289f4c17aba910051cd9afd75887", "html_url": "https://github.com/rust-lang/rust/commit/3a19fbf95d3b289f4c17aba910051cd9afd75887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a19fbf95d3b289f4c17aba910051cd9afd75887/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19bd93467617a447c22ec32cc1cf14d40cb84ccf", "url": "https://api.github.com/repos/rust-lang/rust/commits/19bd93467617a447c22ec32cc1cf14d40cb84ccf", "html_url": "https://github.com/rust-lang/rust/commit/19bd93467617a447c22ec32cc1cf14d40cb84ccf"}], "stats": {"total": 476, "additions": 307, "deletions": 169}, "files": [{"sha": "3b4adbaf78c7460d99200919dcfac3caafbfbed6", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -2060,6 +2060,11 @@ pub enum Rvalue<'tcx> {\n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n+    /// Create a raw pointer to the given place\n+    /// Can be generated by raw address of expressions (`&raw const x`),\n+    /// or when casting a reference to a raw pointer.\n+    AddressOf(Mutability, Place<'tcx>),\n+\n     /// length of a [X] or [X;n] value\n     Len(Place<'tcx>),\n \n@@ -2214,6 +2219,15 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 write!(fmt, \"&{}{}{:?}\", region, kind_str, place)\n             }\n \n+            AddressOf(mutability, ref place) => {\n+                let kind_str = match mutability {\n+                    Mutability::Mut => \"mut\",\n+                    Mutability::Not => \"const\",\n+                };\n+\n+                write!(fmt, \"&raw {} {:?}\", kind_str, place)\n+            }\n+\n             Aggregate(ref kind, ref places) => {\n                 fn fmt_tuple(fmt: &mut Formatter<'_>, places: &[Operand<'_>]) -> fmt::Result {\n                     let mut tuple_fmt = fmt.debug_tuple(\"\");\n@@ -3085,6 +3099,9 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n             Ref(region, bk, ref place) => {\n                 Ref(region.fold_with(folder), bk, place.fold_with(folder))\n             }\n+            AddressOf(mutability, ref place) => {\n+                AddressOf(mutability, place.fold_with(folder))\n+            }\n             Len(ref place) => Len(place.fold_with(folder)),\n             Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n             BinaryOp(op, ref rhs, ref lhs) => {\n@@ -3125,6 +3142,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n             Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            AddressOf(_, ref place) => place.visit_with(visitor),\n             Len(ref place) => place.visit_with(visitor),\n             Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n             BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {"}, {"sha": "a24b1d863d6440b38649e699b100774a4c45a061", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -172,6 +172,13 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                 )\n             }\n+            Rvalue::AddressOf(mutability, ref place) => {\n+                let place_ty = place.ty(local_decls, tcx).ty;\n+                tcx.mk_ptr(ty::TypeAndMut {\n+                    ty: place_ty,\n+                    mutbl: mutability.into(),\n+                })\n+            }\n             Rvalue::Len(..) => tcx.types.usize,\n             Rvalue::Cast(.., ty) => ty,\n             Rvalue::BinaryOp(op, ref lhs, ref rhs) => {"}, {"sha": "fa96b51347d350f0197e0ca6a006c2fd6de0d043", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -570,6 +570,18 @@ macro_rules! make_mir_visitor {\n                         self.visit_place(path, ctx, location);\n                     }\n \n+                    Rvalue::AddressOf(m, path) => {\n+                        let ctx = match m {\n+                            Mutability::Mut => PlaceContext::MutatingUse(\n+                                MutatingUseContext::AddressOf\n+                            ),\n+                            Mutability::Not => PlaceContext::NonMutatingUse(\n+                                NonMutatingUseContext::AddressOf\n+                            ),\n+                        };\n+                        self.visit_place(path, ctx, location);\n+                    }\n+\n                     Rvalue::Len(path) => {\n                         self.visit_place(\n                             path,\n@@ -1031,6 +1043,8 @@ pub enum NonMutatingUseContext {\n     ShallowBorrow,\n     /// Unique borrow.\n     UniqueBorrow,\n+    /// AddressOf for *const pointer.\n+    AddressOf,\n     /// Used as base for another place, e.g., `x` in `x.y`. Will not mutate the place.\n     /// For example, the projection `x.y` is not marked as a mutation in these cases:\n     ///\n@@ -1054,6 +1068,8 @@ pub enum MutatingUseContext {\n     Drop,\n     /// Mutable borrow.\n     Borrow,\n+    /// AddressOf for *mut pointer.\n+    AddressOf,\n     /// Used as base for another place, e.g., `x` in `x.y`. Could potentially mutate the place.\n     /// For example, the projection `x.y` is marked as a mutation in these cases:\n     ///"}, {"sha": "fca53db1475a0abc6dc41c0ba720af2feaf5f62b", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -28,8 +28,6 @@ pub enum CastTy<'tcx> {\n     FnPtr,\n     /// Raw pointers\n     Ptr(ty::TypeAndMut<'tcx>),\n-    /// References\n-    RPtr(ty::TypeAndMut<'tcx>),\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n@@ -63,7 +61,6 @@ impl<'tcx> CastTy<'tcx> {\n             ty::Adt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::RawPtr(mt) => Some(CastTy::Ptr(mt)),\n-            ty::Ref(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n             ty::FnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }"}, {"sha": "7bcd98167864071bf44a2a6c0e0f4704bc7a40be", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -340,10 +340,12 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             PlaceContext::MutatingUse(MutatingUseContext::Store) |\n             PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n             PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n+            PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n             PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) => {\n                 self.not_ssa(local);\n             }"}, {"sha": "5b21dfbdf1c695240a97a22603b279bc4ca2c9a2", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        let result = match &place_ref {\n+        let result = match place_ref {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Local(index),\n                 projection: [],"}, {"sha": "3a8d782aa7308d22121b69d8b8c133cc61df2b69", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -7,7 +7,7 @@ use crate::MemFlags;\n use crate::common::{self, RealPredicate, IntPredicate};\n use crate::traits::*;\n \n-use rustc::ty::{self, Ty, adjustment::{PointerCast}, Instance};\n+use rustc::ty::{self, Ty, TyCtxt, adjustment::{PointerCast}, Instance};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n@@ -342,8 +342,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 }\n                             }\n                             (CastTy::Ptr(_), CastTy::Ptr(_)) |\n-                            (CastTy::FnPtr, CastTy::Ptr(_)) |\n-                            (CastTy::RPtr(_), CastTy::Ptr(_)) =>\n+                            (CastTy::FnPtr, CastTy::Ptr(_)) =>\n                                 bx.pointercast(llval, ll_t_out),\n                             (CastTy::Ptr(_), CastTy::Int(_)) |\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n@@ -370,24 +369,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Ref(_, bk, ref place) => {\n-                let cg_place = self.codegen_place(&mut bx, &place.as_ref());\n-\n-                let ty = cg_place.layout.ty;\n+                let mk_ref = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| tcx.mk_ref(\n+                    tcx.lifetimes.re_erased,\n+                    ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n+                );\n+                self.codegen_place_to_pointer(bx, place, mk_ref)\n+            }\n \n-                // Note: places are indirect, so storing the `llval` into the\n-                // destination effectively creates a reference.\n-                let val = if !bx.cx().type_has_metadata(ty) {\n-                    OperandValue::Immediate(cg_place.llval)\n-                } else {\n-                    OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n-                };\n-                (bx, OperandRef {\n-                    val,\n-                    layout: self.cx.layout_of(self.cx.tcx().mk_ref(\n-                        self.cx.tcx().lifetimes.re_erased,\n-                        ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n-                    )),\n-                })\n+            mir::Rvalue::AddressOf(mutability, ref place) => {\n+                let mk_ptr = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| tcx.mk_ptr(\n+                    ty::TypeAndMut { ty, mutbl: mutability.into() }\n+                );\n+                self.codegen_place_to_pointer(bx, place, mk_ptr)\n             }\n \n             mir::Rvalue::Len(ref place) => {\n@@ -543,6 +536,30 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         cg_value.len(bx.cx())\n     }\n \n+    /// Codegen an `Rvalue::AddressOf` or `Rvalue::Ref`\n+    fn codegen_place_to_pointer(\n+        &mut self,\n+        mut bx: Bx,\n+        place: &mir::Place<'tcx>,\n+        mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n+    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n+        let cg_place = self.codegen_place(&mut bx, &place.as_ref());\n+\n+        let ty = cg_place.layout.ty;\n+\n+        // Note: places are indirect, so storing the `llval` into the\n+        // destination effectively creates a reference.\n+        let val = if !bx.cx().type_has_metadata(ty) {\n+            OperandValue::Immediate(cg_place.llval)\n+        } else {\n+            OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n+        };\n+        (bx, OperandRef {\n+            val,\n+            layout: self.cx.layout_of(mk_ptr_ty(self.cx.tcx(), ty)),\n+        })\n+    }\n+\n     pub fn codegen_scalar_binop(\n         &mut self,\n         bx: &mut Bx,\n@@ -699,6 +716,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>, span: Span) -> bool {\n         match *rvalue {\n             mir::Rvalue::Ref(..) |\n+            mir::Rvalue::AddressOf(..) |\n             mir::Rvalue::Len(..) |\n             mir::Rvalue::Cast(..) | // (*)\n             mir::Rvalue::BinaryOp(..) |"}, {"sha": "d5b9aaf9511a19197a859eb609328dee4f56eaee", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -3,7 +3,7 @@ use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, Location, Body, Place, ReadOnlyBodyAndCache, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::TerminatorKind;\n-use rustc::mir::{Operand, BorrowKind};\n+use rustc::mir::{Operand, BorrowKind, Mutability};\n use rustc_data_structures::graph::dominators::Dominators;\n \n use crate::dataflow::indexes::BorrowIndex;\n@@ -337,6 +337,22 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n \n+            Rvalue::AddressOf(mutability, ref place) => {\n+                let access_kind = match mutability {\n+                    Mutability::Mut => (Deep, Write(WriteKind::MutableBorrow(BorrowKind::Mut {\n+                        allow_two_phase_borrow: false,\n+                    }))),\n+                    Mutability::Not => (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                };\n+\n+                self.access_place(\n+                    location,\n+                    place,\n+                    access_kind,\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+\n             Rvalue::Use(ref operand)\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)"}, {"sha": "2554d5e729da983ce477163b82cd2f2e80ab8469", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -1233,6 +1233,31 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n+\n+            Rvalue::AddressOf(mutability, ref place) => {\n+                let access_kind = match mutability {\n+                    Mutability::Mut => (Deep, Write(WriteKind::MutableBorrow(BorrowKind::Mut {\n+                        allow_two_phase_borrow: false,\n+                    }))),\n+                    Mutability::Not => (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                };\n+\n+                self.access_place(\n+                    location,\n+                    (place, span),\n+                    access_kind,\n+                    LocalMutationIsAllowed::No,\n+                    flow_state,\n+                );\n+\n+                self.check_if_path_or_subpath_is_moved(\n+                    location,\n+                    InitializationRequiringAction::Borrow,\n+                    (place.as_ref(), span),\n+                    flow_state,\n+                );\n+            }\n+\n             Rvalue::Use(ref operand)\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)"}, {"sha": "108279eeef49245afe35073d8002b8978144e893", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -2273,41 +2273,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n-                            (Some(CastTy::RPtr(ref_tm)), Some(CastTy::Ptr(ptr_tm))) => {\n-                                if let hir::Mutability::Mutable = ptr_tm.mutbl {\n-                                    if let Err(terr) = self.eq_types(\n-                                        ref_tm.ty,\n-                                        ptr_tm.ty,\n-                                        location.to_locations(),\n-                                        ConstraintCategory::Cast,\n-                                    ) {\n-                                        span_mirbug!(\n-                                            self,\n-                                            rvalue,\n-                                            \"equating {:?} with {:?} yields {:?}\",\n-                                            ref_tm.ty,\n-                                            ptr_tm.ty,\n-                                            terr\n-                                        )\n-                                    }\n-                                } else {\n-                                    if let Err(terr) = self.sub_types(\n-                                        ref_tm.ty,\n-                                        ptr_tm.ty,\n-                                        location.to_locations(),\n-                                        ConstraintCategory::Cast,\n-                                    ) {\n-                                        span_mirbug!(\n-                                            self,\n-                                            rvalue,\n-                                            \"relating {:?} with {:?} yields {:?}\",\n-                                            ref_tm.ty,\n-                                            ptr_tm.ty,\n-                                            terr\n-                                        )\n-                                    }\n-                                }\n-                            },\n                             (None, _)\n                             | (_, None)\n                             | (_, Some(CastTy::FnPtr))\n@@ -2320,7 +2285,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ty_from,\n                                 ty,\n                             ),\n-                            _ => (),\n+                            (Some(CastTy::Int(_)), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::Float), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::Int(_)), Some(CastTy::Float))\n+                            | (Some(CastTy::Float), Some(CastTy::Float))\n+                            | (Some(CastTy::Ptr(_)), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::Int(_)), Some(CastTy::Ptr(_)))\n+                            | (Some(CastTy::Ptr(_)), Some(CastTy::Ptr(_)))\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Ptr(_))) => (),\n                         }\n                     }\n                 }\n@@ -2371,7 +2344,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            Rvalue::Use(..)\n+            Rvalue::AddressOf(..)\n+            | Rvalue::Use(..)\n             | Rvalue::Len(..)\n             | Rvalue::BinaryOp(..)\n             | Rvalue::CheckedBinaryOp(..)\n@@ -2388,6 +2362,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)\n             | Rvalue::Ref(..)\n+            | Rvalue::AddressOf(..)\n             | Rvalue::Len(..)\n             | Rvalue::Cast(..)\n             | Rvalue::BinaryOp(..)"}, {"sha": "5522da6fbf0858163c0020a39e7599292a8b7bf2", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -335,6 +335,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 }\n             }\n             Rvalue::Ref(..)\n+            | Rvalue::AddressOf(..)\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(..)\n             | Rvalue::NullaryOp(NullOp::SizeOf, _)"}, {"sha": "33cdf1b27f8db9a8e5942a3f0bd1013aa707771b", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -248,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 )?;\n             }\n \n-            Ref(_, _, ref place) => {\n+            AddressOf(_, ref place) | Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(src)?;\n                 if place.layout.size.bytes() > 0 {"}, {"sha": "0e4fe3f7f4015cd3803b65d3a73298d87c37fd9a", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -136,21 +136,9 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n-                    // If we are casting *from* a reference, we may have to retag-as-raw.\n-                    StatementKind::Assign(box(ref place, Rvalue::Cast(\n-                        CastKind::Misc,\n-                        ref src,\n-                        dest_ty,\n-                    ))) => {\n-                        let src_ty = src.ty(&*local_decls, tcx);\n-                        if src_ty.is_region_ptr() {\n-                            // The only `Misc` casts on references are those creating raw pointers.\n-                            assert!(dest_ty.is_unsafe_ptr());\n-                            (RetagKind::Raw, place.clone())\n-                        } else {\n-                            // Some other cast, no retag\n-                            continue\n-                        }\n+                    // Retag-as-raw after escaping to a raw pointer.\n+                    StatementKind::Assign(box (ref place, Rvalue::AddressOf(..))) => {\n+                        (RetagKind::Raw, place.clone())\n                     }\n                     // Assignments of reference or ptr type are the ones where we may have\n                     // to update tags.  This includes `x = &[mut] ...` and hence"}, {"sha": "e5f3003cd711007d55caafdb2e0388c3f8eb42bf", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -224,6 +224,23 @@ impl NonConstOp for MutBorrow {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct MutAddressOf;\n+impl NonConstOp for MutAddressOf {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_mut_refs)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_mut_refs,\n+            span,\n+            &format!(\"`&raw mut` is not allowed in {}s\", item.const_kind())\n+        ).emit();\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MutDeref;\n impl NonConstOp for MutDeref {"}, {"sha": "28243bd71a228f05629111ac99c6787d53b891c8", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -151,17 +151,15 @@ pub trait Qualif {\n                 Self::in_operand(cx, per_local, lhs) || Self::in_operand(cx, per_local, rhs)\n             }\n \n-            Rvalue::Ref(_, _, ref place) => {\n+            Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                    if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n-                        if let ty::Ref(..) = base_ty.kind {\n-                            return Self::in_place(cx, per_local, PlaceRef {\n-                                base: &place.base,\n-                                projection: proj_base,\n-                            });\n-                        }\n+                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        return Self::in_place(cx, per_local, PlaceRef {\n+                            base: &place.base,\n+                            projection: proj_base,\n+                        });\n                     }\n                 }\n "}, {"sha": "0904264586c7c855fa372781356a8df77220feae", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -276,6 +276,27 @@ impl Validator<'a, 'mir, 'tcx> {\n             self.check_op_spanned(ops::StaticAccess, span)\n         }\n     }\n+\n+    fn check_immutable_borrow_like(\n+        &mut self,\n+        location: Location,\n+        place: &Place<'tcx>,\n+    ) {\n+        // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n+        // seek the cursors beforehand.\n+        self.qualifs.has_mut_interior.cursor.seek_before(location);\n+        self.qualifs.indirectly_mutable.seek(location);\n+\n+        let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+            &self.item,\n+            &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+            place.as_ref(),\n+        );\n+\n+        if borrowed_place_has_mut_interior {\n+            self.check_op(ops::CellBorrow);\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n@@ -302,26 +323,44 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n         // Special-case reborrows to be more like a copy of a reference.\n-        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n-                let ctx = match kind {\n-                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::SharedBorrow,\n-                    ),\n-                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::ShallowBorrow,\n-                    ),\n-                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::UniqueBorrow,\n-                    ),\n-                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n-                        MutatingUseContext::Borrow,\n-                    ),\n-                };\n-                self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n-                return;\n+        match *rvalue {\n+            Rvalue::Ref(_, kind, ref place) => {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                    let ctx = match kind {\n+                        BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::SharedBorrow,\n+                        ),\n+                        BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::ShallowBorrow,\n+                        ),\n+                        BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::UniqueBorrow,\n+                        ),\n+                        BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n+                            MutatingUseContext::Borrow,\n+                        ),\n+                    };\n+                    self.visit_place_base(&place.base, ctx, location);\n+                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    return;\n+                }\n             }\n+            Rvalue::AddressOf(mutbl, ref place) => {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                    let ctx = match mutbl {\n+                        Mutability::Not => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::AddressOf,\n+                        ),\n+                        Mutability::Mut => PlaceContext::MutatingUse(\n+                            MutatingUseContext::AddressOf,\n+                        ),\n+                    };\n+                    self.visit_place_base(&place.base, ctx, location);\n+                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    return;\n+                }\n+            }\n+            _ => {}\n         }\n \n         self.super_rvalue(rvalue, location);\n@@ -367,34 +406,25 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 }\n             }\n \n+            Rvalue::AddressOf(Mutability::Mut, _) => {\n+                self.check_op(ops::MutAddressOf)\n+            }\n+\n             // At the moment, `PlaceBase::Static` is only used for promoted MIR.\n             | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n             | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n+            | Rvalue::AddressOf(Mutability::Not, ref place)\n             if matches!(place.base, PlaceBase::Static(_))\n             => bug!(\"Saw a promoted during const-checking, which must run before promotion\"),\n \n-            | Rvalue::Ref(_, kind @ BorrowKind::Shared, ref place)\n-            | Rvalue::Ref(_, kind @ BorrowKind::Shallow, ref place)\n-            => {\n-                // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n-                // seek the cursors beforehand.\n-                self.qualifs.has_mut_interior.cursor.seek_before(location);\n-                self.qualifs.indirectly_mutable.seek(location);\n-\n-                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n-                    &self.item,\n-                    &|local| self.qualifs.has_mut_interior_eager_seek(local),\n-                    place.as_ref(),\n-                );\n-\n-                if borrowed_place_has_mut_interior {\n-                    if let BorrowKind::Mut{ .. } = kind {\n-                        self.check_op(ops::MutBorrow);\n-                    } else {\n-                        self.check_op(ops::CellBorrow);\n-                    }\n-                }\n-            }\n+            | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, BorrowKind::Shallow, ref place) => {\n+                self.check_immutable_borrow_like(location, place)\n+            },\n+\n+            Rvalue::AddressOf(Mutability::Not, ref place) => {\n+                self.check_immutable_borrow_like(location, place)\n+            },\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(*self.body, self.tcx);"}, {"sha": "4e5d8ae08fe5bd7b07c960b5be1758aff50a8241", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -196,7 +196,12 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         } else if let TempState::Defined { ref mut uses, .. } = *temp {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g., `&mut []`.\n-            let allowed_use = context.is_borrow() || context.is_nonmutating_use();\n+            let allowed_use = match context {\n+                PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+                | PlaceContext::NonMutatingUse(_) => true,\n+                PlaceContext::MutatingUse(_)\n+                | PlaceContext::NonUse(_) => false,\n+            };\n             debug!(\"visit_local: allowed_use={:?}\", allowed_use);\n             if allowed_use {\n                 *uses += 1;\n@@ -618,6 +623,21 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 self.validate_operand(rhs)\n             }\n \n+            Rvalue::AddressOf(_, place) => {\n+                // Raw reborrows can come from reference to pointer coercions,\n+                // so are allowed.\n+                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        return self.validate_place(PlaceRef {\n+                            base: &place.base,\n+                            projection: proj_base,\n+                        });\n+                    }\n+                }\n+                Err(Unpromotable)\n+            }\n+\n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n                     let ty = place.ty(*self.body, self.tcx).ty;\n@@ -950,7 +970,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref mut place))) => {\n+                        StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref mut place))) => {\n                             // Use the underlying local for this (necessarily interior) borrow.\n                             let ty = place.base.ty(local_decls).ty;\n                             let span = statement.source_info.span;"}, {"sha": "a61bff37fc873378698104eed255753a6aae2cfa", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -135,7 +135,10 @@ fn check_rvalue(\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n             check_operand(tcx, operand, span, def_id, body)\n         }\n-        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) => {\n+        Rvalue::Len(place)\n+        | Rvalue::Discriminant(place)\n+        | Rvalue::Ref(_, _, place)\n+        | Rvalue::AddressOf(_, place) => {\n             check_place(tcx, place, span, def_id, body)\n         }\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n@@ -147,9 +150,6 @@ fn check_rvalue(\n                     span,\n                     \"casting pointers to ints is unstable in const fn\".into(),\n                 )),\n-                (CastTy::RPtr(_), CastTy::Float) => bug!(),\n-                (CastTy::RPtr(_), CastTy::Int(_)) => bug!(),\n-                (CastTy::Ptr(_), CastTy::RPtr(_)) => bug!(),\n                 _ => check_operand(tcx, operand, span, def_id, body),\n             }\n         }"}, {"sha": "01eebeb8c55a55a68ed4045b34d1c057743cbcdb", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -167,6 +167,8 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n \n+        PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |"}, {"sha": "21ba02746c79e6cf786b96e8f75837c93e67821a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a19fbf95d3b289f4c17aba910051cd9afd75887/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=3a19fbf95d3b289f4c17aba910051cd9afd75887", "patch": "@@ -469,30 +469,56 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::FnDef(..) = self.expr_ty.kind {\n-                    // Attempt a coercion to a fn pointer type.\n-                    let f = self.expr_ty.fn_sig(fcx.tcx);\n-                    let res = fcx.try_coerce(self.expr,\n-                                             self.expr_ty,\n-                                             fcx.tcx.mk_fn_ptr(f),\n-                                             AllowTwoPhase::No);\n-                    if let Err(TypeError::IntrinsicCast) = res {\n-                        return Err(CastError::IllegalCast);\n+                match self.expr_ty.kind {\n+                    ty::FnDef(..) => {\n+                        // Attempt a coercion to a fn pointer type.\n+                        let f = self.expr_ty.fn_sig(fcx.tcx);\n+                        let res = fcx.try_coerce(self.expr,\n+                                                 self.expr_ty,\n+                                                 fcx.tcx.mk_fn_ptr(f),\n+                                                 AllowTwoPhase::No);\n+                        if let Err(TypeError::IntrinsicCast) = res {\n+                            return Err(CastError::IllegalCast);\n+                        }\n+                        if res.is_err() {\n+                            return Err(CastError::NonScalar);\n+                        }\n+                        (FnPtr, t_cast)\n                     }\n-                    if res.is_err() {\n-                        return Err(CastError::NonScalar);\n+                    // Special case some errors for references, and check for\n+                    // array-ptr-casts. `Ref` is not a CastTy because the cast\n+                    // is split into a coercion to a pointer type, followed by\n+                    // a cast.\n+                    ty::Ref(_, inner_ty, mutbl) => {\n+                        return match t_cast {\n+                            Int(_) | Float => match inner_ty.kind {\n+                                ty::Int(_) |\n+                                ty::Uint(_) |\n+                                ty::Float(_) |\n+                                ty::Infer(ty::InferTy::IntVar(_)) |\n+                                ty::Infer(ty::InferTy::FloatVar(_)) => {\n+                                    Err(CastError::NeedDeref)\n+                                }\n+                                _ => Err(CastError::NeedViaPtr),\n+                            }\n+                            // array-ptr-cast\n+                            Ptr(mt) => self.check_ref_cast(\n+                                fcx,\n+                                TypeAndMut { mutbl, ty: inner_ty },\n+                                mt,\n+                            ),\n+                            _ => Err(CastError::NonScalar),\n+                        };\n                     }\n-                    (FnPtr, t_cast)\n-                } else {\n-                    return Err(CastError::NonScalar);\n+                    _ => return Err(CastError::NonScalar),\n                 }\n             }\n             _ => return Err(CastError::NonScalar),\n         };\n \n         match (t_from, t_cast) {\n             // These types have invariants! can't cast into them.\n-            (_, RPtr(_)) | (_, Int(CEnum)) | (_, FnPtr) => Err(CastError::NonScalar),\n+            (_, Int(CEnum)) | (_, FnPtr) => Err(CastError::NonScalar),\n \n             // * -> Bool\n             (_, Int(Bool)) => Err(CastError::CastToBool),\n@@ -517,28 +543,10 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n             (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n             (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n-            (RPtr(p), Int(_)) |\n-            (RPtr(p), Float) => {\n-                match p.ty.kind {\n-                    ty::Int(_) |\n-                    ty::Uint(_) |\n-                    ty::Float(_) => {\n-                        Err(CastError::NeedDeref)\n-                    }\n-                    ty::Infer(t) => {\n-                        match t {\n-                            ty::InferTy::IntVar(_) |\n-                            ty::InferTy::FloatVar(_) => Err(CastError::NeedDeref),\n-                            _ => Err(CastError::NeedViaPtr),\n-                        }\n-                    }\n-                    _ => Err(CastError::NeedViaPtr),\n-                }\n-            }\n+\n             // * -> ptr\n             (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n-            (RPtr(rmt), Ptr(mt)) => self.check_ref_cast(fcx, rmt, mt), // array-ptr-cast\n \n             // prim -> prim\n             (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),"}]}