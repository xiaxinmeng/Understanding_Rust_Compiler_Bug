{"sha": "65d1f83d2c593c7997b4fe781814eb0fb69272e9", "node_id": "C_kwDOAAsO6NoAKDY1ZDFmODNkMmM1OTNjNzk5N2I0ZmU3ODE4MTRlYjBmYjY5MjcyZTk", "commit": {"author": {"name": "Nick Mathewson", "email": "nickm@torproject.org", "date": "2021-12-27T16:17:17Z"}, "committer": {"name": "Nick Mathewson", "email": "nickm@torproject.org", "date": "2021-12-31T17:10:59Z"}, "message": "Extend [`unused_io_amount`] to cover AsyncRead and AsyncWrite.\n\nClippy helpfully warns about code like this, telling you that you\nprobably meant \"write_all\":\n\n    fn say_hi<W:Write>(w: &mut W) {\n       w.write(b\"hello\").unwrap();\n    }\n\nThis patch attempts to extend the lint so it also covers this\ncase:\n\n    async fn say_hi<W:AsyncWrite>(w: &mut W) {\n       w.write(b\"hello\").await.unwrap();\n    }\n\n(I've run into this second case several times in my own programming,\nand so have my coworkers, so unless we're especially accident-prone\nin this area, it's probably worth addressing?)\n\nThis patch covers the Async{Read,Write}Ext traits in futures-rs,\nand in tokio, since both are quite widely used.\n\nchangelog: [`unused_io_amount`] now supports AsyncReadExt and AsyncWriteExt.", "tree": {"sha": "d65958351faa99a53291071590c77c1f3910455f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d65958351faa99a53291071590c77c1f3910455f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65d1f83d2c593c7997b4fe781814eb0fb69272e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65d1f83d2c593c7997b4fe781814eb0fb69272e9", "html_url": "https://github.com/rust-lang/rust/commit/65d1f83d2c593c7997b4fe781814eb0fb69272e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65d1f83d2c593c7997b4fe781814eb0fb69272e9/comments", "author": {"login": "nmathewson", "id": 162054, "node_id": "MDQ6VXNlcjE2MjA1NA==", "avatar_url": "https://avatars.githubusercontent.com/u/162054?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nmathewson", "html_url": "https://github.com/nmathewson", "followers_url": "https://api.github.com/users/nmathewson/followers", "following_url": "https://api.github.com/users/nmathewson/following{/other_user}", "gists_url": "https://api.github.com/users/nmathewson/gists{/gist_id}", "starred_url": "https://api.github.com/users/nmathewson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nmathewson/subscriptions", "organizations_url": "https://api.github.com/users/nmathewson/orgs", "repos_url": "https://api.github.com/users/nmathewson/repos", "events_url": "https://api.github.com/users/nmathewson/events{/privacy}", "received_events_url": "https://api.github.com/users/nmathewson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nmathewson", "id": 162054, "node_id": "MDQ6VXNlcjE2MjA1NA==", "avatar_url": "https://avatars.githubusercontent.com/u/162054?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nmathewson", "html_url": "https://github.com/nmathewson", "followers_url": "https://api.github.com/users/nmathewson/followers", "following_url": "https://api.github.com/users/nmathewson/following{/other_user}", "gists_url": "https://api.github.com/users/nmathewson/gists{/gist_id}", "starred_url": "https://api.github.com/users/nmathewson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nmathewson/subscriptions", "organizations_url": "https://api.github.com/users/nmathewson/orgs", "repos_url": "https://api.github.com/users/nmathewson/repos", "events_url": "https://api.github.com/users/nmathewson/events{/privacy}", "received_events_url": "https://api.github.com/users/nmathewson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eff589afc83e21a03a168497bbab6b4dfbb4ef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eff589afc83e21a03a168497bbab6b4dfbb4ef6", "html_url": "https://github.com/rust-lang/rust/commit/0eff589afc83e21a03a168497bbab6b4dfbb4ef6"}], "stats": {"total": 202, "additions": 181, "deletions": 21}, "files": [{"sha": "79a7ec92071c0068a33d1e7a0bf9f4cd0df38ba1", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65d1f83d2c593c7997b4fe781814eb0fb69272e9/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/65d1f83d2c593c7997b4fe781814eb0fb69272e9/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=65d1f83d2c593c7997b4fe781814eb0fb69272e9", "patch": "@@ -47,7 +47,9 @@ itertools = \"0.10\"\n quote = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n syn = { version = \"1.0\", features = [\"full\"] }\n+futures = \"0.3\"\n parking_lot = \"0.11.2\"\n+tokio = { version = \"1\", features = [\"io-util\"] }\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }"}, {"sha": "8afd8472db7ab30c40436f72f91d14257f8e6632", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/65d1f83d2c593c7997b4fe781814eb0fb69272e9/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65d1f83d2c593c7997b4fe781814eb0fb69272e9/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=65d1f83d2c593c7997b4fe781814eb0fb69272e9", "patch": "@@ -17,10 +17,17 @@ declare_clippy_lint! {\n     /// partial-write/read, use\n     /// `write_all`/`read_exact` instead.\n     ///\n+    /// When working with asynchronous code (either with the `futures`\n+    /// crate or with `tokio`), a similar issue exists for\n+    /// `AsyncWriteExt::write()` and `AsyncReadExt::read()` : these\n+    /// functions are also not guaranteed to process the entire\n+    /// buffer.  Your code should either handle partial-writes/reads, or\n+    /// call the `write_all`/`read_exact` methods on those traits instead.\n+    ///\n     /// ### Known problems\n     /// Detects only common patterns.\n     ///\n-    /// ### Example\n+    /// ### Examples\n     /// ```rust,ignore\n     /// use std::io;\n     /// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n@@ -68,6 +75,23 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n     }\n }\n \n+/// If `expr` is an (e).await, return the inner expression \"e\" that's being\n+/// waited on.  Otherwise return None.\n+fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n+    if let hir::ExprKind::Match(expr, _, hir::MatchSource::AwaitDesugar) = expr.kind {\n+        if let hir::ExprKind::Call(func, [ref arg_0, ..]) = expr.kind {\n+            if matches!(\n+                func.kind,\n+                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::IntoFutureIntoFuture, ..))\n+            ) {\n+                return Some(arg_0);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n     while let hir::ExprKind::MethodCall(path, _, args, _) = call.kind {\n@@ -77,30 +101,61 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n             break;\n         }\n     }\n-    check_method_call(cx, call, expr);\n+\n+    if let Some(call) = try_remove_await(call) {\n+        check_method_call(cx, call, expr, true);\n+    } else {\n+        check_method_call(cx, call, expr, false);\n+    }\n }\n \n-fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n+fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n     if let hir::ExprKind::MethodCall(path, _, _, _) = call.kind {\n         let symbol = path.ident.as_str();\n-        let read_trait = match_trait_method(cx, call, &paths::IO_READ);\n-        let write_trait = match_trait_method(cx, call, &paths::IO_WRITE);\n+        let read_trait = if is_await {\n+            match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n+                || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n+        } else {\n+            match_trait_method(cx, call, &paths::IO_READ)\n+        };\n+        let write_trait = if is_await {\n+            match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n+                || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n+        } else {\n+            match_trait_method(cx, call, &paths::IO_WRITE)\n+        };\n \n-        match (read_trait, write_trait, symbol) {\n-            (true, _, \"read\") => span_lint(\n+        match (read_trait, write_trait, symbol, is_await) {\n+            (true, _, \"read\", false) => span_lint(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n                 \"read amount is not handled. Use `Read::read_exact` instead\",\n             ),\n-            (true, _, \"read_vectored\") => span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"read amount is not handled\"),\n-            (_, true, \"write\") => span_lint(\n+            (true, _, \"read\", true) => span_lint(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"read amount is not handled. Use `AsyncReadExt::read_exact` instead\",\n+            ),\n+            (true, _, \"read_vectored\", _) => {\n+                span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"read amount is not handled\");\n+            },\n+            (_, true, \"write\", false) => span_lint(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n                 \"written amount is not handled. Use `Write::write_all` instead\",\n             ),\n-            (_, true, \"write_vectored\") => span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"written amount is not handled\"),\n+            (_, true, \"write\", true) => span_lint(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"written amount is not handled. Use `AsyncWriteExt::write_all` instead\",\n+            ),\n+            (_, true, \"write_vectored\", _) => {\n+                span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"written amount is not handled\");\n+            },\n             _ => (),\n         }\n     }"}, {"sha": "aa3b3af2356700348dda96075fd136ae55b1101c", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/65d1f83d2c593c7997b4fe781814eb0fb69272e9/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65d1f83d2c593c7997b4fe781814eb0fb69272e9/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=65d1f83d2c593c7997b4fe781814eb0fb69272e9", "patch": "@@ -64,6 +64,10 @@ pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"From\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const FUTURES_IO_ASYNCREADEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncReadExt\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWriteExt\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n@@ -194,6 +198,10 @@ pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const TOKIO_IO_ASYNCREADEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_read_ext\", \"AsyncReadExt\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const TOKIO_IO_ASYNCWRITEEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_write_ext\", \"AsyncWriteExt\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];"}, {"sha": "d602d2042ee7fd30f6255eebd293993abc95c77a", "filename": "tests/compile-test.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65d1f83d2c593c7997b4fe781814eb0fb69272e9/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65d1f83d2c593c7997b4fe781814eb0fb69272e9/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=65d1f83d2c593c7997b4fe781814eb0fb69272e9", "patch": "@@ -21,13 +21,15 @@ const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal-lints\");\n static TEST_DEPENDENCIES: &[&str] = &[\n     \"clippy_utils\",\n     \"derive_new\",\n+    \"futures\",\n     \"if_chain\",\n     \"itertools\",\n     \"quote\",\n     \"regex\",\n     \"serde\",\n     \"serde_derive\",\n     \"syn\",\n+    \"tokio\",\n     \"parking_lot\",\n ];\n \n@@ -38,6 +40,8 @@ extern crate clippy_utils;\n #[allow(unused_extern_crates)]\n extern crate derive_new;\n #[allow(unused_extern_crates)]\n+extern crate futures;\n+#[allow(unused_extern_crates)]\n extern crate if_chain;\n #[allow(unused_extern_crates)]\n extern crate itertools;\n@@ -47,6 +51,8 @@ extern crate parking_lot;\n extern crate quote;\n #[allow(unused_extern_crates)]\n extern crate syn;\n+#[allow(unused_extern_crates)]\n+extern crate tokio;\n \n /// Produces a string with an `--extern` flag for all UI test crate\n /// dependencies."}, {"sha": "4b059558173fb783044655ef7358f968cd633d88", "filename": "tests/ui/unused_io_amount.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/65d1f83d2c593c7997b4fe781814eb0fb69272e9/tests%2Fui%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65d1f83d2c593c7997b4fe781814eb0fb69272e9/tests%2Fui%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_io_amount.rs?ref=65d1f83d2c593c7997b4fe781814eb0fb69272e9", "patch": "@@ -1,6 +1,8 @@\n #![allow(dead_code)]\n #![warn(clippy::unused_io_amount)]\n \n+extern crate futures;\n+use futures::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};\n use std::io::{self, Read};\n \n fn question_mark<T: io::Read + io::Write>(s: &mut T) -> io::Result<()> {\n@@ -61,4 +63,55 @@ fn combine_or(file: &str) -> Result<(), Error> {\n     Ok(())\n }\n \n+async fn bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n+    w.write(b\"hello world\").await.unwrap();\n+}\n+\n+async fn bad_async_read<R: AsyncRead + Unpin>(r: &mut R) {\n+    let mut buf = [0u8; 0];\n+    r.read(&mut buf[..]).await.unwrap();\n+}\n+\n+async fn io_not_ignored_async_write<W: AsyncWrite + Unpin>(mut w: W) {\n+    // Here we're forgetting to await the future, so we should get a\n+    // warning about _that_ (or we would, if it were enabled), but we\n+    // won't get one about ignoring the return value.\n+    w.write(b\"hello world\");\n+}\n+\n+fn bad_async_write_closure<W: AsyncWrite + Unpin + 'static>(w: W) -> impl futures::Future<Output = io::Result<()>> {\n+    let mut w = w;\n+    async move {\n+        w.write(b\"hello world\").await?;\n+        Ok(())\n+    }\n+}\n+\n+async fn async_read_nested_or<R: AsyncRead + Unpin>(r: &mut R, do_it: bool) -> Result<[u8; 1], Error> {\n+    let mut buf = [0u8; 1];\n+    if do_it {\n+        r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n+    }\n+    Ok(buf)\n+}\n+\n+use tokio::io::{AsyncRead as TokioAsyncRead, AsyncReadExt as _, AsyncWrite as TokioAsyncWrite, AsyncWriteExt as _};\n+\n+async fn bad_async_write_tokio<W: TokioAsyncWrite + Unpin>(w: &mut W) {\n+    w.write(b\"hello world\").await.unwrap();\n+}\n+\n+async fn bad_async_read_tokio<R: TokioAsyncRead + Unpin>(r: &mut R) {\n+    let mut buf = [0u8; 0];\n+    r.read(&mut buf[..]).await.unwrap();\n+}\n+\n+async fn undetected_bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n+    // It would be good to detect this case some day, but the current lint\n+    // doesn't handle it. (The documentation says that this lint \"detects\n+    // only common patterns\".)\n+    let future = w.write(b\"Hello world\");\n+    future.await.unwrap();\n+}\n+\n fn main() {}"}, {"sha": "3852d0622d6a540f2505a850e6e6cc135219fb40", "filename": "tests/ui/unused_io_amount.stderr", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/65d1f83d2c593c7997b4fe781814eb0fb69272e9/tests%2Fui%2Funused_io_amount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65d1f83d2c593c7997b4fe781814eb0fb69272e9/tests%2Fui%2Funused_io_amount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_io_amount.stderr?ref=65d1f83d2c593c7997b4fe781814eb0fb69272e9", "patch": "@@ -1,61 +1,61 @@\n error: written amount is not handled. Use `Write::write_all` instead\n-  --> $DIR/unused_io_amount.rs:7:5\n+  --> $DIR/unused_io_amount.rs:9:5\n    |\n LL |     s.write(b\"test\")?;\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unused-io-amount` implied by `-D warnings`\n \n error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:9:5\n+  --> $DIR/unused_io_amount.rs:11:5\n    |\n LL |     s.read(&mut buf)?;\n    |     ^^^^^^^^^^^^^^^^^\n \n error: written amount is not handled. Use `Write::write_all` instead\n-  --> $DIR/unused_io_amount.rs:14:5\n+  --> $DIR/unused_io_amount.rs:16:5\n    |\n LL |     s.write(b\"test\").unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:16:5\n+  --> $DIR/unused_io_amount.rs:18:5\n    |\n LL |     s.read(&mut buf).unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: read amount is not handled\n-  --> $DIR/unused_io_amount.rs:20:5\n+  --> $DIR/unused_io_amount.rs:22:5\n    |\n LL |     s.read_vectored(&mut [io::IoSliceMut::new(&mut [])])?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: written amount is not handled\n-  --> $DIR/unused_io_amount.rs:21:5\n+  --> $DIR/unused_io_amount.rs:23:5\n    |\n LL |     s.write_vectored(&[io::IoSlice::new(&[])])?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:28:5\n+  --> $DIR/unused_io_amount.rs:30:5\n    |\n LL |     reader.read(&mut result).ok()?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:37:5\n+  --> $DIR/unused_io_amount.rs:39:5\n    |\n LL |     reader.read(&mut result).or_else(|err| Err(err))?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:49:5\n+  --> $DIR/unused_io_amount.rs:51:5\n    |\n LL |     reader.read(&mut result).or(Err(Error::Kind))?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:56:5\n+  --> $DIR/unused_io_amount.rs:58:5\n    |\n LL | /     reader\n LL | |         .read(&mut result)\n@@ -64,5 +64,41 @@ LL | |         .or(Err(Error::Kind))\n LL | |         .expect(\"error\");\n    | |________________________^\n \n-error: aborting due to 10 previous errors\n+error: written amount is not handled. Use `AsyncWriteExt::write_all` instead\n+  --> $DIR/unused_io_amount.rs:67:5\n+   |\n+LL |     w.write(b\"hello world\").await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: read amount is not handled. Use `AsyncReadExt::read_exact` instead\n+  --> $DIR/unused_io_amount.rs:72:5\n+   |\n+LL |     r.read(&mut buf[..]).await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: written amount is not handled. Use `AsyncWriteExt::write_all` instead\n+  --> $DIR/unused_io_amount.rs:85:9\n+   |\n+LL |         w.write(b\"hello world\").await?;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: read amount is not handled. Use `AsyncReadExt::read_exact` instead\n+  --> $DIR/unused_io_amount.rs:93:9\n+   |\n+LL |         r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: written amount is not handled. Use `AsyncWriteExt::write_all` instead\n+  --> $DIR/unused_io_amount.rs:101:5\n+   |\n+LL |     w.write(b\"hello world\").await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: read amount is not handled. Use `AsyncReadExt::read_exact` instead\n+  --> $DIR/unused_io_amount.rs:106:5\n+   |\n+LL |     r.read(&mut buf[..]).await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 16 previous errors\n "}]}