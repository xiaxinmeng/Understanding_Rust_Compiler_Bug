{"sha": "8bd84653af8aedacff38bb55f3d8cfd3ffe8d883", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZDg0NjUzYWY4YWVkYWNmZjM4YmI1NWYzZDhjZmQzZmZlOGQ4ODM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-11-14T05:16:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-14T05:16:26Z"}, "message": "Rollup merge of #66369 - tmiasko:compiletest-stamp, r=Mark-Simulacrum\n\ncompiletest: Obtain timestamps for common inputs only once\n\nObtain timestamps for common inputs (e.g., libraries in run-lib path, or\nsources in `src/tool/compiletest/`) only once and reuse the result,\ninstead of repeating the work for each test case.", "tree": {"sha": "15e3aa19a31bd7a4caa9b6387656f23bde1aaa71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15e3aa19a31bd7a4caa9b6387656f23bde1aaa71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bd84653af8aedacff38bb55f3d8cfd3ffe8d883", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzOMqCRBK7hj4Ov3rIwAAdHIIAIRwr5GTeXGSA+2aScY0cGSG\nzdZc1dtl0JAfcjCuKQS52tT5Nd+CyxMXJuIeGMtHm2QZN3hmN+ogXAbZ8Hleq/OP\nVdKeVP053GyKNr6/TQOzwkJlxSuSEk4WT5JzqcoYBNFSF5RrSW9Xw4PDZhUg1bz4\nW/QOCRvJDdfmZjhoweLbT136+B36UE9nzQioo5n34JN3E1U+CtXU7HfnaGRO7GXY\nnjk7FpmnXSArSBWsx92XNFIfZqbaOLVwT2CjF7G4GlyYhmxu2FKjj8K9CW4XHrN8\nNyJn1481lf5Zct76CYpVDxU334HQdH+fYsw/DQ9lQis8QyjQ7RYU5im6qqWhKlo=\n=i/ui\n-----END PGP SIGNATURE-----\n", "payload": "tree 15e3aa19a31bd7a4caa9b6387656f23bde1aaa71\nparent 2d453b3907e9111265a771e966a0486d76876719\nparent 1ac470f70c9de77cbd5fd6e5c5a624e55af81fad\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1573708586 +0900\ncommitter GitHub <noreply@github.com> 1573708586 +0900\n\nRollup merge of #66369 - tmiasko:compiletest-stamp, r=Mark-Simulacrum\n\ncompiletest: Obtain timestamps for common inputs only once\n\nObtain timestamps for common inputs (e.g., libraries in run-lib path, or\nsources in `src/tool/compiletest/`) only once and reuse the result,\ninstead of repeating the work for each test case.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bd84653af8aedacff38bb55f3d8cfd3ffe8d883", "html_url": "https://github.com/rust-lang/rust/commit/8bd84653af8aedacff38bb55f3d8cfd3ffe8d883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bd84653af8aedacff38bb55f3d8cfd3ffe8d883/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d453b3907e9111265a771e966a0486d76876719", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d453b3907e9111265a771e966a0486d76876719", "html_url": "https://github.com/rust-lang/rust/commit/2d453b3907e9111265a771e966a0486d76876719"}, {"sha": "1ac470f70c9de77cbd5fd6e5c5a624e55af81fad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac470f70c9de77cbd5fd6e5c5a624e55af81fad", "html_url": "https://github.com/rust-lang/rust/commit/1ac470f70c9de77cbd5fd6e5c5a624e55af81fad"}], "stats": {"total": 162, "additions": 90, "deletions": 72}, "files": [{"sha": "15f8abd75d59a9c0061f3cb6cbf1fc065892c7e5", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 90, "deletions": 72, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8bd84653af8aedacff38bb55f3d8cfd3ffe8d883/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd84653af8aedacff38bb55f3d8cfd3ffe8d883/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=8bd84653af8aedacff38bb55f3d8cfd3ffe8d883", "patch": "@@ -574,22 +574,59 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n \n pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {:?}\", config.src_base.display());\n+    let inputs = common_inputs_stamp(config);\n     let mut tests = Vec::new();\n     collect_tests_from_dir(\n         config,\n         &config.src_base,\n         &config.src_base,\n         &PathBuf::new(),\n+        &inputs,\n         &mut tests,\n     ).expect(&format!(\"Could not read tests from {}\", config.src_base.display()));\n     tests\n }\n \n+/// Returns a stamp constructed from input files common to all test cases.\n+fn common_inputs_stamp(config: &Config) -> Stamp {\n+    let rust_src_dir = config\n+        .find_rust_src_root()\n+        .expect(\"Could not find Rust source root\");\n+\n+    let mut stamp = Stamp::from_path(&config.rustc_path);\n+\n+    // Relevant pretty printer files\n+    let pretty_printer_files = [\n+        \"src/etc/debugger_pretty_printers_common.py\",\n+        \"src/etc/gdb_load_rust_pretty_printers.py\",\n+        \"src/etc/gdb_rust_pretty_printing.py\",\n+        \"src/etc/lldb_batchmode.py\",\n+        \"src/etc/lldb_rust_formatters.py\",\n+    ];\n+    for file in &pretty_printer_files {\n+        let path = rust_src_dir.join(file);\n+        stamp.add_path(&path);\n+    }\n+\n+    stamp.add_dir(&config.run_lib_path);\n+\n+    if let Some(ref rustdoc_path) = config.rustdoc_path {\n+        stamp.add_path(&rustdoc_path);\n+        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n+    }\n+\n+    // Compiletest itself.\n+    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n+\n+    stamp\n+}\n+\n fn collect_tests_from_dir(\n     config: &Config,\n     base: &Path,\n     dir: &Path,\n     relative_dir_path: &Path,\n+    inputs: &Stamp,\n     tests: &mut Vec<test::TestDescAndFn>,\n ) -> io::Result<()> {\n     // Ignore directories that contain a file named `compiletest-ignore-dir`.\n@@ -602,7 +639,7 @@ fn collect_tests_from_dir(\n             file: dir.to_path_buf(),\n             relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n         };\n-        tests.extend(make_test(config, &paths));\n+        tests.extend(make_test(config, &paths, inputs));\n         return Ok(());\n     }\n \n@@ -627,12 +664,14 @@ fn collect_tests_from_dir(\n                 file: file_path,\n                 relative_dir: relative_dir_path.to_path_buf(),\n             };\n-            tests.extend(make_test(config, &paths))\n+            tests.extend(make_test(config, &paths, inputs))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(config, base, &file_path, &relative_file_path, tests)?;\n+                collect_tests_from_dir(\n+                    config, base, &file_path, &relative_file_path,\n+                    inputs, tests)?;\n             }\n         } else {\n             debug!(\"found other file/directory: {:?}\", file_path.display());\n@@ -655,7 +694,7 @@ pub fn is_test(file_name: &OsString) -> bool {\n     !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n }\n \n-pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAndFn> {\n+fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test::TestDescAndFn> {\n     let early_props = if config.mode == Mode::RunMake {\n         // Allow `ignore` directives to be in the Makefile.\n         EarlyProps::from_file(config, &testpaths.file.join(\"Makefile\"))\n@@ -685,19 +724,21 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAn\n     revisions\n         .into_iter()\n         .map(|revision| {\n-            // Debugging emscripten code doesn't make sense today\n             let ignore = early_props.ignore == Ignore::Ignore\n-                || !up_to_date(\n-                    config,\n-                    testpaths,\n-                    &early_props,\n-                    revision.map(|s| s.as_str()),\n-                )\n+                // Debugging emscripten code doesn't make sense today\n                 || ((config.mode == DebugInfoGdbLldb || config.mode == DebugInfoCdb ||\n                      config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n                     && config.target.contains(\"emscripten\"))\n                 || (config.mode == DebugInfoGdb && !early_props.ignore.can_run_gdb())\n-                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb());\n+                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb())\n+                // Ignore tests that already run and are up to date with respect to inputs.\n+                || is_up_to_date(\n+                    config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                    inputs,\n+                );\n             test::TestDescAndFn {\n                 desc: test::TestDesc {\n                     name: make_test_name(config, testpaths, revision),\n@@ -716,98 +757,75 @@ fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> Path\n     output_base_dir(config, testpaths, revision).join(\"stamp\")\n }\n \n-fn up_to_date(\n+fn is_up_to_date(\n     config: &Config,\n     testpaths: &TestPaths,\n     props: &EarlyProps,\n     revision: Option<&str>,\n+    inputs: &Stamp,\n ) -> bool {\n     let stamp_name = stamp(config, testpaths, revision);\n     // Check hash.\n     let contents = match fs::read_to_string(&stamp_name) {\n         Ok(f) => f,\n         Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n-        Err(_) => return true,\n+        Err(_) => return false,\n     };\n     let expected_hash = runtest::compute_stamp_hash(config);\n     if contents != expected_hash {\n-        return true;\n+        return false;\n     }\n \n     // Check timestamps.\n-    let rust_src_dir = config\n-        .find_rust_src_root()\n-        .expect(\"Could not find Rust source root\");\n-    let stamp = Stamp::from_path(&stamp_name);\n-    let mut inputs = vec![Stamp::from_path(&testpaths.file), Stamp::from_path(&config.rustc_path)];\n-    inputs.extend(\n-        props\n-            .aux\n-            .iter()\n-            .map(|aux| {\n-                Stamp::from_path(&testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux))\n-            }),\n-    );\n-    // Relevant pretty printer files\n-    let pretty_printer_files = [\n-        \"src/etc/debugger_pretty_printers_common.py\",\n-        \"src/etc/gdb_load_rust_pretty_printers.py\",\n-        \"src/etc/gdb_rust_pretty_printing.py\",\n-        \"src/etc/lldb_batchmode.py\",\n-        \"src/etc/lldb_rust_formatters.py\",\n-    ];\n-    inputs.extend(pretty_printer_files.iter().map(|pretty_printer_file| {\n-        Stamp::from_path(&rust_src_dir.join(pretty_printer_file))\n-    }));\n-    inputs.extend(Stamp::from_dir(&config.run_lib_path));\n-    if let Some(ref rustdoc_path) = config.rustdoc_path {\n-        inputs.push(Stamp::from_path(&rustdoc_path));\n-        inputs.push(Stamp::from_path(&rust_src_dir.join(\"src/etc/htmldocck.py\")));\n+    let mut inputs = inputs.clone();\n+    inputs.add_path(&testpaths.file);\n+\n+    for aux in &props.aux {\n+        let path = testpaths.file.parent()\n+            .unwrap()\n+            .join(\"auxiliary\")\n+            .join(aux);\n+        inputs.add_path(&path);\n     }\n \n     // UI test files.\n-    inputs.extend(UI_EXTENSIONS.iter().map(|extension| {\n+    for extension in UI_EXTENSIONS {\n         let path = &expected_output_path(testpaths, revision, &config.compare_mode, extension);\n-        Stamp::from_path(path)\n-    }));\n-\n-    // Compiletest itself.\n-    inputs.extend(Stamp::from_dir(&rust_src_dir.join(\"src/tools/compiletest/\")));\n+        inputs.add_path(path);\n+    }\n \n-    inputs.iter().any(|input| input > &stamp)\n+    inputs < Stamp::from_path(&stamp_name)\n }\n \n-#[derive(Debug, PartialEq, PartialOrd, Ord, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n struct Stamp {\n     time: SystemTime,\n-    file: PathBuf,\n }\n \n impl Stamp {\n-    fn from_path(p: &Path) -> Self {\n-        let time = fs::metadata(p)\n+    fn from_path(path: &Path) -> Self {\n+        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n+        stamp.add_path(path);\n+        stamp\n+    }\n+\n+    fn add_path(&mut self, path: &Path) {\n+        let modified = fs::metadata(path)\n             .and_then(|metadata| metadata.modified())\n             .unwrap_or(SystemTime::UNIX_EPOCH);\n-\n-        Stamp {\n-            time,\n-            file: p.into(),\n-        }\n+        self.time = self.time.max(modified);\n     }\n \n-    fn from_dir(path: &Path) -> impl Iterator<Item = Stamp> {\n-        WalkDir::new(path)\n-            .into_iter()\n-            .map(|entry| entry.unwrap())\n-            .filter(|entry| entry.file_type().is_file())\n-            .map(|entry| {\n-                let time = (|| -> io::Result<_> { entry.metadata()?.modified() })();\n-\n-                Stamp {\n-                    time: time.unwrap_or(SystemTime::UNIX_EPOCH),\n-                    file: entry.path().into(),\n-                }\n-            })\n+    fn add_dir(&mut self, path: &Path) {\n+        for entry in WalkDir::new(path) {\n+            let entry = entry.unwrap();\n+            if entry.file_type().is_file() {\n+                let modified = entry.metadata().ok()\n+                    .and_then(|metadata| metadata.modified().ok())\n+                    .unwrap_or(SystemTime::UNIX_EPOCH);\n+                self.time = self.time.max(modified);\n+            }\n+        }\n     }\n }\n "}]}