{"sha": "75c82b4dd8152562ff2056f2172b20aa9c46def2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YzgyYjRkZDgxNTI1NjJmZjIwNTZmMjE3MmIyMGFhOWM0NmRlZjI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-27T19:13:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-09-15T12:23:14Z"}, "message": "drop redundant ParamEnv, and avoid constructing InternVisitor without visiting", "tree": {"sha": "a49a3ec5ca5de1c98f21711203a8be79ad792c4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a49a3ec5ca5de1c98f21711203a8be79ad792c4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75c82b4dd8152562ff2056f2172b20aa9c46def2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75c82b4dd8152562ff2056f2172b20aa9c46def2", "html_url": "https://github.com/rust-lang/rust/commit/75c82b4dd8152562ff2056f2172b20aa9c46def2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75c82b4dd8152562ff2056f2172b20aa9c46def2/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b8693eff85d39d7b836fa45cdcf30507d7f8731", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b8693eff85d39d7b836fa45cdcf30507d7f8731", "html_url": "https://github.com/rust-lang/rust/commit/7b8693eff85d39d7b836fa45cdcf30507d7f8731"}], "stats": {"total": 176, "additions": 95, "deletions": 81}, "files": [{"sha": "3f53f842f314f830ead99690074e4cc70873a653", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75c82b4dd8152562ff2056f2172b20aa9c46def2/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c82b4dd8152562ff2056f2172b20aa9c46def2/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=75c82b4dd8152562ff2056f2172b20aa9c46def2", "patch": "@@ -134,9 +134,8 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n     let tcx = ecx.tcx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n@@ -162,7 +161,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         ecx,\n         cid.instance.def_id(),\n         ret,\n-        param_env,\n     )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n@@ -658,7 +656,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(\n-        |body| eval_body_using_ecx(&mut ecx, cid, body, key.param_env)\n+        |body| eval_body_using_ecx(&mut ecx, cid, body)\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.ptr.assert_ptr().alloc_id,"}, {"sha": "b657a33db516ee23dbb79ad47dc937637bca234d", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 93, "deletions": 77, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/75c82b4dd8152562ff2056f2172b20aa9c46def2/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c82b4dd8152562ff2056f2172b20aa9c46def2/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=75c82b4dd8152562ff2056f2172b20aa9c46def2", "patch": "@@ -3,7 +3,7 @@\n //! After a const evaluation has computed a value, before we destroy the const evaluator's session\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n \n-use rustc::ty::{Ty, ParamEnv, self};\n+use rustc::ty::{Ty, self};\n use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -18,10 +18,10 @@ use super::{\n use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n \n struct InternVisitor<'rt, 'mir, 'tcx> {\n-    /// previously encountered safe references\n-    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    /// The ectx from which we intern.\n     ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n-    param_env: ParamEnv<'tcx>,\n+    /// Previously encountered safe references.\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n     /// The root node of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n@@ -53,74 +53,93 @@ enum InternMode {\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n+/// Intern an allocation without looking at its children.\n+/// `mode` is the mode of the environment where we found this pointer.\n+/// `mutablity` is the mutability of the place to be interned; even if that says\n+/// `immutable` things might become mutable if `ty` is not frozen.\n+fn intern_shallow<'rt, 'mir, 'tcx>(\n+    ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n+    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n+    mode: InternMode,\n+    alloc_id: AllocId,\n+    mutability: Mutability,\n+    ty: Option<Ty<'tcx>>,\n+) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+    trace!(\n+        \"InternVisitor::intern {:?} with {:?}\",\n+        alloc_id, mutability,\n+    );\n+    // remove allocation\n+    let tcx = ecx.tcx;\n+    let memory = ecx.memory_mut();\n+    let (kind, mut alloc) = match memory.alloc_map.remove(&alloc_id) {\n+        Some(entry) => entry,\n+        None => {\n+            // Pointer not found in local memory map. It is either a pointer to the global\n+            // map, or dangling.\n+            // If the pointer is dangling (neither in local nor global memory), we leave it\n+            // to validation to error. The `delay_span_bug` ensures that we don't forget such\n+            // a check in validation.\n+            if tcx.alloc_map.lock().get(alloc_id).is_none() {\n+                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n+            }\n+            // treat dangling pointers like other statics\n+            // just to stop trying to recurse into them\n+            return Ok(Some(IsStaticOrFn));\n+        },\n+    };\n+    // This match is just a canary for future changes to `MemoryKind`, which most likely need\n+    // changes in this function.\n+    match kind {\n+        MemoryKind::Stack | MemoryKind::Vtable => {},\n+    }\n+    // Set allocation mutability as appropriate. This is used by LLVM to put things into\n+    // read-only memory, and also by Miri when evluating other constants/statics that\n+    // access this one.\n+    if mode == InternMode::Static {\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(\n+            ecx.tcx.tcx,\n+            ecx.param_env,\n+            ecx.tcx.span,\n+        ));\n+        // For statics, allocation mutability is the combination of the place mutability and\n+        // the type mutability.\n+        // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n+        if mutability == Mutability::Immutable && frozen {\n+            alloc.mutability = Mutability::Immutable;\n+        } else {\n+            // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n+            assert_eq!(alloc.mutability, Mutability::Mutable);\n+        }\n+    } else {\n+        // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n+        // But we still intern that as immutable as the memory cannot be changed once the\n+        // initial value was computed.\n+        // Constants are never mutable.\n+        alloc.mutability = Mutability::Immutable;\n+    };\n+    // link the alloc id to the actual allocation\n+    let alloc = tcx.intern_const_alloc(alloc);\n+    leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n+    tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+    Ok(None)\n+}\n+\n impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n-    /// Intern an allocation without looking at its children.\n-    /// `mutablity` is the mutability of the place to be interned; even if that says\n-    /// `immutable` things might become mutable if `ty` is not frozen.\n     fn intern_shallow(\n         &mut self,\n         alloc_id: AllocId,\n         mutability: Mutability,\n         ty: Option<Ty<'tcx>>,\n     ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-        trace!(\n-            \"InternVisitor::intern {:?} with {:?}\",\n-            alloc_id, mutability,\n-        );\n-        // remove allocation\n-        let tcx = self.ecx.tcx;\n-        let memory = self.ecx.memory_mut();\n-        let (kind, mut alloc) = match memory.alloc_map.remove(&alloc_id) {\n-            Some(entry) => entry,\n-            None => {\n-                // Pointer not found in local memory map. It is either a pointer to the global\n-                // map, or dangling.\n-                // If the pointer is dangling (neither in local nor global memory), we leave it\n-                // to validation to error. The `delay_span_bug` ensures that we don't forget such\n-                // a check in validation.\n-                if tcx.alloc_map.lock().get(alloc_id).is_none() {\n-                    tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n-                }\n-                // treat dangling pointers like other statics\n-                // just to stop trying to recurse into them\n-                return Ok(Some(IsStaticOrFn));\n-            },\n-        };\n-        // This match is just a canary for future changes to `MemoryKind`, which most likely need\n-        // changes in this function.\n-        match kind {\n-            MemoryKind::Stack | MemoryKind::Vtable => {},\n-        }\n-        // Set allocation mutability as appropriate. This is used by LLVM to put things into\n-        // read-only memory, and also by Miri when evluating other constants/statics that\n-        // access this one.\n-        if self.mode == InternMode::Static {\n-            let frozen = ty.map_or(true, |ty| ty.is_freeze(\n-                self.ecx.tcx.tcx,\n-                self.param_env,\n-                self.ecx.tcx.span,\n-            ));\n-            // For statics, allocation mutability is the combination of the place mutability and\n-            // the type mutability.\n-            // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n-            if mutability == Mutability::Immutable && frozen {\n-                alloc.mutability = Mutability::Immutable;\n-            } else {\n-                // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n-                assert_eq!(alloc.mutability, Mutability::Mutable);\n-            }\n-        } else {\n-            // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n-            // But we still intern that as immutable as the memory cannot be changed once the\n-            // initial value was computed.\n-            // Constants are never mutable.\n-            alloc.mutability = Mutability::Immutable;\n-        };\n-        // link the alloc id to the actual allocation\n-        let alloc = tcx.intern_const_alloc(alloc);\n-        self.leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-        tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n-        Ok(None)\n+        intern_shallow(\n+            self.ecx,\n+            self.leftover_relocations,\n+            self.mode,\n+            alloc_id,\n+            mutability,\n+            ty,\n+        )\n     }\n }\n \n@@ -171,7 +190,8 @@ for\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n                 if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.param_env).sty\n+                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                        referenced_ty, self.ecx.param_env).sty\n                 {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n@@ -203,7 +223,7 @@ for\n                     (InternMode::Const, hir::Mutability::MutMutable) => {\n                         match referenced_ty.sty {\n                             ty::Array(_, n)\n-                                if n.eval_usize(self.ecx.tcx.tcx, self.param_env) == 0 => {}\n+                                if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n                                 if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n@@ -246,9 +266,6 @@ pub fn intern_const_alloc_recursive(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     def_id: DefId,\n     ret: MPlaceTy<'tcx>,\n-    // FIXME(oli-obk): can we scrap the param env? I think we can, the final value of a const eval\n-    // must always be monomorphic, right?\n-    param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     // this `mutability` is the mutability of the place, ignoring the type\n@@ -264,22 +281,21 @@ pub fn intern_const_alloc_recursive(\n     let leftover_relocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n-    InternVisitor {\n-        ref_tracking: &mut ref_tracking,\n+    intern_shallow(\n         ecx,\n-        mode: base_intern_mode,\n         leftover_relocations,\n-        param_env,\n-        mutability: base_mutability,\n-    }.intern_shallow(ret.ptr.to_ptr()?.alloc_id, base_mutability, Some(ret.layout.ty))?;\n+        base_intern_mode,\n+        ret.ptr.to_ptr()?.alloc_id,\n+        base_mutability,\n+        Some(ret.layout.ty)\n+    )?;\n \n     while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n         let interned = InternVisitor {\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n             leftover_relocations,\n-            param_env,\n             mutability,\n         }.visit_value(mplace);\n         if let Err(error) = interned {"}]}