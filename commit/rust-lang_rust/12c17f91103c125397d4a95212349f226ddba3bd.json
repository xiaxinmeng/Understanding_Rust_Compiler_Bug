{"sha": "12c17f91103c125397d4a95212349f226ddba3bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzE3ZjkxMTAzYzEyNTM5N2Q0YTk1MjEyMzQ5ZjIyNmRkYmEzYmQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-02T16:21:41Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-14T22:41:28Z"}, "message": "move overflow error reporting out of the query\n\nthat allows the error reporting to contain the span.", "tree": {"sha": "fc13f59894b04e2246602a452945576304f00a55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc13f59894b04e2246602a452945576304f00a55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c17f91103c125397d4a95212349f226ddba3bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c17f91103c125397d4a95212349f226ddba3bd", "html_url": "https://github.com/rust-lang/rust/commit/12c17f91103c125397d4a95212349f226ddba3bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c17f91103c125397d4a95212349f226ddba3bd/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "html_url": "https://github.com/rust-lang/rust/commit/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1"}], "stats": {"total": 102, "additions": 73, "deletions": 29}, "files": [{"sha": "175883eb2a73458febddcd9faab1b8d7cf415353", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12c17f91103c125397d4a95212349f226ddba3bd/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c17f91103c125397d4a95212349f226ddba3bd/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=12c17f91103c125397d4a95212349f226ddba3bd", "patch": "@@ -30,7 +30,10 @@ pub struct MethodAutoderefStepsResult<'tcx> {\n     /// The valid autoderef steps that could be find.\n     pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n     /// If Some(T), a type autoderef reported an error on.\n-    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>\n+    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n+    /// If `true`, `steps` has been truncated due to reaching the\n+    /// recursion limit.\n+    pub reached_recursion_limit: bool,\n }\n \n #[derive(Debug)]\n@@ -44,7 +47,7 @@ impl_stable_hash_for!(struct MethodAutoderefBadTy<'tcx> {\n });\n \n impl_stable_hash_for!(struct MethodAutoderefStepsResult<'tcx> {\n-    steps, opt_bad_ty\n+    reached_recursion_limit, steps, opt_bad_ty\n });\n \n impl_stable_hash_for!(struct CandidateStep<'tcx> {"}, {"sha": "d240f45c7d9a459a7da18758531160d0b4e0b880", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/12c17f91103c125397d4a95212349f226ddba3bd/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c17f91103c125397d4a95212349f226ddba3bd/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=12c17f91103c125397d4a95212349f226ddba3bd", "patch": "@@ -14,7 +14,7 @@ use super::method::MethodCallee;\n use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n use rustc::traits::{self, TraitEngine};\n-use rustc::ty::{self, Ty, TraitRef};\n+use rustc::ty::{self, Ty, TyCtxt, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n@@ -39,6 +39,8 @@ pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     at_start: bool,\n     include_raw_pointers: bool,\n     span: Span,\n+    silence_errors: bool,\n+    reached_recursion_limit: bool\n }\n \n impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n@@ -57,24 +59,10 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         if self.steps.len() >= *tcx.sess.recursion_limit.get() {\n-            // We've reached the recursion limit, error gracefully.\n-            let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n-            let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\",\n-                              self.cur_ty);\n-            let error_id = (DiagnosticMessageId::ErrorId(55), Some(self.span), msg);\n-            let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-            if fresh {\n-                struct_span_err!(tcx.sess,\n-                                 self.span,\n-                                 E0055,\n-                                 \"reached the recursion limit while auto-dereferencing `{:?}`\",\n-                                 self.cur_ty)\n-                    .span_label(self.span, \"deref recursion limit reached\")\n-                    .help(&format!(\n-                        \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                        suggested_limit))\n-                    .emit();\n+            if !self.silence_errors {\n+                report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n             }\n+            self.reached_recursion_limit = true;\n             return None;\n         }\n \n@@ -123,6 +111,8 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             obligations: vec![],\n             at_start: true,\n             include_raw_pointers: false,\n+            silence_errors: false,\n+            reached_recursion_limit: false,\n             span,\n         }\n     }\n@@ -240,6 +230,15 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self\n     }\n \n+    pub fn silence_errors(mut self) -> Self {\n+        self.silence_errors = true;\n+        self\n+    }\n+\n+    pub fn reached_recursion_limit(&self) -> bool {\n+        self.reached_recursion_limit\n+    }\n+\n     pub fn finalize(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         fcx.register_predicates(self.into_obligations());\n     }\n@@ -249,6 +248,29 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub fn report_autoderef_recursion_limit_error<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>, span: Span, ty: Ty<'tcx>)\n+{\n+    // We've reached the recursion limit, error gracefully.\n+    let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n+    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\",\n+                      ty);\n+    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n+    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+    if fresh {\n+        struct_span_err!(tcx.sess,\n+                         span,\n+                         E0055,\n+                         \"reached the recursion limit while auto-dereferencing `{:?}`\",\n+                         ty)\n+            .span_label(span, \"deref recursion limit reached\")\n+            .help(&format!(\n+                \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                suggested_limit))\n+            .emit();\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'gcx, 'tcx> {\n         Autoderef::new(self, self.param_env, self.body_id, span, base_ty)"}, {"sha": "29fd9f5f71e8e22686d765fcb705026f1f858586", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/12c17f91103c125397d4a95212349f226ddba3bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c17f91103c125397d4a95212349f226ddba3bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=12c17f91103c125397d4a95212349f226ddba3bd", "patch": "@@ -13,7 +13,7 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n-use check::autoderef::Autoderef;\n+use check::autoderef::{self, Autoderef};\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n@@ -283,19 +283,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         from_unsafe_deref: false,\n                         unsize: false,\n                     }]),\n-                    opt_bad_ty: None\n+                    opt_bad_ty: None,\n+                    reached_recursion_limit: false\n                 }\n             })\n         };\n \n+        // If our autoderef loop had reached the recursion limit,\n+        // report an overflow error, but continue going on with\n+        // the truncated autoderef list.\n+        if steps.reached_recursion_limit {\n+            self.probe(|_| {\n+                let ty = &steps.steps.last().unwrap_or_else(|| {\n+                    span_bug!(span, \"reached the recursion limit in 0 steps?\")\n+                }).self_ty;\n+                let ty = self.probe_instantiate_query_response(span, &orig_values, ty)\n+                    .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n+                autoderef::report_autoderef_recursion_limit_error(self.tcx, span,\n+                                                                  ty.value);\n+            });\n+        }\n+\n+\n         // If we encountered an `_` type or an error type during autoderef, this is\n         // ambiguous.\n-        if let Some(autoderef_bad_ty) = &steps.opt_bad_ty {\n-            let MethodAutoderefBadTy { reached_raw_pointer, ref ty } = **autoderef_bad_ty;\n+        if let Some(bad_ty) = &steps.opt_bad_ty {\n             if is_suggestion.0 {\n                 // Ambiguity was encountered during a suggestion. Just keep going.\n                 debug!(\"ProbeContext: encountered ambiguity in suggestion\");\n-            } else if reached_raw_pointer && !self.tcx.features().arbitrary_self_types {\n+            } else if bad_ty.reached_raw_pointer && !self.tcx.features().arbitrary_self_types {\n                 // this case used to be allowed by the compiler,\n                 // so we do a future-compat lint here for the 2015 edition\n                 // (see https://github.com/rust-lang/rust/issues/46906)\n@@ -314,10 +330,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Encountered a real ambiguity, so abort the lookup. If `ty` is not\n                 // an `Err`, report the right \"type annotations needed\" error pointing\n                 // to it.\n+                let ty = &bad_ty.ty;\n                 let ty = self.probe_instantiate_query_response(span, &orig_values, ty)\n                     .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n-                let t = self.structurally_resolved_type(span, ty.value);\n-                assert_eq!(t, self.tcx.types.err);\n+                let ty = self.structurally_resolved_type(span, ty.value);\n+                assert_eq!(ty, self.tcx.types.err);\n                 return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n                                                                  Vec::new(),\n                                                                  Vec::new(),\n@@ -365,7 +382,8 @@ fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n         let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, DUMMY_SP, self_ty)\n-            .include_raw_pointers();\n+            .include_raw_pointers()\n+            .silence_errors();\n         let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef.by_ref()\n             .map(|(ty, d)| {\n@@ -416,7 +434,8 @@ fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n \n         MethodAutoderefStepsResult {\n             steps: Lrc::new(steps),\n-            opt_bad_ty: opt_bad_ty.map(Lrc::new)\n+            opt_bad_ty: opt_bad_ty.map(Lrc::new),\n+            reached_recursion_limit: autoderef.reached_recursion_limit()\n         }\n     })\n }"}]}