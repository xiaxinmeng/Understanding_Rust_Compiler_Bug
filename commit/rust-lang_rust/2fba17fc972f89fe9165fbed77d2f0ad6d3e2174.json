{"sha": "2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYmExN2ZjOTcyZjg5ZmU5MTY1ZmJlZDc3ZDJmMGFkNmQzZTIxNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-05T03:36:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-05T03:36:31Z"}, "message": "Auto merge of #56837 - arielb1:nonprincipal-trait-objects, r=nikomatsakis\n\nAdd support for trait-objects without a principal\n\nThe hard-error version of #56481 - should be merged after we do something about the `traitobject` crate.\n\nFixes #33140.\nFixes #57057.\n\nr? @nikomatsakis", "tree": {"sha": "4d53cc7f637ccfb8c21ea5c1c113907d96694749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d53cc7f637ccfb8c21ea5c1c113907d96694749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "html_url": "https://github.com/rust-lang/rust/commit/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "244b05db12e47efef4695036974bc25fde13b828", "url": "https://api.github.com/repos/rust-lang/rust/commits/244b05db12e47efef4695036974bc25fde13b828", "html_url": "https://github.com/rust-lang/rust/commit/244b05db12e47efef4695036974bc25fde13b828"}, {"sha": "c213b0db2e8e344c419095450dbbdae71afa8c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/c213b0db2e8e344c419095450dbbdae71afa8c61", "html_url": "https://github.com/rust-lang/rust/commit/c213b0db2e8e344c419095450dbbdae71afa8c61"}], "stats": {"total": 1268, "additions": 815, "deletions": 453}, "files": [{"sha": "3156f17e0c4c5e6b15261e353c1b8a655214c320", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -492,6 +492,7 @@ define_dep_nodes!( <'tcx>\n     [] AdtDefOfItem(DefId),\n     [] ImplTraitRef(DefId),\n     [] ImplPolarity(DefId),\n+    [] Issue33140SelfTy(DefId),\n     [] FnSignature(DefId),\n     [] CoerceUnsizedInfo(DefId),\n "}, {"sha": "40c11695d51e2f67618544b4a1cd47cd871ef39e", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -337,10 +337,6 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.infcx.trait_object_mode()\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"Generalizer\"\n     }"}, {"sha": "60a7eb0d54f8bf7a4ed7c4e3bcab3caaf2eadd72", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -29,10 +29,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_item_substs(&mut self,"}, {"sha": "635a6d00270b7f3ce979c13529122e1159ebff68", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -5,7 +5,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -26,10 +26,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "0b9839f69fa2ad1d86cbf773b1528f37201d5cd0", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -5,7 +5,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -26,10 +26,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "958982545750fb3b34abac5d9f74a7c133bbdbb1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::{self, Span};\n use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n-use ty::relate::{RelateResult, TraitObjectMode};\n+use ty::relate::RelateResult;\n use ty::subst::{Kind, Substs};\n use ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n use ty::{FloatVid, IntVid, TyVid};\n@@ -171,9 +171,6 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n-    // The TraitObjectMode used here,\n-    trait_object_mode: TraitObjectMode,\n-\n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n     // outlive the lifetime 'a\". These constraints derive from\n@@ -465,7 +462,6 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     arena: SyncDroplessArena,\n     interners: Option<CtxtInterners<'tcx>>,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n-    trait_object_mode: TraitObjectMode,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n@@ -475,7 +471,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             arena: SyncDroplessArena::default(),\n             interners: None,\n             fresh_tables: None,\n-            trait_object_mode: TraitObjectMode::NoSquash,\n         }\n     }\n }\n@@ -488,12 +483,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         self\n     }\n \n-    pub fn with_trait_object_mode(mut self, mode: TraitObjectMode) -> Self {\n-        debug!(\"with_trait_object_mode: setting mode to {:?}\", mode);\n-        self.trait_object_mode = mode;\n-        self\n-    }\n-\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -520,7 +509,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n-            trait_object_mode,\n             ref arena,\n             ref mut interners,\n             ref fresh_tables,\n@@ -532,7 +520,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n-                trait_object_mode,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n@@ -614,10 +601,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n-    pub fn trait_object_mode(&self) -> TraitObjectMode {\n-        self.trait_object_mode\n-    }\n-\n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }"}, {"sha": "7671a47135702d9ef74cc98eaae9a4cb3ee23059", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -372,13 +372,6 @@ where\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        // squashing should only be done in coherence, not NLL\n-        assert_eq!(self.infcx.trait_object_mode(),\n-                   relate::TraitObjectMode::NoSquash);\n-        relate::TraitObjectMode::NoSquash\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"nll::subtype\"\n     }\n@@ -693,13 +686,6 @@ where\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        // squashing should only be done in coherence, not NLL\n-        assert_eq!(self.infcx.trait_object_mode(),\n-                   relate::TraitObjectMode::NoSquash);\n-        relate::TraitObjectMode::NoSquash\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"nll::generalizer\"\n     }"}, {"sha": "df76d1d3afb34bd1cf39b464b0fe06d4db13c9d8", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -5,7 +5,7 @@ use traits::Obligation;\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::fold::TypeFoldable;\n-use ty::relate::{self, Cause, Relate, RelateResult, TypeRelation};\n+use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -33,10 +33,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n     for Sub<'combine, 'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "4c7049c3662075442ef9491c0f046327742d31e2", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -11,7 +11,6 @@ use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::TraitObjectMode;\n use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n@@ -55,7 +54,6 @@ pub fn overlapping_impls<'gcx, F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n-    trait_object_mode: TraitObjectMode,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -66,14 +64,12 @@ where\n     debug!(\"overlapping_impls(\\\n            impl1_def_id={:?}, \\\n            impl2_def_id={:?},\n-           intercrate_mode={:?},\n-           trait_object_mode={:?})\",\n+           intercrate_mode={:?})\",\n            impl1_def_id,\n            impl2_def_id,\n-           intercrate_mode,\n-           trait_object_mode);\n+           intercrate_mode);\n \n-    let overlaps = tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n+    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n     });\n@@ -85,7 +81,7 @@ where\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambuiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n         on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())\n@@ -510,7 +506,13 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n \n-        ty::Dynamic(ref tt, ..) => def_id_is_local(tt.principal().def_id(), in_crate),\n+        ty::Dynamic(ref tt, ..) => {\n+            if let Some(principal) = tt.principal() {\n+                def_id_is_local(principal.def_id(), in_crate)\n+            } else {\n+                false\n+            }\n+        }\n \n         ty::Error => true,\n "}, {"sha": "7ce5960b9b3d6b38e9d2149b4d5c48b6de5d51cc", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -447,7 +447,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let simp = fast_reject::simplify_type(self.tcx,\n                                               trait_ref.skip_binder().self_ty(),\n-                                              true,);\n+                                              true);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {"}, {"sha": "6db6fe31fba70b9349ebd56230859cf398c346fb", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -33,7 +33,7 @@ use infer::{InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n use ty::fast_reject;\n-use ty::relate::{TypeRelation, TraitObjectMode};\n+use ty::relate::TypeRelation;\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n@@ -1416,13 +1416,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return false;\n         }\n \n-        // Same idea as the above, but for alt trait object modes. These\n-        // should only be used in intercrate mode - better safe than sorry.\n-        if self.infcx.trait_object_mode() != TraitObjectMode::NoSquash {\n-            bug!(\"using squashing TraitObjectMode outside of intercrate mode? param_env={:?}\",\n-                 param_env);\n-        }\n-\n         // Otherwise, we can use the global cache.\n         true\n     }\n@@ -2016,7 +2009,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         return;\n                     }\n \n-                    data.principal().with_self_ty(self.tcx(), self_ty)\n+                    if let Some(principal) = data.principal() {\n+                        principal.with_self_ty(self.tcx(), self_ty)\n+                    } else {\n+                        // Only auto-trait bounds exist.\n+                        return;\n+                    }\n                 }\n                 ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -2108,7 +2106,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 //\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n-                data_a.principal().def_id() == data_b.principal().def_id()\n+                data_a.principal_def_id() == data_b.principal_def_id()\n                     && data_b.auto_traits()\n                     // All of a's auto traits need to be in b's auto traits.\n                     .all(|b| data_a.auto_traits().any(|a| a == b))\n@@ -2262,7 +2260,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         ImplCandidate(victim_def) => {\n                             let tcx = self.tcx().global_tcx();\n                             return tcx.specializes((other_def, victim_def))\n-                                || tcx.impls_are_allowed_to_overlap(other_def, victim_def);\n+                                || tcx.impls_are_allowed_to_overlap(\n+                                    other_def, victim_def).is_some();\n                         }\n                         ParamCandidate(ref cand) => {\n                             // Prefer the impl to a global where clause candidate.\n@@ -2919,7 +2918,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::Dynamic(ref data, ..) => data.principal().with_self_ty(self.tcx(), self_ty),\n+            ty::Dynamic(ref data, ..) =>\n+                data.principal().unwrap_or_else(|| {\n+                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n+                }).with_self_ty(self.tcx(), self_ty),\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n \n@@ -3222,8 +3224,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n                 let existential_predicates = data_a.map_bound(|data_a| {\n-                    let iter = iter::once(ty::ExistentialPredicate::Trait(data_a.principal()))\n-                        .chain(\n+                    let iter =\n+                        data_a.principal().map(|x| ty::ExistentialPredicate::Trait(x))\n+                        .into_iter().chain(\n                             data_a\n                                 .projection_bounds()\n                                 .map(|x| ty::ExistentialPredicate::Projection(x)),\n@@ -3260,7 +3263,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // T -> Trait.\n             (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids = data.auto_traits()\n-                    .chain(iter::once(data.principal().def_id()));\n+                    .chain(data.principal_def_id());\n                 if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n                     return Err(TraitNotObjectSafe(did));\n                 }\n@@ -3571,8 +3574,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         previous: &ty::PolyTraitRef<'tcx>,\n         current: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        let mut matcher = ty::_match::Match::new(\n-            self.tcx(), self.infcx.trait_object_mode());\n+        let mut matcher = ty::_match::Match::new(self.tcx());\n         matcher.relate(previous, current).is_ok()\n     }\n "}, {"sha": "e5ed16e7558601a28ee1e387eaa3f142118a4bc5", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -14,8 +14,7 @@ pub mod specialization_graph;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use lint;\n-use traits::{self, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n-use traits::coherence;\n+use traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;"}, {"sha": "e5780a26a19186647a4c2d065ecf761427a95759", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n-use ty::relate::TraitObjectMode;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use util::captures::Captures;\n@@ -174,9 +173,20 @@ impl<'a, 'gcx, 'tcx> Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::IntercrateMode::Issue43355,\n-                TraitObjectMode::NoSquash,\n                 |overlap| {\n-                    if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                    if let Some(overlap_kind) =\n+                        tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n+                    {\n+                        match overlap_kind {\n+                            ty::ImplOverlapKind::Permitted => {}\n+                            ty::ImplOverlapKind::Issue33140 => {\n+                                last_lint = Some(FutureCompatOverlapError {\n+                                    error: overlap_error(overlap),\n+                                    kind: FutureCompatOverlapErrorKind::Issue33140\n+                                });\n+                            }\n+                        }\n+\n                         return Ok((false, false));\n                     }\n \n@@ -204,31 +214,17 @@ impl<'a, 'gcx, 'tcx> Children {\n \n                 replace_children.push(possible_sibling);\n             } else {\n-                if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                    // do future-compat checks for overlap. Have issue #43355\n-                    // errors overwrite issue #33140 errors when both are present.\n-\n-                    traits::overlapping_impls(\n-                        tcx,\n-                        possible_sibling,\n-                        impl_def_id,\n-                        traits::IntercrateMode::Fixed,\n-                        TraitObjectMode::SquashAutoTraitsIssue33140,\n-                        |overlap| {\n-                            last_lint = Some(FutureCompatOverlapError {\n-                                error: overlap_error(overlap),\n-                                kind: FutureCompatOverlapErrorKind::Issue33140\n-                            });\n-                        },\n-                        || (),\n-                    );\n+                if let None = tcx.impls_are_allowed_to_overlap(\n+                    impl_def_id, possible_sibling)\n+                {\n+                    // do future-compat checks for overlap. Have issue #33140\n+                    // errors overwrite issue #43355 errors when both are present.\n \n                     traits::overlapping_impls(\n                         tcx,\n                         possible_sibling,\n                         impl_def_id,\n                         traits::IntercrateMode::Fixed,\n-                        TraitObjectMode::NoSquash,\n                         |overlap| {\n                             last_lint = Some(FutureCompatOverlapError {\n                                 error: overlap_error(overlap),"}, {"sha": "34b94d4217d8b0889e459d6259aa1950d0471681", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -19,24 +19,17 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    trait_object_mode: relate::TraitObjectMode\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               trait_object_mode: relate::TraitObjectMode)\n-               -> Match<'a, 'gcx, 'tcx> {\n-        Match { tcx, trait_object_mode }\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n+        Match { tcx }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.trait_object_mode\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n "}, {"sha": "834b541d4c01b2d2b316e7a7940cf0226625231a", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -184,7 +184,11 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::FnDef(..) => \"fn item\".into(),\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n-                format!(\"trait {}\", tcx.item_path_str(inner.principal().def_id())).into()\n+                if let Some(principal) = inner.principal() {\n+                    format!(\"trait {}\", tcx.item_path_str(principal.def_id())).into()\n+                } else {\n+                    \"trait\".into()\n+                }\n             }\n             ty::Closure(..) => \"closure\".into(),\n             ty::Generator(..) => \"generator\".into(),"}, {"sha": "2b41fc4fe341f74623b1f7c1faace1f456463474", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -71,11 +71,11 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n         ty::RawPtr(_) => Some(PtrSimplifiedType),\n         ty::Dynamic(ref trait_info, ..) => {\n-            let principal_def_id = trait_info.principal().def_id();\n-            if tcx.trait_is_auto(principal_def_id) {\n-                Some(MarkerTraitObjectSimplifiedType)\n-            } else {\n-                Some(TraitSimplifiedType(principal_def_id))\n+            match trait_info.principal_def_id() {\n+                Some(principal_def_id) if !tcx.trait_is_auto(principal_def_id) => {\n+                    Some(TraitSimplifiedType(principal_def_id))\n+                }\n+                _ => Some(MarkerTraitObjectSimplifiedType)\n             }\n         }\n         ty::Ref(_, ty, _) => {\n@@ -140,9 +140,9 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n             ArraySimplifiedType => ArraySimplifiedType,\n             PtrSimplifiedType => PtrSimplifiedType,\n             NeverSimplifiedType => NeverSimplifiedType,\n+            MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n             TupleSimplifiedType(n) => TupleSimplifiedType(n),\n             TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n-            MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),"}, {"sha": "417e14054d24f260668bbb84edcc0b03593df614", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -479,7 +479,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     match ty.sty {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n-        ty::Dynamic(data, ..) => Some(data.principal().def_id()),\n+        ty::Dynamic(data, ..) => data.principal_def_id(),\n \n         ty::Array(subty, _) |\n         ty::Slice(subty) => characteristic_def_id_of_type(subty),"}, {"sha": "f11a3688b39cbffcb465109ce38d4eae0a0beed4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 120, "deletions": 2, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -2637,6 +2637,45 @@ impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n     }\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub enum ImplOverlapKind {\n+    /// These impls are always allowed to overlap.\n+    Permitted,\n+    /// These impls are allowed to overlap, but that raises\n+    /// an issue #33140 future-compatibility warning.\n+    ///\n+    /// Some background: in Rust 1.0, the trait-object types `Send + Sync` (today's\n+    /// `dyn Send + Sync`) and `Sync + Send` (now `dyn Sync + Send`) were different.\n+    ///\n+    /// The widely-used version 0.1.0 of the crate `traitobject` had accidentally relied\n+    /// that difference, making what reduces to the following set of impls:\n+    ///\n+    /// ```\n+    /// trait Trait {}\n+    /// impl Trait for dyn Send + Sync {}\n+    /// impl Trait for dyn Sync + Send {}\n+    /// ```\n+    ///\n+    /// Obviously, once we made these types be identical, that code causes a coherence\n+    /// error and a fairly big headache for us. However, luckily for us, the trait\n+    /// `Trait` used in this case is basically a marker trait, and therefore having\n+    /// overlapping impls for it is sound.\n+    ///\n+    /// To handle this, we basically regard the trait as a marker trait, with an additional\n+    /// future-compatibility warning. To avoid accidentally \"stabilizing\" this feature,\n+    /// it has the following restrictions:\n+    ///\n+    /// 1. The trait must indeed be a marker-like trait (i.e., no items), and must be\n+    /// positive impls.\n+    /// 2. The trait-ref of both impls must be equal.\n+    /// 3. The trait-ref of both impls must be a trait object type consisting only of\n+    /// marker traits.\n+    /// 4. Neither of the impls can have any where-clauses.\n+    ///\n+    /// Once `traitobject` 0.1.0 is no longer an active concern, this hack can be removed.\n+    Issue33140\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n         self.typeck_tables_of(self.hir().body_owner_def_id(body))\n@@ -2788,8 +2827,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated #[marker] and prevents item overrides.\n-    pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n-        if self.features().overlapping_marker_traits {\n+    pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId)\n+                                        -> Option<ImplOverlapKind>\n+    {\n+        let is_legit = if self.features().overlapping_marker_traits {\n             let trait1_is_empty = self.impl_trait_ref(def_id1)\n                 .map_or(false, |trait_ref| {\n                     self.associated_item_def_ids(trait_ref.def_id).is_empty()\n@@ -2811,6 +2852,29 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 && is_marker_impl(def_id2)\n         } else {\n             false\n+        };\n+\n+        if is_legit {\n+            debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted)\",\n+                  def_id1, def_id2);\n+            Some(ImplOverlapKind::Permitted)\n+        } else {\n+            if let Some(self_ty1) = self.issue33140_self_ty(def_id1) {\n+                if let Some(self_ty2) = self.issue33140_self_ty(def_id2) {\n+                    if self_ty1 == self_ty2 {\n+                        debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) - issue #33140 HACK\",\n+                               def_id1, def_id2);\n+                        return Some(ImplOverlapKind::Issue33140);\n+                    } else {\n+                        debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) - found {:?} != {:?}\",\n+                              def_id1, def_id2, self_ty1, self_ty2);\n+                    }\n+                }\n+            }\n+\n+            debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = None\",\n+                  def_id1, def_id2);\n+            None\n         }\n     }\n \n@@ -3203,6 +3267,59 @@ fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+/// If `def_id` is an issue 33140 hack impl, return its self type. Otherwise\n+/// return None.\n+///\n+/// See ImplOverlapKind::Issue33140 for more details.\n+fn issue33140_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                def_id: DefId)\n+                                -> Option<Ty<'tcx>>\n+{\n+    debug!(\"issue33140_self_ty({:?})\", def_id);\n+\n+    let trait_ref = tcx.impl_trait_ref(def_id).unwrap_or_else(|| {\n+        bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id)\n+    });\n+\n+    debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n+\n+    let is_marker_like =\n+        tcx.impl_polarity(def_id) == hir::ImplPolarity::Positive &&\n+        tcx.associated_item_def_ids(trait_ref.def_id).is_empty();\n+\n+    // Check whether these impls would be ok for a marker trait.\n+    if !is_marker_like {\n+        debug!(\"issue33140_self_ty - not marker-like!\");\n+        return None;\n+    }\n+\n+    // impl must be `impl Trait for dyn Marker1 + Marker2 + ...`\n+    if trait_ref.substs.len() != 1 {\n+        debug!(\"issue33140_self_ty - impl has substs!\");\n+        return None;\n+    }\n+\n+    let predicates = tcx.predicates_of(def_id);\n+    if predicates.parent.is_some() || !predicates.predicates.is_empty() {\n+        debug!(\"issue33140_self_ty - impl has predicates {:?}!\", predicates);\n+        return None;\n+    }\n+\n+    let self_ty = trait_ref.self_ty();\n+    let self_ty_matches = match self_ty.sty {\n+        ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n+        _ => false\n+    };\n+\n+    if self_ty_matches {\n+        debug!(\"issue33140_self_ty - MATCHES!\");\n+        Some(self_ty)\n+    } else {\n+        debug!(\"issue33140_self_ty - non-matching self type\");\n+        None\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n@@ -3221,6 +3338,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         crate_hash,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         instance_def_size_estimate,\n+        issue33140_self_ty,\n         ..*providers\n     };\n }"}, {"sha": "99dd3569491bc2772f8a469cd91f8b7c3bb6bda8", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -202,6 +202,8 @@ define_queries! { <'tcx>\n \n         [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n         [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n+\n+        [] fn issue33140_self_ty: Issue33140SelfTy(DefId) -> Option<ty::Ty<'tcx>>,\n     },\n \n     TypeChecking {"}, {"sha": "9a1ab559688a834ca2ff9f2a85e4216ae45c6d93", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -1275,6 +1275,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::AdtDefOfItem => { force!(adt_def, def_id!()); }\n         DepKind::ImplTraitRef => { force!(impl_trait_ref, def_id!()); }\n         DepKind::ImplPolarity => { force!(impl_polarity, def_id!()); }\n+        DepKind::Issue33140SelfTy => { force!(issue33140_self_ty, def_id!()); }\n         DepKind::FnSignature => { force!(fn_sig, def_id!()); }\n         DepKind::CoerceUnsizedInfo => { force!(coerce_unsized_info, def_id!()); }\n         DepKind::ItemVariances => { force!(variances_of, def_id!()); }"}, {"sha": "a16d6fea74c0b0d49d04f321c4fedbdd811956dc", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -24,20 +24,9 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum TraitObjectMode {\n-    NoSquash,\n-    /// A temporary mode to treat `Send + Sync = Sync + Send`, should be\n-    /// used only in coherence.\n-    SquashAutoTraitsIssue33140\n-}\n-\n pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n-    /// Return the trait object mode to be used.\n-    fn trait_object_mode(&self) -> TraitObjectMode;\n-\n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n \n@@ -591,44 +580,14 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n                            a: &Self,\n                            b: &Self)\n         -> RelateResult<'tcx, Self>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n-        use ty::ExistentialPredicate::*;\n+            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n \n-        let tcx = relation.tcx();\n-        let (a_buf, b_buf);\n-        let (a_norm, b_norm): (&[_], &[_]) = match relation.trait_object_mode() {\n-            TraitObjectMode::NoSquash => {\n-                (a, b)\n-            }\n-            TraitObjectMode::SquashAutoTraitsIssue33140 => {\n-                // Treat auto-trait \"principal\" components as equal\n-                // to the non-principal components, to make\n-                // `dyn Send+Sync = dyn Sync+Send`.\n-                let normalize = |d: &[ty::ExistentialPredicate<'tcx>]| {\n-                    let mut result: Vec<_> = d.iter().map(|pi| match pi {\n-                        Trait(ref a) if tcx.trait_is_auto(a.def_id) => {\n-                            AutoTrait(a.def_id)\n-                        },\n-                        other => *other\n-                    }).collect();\n-\n-                    result.sort_by(|a, b| a.stable_cmp(tcx, b));\n-                    result.dedup();\n-                    result\n-                };\n-\n-                a_buf = normalize(a);\n-                b_buf = normalize(b);\n-\n-                (&a_buf, &b_buf)\n-            }\n-        };\n-\n-        if a_norm.len() != b_norm.len() {\n+        if a.len() != b.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n-        let v = a_norm.iter().zip(b_norm.iter()).map(|(ep_a, ep_b)| {\n+        let tcx = relation.tcx();\n+        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n             use ty::ExistentialPredicate::*;\n             match (*ep_a, *ep_b) {\n                 (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),"}, {"sha": "b98369b62ea37de107365daa9d85e30f02866280", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -569,13 +569,42 @@ impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n-    pub fn principal(&self) -> ExistentialTraitRef<'tcx> {\n+    /// Returns the \"principal def id\" of this set of existential predicates.\n+    ///\n+    /// A Rust trait object type consists (in addition to a lifetime bound)\n+    /// of a set of trait bounds, which are separated into any number\n+    /// of auto-trait bounds, and at most 1 non-auto-trait bound. The\n+    /// non-auto-trait bound is called the \"principal\" of the trait\n+    /// object.\n+    ///\n+    /// Only the principal can have methods or type parameters (because\n+    /// auto traits can have neither of them). This is important, because\n+    /// it means the auto traits can be treated as an unordered set (methods\n+    /// would force an order for the vtable, while relating traits with\n+    /// type parameters without knowing the order to relate them in is\n+    /// a rather non-trivial task).\n+    ///\n+    /// For example, in the trait object `dyn fmt::Debug + Sync`, the\n+    /// principal bound is `Some(fmt::Debug)`, while the auto-trait bounds\n+    /// are the set `{Sync}`.\n+    ///\n+    /// It is also possible to have a \"trivial\" trait object that\n+    /// consists only of auto traits, with no principal - for example,\n+    /// `dyn Send + Sync`. In that case, the set of auto-trait bounds\n+    /// is `{Send, Sync}`, while there is no principal. These trait objects\n+    /// have a \"trivial\" vtable consisting of just the size, alignment,\n+    /// and destructor.\n+    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n         match self[0] {\n-            ExistentialPredicate::Trait(tr) => tr,\n-            other => bug!(\"first predicate is {:?}\", other),\n+            ExistentialPredicate::Trait(tr) => Some(tr),\n+            _ => None\n         }\n     }\n \n+    pub fn principal_def_id(&self) -> Option<DefId> {\n+        self.principal().map(|d| d.def_id)\n+    }\n+\n     #[inline]\n     pub fn projection_bounds<'a>(&'a self) ->\n         impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n@@ -599,8 +628,12 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n }\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n-    pub fn principal(&self) -> PolyExistentialTraitRef<'tcx> {\n-        Binder::bind(self.skip_binder().principal())\n+    pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n+        self.skip_binder().principal().map(Binder::bind)\n+    }\n+\n+    pub fn principal_def_id(&self) -> Option<DefId> {\n+        self.skip_binder().principal_def_id()\n     }\n \n     #[inline]\n@@ -1917,7 +1950,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             Dynamic(ref obj, region) => {\n                 out.push(region);\n-                out.extend(obj.principal().skip_binder().substs.regions());\n+                if let Some(principal) = obj.principal() {\n+                    out.extend(principal.skip_binder().substs.regions());\n+                }\n             }\n             Adt(_, substs) | Opaque(_, substs) => {\n                 out.extend(substs.regions())"}, {"sha": "ef68394029680716d92dc3b796a863cd2163a04f", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                     let cause = self.cause(traits::MiscObligation);\n                     let component_traits =\n-                        data.auto_traits().chain(once(data.principal().def_id()));\n+                        data.auto_traits().chain(data.principal_def_id());\n                     self.out.extend(\n                         component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),"}, {"sha": "04e571863d42f8f3142fc98e17f8b1a83d07c783", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -711,21 +711,43 @@ define_print! {\n             ty::tls::with(|tcx| {\n                 // Use a type that can't appear in defaults of type parameters.\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-                let principal = tcx\n-                    .lift(&self.principal())\n-                    .expect(\"could not lift TraitRef for printing\")\n-                    .with_self_ty(tcx, dummy_self);\n-                let projections = self.projection_bounds().map(|p| {\n-                    tcx.lift(&p)\n-                        .expect(\"could not lift projection for printing\")\n-                        .with_self_ty(tcx, dummy_self)\n-                }).collect::<Vec<_>>();\n-                cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                let mut first = true;\n+\n+                if let Some(principal) = self.principal() {\n+                    let principal = tcx\n+                        .lift(&principal)\n+                        .expect(\"could not lift TraitRef for printing\")\n+                        .with_self_ty(tcx, dummy_self);\n+                    let projections = self.projection_bounds().map(|p| {\n+                        tcx.lift(&p)\n+                            .expect(\"could not lift projection for printing\")\n+                            .with_self_ty(tcx, dummy_self)\n+                    }).collect::<Vec<_>>();\n+                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                    first = false;\n+                }\n \n                 // Builtin bounds.\n-                for did in self.auto_traits() {\n-                    write!(f, \" + {}\", tcx.item_path_str(did))?;\n+                let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n+                    tcx.item_path_str(did)\n+                }).collect();\n+\n+                // The auto traits come ordered by `DefPathHash`. While\n+                // `DefPathHash` is *stable* in the sense that it depends on\n+                // neither the host nor the phase of the moon, it depends\n+                // \"pseudorandomly\" on the compiler version and the target.\n+                //\n+                // To avoid that causing instabilities in compiletest\n+                // output, sort the auto-traits alphabetically.\n+                auto_traits.sort();\n+\n+                for auto_trait in auto_traits {\n+                    if !first {\n+                        write!(f, \" + \")?;\n+                    }\n+                    first = false;\n+\n+                    write!(f, \"{}\", auto_trait)?;\n                 }\n \n                 Ok(())"}, {"sha": "2b03e99161db8911939e39240d8b23e2f652ad34", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -50,7 +50,8 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, &'ll Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), &'ll Value>>,\n+    pub vtables: RefCell<FxHashMap<\n+            (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'ll Value>>,\n \n@@ -311,7 +312,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n \n impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn vtables(&self) -> &RefCell<FxHashMap<(Ty<'tcx>,\n-                                ty::PolyExistentialTraitRef<'tcx>), &'ll Value>>\n+                                Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>\n     {\n         &self.vtables\n     }"}, {"sha": "72ed55df946588440b4567ea82f6baf172e9c8e6", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -429,7 +429,8 @@ fn trait_pointer_metadata(\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n-        ty::Dynamic(ref data, ..) => Some(get_namespace_for_item(cx, data.principal().def_id())),\n+        ty::Dynamic(ref data, ..) =>\n+            data.principal_def_id().map(|did| get_namespace_for_item(cx, did)),\n         _ => {\n             bug!(\"debuginfo: Unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\","}, {"sha": "32432f7e4ec10d2da4be8a22f818910912a4d2d6", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -107,12 +107,16 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         },\n         ty::Dynamic(ref trait_data, ..) => {\n-            let principal = cx.tcx.normalize_erasing_late_bound_regions(\n-                ty::ParamEnv::reveal_all(),\n-                &trait_data.principal(),\n-            );\n-            push_item_name(cx, principal.def_id, false, output);\n-            push_type_params(cx, principal.substs, output);\n+            if let Some(principal) = trait_data.principal() {\n+                let principal = cx.tcx.normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &principal,\n+                );\n+                push_item_name(cx, principal.def_id, false, output);\n+                push_type_params(cx, principal.substs, output);\n+            } else {\n+                output.push_str(\"dyn '_\");\n+            }\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let sig = t.fn_sig(cx.tcx);"}, {"sha": "98ad2616eeaae364c47f339a27cca95db2c639bc", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx: 'a> VirtualIndex {\n pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     cx: &Cx,\n     ty: Ty<'tcx>,\n-    trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Cx::Value {\n     let tcx = cx.tcx();\n \n@@ -83,8 +83,15 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     // Not in the cache. Build it.\n     let nullptr = cx.const_null(cx.type_i8p());\n \n-    let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n-    let methods = methods.iter().cloned().map(|opt_mth| {\n+    let methods_root;\n+    let methods = if let Some(trait_ref) = trait_ref {\n+        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n+        methods_root.iter()\n+    } else {\n+        (&[]).iter()\n+    };\n+\n+    let methods = methods.cloned().map(|opt_mth| {\n         opt_mth.map_or(nullptr, |(def_id, substs)| {\n             callee::resolve_and_get_fn_for_vtable(cx, def_id, substs)\n         })"}, {"sha": "b23155563665d1c38a71f86195ba9f9f148fafcf", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n pub trait MiscMethods<'tcx>: BackendTypes {\n     fn vtables(\n         &self,\n-    ) -> &RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), Self::Value>>;\n+    ) -> &RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Self::Value>>;\n     fn check_overflow(&self) -> bool;\n     fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, Self::Value>>;\n     fn get_fn(&self, instance: Instance<'tcx>) -> Self::Value;"}, {"sha": "19362b6cfdb1c4af21052d343674fde60cdb9b05", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -42,7 +42,7 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n \n     /// A cache for deduplicating vtables\n-    pub(super) vtables: FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), AllocId>,\n+    pub(super) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>,\n }\n \n /// A stack frame."}, {"sha": "642bbc114f5620c6a79165e4df3c5d25c04027e4", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -1,3 +1,4 @@\n+use rustc_data_structures::sync::Lrc;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n@@ -14,7 +15,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn get_vtable(\n         &mut self,\n         ty: Ty<'tcx>,\n-        poly_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n+        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n     ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n         trace!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n@@ -24,10 +25,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             return Ok(Pointer::from(vtable).with_default_tag());\n         }\n \n-        let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n-        let trait_ref = self.tcx.erase_regions(&trait_ref);\n+        let methods = if let Some(poly_trait_ref) = poly_trait_ref {\n+            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n+            let trait_ref = self.tcx.erase_regions(&trait_ref);\n \n-        let methods = self.tcx.vtable_methods(trait_ref);\n+            self.tcx.vtable_methods(trait_ref)\n+        } else {\n+            Lrc::new(Vec::new())\n+        };\n \n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");"}, {"sha": "a6a8fe5ade56c7c0aceb852974a927251c0bb022", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -894,20 +894,23 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_bound_vars());\n \n     if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal().with_self_ty(tcx, impl_ty);\n-        assert!(!poly_trait_ref.has_escaping_bound_vars());\n-\n-        // Walk all methods of the trait, including those of its supertraits\n-        let methods = tcx.vtable_methods(poly_trait_ref);\n-        let methods = methods.iter().cloned().filter_map(|method| method)\n-            .map(|(def_id, substs)| ty::Instance::resolve_for_vtable(\n+        if let Some(principal) = trait_ty.principal() {\n+            let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n+            assert!(!poly_trait_ref.has_escaping_bound_vars());\n+\n+            // Walk all methods of the trait, including those of its supertraits\n+            let methods = tcx.vtable_methods(poly_trait_ref);\n+            let methods = methods.iter().cloned().filter_map(|method| method)\n+                .map(|(def_id, substs)| ty::Instance::resolve_for_vtable(\n                     tcx,\n                     ty::ParamEnv::reveal_all(),\n                     def_id,\n                     substs).unwrap())\n-            .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n-            .map(|instance| create_fn_mono_item(instance));\n-        output.extend(methods);\n+                .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n+                .map(|instance| create_fn_mono_item(instance));\n+            output.extend(methods);\n+        }\n+\n         // Also add the destructor\n         visit_drop_use(tcx, impl_ty, false, output);\n     }"}, {"sha": "7014f539d575416eb76f9fe14bdf5e8543050b03", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -304,13 +304,16 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 output.push(']');\n             },\n             ty::Dynamic(ref trait_data, ..) => {\n-                let principal = trait_data.principal();\n-                self.push_def_path(principal.def_id(), output);\n-                self.push_type_params(\n-                    principal.skip_binder().substs,\n-                    trait_data.projection_bounds(),\n-                    output,\n-                );\n+                if let Some(principal) = trait_data.principal() {\n+                    self.push_def_path(principal.def_id(), output);\n+                    self.push_type_params(\n+                        principal.skip_binder().substs,\n+                        trait_data.projection_bounds(),\n+                        output,\n+                    );\n+                } else {\n+                    output.push_str(\"dyn '_\");\n+                }\n             },\n             ty::Foreign(did) => self.push_def_path(did, output),\n             ty::FnDef(..) |"}, {"sha": "932501cc04fe0dd8c4fa471042023fcb2d0af705", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -17,7 +17,7 @@ use rustc::traits::{\n };\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Kind;\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax_pos::DUMMY_SP;\n \n use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n@@ -157,10 +157,6 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.infcx.trait_object_mode()\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"chalk_context::answer_substitutor\"\n     }"}, {"sha": "41ecfaad86aab96a8cee93368b8d4c00442b21e6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -1138,13 +1138,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         auto_traits.dedup();\n \n         // Calling `skip_binder` is okay, because the predicates are re-bound.\n+        let principal = if tcx.trait_is_auto(existential_principal.def_id()) {\n+            ty::ExistentialPredicate::AutoTrait(existential_principal.def_id())\n+        } else {\n+            ty::ExistentialPredicate::Trait(*existential_principal.skip_binder())\n+        };\n         let mut v =\n-            iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n+            iter::once(principal)\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n             .chain(existential_projections\n                 .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.stable_cmp(tcx, b));\n+        v.dedup();\n         let existential_predicates = ty::Binder::bind(tcx.mk_existential_predicates(v.into_iter()));\n \n         // Use explicitly-specified region bound."}, {"sha": "38f9adee0a48fc1401a7ce4de3bd61caf46bf2ef", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -63,7 +63,7 @@ enum PointerKind<'tcx> {\n     /// No metadata attached, ie pointer to sized type or foreign type\n     Thin,\n     /// A trait object\n-    Vtable(DefId),\n+    Vtable(Option<DefId>),\n     /// Slice\n     Length,\n     /// The unsize info of this projection\n@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(match t.sty {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n             ty::Dynamic(ref tty, ..) =>\n-                Some(PointerKind::Vtable(tty.principal().def_id())),\n+                Some(PointerKind::Vtable(tty.principal_def_id())),\n             ty::Adt(def, substs) if def.is_struct() => {\n                 match def.non_enum_variant().fields.last() {\n                     None => Some(PointerKind::Thin),"}, {"sha": "ff3b22dd1dec783235d2c5e7bdd98dd745fa327e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -190,7 +190,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n-                let kind = self.tcx.lang_items().fn_trait_kind(object_type.principal().def_id());\n+                let kind = object_type.principal_def_id().and_then(|did| {\n+                    self.tcx.lang_items().fn_trait_kind(did)\n+                });\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),"}, {"sha": "2cf2974a45a1cd64597f2de807d69f1055e57864", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -280,7 +280,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .include_raw_pointers()\n             .filter_map(|(ty, _)|\n                 match ty.sty {\n-                    ty::Dynamic(ref data, ..) => Some(closure(self, ty, data.principal())),\n+                    ty::Dynamic(ref data, ..) => {\n+                        Some(closure(self, ty, data.principal().unwrap_or_else(|| {\n+                            span_bug!(self.span, \"calling trait method on empty object?\")\n+                        })))\n+                    },\n                     _ => None,\n                 }\n             )"}, {"sha": "9a828ce01775c0df574f734aea316ff4761f1f43", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -505,17 +505,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         match self_ty.value.value.sty {\n             ty::Dynamic(ref data, ..) => {\n-                let p = data.principal();\n-                self.fcx.probe(|_| {\n-                    let InferOk { value: self_ty, obligations: _ } =\n-                        self.fcx.probe_instantiate_query_response(\n-                            self.span, &self.orig_steps_var_values, self_ty)\n-                        .unwrap_or_else(|_| {\n-                            span_bug!(self.span, \"{:?} was applicable but now isn't?\", self_ty)\n-                        });\n-                    self.assemble_inherent_candidates_from_object(self_ty);\n-                });\n-                self.assemble_inherent_impl_candidates_for_type(p.def_id());\n+                if let Some(p) = data.principal() {\n+                    self.fcx.probe(|_| {\n+                        let InferOk { value: self_ty, obligations: _ } =\n+                            self.fcx.probe_instantiate_query_response(\n+                                self.span, &self.orig_steps_var_values, self_ty)\n+                            .unwrap_or_else(|_| {\n+                                span_bug!(self.span, \"{:?} was applicable but now isn't?\", self_ty)\n+                            });\n+                        self.assemble_inherent_candidates_from_object(self_ty);\n+                    });\n+                    self.assemble_inherent_impl_candidates_for_type(p.def_id());\n+                }\n             }\n             ty::Adt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n@@ -680,10 +681,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                self_ty);\n \n         let principal = match self_ty.sty {\n-            ty::Dynamic(ref data, ..) => data.principal(),\n-            _ => span_bug!(self.span, \"non-object {:?} in assemble_inherent_candidates_from_object\",\n-                           self_ty)\n-        };\n+            ty::Dynamic(ref data, ..) => Some(data),\n+            _ => None\n+        }.and_then(|data| data.principal()).unwrap_or_else(|| {\n+            span_bug!(self.span, \"non-object {:?} in assemble_inherent_candidates_from_object\",\n+                      self_ty)\n+        });\n \n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `Self` type. An error will be reported by"}, {"sha": "23bcd88d6afb5548ccc94557115a1be069fd5d62", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -651,7 +651,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n \n-                ty::Dynamic(ref tr, ..) => tr.principal().def_id().is_local(),\n+                ty::Dynamic(ref tr, ..) =>\n+                    tr.principal().map(|d| d.def_id().is_local()).unwrap_or(false),\n \n                 ty::Param(_) => true,\n "}, {"sha": "93cc86423ace314ac1a494ca3021996da3da5552", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -95,8 +95,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::Foreign(did) => {\n                 self.check_def_id(item, did);\n             }\n-            ty::Dynamic(ref data, ..) => {\n-                self.check_def_id(item, data.principal().def_id());\n+            ty::Dynamic(ref data, ..) if data.principal_def_id().is_some() => {\n+                self.check_def_id(item, data.principal_def_id().unwrap());\n             }\n             ty::Char => {\n                 self.check_primitive_impl(def_id,"}, {"sha": "52dee29294cb72c35d9f8385fd23c2ab04fbd273", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 29, "deletions": 76, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -2,9 +2,8 @@ use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits::{self, IntercrateMode, FutureCompatOverlapErrorKind};\n+use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n-use rustc::ty::relate::TraitObjectMode;\n \n use lint;\n \n@@ -20,11 +19,9 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(\n-        &self, impl1: DefId, impl2: DefId,\n-        overlap: traits::OverlapResult,\n-        used_to_be_allowed: Option<FutureCompatOverlapErrorKind>)\n-    {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n+                                       overlap: traits::OverlapResult,\n+                                       used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -40,28 +37,19 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n                     let node_id = self.tcx.hir().as_local_node_id(impl1);\n-                    let mut err = match used_to_be_allowed {\n-                        Some(kind) if node_id.is_some() => {\n-                            let lint = match kind {\n-                                FutureCompatOverlapErrorKind::Issue43355 =>\n-                                    lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                                FutureCompatOverlapErrorKind::Issue33140 =>\n-                                    lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n-                            };\n-                            self.tcx.struct_span_lint_node(\n-                                lint,\n-                                node_id.unwrap(),\n-                                self.tcx.span_of_impl(item1).unwrap(),\n-                                &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n-                            )\n-                        }\n-                        _ => {\n-                            struct_span_err!(self.tcx.sess,\n-                                             self.tcx.span_of_impl(item1).unwrap(),\n-                                             E0592,\n-                                             \"duplicate definitions with name `{}`\",\n-                                             name)\n-                        }\n+                    let mut err = if used_to_be_allowed && node_id.is_some() {\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                            node_id.unwrap(),\n+                            self.tcx.span_of_impl(item1).unwrap(),\n+                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n+                        )\n+                    } else {\n+                        struct_span_err!(self.tcx.sess,\n+                                         self.tcx.span_of_impl(item1).unwrap(),\n+                                         E0592,\n+                                         \"duplicate definitions with name `{}`\",\n+                                         name)\n                     };\n \n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n@@ -88,73 +76,38 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                // First, check if the impl was forbidden under the\n-                // old rules. In that case, just have an error.\n                 let used_to_be_allowed = traits::overlapping_impls(\n                     self.tcx,\n                     impl1_def_id,\n                     impl2_def_id,\n                     IntercrateMode::Issue43355,\n-                    TraitObjectMode::NoSquash,\n                     |overlap| {\n                         self.check_for_common_items_in_impls(\n                             impl1_def_id,\n                             impl2_def_id,\n                             overlap,\n-                            None,\n+                            false,\n                         );\n                         false\n                     },\n                     || true,\n                 );\n \n-                if !used_to_be_allowed {\n-                    continue;\n-                }\n-\n-                // Then, check if the impl was forbidden under only\n-                // #43355. In that case, emit an #43355 error.\n-                let used_to_be_allowed = traits::overlapping_impls(\n-                    self.tcx,\n-                    impl1_def_id,\n-                    impl2_def_id,\n-                    IntercrateMode::Fixed,\n-                    TraitObjectMode::NoSquash,\n-                    |overlap| {\n-                        self.check_for_common_items_in_impls(\n+                if used_to_be_allowed {\n+                    traits::overlapping_impls(\n+                        self.tcx,\n+                        impl1_def_id,\n+                        impl2_def_id,\n+                        IntercrateMode::Fixed,\n+                        |overlap| self.check_for_common_items_in_impls(\n                             impl1_def_id,\n                             impl2_def_id,\n                             overlap,\n-                            Some(FutureCompatOverlapErrorKind::Issue43355),\n-                        );\n-                        false\n-                    },\n-                    || true,\n-                );\n-\n-                if !used_to_be_allowed {\n-                    continue;\n+                            true,\n+                        ),\n+                        || (),\n+                    );\n                 }\n-\n-                // Then, check if the impl was forbidden under\n-                // #33140. In that case, emit a #33140 error.\n-                traits::overlapping_impls(\n-                    self.tcx,\n-                    impl1_def_id,\n-                    impl2_def_id,\n-                    IntercrateMode::Fixed,\n-                    TraitObjectMode::SquashAutoTraitsIssue33140,\n-                    |overlap| {\n-                        self.check_for_common_items_in_impls(\n-                            impl1_def_id,\n-                            impl2_def_id,\n-                            overlap,\n-                            Some(FutureCompatOverlapErrorKind::Issue33140),\n-                        );\n-                        false\n-                    },\n-                    || true,\n-                );\n             }\n         }\n     }"}, {"sha": "ce71be07efd423e1b8df93d0d5edca1bf7ca246e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -171,25 +171,28 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-        if !tcx.is_object_safe(data.principal().def_id()) {\n-            // This is an error, but it will be reported by wfcheck.  Ignore it here.\n-            // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n-        } else {\n-            let mut supertrait_def_ids =\n-                traits::supertrait_def_ids(tcx, data.principal().def_id());\n-            if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n-                struct_span_err!(tcx.sess,\n-                                 sp,\n-                                 E0371,\n-                                 \"the object type `{}` automatically implements the trait `{}`\",\n-                                 trait_ref.self_ty(),\n-                                 tcx.item_path_str(trait_def_id))\n-                    .span_label(sp, format!(\"`{}` automatically implements trait `{}`\",\n-                                            trait_ref.self_ty(),\n-                                            tcx.item_path_str(trait_def_id)))\n-                    .emit();\n+        if let Some(principal_def_id) = data.principal_def_id() {\n+            if !tcx.is_object_safe(principal_def_id) {\n+                // This is an error, but it will be reported by wfcheck.  Ignore it here.\n+                // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n+            } else {\n+                let mut supertrait_def_ids =\n+                    traits::supertrait_def_ids(tcx, principal_def_id);\n+                if supertrait_def_ids.any(|d| d == trait_def_id) {\n+                    let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                    struct_span_err!(tcx.sess,\n+                                     sp,\n+                                     E0371,\n+                                     \"the object type `{}` automatically implements the trait `{}`\",\n+                                     trait_ref.self_ty(),\n+                                     tcx.item_path_str(trait_def_id))\n+                        .span_label(sp, format!(\"`{}` automatically implements trait `{}`\",\n+                                                trait_ref.self_ty(),\n+                                                tcx.item_path_str(trait_def_id)))\n+                        .emit();\n+                }\n             }\n         }\n+        // FIXME: also check auto-trait def-ids? (e.g. `impl Sync for Foo+Sync`)?\n     }\n }"}, {"sha": "e0e173901ef38bfb1af2612757bf96975d35f608", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -1618,6 +1618,7 @@ fn predicates_defined_on<'a, 'tcx>(\n             .predicates\n             .extend(inferred_outlives.iter().map(|&p| (p, span)));\n     }\n+    debug!(\"predicates_defined_on({:?}) = {:?}\", def_id, result);\n     result\n }\n \n@@ -1645,6 +1646,7 @@ fn predicates_of<'a, 'tcx>(\n             .predicates\n             .push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n     }\n+    debug!(\"predicates_of(def_id={:?}) = {:?}\", def_id, result);\n     result\n }\n \n@@ -1972,10 +1974,12 @@ fn explicit_predicates_of<'a, 'tcx>(\n         );\n     }\n \n-    Lrc::new(ty::GenericPredicates {\n+    let result = Lrc::new(ty::GenericPredicates {\n         parent: generics.parent,\n         predicates,\n-    })\n+    });\n+    debug!(\"explicit_predicates_of(def_id={:?}) = {:?}\", def_id, result);\n+    result\n }\n \n pub enum SizedByDefault {"}, {"sha": "e388a3e0d0c2fa49526fcef06bae444b2c97a439", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -194,27 +194,28 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Dynamic\");\n                 debug!(\"field_ty = {}\", &field_ty);\n                 debug!(\"ty in field = {}\", &ty);\n-                let ex_trait_ref = obj.principal();\n-                // Here, we are passing the type `usize` as a\n-                // placeholder value with the function\n-                // `with_self_ty`, since there is no concrete type\n-                // `Self` for a `dyn Trait` at this\n-                // stage. Therefore when checking explicit\n-                // predicates in `check_explicit_predicates` we\n-                // need to ignore checking the explicit_map for\n-                // Self type.\n-                let substs = ex_trait_ref\n-                    .with_self_ty(tcx, tcx.types.usize)\n-                    .skip_binder()\n-                    .substs;\n-                check_explicit_predicates(\n-                    tcx,\n-                    &ex_trait_ref.skip_binder().def_id,\n-                    substs,\n-                    required_predicates,\n-                    explicit_map,\n-                    IgnoreSelfTy(true),\n-                );\n+                if let Some(ex_trait_ref) = obj.principal() {\n+                    // Here, we are passing the type `usize` as a\n+                    // placeholder value with the function\n+                    // `with_self_ty`, since there is no concrete type\n+                    // `Self` for a `dyn Trait` at this\n+                    // stage. Therefore when checking explicit\n+                    // predicates in `check_explicit_predicates` we\n+                    // need to ignore checking the explicit_map for\n+                    // Self type.\n+                    let substs = ex_trait_ref\n+                        .with_self_ty(tcx, tcx.types.usize)\n+                        .skip_binder()\n+                        .substs;\n+                    check_explicit_predicates(\n+                        tcx,\n+                        &ex_trait_ref.skip_binder().def_id,\n+                        substs,\n+                        required_predicates,\n+                        explicit_map,\n+                        IgnoreSelfTy(true),\n+                    );\n+                }\n             }\n \n             ty::Projection(obj) => {"}, {"sha": "868c1132e44c560653dbc73ffae9d18062ffa663", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -301,11 +301,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, r, contra);\n \n-                let poly_trait_ref = data\n-                    .principal()\n-                    .with_self_ty(self.tcx(), self.tcx().types.err);\n-                self.add_constraints_from_trait_ref(\n-                    current, *poly_trait_ref.skip_binder(), variance);\n+                if let Some(poly_trait_ref) = data.principal() {\n+                    let poly_trait_ref =\n+                        poly_trait_ref.with_self_ty(self.tcx(), self.tcx().types.err);\n+                    self.add_constraints_from_trait_ref(\n+                        current, *poly_trait_ref.skip_binder(), variance);\n+                }\n \n                 for projection in data.projection_bounds() {\n                     self.add_constraints_from_ty("}, {"sha": "37c6407fbd1c0eedbfdc57c3c10d4d42ce274e59", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -2642,13 +2642,24 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }\n             }\n             ty::Dynamic(ref obj, ref reg) => {\n-                let principal = obj.principal();\n-                let did = principal.def_id();\n+                // HACK: pick the first `did` as the `did` of the trait object. Someone\n+                // might want to implement \"native\" support for marker-trait-only\n+                // trait objects.\n+                let mut dids = obj.principal_def_id().into_iter().chain(obj.auto_traits());\n+                let did = dids.next().unwrap_or_else(|| {\n+                    panic!(\"found trait object `{:?}` with no traits?\", self)\n+                });\n+                let substs = match obj.principal() {\n+                    Some(principal) => principal.skip_binder().substs,\n+                    // marker traits have no substs.\n+                    _ => cx.tcx.intern_substs(&[])\n+                };\n+\n                 inline::record_extern_fqn(cx, did, TypeKind::Trait);\n \n                 let mut typarams = vec![];\n                 reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n-                for did in obj.auto_traits() {\n+                for did in dids {\n                     let empty = cx.tcx.intern_substs(&[]);\n                     let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                         Some(did), false, vec![], empty);\n@@ -2674,7 +2685,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }\n \n                 let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n-                    false, bindings, principal.skip_binder().substs);\n+                    false, bindings, substs);\n                 ResolvedPath {\n                     path,\n                     typarams: Some(typarams),"}, {"sha": "4d91af2fb19ca86152f699e384856a3b04ce1542", "filename": "src/test/run-pass/issues/issue-33140.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/244b05db12e47efef4695036974bc25fde13b828/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244b05db12e47efef4695036974bc25fde13b828/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33140.rs?ref=244b05db12e47efef4695036974bc25fde13b828", "patch": "@@ -1,47 +0,0 @@\n-#![allow(order_dependent_trait_objects)]\n-\n-trait Trait {\n-    fn xyz() -> bool;\n-}\n-\n-impl Trait for dyn Send + Sync {\n-    fn xyz() -> bool { false }\n-}\n-\n-impl Trait for dyn Sync + Send {\n-    fn xyz() -> bool { true }\n-}\n-\n-trait Trait2 {\n-    fn uvw() -> bool;\n-}\n-\n-impl Trait2 for dyn Send + Sync {\n-    fn uvw() -> bool { false }\n-}\n-\n-impl Trait2 for dyn Sync + Send + Sync {\n-    fn uvw() -> bool { true }\n-}\n-\n-struct Foo<T: ?Sized>(T);\n-impl Foo<dyn Send + Sync> {\n-    fn abc() -> bool {\n-        false\n-    }\n-}\n-\n-impl Foo<dyn Sync + Send> {\n-    fn abc() -> bool {\n-        true\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(<dyn Send+Sync>::xyz(), false);\n-    assert_eq!(<dyn Sync+Send>::xyz(), true);\n-    assert_eq!(<dyn Send+Sync>::uvw(), false);\n-    assert_eq!(<dyn Sync+Send+Sync>::uvw(), true);\n-    assert_eq!(<Foo<dyn Send+Sync>>::abc(), false);\n-    assert_eq!(<Foo<dyn Sync+Send>>::abc(), true);\n-}"}, {"sha": "0984362993cb9bef9ba89429914088bf0b03ed9d", "filename": "src/test/run-pass/traits/principal-less-trait-objects.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Frun-pass%2Ftraits%2Fprincipal-less-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Frun-pass%2Ftraits%2Fprincipal-less-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fprincipal-less-trait-objects.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -0,0 +1,41 @@\n+// Check that trait-objects without a principal codegen properly.\n+\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::mem;\n+\n+// Array is to make sure the size is not exactly pointer-size, so\n+// we can be sure we are measuring the right size in the\n+// `size_of_val` test.\n+struct SetOnDrop<'a>(&'a AtomicUsize, [u8; 64]);\n+impl<'a> Drop for SetOnDrop<'a> {\n+    fn drop(&mut self) {\n+        self.0.store(self.0.load(Ordering::Relaxed)+1, Ordering::Relaxed);\n+    }\n+}\n+\n+trait TypeEq<V: ?Sized> {}\n+impl<T: ?Sized> TypeEq<T> for T {}\n+fn assert_types_eq<U: ?Sized, V: ?Sized>() where U: TypeEq<V> {}\n+\n+fn main() {\n+    // Check that different ways of writing the same type are equal.\n+    assert_types_eq::<dyn Sync, dyn Sync + Sync>();\n+    assert_types_eq::<dyn Sync + Send, dyn Send + Sync>();\n+    assert_types_eq::<dyn Sync + Send + Sync, dyn Send + Sync>();\n+\n+    // Check that codegen works.\n+    //\n+    // Using `AtomicUsize` here because `Cell<u32>` is not `Sync`, and\n+    // so can't be made into a `Box<dyn Sync>`.\n+    let c = AtomicUsize::new(0);\n+    {\n+        let d: Box<dyn Sync> = Box::new(SetOnDrop(&c, [0; 64]));\n+\n+        assert_eq!(mem::size_of_val(&*d),\n+                   mem::size_of::<SetOnDrop>());\n+        assert_eq!(mem::align_of_val(&*d),\n+                   mem::align_of::<SetOnDrop>());\n+        assert_eq!(c.load(Ordering::Relaxed), 0);\n+    }\n+    assert_eq!(c.load(Ordering::Relaxed), 1);\n+}"}, {"sha": "fbdef51c13255255e06592294f46758bdcdbda24", "filename": "src/test/ui/issues/issue-33140-hack-boundaries.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-hack-boundaries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-hack-boundaries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140-hack-boundaries.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -0,0 +1,80 @@\n+#![feature(optin_builtin_traits)]\n+#![allow(order_dependent_trait_objects)]\n+\n+// Check that the issue #33140 hack does not allow unintended things.\n+\n+// OK\n+trait Trait0 {\n+}\n+\n+impl Trait0 for dyn Send {}\n+impl Trait0 for dyn Send {}\n+\n+// Problem 1: associated types\n+trait Trait1 {\n+    fn my_fn(&self) {}\n+}\n+\n+impl Trait1 for dyn Send {}\n+impl Trait1 for dyn Send {}\n+//~^ ERROR E0119\n+\n+// Problem 2: negative impl\n+trait Trait2 {\n+}\n+\n+impl Trait2 for dyn Send {}\n+impl !Trait2 for dyn Send {}\n+//~^ ERROR E0119\n+\n+\n+// Problem 3: type parameter\n+trait Trait3<T: ?Sized> {\n+}\n+\n+impl Trait3<dyn Sync> for dyn Send {}\n+impl Trait3<dyn Sync> for dyn Send {}\n+//~^ ERROR E0119\n+\n+// Problem 4a: not a trait object - generic\n+trait Trait4a {\n+}\n+\n+impl<T: ?Sized> Trait4a for T {}\n+impl Trait4a for dyn Send {}\n+//~^ ERROR E0119\n+\n+// Problem 4b: not a trait object - misc\n+trait Trait4b {\n+}\n+\n+impl Trait4b for () {}\n+impl Trait4b for () {}\n+//~^ ERROR E0119\n+\n+// Problem 4c: not a principal-less trait object\n+trait Trait4c {\n+}\n+\n+impl Trait4c for dyn Trait1 + Send {}\n+impl Trait4c for dyn Trait1 + Send {}\n+//~^ ERROR E0119\n+\n+// Problem 4d: lifetimes\n+trait Trait4d {\n+}\n+\n+impl<'a> Trait4d for dyn Send + 'a {}\n+impl<'a> Trait4d for dyn Send + 'a {}\n+//~^ ERROR E0119\n+\n+\n+// Problem 5: where-clauses\n+trait Trait5 {\n+}\n+\n+impl Trait5 for dyn Send {}\n+impl Trait5 for dyn Send where u32: Copy {}\n+//~^ ERROR E0119\n+\n+fn main() {}"}, {"sha": "95aaa55ba7c67b199f326da15663a73cc6a58eb0", "filename": "src/test/ui/issues/issue-33140-hack-boundaries.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-hack-boundaries.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-hack-boundaries.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140-hack-boundaries.stderr?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -0,0 +1,67 @@\n+error[E0119]: conflicting implementations of trait `Trait1` for type `(dyn std::marker::Send + 'static)`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:19:1\n+   |\n+LL | impl Trait1 for dyn Send {}\n+   | ------------------------ first implementation here\n+LL | impl Trait1 for dyn Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + 'static)`\n+\n+error[E0119]: conflicting implementations of trait `Trait2` for type `(dyn std::marker::Send + 'static)`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:27:1\n+   |\n+LL | impl Trait2 for dyn Send {}\n+   | ------------------------ first implementation here\n+LL | impl !Trait2 for dyn Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + 'static)`\n+\n+error[E0119]: conflicting implementations of trait `Trait3<(dyn std::marker::Sync + 'static)>` for type `(dyn std::marker::Send + 'static)`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:36:1\n+   |\n+LL | impl Trait3<dyn Sync> for dyn Send {}\n+   | ---------------------------------- first implementation here\n+LL | impl Trait3<dyn Sync> for dyn Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + 'static)`\n+\n+error[E0119]: conflicting implementations of trait `Trait4a` for type `(dyn std::marker::Send + 'static)`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:44:1\n+   |\n+LL | impl<T: ?Sized> Trait4a for T {}\n+   | ----------------------------- first implementation here\n+LL | impl Trait4a for dyn Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + 'static)`\n+\n+error[E0119]: conflicting implementations of trait `Trait4b` for type `()`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:52:1\n+   |\n+LL | impl Trait4b for () {}\n+   | ------------------- first implementation here\n+LL | impl Trait4b for () {}\n+   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+\n+error[E0119]: conflicting implementations of trait `Trait4c` for type `(dyn Trait1 + std::marker::Send + 'static)`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:60:1\n+   |\n+LL | impl Trait4c for dyn Trait1 + Send {}\n+   | ---------------------------------- first implementation here\n+LL | impl Trait4c for dyn Trait1 + Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn Trait1 + std::marker::Send + 'static)`\n+\n+error[E0119]: conflicting implementations of trait `Trait4d` for type `dyn std::marker::Send`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:68:1\n+   |\n+LL | impl<'a> Trait4d for dyn Send + 'a {}\n+   | ---------------------------------- first implementation here\n+LL | impl<'a> Trait4d for dyn Send + 'a {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `dyn std::marker::Send`\n+\n+error[E0119]: conflicting implementations of trait `Trait5` for type `(dyn std::marker::Send + 'static)`:\n+  --> $DIR/issue-33140-hack-boundaries.rs:77:1\n+   |\n+LL | impl Trait5 for dyn Send {}\n+   | ------------------------ first implementation here\n+LL | impl Trait5 for dyn Send where u32: Copy {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + 'static)`\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "2b644817df1158272ad890c6a34bf0c2fc3664d6", "filename": "src/test/ui/issues/issue-33140-traitobject-crate.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-traitobject-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-traitobject-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140-traitobject-crate.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -0,0 +1,101 @@\n+// compile-pass\n+\n+#![warn(order_dependent_trait_objects)]\n+\n+// Check that traitobject 0.1.0 compiles\n+\n+//! # traitobject\n+//!\n+//! Unsafe helpers for working with raw TraitObjects.\n+\n+/// A trait implemented for all trait objects.\n+///\n+/// Implementations for all traits in std are provided.\n+pub unsafe trait Trait {}\n+\n+unsafe impl Trait for ::std::any::Any + Send { }\n+unsafe impl Trait for ::std::any::Any + Sync { }\n+unsafe impl Trait for ::std::any::Any + Send + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::borrow::Borrow<T> + Send { }\n+unsafe impl<T: ?Sized> Trait for ::std::borrow::Borrow<T> + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::borrow::Borrow<T> + Send + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::borrow::BorrowMut<T> + Send { }\n+unsafe impl<T: ?Sized> Trait for ::std::borrow::BorrowMut<T> + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::borrow::BorrowMut<T> + Send + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::convert::AsMut<T> + Send { }\n+unsafe impl<T: ?Sized> Trait for ::std::convert::AsMut<T> + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::convert::AsMut<T> + Send + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::convert::AsRef<T> + Send { }\n+unsafe impl<T: ?Sized> Trait for ::std::convert::AsRef<T> + Sync { }\n+unsafe impl<T: ?Sized> Trait for ::std::convert::AsRef<T> + Send + Sync { }\n+unsafe impl Trait for ::std::error::Error + Send { }\n+unsafe impl Trait for ::std::error::Error + Sync { }\n+unsafe impl Trait for ::std::error::Error + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::Binary + Send { }\n+unsafe impl Trait for ::std::fmt::Binary + Sync { }\n+unsafe impl Trait for ::std::fmt::Binary + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::Debug + Send { }\n+unsafe impl Trait for ::std::fmt::Debug + Sync { }\n+unsafe impl Trait for ::std::fmt::Debug + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::Display + Send { }\n+unsafe impl Trait for ::std::fmt::Display + Sync { }\n+unsafe impl Trait for ::std::fmt::Display + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::LowerExp + Send { }\n+unsafe impl Trait for ::std::fmt::LowerExp + Sync { }\n+unsafe impl Trait for ::std::fmt::LowerExp + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::LowerHex + Send { }\n+unsafe impl Trait for ::std::fmt::LowerHex + Sync { }\n+unsafe impl Trait for ::std::fmt::LowerHex + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::Octal + Send { }\n+unsafe impl Trait for ::std::fmt::Octal + Sync { }\n+unsafe impl Trait for ::std::fmt::Octal + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::Pointer + Send { }\n+unsafe impl Trait for ::std::fmt::Pointer + Sync { }\n+unsafe impl Trait for ::std::fmt::Pointer + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::UpperExp + Send { }\n+unsafe impl Trait for ::std::fmt::UpperExp + Sync { }\n+unsafe impl Trait for ::std::fmt::UpperExp + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::UpperHex + Send { }\n+unsafe impl Trait for ::std::fmt::UpperHex + Sync { }\n+unsafe impl Trait for ::std::fmt::UpperHex + Send + Sync { }\n+unsafe impl Trait for ::std::fmt::Write + Send { }\n+unsafe impl Trait for ::std::fmt::Write + Sync { }\n+unsafe impl Trait for ::std::fmt::Write + Send + Sync { }\n+unsafe impl Trait for ::std::hash::Hasher + Send { }\n+unsafe impl Trait for ::std::hash::Hasher + Sync { }\n+unsafe impl Trait for ::std::hash::Hasher + Send + Sync { }\n+unsafe impl Trait for ::std::io::BufRead + Send { }\n+unsafe impl Trait for ::std::io::BufRead + Sync { }\n+unsafe impl Trait for ::std::io::BufRead + Send + Sync { }\n+unsafe impl Trait for ::std::io::Read + Send { }\n+unsafe impl Trait for ::std::io::Read + Sync { }\n+unsafe impl Trait for ::std::io::Read + Send + Sync { }\n+unsafe impl Trait for ::std::io::Seek + Send { }\n+unsafe impl Trait for ::std::io::Seek + Sync { }\n+unsafe impl Trait for ::std::io::Seek + Send + Sync { }\n+unsafe impl Trait for ::std::io::Write + Send { }\n+unsafe impl Trait for ::std::io::Write + Sync { }\n+unsafe impl Trait for ::std::io::Write + Send + Sync { }\n+unsafe impl<T, I> Trait for ::std::iter::IntoIterator<IntoIter=I, Item=T> { }\n+unsafe impl<T> Trait for ::std::iter::Iterator<Item=T> + Send { }\n+unsafe impl<T> Trait for ::std::iter::Iterator<Item=T> + Sync { }\n+unsafe impl<T> Trait for ::std::iter::Iterator<Item=T> + Send + Sync { }\n+unsafe impl Trait for ::std::marker::Send + Send { }\n+unsafe impl Trait for ::std::marker::Send + Sync { }\n+unsafe impl Trait for ::std::marker::Send + Send + Sync { }\n+unsafe impl Trait for ::std::marker::Sync + Send { }\n+unsafe impl Trait for ::std::marker::Sync + Sync { }\n+unsafe impl Trait for ::std::marker::Sync + Send + Sync { }\n+unsafe impl Trait for ::std::ops::Drop + Send { }\n+unsafe impl Trait for ::std::ops::Drop + Sync { }\n+unsafe impl Trait for ::std::ops::Drop + Send + Sync { }\n+unsafe impl Trait for ::std::string::ToString + Send { }\n+unsafe impl Trait for ::std::string::ToString + Sync { }\n+unsafe impl Trait for ::std::string::ToString + Send + Sync { }\n+fn assert_trait<T: Trait + ?Sized>() {}\n+\n+fn main() {\n+    assert_trait::<dyn Send>();\n+    assert_trait::<dyn Sync>();\n+    assert_trait::<dyn Send + Sync>();\n+}"}, {"sha": "6f71e79d0ee7a69595ef5a6102f76a56d9b49300", "filename": "src/test/ui/issues/issue-33140-traitobject-crate.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-traitobject-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140-traitobject-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140-traitobject-crate.stderr?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -0,0 +1,39 @@\n+warning: conflicting implementations of trait `Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/issue-33140-traitobject-crate.rs:85:1\n+   |\n+LL | unsafe impl Trait for ::std::marker::Send + Sync { }\n+   | ------------------------------------------------ first implementation here\n+LL | unsafe impl Trait for ::std::marker::Send + Send + Sync { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-33140-traitobject-crate.rs:3:9\n+   |\n+LL | #![warn(order_dependent_trait_objects)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+warning: conflicting implementations of trait `Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/issue-33140-traitobject-crate.rs:86:1\n+   |\n+LL | unsafe impl Trait for ::std::marker::Send + Send + Sync { }\n+   | ------------------------------------------------------- first implementation here\n+LL | unsafe impl Trait for ::std::marker::Sync + Send { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+warning: conflicting implementations of trait `Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/issue-33140-traitobject-crate.rs:88:1\n+   |\n+LL | unsafe impl Trait for ::std::marker::Sync + Send { }\n+   | ------------------------------------------------ first implementation here\n+LL | unsafe impl Trait for ::std::marker::Sync + Sync { }\n+LL | unsafe impl Trait for ::std::marker::Sync + Send + Sync { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+"}, {"sha": "930e24218ac72a49319065d5ac344c6be2f05363", "filename": "src/test/ui/issues/issue-33140.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -1,5 +1,3 @@\n-#![deny(order_dependent_trait_objects)]\n-\n trait Trait {\n     fn xyz() -> bool;\n }\n@@ -10,7 +8,6 @@ impl Trait for dyn Send + Sync {\n \n impl Trait for dyn Sync + Send {\n //~^ ERROR conflicting implementations\n-//~| hard error\n     fn xyz() -> bool { true }\n }\n \n@@ -24,14 +21,12 @@ impl Trait2 for dyn Send + Sync {\n \n impl Trait2 for dyn Sync + Send + Sync {\n //~^ ERROR conflicting implementations\n-//~| hard error\n     fn uvw() -> bool { true }\n }\n \n struct Foo<T: ?Sized>(T);\n impl Foo<dyn Send + Sync> {\n     fn abc() -> bool { //~ ERROR duplicate definitions with name `abc`\n-                       //~| hard error\n         false\n     }\n }"}, {"sha": "e2631e971c5166647b043fd6488a4040ee103fc3", "filename": "src/test/ui/issues/issue-33140.stderr", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-33140.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140.stderr?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -1,37 +1,25 @@\n-error: conflicting implementations of trait `Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n-  --> $DIR/issue-33140.rs:11:1\n+error[E0119]: conflicting implementations of trait `Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`:\n+  --> $DIR/issue-33140.rs:9:1\n    |\n LL | impl Trait for dyn Send + Sync {\n    | ------------------------------ first implementation here\n ...\n LL | impl Trait for dyn Sync + Send {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n-   |\n-note: lint level defined here\n-  --> $DIR/issue-33140.rs:1:9\n-   |\n-LL | #![deny(order_dependent_trait_objects)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n \n-error: conflicting implementations of trait `Trait2` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n-  --> $DIR/issue-33140.rs:25:1\n+error[E0119]: conflicting implementations of trait `Trait2` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`:\n+  --> $DIR/issue-33140.rs:22:1\n    |\n LL | impl Trait2 for dyn Send + Sync {\n    | ------------------------------- first implementation here\n ...\n LL | impl Trait2 for dyn Sync + Send + Sync {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n \n-error: duplicate definitions with name `abc` (E0592)\n-  --> $DIR/issue-33140.rs:33:5\n+error[E0592]: duplicate definitions with name `abc`\n+  --> $DIR/issue-33140.rs:29:5\n    |\n LL | /     fn abc() -> bool { //~ ERROR duplicate definitions with name `abc`\n-LL | |                        //~| hard error\n LL | |         false\n LL | |     }\n    | |_____^ duplicate definitions for `abc`\n@@ -40,9 +28,8 @@ LL | /     fn abc() -> bool {\n LL | |         true\n LL | |     }\n    | |_____- other definition for `abc`\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n \n error: aborting due to 3 previous errors\n \n+Some errors occurred: E0119, E0592.\n+For more information about an error, try `rustc --explain E0119`."}, {"sha": "abe0887e927b5cd15738b8748f7d15cfc7799692", "filename": "src/test/ui/issues/issue-57162.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-57162.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba17fc972f89fe9165fbed77d2f0ad6d3e2174/src%2Ftest%2Fui%2Fissues%2Fissue-57162.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57162.rs?ref=2fba17fc972f89fe9165fbed77d2f0ad6d3e2174", "patch": "@@ -0,0 +1,7 @@\n+// compile-pass\n+\n+trait Foo {}\n+impl Foo for dyn Send {}\n+\n+impl<T: Sync + Sync> Foo for T {}\n+fn main() {}"}]}