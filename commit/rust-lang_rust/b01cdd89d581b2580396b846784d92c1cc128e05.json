{"sha": "b01cdd89d581b2580396b846784d92c1cc128e05", "node_id": "C_kwDOAAsO6NoAKGIwMWNkZDg5ZDU4MWIyNTgwMzk2Yjg0Njc4NGQ5MmMxY2MxMjhlMDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-27T12:59:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-27T12:59:45Z"}, "message": "Auto merge of #13189 - unexge:unconfigured-diagnostics-for-fields, r=Veykril\n\nEmit unconfigured code diagnostics for enum variants and struct/union fields\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12664", "tree": {"sha": "344b81f6e4c6693f7a770c726ab75a0d60c4fb2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/344b81f6e4c6693f7a770c726ab75a0d60c4fb2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01cdd89d581b2580396b846784d92c1cc128e05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01cdd89d581b2580396b846784d92c1cc128e05", "html_url": "https://github.com/rust-lang/rust/commit/b01cdd89d581b2580396b846784d92c1cc128e05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01cdd89d581b2580396b846784d92c1cc128e05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f972cdd5fc4f5eb312773635804b0f1ccebdf45e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f972cdd5fc4f5eb312773635804b0f1ccebdf45e", "html_url": "https://github.com/rust-lang/rust/commit/f972cdd5fc4f5eb312773635804b0f1ccebdf45e"}, {"sha": "7e5e5177b60c7986d6d8b776b112219d99d23969", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e5e5177b60c7986d6d8b776b112219d99d23969", "html_url": "https://github.com/rust-lang/rust/commit/7e5e5177b60c7986d6d8b776b112219d99d23969"}], "stats": {"total": 312, "additions": 255, "deletions": 57}, "files": [{"sha": "938db032fbc8b6a79b130030750b1e48898857bd", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 129, "deletions": 35, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -6,7 +6,7 @@ use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n-    InFile,\n+    HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n use syntax::ast::{self, HasName, HasVisibility};\n@@ -17,13 +17,15 @@ use crate::{\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n+    item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n-    EnumId, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+    EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n+    VariantId,\n };\n use cfg::CfgOptions;\n \n@@ -143,43 +145,87 @@ fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n+        db.struct_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn struct_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: StructId,\n+    ) -> (Arc<StructData>, Arc<[DefDiagnostic]>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &strukt.fields, None);\n-        Arc::new(StructData {\n-            name: strukt.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[strukt.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &strukt.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: strukt.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[strukt.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n \n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n+        db.union_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn union_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: UnionId,\n+    ) -> (Arc<StructData>, Arc<[DefDiagnostic]>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &union.fields, None);\n-\n-        Arc::new(StructData {\n-            name: union.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[union.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &union.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: union.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[union.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n }\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n+        db.enum_data_with_diagnostics(e).0\n+    }\n+\n+    pub(crate) fn enum_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        e: EnumId,\n+    ) -> (Arc<EnumData>, Arc<[DefDiagnostic]>) {\n         let loc = e.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n@@ -188,31 +234,46 @@ impl EnumData {\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n+        let mut diagnostics = Vec::new();\n         for tree_id in enum_.variants.clone() {\n-            if item_tree.attrs(db, krate, tree_id.into()).is_cfg_enabled(&cfg_options) {\n-                let var = &item_tree[tree_id];\n-                let var_data = lower_fields(\n+            let attrs = item_tree.attrs(db, krate, tree_id.into());\n+            let var = &item_tree[tree_id];\n+            if attrs.is_cfg_enabled(&cfg_options) {\n+                let (var_data, field_diagnostics) = lower_fields(\n                     db,\n                     krate,\n+                    loc.id.file_id(),\n+                    loc.container.local_id,\n                     &item_tree,\n                     &cfg_options,\n                     &var.fields,\n                     Some(enum_.visibility),\n                 );\n+                diagnostics.extend(field_diagnostics);\n \n                 variants.alloc(EnumVariantData {\n                     name: var.name.clone(),\n                     variant_data: Arc::new(var_data),\n                 });\n+            } else {\n+                diagnostics.push(DefDiagnostic::unconfigured_code(\n+                    loc.container.local_id,\n+                    InFile::new(loc.id.file_id(), var.ast_id.upcast()),\n+                    attrs.cfg().unwrap(),\n+                    cfg_options.clone(),\n+                ))\n             }\n         }\n \n-        Arc::new(EnumData {\n-            name: enum_.name.clone(),\n-            variants,\n-            repr,\n-            visibility: item_tree[enum_.visibility].clone(),\n-        })\n+        (\n+            Arc::new(EnumData {\n+                name: enum_.name.clone(),\n+                variants,\n+                repr,\n+                visibility: item_tree[enum_.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n@@ -384,31 +445,64 @@ fn lower_struct(\n fn lower_fields(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n+    current_file_id: HirFileId,\n+    container: LocalModuleId,\n     item_tree: &ItemTree,\n     cfg_options: &CfgOptions,\n     fields: &Fields,\n     override_visibility: Option<RawVisibilityId>,\n-) -> VariantData {\n+) -> (VariantData, Vec<DefDiagnostic>) {\n+    let mut diagnostics = Vec::new();\n     match fields {\n         Fields::Record(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Record(arena)\n+            (VariantData::Record(arena), diagnostics)\n         }\n         Fields::Tuple(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Tuple(arena)\n+            (VariantData::Tuple(arena), diagnostics)\n         }\n-        Fields::Unit => VariantData::Unit,\n+        Fields::Unit => (VariantData::Unit, diagnostics),\n     }\n }\n "}, {"sha": "2dc69b00ace00d12659f844b1ceafee85a2b4957", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -219,7 +219,7 @@ impl TraitData {\n     pub(crate) fn trait_data_with_diagnostics_query(\n         db: &dyn DefDatabase,\n         tr: TraitId,\n-    ) -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>) {\n+    ) -> (Arc<TraitData>, Arc<[DefDiagnostic]>) {\n         let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n         let item_tree = tree_id.item_tree(db);\n         let tr_def = &item_tree[tree_id.value];\n@@ -251,7 +251,7 @@ impl TraitData {\n                 visibility,\n                 skip_array_during_method_dispatch,\n             }),\n-            Arc::new(diagnostics),\n+            diagnostics.into(),\n         )\n     }\n \n@@ -299,7 +299,7 @@ impl ImplData {\n     pub(crate) fn impl_data_with_diagnostics_query(\n         db: &dyn DefDatabase,\n         id: ImplId,\n-    ) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>) {\n+    ) -> (Arc<ImplData>, Arc<[DefDiagnostic]>) {\n         let _p = profile::span(\"impl_data_with_diagnostics_query\");\n         let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n@@ -318,7 +318,7 @@ impl ImplData {\n \n         (\n             Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls }),\n-            Arc::new(diagnostics),\n+            diagnostics.into(),\n         )\n     }\n "}, {"sha": "431c8255497b62e17741350c424f069f23b04f11", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -97,24 +97,33 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::struct_data_with_diagnostics_query)]\n+    fn struct_data_with_diagnostics(&self, id: StructId)\n+        -> (Arc<StructData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(StructData::union_data_query)]\n     fn union_data(&self, id: UnionId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::union_data_with_diagnostics_query)]\n+    fn union_data_with_diagnostics(&self, id: UnionId) -> (Arc<StructData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n \n+    #[salsa::invoke(EnumData::enum_data_with_diagnostics_query)]\n+    fn enum_data_with_diagnostics(&self, e: EnumId) -> (Arc<EnumData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n     #[salsa::invoke(ImplData::impl_data_with_diagnostics_query)]\n-    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>);\n+    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<[DefDiagnostic]>);\n \n     #[salsa::invoke(TraitData::trait_data_query)]\n     fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n \n     #[salsa::invoke(TraitData::trait_data_with_diagnostics_query)]\n-    fn trait_data_with_diagnostics(&self, tr: TraitId)\n-        -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>);\n+    fn trait_data_with_diagnostics(&self, tr: TraitId) -> (Arc<TraitData>, Arc<[DefDiagnostic]>);\n \n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;"}, {"sha": "570344596def80a2c62711c72ba2b1fa11358dbf", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -943,6 +943,7 @@ impl AssocItem {\n pub struct Variant {\n     pub name: Name,\n     pub fields: Fields,\n+    pub ast_id: FileAstId<ast::Variant>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -952,10 +953,17 @@ pub enum Fields {\n     Unit,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum FieldAstId {\n+    Record(FileAstId<ast::RecordField>),\n+    Tuple(FileAstId<ast::TupleField>),\n+}\n+\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Field {\n     pub name: Name,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibilityId,\n+    pub ast_id: FieldAstId,\n }"}, {"sha": "077a1b619dd5a056cd89c79a14e260b32aafc7ed", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -184,7 +184,8 @@ impl<'a> Ctx<'a> {\n         let name = field.name()?.as_name();\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        let res = Field { name, type_ref, visibility };\n+        let ast_id = FieldAstId::Record(self.source_ast_id_map.ast_id(field));\n+        let res = Field { name, type_ref, visibility, ast_id };\n         Some(res)\n     }\n \n@@ -203,7 +204,8 @@ impl<'a> Ctx<'a> {\n         let name = Name::new_tuple_field(idx);\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        Field { name, type_ref, visibility }\n+        let ast_id = FieldAstId::Tuple(self.source_ast_id_map.ast_id(field));\n+        Field { name, type_ref, visibility, ast_id }\n     }\n \n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n@@ -247,7 +249,8 @@ impl<'a> Ctx<'a> {\n     fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n         let name = variant.name()?.as_name();\n         let fields = self.lower_fields(&variant.kind());\n-        let res = Variant { name, fields };\n+        let ast_id = self.source_ast_id_map.ast_id(variant);\n+        let res = Variant { name, fields, ast_id };\n         Some(res)\n     }\n "}, {"sha": "da1643152c2fe09f3683aeb495b67f3371e3c4ff", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -115,7 +115,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"{{\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -129,7 +129,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"(\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -323,7 +323,7 @@ impl<'a> Printer<'a> {\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n-                        let Variant { name, fields } = &this.tree[variant];\n+                        let Variant { name, fields, ast_id: _ } = &this.tree[variant];\n                         this.print_attrs_of(variant);\n                         w!(this, \"{}\", name);\n                         this.print_fields(fields);"}, {"sha": "9ffc218818ca164cd91f0609941b3a7f5e80d8a2", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -2122,7 +2122,7 @@ impl ModCollector<'_, '_> {\n     fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n         let ast_id = item.ast_id(self.item_tree);\n \n-        let ast_id = InFile::new(self.file_id(), ast_id);\n+        let ast_id = InFile::new(self.file_id(), ast_id.upcast());\n         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n             self.module_id,\n             ast_id,"}, {"sha": "066142291981dd9debf879d8a1ece627f2292a32", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -4,7 +4,7 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::MacroCallKind;\n use la_arena::Idx;\n-use syntax::ast;\n+use syntax::ast::{self, AnyHasAttrs};\n \n use crate::{\n     attr::AttrId,\n@@ -22,7 +22,7 @@ pub enum DefDiagnosticKind {\n \n     UnresolvedImport { id: ItemTreeId<item_tree::Import>, index: Idx<ast::UseTree> },\n \n-    UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n+    UnconfiguredCode { ast: AstId<AnyHasAttrs>, cfg: CfgExpr, opts: CfgOptions },\n \n     UnresolvedProcMacro { ast: MacroCallKind, krate: CrateId },\n \n@@ -75,7 +75,7 @@ impl DefDiagnostic {\n \n     pub fn unconfigured_code(\n         container: LocalModuleId,\n-        ast: AstId<ast::Item>,\n+        ast: AstId<ast::AnyHasAttrs>,\n         cfg: CfgExpr,\n         opts: CfgOptions,\n     ) -> Self {"}, {"sha": "2b27db0e950630e34601f19640d691f27bad5835", "filename": "crates/hir-expand/src/ast_id_map.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -93,7 +93,12 @@ impl AstIdMap {\n         // trait does not change ids of top-level items, which helps caching.\n         bdfs(node, |it| {\n             let kind = it.kind();\n-            if ast::Item::can_cast(kind) || ast::BlockExpr::can_cast(kind) {\n+            if ast::Item::can_cast(kind)\n+                || ast::BlockExpr::can_cast(kind)\n+                || ast::Variant::can_cast(kind)\n+                || ast::RecordField::can_cast(kind)\n+                || ast::TupleField::can_cast(kind)\n+            {\n                 res.alloc(&it);\n                 true\n             } else {"}, {"sha": "c5dc60f1ec5f962e319af3c48191fe2769984243", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -1,7 +1,7 @@\n //! Re-export diagnostics such that clients of `hir` don't have to depend on\n //! low-level crates.\n //!\n-//! This probably isn't the best way to do this -- ideally, diagnistics should\n+//! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};"}, {"sha": "d1c8fa59aef473b850f52bfd4993932514d75fcb", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -540,9 +540,27 @@ impl Module {\n                     }\n                     acc.extend(decl.diagnostics(db))\n                 }\n-                ModuleDef::Adt(Adt::Enum(e)) => {\n-                    for v in e.variants(db) {\n-                        acc.extend(ModuleDef::Variant(v).diagnostics(db));\n+                ModuleDef::Adt(adt) => {\n+                    match adt {\n+                        Adt::Struct(s) => {\n+                            for diag in db.struct_data_with_diagnostics(s.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Union(u) => {\n+                            for diag in db.union_data_with_diagnostics(u.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Enum(e) => {\n+                            for v in e.variants(db) {\n+                                acc.extend(ModuleDef::Variant(v).diagnostics(db));\n+                            }\n+\n+                            for diag in db.enum_data_with_diagnostics(e.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n                     }\n                     acc.extend(decl.diagnostics(db))\n                 }"}, {"sha": "f558b7256a4c6473aad6f452d57aea3a0bca0fa1", "filename": "crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -137,6 +137,37 @@ trait Bar {\n \n     #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: no is disabled\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inactive_fields_and_variants() {\n+        check(\n+            r#\"\n+enum Foo {\n+  #[cfg(a)] Bar,\n+//^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  Baz {\n+    #[cfg(a)] baz: String,\n+  //^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  },\n+  Qux(#[cfg(a)] String),\n+    //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Baz {\n+  #[cfg(a)] baz: String,\n+//^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Qux(#[cfg(a)] String);\n+         //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+\n+union FooBar {\n+  #[cfg(a)] baz: u32,\n+//^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n \"#,\n         );\n     }"}, {"sha": "fe82aa907222f7d4e97d03c69cd91d420c276c3c", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01cdd89d581b2580396b846784d92c1cc128e05/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=b01cdd89d581b2580396b846784d92c1cc128e05", "patch": "@@ -873,3 +873,33 @@ impl ast::MatchGuard {\n         support::child(&self.syntax)\n     }\n }\n+\n+impl From<ast::Item> for ast::AnyHasAttrs {\n+    fn from(node: ast::Item) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::AssocItem> for ast::AnyHasAttrs {\n+    fn from(node: ast::AssocItem) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::Variant> for ast::AnyHasAttrs {\n+    fn from(node: ast::Variant) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::RecordField> for ast::AnyHasAttrs {\n+    fn from(node: ast::RecordField) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::TupleField> for ast::AnyHasAttrs {\n+    fn from(node: ast::TupleField) -> Self {\n+        Self::new(node)\n+    }\n+}"}]}