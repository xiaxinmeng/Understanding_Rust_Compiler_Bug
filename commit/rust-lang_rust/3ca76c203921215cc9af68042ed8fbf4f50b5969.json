{"sha": "3ca76c203921215cc9af68042ed8fbf4f50b5969", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYTc2YzIwMzkyMTIxNWNjOWFmNjgwNDJlZDhmYmY0ZjUwYjU5Njk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-10T14:50:49Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-10T14:50:49Z"}, "message": "move join_lines to a separate module", "tree": {"sha": "52d77756f5d60161fa361e8772bbda78ccee3950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52d77756f5d60161fa361e8772bbda78ccee3950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ca76c203921215cc9af68042ed8fbf4f50b5969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca76c203921215cc9af68042ed8fbf4f50b5969", "html_url": "https://github.com/rust-lang/rust/commit/3ca76c203921215cc9af68042ed8fbf4f50b5969", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ca76c203921215cc9af68042ed8fbf4f50b5969/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aca14c591fea40b2f803bbf5f02c1571732348fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/aca14c591fea40b2f803bbf5f02c1571732348fb", "html_url": "https://github.com/rust-lang/rust/commit/aca14c591fea40b2f803bbf5f02c1571732348fb"}], "stats": {"total": 990, "additions": 503, "deletions": 487}, "files": [{"sha": "bda6be8789c642a6f933ab327b8b3c0a1cb778d3", "filename": "crates/ra_ide_api_light/src/join_lines.rs", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/3ca76c203921215cc9af68042ed8fbf4f50b5969/crates%2Fra_ide_api_light%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca76c203921215cc9af68042ed8fbf4f50b5969/crates%2Fra_ide_api_light%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fjoin_lines.rs?ref=3ca76c203921215cc9af68042ed8fbf4f50b5969", "patch": "@@ -0,0 +1,493 @@\n+use std::mem;\n+\n+use itertools::Itertools;\n+use ra_syntax::{\n+    SourceFile, TextRange, TextUnit, AstNode, SyntaxNode,\n+    SyntaxKind::{self, WHITESPACE, COMMA, L_CURLY, R_CURLY, L_PAREN, R_PAREN, L_BRACK, R_BRACK, USE_TREE, DOT},\n+    algo::find_covering_node,\n+    ast,\n+};\n+\n+use crate::{LocalEdit, TextEditBuilder};\n+\n+pub fn join_lines(file: &SourceFile, range: TextRange) -> LocalEdit {\n+    let range = if range.is_empty() {\n+        let syntax = file.syntax();\n+        let text = syntax.text().slice(range.start()..);\n+        let pos = match text.find('\\n') {\n+            None => {\n+                return LocalEdit {\n+                    label: \"join lines\".to_string(),\n+                    edit: TextEditBuilder::default().finish(),\n+                    cursor_position: None,\n+                };\n+            }\n+            Some(pos) => pos,\n+        };\n+        TextRange::offset_len(range.start() + pos, TextUnit::of_char('\\n'))\n+    } else {\n+        range\n+    };\n+\n+    let node = find_covering_node(file.syntax(), range);\n+    let mut edit = TextEditBuilder::default();\n+    for node in node.descendants() {\n+        let text = match node.leaf_text() {\n+            Some(text) => text,\n+            None => continue,\n+        };\n+        let range = match range.intersection(&node.range()) {\n+            Some(range) => range,\n+            None => continue,\n+        } - node.range().start();\n+        for (pos, _) in text[range].bytes().enumerate().filter(|&(_, b)| b == b'\\n') {\n+            let pos: TextUnit = (pos as u32).into();\n+            let off = node.range().start() + range.start() + pos;\n+            if !edit.invalidates_offset(off) {\n+                remove_newline(&mut edit, node, text.as_str(), off);\n+            }\n+        }\n+    }\n+\n+    LocalEdit {\n+        label: \"join lines\".to_string(),\n+        edit: edit.finish(),\n+        cursor_position: None,\n+    }\n+}\n+\n+fn remove_newline(\n+    edit: &mut TextEditBuilder,\n+    node: &SyntaxNode,\n+    node_text: &str,\n+    offset: TextUnit,\n+) {\n+    if node.kind() != WHITESPACE || node_text.bytes().filter(|&b| b == b'\\n').count() != 1 {\n+        // The node is either the first or the last in the file\n+        let suff = &node_text[TextRange::from_to(\n+            offset - node.range().start() + TextUnit::of_char('\\n'),\n+            TextUnit::of_str(node_text),\n+        )];\n+        let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n+\n+        edit.replace(\n+            TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n+            \" \".to_string(),\n+        );\n+        return;\n+    }\n+\n+    // Special case that turns something like:\n+    //\n+    // ```\n+    // my_function({<|>\n+    //    <some-expr>\n+    // })\n+    // ```\n+    //\n+    // into `my_function(<some-expr>)`\n+    if join_single_expr_block(edit, node).is_some() {\n+        return;\n+    }\n+    // ditto for\n+    //\n+    // ```\n+    // use foo::{<|>\n+    //    bar\n+    // };\n+    // ```\n+    if join_single_use_tree(edit, node).is_some() {\n+        return;\n+    }\n+\n+    // The node is between two other nodes\n+    let prev = node.prev_sibling().unwrap();\n+    let next = node.next_sibling().unwrap();\n+    if is_trailing_comma(prev.kind(), next.kind()) {\n+        // Removes: trailing comma, newline (incl. surrounding whitespace)\n+        edit.delete(TextRange::from_to(prev.range().start(), node.range().end()));\n+    } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n+        // Removes: comma, newline (incl. surrounding whitespace)\n+        let space = if let Some(left) = prev.prev_sibling() {\n+            compute_ws(left, next)\n+        } else {\n+            \" \"\n+        };\n+        edit.replace(\n+            TextRange::from_to(prev.range().start(), node.range().end()),\n+            space.to_string(),\n+        );\n+    } else if let (Some(_), Some(next)) = (ast::Comment::cast(prev), ast::Comment::cast(next)) {\n+        // Removes: newline (incl. surrounding whitespace), start of the next comment\n+        edit.delete(TextRange::from_to(\n+            node.range().start(),\n+            next.syntax().range().start() + TextUnit::of_str(next.prefix()),\n+        ));\n+    } else {\n+        // Remove newline but add a computed amount of whitespace characters\n+        edit.replace(node.range(), compute_ws(prev, next).to_string());\n+    }\n+}\n+\n+fn join_single_expr_block(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n+    let block = ast::Block::cast(node.parent()?)?;\n+    let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n+    let expr = single_expr(block)?;\n+    edit.replace(\n+        block_expr.syntax().range(),\n+        expr.syntax().text().to_string(),\n+    );\n+    Some(())\n+}\n+\n+fn single_expr(block: &ast::Block) -> Option<&ast::Expr> {\n+    let mut res = None;\n+    for child in block.syntax().children() {\n+        if let Some(expr) = ast::Expr::cast(child) {\n+            if expr.syntax().text().contains('\\n') {\n+                return None;\n+            }\n+            if mem::replace(&mut res, Some(expr)).is_some() {\n+                return None;\n+            }\n+        } else {\n+            match child.kind() {\n+                WHITESPACE | L_CURLY | R_CURLY => (),\n+                _ => return None,\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+fn join_single_use_tree(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n+    let use_tree_list = ast::UseTreeList::cast(node.parent()?)?;\n+    let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n+    edit.replace(\n+        use_tree_list.syntax().range(),\n+        tree.syntax().text().to_string(),\n+    );\n+    Some(())\n+}\n+\n+fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n+    match (left, right) {\n+        (COMMA, R_PAREN) | (COMMA, R_BRACK) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn compute_ws(left: &SyntaxNode, right: &SyntaxNode) -> &'static str {\n+    match left.kind() {\n+        L_PAREN | L_BRACK => return \"\",\n+        L_CURLY => {\n+            if let USE_TREE = right.kind() {\n+                return \"\";\n+            }\n+        }\n+        _ => (),\n+    }\n+    match right.kind() {\n+        R_PAREN | R_BRACK => return \"\",\n+        R_CURLY => {\n+            if let USE_TREE = left.kind() {\n+                return \"\";\n+            }\n+        }\n+        DOT => return \"\",\n+        _ => (),\n+    }\n+    \" \"\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::test_utils::{assert_eq_text, check_action, extract_range};\n+\n+    use super::*;\n+\n+    fn check_join_lines(before: &str, after: &str) {\n+        check_action(before, after, |file, offset| {\n+            let range = TextRange::offset_len(offset, 0.into());\n+            let res = join_lines(file, range);\n+            Some(res)\n+        })\n+    }\n+\n+    #[test]\n+    fn test_join_lines_comma() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    <|>foo(1,\n+    )\n+}\n+\",\n+            r\"\n+fn foo() {\n+    <|>foo(1)\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_lambda_block() {\n+        check_join_lines(\n+            r\"\n+pub fn reparse(&self, edit: &AtomTextEdit) -> File {\n+    <|>self.incremental_reparse(edit).unwrap_or_else(|| {\n+        self.full_reparse(edit)\n+    })\n+}\n+\",\n+            r\"\n+pub fn reparse(&self, edit: &AtomTextEdit) -> File {\n+    <|>self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_block() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    foo(<|>{\n+        92\n+    })\n+}\",\n+            r\"\n+fn foo() {\n+    foo(<|>92)\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_use_items_left() {\n+        // No space after the '{'\n+        check_join_lines(\n+            r\"\n+<|>use ra_syntax::{\n+    TextUnit, TextRange,\n+};\",\n+            r\"\n+<|>use ra_syntax::{TextUnit, TextRange,\n+};\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_use_items_right() {\n+        // No space after the '}'\n+        check_join_lines(\n+            r\"\n+use ra_syntax::{\n+<|>    TextUnit, TextRange\n+};\",\n+            r\"\n+use ra_syntax::{\n+<|>    TextUnit, TextRange};\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_use_items_right_comma() {\n+        // No space after the '}'\n+        check_join_lines(\n+            r\"\n+use ra_syntax::{\n+<|>    TextUnit, TextRange,\n+};\",\n+            r\"\n+use ra_syntax::{\n+<|>    TextUnit, TextRange};\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_use_tree() {\n+        check_join_lines(\n+            r\"\n+use ra_syntax::{\n+    algo::<|>{\n+        find_leaf_at_offset,\n+    },\n+    ast,\n+};\",\n+            r\"\n+use ra_syntax::{\n+    algo::<|>find_leaf_at_offset,\n+    ast,\n+};\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_normal_comments() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    // Hello<|>\n+    // world!\n+}\n+\",\n+            r\"\n+fn foo() {\n+    // Hello<|> world!\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_doc_comments() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    /// Hello<|>\n+    /// world!\n+}\n+\",\n+            r\"\n+fn foo() {\n+    /// Hello<|> world!\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_mod_comments() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    //! Hello<|>\n+    //! world!\n+}\n+\",\n+            r\"\n+fn foo() {\n+    //! Hello<|> world!\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_multiline_comments_1() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    // Hello<|>\n+    /* world! */\n+}\n+\",\n+            r\"\n+fn foo() {\n+    // Hello<|> world! */\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_multiline_comments_2() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    // The<|>\n+    /* quick\n+    brown\n+    fox! */\n+}\n+\",\n+            r\"\n+fn foo() {\n+    // The<|> quick\n+    brown\n+    fox! */\n+}\n+\",\n+        );\n+    }\n+\n+    fn check_join_lines_sel(before: &str, after: &str) {\n+        let (sel, before) = extract_range(before);\n+        let file = SourceFile::parse(&before);\n+        let result = join_lines(&file, sel);\n+        let actual = result.edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    #[test]\n+    fn test_join_lines_selection_fn_args() {\n+        check_join_lines_sel(\n+            r\"\n+fn foo() {\n+    <|>foo(1,\n+        2,\n+        3,\n+    <|>)\n+}\n+    \",\n+            r\"\n+fn foo() {\n+    foo(1, 2, 3)\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_selection_struct() {\n+        check_join_lines_sel(\n+            r\"\n+struct Foo <|>{\n+    f: u32,\n+}<|>\n+    \",\n+            r\"\n+struct Foo { f: u32 }\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_selection_dot_chain() {\n+        check_join_lines_sel(\n+            r\"\n+fn foo() {\n+    join(<|>type_params.type_params()\n+            .filter_map(|it| it.name())\n+            .map(|it| it.text())<|>)\n+}\",\n+            r\"\n+fn foo() {\n+    join(type_params.type_params().filter_map(|it| it.name()).map(|it| it.text()))\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_join_lines_selection_lambda_block_body() {\n+        check_join_lines_sel(\n+            r\"\n+pub fn handle_find_matching_brace() {\n+    params.offsets\n+        .map(|offset| <|>{\n+            world.analysis().matching_brace(&file, offset).unwrap_or(offset)\n+        }<|>)\n+        .collect();\n+}\",\n+            r\"\n+pub fn handle_find_matching_brace() {\n+    params.offsets\n+        .map(|offset| world.analysis().matching_brace(&file, offset).unwrap_or(offset))\n+        .collect();\n+}\",\n+        );\n+    }\n+}"}, {"sha": "e632108ce3ab6f19f7e8e717e99abc26c8c2c457", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ca76c203921215cc9af68042ed8fbf4f50b5969/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca76c203921215cc9af68042ed8fbf4f50b5969/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=3ca76c203921215cc9af68042ed8fbf4f50b5969", "patch": "@@ -11,6 +11,7 @@ mod line_index_utils;\n mod structure;\n #[cfg(test)]\n mod test_utils;\n+mod join_lines;\n mod typing;\n mod diagnostics;\n \n@@ -21,8 +22,10 @@ pub use self::{\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n     structure::{file_structure, StructureNode},\n-    typing::{join_lines, on_enter, on_dot_typed, on_eq_typed},\n-    diagnostics::diagnostics\n+    diagnostics::diagnostics,\n+    join_lines::join_lines,\n+    typing::{on_enter, on_dot_typed, on_eq_typed},\n+\n };\n use ra_text_edit::TextEditBuilder;\n use ra_syntax::{"}, {"sha": "5726209ccea02e03b3c1a7140fadde37a45f7ef9", "filename": "crates/ra_ide_api_light/src/typing.rs", "status": "modified", "additions": 5, "deletions": 485, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/3ca76c203921215cc9af68042ed8fbf4f50b5969/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca76c203921215cc9af68042ed8fbf4f50b5969/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs?ref=3ca76c203921215cc9af68042ed8fbf4f50b5969", "patch": "@@ -1,62 +1,12 @@\n-use std::mem;\n-\n-use itertools::Itertools;\n use ra_syntax::{\n-    algo::{find_node_at_offset, find_covering_node, find_leaf_at_offset, LeafAtOffset},\n+    algo::{find_node_at_offset, find_leaf_at_offset, LeafAtOffset},\n     ast,\n-    AstNode, Direction, SourceFile, SyntaxKind,\n-    SyntaxKind::*,\n-    SyntaxNode, TextRange, TextUnit,\n+    AstNode, Direction, SourceFile, SyntaxKind::*,\n+    SyntaxNode, TextUnit,\n };\n \n use crate::{LocalEdit, TextEditBuilder};\n \n-pub fn join_lines(file: &SourceFile, range: TextRange) -> LocalEdit {\n-    let range = if range.is_empty() {\n-        let syntax = file.syntax();\n-        let text = syntax.text().slice(range.start()..);\n-        let pos = match text.find('\\n') {\n-            None => {\n-                return LocalEdit {\n-                    label: \"join lines\".to_string(),\n-                    edit: TextEditBuilder::default().finish(),\n-                    cursor_position: None,\n-                };\n-            }\n-            Some(pos) => pos,\n-        };\n-        TextRange::offset_len(range.start() + pos, TextUnit::of_char('\\n'))\n-    } else {\n-        range\n-    };\n-\n-    let node = find_covering_node(file.syntax(), range);\n-    let mut edit = TextEditBuilder::default();\n-    for node in node.descendants() {\n-        let text = match node.leaf_text() {\n-            Some(text) => text,\n-            None => continue,\n-        };\n-        let range = match range.intersection(&node.range()) {\n-            Some(range) => range,\n-            None => continue,\n-        } - node.range().start();\n-        for (pos, _) in text[range].bytes().enumerate().filter(|&(_, b)| b == b'\\n') {\n-            let pos: TextUnit = (pos as u32).into();\n-            let off = node.range().start() + range.start() + pos;\n-            if !edit.invalidates_offset(off) {\n-                remove_newline(&mut edit, node, text.as_str(), off);\n-            }\n-        }\n-    }\n-\n-    LocalEdit {\n-        label: \"join lines\".to_string(),\n-        edit: edit.finish(),\n-        cursor_position: None,\n-    }\n-}\n-\n pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let comment = find_leaf_at_offset(file.syntax(), offset)\n         .left_biased()\n@@ -184,441 +134,11 @@ fn last_line_indent_in_whitespace(ws: &str) -> &str {\n     ws.split('\\n').last().unwrap_or(\"\")\n }\n \n-fn remove_newline(\n-    edit: &mut TextEditBuilder,\n-    node: &SyntaxNode,\n-    node_text: &str,\n-    offset: TextUnit,\n-) {\n-    if node.kind() != WHITESPACE || node_text.bytes().filter(|&b| b == b'\\n').count() != 1 {\n-        // The node is either the first or the last in the file\n-        let suff = &node_text[TextRange::from_to(\n-            offset - node.range().start() + TextUnit::of_char('\\n'),\n-            TextUnit::of_str(node_text),\n-        )];\n-        let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n-\n-        edit.replace(\n-            TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n-            \" \".to_string(),\n-        );\n-        return;\n-    }\n-\n-    // Special case that turns something like:\n-    //\n-    // ```\n-    // my_function({<|>\n-    //    <some-expr>\n-    // })\n-    // ```\n-    //\n-    // into `my_function(<some-expr>)`\n-    if join_single_expr_block(edit, node).is_some() {\n-        return;\n-    }\n-    // ditto for\n-    //\n-    // ```\n-    // use foo::{<|>\n-    //    bar\n-    // };\n-    // ```\n-    if join_single_use_tree(edit, node).is_some() {\n-        return;\n-    }\n-\n-    // The node is between two other nodes\n-    let prev = node.prev_sibling().unwrap();\n-    let next = node.next_sibling().unwrap();\n-    if is_trailing_comma(prev.kind(), next.kind()) {\n-        // Removes: trailing comma, newline (incl. surrounding whitespace)\n-        edit.delete(TextRange::from_to(prev.range().start(), node.range().end()));\n-    } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n-        // Removes: comma, newline (incl. surrounding whitespace)\n-        let space = if let Some(left) = prev.prev_sibling() {\n-            compute_ws(left, next)\n-        } else {\n-            \" \"\n-        };\n-        edit.replace(\n-            TextRange::from_to(prev.range().start(), node.range().end()),\n-            space.to_string(),\n-        );\n-    } else if let (Some(_), Some(next)) = (ast::Comment::cast(prev), ast::Comment::cast(next)) {\n-        // Removes: newline (incl. surrounding whitespace), start of the next comment\n-        edit.delete(TextRange::from_to(\n-            node.range().start(),\n-            next.syntax().range().start() + TextUnit::of_str(next.prefix()),\n-        ));\n-    } else {\n-        // Remove newline but add a computed amount of whitespace characters\n-        edit.replace(node.range(), compute_ws(prev, next).to_string());\n-    }\n-}\n-\n-fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n-    match (left, right) {\n-        (COMMA, R_PAREN) | (COMMA, R_BRACK) => true,\n-        _ => false,\n-    }\n-}\n-\n-fn join_single_expr_block(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n-    let block = ast::Block::cast(node.parent()?)?;\n-    let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n-    let expr = single_expr(block)?;\n-    edit.replace(\n-        block_expr.syntax().range(),\n-        expr.syntax().text().to_string(),\n-    );\n-    Some(())\n-}\n-\n-fn single_expr(block: &ast::Block) -> Option<&ast::Expr> {\n-    let mut res = None;\n-    for child in block.syntax().children() {\n-        if let Some(expr) = ast::Expr::cast(child) {\n-            if expr.syntax().text().contains('\\n') {\n-                return None;\n-            }\n-            if mem::replace(&mut res, Some(expr)).is_some() {\n-                return None;\n-            }\n-        } else {\n-            match child.kind() {\n-                WHITESPACE | L_CURLY | R_CURLY => (),\n-                _ => return None,\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-fn join_single_use_tree(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(node.parent()?)?;\n-    let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n-    edit.replace(\n-        use_tree_list.syntax().range(),\n-        tree.syntax().text().to_string(),\n-    );\n-    Some(())\n-}\n-\n-fn compute_ws(left: &SyntaxNode, right: &SyntaxNode) -> &'static str {\n-    match left.kind() {\n-        L_PAREN | L_BRACK => return \"\",\n-        L_CURLY => {\n-            if let USE_TREE = right.kind() {\n-                return \"\";\n-            }\n-        }\n-        _ => (),\n-    }\n-    match right.kind() {\n-        R_PAREN | R_BRACK => return \"\",\n-        R_CURLY => {\n-            if let USE_TREE = left.kind() {\n-                return \"\";\n-            }\n-        }\n-        DOT => return \"\",\n-        _ => (),\n-    }\n-    \" \"\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::test_utils::{\n-        add_cursor, assert_eq_text, check_action, extract_offset, extract_range,\n-};\n-\n-    fn check_join_lines(before: &str, after: &str) {\n-        check_action(before, after, |file, offset| {\n-            let range = TextRange::offset_len(offset, 0.into());\n-            let res = join_lines(file, range);\n-            Some(res)\n-        })\n-    }\n+    use crate::test_utils::{add_cursor, assert_eq_text, extract_offset};\n \n-    #[test]\n-    fn test_join_lines_comma() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    <|>foo(1,\n-    )\n-}\n-\",\n-            r\"\n-fn foo() {\n-    <|>foo(1)\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_lambda_block() {\n-        check_join_lines(\n-            r\"\n-pub fn reparse(&self, edit: &AtomTextEdit) -> File {\n-    <|>self.incremental_reparse(edit).unwrap_or_else(|| {\n-        self.full_reparse(edit)\n-    })\n-}\n-\",\n-            r\"\n-pub fn reparse(&self, edit: &AtomTextEdit) -> File {\n-    <|>self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_block() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    foo(<|>{\n-        92\n-    })\n-}\",\n-            r\"\n-fn foo() {\n-    foo(<|>92)\n-}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_use_items_left() {\n-        // No space after the '{'\n-        check_join_lines(\n-            r\"\n-<|>use ra_syntax::{\n-    TextUnit, TextRange,\n-};\",\n-            r\"\n-<|>use ra_syntax::{TextUnit, TextRange,\n-};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_use_items_right() {\n-        // No space after the '}'\n-        check_join_lines(\n-            r\"\n-use ra_syntax::{\n-<|>    TextUnit, TextRange\n-};\",\n-            r\"\n-use ra_syntax::{\n-<|>    TextUnit, TextRange};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_use_items_right_comma() {\n-        // No space after the '}'\n-        check_join_lines(\n-            r\"\n-use ra_syntax::{\n-<|>    TextUnit, TextRange,\n-};\",\n-            r\"\n-use ra_syntax::{\n-<|>    TextUnit, TextRange};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_use_tree() {\n-        check_join_lines(\n-            r\"\n-use ra_syntax::{\n-    algo::<|>{\n-        find_leaf_at_offset,\n-    },\n-    ast,\n-};\",\n-            r\"\n-use ra_syntax::{\n-    algo::<|>find_leaf_at_offset,\n-    ast,\n-};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_normal_comments() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    // Hello<|>\n-    // world!\n-}\n-\",\n-            r\"\n-fn foo() {\n-    // Hello<|> world!\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_doc_comments() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    /// Hello<|>\n-    /// world!\n-}\n-\",\n-            r\"\n-fn foo() {\n-    /// Hello<|> world!\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_mod_comments() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    //! Hello<|>\n-    //! world!\n-}\n-\",\n-            r\"\n-fn foo() {\n-    //! Hello<|> world!\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_multiline_comments_1() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    // Hello<|>\n-    /* world! */\n-}\n-\",\n-            r\"\n-fn foo() {\n-    // Hello<|> world! */\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_multiline_comments_2() {\n-        check_join_lines(\n-            r\"\n-fn foo() {\n-    // The<|>\n-    /* quick\n-    brown\n-    fox! */\n-}\n-\",\n-            r\"\n-fn foo() {\n-    // The<|> quick\n-    brown\n-    fox! */\n-}\n-\",\n-        );\n-    }\n-\n-    fn check_join_lines_sel(before: &str, after: &str) {\n-        let (sel, before) = extract_range(before);\n-        let file = SourceFile::parse(&before);\n-        let result = join_lines(&file, sel);\n-        let actual = result.edit.apply(&before);\n-        assert_eq_text!(after, &actual);\n-    }\n-\n-    #[test]\n-    fn test_join_lines_selection_fn_args() {\n-        check_join_lines_sel(\n-            r\"\n-fn foo() {\n-    <|>foo(1,\n-        2,\n-        3,\n-    <|>)\n-}\n-    \",\n-            r\"\n-fn foo() {\n-    foo(1, 2, 3)\n-}\n-    \",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_selection_struct() {\n-        check_join_lines_sel(\n-            r\"\n-struct Foo <|>{\n-    f: u32,\n-}<|>\n-    \",\n-            r\"\n-struct Foo { f: u32 }\n-    \",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_selection_dot_chain() {\n-        check_join_lines_sel(\n-            r\"\n-fn foo() {\n-    join(<|>type_params.type_params()\n-            .filter_map(|it| it.name())\n-            .map(|it| it.text())<|>)\n-}\",\n-            r\"\n-fn foo() {\n-    join(type_params.type_params().filter_map(|it| it.name()).map(|it| it.text()))\n-}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_join_lines_selection_lambda_block_body() {\n-        check_join_lines_sel(\n-            r\"\n-pub fn handle_find_matching_brace() {\n-    params.offsets\n-        .map(|offset| <|>{\n-            world.analysis().matching_brace(&file, offset).unwrap_or(offset)\n-        }<|>)\n-        .collect();\n-}\",\n-            r\"\n-pub fn handle_find_matching_brace() {\n-    params.offsets\n-        .map(|offset| world.analysis().matching_brace(&file, offset).unwrap_or(offset))\n-        .collect();\n-}\",\n-        );\n-    }\n+    use super::*;\n \n     #[test]\n     fn test_on_eq_typed() {"}]}