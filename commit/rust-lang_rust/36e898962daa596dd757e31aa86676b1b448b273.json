{"sha": "36e898962daa596dd757e31aa86676b1b448b273", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZTg5ODk2MmRhYTU5NmRkNzU3ZTMxYWE4NjY3NmIxYjQ0OGIyNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-02T04:51:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-02T04:51:40Z"}, "message": "auto merge of #5185 : ben0x539/rust/net-tcp-docs, r=brson\n\nThis changes various type_names to TypeNames and fixes the example for `tcp::accept` that was still using the old `match` syntax and `{|args| ...}` closures.\r\n\r\nThe `accept` example was fairly outdated. I was just going to stay away from all the IO things until the scheduler revamp lands, but `accept` is probably one of the obvious starting points for networking stuff for a learner, and I don't want to get in the way of anyone's enthusiasm.\r\n\r\nDoesn't touch non-comment lines, so I hope I will get away without learning about unit tests. It doesn't seem like the test system is set up to extract tests from doc comments right now.", "tree": {"sha": "b47d25716a7f9a1c936a9e5019d871c6472f7334", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b47d25716a7f9a1c936a9e5019d871c6472f7334"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36e898962daa596dd757e31aa86676b1b448b273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36e898962daa596dd757e31aa86676b1b448b273", "html_url": "https://github.com/rust-lang/rust/commit/36e898962daa596dd757e31aa86676b1b448b273", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36e898962daa596dd757e31aa86676b1b448b273/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10929ed1ca422eeefee133ab39373947551aa62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/10929ed1ca422eeefee133ab39373947551aa62b", "html_url": "https://github.com/rust-lang/rust/commit/10929ed1ca422eeefee133ab39373947551aa62b"}, {"sha": "228e83888bf3d0e14d0bc00ddd0040bb71e24a87", "url": "https://api.github.com/repos/rust-lang/rust/commits/228e83888bf3d0e14d0bc00ddd0040bb71e24a87", "html_url": "https://github.com/rust-lang/rust/commit/228e83888bf3d0e14d0bc00ddd0040bb71e24a87"}], "stats": {"total": 152, "additions": 76, "deletions": 76}, "files": [{"sha": "4266cab0a056e162f96eeffbf4a2aa6edbdd4b7a", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/36e898962daa596dd757e31aa86676b1b448b273/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e898962daa596dd757e31aa86676b1b448b273/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=36e898962daa596dd757e31aa86676b1b448b273", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -43,7 +43,7 @@ extern mod rustrt {\n /**\n  * Encapsulates an open TCP/IP connection through libuv\n  *\n- * `tcp_socket` is non-copyable/sendable and automagically handles closing the\n+ * `TcpSocket` is non-copyable/sendable and automagically handles closing the\n  * underlying libuv data structures when it goes out of scope. This is the\n  * data structure that is used for read/write operations over a TCP stream.\n  */\n@@ -66,10 +66,10 @@ pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n }\n \n /**\n- * A buffered wrapper for `net::tcp::tcp_socket`\n+ * A buffered wrapper for `net::tcp::TcpSocket`\n  *\n  * It is created with a call to `net::tcp::socket_buf()` and has impls that\n- * satisfy both the `io::reader` and `io::writer` traits.\n+ * satisfy both the `io::Reader` and `io::Writer` traits.\n  */\n pub struct TcpSocketBuf {\n     data: @TcpBufferedSocketData,\n@@ -89,7 +89,7 @@ pub struct TcpErrData {\n     err_msg: ~str,\n }\n \n-/// Details returned as part of a `result::err` result from `tcp::listen`\n+/// Details returned as part of a `Result::Err` result from `tcp::listen`\n pub enum TcpListenErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n@@ -116,7 +116,7 @@ pub enum TcpListenErrData {\n      */\n     AccessDenied\n }\n-/// Details returned as part of a `result::err` result from `tcp::connect`\n+/// Details returned as part of a `Result::Err` result from `tcp::connect`\n pub enum TcpConnectErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n@@ -139,9 +139,9 @@ pub enum TcpConnectErrData {\n  * # Returns\n  *\n  * A `result` that, if the operation succeeds, contains a\n- * `net::net::tcp_socket` that can be used to send and receive data to/from\n+ * `net::net::TcpSocket` that can be used to send and receive data to/from\n  * the remote host. In the event of failure, a\n- * `net::tcp::tcp_connect_err_data` instance will be returned\n+ * `net::tcp::TcpConnectErrData` instance will be returned\n  */\n pub fn connect(input_ip: ip::IpAddr, port: uint,\n                iotask: &IoTask)\n@@ -288,14 +288,14 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  *\n  * # Arguments\n  *\n- * * sock - a `tcp_socket` to write to\n+ * * sock - a `TcpSocket` to write to\n  * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n  * This value must remain valid for the duration of the `write` call\n  *\n  * # Returns\n  *\n- * A `result` object with a `nil` value as the `ok` variant, or a\n- * `tcp_err_data` value as the `err` variant\n+ * A `Result` object with a `()` value as the `Ok` variant, or a\n+ * `TcpErrData` value as the `Err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> result::Result<(), TcpErrData> {\n@@ -306,35 +306,35 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n }\n \n /**\n- * Write binary data to tcp stream; Returns a `future::future` value\n+ * Write binary data to tcp stream; Returns a `future::Future` value\n  * immediately\n  *\n  * # Safety\n  *\n  * This function can produce unsafe results if:\n  *\n  * 1. the call to `write_future` is made\n- * 2. the `future::future` value returned is never resolved via\n- * `future::get`\n- * 3. and then the `tcp_socket` passed in to `write_future` leaves\n+ * 2. the `future::Future` value returned is never resolved via\n+ * `Future::get`\n+ * 3. and then the `TcpSocket` passed in to `write_future` leaves\n  * scope and is destructed before the task that runs the libuv write\n  * operation completes.\n  *\n  * As such: If using `write_future`, always be sure to resolve the returned\n- * `future` so as to ensure libuv doesn't try to access a released write\n+ * `Future` so as to ensure libuv doesn't try to access a released write\n  * handle. Otherwise, use the blocking `tcp::write` function instead.\n  *\n  * # Arguments\n  *\n- * * sock - a `tcp_socket` to write to\n+ * * sock - a `TcpSocket` to write to\n  * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n  * This value must remain valid for the duration of the `write` call\n  *\n  * # Returns\n  *\n- * A `future` value that, once the `write` operation completes, resolves to a\n- * `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n- * value as the `err` variant\n+ * A `Future` value that, once the `write` operation completes, resolves to a\n+ * `Result` object with a `nil` value as the `Ok` variant, or a `TcpErrData`\n+ * value as the `Err` variant\n  */\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> future::Future<result::Result<(), TcpErrData>> {\n@@ -353,14 +353,14 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  *\n  * # Arguments\n  *\n- * * sock -- a `net::tcp::tcp_socket` for the connection to read from\n+ * * sock -- a `net::tcp::TcpSocket` for the connection to read from\n  *\n  * # Returns\n  *\n- * * A `result` instance that will either contain a\n- * `core::comm::port<tcp_read_result>` that the user can read (and\n- * optionally, loop on) from until `read_stop` is called, or a\n- * `tcp_err_data` record\n+ * * A `Result` instance that will either contain a\n+ * `core::comm::Port<Result<~[u8], TcpErrData>>` that the user can read\n+ * (and * optionally, loop on) from until `read_stop` is called, or a\n+ * `TcpErrData` record\n  */\n pub fn read_start(sock: &TcpSocket)\n     -> result::Result<@Port<\n@@ -376,7 +376,7 @@ pub fn read_start(sock: &TcpSocket)\n  *\n  * # Arguments\n  *\n- * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n+ * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket) ->\n     result::Result<(), TcpErrData> {\n@@ -387,17 +387,17 @@ pub fn read_stop(sock: &TcpSocket) ->\n }\n \n /**\n- * Reads a single chunk of data from `tcp_socket`; block until data/error\n+ * Reads a single chunk of data from `TcpSocket`; block until data/error\n  * recv'd\n  *\n  * Does a blocking read operation for a single chunk of data from a\n- * `tcp_socket` until a data arrives or an error is received. The provided\n+ * `TcpSocket` until a data arrives or an error is received. The provided\n  * `timeout_msecs` value is used to raise an error if the timeout period\n  * passes without any data received.\n  *\n  * # Arguments\n  *\n- * * `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+ * * `sock` - a `net::tcp::TcpSocket` that you wish to read from\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n@@ -408,31 +408,31 @@ pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n }\n \n /**\n- * Reads a single chunk of data; returns a `future::future<~[u8]>`\n+ * Reads a single chunk of data; returns a `future::Future<~[u8]>`\n  * immediately\n  *\n  * Does a non-blocking read operation for a single chunk of data from a\n- * `tcp_socket` and immediately returns a `future` value representing the\n- * result. When resolving the returned `future`, it will block until data\n+ * `TcpSocket` and immediately returns a `Future` value representing the\n+ * result. When resolving the returned `Future`, it will block until data\n  * arrives or an error is received. The provided `timeout_msecs`\n  * value is used to raise an error if the timeout period passes without any\n  * data received.\n  *\n  * # Safety\n  *\n  * This function can produce unsafe results if the call to `read_future` is\n- * made, the `future::future` value returned is never resolved via\n- * `future::get`, and then the `tcp_socket` passed in to `read_future` leaves\n+ * made, the `future::Future` value returned is never resolved via\n+ * `Future::get`, and then the `TcpSocket` passed in to `read_future` leaves\n  * scope and is destructed before the task that runs the libuv read\n  * operation completes.\n  *\n  * As such: If using `read_future`, always be sure to resolve the returned\n- * `future` so as to ensure libuv doesn't try to access a released read\n+ * `Future` so as to ensure libuv doesn't try to access a released read\n  * handle. Otherwise, use the blocking `tcp::read` function instead.\n  *\n  * # Arguments\n  *\n- * * `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+ * * `sock` - a `net::tcp::TcpSocket` that you wish to read from\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n@@ -445,7 +445,7 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n }\n \n /**\n- * Bind an incoming client connection to a `net::tcp::tcp_socket`\n+ * Bind an incoming client connection to a `net::tcp::TcpSocket`\n  *\n  * # Notes\n  *\n@@ -461,57 +461,57 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  *\n  * This implies that a port/chan pair must be used to make sure that the\n  * `new_connect_cb` call blocks until an attempt to create a\n- * `net::tcp::tcp_socket` is completed.\n+ * `net::tcp::TcpSocket` is completed.\n  *\n  * # Example\n  *\n  * Here, the `new_conn` is used in conjunction with `accept` from within\n  * a task spawned by the `new_connect_cb` passed into `listen`\n  *\n  * ~~~~~~~~~~~\n- * net::tcp::listen(remote_ip, remote_port, backlog)\n+ * do net::tcp::listen(remote_ip, remote_port, backlog, iotask,\n  *     // this callback is ran once after the connection is successfully\n  *     // set up\n- *     {|kill_ch|\n+ *     |kill_ch| {\n  *       // pass the kill_ch to your main loop or wherever you want\n  *       // to be able to externally kill the server from\n- *     }\n+ *     })\n  *     // this callback is ran when a new connection arrives\n- *     {|new_conn, kill_ch|\n- *     let cont_po = core::comm::port::<Option<tcp_err_data>>();\n- *     let cont_ch = core::comm::chan(cont_po);\n- *     task::spawn {||\n+ *     |new_conn, kill_ch| {\n+ *     let (cont_po, cont_ch) = comm::stream::<option::Option<TcpErrData>>();\n+ *     do task::spawn {\n  *         let accept_result = net::tcp::accept(new_conn);\n- *         if accept_result.is_err() {\n- *             core::comm::send(cont_ch, result::get_err(accept_result));\n- *             // fail?\n- *         }\n- *         else {\n- *             let sock = result::get(accept_result);\n- *             core::comm::send(cont_ch, true);\n- *             // do work here\n+ *         match accept_result {\n+ *             Err(accept_error) => {\n+ *                 cont_ch.send(Some(accept_error));\n+ *                 // fail?\n+ *             },\n+ *             Ok(sock) => {\n+ *                 cont_ch.send(None);\n+ *                 // do work here\n+ *             }\n  *         }\n  *     };\n- *     match core::comm::recv(cont_po) {\n+ *     match cont_po.recv() {\n  *       // shut down listen()\n- *       Some(err_data) { core::comm::send(kill_chan, Some(err_data)) }\n+ *       Some(err_data) => kill_ch.send(Some(err_data)),\n  *       // wait for next connection\n- *       None {}\n+ *       None => ()\n  *     }\n  * };\n  * ~~~~~~~~~~~\n  *\n  * # Arguments\n  *\n- * * `new_conn` - an opaque value used to create a new `tcp_socket`\n+ * * `new_conn` - an opaque value used to create a new `TcpSocket`\n  *\n  * # Returns\n  *\n- * On success, this function will return a `net::tcp::tcp_socket` as the\n- * `ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n+ * On success, this function will return a `net::tcp::TcpSocket` as the\n+ * `Ok` variant of a `Result`. The `net::tcp::TcpSocket` is anchored within\n  * the task that `accept` was called within for its lifetime. On failure,\n- * this function will return a `net::tcp::tcp_err_data` record\n- * as the `err` variant of a `result`.\n+ * this function will return a `net::tcp::TcpErrData` record\n+ * as the `Err` variant of a `Result`.\n  */\n pub fn accept(new_conn: TcpNewConnection)\n     -> result::Result<TcpSocket, TcpErrData> {\n@@ -600,27 +600,27 @@ pub fn accept(new_conn: TcpNewConnection)\n  *\n  * # Arguments\n  *\n- * * `host_ip` - a `net::ip::ip_addr` representing a unique IP\n+ * * `host_ip` - a `net::ip::IpAddr` representing a unique IP\n  * (versions 4 or 6)\n  * * `port` - a uint representing the port to listen on\n  * * `backlog` - a uint representing the number of incoming connections\n  * to cache in memory\n- * * `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+ * * `hl_loop` - a `uv_iotask::IoTask` that the tcp request will run on\n  * * `on_establish_cb` - a callback that is evaluated if/when the listener\n  * is successfully established. it takes no parameters\n  * * `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n  * whenever a client attempts to conect on the provided ip/port. the\n  * callback's arguments are:\n  *     * `new_conn` - an opaque type that can be passed to\n- *     `net::tcp::accept` in order to be converted to a `tcp_socket`.\n- *     * `kill_ch` - channel of type `core::comm::chan<Option<tcp_err_data>>`.\n+ *     `net::tcp::accept` in order to be converted to a `TcpSocket`.\n+ *     * `kill_ch` - channel of type `core::comm::Chan<Option<tcp_err_data>>`.\n  *     this channel can be used to send a message to cause `listen` to begin\n  *     closing the underlying libuv data structures.\n  *\n  * # returns\n  *\n- * a `result` instance containing empty data of type `()` on a\n- * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n+ * a `Result` instance containing empty data of type `()` on a\n+ * successful/normal shutdown, and a `TcpListenErrData` enum in the event\n  * of listen exiting because of an error\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n@@ -799,27 +799,27 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n \n \n /**\n- * Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n+ * Convert a `net::tcp::TcpSocket` to a `net::tcp::TcpSocketBuf`.\n  *\n- * This function takes ownership of a `net::tcp::tcp_socket`, returning it\n- * stored within a buffered wrapper, which can be converted to a `io::reader`\n- * or `io::writer`\n+ * This function takes ownership of a `net::tcp::TcpSocket`, returning it\n+ * stored within a buffered wrapper, which can be converted to a `io::Reader`\n+ * or `io::Writer`\n  *\n  * # Arguments\n  *\n- * * `sock` -- a `net::tcp::tcp_socket` that you want to buffer\n+ * * `sock` -- a `net::tcp::TcpSocket` that you want to buffer\n  *\n  * # Returns\n  *\n- * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n+ * A buffered wrapper that you can cast as an `io::Reader` or `io::Writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@TcpBufferedSocketData {\n         sock: sock, mut buf: ~[], buf_off: 0\n     })\n }\n \n-/// Convenience methods extending `net::tcp::tcp_socket`\n+/// Convenience methods extending `net::tcp::TcpSocket`\n pub impl TcpSocket {\n     pub fn read_start() -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n@@ -862,7 +862,7 @@ pub impl TcpSocket {\n     }\n }\n \n-/// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n+/// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Reader for TcpSocketBuf {\n     fn read(&self, buf: &mut [u8], len: uint) -> uint {\n         if len == 0 { return 0 }\n@@ -962,7 +962,7 @@ impl io::Reader for TcpSocketBuf {\n     }\n }\n \n-/// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n+/// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Writer for TcpSocketBuf {\n     pub fn write(&self, data: &[const u8]) {\n         unsafe {"}]}