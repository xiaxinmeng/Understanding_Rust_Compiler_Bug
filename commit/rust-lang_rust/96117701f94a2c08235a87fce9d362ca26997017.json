{"sha": "96117701f94a2c08235a87fce9d362ca26997017", "node_id": "C_kwDOAAsO6NoAKDk2MTE3NzAxZjk0YTJjMDgyMzVhODdmY2U5ZDM2MmNhMjY5OTcwMTc", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-11-03T23:28:07Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:25Z"}, "message": "Support reinitialization of variables", "tree": {"sha": "4bea4f71f30961e09084835d3025ee80141f440b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bea4f71f30961e09084835d3025ee80141f440b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96117701f94a2c08235a87fce9d362ca26997017", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96117701f94a2c08235a87fce9d362ca26997017", "html_url": "https://github.com/rust-lang/rust/commit/96117701f94a2c08235a87fce9d362ca26997017", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96117701f94a2c08235a87fce9d362ca26997017/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa029d4bbe78fafbffdebb398a767941459d9d4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa029d4bbe78fafbffdebb398a767941459d9d4e", "html_url": "https://github.com/rust-lang/rust/commit/aa029d4bbe78fafbffdebb398a767941459d9d4e"}], "stats": {"total": 148, "additions": 116, "deletions": 32}, "files": [{"sha": "65644a54c4fa11c6c27b0d153233c3ae1f80e30f", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/96117701f94a2c08235a87fce9d362ca26997017/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96117701f94a2c08235a87fce9d362ca26997017/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=96117701f94a2c08235a87fce9d362ca26997017", "patch": "@@ -691,13 +691,20 @@ impl DropRangeVisitor<'tcx> {\n         self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n     }\n \n+    fn drop_range(&mut self, hir_id: &HirId) -> &mut DropRange {\n+        if !self.drop_ranges.contains_key(hir_id) {\n+            self.drop_ranges.insert(*hir_id, DropRange::empty());\n+        }\n+        self.drop_ranges.get_mut(hir_id).unwrap()\n+    }\n+\n     fn record_drop(&mut self, hir_id: HirId) {\n-        let drop_ranges = &mut self.drop_ranges;\n         if self.borrowed_places.contains(&hir_id) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n         } else {\n             debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n-            drop_ranges.insert(hir_id, DropRange::new(self.expr_count));\n+            let count = self.expr_count;\n+            self.drop_range(&hir_id).drop(count);\n         }\n     }\n \n@@ -706,7 +713,6 @@ impl DropRangeVisitor<'tcx> {\n         other\n     }\n \n-    #[allow(dead_code)]\n     fn fork_drop_ranges(&self) -> HirIdMap<DropRange> {\n         self.drop_ranges.iter().map(|(k, v)| (*k, v.fork_at(self.expr_count))).collect()\n     }\n@@ -720,7 +726,6 @@ impl DropRangeVisitor<'tcx> {\n         })\n     }\n \n-    #[allow(dead_code)]\n     fn merge_drop_ranges(&mut self, drops: HirIdMap<DropRange>) {\n         drops.into_iter().for_each(|(k, v)| {\n             if !self.drop_ranges.contains_key(&k) {\n@@ -753,6 +758,20 @@ impl DropRangeVisitor<'tcx> {\n             }\n         }\n     }\n+\n+    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n+        if let ExprKind::Path(hir::QPath::Resolved(\n+            _,\n+            hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+        )) = expr.kind\n+        {\n+            let location = self.expr_count;\n+            debug!(\"reinitializing {:?} at {}\", hir_id, location);\n+            self.drop_range(hir_id).reinit(location)\n+        } else {\n+            warn!(\"reinitializing {:?} is not supported\", expr);\n+        }\n+    }\n }\n \n fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n@@ -814,6 +833,7 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut reinit = None;\n         match expr.kind {\n             ExprKind::AssignOp(_op, lhs, rhs) => {\n                 // These operations are weird because their order of evaluation depends on whether\n@@ -867,11 +887,20 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                     }\n                 }\n             }\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                self.visit_expr(lhs);\n+                self.visit_expr(rhs);\n+\n+                reinit = Some(lhs);\n+            }\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n         self.expr_count += 1;\n         self.consume_expr(expr);\n+        if let Some(expr) = reinit {\n+            self.reinit_expr(expr);\n+        }\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n@@ -908,8 +937,8 @@ struct DropRange {\n }\n \n impl DropRange {\n-    fn new(begin: usize) -> Self {\n-        Self { events: vec![Event::Drop(begin)] }\n+    fn empty() -> Self {\n+        Self { events: vec![] }\n     }\n \n     fn intersect(&self, other: &Self) -> Self {\n@@ -966,12 +995,10 @@ impl DropRange {\n         }\n     }\n \n-    #[allow(dead_code)]\n     fn drop(&mut self, location: usize) {\n         self.events.push(Event::Drop(location))\n     }\n \n-    #[allow(dead_code)]\n     fn reinit(&mut self, location: usize) {\n         self.events.push(Event::Reinit(location));\n     }\n@@ -982,7 +1009,6 @@ impl DropRange {\n     /// at the end of both self and other.\n     ///\n     /// Assumes that all locations in each range are less than joinpoint\n-    #[allow(dead_code)]\n     fn merge_with(&mut self, other: &DropRange, join_point: usize) {\n         let mut events: Vec<_> =\n             self.events.iter().merge(other.events.iter()).dedup().cloned().collect();\n@@ -999,7 +1025,6 @@ impl DropRange {\n     /// Creates a new DropRange from this one at the split point.\n     ///\n     /// Used to model branching control flow.\n-    #[allow(dead_code)]\n     fn fork_at(&self, split_point: usize) -> Self {\n         Self {\n             events: vec![if self.is_dropped_at(split_point) {"}, {"sha": "b180a61b104100616765b5a5fdefd8819a898500", "filename": "src/test/ui/generator/drop-control-flow.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/96117701f94a2c08235a87fce9d362ca26997017/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96117701f94a2c08235a87fce9d362ca26997017/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs?ref=96117701f94a2c08235a87fce9d362ca26997017", "patch": "@@ -0,0 +1,81 @@\n+// build-pass\n+\n+// A test to ensure generators capture values that were conditionally dropped,\n+// and also that values that are dropped along all paths to a yield do not get\n+// included in the generator type.\n+\n+#![feature(generators, negative_impls)]\n+\n+#![allow(unused_assignments, dead_code)]\n+\n+struct Ptr;\n+impl<'a> Drop for Ptr {\n+    fn drop(&mut self) {}\n+}\n+\n+struct NonSend {}\n+impl !Send for NonSend {}\n+\n+fn assert_send<T: Send>(_: T) {}\n+\n+// This test case is reduced from src/test/ui/drop/dynamic-drop-async.rs\n+fn one_armed_if(arg: bool) {\n+    let _ = || {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        }\n+        yield;\n+    };\n+}\n+\n+fn two_armed_if(arg: bool) {\n+    assert_send(|| {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        } else {\n+            drop(arr);\n+        }\n+        yield;\n+    })\n+}\n+\n+fn if_let(arg: Option<i32>) {\n+    let _ = || {\n+        let arr = [Ptr];\n+        if let Some(_) = arg {\n+            drop(arr);\n+        }\n+        yield;\n+    };\n+}\n+\n+fn reinit() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        drop(arr);\n+        arr = [Ptr];\n+        yield;\n+    };\n+}\n+\n+fn loop_uninit() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        let mut count = 0;\n+        drop(arr);\n+        while count < 3 {\n+            yield;\n+            arr = [Ptr];\n+            count += 1;\n+        }\n+    };\n+}\n+\n+fn main() {\n+    one_armed_if(true);\n+    if_let(Some(41));\n+    reinit();\n+    // loop_uninit();\n+}"}, {"sha": "40f01f78662a3cd794212ad5b13d6facc5982a9b", "filename": "src/test/ui/generator/drop-if.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa029d4bbe78fafbffdebb398a767941459d9d4e/src%2Ftest%2Fui%2Fgenerator%2Fdrop-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa029d4bbe78fafbffdebb398a767941459d9d4e/src%2Ftest%2Fui%2Fgenerator%2Fdrop-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-if.rs?ref=aa029d4bbe78fafbffdebb398a767941459d9d4e", "patch": "@@ -1,22 +0,0 @@\n-// build-pass\n-\n-// This test case is reduced from src/test/ui/drop/dynamic-drop-async.rs\n-\n-#![feature(generators)]\n-\n-struct Ptr;\n-impl<'a> Drop for Ptr {\n-    fn drop(&mut self) {\n-    }\n-}\n-\n-fn main() {\n-    let arg = true;\n-    let _ = || {\n-        let arr = [Ptr];\n-        if arg {\n-            drop(arr);\n-        }\n-        yield\n-    };\n-}"}]}