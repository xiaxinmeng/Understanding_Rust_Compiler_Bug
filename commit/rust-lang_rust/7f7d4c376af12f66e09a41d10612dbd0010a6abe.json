{"sha": "7f7d4c376af12f66e09a41d10612dbd0010a6abe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmN2Q0YzM3NmFmMTJmNjZlMDlhNDFkMTA2MTJkYmQwMDEwYTZhYmU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-04-13T16:48:41Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-04-14T10:22:10Z"}, "message": "Get rid of redundant `HashSet`", "tree": {"sha": "8ddeaa2ceed31c4f106eb31ae151ec945be2a4fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ddeaa2ceed31c4f106eb31ae151ec945be2a4fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f7d4c376af12f66e09a41d10612dbd0010a6abe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCgBKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAlrR1lIsHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MATK\nvQ//Qj6YuXPf3cP198fVVBNTKFcOzAxt9Wtk/k0uKB2PH0pbcgxuUm4eq/TFIQRH\nH57ojP+og6F5Jy4vnSk9WuuzQ+KJV5G9BSmqH+YD0p4jzeAsWVR7O3mgppV2jLr3\nn9qQcFbrse3hEbeHABMHlWv5wlKmkWHAuJ/M+Nxoi9YVnsd4vfI5C15ePkpjTdvr\n6zfMfccy4pf2qw/i7JmP6XC/0ez387u5WQhuBcoFxv/yshMPk3OJXqFup1Pe3r4D\nLrEoUbYCr0ZH/3shEjMaF7TSIf/YkvxeyGXRdedYbPMwqgrupPdsdHZVz7Q4t8hL\nWP8UG/vHbaBEogEay2mdzv8CEt6YEYVpaQQAa3vCdyuO2j1xJpdL7PnktdSruwtQ\nf3XoeyWzmkykqGIhuZtDS2gUE/q8ZFWWW5U+L9AE3jmu3pj5ZsbUOhPt2dcYvQJj\n1KVGfFiWMQjfBMcIXdM1Aedl787J7wmpFfSs2WMEECHW0HBawFxTklnj06ar6JBa\nyDiV4OrRnIsFt6JPbw/g85H3QrLQBJi8KXBrKzutq7VidDzWh7lmZOU3Gqth02JV\nzasP26A9YfSP6BxYH9OC6tGGR6kcAw5ckm+SZUTabOprjbaRBmj59bF0a9wu2Mrd\n+HrjiIksXenjQlDwyE9h4nYtJ2SvDdomPBMnXujYkAT9gP8=\n=UsOt\n-----END PGP SIGNATURE-----", "payload": "tree 8ddeaa2ceed31c4f106eb31ae151ec945be2a4fe\nparent 748e71e8f4356ac3ce1313e473aa000118c1e109\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1523638121 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1523701330 +0200\n\nGet rid of redundant `HashSet`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7d4c376af12f66e09a41d10612dbd0010a6abe", "html_url": "https://github.com/rust-lang/rust/commit/7f7d4c376af12f66e09a41d10612dbd0010a6abe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f7d4c376af12f66e09a41d10612dbd0010a6abe/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "748e71e8f4356ac3ce1313e473aa000118c1e109", "url": "https://api.github.com/repos/rust-lang/rust/commits/748e71e8f4356ac3ce1313e473aa000118c1e109", "html_url": "https://github.com/rust-lang/rust/commit/748e71e8f4356ac3ce1313e473aa000118c1e109"}], "stats": {"total": 58, "additions": 28, "deletions": 30}, "files": [{"sha": "c9eed0e4a288580a0452c5ca4b647ff9229e07a4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f7d4c376af12f66e09a41d10612dbd0010a6abe/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7d4c376af12f66e09a41d10612dbd0010a6abe/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7f7d4c376af12f66e09a41d10612dbd0010a6abe", "patch": "@@ -178,7 +178,7 @@ pub fn specialized_encode_alloc_id<\n         AllocKind::Fn.encode(encoder)?;\n         fn_instance.encode(encoder)?;\n     } else if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n-        // referring to statics doesn't need to know about their allocations, just hash the DefId\n+        // referring to statics doesn't need to know about their allocations, just about its DefId\n         AllocKind::Static.encode(encoder)?;\n         did.encode(encoder)?;\n     } else {"}, {"sha": "d60206ffd327cd5eace09920486608118a641b63", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7f7d4c376af12f66e09a41d10612dbd0010a6abe/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7d4c376af12f66e09a41d10612dbd0010a6abe/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=7f7d4c376af12f66e09a41d10612dbd0010a6abe", "patch": "@@ -201,7 +201,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 predicate_shorthands: FxHashMap(),\n                 expn_info_shorthands: FxHashMap(),\n                 interpret_allocs: FxHashMap(),\n-                interpret_alloc_ids: FxHashSet(),\n                 interpret_allocs_inverse: Vec::new(),\n                 codemap: CachingCodemapView::new(tcx.sess.codemap()),\n                 file_to_file_index,\n@@ -284,7 +283,12 @@ impl<'sess> OnDiskCache<'sess> {\n                 let mut interpret_alloc_index = Vec::new();\n                 let mut n = 0;\n                 loop {\n-                    let new_n = encoder.interpret_alloc_ids.len();\n+                    let new_n = encoder.interpret_allocs_inverse.len();\n+                    // if we have found new ids, serialize those, too\n+                    if n == new_n {\n+                        // otherwise, abort\n+                        break;\n+                    }\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n                         let pos = AbsoluteBytePos::new(encoder.position());\n@@ -295,11 +299,6 @@ impl<'sess> OnDiskCache<'sess> {\n                             id,\n                         )?;\n                     }\n-                    // if we have found new ids, serialize those, too\n-                    if n == new_n {\n-                        // otherwise, abort\n-                        break;\n-                    }\n                     n = new_n;\n                 }\n                 interpret_alloc_index\n@@ -802,7 +801,6 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n-    interpret_alloc_ids: FxHashSet<interpret::AllocId>,\n     codemap: CachingCodemapView<'tcx>,\n     file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n }\n@@ -839,14 +837,15 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        let index = if self.interpret_alloc_ids.insert(*alloc_id) {\n-            let idx = self.interpret_alloc_ids.len() - 1;\n-            assert_eq!(idx, self.interpret_allocs_inverse.len());\n-            self.interpret_allocs_inverse.push(*alloc_id);\n-            assert!(self.interpret_allocs.insert(*alloc_id, idx).is_none());\n-            idx\n-        } else {\n-            self.interpret_allocs[alloc_id]\n+        use std::collections::hash_map::Entry;\n+        let index = match self.interpret_allocs.entry(*alloc_id) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                let idx = self.interpret_allocs_inverse.len();\n+                self.interpret_allocs_inverse.push(*alloc_id);\n+                e.insert(idx);\n+                idx\n+            },\n         };\n \n         index.encode(self)"}, {"sha": "a61428b841fea83748d56fe353982414ca9187ae", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7f7d4c376af12f66e09a41d10612dbd0010a6abe/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7d4c376af12f66e09a41d10612dbd0010a6abe/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7f7d4c376af12f66e09a41d10612dbd0010a6abe", "patch": "@@ -29,7 +29,7 @@ use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc::util::nodemap::FxHashMap;\n \n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n@@ -62,7 +62,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n \n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n-    interpret_alloc_ids: FxHashSet<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n     filemap_cache: Lrc<FileMap>,\n@@ -199,14 +198,15 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        let index = if self.interpret_alloc_ids.insert(*alloc_id) {\n-            let idx = self.interpret_alloc_ids.len() - 1;\n-            assert_eq!(idx, self.interpret_allocs_inverse.len());\n-            self.interpret_allocs_inverse.push(*alloc_id);\n-            assert!(self.interpret_allocs.insert(*alloc_id, idx).is_none());\n-            idx\n-        } else {\n-            self.interpret_allocs[alloc_id]\n+        use std::collections::hash_map::Entry;\n+        let index = match self.interpret_allocs.entry(*alloc_id) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                let idx = self.interpret_allocs_inverse.len();\n+                self.interpret_allocs_inverse.push(*alloc_id);\n+                e.insert(idx);\n+                idx\n+            },\n         };\n \n         index.encode(self)\n@@ -456,7 +456,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let mut n = 0;\n             trace!(\"beginning to encode alloc ids\");\n             loop {\n-                let new_n = self.interpret_alloc_ids.len();\n+                let new_n = self.interpret_allocs_inverse.len();\n                 // if we have found new ids, serialize those, too\n                 if n == new_n {\n                     // otherwise, abort\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let has_default_lib_allocator =\n             attr::contains_name(tcx.hir.krate_attrs(), \"default_lib_allocator\");\n-        let has_global_allocator = tcx.sess.has_global_allocator.get();\n+        let has_global_allocator = *tcx.sess.has_global_allocator.get();\n \n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n@@ -1792,7 +1792,6 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             filemap_cache: tcx.sess.codemap().files()[0].clone(),\n             interpret_allocs: Default::default(),\n             interpret_allocs_inverse: Default::default(),\n-            interpret_alloc_ids: Default::default(),\n         };\n \n         // Encode the rustc version string in a predictable location."}]}