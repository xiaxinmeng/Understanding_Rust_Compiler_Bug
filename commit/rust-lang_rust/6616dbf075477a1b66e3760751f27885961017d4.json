{"sha": "6616dbf075477a1b66e3760751f27885961017d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MTZkYmYwNzU0NzdhMWI2NmUzNzYwNzUxZjI3ODg1OTYxMDE3ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-01T03:46:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-01T03:46:35Z"}, "message": "auto merge of #10739 : DaGenix/rust/mut-chunks, r=alexcrichton\n\nmut_chunks() returns an iterator that produces mutable slices. This is the mutable version of the existing chunks() method on the ImmutableVector trait.\r\n\r\nEDIT: This uses only safe code now.\r\n\r\nPREVIOUSLY:\r\nI tried to get this working with safe code only, but I couldn't figure out how to make that work. Before #8624, the exact same code worked without the need for the transmute() call. With that fix and without the transmute() call, the compiler complains about the call to mut_slice(). I think the issue is that the mutable slice that is returned will live longer than the self parameter since the self parameter doesn't have an explicit lifetime. However, that is the way that the Iterator trait defines the next() method. I'm sure there is a good reason for that, although I don't quite understand why. Anyway, I think the interface is safe, since the MutChunkIter will only hand out non-overlapping pointers and there is no way to get it to hand out the same pointer twice.", "tree": {"sha": "83ef4f682debef0f743fa2abd133ca17da3dd4ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ef4f682debef0f743fa2abd133ca17da3dd4ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6616dbf075477a1b66e3760751f27885961017d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6616dbf075477a1b66e3760751f27885961017d4", "html_url": "https://github.com/rust-lang/rust/commit/6616dbf075477a1b66e3760751f27885961017d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6616dbf075477a1b66e3760751f27885961017d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c889a2fb56726d6caf392720b0dfb46be5b7d15", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c889a2fb56726d6caf392720b0dfb46be5b7d15", "html_url": "https://github.com/rust-lang/rust/commit/7c889a2fb56726d6caf392720b0dfb46be5b7d15"}, {"sha": "2a8dfc3f22e9f2482719fe89d8c8f2aabae8d754", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8dfc3f22e9f2482719fe89d8c8f2aabae8d754", "html_url": "https://github.com/rust-lang/rust/commit/2a8dfc3f22e9f2482719fe89d8c8f2aabae8d754"}], "stats": {"total": 102, "additions": 102, "deletions": 0}, "files": [{"sha": "45667bdad2ef67d6999d56e810e08fd63ac9f00b", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6616dbf075477a1b66e3760751f27885961017d4/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6616dbf075477a1b66e3760751f27885961017d4/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=6616dbf075477a1b66e3760751f27885961017d4", "patch": "@@ -1933,6 +1933,18 @@ pub trait MutableVector<'self, T> {\n     /// Returns a reversed iterator that allows modifying each value\n     fn mut_rev_iter(self) -> MutRevIterator<'self, T>;\n \n+    /**\n+     * Returns an iterator over `size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     */\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'self, T>;\n+\n     /**\n      * Returns a mutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n@@ -2069,6 +2081,13 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         self.mut_iter().invert()\n     }\n \n+    #[inline]\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'self, T> {\n+        assert!(chunk_size > 0);\n+        let len = self.len();\n+        MutChunkIter { v: self, chunk_size: chunk_size, remaining: len }\n+    }\n+\n     fn mut_shift_ref(&mut self) -> &'self mut T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n@@ -2556,6 +2575,59 @@ impl<'self, T> Clone for VecIterator<'self, T> {\n iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n \n+/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n+/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n+/// the remainder.\n+pub struct MutChunkIter<'self, T> {\n+    priv v: &'self mut [T],\n+    priv chunk_size: uint,\n+    priv remaining: uint\n+}\n+\n+impl<'self, T> Iterator<&'self mut [T]> for MutChunkIter<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut [T]> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            let sz = cmp::min(self.remaining, self.chunk_size);\n+            let tmp = util::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split(sz);\n+            self.v = tail;\n+            self.remaining -= sz;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.remaining == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = self.remaining.div_rem(&self.chunk_size);\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+}\n+\n+impl<'self, T> DoubleEndedIterator<&'self mut [T]> for MutChunkIter<'self, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self mut [T]> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            let remainder = self.remaining % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = util::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split(self.remaining - sz);\n+            self.v = head;\n+            self.remaining -= sz;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n /// An iterator that moves out of a vector.\n #[deriving(Clone)]\n pub struct MoveIterator<T> {\n@@ -3966,6 +4038,36 @@ mod tests {\n         x.pop_ref();\n     }\n \n+    #[test]\n+    fn test_mut_chunks() {\n+        let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n+        for (i, chunk) in v.mut_chunks(3).enumerate() {\n+            for x in chunk.mut_iter() {\n+                *x = i as u8;\n+            }\n+        }\n+        let result = [0u8, 0, 0, 1, 1, 1, 2];\n+        assert_eq!(v, result);\n+    }\n+\n+    #[test]\n+    fn test_mut_chunks_invert() {\n+        let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n+        for (i, chunk) in v.mut_chunks(3).invert().enumerate() {\n+            for x in chunk.mut_iter() {\n+                *x = i as u8;\n+            }\n+        }\n+        let result = [2u8, 2, 2, 1, 1, 1, 0];\n+        assert_eq!(v, result);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mut_chunks_0() {\n+        let mut v = [1, 2, 3, 4];\n+        let _it = v.mut_chunks(0);\n+    }\n \n     #[test]\n     fn test_mut_shift_ref() {"}]}