{"sha": "319f1aba6281adb6ca22522003b49578c406745f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOWYxYWJhNjI4MWFkYjZjYTIyNTIyMDAzYjQ5NTc4YzQwNjc0NWY=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-04T23:50:32Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-09T07:53:59Z"}, "message": "Tests for precise lint analysis", "tree": {"sha": "26574420a6d0780452c2b87af32ea4e3c5638424", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26574420a6d0780452c2b87af32ea4e3c5638424"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/319f1aba6281adb6ca22522003b49578c406745f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/319f1aba6281adb6ca22522003b49578c406745f", "html_url": "https://github.com/rust-lang/rust/commit/319f1aba6281adb6ca22522003b49578c406745f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/319f1aba6281adb6ca22522003b49578c406745f/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01036af1d8da0e5e16f8c126fa0017049d52636", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01036af1d8da0e5e16f8c126fa0017049d52636", "html_url": "https://github.com/rust-lang/rust/commit/c01036af1d8da0e5e16f8c126fa0017049d52636"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "79702cc6b56f3baf9b8f2ad1b5cc6583bd1a1176", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/319f1aba6281adb6ca22522003b49578c406745f/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/319f1aba6281adb6ca22522003b49578c406745f/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=319f1aba6281adb6ca22522003b49578c406745f", "patch": "@@ -0,0 +1,78 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+#[derive(Debug)]\n+struct ContainsAndImplsDrop(Foo);\n+impl Drop for ContainsAndImplsDrop {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// Test that even if all paths starting at root variable that implement Drop are captured,\n+// the lint is triggered if the root variable implements drop and isn't captured.\n+fn test_precise_analysis_parent_root_impl_drop_not_captured() {\n+    let t = ContainsAndImplsDrop(Foo(10));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test that lint is triggered if a path that implements Drop is not captured by move\n+fn test_precise_analysis_drop_paths_not_captured_by_move() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _t = &t.1;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test precise analysis for the lint works with paths longer than one.\n+fn test_precise_analysis_long_path_missing() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(u));\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_parent_root_impl_drop_not_captured();\n+    test_precise_analysis_drop_paths_not_captured_by_move();\n+    test_precise_analysis_long_path_missing();\n+}"}, {"sha": "968ca395f946ef9ccaab6fe357a776aa59905a75", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/319f1aba6281adb6ca22522003b49578c406745f/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/319f1aba6281adb6ca22522003b49578c406745f/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=319f1aba6281adb6ca22522003b49578c406745f", "patch": "@@ -0,0 +1,49 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:27:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/precise.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:40:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t = &t.1;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:63:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _x = u.0.0;\n+LL | |         let _x = u.0.1;\n+LL | |         let _x = u.1.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(u));\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8af48501ca2952670fe96143363d1c8ad0f3b0a5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise_no_migrations.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/319f1aba6281adb6ca22522003b49578c406745f/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/319f1aba6281adb6ca22522003b49578c406745f/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs?ref=319f1aba6281adb6ca22522003b49578c406745f", "patch": "@@ -0,0 +1,105 @@\n+// run-pass\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+// Test that if all paths starting at root variable that implement Drop are captured\n+// then it doesn't trigger the lint.\n+fn test_precise_analysis_simple_1() {\n+    let t = (Foo(10), Foo(20), Foo(30));\n+\n+    let c = || {\n+        let _t = t.0;\n+        let _t = t.1;\n+        let _t = t.2;\n+    };\n+\n+    c();\n+}\n+\n+// Test that if all paths starting at root variable that implement Drop are captured\n+// then it doesn't trigger the lint.\n+fn test_precise_analysis_simple_2() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+        let _t = t.0;\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+#[derive(Debug)]\n+struct ContainsAndImplsDrop(Foo);\n+impl Drop for ContainsAndImplsDrop {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// If a path isn't directly captured but requires Drop, then this tests that migrations aren't\n+// needed if the a parent to that path is captured.\n+fn test_precise_analysis_parent_captured_1() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+        let _t = t;\n+    };\n+\n+    c();\n+}\n+\n+// If a path isn't directly captured but requires Drop, then this tests that migrations aren't\n+// needed if the a parent to that path is captured.\n+fn test_precise_analysis_parent_captured_2() {\n+    let t = ContainsAndImplsDrop(Foo(10));\n+\n+    let c = || {\n+        let _t = t;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test that if the path is longer than just one element, precise analysis works correctly.\n+fn test_precise_analysis_long_path() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || {\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+        let _x = u.1.1;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_simple_1();\n+    test_precise_analysis_simple_2();\n+\n+    test_precise_analysis_parent_captured_1();\n+    test_precise_analysis_parent_captured_2();\n+\n+    test_precise_analysis_long_path();\n+}"}]}