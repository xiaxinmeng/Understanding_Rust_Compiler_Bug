{"sha": "e186accbc43dad8c340112fc39d8df924a9a79e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODZhY2NiYzQzZGFkOGMzNDAxMTJmYzM5ZDhkZjkyNGE5YTc5ZTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T17:09:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T17:09:21Z"}, "message": "Fix rebase conflicts", "tree": {"sha": "dc55dc0219844669606d0dcd314b08ebf1ccf209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc55dc0219844669606d0dcd314b08ebf1ccf209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e186accbc43dad8c340112fc39d8df924a9a79e9", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e186accbc43dad8c340112fc39d8df924a9a79e9", "html_url": "https://github.com/rust-lang/rust/commit/e186accbc43dad8c340112fc39d8df924a9a79e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e186accbc43dad8c340112fc39d8df924a9a79e9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "919975d0a5c90a25bf09a0a7c27fb7156d6aa2ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/919975d0a5c90a25bf09a0a7c27fb7156d6aa2ad", "html_url": "https://github.com/rust-lang/rust/commit/919975d0a5c90a25bf09a0a7c27fb7156d6aa2ad"}], "stats": {"total": 150, "additions": 48, "deletions": 102}, "files": [{"sha": "eba040e7ea8b6ad226ab6ad9515f80d4d816b689", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e186accbc43dad8c340112fc39d8df924a9a79e9", "patch": "@@ -48,7 +48,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             match expected_sig_and_kind {\n                 None => { // doesn't look like an unboxed closure\n                     let region = astconv::opt_ast_region_to_region(fcx,\n-                                                                   fcx.infcx(),\n+                                                                   fcx,\n                                                                    expr.span,\n                                                                    &None);\n \n@@ -117,7 +117,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         abi::RustCall,\n         expected_sig);\n \n-    let region = match fcx.infcx().anon_regions(expr.span, 1) {\n+    let region = match fcx.anon_regions(expr.span, 1) {\n         Err(_) => {\n             fcx.ccx.tcx.sess.span_bug(expr.span,\n                                       \"can't make anon regions here?!\")"}, {"sha": "8069d00dda826fc8f4aa002b305e890e29d92267", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 86, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e186accbc43dad8c340112fc39d8df924a9a79e9", "patch": "@@ -1933,7 +1933,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n-        let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n+        let t = ast_ty_to_ty(self, self, ast_t);\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n                                                         ast_t.span,\n@@ -2123,18 +2123,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-//impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n-//    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n-//        Some(self.next_region_var(infer::MiscVariable(span)))\n-//    }\n-//\n-//    fn anon_regions(&self, span: Span, count: uint)\n-//                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-//        Ok(Vec::from_fn(count, |_| {\n-//            self.next_region_var(infer::MiscVariable(span))\n-//        }))\n-//    }\n-//}\n+impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n+    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n+        Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n+    }\n+\n+    fn anon_regions(&self, span: Span, count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+        Ok(Vec::from_fn(count, |_| {\n+            self.infcx().next_region_var(infer::MiscVariable(span))\n+        }))\n+    }\n+}\n \n #[deriving(Copy, Show, PartialEq, Eq)]\n pub enum LvaluePreference {\n@@ -2347,58 +2347,6 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Autoderefs `base_expr`, looking for a `Slice` impl. If it finds one, installs the relevant\n-/// method info and returns the result type (else None).\n-fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  method_call: MethodCall,\n-                                  expr: &ast::Expr,\n-                                  base_expr: &ast::Expr,\n-                                  base_ty: Ty<'tcx>,\n-                                  start_expr: &Option<P<ast::Expr>>,\n-                                  end_expr: &Option<P<ast::Expr>>,\n-                                  mutbl: ast::Mutability)\n-                                  -> Option<Ty<'tcx>> // return type is result of slice\n-{\n-    let lvalue_pref = match mutbl {\n-        ast::MutMutable => PreferMutLvalue,\n-        ast::MutImmutable => NoPreference\n-    };\n-\n-    let opt_method_ty =\n-        autoderef_for_index(fcx, base_expr, base_ty, lvalue_pref, |adjusted_ty, autoderefref| {\n-            try_overloaded_slice_step(fcx, method_call, expr, base_expr,\n-                                      adjusted_ty, autoderefref, mutbl,\n-                                      start_expr, end_expr)\n-        });\n-\n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_ty_or_err = opt_method_ty.unwrap_or(fcx.tcx().types.err);\n-\n-    let mut args = vec![];\n-    start_expr.as_ref().map(|x| args.push(x));\n-    end_expr.as_ref().map(|x| args.push(x));\n-\n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_ty_or_err,\n-                                expr,\n-                                args.as_slice(),\n-                                AutorefArgs::Yes,\n-                                DontTupleArguments);\n-\n-    opt_method_ty.map(|method_ty| {\n-        let result_ty = ty::ty_fn_ret(method_ty);\n-        match result_ty {\n-            ty::FnConverging(result_ty) => result_ty,\n-            ty::FnDiverging => {\n-                fcx.tcx().sess.span_bug(expr.span,\n-                                        \"slice trait does not define a `!` return\")\n-            }\n-        }\n-    })\n-}\n-\n /// Checks for a `Slice` (or `SliceMut`) impl at the relevant level of autoderef. If it finds one,\n /// installs method info and returns type of method (else None).\n fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -4327,7 +4275,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let actual_structure_type = fcx.expr_ty(&*expr);\n         if !ty::type_is_error(actual_structure_type) {\n             let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n-                                                                  fcx.infcx(),\n+                                                                  fcx,\n                                                                   struct_id,\n                                                                   path);\n             match fcx.mk_subty(false,\n@@ -4410,8 +4358,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                              },\n                              base_t,\n                              None);\n-                          fcx.write_ty(idx.id, ty::mk_err());\n-                          fcx.write_ty(id, ty::mk_err())\n+                          fcx.write_ty(idx.id, fcx.tcx().types.err);\n+                          fcx.write_ty(id, fcx.tcx().types.err);\n                       }\n                   }\n                 }\n@@ -4440,7 +4388,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                               fcx.write_ty(id, element_ty);\n                           }\n                           _ => {\n-                              check_expr_has_type(fcx, &**idx, ty::mk_err());\n+                              check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n                               fcx.type_error_message(\n                                   expr.span,\n                                   |actual| {\n@@ -4449,7 +4397,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                   },\n                                   base_t,\n                                   None);\n-                              fcx.write_ty(id, ty::mk_err())\n+                              fcx.write_ty(id, fcx.tcx().types.err);\n                           }\n                       }\n                   }\n@@ -4468,19 +4416,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           });\n \n           let idx_type = match (t_start, t_end) {\n-            (Some(ty), None) | (None, Some(ty)) => Some(ty),\n-            (Some(t_start), Some(t_end))\n-              if ty::type_is_error(t_start) || ty::type_is_error(t_end) => {\n-                Some(ty::mk_err())\n-            }\n-            (Some(t_start), Some(t_end)) => {\n-                Some(infer::common_supertype(fcx.infcx(),\n-                                             infer::RangeExpression(expr.span),\n-                                             true,\n-                                             t_start,\n-                                             t_end))\n-            }\n-            _ => None\n+              (Some(ty), None) | (None, Some(ty)) => {\n+                  Some(ty)\n+              }\n+              (Some(t_start), Some(t_end)) if (ty::type_is_error(t_start) ||\n+                                               ty::type_is_error(t_end)) => {\n+                  Some(fcx.tcx().types.err)\n+              }\n+              (Some(t_start), Some(t_end)) => {\n+                  Some(infer::common_supertype(fcx.infcx(),\n+                                               infer::RangeExpression(expr.span),\n+                                               true,\n+                                               t_start,\n+                                               t_end))\n+              }\n+              _ => None\n           };\n \n           // Note that we don't check the type of start/end satisfy any\n@@ -4489,7 +4439,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           let range_type = match idx_type {\n             Some(idx_type) if ty::type_is_error(idx_type) => {\n-                ty::mk_err()\n+                fcx.tcx().types.err\n             }\n             Some(idx_type) => {\n                 // Find the did from the appropriate lang item.\n@@ -4515,7 +4465,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n                     tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n             }\n             None => {\n@@ -4525,7 +4475,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n                     tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n             }\n           };"}, {"sha": "9e184db3b84fec1ea943f578c037ae3e24f0d5fc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e186accbc43dad8c340112fc39d8df924a9a79e9", "patch": "@@ -1098,7 +1098,6 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let bounds = compute_bounds(ccx,\n                                             assoc_ty,\n                                             assoc_type_def.bounds.as_slice(),\n-                                            &assoc_type_def.unbound,\n                                             assoc_type_def.span);\n \n                 ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()"}, {"sha": "1fbfbe7eb1ab50f26123d1492feae6d6fac1f2c1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e186accbc43dad8c340112fc39d8df924a9a79e9", "patch": "@@ -1474,7 +1474,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n             ty::ty_projection(ref data) => {\n                 let trait_ref = match data.trait_ref.clean(cx) {\n-                    TyParamBound::TraitBound(t) => t.trait_,\n+                    TyParamBound::TraitBound(t, _) => t.trait_,\n                     TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n                 };\n                 Type::QPath {"}, {"sha": "651f663fc991343fe35c2ec64877b5fba854f698", "filename": "src/test/compile-fail/trait-static-method-generic-inference.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e186accbc43dad8c340112fc39d8df924a9a79e9/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs?ref=e186accbc43dad8c340112fc39d8df924a9a79e9", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Issue #3902. We are (at least currently) unable to infer `Self`\n+// based on `T`, even though there is only a single impl, because of\n+// the possibility of associated types and other things (basically: no\n+// constraints on `Self` here at all).\n+\n mod base {\n     pub trait HasNew<T> {\n         fn new() -> T;\n@@ -22,19 +27,11 @@ mod base {\n             Foo { dummy: () }\n         }\n     }\n-\n-    pub struct Bar {\n-        dummy: (),\n-    }\n-\n-    impl HasNew<Bar> for Bar {\n-        fn new() -> Bar {\n-            Bar { dummy: () }\n-        }\n-    }\n }\n \n-pub fn main() {\n+pub fn foo() {\n     let _f: base::Foo = base::HasNew::new();\n-    let _b: base::Bar = base::HasNew::new();\n+    //~^ ERROR type annotations required\n }\n+\n+fn main() { }", "previous_filename": "src/test/run-pass/trait-static-method-generic-inference.rs"}]}