{"sha": "dda9587e75f4fd1740d16531038023ff582ef43f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYTk1ODdlNzVmNGZkMTc0MGQxNjUzMTAzODAyM2ZmNTgyZWY0M2Y=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-07T17:24:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-07T18:44:43Z"}, "message": "Track source of type parameters", "tree": {"sha": "56a377d2ff6b3dcbb8e2f25ccc876c718b48d37a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56a377d2ff6b3dcbb8e2f25ccc876c718b48d37a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dda9587e75f4fd1740d16531038023ff582ef43f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dda9587e75f4fd1740d16531038023ff582ef43f", "html_url": "https://github.com/rust-lang/rust/commit/dda9587e75f4fd1740d16531038023ff582ef43f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dda9587e75f4fd1740d16531038023ff582ef43f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d75f768c13752dfa5ea9189a0b4dfb9b460993e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d75f768c13752dfa5ea9189a0b4dfb9b460993e6", "html_url": "https://github.com/rust-lang/rust/commit/d75f768c13752dfa5ea9189a0b4dfb9b460993e6"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "8f04ebd23aca0a1f1be99527c8853f3778606435", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dda9587e75f4fd1740d16531038023ff582ef43f/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda9587e75f4fd1740d16531038023ff582ef43f/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=dda9587e75f4fd1740d16531038023ff582ef43f", "patch": "@@ -9,8 +9,8 @@ use hir_def::{\n use ra_syntax::ast;\n \n use crate::{\n-    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplBlock, Import, MacroDef,\n-    Module, Static, Struct, StructField, Trait, TypeAlias, Union,\n+    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, GenericParam, ImplBlock,\n+    Import, MacroDef, Module, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n pub use hir_expand::InFile;\n@@ -129,3 +129,11 @@ impl HasSource for Import {\n         src.with_value(ptr.map_left(|it| it.to_node(&root)).map_right(|it| it.to_node(&root)))\n     }\n }\n+\n+impl HasSource for GenericParam {\n+    type Ast = Either<ast::TraitDef, ast::TypeParam>;\n+    fn source(self, db: &impl DefDatabase) -> InFile<Self::Ast> {\n+        let child_source = self.id.parent.child_source(db);\n+        child_source.map(|it| it[self.id.local_id].clone())\n+    }\n+}"}, {"sha": "0df5a20f5666b072bad016152ddc01f5d02f1b8c", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 72, "deletions": 21, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/dda9587e75f4fd1740d16531038023ff582ef43f/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda9587e75f4fd1740d16531038023ff582ef43f/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=dda9587e75f4fd1740d16531038023ff582ef43f", "patch": "@@ -4,12 +4,18 @@\n //! in rustc.\n use std::sync::Arc;\n \n-use hir_expand::name::{self, AsName, Name};\n-use ra_arena::Arena;\n+use either::Either;\n+use hir_expand::{\n+    name::{self, AsName, Name},\n+    InFile,\n+};\n+use ra_arena::{map::ArenaMap, Arena};\n+use ra_db::FileId;\n use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n     db::DefDatabase,\n+    src::HasChildSource,\n     src::HasSource,\n     type_ref::{TypeBound, TypeRef},\n     AdtId, AstItemDef, GenericDefId, LocalGenericParamId, Lookup,\n@@ -39,46 +45,81 @@ pub struct WherePredicate {\n     pub bound: TypeBound,\n }\n \n+type SourceMap = ArenaMap<LocalGenericParamId, Either<ast::TraitDef, ast::TypeParam>>;\n+\n impl GenericParams {\n     pub(crate) fn generic_params_query(\n         db: &impl DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n-        Arc::new(GenericParams::new(db, def.into()))\n+        let (params, _source_map) = GenericParams::new(db, def.into());\n+        Arc::new(params)\n     }\n \n-    fn new(db: &impl DefDatabase, def: GenericDefId) -> GenericParams {\n+    fn new(db: &impl DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n         let mut generics = GenericParams { params: Arena::default(), where_predicates: Vec::new() };\n+        let mut sm = ArenaMap::default();\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n-        match def {\n-            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value),\n-            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value),\n-            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value),\n-            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value),\n+        let file_id = match def {\n+            GenericDefId::FunctionId(it) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::AdtId(AdtId::StructId(it)) => {\n+                let src = it.source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => {\n+                let src = it.source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::AdtId(AdtId::EnumId(it)) => {\n+                let src = it.source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n             GenericDefId::TraitId(it) => {\n+                let src = it.source(db);\n+\n                 // traits get the Self type as an implicit first type parameter\n-                generics.params.alloc(GenericParamData { name: name::SELF_TYPE, default: None });\n+                let self_param_id = generics\n+                    .params\n+                    .alloc(GenericParamData { name: name::SELF_TYPE, default: None });\n+                sm.insert(self_param_id, Either::Left(src.value.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name::SELF_TYPE.into());\n-                generics.fill_bounds(&it.source(db).value, self_param);\n+                generics.fill_bounds(&src.value, self_param);\n \n-                generics.fill(&it.source(db).value);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::TypeAliasId(it) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n             }\n-            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value),\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n             // type, so this is handled by the resolver.\n-            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value),\n-            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {}\n-        }\n+            GenericDefId::ImplId(it) => {\n+                let src = it.source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            // We won't be using this ID anyway\n+            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => FileId(!0).into(),\n+        };\n \n-        generics\n+        (generics, InFile::new(file_id, sm))\n     }\n \n-    fn fill(&mut self, node: &dyn TypeParamsOwner) {\n+    fn fill(&mut self, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(params)\n+            self.fill_params(sm, params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n             self.fill_where_predicates(where_clause);\n@@ -93,13 +134,14 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(&mut self, params: ast::TypeParamList) {\n+    fn fill_params(&mut self, sm: &mut SourceMap, params: ast::TypeParamList) {\n         for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().map(TypeRef::from_ast);\n             let param = GenericParamData { name: name.clone(), default };\n-            self.params.alloc(param);\n+            let param_id = self.params.alloc(param);\n+            sm.insert(param_id, Either::Right(type_param.clone()));\n \n             let type_ref = TypeRef::Path(name.into());\n             self.fill_bounds(&type_param, type_ref);\n@@ -132,3 +174,12 @@ impl GenericParams {\n         self.params.iter().find_map(|(id, p)| if &p.name == name { Some(id) } else { None })\n     }\n }\n+\n+impl HasChildSource for GenericDefId {\n+    type ChildId = LocalGenericParamId;\n+    type Value = Either<ast::TraitDef, ast::TypeParam>;\n+    fn child_source(&self, db: &impl DefDatabase) -> InFile<SourceMap> {\n+        let (_, sm) = GenericParams::new(db, *self);\n+        sm\n+    }\n+}"}]}