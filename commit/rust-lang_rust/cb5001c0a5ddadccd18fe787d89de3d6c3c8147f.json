{"sha": "cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNTAwMWMwYTVkZGFkY2NkMThmZTc4N2Q4OWRlM2Q2YzNjODE0N2Y=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-02T09:47:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-02T09:47:39Z"}, "message": "move extensions to submodules", "tree": {"sha": "1acf66538292bb3fc9e789ab1e55f61ee46b997e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1acf66538292bb3fc9e789ab1e55f61ee46b997e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "html_url": "https://github.com/rust-lang/rust/commit/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3a82c372ccaa079842f151b749fbe9b8b9eb004", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a82c372ccaa079842f151b749fbe9b8b9eb004", "html_url": "https://github.com/rust-lang/rust/commit/f3a82c372ccaa079842f151b749fbe9b8b9eb004"}], "stats": {"total": 1115, "additions": 566, "deletions": 549}, "files": [{"sha": "74a415bdd922310a2f0997a9d5cd84109db636ed", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 16, "deletions": 549, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "patch": "@@ -2,21 +2,22 @@\n mod generated;\n mod traits;\n mod tokens;\n+mod extensions;\n+mod expr_extensions;\n \n use std::marker::PhantomData;\n \n-use itertools::Itertools;\n-\n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken, SyntaxElement},\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken},\n     SmolStr,\n-    SyntaxKind::*,\n };\n \n pub use self::{\n     generated::*,\n     traits::*,\n     tokens::*,\n+    extensions::{PathSegmentKind, StructFlavor, SelfParamFlavor},\n+    expr_extensions::{ElseBranch, PrefixOp, BinOp, LiteralFlavor},\n };\n \n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The\n@@ -32,6 +33,17 @@ pub trait AstNode:\n     fn syntax(&self) -> &SyntaxNode;\n }\n \n+/// Like `AstNode`, but wraps tokens rather than interior nodes.\n+pub trait AstToken<'a> {\n+    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n+    where\n+        Self: Sized;\n+    fn syntax(&self) -> SyntaxToken<'a>;\n+    fn text(&self) -> &'a SmolStr {\n+        self.syntax().text()\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct AstChildren<'a, N> {\n     inner: SyntaxNodeChildren<'a>,\n@@ -51,215 +63,6 @@ impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n     }\n }\n \n-pub trait AstToken<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n-    where\n-        Self: Sized;\n-    fn syntax(&self) -> SyntaxToken<'a>;\n-    fn text(&self) -> &'a SmolStr {\n-        self.syntax().text()\n-    }\n-}\n-\n-impl Attr {\n-    pub fn is_inner(&self) -> bool {\n-        let tt = match self.value() {\n-            None => return false,\n-            Some(tt) => tt,\n-        };\n-\n-        let prev = match tt.syntax().prev_sibling() {\n-            None => return false,\n-            Some(prev) => prev,\n-        };\n-\n-        prev.kind() == EXCL\n-    }\n-\n-    pub fn as_atom(&self) -> Option<SmolStr> {\n-        let tt = self.value()?;\n-        let (_bra, attr, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n-        if attr.kind() == IDENT {\n-            Some(attr.as_token()?.text().clone())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn as_call(&self) -> Option<(SmolStr, &TokenTree)> {\n-        let tt = self.value()?;\n-        let (_bra, attr, args, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n-        let args = TokenTree::cast(args.as_node()?)?;\n-        if attr.kind() == IDENT {\n-            Some((attr.as_token()?.text().clone(), args))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn as_named(&self) -> Option<SmolStr> {\n-        let tt = self.value()?;\n-        let attr = tt.syntax().children_with_tokens().nth(1)?;\n-        if attr.kind() == IDENT {\n-            Some(attr.as_token()?.text().clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl Name {\n-    pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n-    }\n-}\n-\n-impl NameRef {\n-    pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n-    }\n-}\n-\n-impl ImplBlock {\n-    pub fn target_type(&self) -> Option<&TypeRef> {\n-        match self.target() {\n-            (Some(t), None) | (_, Some(t)) => Some(t),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        match self.target() {\n-            (Some(t), Some(_)) => Some(t),\n-            _ => None,\n-        }\n-    }\n-\n-    fn target(&self) -> (Option<&TypeRef>, Option<&TypeRef>) {\n-        let mut types = children(self);\n-        let first = types.next();\n-        let second = types.next();\n-        (first, second)\n-    }\n-}\n-\n-impl Module {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == SEMI,\n-        }\n-    }\n-}\n-\n-impl LetStmt {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == SEMI,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ElseBranch<'a> {\n-    Block(&'a Block),\n-    IfExpr(&'a IfExpr),\n-}\n-\n-impl IfExpr {\n-    pub fn then_branch(&self) -> Option<&Block> {\n-        self.blocks().nth(0)\n-    }\n-    pub fn else_branch(&self) -> Option<ElseBranch> {\n-        let res = match self.blocks().nth(1) {\n-            Some(block) => ElseBranch::Block(block),\n-            None => {\n-                let elif: &IfExpr = child_opt(self)?;\n-                ElseBranch::IfExpr(elif)\n-            }\n-        };\n-        Some(res)\n-    }\n-\n-    fn blocks(&self) -> AstChildren<Block> {\n-        children(self)\n-    }\n-}\n-\n-impl ExprStmt {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == SEMI,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum PathSegmentKind<'a> {\n-    Name(&'a NameRef),\n-    SelfKw,\n-    SuperKw,\n-    CrateKw,\n-}\n-\n-impl PathSegment {\n-    pub fn parent_path(&self) -> &Path {\n-        self.syntax().parent().and_then(Path::cast).expect(\"segments are always nested in paths\")\n-    }\n-\n-    pub fn kind(&self) -> Option<PathSegmentKind> {\n-        let res = if let Some(name_ref) = self.name_ref() {\n-            PathSegmentKind::Name(name_ref)\n-        } else {\n-            match self.syntax().first_child_or_token()?.kind() {\n-                SELF_KW => PathSegmentKind::SelfKw,\n-                SUPER_KW => PathSegmentKind::SuperKw,\n-                CRATE_KW => PathSegmentKind::CrateKw,\n-                _ => return None,\n-            }\n-        };\n-        Some(res)\n-    }\n-\n-    pub fn has_colon_colon(&self) -> bool {\n-        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n-            Some(COLONCOLON) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Path {\n-    pub fn parent_path(&self) -> Option<&Path> {\n-        self.syntax().parent().and_then(Path::cast)\n-    }\n-}\n-\n-impl UseTree {\n-    pub fn has_star(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == STAR)\n-    }\n-}\n-\n-impl UseTreeList {\n-    pub fn parent_use_tree(&self) -> &UseTree {\n-        self.syntax()\n-            .parent()\n-            .and_then(UseTree::cast)\n-            .expect(\"UseTreeLists are always nested in UseTrees\")\n-    }\n-}\n-\n-impl RefPat {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n fn child_opt<P: AstNode, C: AstNode>(parent: &P) -> Option<&C> {\n     children(parent).next()\n }\n@@ -268,342 +71,6 @@ fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum StructFlavor<'a> {\n-    Tuple(&'a PosFieldDefList),\n-    Named(&'a NamedFieldDefList),\n-    Unit,\n-}\n-\n-impl StructFlavor<'_> {\n-    fn from_node<N: AstNode>(node: &N) -> StructFlavor {\n-        if let Some(nfdl) = child_opt::<_, NamedFieldDefList>(node) {\n-            StructFlavor::Named(nfdl)\n-        } else if let Some(pfl) = child_opt::<_, PosFieldDefList>(node) {\n-            StructFlavor::Tuple(pfl)\n-        } else {\n-            StructFlavor::Unit\n-        }\n-    }\n-}\n-\n-impl StructDef {\n-    pub fn flavor(&self) -> StructFlavor {\n-        StructFlavor::from_node(self)\n-    }\n-}\n-\n-impl EnumVariant {\n-    pub fn parent_enum(&self) -> &EnumDef {\n-        self.syntax()\n-            .parent()\n-            .and_then(|it| it.parent())\n-            .and_then(EnumDef::cast)\n-            .expect(\"EnumVariants are always nested in Enums\")\n-    }\n-    pub fn flavor(&self) -> StructFlavor {\n-        StructFlavor::from_node(self)\n-    }\n-}\n-\n-impl PointerType {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n-impl ReferenceType {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n-impl RefExpr {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum PrefixOp {\n-    /// The `*` operator for dereferencing\n-    Deref,\n-    /// The `!` operator for logical inversion\n-    Not,\n-    /// The `-` operator for negation\n-    Neg,\n-}\n-\n-impl PrefixExpr {\n-    pub fn op_kind(&self) -> Option<PrefixOp> {\n-        match self.op_token()?.kind() {\n-            STAR => Some(PrefixOp::Deref),\n-            EXCL => Some(PrefixOp::Not),\n-            MINUS => Some(PrefixOp::Neg),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn op_token(&self) -> Option<SyntaxToken> {\n-        self.syntax().first_child_or_token()?.as_token()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinOp {\n-    /// The `||` operator for boolean OR\n-    BooleanOr,\n-    /// The `&&` operator for boolean AND\n-    BooleanAnd,\n-    /// The `==` operator for equality testing\n-    EqualityTest,\n-    /// The `!=` operator for equality testing\n-    NegatedEqualityTest,\n-    /// The `<=` operator for lesser-equal testing\n-    LesserEqualTest,\n-    /// The `>=` operator for greater-equal testing\n-    GreaterEqualTest,\n-    /// The `<` operator for comparison\n-    LesserTest,\n-    /// The `>` operator for comparison\n-    GreaterTest,\n-    /// The `+` operator for addition\n-    Addition,\n-    /// The `*` operator for multiplication\n-    Multiplication,\n-    /// The `-` operator for subtraction\n-    Subtraction,\n-    /// The `/` operator for division\n-    Division,\n-    /// The `%` operator for remainder after division\n-    Remainder,\n-    /// The `<<` operator for left shift\n-    LeftShift,\n-    /// The `>>` operator for right shift\n-    RightShift,\n-    /// The `^` operator for bitwise XOR\n-    BitwiseXor,\n-    /// The `|` operator for bitwise OR\n-    BitwiseOr,\n-    /// The `&` operator for bitwise AND\n-    BitwiseAnd,\n-    /// The `..` operator for right-open ranges\n-    RangeRightOpen,\n-    /// The `..=` operator for right-closed ranges\n-    RangeRightClosed,\n-    /// The `=` operator for assignment\n-    Assignment,\n-    /// The `+=` operator for assignment after addition\n-    AddAssign,\n-    /// The `/=` operator for assignment after division\n-    DivAssign,\n-    /// The `*=` operator for assignment after multiplication\n-    MulAssign,\n-    /// The `%=` operator for assignment after remainders\n-    RemAssign,\n-    /// The `>>=` operator for assignment after shifting right\n-    ShrAssign,\n-    /// The `<<=` operator for assignment after shifting left\n-    ShlAssign,\n-    /// The `-=` operator for assignment after subtraction\n-    SubAssign,\n-    /// The `|=` operator for assignment after bitwise OR\n-    BitOrAssign,\n-    /// The `&=` operator for assignment after bitwise AND\n-    BitAndAssign,\n-    /// The `^=` operator for assignment after bitwise XOR\n-    BitXorAssign,\n-}\n-\n-impl BinExpr {\n-    fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n-        self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n-            match c.kind() {\n-                PIPEPIPE => Some((c, BinOp::BooleanOr)),\n-                AMPAMP => Some((c, BinOp::BooleanAnd)),\n-                EQEQ => Some((c, BinOp::EqualityTest)),\n-                NEQ => Some((c, BinOp::NegatedEqualityTest)),\n-                LTEQ => Some((c, BinOp::LesserEqualTest)),\n-                GTEQ => Some((c, BinOp::GreaterEqualTest)),\n-                L_ANGLE => Some((c, BinOp::LesserTest)),\n-                R_ANGLE => Some((c, BinOp::GreaterTest)),\n-                PLUS => Some((c, BinOp::Addition)),\n-                STAR => Some((c, BinOp::Multiplication)),\n-                MINUS => Some((c, BinOp::Subtraction)),\n-                SLASH => Some((c, BinOp::Division)),\n-                PERCENT => Some((c, BinOp::Remainder)),\n-                SHL => Some((c, BinOp::LeftShift)),\n-                SHR => Some((c, BinOp::RightShift)),\n-                CARET => Some((c, BinOp::BitwiseXor)),\n-                PIPE => Some((c, BinOp::BitwiseOr)),\n-                AMP => Some((c, BinOp::BitwiseAnd)),\n-                DOTDOT => Some((c, BinOp::RangeRightOpen)),\n-                DOTDOTEQ => Some((c, BinOp::RangeRightClosed)),\n-                EQ => Some((c, BinOp::Assignment)),\n-                PLUSEQ => Some((c, BinOp::AddAssign)),\n-                SLASHEQ => Some((c, BinOp::DivAssign)),\n-                STAREQ => Some((c, BinOp::MulAssign)),\n-                PERCENTEQ => Some((c, BinOp::RemAssign)),\n-                SHREQ => Some((c, BinOp::ShrAssign)),\n-                SHLEQ => Some((c, BinOp::ShlAssign)),\n-                MINUSEQ => Some((c, BinOp::SubAssign)),\n-                PIPEEQ => Some((c, BinOp::BitOrAssign)),\n-                AMPEQ => Some((c, BinOp::BitAndAssign)),\n-                CARETEQ => Some((c, BinOp::BitXorAssign)),\n-                _ => None,\n-            }\n-        })\n-    }\n-\n-    pub fn op_kind(&self) -> Option<BinOp> {\n-        self.op_details().map(|t| t.1)\n-    }\n-\n-    pub fn op_token(&self) -> Option<SyntaxToken> {\n-        self.op_details().map(|t| t.0)\n-    }\n-\n-    pub fn lhs(&self) -> Option<&Expr> {\n-        children(self).nth(0)\n-    }\n-\n-    pub fn rhs(&self) -> Option<&Expr> {\n-        children(self).nth(1)\n-    }\n-\n-    pub fn sub_exprs(&self) -> (Option<&Expr>, Option<&Expr>) {\n-        let mut children = children(self);\n-        let first = children.next();\n-        let second = children.next();\n-        (first, second)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum SelfParamFlavor {\n-    /// self\n-    Owned,\n-    /// &self\n-    Ref,\n-    /// &mut self\n-    MutRef,\n-}\n-\n-impl SelfParam {\n-    pub fn self_kw_token(&self) -> SyntaxToken {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == SELF_KW)\n-            .expect(\"invalid tree: self param must have self\")\n-    }\n-\n-    pub fn flavor(&self) -> SelfParamFlavor {\n-        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == AMP);\n-        if borrowed {\n-            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n-            if self\n-                .syntax()\n-                .children_with_tokens()\n-                .skip_while(|n| n.kind() != AMP)\n-                .any(|n| n.kind() == MUT_KW)\n-            {\n-                SelfParamFlavor::MutRef\n-            } else {\n-                SelfParamFlavor::Ref\n-            }\n-        } else {\n-            SelfParamFlavor::Owned\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum LiteralFlavor {\n-    String,\n-    ByteString,\n-    Char,\n-    Byte,\n-    IntNumber { suffix: Option<SmolStr> },\n-    FloatNumber { suffix: Option<SmolStr> },\n-    Bool,\n-}\n-\n-impl Literal {\n-    pub fn token(&self) -> SyntaxToken {\n-        match self.syntax().first_child_or_token().unwrap() {\n-            SyntaxElement::Token(token) => token,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    pub fn flavor(&self) -> LiteralFlavor {\n-        match self.token().kind() {\n-            INT_NUMBER => {\n-                let allowed_suffix_list = [\n-                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n-                    \"u16\", \"u8\",\n-                ];\n-                let text = self.token().text().to_string();\n-                let suffix = allowed_suffix_list\n-                    .iter()\n-                    .find(|&s| text.ends_with(s))\n-                    .map(|&suf| SmolStr::new(suf));\n-                LiteralFlavor::IntNumber { suffix }\n-            }\n-            FLOAT_NUMBER => {\n-                let allowed_suffix_list = [\"f64\", \"f32\"];\n-                let text = self.token().text().to_string();\n-                let suffix = allowed_suffix_list\n-                    .iter()\n-                    .find(|&s| text.ends_with(s))\n-                    .map(|&suf| SmolStr::new(suf));\n-                LiteralFlavor::FloatNumber { suffix: suffix }\n-            }\n-            STRING | RAW_STRING => LiteralFlavor::String,\n-            TRUE_KW | FALSE_KW => LiteralFlavor::Bool,\n-            BYTE_STRING | RAW_BYTE_STRING => LiteralFlavor::ByteString,\n-            CHAR => LiteralFlavor::Char,\n-            BYTE => LiteralFlavor::Byte,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl NamedField {\n-    pub fn parent_struct_lit(&self) -> &StructLit {\n-        self.syntax().ancestors().find_map(StructLit::cast).unwrap()\n-    }\n-}\n-\n-impl BindPat {\n-    pub fn is_mutable(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-\n-    pub fn is_ref(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == REF_KW)\n-    }\n-}\n-\n-impl LifetimeParam {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == LIFETIME)\n-    }\n-}\n-\n-impl WherePred {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == LIFETIME)\n-    }\n-}\n-\n #[test]\n fn test_doc_comment_none() {\n     let file = SourceFile::parse("}, {"sha": "ddc26206f1c3899fc7b9ea62531f6608603dfc53", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "patch": "@@ -0,0 +1,250 @@\n+use crate::{\n+    SyntaxToken, SyntaxElement, SmolStr,\n+    ast::{self, AstNode, AstChildren, children, child_opt},\n+    SyntaxKind::*\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ElseBranch<'a> {\n+    Block(&'a ast::Block),\n+    IfExpr(&'a ast::IfExpr),\n+}\n+\n+impl ast::IfExpr {\n+    pub fn then_branch(&self) -> Option<&ast::Block> {\n+        self.blocks().nth(0)\n+    }\n+    pub fn else_branch(&self) -> Option<ElseBranch> {\n+        let res = match self.blocks().nth(1) {\n+            Some(block) => ElseBranch::Block(block),\n+            None => {\n+                let elif: &ast::IfExpr = child_opt(self)?;\n+                ElseBranch::IfExpr(elif)\n+            }\n+        };\n+        Some(res)\n+    }\n+\n+    fn blocks(&self) -> AstChildren<ast::Block> {\n+        children(self)\n+    }\n+}\n+\n+impl ast::RefExpr {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum PrefixOp {\n+    /// The `*` operator for dereferencing\n+    Deref,\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg,\n+}\n+\n+impl ast::PrefixExpr {\n+    pub fn op_kind(&self) -> Option<PrefixOp> {\n+        match self.op_token()?.kind() {\n+            STAR => Some(PrefixOp::Deref),\n+            EXCL => Some(PrefixOp::Not),\n+            MINUS => Some(PrefixOp::Neg),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn op_token(&self) -> Option<SyntaxToken> {\n+        self.syntax().first_child_or_token()?.as_token()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum BinOp {\n+    /// The `||` operator for boolean OR\n+    BooleanOr,\n+    /// The `&&` operator for boolean AND\n+    BooleanAnd,\n+    /// The `==` operator for equality testing\n+    EqualityTest,\n+    /// The `!=` operator for equality testing\n+    NegatedEqualityTest,\n+    /// The `<=` operator for lesser-equal testing\n+    LesserEqualTest,\n+    /// The `>=` operator for greater-equal testing\n+    GreaterEqualTest,\n+    /// The `<` operator for comparison\n+    LesserTest,\n+    /// The `>` operator for comparison\n+    GreaterTest,\n+    /// The `+` operator for addition\n+    Addition,\n+    /// The `*` operator for multiplication\n+    Multiplication,\n+    /// The `-` operator for subtraction\n+    Subtraction,\n+    /// The `/` operator for division\n+    Division,\n+    /// The `%` operator for remainder after division\n+    Remainder,\n+    /// The `<<` operator for left shift\n+    LeftShift,\n+    /// The `>>` operator for right shift\n+    RightShift,\n+    /// The `^` operator for bitwise XOR\n+    BitwiseXor,\n+    /// The `|` operator for bitwise OR\n+    BitwiseOr,\n+    /// The `&` operator for bitwise AND\n+    BitwiseAnd,\n+    /// The `..` operator for right-open ranges\n+    RangeRightOpen,\n+    /// The `..=` operator for right-closed ranges\n+    RangeRightClosed,\n+    /// The `=` operator for assignment\n+    Assignment,\n+    /// The `+=` operator for assignment after addition\n+    AddAssign,\n+    /// The `/=` operator for assignment after division\n+    DivAssign,\n+    /// The `*=` operator for assignment after multiplication\n+    MulAssign,\n+    /// The `%=` operator for assignment after remainders\n+    RemAssign,\n+    /// The `>>=` operator for assignment after shifting right\n+    ShrAssign,\n+    /// The `<<=` operator for assignment after shifting left\n+    ShlAssign,\n+    /// The `-=` operator for assignment after subtraction\n+    SubAssign,\n+    /// The `|=` operator for assignment after bitwise OR\n+    BitOrAssign,\n+    /// The `&=` operator for assignment after bitwise AND\n+    BitAndAssign,\n+    /// The `^=` operator for assignment after bitwise XOR\n+    BitXorAssign,\n+}\n+\n+impl ast::BinExpr {\n+    fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n+        self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n+            match c.kind() {\n+                PIPEPIPE => Some((c, BinOp::BooleanOr)),\n+                AMPAMP => Some((c, BinOp::BooleanAnd)),\n+                EQEQ => Some((c, BinOp::EqualityTest)),\n+                NEQ => Some((c, BinOp::NegatedEqualityTest)),\n+                LTEQ => Some((c, BinOp::LesserEqualTest)),\n+                GTEQ => Some((c, BinOp::GreaterEqualTest)),\n+                L_ANGLE => Some((c, BinOp::LesserTest)),\n+                R_ANGLE => Some((c, BinOp::GreaterTest)),\n+                PLUS => Some((c, BinOp::Addition)),\n+                STAR => Some((c, BinOp::Multiplication)),\n+                MINUS => Some((c, BinOp::Subtraction)),\n+                SLASH => Some((c, BinOp::Division)),\n+                PERCENT => Some((c, BinOp::Remainder)),\n+                SHL => Some((c, BinOp::LeftShift)),\n+                SHR => Some((c, BinOp::RightShift)),\n+                CARET => Some((c, BinOp::BitwiseXor)),\n+                PIPE => Some((c, BinOp::BitwiseOr)),\n+                AMP => Some((c, BinOp::BitwiseAnd)),\n+                DOTDOT => Some((c, BinOp::RangeRightOpen)),\n+                DOTDOTEQ => Some((c, BinOp::RangeRightClosed)),\n+                EQ => Some((c, BinOp::Assignment)),\n+                PLUSEQ => Some((c, BinOp::AddAssign)),\n+                SLASHEQ => Some((c, BinOp::DivAssign)),\n+                STAREQ => Some((c, BinOp::MulAssign)),\n+                PERCENTEQ => Some((c, BinOp::RemAssign)),\n+                SHREQ => Some((c, BinOp::ShrAssign)),\n+                SHLEQ => Some((c, BinOp::ShlAssign)),\n+                MINUSEQ => Some((c, BinOp::SubAssign)),\n+                PIPEEQ => Some((c, BinOp::BitOrAssign)),\n+                AMPEQ => Some((c, BinOp::BitAndAssign)),\n+                CARETEQ => Some((c, BinOp::BitXorAssign)),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    pub fn op_kind(&self) -> Option<BinOp> {\n+        self.op_details().map(|t| t.1)\n+    }\n+\n+    pub fn op_token(&self) -> Option<SyntaxToken> {\n+        self.op_details().map(|t| t.0)\n+    }\n+\n+    pub fn lhs(&self) -> Option<&ast::Expr> {\n+        children(self).nth(0)\n+    }\n+\n+    pub fn rhs(&self) -> Option<&ast::Expr> {\n+        children(self).nth(1)\n+    }\n+\n+    pub fn sub_exprs(&self) -> (Option<&ast::Expr>, Option<&ast::Expr>) {\n+        let mut children = children(self);\n+        let first = children.next();\n+        let second = children.next();\n+        (first, second)\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LiteralFlavor {\n+    String,\n+    ByteString,\n+    Char,\n+    Byte,\n+    IntNumber { suffix: Option<SmolStr> },\n+    FloatNumber { suffix: Option<SmolStr> },\n+    Bool,\n+}\n+\n+impl ast::Literal {\n+    pub fn token(&self) -> SyntaxToken {\n+        match self.syntax().first_child_or_token().unwrap() {\n+            SyntaxElement::Token(token) => token,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    pub fn flavor(&self) -> LiteralFlavor {\n+        match self.token().kind() {\n+            INT_NUMBER => {\n+                let allowed_suffix_list = [\n+                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n+                    \"u16\", \"u8\",\n+                ];\n+                let text = self.token().text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralFlavor::IntNumber { suffix }\n+            }\n+            FLOAT_NUMBER => {\n+                let allowed_suffix_list = [\"f64\", \"f32\"];\n+                let text = self.token().text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralFlavor::FloatNumber { suffix: suffix }\n+            }\n+            STRING | RAW_STRING => LiteralFlavor::String,\n+            TRUE_KW | FALSE_KW => LiteralFlavor::Bool,\n+            BYTE_STRING | RAW_BYTE_STRING => LiteralFlavor::ByteString,\n+            CHAR => LiteralFlavor::Char,\n+            BYTE => LiteralFlavor::Byte,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl ast::NamedField {\n+    pub fn parent_struct_lit(&self) -> &ast::StructLit {\n+        self.syntax().ancestors().find_map(ast::StructLit::cast).unwrap()\n+    }\n+}"}, {"sha": "87592bfd82b00c4ac1dd606be00db7b0bfbeb025", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5001c0a5ddadccd18fe787d89de3d6c3c8147f/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=cb5001c0a5ddadccd18fe787d89de3d6c3c8147f", "patch": "@@ -0,0 +1,300 @@\n+use itertools::Itertools;\n+\n+use crate::{\n+    SmolStr, SyntaxToken,\n+    ast::{self, AstNode, children, child_opt},\n+    SyntaxKind::*,\n+};\n+\n+impl ast::Name {\n+    pub fn text(&self) -> &SmolStr {\n+        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n+        ident.text()\n+    }\n+}\n+\n+impl ast::NameRef {\n+    pub fn text(&self) -> &SmolStr {\n+        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n+        ident.text()\n+    }\n+}\n+\n+impl ast::Attr {\n+    pub fn is_inner(&self) -> bool {\n+        let tt = match self.value() {\n+            None => return false,\n+            Some(tt) => tt,\n+        };\n+\n+        let prev = match tt.syntax().prev_sibling() {\n+            None => return false,\n+            Some(prev) => prev,\n+        };\n+\n+        prev.kind() == EXCL\n+    }\n+\n+    pub fn as_atom(&self) -> Option<SmolStr> {\n+        let tt = self.value()?;\n+        let (_bra, attr, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n+        if attr.kind() == IDENT {\n+            Some(attr.as_token()?.text().clone())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn as_call(&self) -> Option<(SmolStr, &ast::TokenTree)> {\n+        let tt = self.value()?;\n+        let (_bra, attr, args, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n+        let args = ast::TokenTree::cast(args.as_node()?)?;\n+        if attr.kind() == IDENT {\n+            Some((attr.as_token()?.text().clone(), args))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn as_named(&self) -> Option<SmolStr> {\n+        let tt = self.value()?;\n+        let attr = tt.syntax().children_with_tokens().nth(1)?;\n+        if attr.kind() == IDENT {\n+            Some(attr.as_token()?.text().clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum PathSegmentKind<'a> {\n+    Name(&'a ast::NameRef),\n+    SelfKw,\n+    SuperKw,\n+    CrateKw,\n+}\n+\n+impl ast::PathSegment {\n+    pub fn parent_path(&self) -> &ast::Path {\n+        self.syntax()\n+            .parent()\n+            .and_then(ast::Path::cast)\n+            .expect(\"segments are always nested in paths\")\n+    }\n+\n+    pub fn kind(&self) -> Option<PathSegmentKind> {\n+        let res = if let Some(name_ref) = self.name_ref() {\n+            PathSegmentKind::Name(name_ref)\n+        } else {\n+            match self.syntax().first_child_or_token()?.kind() {\n+                SELF_KW => PathSegmentKind::SelfKw,\n+                SUPER_KW => PathSegmentKind::SuperKw,\n+                CRATE_KW => PathSegmentKind::CrateKw,\n+                _ => return None,\n+            }\n+        };\n+        Some(res)\n+    }\n+\n+    pub fn has_colon_colon(&self) -> bool {\n+        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n+            Some(COLONCOLON) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl ast::Path {\n+    pub fn parent_path(&self) -> Option<&ast::Path> {\n+        self.syntax().parent().and_then(ast::Path::cast)\n+    }\n+}\n+\n+impl ast::Module {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax().last_child_or_token() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}\n+\n+impl ast::UseTree {\n+    pub fn has_star(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == STAR)\n+    }\n+}\n+\n+impl ast::UseTreeList {\n+    pub fn parent_use_tree(&self) -> &ast::UseTree {\n+        self.syntax()\n+            .parent()\n+            .and_then(ast::UseTree::cast)\n+            .expect(\"UseTreeLists are always nested in UseTrees\")\n+    }\n+}\n+\n+impl ast::ImplBlock {\n+    pub fn target_type(&self) -> Option<&ast::TypeRef> {\n+        match self.target() {\n+            (Some(t), None) | (_, Some(t)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn target_trait(&self) -> Option<&ast::TypeRef> {\n+        match self.target() {\n+            (Some(t), Some(_)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    fn target(&self) -> (Option<&ast::TypeRef>, Option<&ast::TypeRef>) {\n+        let mut types = children(self);\n+        let first = types.next();\n+        let second = types.next();\n+        (first, second)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum StructFlavor<'a> {\n+    Tuple(&'a ast::PosFieldDefList),\n+    Named(&'a ast::NamedFieldDefList),\n+    Unit,\n+}\n+\n+impl StructFlavor<'_> {\n+    fn from_node<N: AstNode>(node: &N) -> StructFlavor {\n+        if let Some(nfdl) = child_opt::<_, ast::NamedFieldDefList>(node) {\n+            StructFlavor::Named(nfdl)\n+        } else if let Some(pfl) = child_opt::<_, ast::PosFieldDefList>(node) {\n+            StructFlavor::Tuple(pfl)\n+        } else {\n+            StructFlavor::Unit\n+        }\n+    }\n+}\n+\n+impl ast::StructDef {\n+    pub fn flavor(&self) -> StructFlavor {\n+        StructFlavor::from_node(self)\n+    }\n+}\n+\n+impl ast::EnumVariant {\n+    pub fn parent_enum(&self) -> &ast::EnumDef {\n+        self.syntax()\n+            .parent()\n+            .and_then(|it| it.parent())\n+            .and_then(ast::EnumDef::cast)\n+            .expect(\"EnumVariants are always nested in Enums\")\n+    }\n+    pub fn flavor(&self) -> StructFlavor {\n+        StructFlavor::from_node(self)\n+    }\n+}\n+\n+impl ast::LetStmt {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax().last_child_or_token() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}\n+\n+impl ast::ExprStmt {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax().last_child_or_token() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}\n+\n+impl ast::RefPat {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+impl ast::BindPat {\n+    pub fn is_mutable(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+\n+    pub fn is_ref(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == REF_KW)\n+    }\n+}\n+\n+impl ast::PointerType {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+impl ast::ReferenceType {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum SelfParamFlavor {\n+    /// self\n+    Owned,\n+    /// &self\n+    Ref,\n+    /// &mut self\n+    MutRef,\n+}\n+\n+impl ast::SelfParam {\n+    pub fn self_kw_token(&self) -> SyntaxToken {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == SELF_KW)\n+            .expect(\"invalid tree: self param must have self\")\n+    }\n+\n+    pub fn flavor(&self) -> SelfParamFlavor {\n+        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == AMP);\n+        if borrowed {\n+            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n+            if self\n+                .syntax()\n+                .children_with_tokens()\n+                .skip_while(|n| n.kind() != AMP)\n+                .any(|n| n.kind() == MUT_KW)\n+            {\n+                SelfParamFlavor::MutRef\n+            } else {\n+                SelfParamFlavor::Ref\n+            }\n+        } else {\n+            SelfParamFlavor::Owned\n+        }\n+    }\n+}\n+\n+impl ast::LifetimeParam {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == LIFETIME)\n+    }\n+}\n+\n+impl ast::WherePred {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == LIFETIME)\n+    }\n+}"}]}