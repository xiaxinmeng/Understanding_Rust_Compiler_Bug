{"sha": "9e3432447a9c6386443acdf731d488c159be3f66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMzQzMjQ0N2E5YzYzODY0NDNhY2RmNzMxZDQ4OGMxNTliZTNmNjY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-05-10T18:02:19Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-05-17T14:47:25Z"}, "message": "Switch to 1.26 bootstrap compiler", "tree": {"sha": "5a9c32706cb6f6c9bc55068fa8ab96d6e43a4e35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a9c32706cb6f6c9bc55068fa8ab96d6e43a4e35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e3432447a9c6386443acdf731d488c159be3f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3432447a9c6386443acdf731d488c159be3f66", "html_url": "https://github.com/rust-lang/rust/commit/9e3432447a9c6386443acdf731d488c159be3f66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e3432447a9c6386443acdf731d488c159be3f66/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3150564f889a3bad01795d9fcb31d4f14d58a99", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3150564f889a3bad01795d9fcb31d4f14d58a99", "html_url": "https://github.com/rust-lang/rust/commit/e3150564f889a3bad01795d9fcb31d4f14d58a99"}], "stats": {"total": 1946, "additions": 434, "deletions": 1512}, "files": [{"sha": "a2495f68c1fa3148d2ee07aebda3b18cb9a8cfaa", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.27.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.28.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "ada21e04b306cc9c0662611b1dafb0e998b2284f", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -2,6 +2,8 @@\n authors = [\"The Rust Project Developers\"]\n name = \"alloc\"\n version = \"0.0.0\"\n+autotests = false\n+autobenches = false\n \n [lib]\n name = \"alloc\""}, {"sha": "b4b82e6ecffbbce9277975665c5a3aa21e6320e4", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -22,28 +22,6 @@ use core::usize;\n #[doc(inline)]\n pub use core::alloc::*;\n \n-#[cfg(stage0)]\n-extern \"Rust\" {\n-    #[allocator]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-    #[cold]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_oom(err: *const u8) -> !;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n-    #[rustc_allocator_nounwind]\n-    fn __rust_realloc(ptr: *mut u8,\n-                      old_size: usize,\n-                      old_align: usize,\n-                      new_size: usize,\n-                      new_align: usize,\n-                      err: *mut u8) -> *mut u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-}\n-\n-#[cfg(not(stage0))]\n extern \"Rust\" {\n     #[allocator]\n     #[rustc_allocator_nounwind]\n@@ -74,10 +52,7 @@ pub const Heap: Global = Global;\n unsafe impl GlobalAlloc for Global {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-        #[cfg(not(stage0))]\n         let ptr = __rust_alloc(layout.size(), layout.align());\n-        #[cfg(stage0)]\n-        let ptr = __rust_alloc(layout.size(), layout.align(), &mut 0);\n         ptr as *mut Opaque\n     }\n \n@@ -88,20 +63,13 @@ unsafe impl GlobalAlloc for Global {\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-        #[cfg(not(stage0))]\n         let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(), new_size);\n-        #[cfg(stage0)]\n-        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(),\n-                                 new_size, layout.align(), &mut 0);\n         ptr as *mut Opaque\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-        #[cfg(not(stage0))]\n         let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n-        #[cfg(stage0)]\n-        let ptr = __rust_alloc_zeroed(layout.size(), layout.align(), &mut 0);\n         ptr as *mut Opaque\n     }\n }\n@@ -152,14 +120,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg(stage0)]\n-#[lang = \"box_free\"]\n-#[inline]\n-unsafe fn old_box_free<T: ?Sized>(ptr: *mut T) {\n-    box_free(Unique::new_unchecked(ptr))\n-}\n-\n-#[cfg_attr(not(any(test, stage0)), lang = \"box_free\")]\n+#[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     let ptr = ptr.as_ptr();\n@@ -172,12 +133,6 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn oom() -> ! {\n-    unsafe { ::core::intrinsics::abort() }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn oom() -> ! {\n     extern {\n         #[lang = \"oom\"]"}, {"sha": "91de3ad0c390bb1fe292c7788cc4037cdbddb927", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -75,7 +75,6 @@\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(all(not(test), stage0), feature(float_internals))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n@@ -90,13 +89,10 @@\n #![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n-#![cfg_attr(stage0, feature(core_slice_ext))]\n-#![cfg_attr(stage0, feature(core_str_ext))]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n-#![cfg_attr(stage0, feature(fn_must_use))]\n #![feature(from_ref)]\n #![feature(fundamental)]\n #![feature(lang_items)]\n@@ -122,7 +118,6 @@\n #![feature(exact_chunks)]\n #![feature(pointer_methods)]\n #![feature(inclusive_range_methods)]\n-#![cfg_attr(stage0, feature(generic_param_attrs))]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n \n@@ -157,15 +152,10 @@ pub mod alloc;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n /// Use the `alloc` module instead.\n-#[cfg(not(stage0))]\n pub mod heap {\n     pub use alloc::*;\n }\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n-#[cfg(stage0)]\n-pub mod heap;\n \n // Primitive types using the heaps above\n "}, {"sha": "4427ac004f97aa4bef998b973534b6847c4e3f94", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -101,7 +101,6 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n-#[cfg(stage0)] use core::slice::SliceExt;\n use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n@@ -171,13 +170,9 @@ mod hack {\n     }\n }\n \n-#[cfg_attr(stage0, lang = \"slice\")]\n-#[cfg_attr(not(stage0), lang = \"slice_alloc\")]\n+#[lang = \"slice_alloc\"]\n #[cfg(not(test))]\n impl<T> [T] {\n-    #[cfg(stage0)]\n-    slice_core_methods!();\n-\n     /// Sorts the slice.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n@@ -467,8 +462,7 @@ impl<T> [T] {\n     }\n }\n \n-#[cfg_attr(stage0, lang = \"slice_u8\")]\n-#[cfg_attr(not(stage0), lang = \"slice_u8_alloc\")]\n+#[lang = \"slice_u8_alloc\"]\n #[cfg(not(test))]\n impl [u8] {\n     /// Returns a vector containing a copy of this slice where each byte\n@@ -504,9 +498,6 @@ impl [u8] {\n         me.make_ascii_lowercase();\n         me\n     }\n-\n-    #[cfg(stage0)]\n-    slice_u8_core_methods!();\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "c10c0a69433920ba0ff45f6054cab8e4e5e27603", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -40,7 +40,6 @@\n \n use core::fmt;\n use core::str as core_str;\n-#[cfg(stage0)] use core::str::StrExt;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n@@ -158,13 +157,9 @@ impl ToOwned for str {\n }\n \n /// Methods for string slices.\n-#[cfg_attr(stage0, lang = \"str\")]\n-#[cfg_attr(not(stage0), lang = \"str_alloc\")]\n+#[lang = \"str_alloc\"]\n #[cfg(not(test))]\n impl str {\n-    #[cfg(stage0)]\n-    str_core_methods!();\n-\n     /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n     ///\n     /// # Examples"}, {"sha": "bf89b377b7eefcf4fb64326c6362443b7a1f50b1", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -73,9 +73,6 @@ use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem;\n-#[cfg(not(test))]\n-#[cfg(stage0)]\n-use core::num::Float;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds};\n use core::ops;"}, {"sha": "ce856eccd837b8f4298dbd0ef057638ce83c5c75", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -97,13 +97,6 @@ mod contents {\n         ptr\n     }\n \n-    #[cfg(stage0)]\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_oom() -> ! {\n-        ::core::intrinsics::abort();\n-    }\n-\n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_dealloc(ptr: *mut u8,"}, {"sha": "9490b54e675df562e737188bc5a76a52702fe903", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -73,33 +73,6 @@ unsafe impl Alloc for System {\n     }\n }\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl<'a> Alloc for &'a System {\n-    #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(*self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(*self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n-        GlobalAlloc::dealloc(*self, ptr.as_ptr(), layout)\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n-                      layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(*self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n-    }\n-}\n-\n #[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod realloc_fallback {\n     use core::alloc::{GlobalAlloc, Opaque, Layout};"}, {"sha": "f7143a4f981555a4ee1383983e6408b9b7d5abd1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -26,7 +26,6 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![cfg_attr(stage0, feature(generic_param_attrs))]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]"}, {"sha": "321ed892ea9a986337baa7ea902215e27202f816", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -2,6 +2,8 @@\n authors = [\"The Rust Project Developers\"]\n name = \"core\"\n version = \"0.0.0\"\n+autotests = false\n+autobenches = false\n \n [lib]\n name = \"core\""}, {"sha": "3b15ba2b4ab1fbc5167e73d73808191a6467b9de", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -153,7 +153,6 @@ pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T\n ///\n /// Implementations that cannot be described in Rust\n /// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n-#[cfg(not(stage0))]\n mod impls {\n \n     use super::Clone;"}, {"sha": "db75f9bf210fc399bc7a02917b3b5ae0db6fae46", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -86,17 +86,3 @@ macro_rules! forward_ref_op_assign {\n         }\n     }\n }\n-\n-#[cfg(stage0)]\n-macro_rules! public_in_stage0 {\n-    ( { $(#[$attr:meta])* } $($Item: tt)*) => {\n-        $(#[$attr])* pub $($Item)*\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n-macro_rules! public_in_stage0 {\n-    ( { $(#[$attr:meta])* } $($Item: tt)*) => {\n-        $(#[$attr])* pub(crate) $($Item)*\n-    }\n-}"}, {"sha": "77b5488084d99c1b5b786aab51bbb3349a5d4fbd", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -112,18 +112,13 @@\n #![feature(unwind_attributes)]\n #![feature(doc_alias)]\n #![feature(inclusive_range_methods)]\n-\n-#![cfg_attr(not(stage0), feature(mmx_target_feature))]\n-#![cfg_attr(not(stage0), feature(tbm_target_feature))]\n-#![cfg_attr(not(stage0), feature(sse4a_target_feature))]\n-#![cfg_attr(not(stage0), feature(arm_target_feature))]\n-#![cfg_attr(not(stage0), feature(powerpc_target_feature))]\n-#![cfg_attr(not(stage0), feature(mips_target_feature))]\n-#![cfg_attr(not(stage0), feature(aarch64_target_feature))]\n-\n-#![cfg_attr(stage0, feature(target_feature))]\n-#![cfg_attr(stage0, feature(cfg_target_feature))]\n-#![cfg_attr(stage0, feature(fn_must_use))]\n+#![feature(mmx_target_feature)]\n+#![feature(tbm_target_feature)]\n+#![feature(sse4a_target_feature)]\n+#![feature(arm_target_feature)]\n+#![feature(powerpc_target_feature)]\n+#![feature(mips_target_feature)]\n+#![feature(aarch64_target_feature)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "6c8ee0eda11e93f30e11b277dcc2fb47d24f429f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -611,7 +611,6 @@ pub unsafe auto trait Unpin {}\n ///\n /// Implementations that cannot be described in Rust\n /// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n-#[cfg(not(stage0))]\n mod copy_impls {\n \n     use super::Copy;"}, {"sha": "718dd42a61535f6fd59fc405203709b8e6f39b1f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -19,7 +19,7 @@\n \n use mem;\n use num::Float;\n-#[cfg(not(stage0))] use num::FpCategory;\n+use num::FpCategory;\n use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f32`.\n@@ -277,7 +277,6 @@ impl Float for f32 {\n \n // FIXME: remove (inline) this macro and the Float trait\n // when updating to a bootstrap compiler that has the new lang items.\n-#[cfg_attr(stage0, macro_export)]\n #[unstable(feature = \"core_float\", issue = \"32110\")]\n macro_rules! f32_core_methods { () => {\n     /// Returns `true` if this value is `NaN` and false otherwise.\n@@ -553,7 +552,6 @@ macro_rules! f32_core_methods { () => {\n \n #[lang = \"f32\"]\n #[cfg(not(test))]\n-#[cfg(not(stage0))]\n impl f32 {\n     f32_core_methods!();\n }"}, {"sha": "f128c55c78afa2aa59aaa12144d3c7478bfd9bbc", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -19,7 +19,7 @@\n \n use mem;\n use num::Float;\n-#[cfg(not(stage0))] use num::FpCategory;\n+use num::FpCategory;\n use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f64`.\n@@ -276,7 +276,6 @@ impl Float for f64 {\n \n // FIXME: remove (inline) this macro and the Float trait\n // when updating to a bootstrap compiler that has the new lang items.\n-#[cfg_attr(stage0, macro_export)]\n #[unstable(feature = \"core_float\", issue = \"32110\")]\n macro_rules! f64_core_methods { () => {\n     /// Returns `true` if this value is `NaN` and false otherwise.\n@@ -562,7 +561,6 @@ macro_rules! f64_core_methods { () => {\n \n #[lang = \"f64\"]\n #[cfg(not(test))]\n-#[cfg(not(stage0))]\n impl f64 {\n     f64_core_methods!();\n }"}, {"sha": "58d45b107f169598866d1506374ff230e0cce7fe", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -422,7 +422,6 @@ $EndFeature, \"\n         /// assert_eq!(m, -22016);\n         /// ```\n         #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n-        #[cfg(not(stage0))]\n         #[inline]\n         pub fn reverse_bits(self) -> Self {\n             (self as $UnsignedT).reverse_bits() as Self\n@@ -2194,7 +2193,6 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n         /// assert_eq!(m, 43520);\n         /// ```\n         #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n-        #[cfg(not(stage0))]\n         #[inline]\n         pub fn reverse_bits(self) -> Self {\n             unsafe { intrinsics::bitreverse(self as $ActualT) as Self }"}, {"sha": "1f84631ada3a10caa5602c5b95b2e8f16d21046e", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -335,18 +335,8 @@ pub struct RangeInclusive<Idx> {\n     // but it is known that LLVM is not able to optimize loops following that RFC.\n     // Consider adding an extra `bool` field to indicate emptiness of the range.\n     // See #45222 for performance test cases.\n-    #[cfg(not(stage0))]\n     pub(crate) start: Idx,\n-    #[cfg(not(stage0))]\n     pub(crate) end: Idx,\n-    /// The lower bound of the range (inclusive).\n-    #[cfg(stage0)]\n-    #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n-    pub start: Idx,\n-    /// The upper bound of the range (inclusive).\n-    #[cfg(stage0)]\n-    #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n-    pub end: Idx,\n }\n \n impl<Idx> RangeInclusive<Idx> {"}, {"sha": "45f629a64424cd526c0a17d27525f10c58f8bc1d", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -54,13 +54,3 @@ pub use option::Option::{self, Some, None};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use result::Result::{self, Ok, Err};\n-\n-// Re-exported extension traits for primitive types\n-#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)]\n-#[cfg(stage0)]\n-pub use slice::SliceExt;\n-#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)]\n-#[cfg(stage0)]\n-pub use str::StrExt;"}, {"sha": "82891b691dc578306dd4e6d04567c43b662ef052", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 259, "deletions": 728, "changes": 987, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -68,181 +68,6 @@ struct Repr<T> {\n // Extension traits\n //\n \n-public_in_stage0! {\n-{\n-/// Extension methods for slices.\n-#[unstable(feature = \"core_slice_ext\",\n-           reason = \"stable interface provided by `impl [T]` in later crates\",\n-           issue = \"32110\")]\n-#[allow(missing_docs)] // documented elsewhere\n-}\n-trait SliceExt {\n-    type Item;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn iter(&self) -> Iter<Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n-    fn rsplit<P>(&self, pred: P) -> RSplit<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rsplitn<P>(&self,  n: usize, pred: P) -> RSplitN<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn windows(&self, size: usize) -> Windows<Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n-\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-    fn exact_chunks(&self, size: usize) -> ExactChunks<Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<Self>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn first(&self) -> Option<&Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_first(&self) -> Option<(&Self::Item, &[Self::Item])>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_last(&self) -> Option<(&Self::Item, &[Self::Item])>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn last(&self) -> Option<&Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<Self>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn as_ptr(&self) -> *const Self::Item;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize>\n-        where Self::Item: Ord;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a Self::Item) -> Ordering;\n-\n-    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n-    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a Self::Item) -> B,\n-              B: Ord;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn len(&self) -> usize;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<Self>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_first_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_last_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n-    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>\n-        where P: FnMut(&Self::Item) -> bool;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n-\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-    fn exact_chunks_mut(&mut self, size: usize) -> ExactChunksMut<Self::Item>;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn swap(&mut self, a: usize, b: usize);\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn reverse(&mut self);\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<Self>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n-\n-    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n-    fn rotate_left(&mut self, mid: usize);\n-\n-    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n-    fn rotate_right(&mut self, k: usize);\n-\n-    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n-    fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n-\n-    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n-    fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n-\n-    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n-    fn swap_with_slice(&mut self, src: &mut [Self::Item]);\n-\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    fn sort_unstable(&mut self)\n-        where Self::Item: Ord;\n-\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    fn sort_unstable_by<F>(&mut self, compare: F)\n-        where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n-\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    fn sort_unstable_by_key<B, F>(&mut self, f: F)\n-        where F: FnMut(&Self::Item) -> B,\n-              B: Ord;\n-}}\n-\n // Use macros to be generic over const/mut\n macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n@@ -281,488 +106,9 @@ macro_rules! make_ref_mut {\n     }};\n }\n \n-#[unstable(feature = \"core_slice_ext\",\n-           reason = \"stable interface provided by `impl [T]` in later crates\",\n-           issue = \"32110\")]\n-impl<T> SliceExt for [T] {\n-    type Item = T;\n-\n-    #[inline]\n-    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        (&self[..mid], &self[mid..])\n-    }\n-\n-    #[inline]\n-    fn iter(&self) -> Iter<T> {\n-        unsafe {\n-            let p = if mem::size_of::<T>() == 0 {\n-                1 as *const _\n-            } else {\n-                let p = self.as_ptr();\n-                assume(!p.is_null());\n-                p\n-            };\n-\n-            Iter {\n-                ptr: p,\n-                end: slice_offset!(p, self.len() as isize),\n-                _marker: marker::PhantomData\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn split<P>(&self, pred: P) -> Split<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        Split {\n-            v: self,\n-            pred,\n-            finished: false\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsplit<P>(&self, pred: P) -> RSplit<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        RSplit { inner: self.split(pred) }\n-    }\n-\n-    #[inline]\n-    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        SplitN {\n-            inner: GenericSplitN {\n-                iter: self.split(pred),\n-                count: n\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsplitn<P>(&self, n: usize, pred: P) -> RSplitN<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        RSplitN {\n-            inner: GenericSplitN {\n-                iter: self.rsplit(pred),\n-                count: n\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn windows(&self, size: usize) -> Windows<T> {\n-        assert!(size != 0);\n-        Windows { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n-        assert!(chunk_size != 0);\n-        Chunks { v: self, chunk_size: chunk_size }\n-    }\n-\n-    #[inline]\n-    fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n-        assert!(chunk_size != 0);\n-        let rem = self.len() % chunk_size;\n-        let len = self.len() - rem;\n-        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n-    }\n-\n-    #[inline]\n-    fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<[T]>\n-    {\n-        index.get(self)\n-    }\n-\n-    #[inline]\n-    fn first(&self) -> Option<&T> {\n-        if self.is_empty() { None } else { Some(&self[0]) }\n-    }\n-\n-    #[inline]\n-    fn split_first(&self) -> Option<(&T, &[T])> {\n-        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n-    }\n-\n-    #[inline]\n-    fn split_last(&self) -> Option<(&T, &[T])> {\n-        let len = self.len();\n-        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n-    }\n-\n-    #[inline]\n-    fn last(&self) -> Option<&T> {\n-        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<[T]>\n-    {\n-        index.get_unchecked(self)\n-    }\n-\n-    #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        self as *const [T] as *const T\n-    }\n-\n-    fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a T) -> Ordering\n-    {\n-        let s = self;\n-        let mut size = s.len();\n-        if size == 0 {\n-            return Err(0);\n-        }\n-        let mut base = 0usize;\n-        while size > 1 {\n-            let half = size / 2;\n-            let mid = base + half;\n-            // mid is always in [0, size), that means mid is >= 0 and < size.\n-            // mid >= 0: by definition\n-            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n-            let cmp = f(unsafe { s.get_unchecked(mid) });\n-            base = if cmp == Greater { base } else { mid };\n-            size -= half;\n-        }\n-        // base is always in [0, size) because base <= mid.\n-        let cmp = f(unsafe { s.get_unchecked(base) });\n-        if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> usize {\n-        unsafe {\n-            mem::transmute::<&[T], Repr<T>>(self).len\n-        }\n-    }\n-\n-    #[inline]\n-    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<[T]>\n-    {\n-        index.get_mut(self)\n-    }\n-\n-    #[inline]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-\n-        unsafe {\n-            assert!(mid <= len);\n-\n-            (from_raw_parts_mut(ptr, mid),\n-             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n-        }\n-    }\n-\n-    #[inline]\n-    fn iter_mut(&mut self) -> IterMut<T> {\n-        unsafe {\n-            let p = if mem::size_of::<T>() == 0 {\n-                1 as *mut _\n-            } else {\n-                let p = self.as_mut_ptr();\n-                assume(!p.is_null());\n-                p\n-            };\n-\n-            IterMut {\n-                ptr: p,\n-                end: slice_offset!(p, self.len() as isize),\n-                _marker: marker::PhantomData\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn last_mut(&mut self) -> Option<&mut T> {\n-        let len = self.len();\n-        if len == 0 { return None; }\n-        Some(&mut self[len - 1])\n-    }\n-\n-    #[inline]\n-    fn first_mut(&mut self) -> Option<&mut T> {\n-        if self.is_empty() { None } else { Some(&mut self[0]) }\n-    }\n-\n-    #[inline]\n-    fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        if self.is_empty() { None } else {\n-            let split = self.split_at_mut(1);\n-            Some((&mut split.0[0], split.1))\n-        }\n-    }\n-\n-    #[inline]\n-    fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        let len = self.len();\n-        if len == 0 { None } else {\n-            let split = self.split_at_mut(len - 1);\n-            Some((&mut split.1[0], split.0))\n-        }\n-    }\n-\n-    #[inline]\n-    fn split_mut<P>(&mut self, pred: P) -> SplitMut<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        SplitMut { v: self, pred: pred, finished: false }\n-    }\n-\n-    #[inline]\n-    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        RSplitMut { inner: self.split_mut(pred) }\n-    }\n-\n-    #[inline]\n-    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P>\n-        where P: FnMut(&T) -> bool\n-    {\n-        SplitNMut {\n-            inner: GenericSplitN {\n-                iter: self.split_mut(pred),\n-                count: n\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsplitn_mut<P>(&mut self, n: usize, pred: P) -> RSplitNMut<T, P> where\n-        P: FnMut(&T) -> bool,\n-    {\n-        RSplitNMut {\n-            inner: GenericSplitN {\n-                iter: self.rsplit_mut(pred),\n-                count: n\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        assert!(chunk_size != 0);\n-        ChunksMut { v: self, chunk_size: chunk_size }\n-    }\n-\n-    #[inline]\n-    fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n-        assert!(chunk_size != 0);\n-        let rem = self.len() % chunk_size;\n-        let len = self.len() - rem;\n-        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n-    }\n-\n-    #[inline]\n-    fn swap(&mut self, a: usize, b: usize) {\n-        unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n-            ptr::swap(pa, pb);\n-        }\n-    }\n-\n-    fn reverse(&mut self) {\n-        let mut i: usize = 0;\n-        let ln = self.len();\n-\n-        // For very small types, all the individual reads in the normal\n-        // path perform poorly.  We can do better, given efficient unaligned\n-        // load/store, by loading a larger chunk and reversing a register.\n-\n-        // Ideally LLVM would do this for us, as it knows better than we do\n-        // whether unaligned reads are efficient (since that changes between\n-        // different ARM versions, for example) and what the best chunk size\n-        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n-        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n-        // is troublesome because the sides can be aligned differently --\n-        // will be, when the length is odd -- so there's no way of emitting\n-        // pre- and postludes to use fully-aligned SIMD in the middle.)\n-\n-        let fast_unaligned =\n-            cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n-\n-        if fast_unaligned && mem::size_of::<T>() == 1 {\n-            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n-            let chunk = mem::size_of::<usize>();\n-            while i + chunk - 1 < ln / 2 {\n-                unsafe {\n-                    let pa: *mut T = self.get_unchecked_mut(i);\n-                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n-                    let va = ptr::read_unaligned(pa as *mut usize);\n-                    let vb = ptr::read_unaligned(pb as *mut usize);\n-                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n-                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n-                }\n-                i += chunk;\n-            }\n-        }\n-\n-        if fast_unaligned && mem::size_of::<T>() == 2 {\n-            // Use rotate-by-16 to reverse u16s in a u32\n-            let chunk = mem::size_of::<u32>() / 2;\n-            while i + chunk - 1 < ln / 2 {\n-                unsafe {\n-                    let pa: *mut T = self.get_unchecked_mut(i);\n-                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n-                    let va = ptr::read_unaligned(pa as *mut u32);\n-                    let vb = ptr::read_unaligned(pb as *mut u32);\n-                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n-                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n-                }\n-                i += chunk;\n-            }\n-        }\n-\n-        while i < ln / 2 {\n-            // Unsafe swap to avoid the bounds check in safe swap.\n-            unsafe {\n-                let pa: *mut T = self.get_unchecked_mut(i);\n-                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n-                ptr::swap(pa, pb);\n-            }\n-            i += 1;\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<[T]>\n-    {\n-        index.get_unchecked_mut(self)\n-    }\n-\n-    #[inline]\n-    fn as_mut_ptr(&mut self) -> *mut T {\n-        self as *mut [T] as *mut T\n-    }\n-\n-    #[inline]\n-    fn contains(&self, x: &T) -> bool where T: PartialEq {\n-        x.slice_contains(self)\n-    }\n-\n-    #[inline]\n-    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        let n = needle.len();\n-        self.len() >= n && needle == &self[..n]\n-    }\n-\n-    #[inline]\n-    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == &self[m-n..]\n-    }\n-\n-    fn binary_search(&self, x: &T) -> Result<usize, usize>\n-        where T: Ord\n-    {\n-        self.binary_search_by(|p| p.cmp(x))\n-    }\n-\n-    fn rotate_left(&mut self, mid: usize) {\n-        assert!(mid <= self.len());\n-        let k = self.len() - mid;\n-\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n-        }\n-    }\n-\n-    fn rotate_right(&mut self, k: usize) {\n-        assert!(k <= self.len());\n-        let mid = self.len() - k;\n-\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n-        }\n-    }\n-\n-    #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n-        assert!(self.len() == src.len(),\n-                \"destination and source slices have different lengths\");\n-        // NOTE: We need to explicitly slice them to the same length\n-        // for bounds checking to be elided, and the optimizer will\n-        // generate memcpy for simple cases (for example T = u8).\n-        let len = self.len();\n-        let src = &src[..len];\n-        for i in 0..len {\n-            self[i].clone_from(&src[i]);\n-        }\n-    }\n-\n-    #[inline]\n-    fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n-        assert!(self.len() == src.len(),\n-                \"destination and source slices have different lengths\");\n-        unsafe {\n-            ptr::copy_nonoverlapping(\n-                src.as_ptr(), self.as_mut_ptr(), self.len());\n-        }\n-    }\n-\n-    #[inline]\n-    fn swap_with_slice(&mut self, src: &mut [T]) {\n-        assert!(self.len() == src.len(),\n-                \"destination and source slices have different lengths\");\n-        unsafe {\n-            ptr::swap_nonoverlapping(\n-                self.as_mut_ptr(), src.as_mut_ptr(), self.len());\n-        }\n-    }\n-\n-    #[inline]\n-    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a Self::Item) -> B,\n-              B: Ord\n-    {\n-        self.binary_search_by(|k| f(k).cmp(b))\n-    }\n-\n-    #[inline]\n-    fn sort_unstable(&mut self)\n-        where Self::Item: Ord\n-    {\n-        sort::quicksort(self, |a, b| a.lt(b));\n-    }\n-\n-    #[inline]\n-    fn sort_unstable_by<F>(&mut self, mut compare: F)\n-        where F: FnMut(&Self::Item, &Self::Item) -> Ordering\n-    {\n-        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n-    }\n-\n-    #[inline]\n-    fn sort_unstable_by_key<B, F>(&mut self, mut f: F)\n-        where F: FnMut(&Self::Item) -> B,\n-              B: Ord\n-    {\n-        sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n-    }\n-}\n-\n-// FIXME: remove (inline) this macro and the SliceExt trait\n-// when updating to a bootstrap compiler that has the new lang items.\n-#[cfg_attr(stage0, macro_export)]\n-#[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n-macro_rules! slice_core_methods { () => {\n+#[lang = \"slice\"]\n+#[cfg(not(test))]\n+impl<T> [T] {\n     /// Returns the number of elements in the slice.\n     ///\n     /// # Examples\n@@ -774,7 +120,9 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn len(&self) -> usize {\n-        SliceExt::len(self)\n+        unsafe {\n+            mem::transmute::<&[T], Repr<T>>(self).len\n+        }\n     }\n \n     /// Returns `true` if the slice has a length of 0.\n@@ -788,7 +136,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n-        SliceExt::is_empty(self)\n+        self.len() == 0\n     }\n \n     /// Returns the first element of the slice, or `None` if it is empty.\n@@ -805,7 +153,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first(&self) -> Option<&T> {\n-        SliceExt::first(self)\n+        if self.is_empty() { None } else { Some(&self[0]) }\n     }\n \n     /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n@@ -823,7 +171,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first_mut(&mut self) -> Option<&mut T> {\n-        SliceExt::first_mut(self)\n+        if self.is_empty() { None } else { Some(&mut self[0]) }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -841,7 +189,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n-        SliceExt::split_first(self)\n+        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -861,7 +209,10 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        SliceExt::split_first_mut(self)\n+        if self.is_empty() { None } else {\n+            let split = self.split_at_mut(1);\n+            Some((&mut split.0[0], split.1))\n+        }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -879,7 +230,8 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n-        SliceExt::split_last(self)\n+        let len = self.len();\n+        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -899,7 +251,12 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        SliceExt::split_last_mut(self)\n+        let len = self.len();\n+        if len == 0 { None } else {\n+            let split = self.split_at_mut(len - 1);\n+            Some((&mut split.1[0], split.0))\n+        }\n+\n     }\n \n     /// Returns the last element of the slice, or `None` if it is empty.\n@@ -916,7 +273,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last(&self) -> Option<&T> {\n-        SliceExt::last(self)\n+        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n     }\n \n     /// Returns a mutable pointer to the last item in the slice.\n@@ -934,7 +291,9 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last_mut(&mut self) -> Option<&mut T> {\n-        SliceExt::last_mut(self)\n+        let len = self.len();\n+        if len == 0 { return None; }\n+        Some(&mut self[len - 1])\n     }\n \n     /// Returns a reference to an element or subslice depending on the type of\n@@ -959,7 +318,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<Self>\n     {\n-        SliceExt::get(self, index)\n+        index.get(self)\n     }\n \n     /// Returns a mutable reference to an element or subslice depending on the\n@@ -982,7 +341,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n         where I: SliceIndex<Self>\n     {\n-        SliceExt::get_mut(self, index)\n+        index.get_mut(self)\n     }\n \n     /// Returns a reference to an element or subslice, without doing bounds\n@@ -1007,7 +366,7 @@ macro_rules! slice_core_methods { () => {\n     pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n         where I: SliceIndex<Self>\n     {\n-        SliceExt::get_unchecked(self, index)\n+        index.get_unchecked(self)\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -1034,7 +393,7 @@ macro_rules! slice_core_methods { () => {\n     pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n         where I: SliceIndex<Self>\n     {\n-        SliceExt::get_unchecked_mut(self, index)\n+        index.get_unchecked_mut(self)\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -1060,7 +419,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn as_ptr(&self) -> *const T {\n-        SliceExt::as_ptr(self)\n+        self as *const [T] as *const T\n     }\n \n     /// Returns an unsafe mutable pointer to the slice's buffer.\n@@ -1087,7 +446,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n-        SliceExt::as_mut_ptr(self)\n+        self as *mut [T] as *mut T\n     }\n \n     /// Swaps two elements in the slice.\n@@ -1111,7 +470,13 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn swap(&mut self, a: usize, b: usize) {\n-        SliceExt::swap(self, a, b)\n+        unsafe {\n+            // Can't take two mutable loans from one vector, so instead just cast\n+            // them to their raw pointers to do the swap\n+            let pa: *mut T = &mut self[a];\n+            let pb: *mut T = &mut self[b];\n+            ptr::swap(pa, pb);\n+        }\n     }\n \n     /// Reverses the order of elements in the slice, in place.\n@@ -1126,7 +491,66 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn reverse(&mut self) {\n-        SliceExt::reverse(self)\n+        let mut i: usize = 0;\n+        let ln = self.len();\n+\n+        // For very small types, all the individual reads in the normal\n+        // path perform poorly.  We can do better, given efficient unaligned\n+        // load/store, by loading a larger chunk and reversing a register.\n+\n+        // Ideally LLVM would do this for us, as it knows better than we do\n+        // whether unaligned reads are efficient (since that changes between\n+        // different ARM versions, for example) and what the best chunk size\n+        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n+        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n+        // is troublesome because the sides can be aligned differently --\n+        // will be, when the length is odd -- so there's no way of emitting\n+        // pre- and postludes to use fully-aligned SIMD in the middle.)\n+\n+        let fast_unaligned =\n+            cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n+\n+        if fast_unaligned && mem::size_of::<T>() == 1 {\n+            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n+            let chunk = mem::size_of::<usize>();\n+            while i + chunk - 1 < ln / 2 {\n+                unsafe {\n+                    let pa: *mut T = self.get_unchecked_mut(i);\n+                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n+                    let va = ptr::read_unaligned(pa as *mut usize);\n+                    let vb = ptr::read_unaligned(pb as *mut usize);\n+                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n+                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n+                }\n+                i += chunk;\n+            }\n+        }\n+\n+        if fast_unaligned && mem::size_of::<T>() == 2 {\n+            // Use rotate-by-16 to reverse u16s in a u32\n+            let chunk = mem::size_of::<u32>() / 2;\n+            while i + chunk - 1 < ln / 2 {\n+                unsafe {\n+                    let pa: *mut T = self.get_unchecked_mut(i);\n+                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n+                    let va = ptr::read_unaligned(pa as *mut u32);\n+                    let vb = ptr::read_unaligned(pb as *mut u32);\n+                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n+                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n+                }\n+                i += chunk;\n+            }\n+        }\n+\n+        while i < ln / 2 {\n+            // Unsafe swap to avoid the bounds check in safe swap.\n+            unsafe {\n+                let pa: *mut T = self.get_unchecked_mut(i);\n+                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n+                ptr::swap(pa, pb);\n+            }\n+            i += 1;\n+        }\n     }\n \n     /// Returns an iterator over the slice.\n@@ -1145,7 +569,21 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<T> {\n-        SliceExt::iter(self)\n+        unsafe {\n+            let p = if mem::size_of::<T>() == 0 {\n+                1 as *const _\n+            } else {\n+                let p = self.as_ptr();\n+                assume(!p.is_null());\n+                p\n+            };\n+\n+            Iter {\n+                ptr: p,\n+                end: slice_offset!(p, self.len() as isize),\n+                _marker: marker::PhantomData\n+            }\n+        }\n     }\n \n     /// Returns an iterator that allows modifying each value.\n@@ -1162,7 +600,21 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n-        SliceExt::iter_mut(self)\n+        unsafe {\n+            let p = if mem::size_of::<T>() == 0 {\n+                1 as *mut _\n+            } else {\n+                let p = self.as_mut_ptr();\n+                assume(!p.is_null());\n+                p\n+            };\n+\n+            IterMut {\n+                ptr: p,\n+                end: slice_offset!(p, self.len() as isize),\n+                _marker: marker::PhantomData\n+            }\n+        }\n     }\n \n     /// Returns an iterator over all contiguous windows of length\n@@ -1194,7 +646,8 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<T> {\n-        SliceExt::windows(self, size)\n+        assert!(size != 0);\n+        Windows { v: self, size: size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a\n@@ -1224,7 +677,8 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n-        SliceExt::chunks(self, chunk_size)\n+        assert!(chunk_size != 0);\n+        Chunks { v: self, chunk_size: chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a\n@@ -1256,7 +710,10 @@ macro_rules! slice_core_methods { () => {\n     #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n     #[inline]\n     pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n-        SliceExt::exact_chunks(self, chunk_size)\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -1290,7 +747,8 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        SliceExt::chunks_mut(self, chunk_size)\n+        assert!(chunk_size != 0);\n+        ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -1328,7 +786,10 @@ macro_rules! slice_core_methods { () => {\n     #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n     #[inline]\n     pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n-        SliceExt::exact_chunks_mut(self, chunk_size)\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n     }\n \n     /// Divides one slice into two at an index.\n@@ -1367,7 +828,7 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        SliceExt::split_at(self, mid)\n+        (&self[..mid], &self[mid..])\n     }\n \n     /// Divides one mutable slice into two at an index.\n@@ -1397,7 +858,15 @@ macro_rules! slice_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        SliceExt::split_at_mut(self, mid)\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+\n+        unsafe {\n+            assert!(mid <= len);\n+\n+            (from_raw_parts_mut(ptr, mid),\n+             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+        }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1445,7 +914,11 @@ macro_rules! slice_core_methods { () => {\n     pub fn split<F>(&self, pred: F) -> Split<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::split(self, pred)\n+        Split {\n+            v: self,\n+            pred,\n+            finished: false\n+        }\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1466,7 +939,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::split_mut(self, pred)\n+        SplitMut { v: self, pred: pred, finished: false }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1501,7 +974,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::rsplit(self, pred)\n+        RSplit { inner: self.split(pred) }\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1526,7 +999,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::rsplit_mut(self, pred)\n+        RSplitMut { inner: self.split_mut(pred) }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1553,7 +1026,12 @@ macro_rules! slice_core_methods { () => {\n     pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::splitn(self, n, pred)\n+        SplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n\n+            }\n+        }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1578,7 +1056,12 @@ macro_rules! slice_core_methods { () => {\n     pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::splitn_mut(self, n, pred)\n+        SplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n\n+            }\n+        }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1606,7 +1089,12 @@ macro_rules! slice_core_methods { () => {\n     pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::rsplitn(self, n, pred)\n+        RSplitN {\n+            inner: GenericSplitN {\n+                iter: self.rsplit(pred),\n+                count: n\n+            }\n+        }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1632,7 +1120,12 @@ macro_rules! slice_core_methods { () => {\n     pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SliceExt::rsplitn_mut(self, n, pred)\n+        RSplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.rsplit_mut(pred),\n+                count: n\n+            }\n+        }\n     }\n \n     /// Returns `true` if the slice contains an element with the given value.\n@@ -1648,7 +1141,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn contains(&self, x: &T) -> bool\n         where T: PartialEq\n     {\n-        SliceExt::contains(self, x)\n+        x.slice_contains(self)\n     }\n \n     /// Returns `true` if `needle` is a prefix of the slice.\n@@ -1675,7 +1168,8 @@ macro_rules! slice_core_methods { () => {\n     pub fn starts_with(&self, needle: &[T]) -> bool\n         where T: PartialEq\n     {\n-        SliceExt::starts_with(self, needle)\n+        let n = needle.len();\n+        self.len() >= n && needle == &self[..n]\n     }\n \n     /// Returns `true` if `needle` is a suffix of the slice.\n@@ -1702,7 +1196,8 @@ macro_rules! slice_core_methods { () => {\n     pub fn ends_with(&self, needle: &[T]) -> bool\n         where T: PartialEq\n     {\n-        SliceExt::ends_with(self, needle)\n+        let (m, n) = (self.len(), needle.len());\n+        m >= n && needle == &self[m-n..]\n     }\n \n     /// Binary searches this sorted slice for a given element.\n@@ -1731,7 +1226,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n         where T: Ord\n     {\n-        SliceExt::binary_search(self, x)\n+        self.binary_search_by(|p| p.cmp(x))\n     }\n \n     /// Binary searches this sorted slice with a comparator function.\n@@ -1767,10 +1262,29 @@ macro_rules! slice_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n+    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a T) -> Ordering\n     {\n-        SliceExt::binary_search_by(self, f)\n+        let s = self;\n+        let mut size = s.len();\n+        if size == 0 {\n+            return Err(0);\n+        }\n+        let mut base = 0usize;\n+        while size > 1 {\n+            let half = size / 2;\n+            let mid = base + half;\n+            // mid is always in [0, size), that means mid is >= 0 and < size.\n+            // mid >= 0: by definition\n+            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n+            let cmp = f(unsafe { s.get_unchecked(mid) });\n+            base = if cmp == Greater { base } else { mid };\n+            size -= half;\n+        }\n+        // base is always in [0, size) because base <= mid.\n+        let cmp = f(unsafe { s.get_unchecked(base) });\n+        if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n+\n     }\n \n     /// Binary searches this sorted slice with a key extraction function.\n@@ -1805,11 +1319,11 @@ macro_rules! slice_core_methods { () => {\n     /// ```\n     #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n     #[inline]\n-    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a T) -> B,\n               B: Ord\n     {\n-        SliceExt::binary_search_by_key(self, b, f)\n+        self.binary_search_by(|k| f(k).cmp(b))\n     }\n \n     /// Sorts the slice, but may not preserve the order of equal elements.\n@@ -1843,7 +1357,7 @@ macro_rules! slice_core_methods { () => {\n     pub fn sort_unstable(&mut self)\n         where T: Ord\n     {\n-        SliceExt::sort_unstable(self);\n+        sort::quicksort(self, |a, b| a.lt(b));\n     }\n \n     /// Sorts the slice with a comparator function, but may not preserve the order of equal\n@@ -1878,10 +1392,10 @@ macro_rules! slice_core_methods { () => {\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn sort_unstable_by<F>(&mut self, compare: F)\n+    pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n         where F: FnMut(&T, &T) -> Ordering\n     {\n-        SliceExt::sort_unstable_by(self, compare);\n+        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n     }\n \n     /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n@@ -1910,10 +1424,10 @@ macro_rules! slice_core_methods { () => {\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n+    pub fn sort_unstable_by_key<K, F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> K, K: Ord\n     {\n-        SliceExt::sort_unstable_by_key(self, f);\n+        sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n     /// Rotates the slice in-place such that the first `mid` elements of the\n@@ -1948,7 +1462,13 @@ macro_rules! slice_core_methods { () => {\n    /// ```\n     #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n-        SliceExt::rotate_left(self, mid);\n+        assert!(mid <= self.len());\n+        let k = self.len() - mid;\n+\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n+        }\n     }\n \n     /// Rotates the slice in-place such that the first `self.len() - k`\n@@ -1983,7 +1503,13 @@ macro_rules! slice_core_methods { () => {\n     /// ```\n     #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n-        SliceExt::rotate_right(self, k);\n+        assert!(k <= self.len());\n+        let mid = self.len() - k;\n+\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n+        }\n     }\n \n     /// Copies the elements from `src` into `self`.\n@@ -2040,7 +1566,17 @@ macro_rules! slice_core_methods { () => {\n     /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n-        SliceExt::clone_from_slice(self, src)\n+        assert!(self.len() == src.len(),\n+                \"destination and source slices have different lengths\");\n+        // NOTE: We need to explicitly slice them to the same length\n+        // for bounds checking to be elided, and the optimizer will\n+        // generate memcpy for simple cases (for example T = u8).\n+        let len = self.len();\n+        let src = &src[..len];\n+        for i in 0..len {\n+            self[i].clone_from(&src[i]);\n+        }\n+\n     }\n \n     /// Copies all elements from `src` into `self`, using a memcpy.\n@@ -2096,7 +1632,12 @@ macro_rules! slice_core_methods { () => {\n     /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n-        SliceExt::copy_from_slice(self, src)\n+        assert!(self.len() == src.len(),\n+                \"destination and source slices have different lengths\");\n+        unsafe {\n+            ptr::copy_nonoverlapping(\n+                src.as_ptr(), self.as_mut_ptr(), self.len());\n+        }\n     }\n \n     /// Swaps all elements in `self` with those in `other`.\n@@ -2148,22 +1689,18 @@ macro_rules! slice_core_methods { () => {\n     /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n-        SliceExt::swap_with_slice(self, other)\n+        assert!(self.len() == other.len(),\n+                \"destination and source slices have different lengths\");\n+        unsafe {\n+            ptr::swap_nonoverlapping(\n+                self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n+        }\n     }\n-}}\n-\n-#[lang = \"slice\"]\n-#[cfg(not(test))]\n-#[cfg(not(stage0))]\n-impl<T> [T] {\n-    slice_core_methods!();\n }\n \n-// FIXME: remove (inline) this macro\n-// when updating to a bootstrap compiler that has the new lang items.\n-#[cfg_attr(stage0, macro_export)]\n-#[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n-macro_rules! slice_u8_core_methods { () => {\n+#[lang = \"slice_u8\"]\n+#[cfg(not(test))]\n+impl [u8] {\n     /// Checks if all bytes in this slice are within the ASCII range.\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n@@ -2217,13 +1754,7 @@ macro_rules! slice_u8_core_methods { () => {\n             byte.make_ascii_lowercase();\n         }\n     }\n-}}\n \n-#[lang = \"slice_u8\"]\n-#[cfg(not(test))]\n-#[cfg(not(stage0))]\n-impl [u8] {\n-    slice_u8_core_methods!();\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "82bead0ab467699f04025ac1ef8c406d5ac315ff", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 115, "deletions": 475, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -2097,119 +2097,7 @@ mod traits {\n             (..self.end+1).index_mut(slice)\n         }\n     }\n-\n-}\n-\n-public_in_stage0! {\n-{\n-/// Methods for string slices\n-#[allow(missing_docs)]\n-#[doc(hidden)]\n-#[unstable(feature = \"core_str_ext\",\n-           reason = \"stable interface provided by `impl str` in later crates\",\n-           issue = \"32110\")]\n }\n-trait StrExt {\n-    // NB there are no docs here are they're all located on the StrExt trait in\n-    // liballoc, not here.\n-\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn chars(&self) -> Chars;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn bytes(&self) -> Bytes;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn char_indices(&self) -> CharIndices;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn lines(&self) -> Lines;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    #[rustc_deprecated(since = \"1.6.0\", reason = \"use lines() instead now\")]\n-    #[allow(deprecated)]\n-    fn lines_any(&self) -> LinesAny;\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output>;\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output>;\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output;\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>;\n-    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n-    fn is_char_boundary(&self, index: usize) -> bool;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn as_bytes(&self) -> &[u8];\n-    #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-    unsafe fn as_bytes_mut(&mut self) -> &mut [u8];\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>;\n-    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_at(&self, mid: usize) -> (&str, &str);\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn as_ptr(&self) -> *const u8;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn len(&self) -> usize;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn is_empty(&self) -> bool;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n-    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim(&self) -> &str;\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_left(&self) -> &str;\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_right(&self) -> &str;\n-}}\n \n // truncate `&str` to length at most equal to `max`\n // return `true` if it were truncated, and the new str.\n@@ -2255,307 +2143,9 @@ fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n            index, ch, char_range, s_trunc, ellipsis);\n }\n \n-#[stable(feature = \"core\", since = \"1.6.0\")]\n-impl StrExt for str {\n-    #[inline]\n-    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        pat.is_contained_in(self)\n-    }\n-\n-    #[inline]\n-    fn chars(&self) -> Chars {\n-        Chars{iter: self.as_bytes().iter()}\n-    }\n-\n-    #[inline]\n-    fn bytes(&self) -> Bytes {\n-        Bytes(self.as_bytes().iter().cloned())\n-    }\n-\n-    #[inline]\n-    fn char_indices(&self) -> CharIndices {\n-        CharIndices { front_offset: 0, iter: self.chars() }\n-    }\n-\n-    #[inline]\n-    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        Split(SplitInternal {\n-            start: 0,\n-            end: self.len(),\n-            matcher: pat.into_searcher(self),\n-            allow_trailing_empty: true,\n-            finished: false,\n-        })\n-    }\n-\n-    #[inline]\n-    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        RSplit(self.split(pat).0)\n-    }\n-\n-    #[inline]\n-    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        SplitN(SplitNInternal {\n-            iter: self.split(pat).0,\n-            count,\n-        })\n-    }\n-\n-    #[inline]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        RSplitN(self.splitn(count, pat).0)\n-    }\n-\n-    #[inline]\n-    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        SplitTerminator(SplitInternal {\n-            allow_trailing_empty: false,\n-            ..self.split(pat).0\n-        })\n-    }\n-\n-    #[inline]\n-    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        RSplitTerminator(self.split_terminator(pat).0)\n-    }\n-\n-    #[inline]\n-    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        Matches(MatchesInternal(pat.into_searcher(self)))\n-    }\n-\n-    #[inline]\n-    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        RMatches(self.matches(pat).0)\n-    }\n-\n-    #[inline]\n-    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        MatchIndices(MatchIndicesInternal(pat.into_searcher(self)))\n-    }\n-\n-    #[inline]\n-    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        RMatchIndices(self.match_indices(pat).0)\n-    }\n-    #[inline]\n-    fn lines(&self) -> Lines {\n-        Lines(self.split_terminator('\\n').map(LinesAnyMap))\n-    }\n-\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn lines_any(&self) -> LinesAny {\n-        LinesAny(self.lines())\n-    }\n-\n-    #[inline]\n-    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-        i.get(self)\n-    }\n-\n-    #[inline]\n-    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-        i.get_mut(self)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        i.get_unchecked(self)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        i.get_unchecked_mut(self)\n-    }\n-\n-    #[inline]\n-    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        (begin..end).get_unchecked(self)\n-    }\n-\n-    #[inline]\n-    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        (begin..end).get_unchecked_mut(self)\n-    }\n-\n-    #[inline]\n-    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        pat.is_prefix_of(self)\n-    }\n-\n-    #[inline]\n-    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        pat.is_suffix_of(self)\n-    }\n-\n-    #[inline]\n-    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n-    {\n-        let mut i = 0;\n-        let mut j = 0;\n-        let mut matcher = pat.into_searcher(self);\n-        if let Some((a, b)) = matcher.next_reject() {\n-            i = a;\n-            j = b; // Remember earliest known match, correct it below if\n-                   // last match is different\n-        }\n-        if let Some((_, b)) = matcher.next_reject_back() {\n-            j = b;\n-        }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.slice_unchecked(i, j)\n-        }\n-    }\n-\n-    #[inline]\n-    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        let mut i = self.len();\n-        let mut matcher = pat.into_searcher(self);\n-        if let Some((a, _)) = matcher.next_reject() {\n-            i = a;\n-        }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.slice_unchecked(i, self.len())\n-        }\n-    }\n-\n-    #[inline]\n-    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        let mut j = 0;\n-        let mut matcher = pat.into_searcher(self);\n-        if let Some((_, b)) = matcher.next_reject_back() {\n-            j = b;\n-        }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.slice_unchecked(0, j)\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_char_boundary(&self, index: usize) -> bool {\n-        // 0 and len are always ok.\n-        // Test for 0 explicitly so that it can optimize out the check\n-        // easily and skip reading string data for that case.\n-        if index == 0 || index == self.len() { return true; }\n-        match self.as_bytes().get(index) {\n-            None => false,\n-            // This is bit magic equivalent to: b < 128 || b >= 192\n-            Some(&b) => (b as i8) >= -0x40,\n-        }\n-    }\n-\n-    #[inline]\n-    fn as_bytes(&self) -> &[u8] {\n-        unsafe { &*(self as *const str as *const [u8]) }\n-    }\n-\n-    #[inline]\n-    unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        &mut *(self as *mut str as *mut [u8])\n-    }\n-\n-    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        pat.into_searcher(self).next_match().map(|(i, _)| i)\n-    }\n-\n-    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        pat.into_searcher(self).next_match_back().map(|(i, _)| i)\n-    }\n-\n-    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        self.find(pat)\n-    }\n-\n-    #[inline]\n-    fn split_at(&self, mid: usize) -> (&str, &str) {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(mid) {\n-            unsafe {\n-                (self.slice_unchecked(0, mid),\n-                 self.slice_unchecked(mid, self.len()))\n-            }\n-        } else {\n-            slice_error_fail(self, 0, mid)\n-        }\n-    }\n-\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(mid) {\n-            let len = self.len();\n-            let ptr = self.as_ptr() as *mut u8;\n-            unsafe {\n-                (from_raw_parts_mut(ptr, mid),\n-                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n-            }\n-        } else {\n-            slice_error_fail(self, 0, mid)\n-        }\n-    }\n-\n-    #[inline]\n-    fn as_ptr(&self) -> *const u8 {\n-        self as *const str as *const u8\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> usize {\n-        self.as_bytes().len()\n-    }\n-\n-    #[inline]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    #[inline]\n-    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n-\n-    #[inline]\n-    fn split_whitespace(&self) -> SplitWhitespace {\n-        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n-    }\n-\n-    #[inline]\n-    fn trim(&self) -> &str {\n-        self.trim_matches(|c: char| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn trim_left(&self) -> &str {\n-        self.trim_left_matches(|c: char| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn trim_right(&self) -> &str {\n-        self.trim_right_matches(|c: char| c.is_whitespace())\n-    }\n-}\n-\n-// FIXME: remove (inline) this macro and the SliceExt trait\n-// when updating to a bootstrap compiler that has the new lang items.\n-#[cfg_attr(stage0, macro_export)]\n-#[unstable(feature = \"core_str_ext\", issue = \"32110\")]\n-macro_rules! str_core_methods { () => {\n+#[lang = \"str\"]\n+#[cfg(not(test))]\n+impl str {\n     /// Returns the length of `self`.\n     ///\n     /// This length is in bytes, not [`char`]s or graphemes. In other words,\n@@ -2577,7 +2167,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn len(&self) -> usize {\n-        StrExt::len(self)\n+        self.as_bytes().len()\n     }\n \n     /// Returns `true` if `self` has a length of zero bytes.\n@@ -2596,7 +2186,7 @@ macro_rules! str_core_methods { () => {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        StrExt::is_empty(self)\n+        self.len() == 0\n     }\n \n     /// Checks that `index`-th byte lies at the start and/or end of a\n@@ -2626,7 +2216,15 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n     #[inline]\n     pub fn is_char_boundary(&self, index: usize) -> bool {\n-        StrExt::is_char_boundary(self, index)\n+        // 0 and len are always ok.\n+        // Test for 0 explicitly so that it can optimize out the check\n+        // easily and skip reading string data for that case.\n+        if index == 0 || index == self.len() { return true; }\n+        match self.as_bytes().get(index) {\n+            None => false,\n+            // This is bit magic equivalent to: b < 128 || b >= 192\n+            Some(&b) => (b as i8) >= -0x40,\n+        }\n     }\n \n     /// Converts a string slice to a byte slice. To convert the byte slice back\n@@ -2645,7 +2243,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline(always)]\n     pub fn as_bytes(&self) -> &[u8] {\n-        StrExt::as_bytes(self)\n+        unsafe { &*(self as *const str as *const [u8]) }\n     }\n \n     /// Converts a mutable string slice to a mutable byte slice. To convert the\n@@ -2684,7 +2282,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        StrExt::as_bytes_mut(self)\n+        &mut *(self as *mut str as *mut [u8])\n     }\n \n     /// Converts a string slice to a raw pointer.\n@@ -2706,7 +2304,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn as_ptr(&self) -> *const u8 {\n-        StrExt::as_ptr(self)\n+        self as *const str as *const u8\n     }\n \n     /// Returns a subslice of `str`.\n@@ -2733,7 +2331,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-        StrExt::get(self, i)\n+        i.get(self)\n     }\n \n     /// Returns a mutable subslice of `str`.\n@@ -2767,7 +2365,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-        StrExt::get_mut(self, i)\n+        i.get_mut(self)\n     }\n \n     /// Returns a unchecked subslice of `str`.\n@@ -2799,7 +2397,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        StrExt::get_unchecked(self, i)\n+        i.get_unchecked(self)\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2831,7 +2429,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        StrExt::get_unchecked_mut(self, i)\n+        i.get_unchecked_mut(self)\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2880,7 +2478,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        StrExt::slice_unchecked(self, begin, end)\n+        (begin..end).get_unchecked(self)\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2910,7 +2508,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        StrExt::slice_mut_unchecked(self, begin, end)\n+        (begin..end).get_unchecked_mut(self)\n     }\n \n     /// Divide one string slice into two at an index.\n@@ -2946,7 +2544,15 @@ macro_rules! str_core_methods { () => {\n     #[inline]\n     #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n-        StrExt::split_at(self, mid)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(mid) {\n+            unsafe {\n+                (self.slice_unchecked(0, mid),\n+                 self.slice_unchecked(mid, self.len()))\n+            }\n+        } else {\n+            slice_error_fail(self, 0, mid)\n+        }\n     }\n \n     /// Divide one mutable string slice into two at an index.\n@@ -2983,7 +2589,17 @@ macro_rules! str_core_methods { () => {\n     #[inline]\n     #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n     pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n-        StrExt::split_at_mut(self, mid)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(mid) {\n+            let len = self.len();\n+            let ptr = self.as_ptr() as *mut u8;\n+            unsafe {\n+                (from_raw_parts_mut(ptr, mid),\n+                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+            }\n+        } else {\n+            slice_error_fail(self, 0, mid)\n+        }\n     }\n \n     /// Returns an iterator over the [`char`]s of a string slice.\n@@ -3035,8 +2651,9 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chars(&self) -> Chars {\n-        StrExt::chars(self)\n+        Chars{iter: self.as_bytes().iter()}\n     }\n+\n     /// Returns an iterator over the [`char`]s of a string slice, and their\n     /// positions.\n     ///\n@@ -3091,7 +2708,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn char_indices(&self) -> CharIndices {\n-        StrExt::char_indices(self)\n+        CharIndices { front_offset: 0, iter: self.chars() }\n     }\n \n     /// An iterator over the bytes of a string slice.\n@@ -3116,7 +2733,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn bytes(&self) -> Bytes {\n-        StrExt::bytes(self)\n+        Bytes(self.as_bytes().iter().cloned())\n     }\n \n     /// Split a string slice by whitespace.\n@@ -3156,7 +2773,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     #[inline]\n     pub fn split_whitespace(&self) -> SplitWhitespace {\n-        StrExt::split_whitespace(self)\n+        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n     /// An iterator over the lines of a string, as string slices.\n@@ -3198,7 +2815,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn lines(&self) -> Lines {\n-        StrExt::lines(self)\n+        Lines(self.split_terminator('\\n').map(LinesAnyMap))\n     }\n \n     /// An iterator over the lines of a string.\n@@ -3207,7 +2824,7 @@ macro_rules! str_core_methods { () => {\n     #[inline]\n     #[allow(deprecated)]\n     pub fn lines_any(&self) -> LinesAny {\n-        StrExt::lines_any(self)\n+        LinesAny(self.lines())\n     }\n \n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n@@ -3226,7 +2843,7 @@ macro_rules! str_core_methods { () => {\n     /// ```\n     #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n     pub fn encode_utf16(&self) -> EncodeUtf16 {\n-        EncodeUtf16::new(self)\n+        EncodeUtf16 { chars: self.chars(), extra: 0 }\n     }\n \n     /// Returns `true` if the given pattern matches a sub-slice of\n@@ -3247,7 +2864,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        StrExt::contains(self, pat)\n+        pat.is_contained_in(self)\n     }\n \n     /// Returns `true` if the given pattern matches a prefix of this\n@@ -3267,7 +2884,7 @@ macro_rules! str_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        StrExt::starts_with(self, pat)\n+        pat.is_prefix_of(self)\n     }\n \n     /// Returns `true` if the given pattern matches a suffix of this\n@@ -3289,7 +2906,7 @@ macro_rules! str_core_methods { () => {\n     pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::ends_with(self, pat)\n+        pat.is_suffix_of(self)\n     }\n \n     /// Returns the byte index of the first character of this string slice that\n@@ -3337,7 +2954,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        StrExt::find(self, pat)\n+        pat.into_searcher(self).next_match().map(|(i, _)| i)\n     }\n \n     /// Returns the byte index of the last character of this string slice that\n@@ -3384,7 +3001,7 @@ macro_rules! str_core_methods { () => {\n     pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::rfind(self, pat)\n+        pat.into_searcher(self).next_match_back().map(|(i, _)| i)\n     }\n \n     /// An iterator over substrings of this string slice, separated by\n@@ -3496,7 +3113,13 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        StrExt::split(self, pat)\n+        Split(SplitInternal {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_trailing_empty: true,\n+            finished: false,\n+        })\n     }\n \n     /// An iterator over substrings of the given string slice, separated by\n@@ -3548,7 +3171,7 @@ macro_rules! str_core_methods { () => {\n     pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::rsplit(self, pat)\n+        RSplit(self.split(pat).0)\n     }\n \n     /// An iterator over substrings of the given string slice, separated by\n@@ -3593,7 +3216,10 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        StrExt::split_terminator(self, pat)\n+        SplitTerminator(SplitInternal {\n+            allow_trailing_empty: false,\n+            ..self.split(pat).0\n+        })\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -3639,7 +3265,7 @@ macro_rules! str_core_methods { () => {\n     pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::rsplit_terminator(self, pat)\n+        RSplitTerminator(self.split_terminator(pat).0)\n     }\n \n     /// An iterator over substrings of the given string slice, separated by a\n@@ -3690,7 +3316,10 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n-        StrExt::splitn(self, n, pat)\n+        SplitN(SplitNInternal {\n+            iter: self.split(pat).0,\n+            count: n,\n+        })\n     }\n \n     /// An iterator over substrings of this string slice, separated by a\n@@ -3740,7 +3369,7 @@ macro_rules! str_core_methods { () => {\n     pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::rsplitn(self, n, pat)\n+        RSplitN(self.splitn(n, pat).0)\n     }\n \n     /// An iterator over the disjoint matches of a pattern within the given string\n@@ -3779,7 +3408,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n     #[inline]\n     pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        StrExt::matches(self, pat)\n+        Matches(MatchesInternal(pat.into_searcher(self)))\n     }\n \n     /// An iterator over the disjoint matches of a pattern within this string slice,\n@@ -3818,7 +3447,7 @@ macro_rules! str_core_methods { () => {\n     pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::rmatches(self, pat)\n+        RMatches(self.matches(pat).0)\n     }\n \n     /// An iterator over the disjoint matches of a pattern within this string\n@@ -3862,7 +3491,7 @@ macro_rules! str_core_methods { () => {\n     #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n     #[inline]\n     pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        StrExt::match_indices(self, pat)\n+        MatchIndices(MatchIndicesInternal(pat.into_searcher(self)))\n     }\n \n     /// An iterator over the disjoint matches of a pattern within `self`,\n@@ -3907,7 +3536,7 @@ macro_rules! str_core_methods { () => {\n     pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::rmatch_indices(self, pat)\n+        RMatchIndices(self.match_indices(pat).0)\n     }\n \n     /// Returns a string slice with leading and trailing whitespace removed.\n@@ -3926,7 +3555,7 @@ macro_rules! str_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim(&self) -> &str {\n-        StrExt::trim(self)\n+        self.trim_matches(|c: char| c.is_whitespace())\n     }\n \n     /// Returns a string slice with leading whitespace removed.\n@@ -3962,7 +3591,7 @@ macro_rules! str_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_left(&self) -> &str {\n-        StrExt::trim_left(self)\n+        self.trim_left_matches(|c: char| c.is_whitespace())\n     }\n \n     /// Returns a string slice with trailing whitespace removed.\n@@ -3998,7 +3627,7 @@ macro_rules! str_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_right(&self) -> &str {\n-        StrExt::trim_right(self)\n+        self.trim_right_matches(|c: char| c.is_whitespace())\n     }\n \n     /// Returns a string slice with all prefixes and suffixes that match a\n@@ -4030,7 +3659,21 @@ macro_rules! str_core_methods { () => {\n     pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: DoubleEndedSearcher<'a>\n     {\n-        StrExt::trim_matches(self, pat)\n+        let mut i = 0;\n+        let mut j = 0;\n+        let mut matcher = pat.into_searcher(self);\n+        if let Some((a, b)) = matcher.next_reject() {\n+            i = a;\n+            j = b; // Remember earliest known match, correct it below if\n+                   // last match is different\n+        }\n+        if let Some((_, b)) = matcher.next_reject_back() {\n+            j = b;\n+        }\n+        unsafe {\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(i, j)\n+        }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -4061,7 +3704,15 @@ macro_rules! str_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        StrExt::trim_left_matches(self, pat)\n+        let mut i = self.len();\n+        let mut matcher = pat.into_searcher(self);\n+        if let Some((a, _)) = matcher.next_reject() {\n+            i = a;\n+        }\n+        unsafe {\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(i, self.len())\n+        }\n     }\n \n     /// Returns a string slice with all suffixes that match a pattern\n@@ -4100,7 +3751,15 @@ macro_rules! str_core_methods { () => {\n     pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        StrExt::trim_right_matches(self, pat)\n+        let mut j = 0;\n+        let mut matcher = pat.into_searcher(self);\n+        if let Some((_, b)) = matcher.next_reject_back() {\n+            j = b;\n+        }\n+        unsafe {\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(0, j)\n+        }\n     }\n \n     /// Parses this string slice into another type.\n@@ -4150,7 +3809,7 @@ macro_rules! str_core_methods { () => {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        StrExt::parse(self)\n+        FromStr::from_str(self)\n     }\n \n     /// Checks if all characters in this string are within the ASCII range.\n@@ -4220,16 +3879,8 @@ macro_rules! str_core_methods { () => {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n-}}\n-\n-#[lang = \"str\"]\n-#[cfg(not(test))]\n-#[cfg(not(stage0))]\n-impl str {\n-    str_core_methods!();\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<[u8]> for str {\n     #[inline]\n@@ -4332,17 +3983,6 @@ pub struct EncodeUtf16<'a> {\n     extra: u16,\n }\n \n-// FIXME: remove (inline) this method\n-// when updating to a bootstrap compiler that has the new lang items.\n-// For grepping purpose: #[cfg(stage0)]\n-impl<'a> EncodeUtf16<'a> {\n-    #[unstable(feature = \"core_str_ext\", issue = \"32110\")]\n-    #[doc(hidden)]\n-    pub fn new(s: &'a str) -> Self {\n-        EncodeUtf16 { chars: s.chars(), extra: 0 }\n-    }\n-}\n-\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<'a> fmt::Debug for EncodeUtf16<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "8c481338945ff870d12b087ff2bf39f5626e848f", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -41,7 +41,6 @@\n #![feature(try_from)]\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n-#![cfg_attr(stage0, feature(atomic_nand))]\n #![feature(reverse_bits)]\n #![feature(inclusive_range_methods)]\n #![feature(iterator_find_map)]"}, {"sha": "ca6906f731047c62e0091c3a3212756cff2b5c23", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -98,7 +98,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(stage0))]\n     fn test_reverse_bits() {\n         assert_eq!(A.reverse_bits().reverse_bits(), A);\n         assert_eq!(B.reverse_bits().reverse_bits(), B);"}, {"sha": "bbd684982fa41133e2e5db23a9859860b82122af", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -46,7 +46,6 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(entry_or_default)]\n-#![cfg_attr(stage0, feature(dyn_trait))]\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n #![feature(iterator_find_map)]"}, {"sha": "a162ef36a6054669e0da2992c59f257d1c14a542", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -240,11 +240,11 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     });\n \n     // Also dump the inference graph constraints as a graphviz file.\n-    let _: io::Result<()> = do_catch! {{\n+    let _: io::Result<()> = do catch {\n         let mut file =\n             pretty::create_dump_file(infcx.tcx, \"regioncx.dot\", None, \"nll\", &0, source)?;\n         regioncx.dump_graphviz(&mut file)?;\n-    }};\n+    };\n }\n \n fn dump_annotation<'a, 'gcx, 'tcx>("}, {"sha": "d9b6c406e2012367464b67d99ab0db59ddc56bbe", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -24,7 +24,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n-#![cfg_attr(stage0, feature(dyn_trait))]\n #![feature(fs_read_write)]\n #![feature(macro_vis_matcher)]\n #![feature(exhaustive_patterns)]\n@@ -34,7 +33,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![feature(specialization)]\n-#![cfg_attr(stage0, feature(try_trait))]\n+#![feature(try_trait)]\n \n extern crate arena;\n #[macro_use]\n@@ -54,16 +53,6 @@ extern crate log_settings;\n extern crate rustc_apfloat;\n extern crate byteorder;\n \n-#[cfg(stage0)]\n-macro_rules! do_catch {\n-  ($t:expr) => { (|| ::std::ops::Try::from_ok($t) )() }\n-}\n-\n-#[cfg(not(stage0))]\n-macro_rules! do_catch {\n-  ($t:expr) => { do catch { $t } }\n-}\n-\n mod diagnostics;\n \n mod borrow_check;"}, {"sha": "9e1ce9b2851dea4f01e813acfcb721c8b7dd8d58", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -137,7 +137,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n-    let _: io::Result<()> = do_catch! {{\n+    let _: io::Result<()> = do catch {\n         let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, source)?;\n         writeln!(file, \"// MIR for `{}`\", node_path)?;\n         writeln!(file, \"// source = {:?}\", source)?;\n@@ -150,14 +150,14 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n         extra_data(PassWhere::BeforeCFG, &mut file)?;\n         write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n         extra_data(PassWhere::AfterCFG, &mut file)?;\n-    }};\n+    };\n \n     if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n-        let _: io::Result<()> = do_catch! {{\n+        let _: io::Result<()> = do catch {\n             let mut file =\n                 create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, source)?;\n             write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n-        }};\n+        };\n     }\n }\n "}, {"sha": "ef79517d06a4577f936f354035ecf0381687ae6a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -71,8 +71,6 @@ This API is completely unstable and subject to change.\n \n #![allow(non_camel_case_types)]\n \n-#![cfg_attr(stage0, feature(dyn_trait))]\n-\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "e4b80b13aec2a04ac07c4fa422c0911ca797db4a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -13,8 +13,6 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n \n-#![cfg_attr(stage0, feature(dyn_trait))]\n-\n #![feature(ascii_ctype)]\n #![feature(rustc_private)]\n #![feature(box_patterns)]"}, {"sha": "78d3d6d5e60cc6e4a3b4c895ed41664d34f48ff6", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -17,7 +17,6 @@\n #[doc(inline)] pub use alloc_system::System;\n #[doc(inline)] pub use core::alloc::*;\n \n-#[cfg(not(stage0))]\n #[cfg(not(test))]\n #[doc(hidden)]\n #[lang = \"oom\"]\n@@ -43,13 +42,6 @@ pub mod __default_lib_allocator {\n         System.alloc(layout) as *mut u8\n     }\n \n-    #[cfg(stage0)]\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_oom() -> ! {\n-        super::oom()\n-    }\n-\n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n@@ -74,57 +66,4 @@ pub mod __default_lib_allocator {\n         let layout = Layout::from_size_align_unchecked(size, align);\n         System.alloc_zeroed(layout) as *mut u8\n     }\n-\n-    #[cfg(stage0)]\n-    pub mod stage0 {\n-        #[no_mangle]\n-        #[rustc_std_internal_symbol]\n-        pub unsafe extern fn __rdl_usable_size(_layout: *const u8,\n-                                               _min: *mut usize,\n-                                               _max: *mut usize) {\n-            unimplemented!()\n-        }\n-\n-        #[no_mangle]\n-        #[rustc_std_internal_symbol]\n-        pub unsafe extern fn __rdl_alloc_excess(_size: usize,\n-                                                _align: usize,\n-                                                _excess: *mut usize,\n-                                                _err: *mut u8) -> *mut u8 {\n-            unimplemented!()\n-        }\n-\n-        #[no_mangle]\n-        #[rustc_std_internal_symbol]\n-        pub unsafe extern fn __rdl_realloc_excess(_ptr: *mut u8,\n-                                                  _old_size: usize,\n-                                                  _old_align: usize,\n-                                                  _new_size: usize,\n-                                                  _new_align: usize,\n-                                                  _excess: *mut usize,\n-                                                  _err: *mut u8) -> *mut u8 {\n-            unimplemented!()\n-        }\n-\n-        #[no_mangle]\n-        #[rustc_std_internal_symbol]\n-        pub unsafe extern fn __rdl_grow_in_place(_ptr: *mut u8,\n-                                                 _old_size: usize,\n-                                                 _old_align: usize,\n-                                                 _new_size: usize,\n-                                                 _new_align: usize) -> u8 {\n-            unimplemented!()\n-        }\n-\n-        #[no_mangle]\n-        #[rustc_std_internal_symbol]\n-        pub unsafe extern fn __rdl_shrink_in_place(_ptr: *mut u8,\n-                                                   _old_size: usize,\n-                                                   _old_align: usize,\n-                                                   _new_size: usize,\n-                                                   _new_align: usize) -> u8 {\n-            unimplemented!()\n-        }\n-\n-    }\n }"}, {"sha": "ae30321f46dfca4ed02c039e88b7ce28028c62d5", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -18,15 +18,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[cfg(not(test))]\n-#[cfg(stage0)]\n-use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-#[cfg(stage0)]\n-use num::FpCategory;\n-#[cfg(not(test))]\n use sys::cmath;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -41,12 +35,8 @@ pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n \n #[cfg(not(test))]\n-#[cfg_attr(stage0, lang = \"f32\")]\n-#[cfg_attr(not(stage0), lang = \"f32_runtime\")]\n+#[lang = \"f32_runtime\"]\n impl f32 {\n-    #[cfg(stage0)]\n-    f32_core_methods!();\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// # Examples"}, {"sha": "7950d434b77e67a5c7302fdafc42c855965e0527", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -18,15 +18,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[cfg(not(test))]\n-#[cfg(stage0)]\n-use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-#[cfg(stage0)]\n-use num::FpCategory;\n-#[cfg(not(test))]\n use sys::cmath;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -41,12 +35,8 @@ pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n \n #[cfg(not(test))]\n-#[cfg_attr(stage0, lang = \"f64\")]\n-#[cfg_attr(not(stage0), lang = \"f64_runtime\")]\n+#[lang = \"f64_runtime\"]\n impl f64 {\n-    #[cfg(stage0)]\n-    f64_core_methods!();\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// # Examples"}, {"sha": "f7d06852f27937f61ef7e9beea6083f118a1bb87", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -252,18 +252,15 @@\n #![feature(collections_range)]\n #![feature(compiler_builtins_lib)]\n #![feature(const_fn)]\n-#![cfg_attr(stage0, feature(core_float))]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(external_doc)]\n #![feature(fs_read_write)]\n #![feature(fixed_size_array)]\n #![feature(float_from_str_radix)]\n-#![cfg_attr(stage0, feature(float_internals))]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n-#![cfg_attr(stage0, feature(generic_param_attrs))]\n #![feature(hashmap_internals)]\n #![feature(heap_api)]\n #![feature(int_error_internals)]\n@@ -319,6 +316,7 @@\n #![cfg_attr(test, feature(update_panic_count))]\n #![cfg_attr(windows, feature(used))]\n #![feature(doc_alias)]\n+#![feature(float_internals)]\n \n #![default_lib_allocator]\n \n@@ -364,11 +362,6 @@ extern crate libc;\n #[allow(unused_extern_crates)]\n extern crate unwind;\n \n-// compiler-rt intrinsics\n-#[doc(masked)]\n-#[cfg(stage0)]\n-extern crate compiler_builtins;\n-\n // During testing, this crate is not actually the \"real\" std library, but rather\n // it links to the real std library, which was compiled from this same source\n // code. So any lang items std defines are conditionally excluded (or else they"}, {"sha": "dd8f79d20abda429638cfc6f2cdce96b7430bdb1", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -45,17 +45,6 @@ impl State {\n     }\n }\n \n-macro_rules! span_err_if_not_stage0 {\n-    ($cx:expr, $sp:expr, $code:ident, $text:tt) => {\n-        #[cfg(not(stage0))] {\n-            span_err!($cx, $sp, $code, $text)\n-        }\n-        #[cfg(stage0)] {\n-            $cx.span_err($sp, $text)\n-        }\n-    }\n-}\n-\n const OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n@@ -100,7 +89,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 if asm_str_style.is_some() {\n                     // If we already have a string with instructions,\n                     // ending up in Asm state again is an error.\n-                    span_err_if_not_stage0!(cx, sp, E0660, \"malformed inline assembly\");\n+                    span_err!(cx, sp, E0660, \"malformed inline assembly\");\n                     return DummyResult::expr(sp);\n                 }\n                 // Nested parser, stop before the first colon (see above).\n@@ -153,7 +142,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                             Some(Symbol::intern(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n-                            span_err_if_not_stage0!(cx, span, E0661,\n+                            span_err!(cx, span, E0661,\n                                                     \"output operand constraint lacks '=' or '+'\");\n                             None\n                         }\n@@ -179,10 +168,10 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     let (constraint, _str_style) = panictry!(p.parse_str());\n \n                     if constraint.as_str().starts_with(\"=\") {\n-                        span_err_if_not_stage0!(cx, p.prev_span, E0662,\n+                        span_err!(cx, p.prev_span, E0662,\n                                                 \"input operand constraint contains '='\");\n                     } else if constraint.as_str().starts_with(\"+\") {\n-                        span_err_if_not_stage0!(cx, p.prev_span, E0663,\n+                        span_err!(cx, p.prev_span, E0663,\n                                                 \"input operand constraint contains '+'\");\n                     }\n \n@@ -205,7 +194,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n                     } else if s.as_str().starts_with(\"{\") || s.as_str().ends_with(\"}\") {\n-                        span_err_if_not_stage0!(cx, p.prev_span, E0664,\n+                        span_err!(cx, p.prev_span, E0664,\n                                                 \"clobber should not be surrounded by braces\");\n                     }\n "}, {"sha": "e100ef292253b01ac452eb86df363cc704bc8b34", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -18,7 +18,7 @@\n #![feature(decl_macro)]\n #![feature(str_escape)]\n \n-#![cfg_attr(not(stage0), feature(rustc_diagnostic_macros))]\n+#![feature(rustc_diagnostic_macros)]\n \n extern crate fmt_macros;\n #[macro_use]\n@@ -29,7 +29,6 @@ extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_target;\n \n-#[cfg(not(stage0))]\n mod diagnostics;\n \n mod assert;"}, {"sha": "8ff401164c1353e7f4088bd485fefe12b30a06e0", "filename": "src/rtstartup/rsbegin.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -23,7 +23,7 @@\n // of other runtime components (registered via yet another special image section).\n \n #![feature(no_core, lang_items, optin_builtin_traits)]\n-#![crate_type=\"rlib\"]\n+#![crate_type = \"rlib\"]\n #![no_core]\n #![allow(non_camel_case_types)]\n \n@@ -43,7 +43,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     drop_in_place(to_drop);\n }\n \n-#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+#[cfg(all(target_os = \"windows\", target_arch = \"x86\", target_env = \"gnu\"))]\n pub mod eh_frames {\n     #[no_mangle]\n     #[link_section = \".eh_frame\"]\n@@ -54,6 +54,21 @@ pub mod eh_frames {\n     // This is defined as `struct object` in $GCC/libgcc/unwind-dw2-fde.h.\n     static mut OBJ: [isize; 6] = [0; 6];\n \n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                impl ::Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n     // Unwind info registration/deregistration routines.\n     // See the docs of `unwind` module in libstd.\n     extern \"C\" {\n@@ -63,14 +78,18 @@ pub mod eh_frames {\n \n     unsafe fn init() {\n         // register unwind info on module startup\n-        rust_eh_register_frames(&__EH_FRAME_BEGIN__ as *const u8,\n-                                &mut OBJ as *mut _ as *mut u8);\n+        rust_eh_register_frames(\n+            &__EH_FRAME_BEGIN__ as *const u8,\n+            &mut OBJ as *mut _ as *mut u8,\n+        );\n     }\n \n     unsafe fn uninit() {\n         // unregister on shutdown\n-        rust_eh_unregister_frames(&__EH_FRAME_BEGIN__ as *const u8,\n-                                  &mut OBJ as *mut _ as *mut u8);\n+        rust_eh_unregister_frames(\n+            &__EH_FRAME_BEGIN__ as *const u8,\n+            &mut OBJ as *mut _ as *mut u8,\n+        );\n     }\n \n     // MSVC-specific init/uninit routine registration"}, {"sha": "435cfd2f6db4eb4752d593e27c108cf759b1b4d8", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9e3432447a9c6386443acdf731d488c159be3f66/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=9e3432447a9c6386443acdf731d488c159be3f66", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2018-04-24\n+date: 2018-05-10\n rustc: beta\n cargo: beta\n "}]}