{"sha": "05f1a057b6e59fd07b4af7a9a2f0101d67faba88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZjFhMDU3YjZlNTlmZDA3YjRhZjdhOWEyZjAxMDFkNjdmYWJhODg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-04-22T13:38:17Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-03T15:30:10Z"}, "message": "address review comments", "tree": {"sha": "89b72843e31fc98ae1670741e197dfc29ed37cf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89b72843e31fc98ae1670741e197dfc29ed37cf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f1a057b6e59fd07b4af7a9a2f0101d67faba88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f1a057b6e59fd07b4af7a9a2f0101d67faba88", "html_url": "https://github.com/rust-lang/rust/commit/05f1a057b6e59fd07b4af7a9a2f0101d67faba88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f1a057b6e59fd07b4af7a9a2f0101d67faba88/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc19ada6b2c6373b28e70a1dffda68dba96f9a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc19ada6b2c6373b28e70a1dffda68dba96f9a1", "html_url": "https://github.com/rust-lang/rust/commit/6fc19ada6b2c6373b28e70a1dffda68dba96f9a1"}], "stats": {"total": 165, "additions": 83, "deletions": 82}, "files": [{"sha": "a61e8603dbbe47fa91ddb2b511ff78a913eba60c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 75, "deletions": 81, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/05f1a057b6e59fd07b4af7a9a2f0101d67faba88/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f1a057b6e59fd07b4af7a9a2f0101d67faba88/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=05f1a057b6e59fd07b4af7a9a2f0101d67faba88", "patch": "@@ -1750,28 +1750,69 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n }\n \n impl<'tcx> AdtDefData<'tcx, 'tcx> {\n-    fn sized_constraint_for_tys<TYS>(\n-        &'tcx self,\n-        tcx: &ty::TyCtxt<'tcx>,\n-        stack: &mut Vec<AdtDefMaster<'tcx>>,\n-        tys: TYS\n-    ) -> Ty<'tcx>\n-        where TYS: IntoIterator<Item=Ty<'tcx>>\n+    /// Calculates the Sized-constraint.\n+    ///\n+    /// As the Sized-constraint of enums can be a *set* of types,\n+    /// the Sized-constraint may need to be a set also. Because introducing\n+    /// a new type of IVar is currently a complex affair, the Sized-constraint\n+    /// may be a tuple.\n+    ///\n+    /// In fact, there are only a few options for the constraint:\n+    ///     - `bool`, if the type is always Sized\n+    ///     - an obviously-unsized type\n+    ///     - a type parameter or projection whose Sizedness can't be known\n+    ///     - a tuple of type parameters or projections, if there are multiple\n+    ///       such.\n+    ///     - a TyError, if a type contained itself. The representability\n+    ///       check should catch this case.\n+    fn calculate_sized_constraint_inner(&'tcx self, tcx: &ty::TyCtxt<'tcx>,\n+                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n-        let tys : Vec<_> = tys.into_iter()\n-            .map(|ty| self.sized_constraint_for_ty(tcx, stack, ty))\n-            .flat_map(|ty| match ty.sty {\n-                ty::TyTuple(ref tys) => tys.last().cloned(),\n-                _ => Some(ty)\n-            })\n-            .filter(|ty| *ty != tcx.types.bool)\n-            .collect();\n-\n-        match tys.len() {\n+\n+        let dep_node = DepNode::SizedConstraint(self.did);\n+\n+        if self.sized_constraint.get(dep_node).is_some() {\n+            return;\n+        }\n+\n+        if stack.contains(&self) {\n+            debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n+            // This should be reported as an error by `check_representable`.\n+            //\n+            // Consider the type as Sized in the meanwhile to avoid\n+            // further errors.\n+            self.sized_constraint.fulfill(dep_node, tcx.types.err);\n+            return;\n+        }\n+\n+        stack.push(self);\n+\n+        let tys : Vec<_> =\n+            self.variants.iter().flat_map(|v| {\n+                v.fields.last()\n+            }).flat_map(|f| {\n+                self.sized_constraint_for_ty(tcx, stack, f.unsubst_ty())\n+            }).collect();\n+\n+        let self_ = stack.pop().unwrap();\n+        assert_eq!(self_, self);\n+\n+        let ty = match tys.len() {\n             _ if tys.references_error() => tcx.types.err,\n             0 => tcx.types.bool,\n             1 => tys[0],\n             _ => tcx.mk_tup(tys)\n+        };\n+\n+        match self.sized_constraint.get(dep_node) {\n+            Some(old_ty) => {\n+                debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n+                assert_eq!(old_ty, tcx.types.err)\n+            }\n+            None => {\n+                debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n+                self.sized_constraint.fulfill(dep_node, ty)\n+            }\n         }\n     }\n \n@@ -1780,22 +1821,23 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n         tcx: &ty::TyCtxt<'tcx>,\n         stack: &mut Vec<AdtDefMaster<'tcx>>,\n         ty: Ty<'tcx>\n-    ) -> Ty<'tcx> {\n+    ) -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyClosure(..) => {\n-                // these are always sized - return a primitive\n-                tcx.types.bool\n+                vec![]\n             }\n \n             TyStr | TyTrait(..) | TySlice(_) | TyError => {\n                 // these are never sized - return the target type\n-                ty\n+                vec![ty]\n             }\n \n             TyTuple(ref tys) => {\n-                self.sized_constraint_for_tys(tcx, stack, tys.iter().cloned())\n+                tys.last().into_iter().flat_map(|ty| {\n+                    self.sized_constraint_for_ty(tcx, stack, ty)\n+                }).collect()\n             }\n \n             TyEnum(adt, substs) | TyStruct(adt, substs) => {\n@@ -1808,13 +1850,19 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n                     .subst(tcx, substs);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_ty);\n-                self.sized_constraint_for_ty(tcx, stack, adt_ty)\n+                if let ty::TyTuple(ref tys) = adt_ty.sty {\n+                    tys.iter().flat_map(|ty| {\n+                        self.sized_constraint_for_ty(tcx, stack, ty)\n+                    }).collect()\n+                } else {\n+                    self.sized_constraint_for_ty(tcx, stack, adt_ty)\n+                }\n             }\n \n             TyProjection(..) => {\n                 // must calculate explicitly.\n                 // FIXME: consider special-casing always-Sized projections\n-                ty\n+                vec![ty]\n             }\n \n             TyParam(..) => {\n@@ -1824,7 +1872,7 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n \n                 let sized_trait = match tcx.lang_items.sized_trait() {\n                     Some(x) => x,\n-                    _ => return ty\n+                    _ => return vec![ty]\n                 };\n                 let sized_predicate = Binder(TraitRef {\n                     def_id: sized_trait,\n@@ -1834,9 +1882,9 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n                 }).to_predicate();\n                 let predicates = tcx.lookup_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n-                    tcx.types.bool\n+                    vec![]\n                 } else {\n-                    ty\n+                    vec![ty]\n                 }\n             }\n \n@@ -1848,60 +1896,6 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n         debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n         result\n     }\n-\n-    /// Calculates the Sized-constraint.\n-    ///\n-    /// As the Sized-constraint of enums can be a *set* of types,\n-    /// the Sized-constraint may need to be a set also. Because introducing\n-    /// a new type of IVar is currently a complex affair, the Sized-constraint\n-    /// may be a tuple.\n-    ///\n-    /// In fact, there are only a few options for the constraint:\n-    ///     - `bool`, if the type is always Sized\n-    ///     - an obviously-unsized type\n-    ///     - a type parameter or projection whose Sizedness can't be known\n-    ///     - a tuple of type parameters or projections, if there are multiple\n-    ///       such.\n-    ///     - a TyError, if a type contained itself. The representability\n-    ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self, tcx: &ty::TyCtxt<'tcx>,\n-                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n-    {\n-\n-        let dep_node = DepNode::SizedConstraint(self.did);\n-\n-        if self.sized_constraint.get(dep_node).is_some() {\n-            return;\n-        }\n-\n-        if stack.contains(&self) {\n-            debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n-            self.sized_constraint.fulfill(dep_node, tcx.types.err);\n-            return;\n-        }\n-\n-        stack.push(self);\n-        let ty = self.sized_constraint_for_tys(\n-            tcx, stack,\n-            self.variants.iter().flat_map(|v| {\n-                v.fields.last()\n-            }).map(|f| f.unsubst_ty())\n-        );\n-\n-        let self_ = stack.pop().unwrap();\n-        assert_eq!(self_, self);\n-\n-        match self.sized_constraint.get(dep_node) {\n-            Some(old_ty) => {\n-                debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n-                assert_eq!(old_ty, tcx.types.err)\n-            }\n-            None => {\n-                debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                self.sized_constraint.fulfill(dep_node, ty)\n-            }\n-        }\n-    }\n }\n \n impl<'tcx, 'container> VariantDefData<'tcx, 'container> {"}, {"sha": "6c04e66068e60b5547dc1021005227e18c28cbea", "filename": "src/test/run-pass/issue-31299.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05f1a057b6e59fd07b4af7a9a2f0101d67faba88/src%2Ftest%2Frun-pass%2Fissue-31299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f1a057b6e59fd07b4af7a9a2f0101d67faba88/src%2Ftest%2Frun-pass%2Fissue-31299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-31299.rs?ref=05f1a057b6e59fd07b4af7a9a2f0101d67faba88", "patch": "@@ -12,12 +12,19 @@\n // because of eager normalization:\n //\n // proving `M: Sized` requires\n-// - proving `PtrBack<Vec<M>>: Sized` requis\n+// - proving `PtrBack<Vec<M>>: Sized` requires\n //   - normalizing `Vec<<Vec<M> as Front>::Back>>: Sized` requires\n //     - proving `Vec<M>: Front` requires\n //       - `M: Sized` <-- cycle!\n //\n // If we skip the normalization step, though, everything goes fine.\n+//\n+// This could be fixed by implementing lazy normalization everywhere.\n+//\n+// However, we want this to work before then. For that, when checking\n+// whether a type is Sized we only check that the tails are Sized. As\n+// PtrBack does not have a tail, we don't need to normalize anything\n+// and this compiles\n \n trait Front {\n     type Back;"}]}