{"sha": "b0d31707cc849bd385ae8677823d1f2bcc8aba41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZDMxNzA3Y2M4NDliZDM4NWFlODY3NzgyM2QxZjJiY2M4YWJhNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-01T08:46:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-01T08:46:06Z"}, "message": "Auto merge of #32643 - Amanieu:arc_compare_exchange, r=alexcrichton\n\nChange Arc to use compare_exchange instead of compare_and_swap\n\nThis should slightly improve code generation on architectures with a weak memory model like ARM.", "tree": {"sha": "d368a3f3284a3d7bb932bf6745deb0f279ea2387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d368a3f3284a3d7bb932bf6745deb0f279ea2387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0d31707cc849bd385ae8677823d1f2bcc8aba41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0d31707cc849bd385ae8677823d1f2bcc8aba41", "html_url": "https://github.com/rust-lang/rust/commit/b0d31707cc849bd385ae8677823d1f2bcc8aba41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0d31707cc849bd385ae8677823d1f2bcc8aba41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53498eca50e25d8a11f9dc5859770715fa906fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/53498eca50e25d8a11f9dc5859770715fa906fa7", "html_url": "https://github.com/rust-lang/rust/commit/53498eca50e25d8a11f9dc5859770715fa906fa7"}, {"sha": "9a28d4edc9375e5bf606c453d1e03a45ae8be0af", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a28d4edc9375e5bf606c453d1e03a45ae8be0af", "html_url": "https://github.com/rust-lang/rust/commit/9a28d4edc9375e5bf606c453d1e03a45ae8be0af"}], "stats": {"total": 38, "additions": 21, "deletions": 17}, "files": [{"sha": "055029dddcdddfe51cf23429932bab6633f9102a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b0d31707cc849bd385ae8677823d1f2bcc8aba41/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d31707cc849bd385ae8677823d1f2bcc8aba41/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b0d31707cc849bd385ae8677823d1f2bcc8aba41", "patch": "@@ -223,7 +223,7 @@ impl<T> Arc<T> {\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n         // See `drop` for why all these atomics are like this\n-        if this.inner().strong.compare_and_swap(1, 0, Release) != 1 {\n+        if this.inner().strong.compare_exchange(1, 0, Release, Relaxed).is_err() {\n             return Err(this);\n         }\n \n@@ -256,11 +256,11 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n     pub fn downgrade(this: &Self) -> Weak<T> {\n-        loop {\n-            // This Relaxed is OK because we're checking the value in the CAS\n-            // below.\n-            let cur = this.inner().weak.load(Relaxed);\n+        // This Relaxed is OK because we're checking the value in the CAS\n+        // below.\n+        let mut cur = this.inner().weak.load(Relaxed);\n \n+        loop {\n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX {\n                 continue;\n@@ -273,8 +273,9 @@ impl<T: ?Sized> Arc<T> {\n             // Unlike with Clone(), we need this to be an Acquire read to\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n-            if this.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n-                return Weak { _ptr: this._ptr };\n+            match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n+                Ok(_) => return Weak { _ptr: this._ptr },\n+                Err(old) => cur = old,\n             }\n         }\n     }\n@@ -416,7 +417,7 @@ impl<T: Clone> Arc<T> {\n         // before release writes (i.e., decrements) to `strong`. Since we hold a\n         // weak count, there's no chance the ArcInner itself could be\n         // deallocated.\n-        if this.inner().strong.compare_and_swap(1, 0, Acquire) != 1 {\n+        if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {\n             // Another strong pointer exists; clone\n             *this = Arc::new((**this).clone());\n         } else if this.inner().weak.load(Relaxed) != 1 {\n@@ -506,7 +507,7 @@ impl<T: ?Sized> Arc<T> {\n         // The acquire label here ensures a happens-before relationship with any\n         // writes to `strong` prior to decrements of the `weak` count (via drop,\n         // which uses Release).\n-        if self.inner().weak.compare_and_swap(1, usize::MAX, Acquire) == 1 {\n+        if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n             // Due to the previous acquire read, this will observe any writes to\n             // `strong` that were due to upgrading weak pointers; only strong\n             // clones remain, which require that the strong count is > 1 anyway.\n@@ -618,12 +619,14 @@ impl<T: ?Sized> Weak<T> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n         let inner = self.inner();\n+\n+        // Relaxed load because any write of 0 that we can observe\n+        // leaves the field in a permanently zero state (so a\n+        // \"stale\" read of 0 is fine), and any other value is\n+        // confirmed via the CAS below.\n+        let mut n = inner.strong.load(Relaxed);\n+\n         loop {\n-            // Relaxed load because any write of 0 that we can observe\n-            // leaves the field in a permanently zero state (so a\n-            // \"stale\" read of 0 is fine), and any other value is\n-            // confirmed via the CAS below.\n-            let n = inner.strong.load(Relaxed);\n             if n == 0 {\n                 return None;\n             }\n@@ -634,9 +637,9 @@ impl<T: ?Sized> Weak<T> {\n             }\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n-            let old = inner.strong.compare_and_swap(n, n + 1, Relaxed);\n-            if old == n {\n-                return Some(Arc { _ptr: self._ptr });\n+            match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n+                Ok(_) => return Some(Arc { _ptr: self._ptr }),\n+                Err(old) => n = old,\n             }\n         }\n     }"}, {"sha": "c2dad9a1ae4f95b53b40673fc020aa457735d12a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0d31707cc849bd385ae8677823d1f2bcc8aba41/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d31707cc849bd385ae8677823d1f2bcc8aba41/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b0d31707cc849bd385ae8677823d1f2bcc8aba41", "patch": "@@ -90,6 +90,7 @@\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(unsize)]\n+#![feature(extended_compare_and_swap)]\n \n #![cfg_attr(not(test), feature(raw, fn_traits, placement_new_protocol))]\n #![cfg_attr(test, feature(test, box_heap))]"}]}