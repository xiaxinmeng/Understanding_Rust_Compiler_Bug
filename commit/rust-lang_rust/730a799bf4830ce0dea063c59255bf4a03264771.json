{"sha": "730a799bf4830ce0dea063c59255bf4a03264771", "node_id": "C_kwDOAAsO6NoAKDczMGE3OTliZjQ4MzBjZTBkZWEwNjNjNTkyNTViZjRhMDMyNjQ3NzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T15:02:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T15:02:34Z"}, "message": "Auto merge of #2459 - RalfJung:cargo-miri-split, r=RalfJung\n\nsplit cargo-miri into multiple files\n\nalso greatly extend the 'who calls who' comment", "tree": {"sha": "d47e8c9121573383d06b664b40113cf3ece5b84d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d47e8c9121573383d06b664b40113cf3ece5b84d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/730a799bf4830ce0dea063c59255bf4a03264771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/730a799bf4830ce0dea063c59255bf4a03264771", "html_url": "https://github.com/rust-lang/rust/commit/730a799bf4830ce0dea063c59255bf4a03264771", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/730a799bf4830ce0dea063c59255bf4a03264771/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c24c6388848634a4fb6e22e6b6b51b246eda96cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c24c6388848634a4fb6e22e6b6b51b246eda96cb", "html_url": "https://github.com/rust-lang/rust/commit/c24c6388848634a4fb6e22e6b6b51b246eda96cb"}, {"sha": "29e9a8aa1a3639393681f2d1bd471a38eb08e318", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e9a8aa1a3639393681f2d1bd471a38eb08e318", "html_url": "https://github.com/rust-lang/rust/commit/29e9a8aa1a3639393681f2d1bd471a38eb08e318"}], "stats": {"total": 2596, "additions": 1320, "deletions": 1276}, "files": [{"sha": "95303a592c8a2d9a5dcd98d1dff6825759df26b4", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=730a799bf4830ce0dea063c59255bf4a03264771", "patch": "@@ -58,7 +58,7 @@ jobs:\n             # contains package information of crates installed via `cargo install`.\n             ~/.cargo/.crates.toml\n             ~/.cargo/.crates2.json\n-          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock', 'cargo-miri/version.rs') }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock', 'cargo-miri/src/version.rs') }}\n           restore-keys: ${{ runner.os }}-cargo\n \n       - name: Install rustup-toolchain-install-master and xargo"}, {"sha": "9ac170c5b5377588611d9f1a9f032c6035e9f310", "filename": "cargo-miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2FCargo.toml?ref=730a799bf4830ce0dea063c59255bf4a03264771", "patch": "@@ -9,7 +9,7 @@ edition = \"2021\"\n \n [[bin]]\n name = \"cargo-miri\"\n-path = \"bin.rs\"\n+path = \"src/main.rs\"\n test = false # we have no unit tests\n doctest = false # and no doc tests\n "}, {"sha": "4ddf2295362ac25bc67f2d74d6afab7728c5dcb3", "filename": "cargo-miri/bin.rs", "status": "removed", "additions": 0, "deletions": 1274, "changes": 1274, "blob_url": "https://github.com/rust-lang/rust/blob/c24c6388848634a4fb6e22e6b6b51b246eda96cb/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c6388848634a4fb6e22e6b6b51b246eda96cb/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=c24c6388848634a4fb6e22e6b6b51b246eda96cb", "patch": "@@ -1,1274 +0,0 @@\n-#![feature(let_else)]\n-#![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq)]\n-\n-mod version;\n-\n-use std::collections::HashMap;\n-use std::env;\n-use std::ffi::{OsStr, OsString};\n-use std::fmt::Write as _;\n-use std::fs::{self, File};\n-use std::io::{self, BufRead, BufReader, BufWriter, Read, Write};\n-use std::iter::{self, TakeWhile};\n-use std::ops::Not;\n-use std::path::{Path, PathBuf};\n-use std::process::{self, Command};\n-\n-use cargo_metadata::{Metadata, MetadataCommand};\n-use rustc_version::VersionMeta;\n-use serde::{Deserialize, Serialize};\n-\n-use version::*;\n-\n-const CARGO_MIRI_HELP: &str = r#\"Runs binary crates and tests in Miri\n-\n-Usage:\n-    cargo miri [subcommand] [<cargo options>...] [--] [<program/test suite options>...]\n-\n-Subcommands:\n-    run, r                   Run binaries\n-    test, t                  Run tests\n-    nextest                  Run tests with nextest (requires cargo-nextest installed)\n-    setup                    Only perform automatic setup, but without asking questions (for getting a proper libstd)\n-\n-The cargo options are exactly the same as for `cargo run` and `cargo test`, respectively.\n-\n-Examples:\n-    cargo miri run\n-    cargo miri test -- test-suite-filter\n-\n-    cargo miri setup --print sysroot\n-        This will print the path to the generated sysroot (and nothing else) on stdout.\n-        stderr will still contain progress information about how the build is doing.\n-\n-\"#;\n-\n-#[derive(Clone, Debug)]\n-enum MiriCommand {\n-    /// Our own special 'setup' command.\n-    Setup,\n-    /// A command to be forwarded to cargo.\n-    Forward(String),\n-}\n-\n-/// The information to run a crate with the given environment.\n-#[derive(Clone, Serialize, Deserialize)]\n-struct CrateRunEnv {\n-    /// The command-line arguments.\n-    args: Vec<String>,\n-    /// The environment.\n-    env: Vec<(OsString, OsString)>,\n-    /// The current working directory.\n-    current_dir: OsString,\n-    /// The contents passed via standard input.\n-    stdin: Vec<u8>,\n-}\n-\n-impl CrateRunEnv {\n-    /// Gather all the information we need.\n-    fn collect(args: impl Iterator<Item = String>, capture_stdin: bool) -> Self {\n-        let args = args.collect();\n-        let env = env::vars_os().collect();\n-        let current_dir = env::current_dir().unwrap().into_os_string();\n-\n-        let mut stdin = Vec::new();\n-        if capture_stdin {\n-            std::io::stdin().lock().read_to_end(&mut stdin).expect(\"cannot read stdin\");\n-        }\n-\n-        CrateRunEnv { args, env, current_dir, stdin }\n-    }\n-}\n-\n-/// The information Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n-#[derive(Serialize, Deserialize)]\n-enum CrateRunInfo {\n-    /// Run it with the given environment.\n-    RunWith(CrateRunEnv),\n-    /// Skip it as Miri does not support interpreting such kind of crates.\n-    SkipProcMacroTest,\n-}\n-\n-impl CrateRunInfo {\n-    fn store(&self, filename: &Path) {\n-        let file = File::create(filename)\n-            .unwrap_or_else(|_| show_error(format!(\"cannot create `{}`\", filename.display())));\n-        let file = BufWriter::new(file);\n-        serde_json::ser::to_writer(file, self)\n-            .unwrap_or_else(|_| show_error(format!(\"cannot write to `{}`\", filename.display())));\n-    }\n-}\n-\n-fn show_help() {\n-    println!(\"{}\", CARGO_MIRI_HELP);\n-}\n-\n-fn show_version() {\n-    let mut version = format!(\"miri {}\", env!(\"CARGO_PKG_VERSION\"));\n-    // Only use `option_env` on vergen variables to ensure the build succeeds\n-    // when vergen failed to find the git info.\n-    if let Some(sha) = option_env!(\"VERGEN_GIT_SHA_SHORT\") {\n-        // This `unwrap` can never fail because if VERGEN_GIT_SHA_SHORT exists, then so does\n-        // VERGEN_GIT_COMMIT_DATE.\n-        #[allow(clippy::option_env_unwrap)]\n-        write!(&mut version, \" ({} {})\", sha, option_env!(\"VERGEN_GIT_COMMIT_DATE\").unwrap())\n-            .unwrap();\n-    }\n-    println!(\"{}\", version);\n-}\n-\n-fn show_error(msg: String) -> ! {\n-    eprintln!(\"fatal error: {}\", msg);\n-    std::process::exit(1)\n-}\n-\n-/// Determines whether a `--flag` is present.\n-fn has_arg_flag(name: &str) -> bool {\n-    num_arg_flag(name) > 0\n-}\n-\n-/// Determines how many times a `--flag` is present.\n-fn num_arg_flag(name: &str) -> usize {\n-    std::env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n-}\n-\n-/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n-/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n-struct ArgSplitFlagValue<'a, I> {\n-    args: TakeWhile<I, fn(&String) -> bool>,\n-    name: &'a str,\n-}\n-\n-impl<'a, I: Iterator<Item = String>> ArgSplitFlagValue<'a, I> {\n-    fn new(args: I, name: &'a str) -> Self {\n-        Self {\n-            // Stop searching at `--`.\n-            args: args.take_while(|val| val != \"--\"),\n-            name,\n-        }\n-    }\n-}\n-\n-impl<I: Iterator<Item = String>> Iterator for ArgSplitFlagValue<'_, I> {\n-    type Item = Result<String, String>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let arg = self.args.next()?;\n-        if let Some(suffix) = arg.strip_prefix(self.name) {\n-            // Strip leading `name`.\n-            if suffix.is_empty() {\n-                // This argument is exactly `name`; the next one is the value.\n-                return self.args.next().map(Ok);\n-            } else if let Some(suffix) = suffix.strip_prefix('=') {\n-                // This argument is `name=value`; get the value.\n-                return Some(Ok(suffix.to_owned()));\n-            }\n-        }\n-        Some(Err(arg))\n-    }\n-}\n-\n-/// Yields all values of command line flag `name`.\n-struct ArgFlagValueIter<'a>(ArgSplitFlagValue<'a, env::Args>);\n-\n-impl<'a> ArgFlagValueIter<'a> {\n-    fn new(name: &'a str) -> Self {\n-        Self(ArgSplitFlagValue::new(env::args(), name))\n-    }\n-}\n-\n-impl Iterator for ArgFlagValueIter<'_> {\n-    type Item = String;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        loop {\n-            if let Ok(value) = self.0.next()? {\n-                return Some(value);\n-            }\n-        }\n-    }\n-}\n-\n-/// Gets the value of a `--flag`.\n-fn get_arg_flag_value(name: &str) -> Option<String> {\n-    ArgFlagValueIter::new(name).next()\n-}\n-\n-fn forward_patched_extern_arg(args: &mut impl Iterator<Item = String>, cmd: &mut Command) {\n-    cmd.arg(\"--extern\"); // always forward flag, but adjust filename:\n-    let path = args.next().expect(\"`--extern` should be followed by a filename\");\n-    if let Some(lib) = path.strip_suffix(\".rlib\") {\n-        // If this is an rlib, make it an rmeta.\n-        cmd.arg(format!(\"{}.rmeta\", lib));\n-    } else {\n-        // Some other extern file (e.g. a `.so`). Forward unchanged.\n-        cmd.arg(path);\n-    }\n-}\n-\n-/// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n-fn escape_for_toml(s: &str) -> String {\n-    // We want to surround this string in quotes `\"`. So we first escape all quotes,\n-    // and also all backslashes (that are used to escape quotes).\n-    let s = s.replace('\\\\', r#\"\\\\\"#).replace('\"', r#\"\\\"\"#);\n-    format!(\"\\\"{}\\\"\", s)\n-}\n-\n-/// Returns the path to the `miri` binary\n-fn find_miri() -> PathBuf {\n-    if let Some(path) = env::var_os(\"MIRI\") {\n-        return path.into();\n-    }\n-    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n-    if cfg!(windows) {\n-        path.set_file_name(\"miri.exe\");\n-    } else {\n-        path.set_file_name(\"miri\");\n-    }\n-    path\n-}\n-\n-fn miri() -> Command {\n-    Command::new(find_miri())\n-}\n-\n-fn miri_for_host() -> Command {\n-    let mut cmd = miri();\n-    cmd.env(\"MIRI_BE_RUSTC\", \"host\");\n-    cmd\n-}\n-\n-fn version_info() -> VersionMeta {\n-    VersionMeta::for_command(miri_for_host())\n-        .expect(\"failed to determine underlying rustc version of Miri\")\n-}\n-\n-fn cargo() -> Command {\n-    Command::new(env::var_os(\"CARGO\").unwrap_or_else(|| OsString::from(\"cargo\")))\n-}\n-\n-fn xargo_check() -> Command {\n-    Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n-}\n-\n-/// Execute the `Command`, where possible by replacing the current process with a new process\n-/// described by the `Command`. Then exit this process with the exit code of the new process.\n-fn exec(mut cmd: Command) -> ! {\n-    // On non-Unix imitate POSIX exec as closely as we can\n-    #[cfg(not(unix))]\n-    {\n-        let exit_status = cmd.status().expect(\"failed to run command\");\n-        std::process::exit(exit_status.code().unwrap_or(-1))\n-    }\n-    // On Unix targets, actually exec.\n-    // If exec returns, process setup has failed. This is the same error condition as the expect in\n-    // the non-Unix case.\n-    #[cfg(unix)]\n-    {\n-        use std::os::unix::process::CommandExt;\n-        let error = cmd.exec();\n-        Err(error).expect(\"failed to run command\")\n-    }\n-}\n-\n-/// Execute the `Command`, where possible by replacing the current process with a new process\n-/// described by the `Command`. Then exit this process with the exit code of the new process.\n-/// `input` is also piped to the new process's stdin, on cfg(unix) platforms by writing its\n-/// contents to `path` first, then setting stdin to that file.\n-fn exec_with_pipe<P>(mut cmd: Command, input: &[u8], path: P) -> !\n-where\n-    P: AsRef<Path>,\n-{\n-    #[cfg(unix)]\n-    {\n-        // Write the bytes we want to send to stdin out to a file\n-        std::fs::write(&path, input).unwrap();\n-        // Open the file for reading, and set our new stdin to it\n-        let stdin = File::open(&path).unwrap();\n-        cmd.stdin(stdin);\n-        // Unlink the file so that it is fully cleaned up as soon as the new process exits\n-        std::fs::remove_file(&path).unwrap();\n-        // Finally, we can hand off control.\n-        exec(cmd)\n-    }\n-    #[cfg(not(unix))]\n-    {\n-        drop(path); // We don't need the path, we can pipe the bytes directly\n-        cmd.stdin(process::Stdio::piped());\n-        let mut child = cmd.spawn().expect(\"failed to spawn process\");\n-        {\n-            let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n-            stdin.write_all(input).expect(\"failed to write out test source\");\n-        }\n-        let exit_status = child.wait().expect(\"failed to run command\");\n-        std::process::exit(exit_status.code().unwrap_or(-1))\n-    }\n-}\n-\n-fn xargo_version() -> Option<(u32, u32, u32)> {\n-    let out = xargo_check().arg(\"--version\").output().ok()?;\n-    if !out.status.success() {\n-        return None;\n-    }\n-    // Parse output. The first line looks like \"xargo 0.3.12 (b004f1c 2018-12-13)\".\n-    let line = out\n-        .stderr\n-        .lines()\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not at least one line\")\n-        .expect(\"malformed `xargo --version` output: error reading first line\");\n-    let (name, version) = {\n-        let mut split = line.split(' ');\n-        (\n-            split.next().expect(\"malformed `xargo --version` output: empty\"),\n-            split.next().expect(\"malformed `xargo --version` output: not at least two words\"),\n-        )\n-    };\n-    if name != \"xargo\" {\n-        // This is some fork of xargo\n-        return None;\n-    }\n-    let mut version_pieces = version.split('.');\n-    let major = version_pieces\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not a major version piece\")\n-        .parse()\n-        .expect(\"malformed `xargo --version` output: major version is not an integer\");\n-    let minor = version_pieces\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not a minor version piece\")\n-        .parse()\n-        .expect(\"malformed `xargo --version` output: minor version is not an integer\");\n-    let patch = version_pieces\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not a patch version piece\")\n-        .parse()\n-        .expect(\"malformed `xargo --version` output: patch version is not an integer\");\n-    if version_pieces.next().is_some() {\n-        panic!(\"malformed `xargo --version` output: more than three pieces in version\");\n-    }\n-    Some((major, minor, patch))\n-}\n-\n-fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n-    // Disable interactive prompts in CI (GitHub Actions, Travis, AppVeyor, etc).\n-    // Azure doesn't set `CI` though (nothing to see here, just Microsoft being Microsoft),\n-    // so we also check their `TF_BUILD`.\n-    let is_ci = env::var_os(\"CI\").is_some() || env::var_os(\"TF_BUILD\").is_some();\n-    if ask && !is_ci {\n-        let mut buf = String::new();\n-        print!(\"I will run `{:?}` to {}. Proceed? [Y/n] \", cmd, text);\n-        io::stdout().flush().unwrap();\n-        io::stdin().read_line(&mut buf).unwrap();\n-        match buf.trim().to_lowercase().as_ref() {\n-            // Proceed.\n-            \"\" | \"y\" | \"yes\" => {}\n-            \"n\" | \"no\" => show_error(format!(\"aborting as per your request\")),\n-            a => show_error(format!(\"invalid answer `{}`\", a)),\n-        };\n-    } else {\n-        eprintln!(\"Running `{:?}` to {}.\", cmd, text);\n-    }\n-\n-    if cmd.status().unwrap_or_else(|_| panic!(\"failed to execute {:?}\", cmd)).success().not() {\n-        show_error(format!(\"failed to {}\", text));\n-    }\n-}\n-\n-/// Writes the given content to the given file *cross-process atomically*, in the sense that another\n-/// process concurrently reading that file will see either the old content or the new content, but\n-/// not some intermediate (e.g., empty) state.\n-///\n-/// We assume no other parts of this same process are trying to read or write that file.\n-fn write_to_file(filename: &Path, content: &str) {\n-    // Create a temporary file with the desired contents.\n-    let mut temp_filename = filename.as_os_str().to_os_string();\n-    temp_filename.push(&format!(\".{}\", std::process::id()));\n-    let mut temp_file = File::create(&temp_filename).unwrap();\n-    temp_file.write_all(content.as_bytes()).unwrap();\n-    drop(temp_file);\n-\n-    // Move file to the desired location.\n-    fs::rename(temp_filename, filename).unwrap();\n-}\n-\n-/// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n-/// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n-/// done all this already.\n-fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n-    let only_setup = matches!(subcommand, MiriCommand::Setup);\n-    let ask_user = !only_setup;\n-    let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n-    if std::env::var_os(\"MIRI_SYSROOT\").is_some() {\n-        if only_setup {\n-            println!(\"WARNING: MIRI_SYSROOT already set, not doing anything.\")\n-        }\n-        return;\n-    }\n-\n-    // First, we need xargo.\n-    if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n-        if std::env::var_os(\"XARGO_CHECK\").is_some() {\n-            // The user manually gave us a xargo binary; don't do anything automatically.\n-            show_error(format!(\"xargo is too old; please upgrade to the latest version\"))\n-        }\n-        let mut cmd = cargo();\n-        cmd.args(&[\"install\", \"xargo\"]);\n-        ask_to_run(cmd, ask_user, \"install a recent enough xargo\");\n-    }\n-\n-    // Determine where the rust sources are located.  The env vars manually setting the source\n-    // (`MIRI_LIB_SRC`, `XARGO_RUST_SRC`) trump auto-detection.\n-    let rust_src_env_var =\n-        std::env::var_os(\"MIRI_LIB_SRC\").or_else(|| std::env::var_os(\"XARGO_RUST_SRC\"));\n-    let rust_src = match rust_src_env_var {\n-        Some(path) => {\n-            let path = PathBuf::from(path);\n-            // Make path absolute if possible.\n-            path.canonicalize().unwrap_or(path)\n-        }\n-        None => {\n-            // Check for `rust-src` rustup component.\n-            let output = miri_for_host()\n-                .args(&[\"--print\", \"sysroot\"])\n-                .output()\n-                .expect(\"failed to determine sysroot\");\n-            if !output.status.success() {\n-                show_error(format!(\n-                    \"Failed to determine sysroot; Miri said:\\n{}\",\n-                    String::from_utf8_lossy(&output.stderr).trim_end()\n-                ));\n-            }\n-            let sysroot = std::str::from_utf8(&output.stdout).unwrap();\n-            let sysroot = Path::new(sysroot.trim_end_matches('\\n'));\n-            // Check for `$SYSROOT/lib/rustlib/src/rust/library`; test if that contains `std/Cargo.toml`.\n-            let rustup_src =\n-                sysroot.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\").join(\"library\");\n-            if !rustup_src.join(\"std\").join(\"Cargo.toml\").exists() {\n-                // Ask the user to install the `rust-src` component, and use that.\n-                let mut cmd = Command::new(\"rustup\");\n-                cmd.args(&[\"component\", \"add\", \"rust-src\"]);\n-                ask_to_run(\n-                    cmd,\n-                    ask_user,\n-                    \"install the `rust-src` component for the selected toolchain\",\n-                );\n-            }\n-            rustup_src\n-        }\n-    };\n-    if !rust_src.exists() {\n-        show_error(format!(\"given Rust source directory `{}` does not exist.\", rust_src.display()));\n-    }\n-    if rust_src.file_name().and_then(OsStr::to_str) != Some(\"library\") {\n-        show_error(format!(\n-            \"given Rust source directory `{}` does not seem to be the `library` subdirectory of \\\n-             a Rust source checkout.\",\n-            rust_src.display()\n-        ));\n-    }\n-\n-    // Next, we need our own libstd. Prepare a xargo project for that purpose.\n-    // We will do this work in whatever is a good cache dir for this platform.\n-    let dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n-    let dir = dirs.cache_dir();\n-    if !dir.exists() {\n-        fs::create_dir_all(&dir).unwrap();\n-    }\n-    // The interesting bit: Xargo.toml (only needs content if we actually need std)\n-    let xargo_toml = if std::env::var_os(\"MIRI_NO_STD\").is_some() {\n-        \"\"\n-    } else {\n-        r#\"\n-[dependencies.std]\n-default_features = false\n-# We support unwinding, so enable that panic runtime.\n-features = [\"panic_unwind\", \"backtrace\"]\n-\n-[dependencies.test]\n-\"#\n-    };\n-    write_to_file(&dir.join(\"Xargo.toml\"), xargo_toml);\n-    // The boring bits: a dummy project for xargo.\n-    // FIXME: With xargo-check, can we avoid doing this?\n-    write_to_file(\n-        &dir.join(\"Cargo.toml\"),\n-        r#\"\n-[package]\n-name = \"miri-xargo\"\n-description = \"A dummy project for building libstd with xargo.\"\n-version = \"0.0.0\"\n-\n-[lib]\n-path = \"lib.rs\"\n-\"#,\n-    );\n-    write_to_file(&dir.join(\"lib.rs\"), \"#![no_std]\");\n-\n-    // Figure out where xargo will build its stuff.\n-    // Unfortunately, it puts things into a different directory when the\n-    // architecture matches the host.\n-    let sysroot = if target == host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n-    // Make sure all target-level Miri invocations know their sysroot.\n-    std::env::set_var(\"MIRI_SYSROOT\", &sysroot);\n-\n-    // Now invoke xargo.\n-    let mut command = xargo_check();\n-    command.arg(\"check\").arg(\"-q\");\n-    command.current_dir(&dir);\n-    command.env(\"XARGO_HOME\", &dir);\n-    command.env(\"XARGO_RUST_SRC\", &rust_src);\n-    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n-    command.arg(\"--target\").arg(target);\n-    // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n-    // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n-    // because we still need bootstrap to distinguish between host and target crates.\n-    // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n-    // for target crates.\n-    // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n-    // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n-    // The `MIRI_CALLED_FROM_XARGO` will mean we dispatch to `phase_setup_rustc`.\n-    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n-    if env::var_os(\"RUSTC_STAGE\").is_some() {\n-        assert!(env::var_os(\"RUSTC\").is_some());\n-        command.env(\"RUSTC_REAL\", &cargo_miri_path);\n-    } else {\n-        command.env(\"RUSTC\", &cargo_miri_path);\n-    }\n-    command.env(\"MIRI_CALLED_FROM_XARGO\", \"1\");\n-    // Make sure there are no other wrappers getting in our way\n-    // (Cc https://github.com/rust-lang/miri/issues/1421, https://github.com/rust-lang/miri/issues/2429).\n-    // Looks like setting `RUSTC_WRAPPER` to the empty string overwrites `build.rustc-wrapper` set via `config.toml`.\n-    command.env(\"RUSTC_WRAPPER\", \"\");\n-    // Disable debug assertions in the standard library -- Miri is already slow enough. But keep the\n-    // overflow checks, they are cheap. This completely overwrites flags the user might have set,\n-    // which is consistent with normal `cargo build` that does not apply `RUSTFLAGS` to the sysroot\n-    // either.\n-    command.env(\"RUSTFLAGS\", \"-Cdebug-assertions=off -Coverflow-checks=on\");\n-    // Manage the output the user sees.\n-    if only_setup {\n-        // We want to be explicit.\n-        eprintln!(\"Preparing a sysroot for Miri (target: {target})...\");\n-        if print_sysroot {\n-            // Be extra sure there is no noise on stdout.\n-            command.stdout(process::Stdio::null());\n-        }\n-    } else {\n-        // We want to be quiet, but still let the user know that something is happening.\n-        eprint!(\"Preparing a sysroot for Miri (target: {target})... \");\n-        command.stdout(process::Stdio::null());\n-        command.stderr(process::Stdio::null());\n-    }\n-\n-    // Finally run it!\n-    if command.status().expect(\"failed to run xargo\").success().not() {\n-        if only_setup {\n-            show_error(format!(\"failed to run xargo, see error details above\"))\n-        } else {\n-            show_error(format!(\n-                \"failed to run xargo; run `cargo miri setup` to see the error details\"\n-            ))\n-        }\n-    }\n-\n-    // Figure out what to print.\n-    if only_setup {\n-        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n-    } else {\n-        eprintln!(\"done\");\n-    }\n-    if print_sysroot {\n-        // Print just the sysroot and nothing else to stdout; this way we do not need any escaping.\n-        println!(\"{}\", sysroot.display());\n-    }\n-}\n-\n-fn get_cargo_metadata() -> Metadata {\n-    // The `build.target-dir` config can be passed by `--config` flags, so forward them to\n-    // `cargo metadata`.\n-    let mut additional_options = Vec::new();\n-    // `-Zunstable-options` is required by `--config`.\n-    additional_options.push(\"-Zunstable-options\".to_string());\n-\n-    let config_flag = \"--config\";\n-    for arg in ArgSplitFlagValue::new(\n-        env::args().skip(3), // skip the program name, \"miri\" and \"run\" / \"test\"\n-        config_flag,\n-    )\n-    // Only look at `Ok`\n-    .flatten()\n-    {\n-        additional_options.push(config_flag.to_string());\n-        additional_options.push(arg);\n-    }\n-\n-    let metadata =\n-        MetadataCommand::new().no_deps().other_options(additional_options).exec().unwrap();\n-\n-    metadata\n-}\n-\n-/// Pulls all the crates in this workspace from the cargo metadata.\n-/// Workspace members are emitted like \"miri 0.1.0 (path+file:///path/to/miri)\"\n-/// Additionally, somewhere between cargo metadata and TyCtxt, '-' gets replaced with '_' so we\n-/// make that same transformation here.\n-fn local_crates(metadata: &Metadata) -> String {\n-    assert!(!metadata.workspace_members.is_empty());\n-    let mut local_crates = String::new();\n-    for member in &metadata.workspace_members {\n-        let name = member.repr.split(' ').next().unwrap();\n-        let name = name.replace('-', \"_\");\n-        local_crates.push_str(&name);\n-        local_crates.push(',');\n-    }\n-    local_crates.pop(); // Remove the trailing ','\n-\n-    local_crates\n-}\n-\n-fn env_vars_from_cmd(cmd: &Command) -> Vec<(String, String)> {\n-    let mut envs = HashMap::new();\n-    for (key, value) in std::env::vars() {\n-        envs.insert(key, value);\n-    }\n-    for (key, value) in cmd.get_envs() {\n-        if let Some(value) = value {\n-            envs.insert(key.to_string_lossy().to_string(), value.to_string_lossy().to_string());\n-        } else {\n-            envs.remove(&key.to_string_lossy().to_string());\n-        }\n-    }\n-    let mut envs: Vec<_> = envs.into_iter().collect();\n-    envs.sort();\n-    envs\n-}\n-\n-/// Debug-print a command that is going to be run.\n-fn debug_cmd(prefix: &str, verbose: usize, cmd: &Command) {\n-    if verbose == 0 {\n-        return;\n-    }\n-    // We only do a single `eprintln!` call to minimize concurrency interactions.\n-    let mut out = prefix.to_string();\n-    writeln!(out, \" running command: env \\\\\").unwrap();\n-    if verbose > 1 {\n-        // Print the full environment this will be called in.\n-        for (key, value) in env_vars_from_cmd(cmd) {\n-            writeln!(out, \"{key}={value:?} \\\\\").unwrap();\n-        }\n-    } else {\n-        // Print only what has been changed for this `cmd`.\n-        for (var, val) in cmd.get_envs() {\n-            if let Some(val) = val {\n-                writeln!(out, \"{}={:?} \\\\\", var.to_string_lossy(), val).unwrap();\n-            } else {\n-                writeln!(out, \"--unset={}\", var.to_string_lossy()).unwrap();\n-            }\n-        }\n-    }\n-    write!(out, \"{cmd:?}\").unwrap();\n-    eprintln!(\"{}\", out);\n-}\n-\n-fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n-    // Check for version and help flags even when invoked as `cargo-miri`.\n-    if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n-        show_help();\n-        return;\n-    }\n-    if has_arg_flag(\"--version\") || has_arg_flag(\"-V\") {\n-        show_version();\n-        return;\n-    }\n-\n-    // Require a subcommand before any flags.\n-    // We cannot know which of those flags take arguments and which do not,\n-    // so we cannot detect subcommands later.\n-    let Some(subcommand) = args.next() else {\n-        show_error(format!(\"`cargo miri` needs to be called with a subcommand (`run`, `test`)\"));\n-    };\n-    let subcommand = match &*subcommand {\n-        \"setup\" => MiriCommand::Setup,\n-        \"test\" | \"t\" | \"run\" | \"r\" | \"nextest\" => MiriCommand::Forward(subcommand),\n-        _ =>\n-            show_error(format!(\n-                \"`cargo miri` supports the following subcommands: `run`, `test`, `nextest`, and `setup`.\"\n-            )),\n-    };\n-    let verbose = num_arg_flag(\"-v\");\n-\n-    // Determine the involved architectures.\n-    let host = version_info().host;\n-    let target = get_arg_flag_value(\"--target\");\n-    let target = target.as_ref().unwrap_or(&host);\n-\n-    // We always setup.\n-    setup(&subcommand, &host, target);\n-\n-    // Invoke actual cargo for the job, but with different flags.\n-    // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n-    // requires some extra work to make the build check-only (see all the `--emit` hacks below).\n-    // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n-    // approach that uses `cargo check`, making that part easier but target and binary handling\n-    // harder.\n-    let cargo_miri_path = std::env::current_exe()\n-        .expect(\"current executable path invalid\")\n-        .into_os_string()\n-        .into_string()\n-        .expect(\"current executable path is not valid UTF-8\");\n-    let cargo_cmd = match subcommand {\n-        MiriCommand::Forward(s) => s,\n-        MiriCommand::Setup => return, // `cargo miri setup` stops here.\n-    };\n-    let metadata = get_cargo_metadata();\n-    let mut cmd = cargo();\n-    cmd.arg(cargo_cmd);\n-\n-    // Forward all arguments before `--` other than `--target-dir` and its value to Cargo.\n-    let mut target_dir = None;\n-    for arg in ArgSplitFlagValue::new(&mut args, \"--target-dir\") {\n-        match arg {\n-            Ok(value) => {\n-                if target_dir.is_some() {\n-                    show_error(format!(\"`--target-dir` is provided more than once\"));\n-                }\n-                target_dir = Some(value.into());\n-            }\n-            Err(arg) => {\n-                cmd.arg(arg);\n-            }\n-        }\n-    }\n-    // Detect the target directory if it's not specified via `--target-dir`.\n-    let target_dir = target_dir.get_or_insert_with(|| metadata.target_directory.clone());\n-    // Set `--target-dir` to `miri` inside the original target directory.\n-    target_dir.push(\"miri\");\n-    cmd.arg(\"--target-dir\").arg(target_dir);\n-\n-    // Make sure the build target is explicitly set.\n-    // This is needed to make the `target.runner` settings do something,\n-    // and it later helps us detect which crates are proc-macro/build-script\n-    // (host crates) and which crates are needed for the program itself.\n-    if get_arg_flag_value(\"--target\").is_none() {\n-        // No target given. Explicitly pick the host.\n-        cmd.arg(\"--target\");\n-        cmd.arg(&host);\n-    }\n-\n-    // Set ourselves as runner for al binaries invoked by cargo.\n-    // We use `all()` since `true` is not a thing in cfg-lang, but the empty conjunction is. :)\n-    let cargo_miri_path_for_toml = escape_for_toml(&cargo_miri_path);\n-    cmd.arg(\"--config\")\n-        .arg(format!(\"target.'cfg(all())'.runner=[{cargo_miri_path_for_toml}, 'runner']\"));\n-\n-    // Forward all further arguments after `--` to cargo.\n-    cmd.arg(\"--\").args(args);\n-\n-    // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n-    // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n-    // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n-    if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n-        println!(\n-            \"WARNING: Ignoring `RUSTC_WRAPPER` environment variable, Miri does not support wrapping.\"\n-        );\n-    }\n-    cmd.env(\"RUSTC_WRAPPER\", &cargo_miri_path);\n-    // We are going to invoke `MIRI` for everything, not `RUSTC`.\n-    if env::var_os(\"RUSTC\").is_some() && env::var_os(\"MIRI\").is_none() {\n-        println!(\n-            \"WARNING: Ignoring `RUSTC` environment variable; set `MIRI` if you want to control the binary used as the driver.\"\n-        );\n-    }\n-    // Build scripts (and also cargo: https://github.com/rust-lang/cargo/issues/10885) will invoke\n-    // `rustc` even when `RUSTC_WRAPPER` is set. To make sure everything is coherent, we want that\n-    // to be the Miri driver, but acting as rustc, on the target level. (Target, rather than host,\n-    // is needed for cross-interpretation situations.) This is not a perfect emulation of real rustc\n-    // (it might be unable to produce binaries since the sysroot is check-only), but it's as close\n-    // as we can get, and it's good enough for autocfg.\n-    //\n-    // In `main`, we need the value of `RUSTC` to distinguish RUSTC_WRAPPER invocations from rustdoc\n-    // or TARGET_RUNNER invocations, so we canonicalize it here to make it exceedingly unlikely that\n-    // there would be a collision with other invocations of cargo-miri (as rustdoc or as runner). We\n-    // explicitly do this even if RUSTC_STAGE is set, since for these builds we do *not* want the\n-    // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host\n-    // builds.\n-    cmd.env(\"RUSTC\", &fs::canonicalize(find_miri()).unwrap());\n-    cmd.env(\"MIRI_BE_RUSTC\", \"target\"); // we better remember to *unset* this in the other phases!\n-\n-    // Set rustdoc to us as well, so we can run doctests.\n-    cmd.env(\"RUSTDOC\", &cargo_miri_path);\n-\n-    cmd.env(\"MIRI_LOCAL_CRATES\", local_crates(&metadata));\n-    if verbose > 0 {\n-        cmd.env(\"MIRI_VERBOSE\", verbose.to_string()); // This makes the other phases verbose.\n-    }\n-\n-    // Run cargo.\n-    debug_cmd(\"[cargo-miri miri]\", verbose, &cmd);\n-    exec(cmd)\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq)]\n-enum RustcPhase {\n-    /// `rustc` called via `xargo` for sysroot build.\n-    Setup,\n-    /// `rustc` called by `cargo` for regular build.\n-    Build,\n-    /// `rustc` called by `rustdoc` for doctest.\n-    Rustdoc,\n-}\n-\n-fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n-    /// Determines if we are being invoked (as rustc) to build a crate for\n-    /// the \"target\" architecture, in contrast to the \"host\" architecture.\n-    /// Host crates are for build scripts and proc macros and still need to\n-    /// be built like normal; target crates need to be built for or interpreted\n-    /// by Miri.\n-    ///\n-    /// Currently, we detect this by checking for \"--target=\", which is\n-    /// never set for host crates. This matches what rustc bootstrap does,\n-    /// which hopefully makes it \"reliable enough\". This relies on us always\n-    /// invoking cargo itself with `--target`, which `in_cargo_miri` ensures.\n-    fn is_target_crate() -> bool {\n-        get_arg_flag_value(\"--target\").is_some()\n-    }\n-\n-    /// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n-    /// the final, binary crate (either a test for 'cargo test', or a binary for 'cargo run')\n-    /// Cargo does not give us this information directly, so we need to check\n-    /// various command-line flags.\n-    fn is_runnable_crate() -> bool {\n-        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref().unwrap_or(\"bin\") == \"bin\";\n-        let is_test = has_arg_flag(\"--test\");\n-        is_bin || is_test\n-    }\n-\n-    fn out_filename(prefix: &str, suffix: &str) -> PathBuf {\n-        if let Some(out_dir) = get_arg_flag_value(\"--out-dir\") {\n-            let mut path = PathBuf::from(out_dir);\n-            path.push(format!(\n-                \"{}{}{}{}\",\n-                prefix,\n-                get_arg_flag_value(\"--crate-name\").unwrap(),\n-                // This is technically a `-C` flag but the prefix seems unique enough...\n-                // (and cargo passes this before the filename so it should be unique)\n-                get_arg_flag_value(\"extra-filename\").unwrap_or_default(),\n-                suffix,\n-            ));\n-            path\n-        } else {\n-            let out_file = get_arg_flag_value(\"-o\").unwrap();\n-            PathBuf::from(out_file)\n-        }\n-    }\n-\n-    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n-    // however, if we get called back by cargo here, we'll carefully compute the right flags\n-    // ourselves, so we first un-do what the earlier phase did.\n-    env::remove_var(\"MIRI_BE_RUSTC\");\n-\n-    let verbose = std::env::var(\"MIRI_VERBOSE\")\n-        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n-    let target_crate = is_target_crate();\n-    // Determine whether this is cargo/xargo invoking rustc to get some infos.\n-    let info_query = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\");\n-\n-    let store_json = |info: CrateRunInfo| {\n-        // Create a stub .d file to stop Cargo from \"rebuilding\" the crate:\n-        // https://github.com/rust-lang/miri/issues/1724#issuecomment-787115693\n-        // As we store a JSON file instead of building the crate here, an empty file is fine.\n-        let dep_info_name = out_filename(\"\", \".d\");\n-        if verbose > 0 {\n-            eprintln!(\"[cargo-miri rustc] writing stub dep-info to `{}`\", dep_info_name.display());\n-        }\n-        File::create(dep_info_name).expect(\"failed to create fake .d file\");\n-\n-        let filename = out_filename(\"\", \"\");\n-        if verbose > 0 {\n-            eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n-        }\n-        info.store(&filename);\n-        // For Windows, do the same thing again with `.exe` appended to the filename.\n-        // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n-        info.store(&out_filename(\"\", \".exe\"));\n-    };\n-\n-    let runnable_crate = !info_query && is_runnable_crate();\n-\n-    if runnable_crate && target_crate {\n-        assert!(\n-            phase != RustcPhase::Setup,\n-            \"there should be no interpretation during sysroot build\"\n-        );\n-        let inside_rustdoc = phase == RustcPhase::Rustdoc;\n-        // This is the binary or test crate that we want to interpret under Miri.\n-        // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n-        // like we want them.\n-        // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n-        // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n-        let env = CrateRunEnv::collect(args, inside_rustdoc);\n-\n-        store_json(CrateRunInfo::RunWith(env.clone()));\n-\n-        // Rustdoc expects us to exit with an error code if the test is marked as `compile_fail`,\n-        // just creating the JSON file is not enough: we need to detect syntax errors,\n-        // so we need to run Miri with `MIRI_BE_RUSTC` for a check-only build.\n-        if inside_rustdoc {\n-            let mut cmd = miri();\n-\n-            // Ensure --emit argument for a check-only build is present.\n-            // We cannot use the usual helpers since we need to check specifically in `env.args`.\n-            if let Some(i) = env.args.iter().position(|arg| arg.starts_with(\"--emit=\")) {\n-                // For `no_run` tests, rustdoc passes a `--emit` flag; make sure it has the right shape.\n-                assert_eq!(env.args[i], \"--emit=metadata\");\n-            } else {\n-                // For all other kinds of tests, we can just add our flag.\n-                cmd.arg(\"--emit=metadata\");\n-            }\n-\n-            // Alter the `-o` parameter so that it does not overwrite the JSON file we stored above.\n-            let mut args = env.args.clone();\n-            for i in 0..args.len() {\n-                if args[i] == \"-o\" {\n-                    args[i + 1].push_str(\".miri\");\n-                }\n-            }\n-\n-            cmd.args(&args);\n-            cmd.env(\"MIRI_BE_RUSTC\", \"target\");\n-\n-            if verbose > 0 {\n-                eprintln!(\n-                    \"[cargo-miri rustc inside rustdoc] captured input:\\n{}\",\n-                    std::str::from_utf8(&env.stdin).unwrap()\n-                );\n-                eprintln!(\"[cargo-miri rustc inside rustdoc] going to run:\\n{:?}\", cmd);\n-            }\n-\n-            exec_with_pipe(cmd, &env.stdin, format!(\"{}.stdin\", out_filename(\"\", \"\").display()));\n-        }\n-\n-        return;\n-    }\n-\n-    if runnable_crate && ArgFlagValueIter::new(\"--extern\").any(|krate| krate == \"proc_macro\") {\n-        // This is a \"runnable\" `proc-macro` crate (unit tests). We do not support\n-        // interpreting that under Miri now, so we write a JSON file to (display a\n-        // helpful message and) skip it in the runner phase.\n-        store_json(CrateRunInfo::SkipProcMacroTest);\n-        return;\n-    }\n-\n-    let mut cmd = miri();\n-    let mut emit_link_hack = false;\n-    // Arguments are treated very differently depending on whether this crate is\n-    // for interpretation by Miri, or for use by a build script / proc macro.\n-    if !info_query && target_crate {\n-        // Forward arguments, but remove \"link\" from \"--emit\" to make this a check-only build.\n-        let emit_flag = \"--emit\";\n-        while let Some(arg) = args.next() {\n-            if let Some(val) = arg.strip_prefix(emit_flag) {\n-                // Patch this argument. First, extract its value.\n-                let val =\n-                    val.strip_prefix('=').expect(\"`cargo` should pass `--emit=X` as one argument\");\n-                let mut val: Vec<_> = val.split(',').collect();\n-                // Now make sure \"link\" is not in there, but \"metadata\" is.\n-                if let Some(i) = val.iter().position(|&s| s == \"link\") {\n-                    emit_link_hack = true;\n-                    val.remove(i);\n-                    if !val.iter().any(|&s| s == \"metadata\") {\n-                        val.push(\"metadata\");\n-                    }\n-                }\n-                cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n-            } else if arg == \"--extern\" {\n-                // Patch `--extern` filenames, since Cargo sometimes passes stub `.rlib` files:\n-                // https://github.com/rust-lang/miri/issues/1705\n-                forward_patched_extern_arg(&mut args, &mut cmd);\n-            } else {\n-                cmd.arg(arg);\n-            }\n-        }\n-\n-        // During setup, patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n-        if phase == RustcPhase::Setup\n-            && get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\")\n-        {\n-            cmd.arg(\"-C\").arg(\"panic=abort\");\n-        }\n-    } else {\n-        // For host crates (but not when we are just printing some info),\n-        // we might still have to set the sysroot.\n-        if !info_query {\n-            // When we're running `cargo-miri` from `x.py` we need to pass the sysroot explicitly\n-            // due to bootstrap complications.\n-            if let Some(sysroot) = std::env::var_os(\"MIRI_HOST_SYSROOT\") {\n-                cmd.arg(\"--sysroot\").arg(sysroot);\n-            }\n-        }\n-\n-        // For host crates or when we are printing, just forward everything.\n-        cmd.args(args);\n-    }\n-\n-    // We want to compile, not interpret. We still use Miri to make sure the compiler version etc\n-    // are the exact same as what is used for interpretation.\n-    // MIRI_DEFAULT_ARGS should not be used to build host crates, hence setting \"target\" or \"host\"\n-    // as the value here to help Miri differentiate them.\n-    cmd.env(\"MIRI_BE_RUSTC\", if target_crate { \"target\" } else { \"host\" });\n-\n-    // Run it.\n-    if verbose > 0 {\n-        eprintln!(\n-            \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} info_query={info_query}\"\n-        );\n-    }\n-\n-    // Create a stub .rlib file if \"link\" was requested by cargo.\n-    // This is necessary to prevent cargo from doing rebuilds all the time.\n-    if emit_link_hack {\n-        // Some platforms prepend \"lib\", some do not... let's just create both files.\n-        File::create(out_filename(\"lib\", \".rlib\")).expect(\"failed to create fake .rlib file\");\n-        File::create(out_filename(\"\", \".rlib\")).expect(\"failed to create fake .rlib file\");\n-        // Just in case this is a cdylib or staticlib, also create those fake files.\n-        File::create(out_filename(\"lib\", \".so\")).expect(\"failed to create fake .so file\");\n-        File::create(out_filename(\"lib\", \".a\")).expect(\"failed to create fake .a file\");\n-        File::create(out_filename(\"lib\", \".dylib\")).expect(\"failed to create fake .dylib file\");\n-        File::create(out_filename(\"\", \".dll\")).expect(\"failed to create fake .dll file\");\n-        File::create(out_filename(\"\", \".lib\")).expect(\"failed to create fake .lib file\");\n-    }\n-\n-    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n-    exec(cmd);\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq)]\n-enum RunnerPhase {\n-    /// `cargo` is running a binary\n-    Cargo,\n-    /// `rustdoc` is running a binary\n-    Rustdoc,\n-}\n-\n-fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhase) {\n-    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n-    // however, if we get called back by cargo here, we'll carefully compute the right flags\n-    // ourselves, so we first un-do what the earlier phase did.\n-    env::remove_var(\"MIRI_BE_RUSTC\");\n-\n-    let verbose = std::env::var(\"MIRI_VERBOSE\")\n-        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n-\n-    let binary = binary_args.next().unwrap();\n-    let file = File::open(&binary)\n-        .unwrap_or_else(|_| show_error(format!(\n-            \"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary\n-        )));\n-    let file = BufReader::new(file);\n-\n-    let info = serde_json::from_reader(file).unwrap_or_else(|_| {\n-        show_error(format!(\n-            \"file {:?} contains outdated or invalid JSON; try `cargo clean`\",\n-            binary\n-        ))\n-    });\n-    let info = match info {\n-        CrateRunInfo::RunWith(info) => info,\n-        CrateRunInfo::SkipProcMacroTest => {\n-            eprintln!(\n-                \"Running unit tests of `proc-macro` crates is not currently supported by Miri.\"\n-            );\n-            return;\n-        }\n-    };\n-\n-    let mut cmd = miri();\n-\n-    // Set missing env vars. We prefer build-time env vars over run-time ones; see\n-    // <https://github.com/rust-lang/miri/issues/1661> for the kind of issue that fixes.\n-    for (name, val) in info.env {\n-        if let Some(old_val) = env::var_os(&name) {\n-            if old_val == val {\n-                // This one did not actually change, no need to re-set it.\n-                // (This keeps the `debug_cmd` below more manageable.)\n-                continue;\n-            } else if verbose > 0 {\n-                eprintln!(\n-                    \"[cargo-miri runner] Overwriting run-time env var {:?}={:?} with build-time value {:?}\",\n-                    name, old_val, val\n-                );\n-            }\n-        }\n-        cmd.env(name, val);\n-    }\n-\n-    // Forward rustc arguments.\n-    // We need to patch \"--extern\" filenames because we forced a check-only\n-    // build without cargo knowing about that: replace `.rlib` suffix by\n-    // `.rmeta`.\n-    // We also need to remove `--error-format` as cargo specifies that to be JSON,\n-    // but when we run here, cargo does not interpret the JSON any more. `--json`\n-    // then also nees to be dropped.\n-    let mut args = info.args.into_iter();\n-    let error_format_flag = \"--error-format\";\n-    let json_flag = \"--json\";\n-    while let Some(arg) = args.next() {\n-        if arg == \"--extern\" {\n-            forward_patched_extern_arg(&mut args, &mut cmd);\n-        } else if let Some(suffix) = arg.strip_prefix(error_format_flag) {\n-            assert!(suffix.starts_with('='));\n-            // Drop this argument.\n-        } else if let Some(suffix) = arg.strip_prefix(json_flag) {\n-            assert!(suffix.starts_with('='));\n-            // Drop this argument.\n-        } else {\n-            cmd.arg(arg);\n-        }\n-    }\n-    // Respect `MIRIFLAGS`.\n-    if let Ok(a) = env::var(\"MIRIFLAGS\") {\n-        // This code is taken from `RUSTFLAGS` handling in cargo.\n-        let args = a.split(' ').map(str::trim).filter(|s| !s.is_empty()).map(str::to_string);\n-        cmd.args(args);\n-    }\n-\n-    // Then pass binary arguments.\n-    cmd.arg(\"--\");\n-    cmd.args(binary_args);\n-\n-    // Make sure we use the build-time working directory for interpreting Miri/rustc arguments.\n-    // But then we need to switch to the run-time one, which we instruct Miri do do by setting `MIRI_CWD`.\n-    cmd.current_dir(info.current_dir);\n-    cmd.env(\"MIRI_CWD\", env::current_dir().unwrap());\n-\n-    // Run it.\n-    debug_cmd(\"[cargo-miri runner]\", verbose, &cmd);\n-    match phase {\n-        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin, format!(\"{}.stdin\", binary)),\n-        RunnerPhase::Cargo => exec(cmd),\n-    }\n-}\n-\n-fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n-    let verbose = std::env::var(\"MIRI_VERBOSE\")\n-        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n-\n-    // phase_cargo_miri sets the RUSTDOC env var to ourselves, so we can't use that here;\n-    // just default to a straight-forward invocation for now:\n-    let mut cmd = Command::new(\"rustdoc\");\n-\n-    let extern_flag = \"--extern\";\n-    let runtool_flag = \"--runtool\";\n-    while let Some(arg) = args.next() {\n-        if arg == extern_flag {\n-            // Patch --extern arguments to use *.rmeta files, since phase_cargo_rustc only creates stub *.rlib files.\n-            forward_patched_extern_arg(&mut args, &mut cmd);\n-        } else if arg == runtool_flag {\n-            // An existing --runtool flag indicates cargo is running in cross-target mode, which we don't support.\n-            // Note that this is only passed when cargo is run with the unstable -Zdoctest-xcompile flag;\n-            // otherwise, we won't be called as rustdoc at all.\n-            show_error(format!(\"cross-interpreting doctests is not currently supported by Miri.\"));\n-        } else {\n-            cmd.arg(arg);\n-        }\n-    }\n-\n-    // Doctests of `proc-macro` crates (and their dependencies) are always built for the host,\n-    // so we are not able to run them in Miri.\n-    if ArgFlagValueIter::new(\"--crate-type\").any(|crate_type| crate_type == \"proc-macro\") {\n-        eprintln!(\"Running doctests of `proc-macro` crates is not currently supported by Miri.\");\n-        return;\n-    }\n-\n-    // For each doctest, rustdoc starts two child processes: first the test is compiled,\n-    // then the produced executable is invoked. We want to reroute both of these to cargo-miri,\n-    // such that the first time we'll enter phase_cargo_rustc, and phase_cargo_runner second.\n-    //\n-    // rustdoc invokes the test-builder by forwarding most of its own arguments, which makes\n-    // it difficult to determine when phase_cargo_rustc should run instead of phase_cargo_rustdoc.\n-    // Furthermore, the test code is passed via stdin, rather than a temporary file, so we need\n-    // to let phase_cargo_rustc know to expect that. We'll use this environment variable as a flag:\n-    cmd.env(\"MIRI_CALLED_FROM_RUSTDOC\", \"1\");\n-\n-    // The `--test-builder` and `--runtool` arguments are unstable rustdoc features,\n-    // which are disabled by default. We first need to enable them explicitly:\n-    cmd.arg(\"-Z\").arg(\"unstable-options\");\n-\n-    // rustdoc needs to know the right sysroot.\n-    cmd.arg(\"--sysroot\").arg(env::var_os(\"MIRI_SYSROOT\").unwrap());\n-    // make sure the 'miri' flag is set for rustdoc\n-    cmd.arg(\"--cfg\").arg(\"miri\");\n-\n-    // Make rustdoc call us back.\n-    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n-    cmd.arg(\"--test-builder\").arg(&cargo_miri_path); // invoked by forwarding most arguments\n-    cmd.arg(\"--runtool\").arg(&cargo_miri_path); // invoked with just a single path argument\n-\n-    debug_cmd(\"[cargo-miri rustdoc]\", verbose, &cmd);\n-    exec(cmd)\n-}\n-\n-fn main() {\n-    // Rustc does not support non-UTF-8 arguments so we make no attempt either.\n-    // (We do support non-UTF-8 environment variables though.)\n-    let mut args = std::env::args();\n-    // Skip binary name.\n-    args.next().unwrap();\n-\n-    // Dispatch to `cargo-miri` phase. There are four phases:\n-    // - When we are called via `cargo miri`, we run as the frontend and invoke the underlying\n-    //   cargo. We set RUSTDOC, RUSTC_WRAPPER and CARGO_TARGET_RUNNER to ourselves.\n-    // - When we are executed due to RUSTDOC, we run rustdoc and set both `--test-builder` and\n-    //   `--runtool` to ourselves.\n-    // - When we are executed due to RUSTC_WRAPPER (or as the rustdoc test builder), we build crates\n-    //   or store the flags of binary crates for later interpretation.\n-    // - When we are executed due to CARGO_TARGET_RUNNER (or as the rustdoc runtool), we start\n-    //   interpretation based on the flags that were stored earlier.\n-    //\n-    // Additionally, we also set ourselves as RUSTC when calling xargo to build the sysroot, which\n-    // has to be treated slightly differently than when we build regular crates.\n-\n-    // Dispatch running as part of sysroot compilation.\n-    if env::var_os(\"MIRI_CALLED_FROM_XARGO\").is_some() {\n-        phase_rustc(args, RustcPhase::Setup);\n-        return;\n-    }\n-\n-    // The way rustdoc invokes rustc is indistuingishable from the way cargo invokes rustdoc by the\n-    // arguments alone. `phase_cargo_rustdoc` sets this environment variable to let us disambiguate.\n-    if env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some() {\n-        // ...however, we then also see this variable when rustdoc invokes us as the testrunner!\n-        // The runner is invoked as `$runtool ($runtool-arg)* output_file`;\n-        // since we don't specify any runtool-args, and rustdoc supplies multiple arguments to\n-        // the test-builder unconditionally, we can just check the number of remaining arguments:\n-        if args.len() == 1 {\n-            phase_runner(args, RunnerPhase::Rustdoc);\n-        } else {\n-            phase_rustc(args, RustcPhase::Rustdoc);\n-        }\n-\n-        return;\n-    }\n-\n-    let Some(first) = args.next() else {\n-        show_error(format!(\n-            \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n-        ))\n-    };\n-    match first.as_str() {\n-        \"miri\" => phase_cargo_miri(args),\n-        \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n-        arg if arg == env::var(\"RUSTC\").unwrap() => {\n-            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n-            // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n-            // behavior of having both RUSTC and RUSTC_WRAPPER set\n-            // (see https://github.com/rust-lang/cargo/issues/10886).\n-            phase_rustc(args, RustcPhase::Build)\n-        }\n-        _ => {\n-            // Everything else must be rustdoc. But we need to get `first` \"back onto the iterator\",\n-            // it is some part of the rustdoc invocation.\n-            phase_rustdoc(iter::once(first).chain(args));\n-        }\n-    }\n-}"}, {"sha": "9c07f90a407824c87d53a92c07795df086ae1ac6", "filename": "cargo-miri/src/main.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fmain.rs?ref=730a799bf4830ce0dea063c59255bf4a03264771", "patch": "@@ -0,0 +1,95 @@\n+#![feature(let_else)]\n+#![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq)]\n+\n+mod phases;\n+mod setup;\n+mod util;\n+mod version;\n+\n+use std::{env, iter};\n+\n+use crate::{phases::*, util::*};\n+\n+fn main() {\n+    // Rustc does not support non-UTF-8 arguments so we make no attempt either.\n+    // (We do support non-UTF-8 environment variables though.)\n+    let mut args = std::env::args();\n+    // Skip binary name.\n+    args.next().unwrap();\n+\n+    // Dispatch to `cargo-miri` phase. Here is a rough idea of \"who calls who\".\n+    //\n+    // Initially, we are invoked as `cargo-miri miri run/test`. We first run the setup phase:\n+    // - We call `xargo`, and set `RUSTC` back to us, together with `MIRI_CALLED_FROM_XARGO`,\n+    //   so that xargo's rustc invocations end up in `phase_rustc` with `RustcPhase::Setup`.\n+    //   There we then call the Miri driver with `MIRI_BE_RUSTC` to perform the actual build.\n+    //\n+    // Then we call `cargo run/test`, exactly forwarding all user flags, plus some configuration so\n+    // that we control every binary invoked by cargo:\n+    // - We set RUSTC_WRAPPER to ourselves, so for (almost) all rustc invocations, we end up in\n+    //   `phase_rustc` with `RustcPhase::Build`. This will in turn either determine that a\n+    //   dependency needs to be built (for which it invokes the Miri driver with `MIRI_BE_RUSTC`),\n+    //   or determine that this is a binary Miri should run, in which case we generate a JSON file\n+    //   with all the information needed to build and run this crate.\n+    //   (We don't run it yet since cargo thinks this is a build step, not a run step -- running the\n+    //   binary here would lead to a bad user experience.)\n+    // - We set RUSTC to the Miri driver and also set `MIRI_BE_RUSTC`, so that gets called by build\n+    //   scripts (and cargo uses it for the version query).\n+    // - We set `target.*.runner` to `cargo-miri runner`, which ends up calling `phase_runner` for\n+    //   `RunnerPhase::Cargo`. This parses the JSON file written in `phase_rustc` and then invokes\n+    //   the actual Miri driver for interpretation.\n+    // - We set RUSTDOC to ourselves, which ends up in `phase_rustdoc`. There we call regular\n+    //   rustdoc with some extra flags, and we set `MIRI_CALLED_FROM_RUSTDOC` to recognize this\n+    //   phase in our recursive invocations:\n+    //   - We set the `--test-builder` flag of rustdoc to ourselves, which ends up in `phase_rustc`\n+    //     with `RustcPhase::Rustdoc`. There we perform a check-build (needed to get the expected\n+    //     build failures for `compile_fail` doctests) and then store a JSON file with the\n+    //     information needed to run this test.\n+    //   - We also set `--runtool` to ourselves, which ends up in `phase_runner` with\n+    //     `RunnerPhase::Rustdoc`. There we parse the JSON file written in `phase_rustc` and invoke\n+    //     the Miri driver for interpretation.\n+\n+    // Dispatch running as part of sysroot compilation.\n+    if env::var_os(\"MIRI_CALLED_FROM_XARGO\").is_some() {\n+        phase_rustc(args, RustcPhase::Setup);\n+        return;\n+    }\n+\n+    // The way rustdoc invokes rustc is indistuingishable from the way cargo invokes rustdoc by the\n+    // arguments alone. `phase_cargo_rustdoc` sets this environment variable to let us disambiguate.\n+    if env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some() {\n+        // ...however, we then also see this variable when rustdoc invokes us as the testrunner!\n+        // The runner is invoked as `$runtool ($runtool-arg)* output_file`;\n+        // since we don't specify any runtool-args, and rustdoc supplies multiple arguments to\n+        // the test-builder unconditionally, we can just check the number of remaining arguments:\n+        if args.len() == 1 {\n+            phase_runner(args, RunnerPhase::Rustdoc);\n+        } else {\n+            phase_rustc(args, RustcPhase::Rustdoc);\n+        }\n+\n+        return;\n+    }\n+\n+    let Some(first) = args.next() else {\n+        show_error(format!(\n+            \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n+        ))\n+    };\n+    match first.as_str() {\n+        \"miri\" => phase_cargo_miri(args),\n+        \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n+        arg if arg == env::var(\"RUSTC\").unwrap() => {\n+            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n+            // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n+            // behavior of having both RUSTC and RUSTC_WRAPPER set\n+            // (see https://github.com/rust-lang/cargo/issues/10886).\n+            phase_rustc(args, RustcPhase::Build)\n+        }\n+        _ => {\n+            // Everything else must be rustdoc. But we need to get `first` \"back onto the iterator\",\n+            // it is some part of the rustdoc invocation.\n+            phase_rustdoc(iter::once(first).chain(args));\n+        }\n+    }\n+}"}, {"sha": "4ba627de482cfb3118ca568e02a56190738c19b3", "filename": "cargo-miri/src/phases.rs", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fphases.rs?ref=730a799bf4830ce0dea063c59255bf4a03264771", "patch": "@@ -0,0 +1,601 @@\n+//! Implements the various phases of `cargo miri run/test`.\n+\n+use std::env;\n+use std::fmt::Write as _;\n+use std::fs::{self, File};\n+use std::io::BufReader;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+use crate::{setup::*, util::*};\n+\n+const CARGO_MIRI_HELP: &str = r#\"Runs binary crates and tests in Miri\n+\n+Usage:\n+    cargo miri [subcommand] [<cargo options>...] [--] [<program/test suite options>...]\n+\n+Subcommands:\n+    run, r                   Run binaries\n+    test, t                  Run tests\n+    nextest                  Run tests with nextest (requires cargo-nextest installed)\n+    setup                    Only perform automatic setup, but without asking questions (for getting a proper libstd)\n+\n+The cargo options are exactly the same as for `cargo run` and `cargo test`, respectively.\n+\n+Examples:\n+    cargo miri run\n+    cargo miri test -- test-suite-filter\n+\n+    cargo miri setup --print sysroot\n+        This will print the path to the generated sysroot (and nothing else) on stdout.\n+        stderr will still contain progress information about how the build is doing.\n+\n+\"#;\n+\n+fn show_help() {\n+    println!(\"{}\", CARGO_MIRI_HELP);\n+}\n+\n+fn show_version() {\n+    let mut version = format!(\"miri {}\", env!(\"CARGO_PKG_VERSION\"));\n+    // Only use `option_env` on vergen variables to ensure the build succeeds\n+    // when vergen failed to find the git info.\n+    if let Some(sha) = option_env!(\"VERGEN_GIT_SHA_SHORT\") {\n+        // This `unwrap` can never fail because if VERGEN_GIT_SHA_SHORT exists, then so does\n+        // VERGEN_GIT_COMMIT_DATE.\n+        #[allow(clippy::option_env_unwrap)]\n+        write!(&mut version, \" ({} {})\", sha, option_env!(\"VERGEN_GIT_COMMIT_DATE\").unwrap())\n+            .unwrap();\n+    }\n+    println!(\"{}\", version);\n+}\n+\n+fn forward_patched_extern_arg(args: &mut impl Iterator<Item = String>, cmd: &mut Command) {\n+    cmd.arg(\"--extern\"); // always forward flag, but adjust filename:\n+    let path = args.next().expect(\"`--extern` should be followed by a filename\");\n+    if let Some(lib) = path.strip_suffix(\".rlib\") {\n+        // If this is an rlib, make it an rmeta.\n+        cmd.arg(format!(\"{}.rmeta\", lib));\n+    } else {\n+        // Some other extern file (e.g. a `.so`). Forward unchanged.\n+        cmd.arg(path);\n+    }\n+}\n+\n+pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n+    // Check for version and help flags even when invoked as `cargo-miri`.\n+    if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n+        show_help();\n+        return;\n+    }\n+    if has_arg_flag(\"--version\") || has_arg_flag(\"-V\") {\n+        show_version();\n+        return;\n+    }\n+\n+    // Require a subcommand before any flags.\n+    // We cannot know which of those flags take arguments and which do not,\n+    // so we cannot detect subcommands later.\n+    let Some(subcommand) = args.next() else {\n+        show_error(format!(\"`cargo miri` needs to be called with a subcommand (`run`, `test`)\"));\n+    };\n+    let subcommand = match &*subcommand {\n+        \"setup\" => MiriCommand::Setup,\n+        \"test\" | \"t\" | \"run\" | \"r\" | \"nextest\" => MiriCommand::Forward(subcommand),\n+        _ =>\n+            show_error(format!(\n+                \"`cargo miri` supports the following subcommands: `run`, `test`, `nextest`, and `setup`.\"\n+            )),\n+    };\n+    let verbose = num_arg_flag(\"-v\");\n+\n+    // Determine the involved architectures.\n+    let host = version_info().host;\n+    let target = get_arg_flag_value(\"--target\");\n+    let target = target.as_ref().unwrap_or(&host);\n+\n+    // We always setup.\n+    setup(&subcommand, &host, target);\n+\n+    // Invoke actual cargo for the job, but with different flags.\n+    // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n+    // requires some extra work to make the build check-only (see all the `--emit` hacks below).\n+    // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n+    // approach that uses `cargo check`, making that part easier but target and binary handling\n+    // harder.\n+    let cargo_miri_path = std::env::current_exe()\n+        .expect(\"current executable path invalid\")\n+        .into_os_string()\n+        .into_string()\n+        .expect(\"current executable path is not valid UTF-8\");\n+    let cargo_cmd = match subcommand {\n+        MiriCommand::Forward(s) => s,\n+        MiriCommand::Setup => return, // `cargo miri setup` stops here.\n+    };\n+    let metadata = get_cargo_metadata();\n+    let mut cmd = cargo();\n+    cmd.arg(cargo_cmd);\n+\n+    // Forward all arguments before `--` other than `--target-dir` and its value to Cargo.\n+    let mut target_dir = None;\n+    for arg in ArgSplitFlagValue::new(&mut args, \"--target-dir\") {\n+        match arg {\n+            Ok(value) => {\n+                if target_dir.is_some() {\n+                    show_error(format!(\"`--target-dir` is provided more than once\"));\n+                }\n+                target_dir = Some(value.into());\n+            }\n+            Err(arg) => {\n+                cmd.arg(arg);\n+            }\n+        }\n+    }\n+    // Detect the target directory if it's not specified via `--target-dir`.\n+    let target_dir = target_dir.get_or_insert_with(|| metadata.target_directory.clone());\n+    // Set `--target-dir` to `miri` inside the original target directory.\n+    target_dir.push(\"miri\");\n+    cmd.arg(\"--target-dir\").arg(target_dir);\n+\n+    // Make sure the build target is explicitly set.\n+    // This is needed to make the `target.runner` settings do something,\n+    // and it later helps us detect which crates are proc-macro/build-script\n+    // (host crates) and which crates are needed for the program itself.\n+    if get_arg_flag_value(\"--target\").is_none() {\n+        // No target given. Explicitly pick the host.\n+        cmd.arg(\"--target\");\n+        cmd.arg(&host);\n+    }\n+\n+    // Set ourselves as runner for al binaries invoked by cargo.\n+    // We use `all()` since `true` is not a thing in cfg-lang, but the empty conjunction is. :)\n+    let cargo_miri_path_for_toml = escape_for_toml(&cargo_miri_path);\n+    cmd.arg(\"--config\")\n+        .arg(format!(\"target.'cfg(all())'.runner=[{cargo_miri_path_for_toml}, 'runner']\"));\n+\n+    // Forward all further arguments after `--` to cargo.\n+    cmd.arg(\"--\").args(args);\n+\n+    // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n+    // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n+    // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n+    if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n+        println!(\n+            \"WARNING: Ignoring `RUSTC_WRAPPER` environment variable, Miri does not support wrapping.\"\n+        );\n+    }\n+    cmd.env(\"RUSTC_WRAPPER\", &cargo_miri_path);\n+    // We are going to invoke `MIRI` for everything, not `RUSTC`.\n+    if env::var_os(\"RUSTC\").is_some() && env::var_os(\"MIRI\").is_none() {\n+        println!(\n+            \"WARNING: Ignoring `RUSTC` environment variable; set `MIRI` if you want to control the binary used as the driver.\"\n+        );\n+    }\n+    // Build scripts (and also cargo: https://github.com/rust-lang/cargo/issues/10885) will invoke\n+    // `rustc` even when `RUSTC_WRAPPER` is set. To make sure everything is coherent, we want that\n+    // to be the Miri driver, but acting as rustc, on the target level. (Target, rather than host,\n+    // is needed for cross-interpretation situations.) This is not a perfect emulation of real rustc\n+    // (it might be unable to produce binaries since the sysroot is check-only), but it's as close\n+    // as we can get, and it's good enough for autocfg.\n+    //\n+    // In `main`, we need the value of `RUSTC` to distinguish RUSTC_WRAPPER invocations from rustdoc\n+    // or TARGET_RUNNER invocations, so we canonicalize it here to make it exceedingly unlikely that\n+    // there would be a collision with other invocations of cargo-miri (as rustdoc or as runner). We\n+    // explicitly do this even if RUSTC_STAGE is set, since for these builds we do *not* want the\n+    // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host\n+    // builds.\n+    cmd.env(\"RUSTC\", &fs::canonicalize(find_miri()).unwrap());\n+    cmd.env(\"MIRI_BE_RUSTC\", \"target\"); // we better remember to *unset* this in the other phases!\n+\n+    // Set rustdoc to us as well, so we can run doctests.\n+    cmd.env(\"RUSTDOC\", &cargo_miri_path);\n+\n+    cmd.env(\"MIRI_LOCAL_CRATES\", local_crates(&metadata));\n+    if verbose > 0 {\n+        cmd.env(\"MIRI_VERBOSE\", verbose.to_string()); // This makes the other phases verbose.\n+    }\n+\n+    // Run cargo.\n+    debug_cmd(\"[cargo-miri miri]\", verbose, &cmd);\n+    exec(cmd)\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum RustcPhase {\n+    /// `rustc` called via `xargo` for sysroot build.\n+    Setup,\n+    /// `rustc` called by `cargo` for regular build.\n+    Build,\n+    /// `rustc` called by `rustdoc` for doctest.\n+    Rustdoc,\n+}\n+\n+pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n+    /// Determines if we are being invoked (as rustc) to build a crate for\n+    /// the \"target\" architecture, in contrast to the \"host\" architecture.\n+    /// Host crates are for build scripts and proc macros and still need to\n+    /// be built like normal; target crates need to be built for or interpreted\n+    /// by Miri.\n+    ///\n+    /// Currently, we detect this by checking for \"--target=\", which is\n+    /// never set for host crates. This matches what rustc bootstrap does,\n+    /// which hopefully makes it \"reliable enough\". This relies on us always\n+    /// invoking cargo itself with `--target`, which `in_cargo_miri` ensures.\n+    fn is_target_crate() -> bool {\n+        get_arg_flag_value(\"--target\").is_some()\n+    }\n+\n+    /// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n+    /// the final, binary crate (either a test for 'cargo test', or a binary for 'cargo run')\n+    /// Cargo does not give us this information directly, so we need to check\n+    /// various command-line flags.\n+    fn is_runnable_crate() -> bool {\n+        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref().unwrap_or(\"bin\") == \"bin\";\n+        let is_test = has_arg_flag(\"--test\");\n+        is_bin || is_test\n+    }\n+\n+    fn out_filename(prefix: &str, suffix: &str) -> PathBuf {\n+        if let Some(out_dir) = get_arg_flag_value(\"--out-dir\") {\n+            let mut path = PathBuf::from(out_dir);\n+            path.push(format!(\n+                \"{}{}{}{}\",\n+                prefix,\n+                get_arg_flag_value(\"--crate-name\").unwrap(),\n+                // This is technically a `-C` flag but the prefix seems unique enough...\n+                // (and cargo passes this before the filename so it should be unique)\n+                get_arg_flag_value(\"extra-filename\").unwrap_or_default(),\n+                suffix,\n+            ));\n+            path\n+        } else {\n+            let out_file = get_arg_flag_value(\"-o\").unwrap();\n+            PathBuf::from(out_file)\n+        }\n+    }\n+\n+    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n+    // however, if we get called back by cargo here, we'll carefully compute the right flags\n+    // ourselves, so we first un-do what the earlier phase did.\n+    env::remove_var(\"MIRI_BE_RUSTC\");\n+\n+    let verbose = std::env::var(\"MIRI_VERBOSE\")\n+        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n+    let target_crate = is_target_crate();\n+    // Determine whether this is cargo/xargo invoking rustc to get some infos.\n+    let info_query = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\");\n+\n+    let store_json = |info: CrateRunInfo| {\n+        // Create a stub .d file to stop Cargo from \"rebuilding\" the crate:\n+        // https://github.com/rust-lang/miri/issues/1724#issuecomment-787115693\n+        // As we store a JSON file instead of building the crate here, an empty file is fine.\n+        let dep_info_name = out_filename(\"\", \".d\");\n+        if verbose > 0 {\n+            eprintln!(\"[cargo-miri rustc] writing stub dep-info to `{}`\", dep_info_name.display());\n+        }\n+        File::create(dep_info_name).expect(\"failed to create fake .d file\");\n+\n+        let filename = out_filename(\"\", \"\");\n+        if verbose > 0 {\n+            eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n+        }\n+        info.store(&filename);\n+        // For Windows, do the same thing again with `.exe` appended to the filename.\n+        // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n+        info.store(&out_filename(\"\", \".exe\"));\n+    };\n+\n+    let runnable_crate = !info_query && is_runnable_crate();\n+\n+    if runnable_crate && target_crate {\n+        assert!(\n+            phase != RustcPhase::Setup,\n+            \"there should be no interpretation during sysroot build\"\n+        );\n+        let inside_rustdoc = phase == RustcPhase::Rustdoc;\n+        // This is the binary or test crate that we want to interpret under Miri.\n+        // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n+        // like we want them.\n+        // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n+        // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n+        let env = CrateRunEnv::collect(args, inside_rustdoc);\n+\n+        store_json(CrateRunInfo::RunWith(env.clone()));\n+\n+        // Rustdoc expects us to exit with an error code if the test is marked as `compile_fail`,\n+        // just creating the JSON file is not enough: we need to detect syntax errors,\n+        // so we need to run Miri with `MIRI_BE_RUSTC` for a check-only build.\n+        if inside_rustdoc {\n+            let mut cmd = miri();\n+\n+            // Ensure --emit argument for a check-only build is present.\n+            // We cannot use the usual helpers since we need to check specifically in `env.args`.\n+            if let Some(i) = env.args.iter().position(|arg| arg.starts_with(\"--emit=\")) {\n+                // For `no_run` tests, rustdoc passes a `--emit` flag; make sure it has the right shape.\n+                assert_eq!(env.args[i], \"--emit=metadata\");\n+            } else {\n+                // For all other kinds of tests, we can just add our flag.\n+                cmd.arg(\"--emit=metadata\");\n+            }\n+\n+            // Alter the `-o` parameter so that it does not overwrite the JSON file we stored above.\n+            let mut args = env.args.clone();\n+            for i in 0..args.len() {\n+                if args[i] == \"-o\" {\n+                    args[i + 1].push_str(\".miri\");\n+                }\n+            }\n+\n+            cmd.args(&args);\n+            cmd.env(\"MIRI_BE_RUSTC\", \"target\");\n+\n+            if verbose > 0 {\n+                eprintln!(\n+                    \"[cargo-miri rustc inside rustdoc] captured input:\\n{}\",\n+                    std::str::from_utf8(&env.stdin).unwrap()\n+                );\n+                eprintln!(\"[cargo-miri rustc inside rustdoc] going to run:\\n{:?}\", cmd);\n+            }\n+\n+            exec_with_pipe(cmd, &env.stdin, format!(\"{}.stdin\", out_filename(\"\", \"\").display()));\n+        }\n+\n+        return;\n+    }\n+\n+    if runnable_crate && ArgFlagValueIter::new(\"--extern\").any(|krate| krate == \"proc_macro\") {\n+        // This is a \"runnable\" `proc-macro` crate (unit tests). We do not support\n+        // interpreting that under Miri now, so we write a JSON file to (display a\n+        // helpful message and) skip it in the runner phase.\n+        store_json(CrateRunInfo::SkipProcMacroTest);\n+        return;\n+    }\n+\n+    let mut cmd = miri();\n+    let mut emit_link_hack = false;\n+    // Arguments are treated very differently depending on whether this crate is\n+    // for interpretation by Miri, or for use by a build script / proc macro.\n+    if !info_query && target_crate {\n+        // Forward arguments, but remove \"link\" from \"--emit\" to make this a check-only build.\n+        let emit_flag = \"--emit\";\n+        while let Some(arg) = args.next() {\n+            if let Some(val) = arg.strip_prefix(emit_flag) {\n+                // Patch this argument. First, extract its value.\n+                let val =\n+                    val.strip_prefix('=').expect(\"`cargo` should pass `--emit=X` as one argument\");\n+                let mut val: Vec<_> = val.split(',').collect();\n+                // Now make sure \"link\" is not in there, but \"metadata\" is.\n+                if let Some(i) = val.iter().position(|&s| s == \"link\") {\n+                    emit_link_hack = true;\n+                    val.remove(i);\n+                    if !val.iter().any(|&s| s == \"metadata\") {\n+                        val.push(\"metadata\");\n+                    }\n+                }\n+                cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n+            } else if arg == \"--extern\" {\n+                // Patch `--extern` filenames, since Cargo sometimes passes stub `.rlib` files:\n+                // https://github.com/rust-lang/miri/issues/1705\n+                forward_patched_extern_arg(&mut args, &mut cmd);\n+            } else {\n+                cmd.arg(arg);\n+            }\n+        }\n+\n+        // During setup, patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n+        if phase == RustcPhase::Setup\n+            && get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\")\n+        {\n+            cmd.arg(\"-C\").arg(\"panic=abort\");\n+        }\n+    } else {\n+        // For host crates (but not when we are just printing some info),\n+        // we might still have to set the sysroot.\n+        if !info_query {\n+            // When we're running `cargo-miri` from `x.py` we need to pass the sysroot explicitly\n+            // due to bootstrap complications.\n+            if let Some(sysroot) = std::env::var_os(\"MIRI_HOST_SYSROOT\") {\n+                cmd.arg(\"--sysroot\").arg(sysroot);\n+            }\n+        }\n+\n+        // For host crates or when we are printing, just forward everything.\n+        cmd.args(args);\n+    }\n+\n+    // We want to compile, not interpret. We still use Miri to make sure the compiler version etc\n+    // are the exact same as what is used for interpretation.\n+    // MIRI_DEFAULT_ARGS should not be used to build host crates, hence setting \"target\" or \"host\"\n+    // as the value here to help Miri differentiate them.\n+    cmd.env(\"MIRI_BE_RUSTC\", if target_crate { \"target\" } else { \"host\" });\n+\n+    // Run it.\n+    if verbose > 0 {\n+        eprintln!(\n+            \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} info_query={info_query}\"\n+        );\n+    }\n+\n+    // Create a stub .rlib file if \"link\" was requested by cargo.\n+    // This is necessary to prevent cargo from doing rebuilds all the time.\n+    if emit_link_hack {\n+        // Some platforms prepend \"lib\", some do not... let's just create both files.\n+        File::create(out_filename(\"lib\", \".rlib\")).expect(\"failed to create fake .rlib file\");\n+        File::create(out_filename(\"\", \".rlib\")).expect(\"failed to create fake .rlib file\");\n+        // Just in case this is a cdylib or staticlib, also create those fake files.\n+        File::create(out_filename(\"lib\", \".so\")).expect(\"failed to create fake .so file\");\n+        File::create(out_filename(\"lib\", \".a\")).expect(\"failed to create fake .a file\");\n+        File::create(out_filename(\"lib\", \".dylib\")).expect(\"failed to create fake .dylib file\");\n+        File::create(out_filename(\"\", \".dll\")).expect(\"failed to create fake .dll file\");\n+        File::create(out_filename(\"\", \".lib\")).expect(\"failed to create fake .lib file\");\n+    }\n+\n+    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n+    exec(cmd);\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum RunnerPhase {\n+    /// `cargo` is running a binary\n+    Cargo,\n+    /// `rustdoc` is running a binary\n+    Rustdoc,\n+}\n+\n+pub fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhase) {\n+    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n+    // however, if we get called back by cargo here, we'll carefully compute the right flags\n+    // ourselves, so we first un-do what the earlier phase did.\n+    env::remove_var(\"MIRI_BE_RUSTC\");\n+\n+    let verbose = std::env::var(\"MIRI_VERBOSE\")\n+        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n+\n+    let binary = binary_args.next().unwrap();\n+    let file = File::open(&binary)\n+        .unwrap_or_else(|_| show_error(format!(\n+            \"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary\n+        )));\n+    let file = BufReader::new(file);\n+\n+    let info = serde_json::from_reader(file).unwrap_or_else(|_| {\n+        show_error(format!(\n+            \"file {:?} contains outdated or invalid JSON; try `cargo clean`\",\n+            binary\n+        ))\n+    });\n+    let info = match info {\n+        CrateRunInfo::RunWith(info) => info,\n+        CrateRunInfo::SkipProcMacroTest => {\n+            eprintln!(\n+                \"Running unit tests of `proc-macro` crates is not currently supported by Miri.\"\n+            );\n+            return;\n+        }\n+    };\n+\n+    let mut cmd = miri();\n+\n+    // Set missing env vars. We prefer build-time env vars over run-time ones; see\n+    // <https://github.com/rust-lang/miri/issues/1661> for the kind of issue that fixes.\n+    for (name, val) in info.env {\n+        if let Some(old_val) = env::var_os(&name) {\n+            if old_val == val {\n+                // This one did not actually change, no need to re-set it.\n+                // (This keeps the `debug_cmd` below more manageable.)\n+                continue;\n+            } else if verbose > 0 {\n+                eprintln!(\n+                    \"[cargo-miri runner] Overwriting run-time env var {:?}={:?} with build-time value {:?}\",\n+                    name, old_val, val\n+                );\n+            }\n+        }\n+        cmd.env(name, val);\n+    }\n+\n+    // Forward rustc arguments.\n+    // We need to patch \"--extern\" filenames because we forced a check-only\n+    // build without cargo knowing about that: replace `.rlib` suffix by\n+    // `.rmeta`.\n+    // We also need to remove `--error-format` as cargo specifies that to be JSON,\n+    // but when we run here, cargo does not interpret the JSON any more. `--json`\n+    // then also nees to be dropped.\n+    let mut args = info.args.into_iter();\n+    let error_format_flag = \"--error-format\";\n+    let json_flag = \"--json\";\n+    while let Some(arg) = args.next() {\n+        if arg == \"--extern\" {\n+            forward_patched_extern_arg(&mut args, &mut cmd);\n+        } else if let Some(suffix) = arg.strip_prefix(error_format_flag) {\n+            assert!(suffix.starts_with('='));\n+            // Drop this argument.\n+        } else if let Some(suffix) = arg.strip_prefix(json_flag) {\n+            assert!(suffix.starts_with('='));\n+            // Drop this argument.\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+    // Respect `MIRIFLAGS`.\n+    if let Ok(a) = env::var(\"MIRIFLAGS\") {\n+        // This code is taken from `RUSTFLAGS` handling in cargo.\n+        let args = a.split(' ').map(str::trim).filter(|s| !s.is_empty()).map(str::to_string);\n+        cmd.args(args);\n+    }\n+\n+    // Then pass binary arguments.\n+    cmd.arg(\"--\");\n+    cmd.args(binary_args);\n+\n+    // Make sure we use the build-time working directory for interpreting Miri/rustc arguments.\n+    // But then we need to switch to the run-time one, which we instruct Miri do do by setting `MIRI_CWD`.\n+    cmd.current_dir(info.current_dir);\n+    cmd.env(\"MIRI_CWD\", env::current_dir().unwrap());\n+\n+    // Run it.\n+    debug_cmd(\"[cargo-miri runner]\", verbose, &cmd);\n+    match phase {\n+        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin, format!(\"{}.stdin\", binary)),\n+        RunnerPhase::Cargo => exec(cmd),\n+    }\n+}\n+\n+pub fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n+    let verbose = std::env::var(\"MIRI_VERBOSE\")\n+        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n+\n+    // phase_cargo_miri sets the RUSTDOC env var to ourselves, so we can't use that here;\n+    // just default to a straight-forward invocation for now:\n+    let mut cmd = Command::new(\"rustdoc\");\n+\n+    let extern_flag = \"--extern\";\n+    let runtool_flag = \"--runtool\";\n+    while let Some(arg) = args.next() {\n+        if arg == extern_flag {\n+            // Patch --extern arguments to use *.rmeta files, since phase_cargo_rustc only creates stub *.rlib files.\n+            forward_patched_extern_arg(&mut args, &mut cmd);\n+        } else if arg == runtool_flag {\n+            // An existing --runtool flag indicates cargo is running in cross-target mode, which we don't support.\n+            // Note that this is only passed when cargo is run with the unstable -Zdoctest-xcompile flag;\n+            // otherwise, we won't be called as rustdoc at all.\n+            show_error(format!(\"cross-interpreting doctests is not currently supported by Miri.\"));\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+\n+    // Doctests of `proc-macro` crates (and their dependencies) are always built for the host,\n+    // so we are not able to run them in Miri.\n+    if ArgFlagValueIter::new(\"--crate-type\").any(|crate_type| crate_type == \"proc-macro\") {\n+        eprintln!(\"Running doctests of `proc-macro` crates is not currently supported by Miri.\");\n+        return;\n+    }\n+\n+    // For each doctest, rustdoc starts two child processes: first the test is compiled,\n+    // then the produced executable is invoked. We want to reroute both of these to cargo-miri,\n+    // such that the first time we'll enter phase_cargo_rustc, and phase_cargo_runner second.\n+    //\n+    // rustdoc invokes the test-builder by forwarding most of its own arguments, which makes\n+    // it difficult to determine when phase_cargo_rustc should run instead of phase_cargo_rustdoc.\n+    // Furthermore, the test code is passed via stdin, rather than a temporary file, so we need\n+    // to let phase_cargo_rustc know to expect that. We'll use this environment variable as a flag:\n+    cmd.env(\"MIRI_CALLED_FROM_RUSTDOC\", \"1\");\n+\n+    // The `--test-builder` and `--runtool` arguments are unstable rustdoc features,\n+    // which are disabled by default. We first need to enable them explicitly:\n+    cmd.arg(\"-Z\").arg(\"unstable-options\");\n+\n+    // rustdoc needs to know the right sysroot.\n+    cmd.arg(\"--sysroot\").arg(env::var_os(\"MIRI_SYSROOT\").unwrap());\n+    // make sure the 'miri' flag is set for rustdoc\n+    cmd.arg(\"--cfg\").arg(\"miri\");\n+\n+    // Make rustdoc call us back.\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    cmd.arg(\"--test-builder\").arg(&cargo_miri_path); // invoked by forwarding most arguments\n+    cmd.arg(\"--runtool\").arg(&cargo_miri_path); // invoked with just a single path argument\n+\n+    debug_cmd(\"[cargo-miri rustdoc]\", verbose, &cmd);\n+    exec(cmd)\n+}"}, {"sha": "1211b47e3ba241a2f33ad54d4d6b64c6319f0f20", "filename": "cargo-miri/src/setup.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fsetup.rs?ref=730a799bf4830ce0dea063c59255bf4a03264771", "patch": "@@ -0,0 +1,247 @@\n+//! Implements `cargo miri setup` via xargo\n+\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs::{self};\n+use std::io::BufRead;\n+use std::ops::Not;\n+use std::path::{Path, PathBuf};\n+use std::process::{self, Command};\n+\n+use crate::{util::*, version::*};\n+\n+fn xargo_version() -> Option<(u32, u32, u32)> {\n+    let out = xargo_check().arg(\"--version\").output().ok()?;\n+    if !out.status.success() {\n+        return None;\n+    }\n+    // Parse output. The first line looks like \"xargo 0.3.12 (b004f1c 2018-12-13)\".\n+    let line = out\n+        .stderr\n+        .lines()\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not at least one line\")\n+        .expect(\"malformed `xargo --version` output: error reading first line\");\n+    let (name, version) = {\n+        let mut split = line.split(' ');\n+        (\n+            split.next().expect(\"malformed `xargo --version` output: empty\"),\n+            split.next().expect(\"malformed `xargo --version` output: not at least two words\"),\n+        )\n+    };\n+    if name != \"xargo\" {\n+        // This is some fork of xargo\n+        return None;\n+    }\n+    let mut version_pieces = version.split('.');\n+    let major = version_pieces\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not a major version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: major version is not an integer\");\n+    let minor = version_pieces\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not a minor version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: minor version is not an integer\");\n+    let patch = version_pieces\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not a patch version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: patch version is not an integer\");\n+    if version_pieces.next().is_some() {\n+        panic!(\"malformed `xargo --version` output: more than three pieces in version\");\n+    }\n+    Some((major, minor, patch))\n+}\n+\n+/// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n+/// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n+/// done all this already.\n+pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n+    let only_setup = matches!(subcommand, MiriCommand::Setup);\n+    let ask_user = !only_setup;\n+    let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n+    if std::env::var_os(\"MIRI_SYSROOT\").is_some() {\n+        if only_setup {\n+            println!(\"WARNING: MIRI_SYSROOT already set, not doing anything.\")\n+        }\n+        return;\n+    }\n+\n+    // First, we need xargo.\n+    if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n+        if std::env::var_os(\"XARGO_CHECK\").is_some() {\n+            // The user manually gave us a xargo binary; don't do anything automatically.\n+            show_error(format!(\"xargo is too old; please upgrade to the latest version\"))\n+        }\n+        let mut cmd = cargo();\n+        cmd.args(&[\"install\", \"xargo\"]);\n+        ask_to_run(cmd, ask_user, \"install a recent enough xargo\");\n+    }\n+\n+    // Determine where the rust sources are located.  The env vars manually setting the source\n+    // (`MIRI_LIB_SRC`, `XARGO_RUST_SRC`) trump auto-detection.\n+    let rust_src_env_var =\n+        std::env::var_os(\"MIRI_LIB_SRC\").or_else(|| std::env::var_os(\"XARGO_RUST_SRC\"));\n+    let rust_src = match rust_src_env_var {\n+        Some(path) => {\n+            let path = PathBuf::from(path);\n+            // Make path absolute if possible.\n+            path.canonicalize().unwrap_or(path)\n+        }\n+        None => {\n+            // Check for `rust-src` rustup component.\n+            let output = miri_for_host()\n+                .args(&[\"--print\", \"sysroot\"])\n+                .output()\n+                .expect(\"failed to determine sysroot\");\n+            if !output.status.success() {\n+                show_error(format!(\n+                    \"Failed to determine sysroot; Miri said:\\n{}\",\n+                    String::from_utf8_lossy(&output.stderr).trim_end()\n+                ));\n+            }\n+            let sysroot = std::str::from_utf8(&output.stdout).unwrap();\n+            let sysroot = Path::new(sysroot.trim_end_matches('\\n'));\n+            // Check for `$SYSROOT/lib/rustlib/src/rust/library`; test if that contains `std/Cargo.toml`.\n+            let rustup_src =\n+                sysroot.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\").join(\"library\");\n+            if !rustup_src.join(\"std\").join(\"Cargo.toml\").exists() {\n+                // Ask the user to install the `rust-src` component, and use that.\n+                let mut cmd = Command::new(\"rustup\");\n+                cmd.args(&[\"component\", \"add\", \"rust-src\"]);\n+                ask_to_run(\n+                    cmd,\n+                    ask_user,\n+                    \"install the `rust-src` component for the selected toolchain\",\n+                );\n+            }\n+            rustup_src\n+        }\n+    };\n+    if !rust_src.exists() {\n+        show_error(format!(\"given Rust source directory `{}` does not exist.\", rust_src.display()));\n+    }\n+    if rust_src.file_name().and_then(OsStr::to_str) != Some(\"library\") {\n+        show_error(format!(\n+            \"given Rust source directory `{}` does not seem to be the `library` subdirectory of \\\n+             a Rust source checkout.\",\n+            rust_src.display()\n+        ));\n+    }\n+\n+    // Next, we need our own libstd. Prepare a xargo project for that purpose.\n+    // We will do this work in whatever is a good cache dir for this platform.\n+    let dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n+    let dir = dirs.cache_dir();\n+    if !dir.exists() {\n+        fs::create_dir_all(&dir).unwrap();\n+    }\n+    // The interesting bit: Xargo.toml (only needs content if we actually need std)\n+    let xargo_toml = if std::env::var_os(\"MIRI_NO_STD\").is_some() {\n+        \"\"\n+    } else {\n+        r#\"\n+[dependencies.std]\n+default_features = false\n+# We support unwinding, so enable that panic runtime.\n+features = [\"panic_unwind\", \"backtrace\"]\n+\n+[dependencies.test]\n+\"#\n+    };\n+    write_to_file(&dir.join(\"Xargo.toml\"), xargo_toml);\n+    // The boring bits: a dummy project for xargo.\n+    // FIXME: With xargo-check, can we avoid doing this?\n+    write_to_file(\n+        &dir.join(\"Cargo.toml\"),\n+        r#\"\n+[package]\n+name = \"miri-xargo\"\n+description = \"A dummy project for building libstd with xargo.\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\"#,\n+    );\n+    write_to_file(&dir.join(\"lib.rs\"), \"#![no_std]\");\n+\n+    // Figure out where xargo will build its stuff.\n+    // Unfortunately, it puts things into a different directory when the\n+    // architecture matches the host.\n+    let sysroot = if target == host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n+    // Make sure all target-level Miri invocations know their sysroot.\n+    std::env::set_var(\"MIRI_SYSROOT\", &sysroot);\n+\n+    // Now invoke xargo.\n+    let mut command = xargo_check();\n+    command.arg(\"check\").arg(\"-q\");\n+    command.current_dir(&dir);\n+    command.env(\"XARGO_HOME\", &dir);\n+    command.env(\"XARGO_RUST_SRC\", &rust_src);\n+    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n+    command.arg(\"--target\").arg(target);\n+    // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n+    // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n+    // because we still need bootstrap to distinguish between host and target crates.\n+    // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n+    // for target crates.\n+    // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n+    // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n+    // The `MIRI_CALLED_FROM_XARGO` will mean we dispatch to `phase_setup_rustc`.\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    if env::var_os(\"RUSTC_STAGE\").is_some() {\n+        assert!(env::var_os(\"RUSTC\").is_some());\n+        command.env(\"RUSTC_REAL\", &cargo_miri_path);\n+    } else {\n+        command.env(\"RUSTC\", &cargo_miri_path);\n+    }\n+    command.env(\"MIRI_CALLED_FROM_XARGO\", \"1\");\n+    // Make sure there are no other wrappers getting in our way\n+    // (Cc https://github.com/rust-lang/miri/issues/1421, https://github.com/rust-lang/miri/issues/2429).\n+    // Looks like setting `RUSTC_WRAPPER` to the empty string overwrites `build.rustc-wrapper` set via `config.toml`.\n+    command.env(\"RUSTC_WRAPPER\", \"\");\n+    // Disable debug assertions in the standard library -- Miri is already slow enough. But keep the\n+    // overflow checks, they are cheap. This completely overwrites flags the user might have set,\n+    // which is consistent with normal `cargo build` that does not apply `RUSTFLAGS` to the sysroot\n+    // either.\n+    command.env(\"RUSTFLAGS\", \"-Cdebug-assertions=off -Coverflow-checks=on\");\n+    // Manage the output the user sees.\n+    if only_setup {\n+        // We want to be explicit.\n+        eprintln!(\"Preparing a sysroot for Miri (target: {target})...\");\n+        if print_sysroot {\n+            // Be extra sure there is no noise on stdout.\n+            command.stdout(process::Stdio::null());\n+        }\n+    } else {\n+        // We want to be quiet, but still let the user know that something is happening.\n+        eprint!(\"Preparing a sysroot for Miri (target: {target})... \");\n+        command.stdout(process::Stdio::null());\n+        command.stderr(process::Stdio::null());\n+    }\n+\n+    // Finally run it!\n+    if command.status().expect(\"failed to run xargo\").success().not() {\n+        if only_setup {\n+            show_error(format!(\"failed to run xargo, see error details above\"))\n+        } else {\n+            show_error(format!(\n+                \"failed to run xargo; run `cargo miri setup` to see the error details\"\n+            ))\n+        }\n+    }\n+\n+    // Figure out what to print.\n+    if only_setup {\n+        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n+    } else {\n+        eprintln!(\"done\");\n+    }\n+    if print_sysroot {\n+        // Print just the sysroot and nothing else to stdout; this way we do not need any escaping.\n+        println!(\"{}\", sysroot.display());\n+    }\n+}"}, {"sha": "d6a42a2f855dc9465fb8af96a0c4ec465b810caf", "filename": "cargo-miri/src/util.rs", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Futil.rs?ref=730a799bf4830ce0dea063c59255bf4a03264771", "patch": "@@ -0,0 +1,375 @@\n+use std::collections::HashMap;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fmt::Write as _;\n+use std::fs::{self, File};\n+use std::io::{self, BufWriter, Read, Write};\n+use std::iter::TakeWhile;\n+use std::ops::Not;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use cargo_metadata::{Metadata, MetadataCommand};\n+use rustc_version::VersionMeta;\n+use serde::{Deserialize, Serialize};\n+\n+/// The information to run a crate with the given environment.\n+#[derive(Clone, Serialize, Deserialize)]\n+pub struct CrateRunEnv {\n+    /// The command-line arguments.\n+    pub args: Vec<String>,\n+    /// The environment.\n+    pub env: Vec<(OsString, OsString)>,\n+    /// The current working directory.\n+    pub current_dir: OsString,\n+    /// The contents passed via standard input.\n+    pub stdin: Vec<u8>,\n+}\n+\n+impl CrateRunEnv {\n+    /// Gather all the information we need.\n+    pub fn collect(args: impl Iterator<Item = String>, capture_stdin: bool) -> Self {\n+        let args = args.collect();\n+        let env = env::vars_os().collect();\n+        let current_dir = env::current_dir().unwrap().into_os_string();\n+\n+        let mut stdin = Vec::new();\n+        if capture_stdin {\n+            std::io::stdin().lock().read_to_end(&mut stdin).expect(\"cannot read stdin\");\n+        }\n+\n+        CrateRunEnv { args, env, current_dir, stdin }\n+    }\n+}\n+\n+/// The information Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n+#[derive(Serialize, Deserialize)]\n+pub enum CrateRunInfo {\n+    /// Run it with the given environment.\n+    RunWith(CrateRunEnv),\n+    /// Skip it as Miri does not support interpreting such kind of crates.\n+    SkipProcMacroTest,\n+}\n+\n+impl CrateRunInfo {\n+    pub fn store(&self, filename: &Path) {\n+        let file = File::create(filename)\n+            .unwrap_or_else(|_| show_error(format!(\"cannot create `{}`\", filename.display())));\n+        let file = BufWriter::new(file);\n+        serde_json::ser::to_writer(file, self)\n+            .unwrap_or_else(|_| show_error(format!(\"cannot write to `{}`\", filename.display())));\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum MiriCommand {\n+    /// Our own special 'setup' command.\n+    Setup,\n+    /// A command to be forwarded to cargo.\n+    Forward(String),\n+}\n+\n+pub fn show_error(msg: String) -> ! {\n+    eprintln!(\"fatal error: {}\", msg);\n+    std::process::exit(1)\n+}\n+\n+/// Determines whether a `--flag` is present.\n+pub fn has_arg_flag(name: &str) -> bool {\n+    num_arg_flag(name) > 0\n+}\n+\n+/// Determines how many times a `--flag` is present.\n+pub fn num_arg_flag(name: &str) -> usize {\n+    std::env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n+}\n+\n+/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n+/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n+pub struct ArgSplitFlagValue<'a, I> {\n+    args: TakeWhile<I, fn(&String) -> bool>,\n+    name: &'a str,\n+}\n+\n+impl<'a, I: Iterator<Item = String>> ArgSplitFlagValue<'a, I> {\n+    pub fn new(args: I, name: &'a str) -> Self {\n+        Self {\n+            // Stop searching at `--`.\n+            args: args.take_while(|val| val != \"--\"),\n+            name,\n+        }\n+    }\n+}\n+\n+impl<I: Iterator<Item = String>> Iterator for ArgSplitFlagValue<'_, I> {\n+    type Item = Result<String, String>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let arg = self.args.next()?;\n+        if let Some(suffix) = arg.strip_prefix(self.name) {\n+            // Strip leading `name`.\n+            if suffix.is_empty() {\n+                // This argument is exactly `name`; the next one is the value.\n+                return self.args.next().map(Ok);\n+            } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                // This argument is `name=value`; get the value.\n+                return Some(Ok(suffix.to_owned()));\n+            }\n+        }\n+        Some(Err(arg))\n+    }\n+}\n+\n+/// Yields all values of command line flag `name`.\n+pub struct ArgFlagValueIter<'a>(ArgSplitFlagValue<'a, env::Args>);\n+\n+impl<'a> ArgFlagValueIter<'a> {\n+    pub fn new(name: &'a str) -> Self {\n+        Self(ArgSplitFlagValue::new(env::args(), name))\n+    }\n+}\n+\n+impl Iterator for ArgFlagValueIter<'_> {\n+    type Item = String;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            if let Ok(value) = self.0.next()? {\n+                return Some(value);\n+            }\n+        }\n+    }\n+}\n+\n+/// Gets the value of a `--flag`.\n+pub fn get_arg_flag_value(name: &str) -> Option<String> {\n+    ArgFlagValueIter::new(name).next()\n+}\n+\n+/// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n+pub fn escape_for_toml(s: &str) -> String {\n+    // We want to surround this string in quotes `\"`. So we first escape all quotes,\n+    // and also all backslashes (that are used to escape quotes).\n+    let s = s.replace('\\\\', r#\"\\\\\"#).replace('\"', r#\"\\\"\"#);\n+    format!(\"\\\"{}\\\"\", s)\n+}\n+\n+/// Returns the path to the `miri` binary\n+pub fn find_miri() -> PathBuf {\n+    if let Some(path) = env::var_os(\"MIRI\") {\n+        return path.into();\n+    }\n+    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n+    if cfg!(windows) {\n+        path.set_file_name(\"miri.exe\");\n+    } else {\n+        path.set_file_name(\"miri\");\n+    }\n+    path\n+}\n+\n+pub fn miri() -> Command {\n+    Command::new(find_miri())\n+}\n+\n+pub fn miri_for_host() -> Command {\n+    let mut cmd = miri();\n+    cmd.env(\"MIRI_BE_RUSTC\", \"host\");\n+    cmd\n+}\n+\n+pub fn version_info() -> VersionMeta {\n+    VersionMeta::for_command(miri_for_host())\n+        .expect(\"failed to determine underlying rustc version of Miri\")\n+}\n+\n+pub fn cargo() -> Command {\n+    Command::new(env::var_os(\"CARGO\").unwrap_or_else(|| OsString::from(\"cargo\")))\n+}\n+\n+pub fn xargo_check() -> Command {\n+    Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n+}\n+\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+pub fn exec(mut cmd: Command) -> ! {\n+    // On non-Unix imitate POSIX exec as closely as we can\n+    #[cfg(not(unix))]\n+    {\n+        let exit_status = cmd.status().expect(\"failed to run command\");\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n+    }\n+    // On Unix targets, actually exec.\n+    // If exec returns, process setup has failed. This is the same error condition as the expect in\n+    // the non-Unix case.\n+    #[cfg(unix)]\n+    {\n+        use std::os::unix::process::CommandExt;\n+        let error = cmd.exec();\n+        Err(error).expect(\"failed to run command\")\n+    }\n+}\n+\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+/// `input` is also piped to the new process's stdin, on cfg(unix) platforms by writing its\n+/// contents to `path` first, then setting stdin to that file.\n+pub fn exec_with_pipe<P>(mut cmd: Command, input: &[u8], path: P) -> !\n+where\n+    P: AsRef<Path>,\n+{\n+    #[cfg(unix)]\n+    {\n+        // Write the bytes we want to send to stdin out to a file\n+        std::fs::write(&path, input).unwrap();\n+        // Open the file for reading, and set our new stdin to it\n+        let stdin = File::open(&path).unwrap();\n+        cmd.stdin(stdin);\n+        // Unlink the file so that it is fully cleaned up as soon as the new process exits\n+        std::fs::remove_file(&path).unwrap();\n+        // Finally, we can hand off control.\n+        exec(cmd)\n+    }\n+    #[cfg(not(unix))]\n+    {\n+        drop(path); // We don't need the path, we can pipe the bytes directly\n+        cmd.stdin(std::process::Stdio::piped());\n+        let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+        {\n+            let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n+            stdin.write_all(input).expect(\"failed to write out test source\");\n+        }\n+        let exit_status = child.wait().expect(\"failed to run command\");\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n+    }\n+}\n+\n+pub fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n+    // Disable interactive prompts in CI (GitHub Actions, Travis, AppVeyor, etc).\n+    // Azure doesn't set `CI` though (nothing to see here, just Microsoft being Microsoft),\n+    // so we also check their `TF_BUILD`.\n+    let is_ci = env::var_os(\"CI\").is_some() || env::var_os(\"TF_BUILD\").is_some();\n+    if ask && !is_ci {\n+        let mut buf = String::new();\n+        print!(\"I will run `{:?}` to {}. Proceed? [Y/n] \", cmd, text);\n+        io::stdout().flush().unwrap();\n+        io::stdin().read_line(&mut buf).unwrap();\n+        match buf.trim().to_lowercase().as_ref() {\n+            // Proceed.\n+            \"\" | \"y\" | \"yes\" => {}\n+            \"n\" | \"no\" => show_error(format!(\"aborting as per your request\")),\n+            a => show_error(format!(\"invalid answer `{}`\", a)),\n+        };\n+    } else {\n+        eprintln!(\"Running `{:?}` to {}.\", cmd, text);\n+    }\n+\n+    if cmd.status().unwrap_or_else(|_| panic!(\"failed to execute {:?}\", cmd)).success().not() {\n+        show_error(format!(\"failed to {}\", text));\n+    }\n+}\n+\n+/// Writes the given content to the given file *cross-process atomically*, in the sense that another\n+/// process concurrently reading that file will see either the old content or the new content, but\n+/// not some intermediate (e.g., empty) state.\n+///\n+/// We assume no other parts of this same process are trying to read or write that file.\n+pub fn write_to_file(filename: &Path, content: &str) {\n+    // Create a temporary file with the desired contents.\n+    let mut temp_filename = filename.as_os_str().to_os_string();\n+    temp_filename.push(&format!(\".{}\", std::process::id()));\n+    let mut temp_file = File::create(&temp_filename).unwrap();\n+    temp_file.write_all(content.as_bytes()).unwrap();\n+    drop(temp_file);\n+\n+    // Move file to the desired location.\n+    fs::rename(temp_filename, filename).unwrap();\n+}\n+\n+pub fn get_cargo_metadata() -> Metadata {\n+    // The `build.target-dir` config can be passed by `--config` flags, so forward them to\n+    // `cargo metadata`.\n+    let mut additional_options = Vec::new();\n+    // `-Zunstable-options` is required by `--config`.\n+    additional_options.push(\"-Zunstable-options\".to_string());\n+\n+    let config_flag = \"--config\";\n+    for arg in ArgSplitFlagValue::new(\n+        env::args().skip(3), // skip the program name, \"miri\" and \"run\" / \"test\"\n+        config_flag,\n+    )\n+    // Only look at `Ok`\n+    .flatten()\n+    {\n+        additional_options.push(config_flag.to_string());\n+        additional_options.push(arg);\n+    }\n+\n+    let metadata =\n+        MetadataCommand::new().no_deps().other_options(additional_options).exec().unwrap();\n+\n+    metadata\n+}\n+\n+/// Pulls all the crates in this workspace from the cargo metadata.\n+/// Workspace members are emitted like \"miri 0.1.0 (path+file:///path/to/miri)\"\n+/// Additionally, somewhere between cargo metadata and TyCtxt, '-' gets replaced with '_' so we\n+/// make that same transformation here.\n+pub fn local_crates(metadata: &Metadata) -> String {\n+    assert!(!metadata.workspace_members.is_empty());\n+    let mut local_crates = String::new();\n+    for member in &metadata.workspace_members {\n+        let name = member.repr.split(' ').next().unwrap();\n+        let name = name.replace('-', \"_\");\n+        local_crates.push_str(&name);\n+        local_crates.push(',');\n+    }\n+    local_crates.pop(); // Remove the trailing ','\n+\n+    local_crates\n+}\n+\n+fn env_vars_from_cmd(cmd: &Command) -> Vec<(String, String)> {\n+    let mut envs = HashMap::new();\n+    for (key, value) in std::env::vars() {\n+        envs.insert(key, value);\n+    }\n+    for (key, value) in cmd.get_envs() {\n+        if let Some(value) = value {\n+            envs.insert(key.to_string_lossy().to_string(), value.to_string_lossy().to_string());\n+        } else {\n+            envs.remove(&key.to_string_lossy().to_string());\n+        }\n+    }\n+    let mut envs: Vec<_> = envs.into_iter().collect();\n+    envs.sort();\n+    envs\n+}\n+\n+/// Debug-print a command that is going to be run.\n+pub fn debug_cmd(prefix: &str, verbose: usize, cmd: &Command) {\n+    if verbose == 0 {\n+        return;\n+    }\n+    // We only do a single `eprintln!` call to minimize concurrency interactions.\n+    let mut out = prefix.to_string();\n+    writeln!(out, \" running command: env \\\\\").unwrap();\n+    if verbose > 1 {\n+        // Print the full environment this will be called in.\n+        for (key, value) in env_vars_from_cmd(cmd) {\n+            writeln!(out, \"{key}={value:?} \\\\\").unwrap();\n+        }\n+    } else {\n+        // Print only what has been changed for this `cmd`.\n+        for (var, val) in cmd.get_envs() {\n+            if let Some(val) = val {\n+                writeln!(out, \"{}={:?} \\\\\", var.to_string_lossy(), val).unwrap();\n+            } else {\n+                writeln!(out, \"--unset={}\", var.to_string_lossy()).unwrap();\n+            }\n+        }\n+    }\n+    write!(out, \"{cmd:?}\").unwrap();\n+    eprintln!(\"{}\", out);\n+}"}, {"sha": "366e90df179835ed89d6dffc5932e724a7d4a136", "filename": "cargo-miri/src/version.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730a799bf4830ce0dea063c59255bf4a03264771/cargo-miri%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fversion.rs?ref=730a799bf4830ce0dea063c59255bf4a03264771", "previous_filename": "cargo-miri/version.rs"}]}