{"sha": "8d6d646203254fbd3bddfd5f40b13140ef12211a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNmQ2NDYyMDMyNTRmYmQzYmRkZmQ1ZjQwYjEzMTQwZWYxMjIxMWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-27T12:07:08Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-03T13:11:18Z"}, "message": "address review comments", "tree": {"sha": "8b14684fa5554f5078b947010cd759ec9b9c7ec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b14684fa5554f5078b947010cd759ec9b9c7ec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d6d646203254fbd3bddfd5f40b13140ef12211a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6d646203254fbd3bddfd5f40b13140ef12211a", "html_url": "https://github.com/rust-lang/rust/commit/8d6d646203254fbd3bddfd5f40b13140ef12211a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d6d646203254fbd3bddfd5f40b13140ef12211a/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "html_url": "https://github.com/rust-lang/rust/commit/a091cfd4f3be8677481a3a502bd96bdebd0de1bb"}], "stats": {"total": 162, "additions": 83, "deletions": 79}, "files": [{"sha": "293d2863733f759aee055d487cfb2c9c6dfaa4f7", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d6d646203254fbd3bddfd5f40b13140ef12211a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6d646203254fbd3bddfd5f40b13140ef12211a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=8d6d646203254fbd3bddfd5f40b13140ef12211a", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n pub struct DataflowResults<O>(DataflowState<O>) where O: BitDenotation;\n \n impl<O: BitDenotation> DataflowResults<O> {\n-    pub fn sets(&self) -> &AllSets {\n+    pub fn sets(&self) -> &AllSets<O::Idx> {\n         &self.0.sets\n     }\n }"}, {"sha": "6e5303626f116cc8e9473eec75d9cf90bd746a1f", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 80, "deletions": 76, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8d6d646203254fbd3bddfd5f40b13140ef12211a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6d646203254fbd3bddfd5f40b13140ef12211a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=8d6d646203254fbd3bddfd5f40b13140ef12211a", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use bitslice::BitSlice;\n+use indexed_set::IdxSetBuf;\n use super::gather_moves::{MoveData, MovePathIndex, MovePathContent, Location};\n use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n-use super::{DropFlagState};\n+use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Subst, Substs, VecPerParamSpace};\n@@ -44,23 +44,26 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         let move_data = MoveData::gather_moves(mir, tcx);\n         let elaborate_patch = {\n             let mir = &*mir;\n-            let ((_, _, move_data), flow_inits) =\n-                super::do_dataflow(tcx, mir, id, &[], (tcx, mir, move_data),\n-                                   MaybeInitializedLvals::default());\n-            let ((_, _, move_data), flow_uninits) =\n-                super::do_dataflow(tcx, mir, id, &[], (tcx, mir, move_data),\n-                                   MaybeUninitializedLvals::default());\n-\n-            match (tcx, mir, move_data) {\n-                ref ctxt => ElaborateDropsCtxt {\n-                    ctxt: ctxt,\n-                    param_env: &param_env,\n-                    flow_inits: flow_inits,\n-                    flow_uninits: flow_uninits,\n-                    drop_flags: FnvHashMap(),\n-                    patch: MirPatch::new(mir),\n-                }.elaborate()\n-            }\n+            let env = MoveDataParamEnv {\n+                move_data: move_data,\n+                param_env: param_env\n+            };\n+            let flow_inits =\n+                super::do_dataflow(tcx, mir, id, &[], &env,\n+                                   MaybeInitializedLvals::new(tcx, mir));\n+            let flow_uninits =\n+                super::do_dataflow(tcx, mir, id, &[], &env,\n+                                   MaybeUninitializedLvals::new(tcx, mir));\n+\n+            ElaborateDropsCtxt {\n+                tcx: tcx,\n+                mir: mir,\n+                env: &env,\n+                flow_inits: flow_inits,\n+                flow_uninits: flow_uninits,\n+                drop_flags: FnvHashMap(),\n+                patch: MirPatch::new(mir),\n+            }.elaborate()\n         };\n         pretty::dump_mir(tcx, \"elaborate_drops\", &0, src, mir, None);\n         elaborate_patch.apply(mir);\n@@ -71,35 +74,35 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n impl Pass for ElaborateDrops {}\n \n struct InitializationData {\n-    live: Vec<usize>,\n-    dead: Vec<usize>\n+    live: IdxSetBuf<MovePathIndex>,\n+    dead: IdxSetBuf<MovePathIndex>\n }\n \n impl InitializationData {\n     fn apply_location<'a,'tcx>(&mut self,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                mir: &Mir<'tcx>,\n-                               move_data: &MoveData<'tcx>,\n+                               env: &MoveDataParamEnv<'tcx>,\n                                loc: Location)\n     {\n-        drop_flag_effects_for_location(tcx, mir, move_data, loc, |path, df| {\n+        drop_flag_effects_for_location(tcx, mir, env, loc, |path, df| {\n             debug!(\"at location {:?}: setting {:?} to {:?}\",\n                    loc, path, df);\n             match df {\n-                DropFlagState::Live => {\n-                    self.live.set_bit(path.idx());\n-                    self.dead.clear_bit(path.idx());\n+                DropFlagState::Present => {\n+                    self.live.add(&path);\n+                    self.dead.remove(&path);\n                 }\n-                DropFlagState::Dead => {\n-                    self.dead.set_bit(path.idx());\n-                    self.live.clear_bit(path.idx());\n+                DropFlagState::Absent => {\n+                    self.dead.add(&path);\n+                    self.live.remove(&path);\n                 }\n             }\n         });\n     }\n \n     fn state(&self, path: MovePathIndex) -> (bool, bool) {\n-        (self.live.get_bit(path.idx()), self.dead.get_bit(path.idx()))\n+        (self.live.contains(&path), self.dead.contains(&path))\n     }\n }\n \n@@ -110,8 +113,9 @@ impl fmt::Debug for InitializationData {\n }\n \n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n-    ctxt: &'a (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>),\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n     drop_flags: FnvHashMap<MovePathIndex, u32>,\n@@ -133,9 +137,10 @@ struct DropCtxt<'a, 'tcx: 'a> {\n }\n \n impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> { self.ctxt.0 }\n-    fn mir(&self) -> &'b Mir<'tcx> { self.ctxt.1 }\n-    fn move_data(&self) -> &'b MoveData<'tcx> { &self.ctxt.2 }\n+    fn move_data(&self) -> &'b MoveData<'tcx> { &self.env.move_data }\n+    fn param_env(&self) -> &'b ty::ParameterEnvironment<'tcx> {\n+        &self.env.param_env\n+    }\n \n     fn initialization_data_at(&self, loc: Location) -> InitializationData {\n         let mut data = InitializationData {\n@@ -145,14 +150,14 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 .to_owned(),\n         };\n         for stmt in 0..loc.index {\n-            data.apply_location(self.ctxt.0, self.ctxt.1, &self.ctxt.2,\n+            data.apply_location(self.tcx, self.mir, self.env,\n                                 Location { block: loc.block, index: stmt });\n         }\n         data\n     }\n \n     fn create_drop_flag(&mut self, index: MovePathIndex) {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let patch = &mut self.patch;\n         self.drop_flags.entry(index).or_insert_with(|| {\n             patch.new_temp(tcx.types.bool)\n@@ -183,11 +188,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     {\n         match self.move_data().move_paths[path].content {\n             MovePathContent::Lvalue(ref lvalue) => {\n-                let ty = self.mir().lvalue_ty(self.tcx(), lvalue)\n-                    .to_ty(self.tcx());\n+                let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n                 debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-                self.tcx().type_needs_drop_given_env(ty, &self.param_env)\n+                self.tcx.type_needs_drop_given_env(ty, self.param_env())\n             }\n             _ => false\n         }\n@@ -210,7 +214,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn lvalue_contents_are_tracked(&self, lv: &Lvalue<'tcx>) -> bool {\n-        let ty = self.mir().lvalue_ty(self.tcx(), lv).to_ty(self.tcx());\n+        let ty = self.mir.lvalue_ty(self.tcx, lv).to_ty(self.tcx);\n         match ty.sty {\n             ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n                 false\n@@ -221,8 +225,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn collect_drop_flags(&mut self)\n     {\n-        for bb in self.mir().all_basic_blocks() {\n-            let data = self.mir().basic_block_data(bb);\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n             let terminator = data.terminator();\n             let location = match terminator.kind {\n                 TerminatorKind::Drop { ref location, .. } |\n@@ -243,7 +247,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             debug!(\"collect_drop_flags: {:?}, lv {:?} (index {:?})\",\n                    bb, location, path);\n \n-            on_all_children_bits(self.tcx(), self.mir(), self.move_data(), path, |child| {\n+            on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                 if self.path_needs_drop(child) {\n                     let (maybe_live, maybe_dead) = init_data.state(child);\n                     debug!(\"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n@@ -258,8 +262,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn elaborate_drops(&mut self)\n     {\n-        for bb in self.mir().all_basic_blocks() {\n-            let data = self.mir().basic_block_data(bb);\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n             let loc = Location { block: bb, index: data.statements.len() };\n             let terminator = data.terminator();\n \n@@ -320,7 +324,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         unwind: Option<BasicBlock>)\n     {\n         let bb = loc.block;\n-        let data = self.mir().basic_block_data(bb);\n+        let data = self.mir.basic_block_data(bb);\n         let terminator = data.terminator();\n \n         let unwind = Some(unwind.unwrap_or_else(|| {\n@@ -354,12 +358,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 succ: target,\n                 unwind: unwind\n             }, bb);\n-            on_all_children_bits(self.tcx(), self.mir(), self.move_data(), path, |child| {\n+            on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                 self.set_drop_flag(Location { block: target, index: 0 },\n-                                   child, DropFlagState::Live);\n+                                   child, DropFlagState::Present);\n                 if let Some(unwind) = unwind {\n                     self.set_drop_flag(Location { block: unwind, index: 0 },\n-                                       child, DropFlagState::Live);\n+                                       child, DropFlagState::Present);\n                 }\n             });\n         }\n@@ -397,7 +401,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let mut some_dead = false;\n         let mut children_count = 0;\n         on_all_children_bits(\n-            self.tcx(), self.mir(), self.move_data(),\n+            self.tcx, self.mir, self.move_data(),\n             c.path, |child| {\n                 if self.path_needs_drop(child) {\n                     let (live, dead) = c.init_data.state(child);\n@@ -463,9 +467,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 });\n \n             let field_ty =\n-                self.tcx().normalize_associated_type_in_env(\n-                    &f.ty(self.tcx(), substs),\n-                    &self.param_env\n+                self.tcx.normalize_associated_type_in_env(\n+                    &f.ty(self.tcx, substs),\n+                    self.param_env()\n                 );\n             (base_lv.clone().field(Field::new(i), field_ty), subpath)\n         }).collect()\n@@ -704,7 +708,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     /// This creates a \"drop ladder\" that drops the needed fields of the\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        let ty = self.mir().lvalue_ty(self.tcx(), c.lvalue).to_ty(self.tcx());\n+        let ty = self.mir.lvalue_ty(self.tcx, c.lvalue).to_ty(self.tcx);\n         match ty.sty {\n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n@@ -741,7 +745,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             self.set_drop_flag(\n                 Location { block: drop_block, index: 0 },\n                 c.path,\n-                DropFlagState::Dead\n+                DropFlagState::Absent\n             );\n         }\n \n@@ -859,7 +863,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             });\n         }\n \n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n@@ -896,12 +900,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // dataflow can create unneeded children in some cases\n         // - be sure to ignore them.\n \n-        let ty = self.mir().lvalue_ty(self.tcx(), c.lvalue).to_ty(self.tcx());\n+        let ty = self.mir.lvalue_ty(self.tcx, c.lvalue).to_ty(self.tcx);\n \n         match ty.sty {\n             ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n                 if def.has_dtor() {\n-                    self.tcx().sess.span_warn(\n+                    self.tcx.sess.span_warn(\n                         c.span,\n                         &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n                                  c));\n@@ -917,31 +921,31 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n         Rvalue::Use(Operand::Constant(Constant {\n             span: span,\n-            ty: self.tcx().types.bool,\n+            ty: self.tcx.types.bool,\n             literal: Literal::Value { value: ConstVal::Bool(val) }\n         }))\n     }\n \n     fn set_drop_flag(&mut self, loc: Location, path: MovePathIndex, val: DropFlagState) {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n-            let span = self.patch.context_for_location(self.mir(), loc).0;\n+            let span = self.patch.context_for_location(self.mir, loc).0;\n             let val = self.constant_bool(span, val.value());\n             self.patch.add_assign(loc, Lvalue::Temp(flag), val);\n         }\n     }\n \n     fn drop_flags_on_init(&mut self) {\n         let loc = Location { block: START_BLOCK, index: 0 };\n-        let span = self.patch.context_for_location(self.mir(), loc).0;\n+        let span = self.patch.context_for_location(self.mir, loc).0;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n             self.patch.add_assign(loc, Lvalue::Temp(*flag), false_.clone());\n         }\n     }\n \n     fn drop_flags_for_fn_rets(&mut self) {\n-        for bb in self.mir().all_basic_blocks() {\n-            let data = self.mir().basic_block_data(bb);\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n             if let TerminatorKind::Call {\n                 destination: Some((ref lv, tgt)), cleanup: Some(_), ..\n             } = data.terminator().kind {\n@@ -950,8 +954,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let loc = Location { block: tgt, index: 0 };\n                 let path = self.move_data().rev_lookup.find(lv);\n                 on_all_children_bits(\n-                    self.tcx(), self.mir(), self.move_data(), path,\n-                    |child| self.set_drop_flag(loc, child, DropFlagState::Live)\n+                    self.tcx, self.mir, self.move_data(), path,\n+                    |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );\n             }\n         }\n@@ -960,7 +964,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn drop_flags_for_args(&mut self) {\n         let loc = Location { block: START_BLOCK, index: 0 };\n         super::drop_flag_effects_for_function_entry(\n-            self.tcx(), self.mir(), self.move_data(), |path, ds| {\n+            self.tcx, self.mir, self.env, |path, ds| {\n                 self.set_drop_flag(loc, path, ds);\n             }\n         )\n@@ -973,8 +977,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // drop flags by themselves, to avoid the drop flags being\n         // clobbered before they are read.\n \n-        for bb in self.mir().all_basic_blocks() {\n-            let data = self.mir().basic_block_data(bb);\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len()+1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);\n@@ -999,8 +1003,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 }\n                 let loc = Location { block: bb, index: i };\n                 super::drop_flag_effects_for_location(\n-                    self.tcx(), self.mir(), self.move_data(), loc, |path, ds| {\n-                        if ds == DropFlagState::Dead || allow_initializations {\n+                    self.tcx, self.mir, self.env, loc, |path, ds| {\n+                        if ds == DropFlagState::Absent || allow_initializations {\n                             self.set_drop_flag(loc, path, ds)\n                         }\n                     }\n@@ -1018,8 +1022,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let loc = Location { block: bb, index: data.statements.len() };\n                 let path = self.move_data().rev_lookup.find(lv);\n                 on_all_children_bits(\n-                    self.tcx(), self.mir(), self.move_data(), path,\n-                    |child| self.set_drop_flag(loc, child, DropFlagState::Live)\n+                    self.tcx, self.mir, self.move_data(), path,\n+                    |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );\n             }\n         }\n@@ -1029,10 +1033,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                                c: &DropCtxt<'a, 'tcx>,\n                                bb: BasicBlock)\n     {\n-        let loc = self.patch.terminator_loc(self.mir(), bb);\n+        let loc = self.patch.terminator_loc(self.mir, bb);\n         on_all_children_bits(\n-            self.tcx(), self.mir(), self.move_data(), c.path,\n-            |child| self.set_drop_flag(loc, child, DropFlagState::Dead)\n+            self.tcx, self.mir, self.move_data(), c.path,\n+            |child| self.set_drop_flag(loc, child, DropFlagState::Absent)\n         );\n     }\n }"}, {"sha": "007cde156f40f12ca3496dfaf064394d4a73b43a", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d6d646203254fbd3bddfd5f40b13140ef12211a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6d646203254fbd3bddfd5f40b13140ef12211a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=8d6d646203254fbd3bddfd5f40b13140ef12211a", "patch": "@@ -207,8 +207,8 @@ enum DropFlagState {\n impl DropFlagState {\n     fn value(self) -> bool {\n         match self {\n-            DropFlagState::Live => true,\n-            DropFlagState::Dead => false\n+            DropFlagState::Present => true,\n+            DropFlagState::Absent => false\n         }\n     }\n }"}]}