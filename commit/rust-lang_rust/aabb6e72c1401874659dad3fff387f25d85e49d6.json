{"sha": "aabb6e72c1401874659dad3fff387f25d85e49d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYmI2ZTcyYzE0MDE4NzQ2NTlkYWQzZmZmMzg3ZjI1ZDg1ZTQ5ZDY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-14T18:37:16Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-14T22:22:52Z"}, "message": "rustc: Rename lints per RFC 344\n\nRFC 344 proposes a set of naming conventions for lints. This commit\nrenames existing lints to follow the conventions.\n\nUse the following sed script to bring your code up to date:\n\n```\ns/unnecessary_typecast/unused_typecasts/g\ns/unsigned_negate/unsigned_negation/g\ns/type_limits/unused_comparisons/g\ns/type_overflow/overflowing_literals/g\ns/ctypes/improper_ctypes/g\ns/owned_heap_memory/box_pointers/g\ns/unused_attribute/unused_attributes/g\ns/path_statement/path_statements/g\ns/unused_must_use/unused_must_use/g\ns/unused_result/unused_results/g\ns/non_uppercase_statics/non_upper_case_globals/g\ns/unnecessary_parens/unused_parens/g\ns/unnecessary_import_braces/unused_import_braces/g\ns/unused_unsafe/unused_unsafe/g\ns/unsafe_block/unsafe_blocks/g\ns/unused_mut/unused_mut/g\ns/unnecessary_allocation/unused_allocation/g\ns/missing_doc/missing_docs/g\ns/unused_imports/unused_imports/g\ns/unused_extern_crate/unused_extern_crates/g\ns/unnecessary_qualification/unused_qualifications/g\ns/unrecognized_lint/unknown_lints/g\ns/unused_variable/unused_variables/g\ns/dead_assignment/unused_assignments/g\ns/unknown_crate_type/unknown_crate_types/g\ns/variant_size_difference/variant_size_differences/g\ns/transmute_fat_ptr/fat_ptr_transmutes/g\n```\n\nCloses #16545\nCloses #17932\n\nDue to deprecation, this is a:\n\n[breaking-change]", "tree": {"sha": "6a2b39f526379da4793a619b29c145adcd87cd6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a2b39f526379da4793a619b29c145adcd87cd6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aabb6e72c1401874659dad3fff387f25d85e49d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aabb6e72c1401874659dad3fff387f25d85e49d6", "html_url": "https://github.com/rust-lang/rust/commit/aabb6e72c1401874659dad3fff387f25d85e49d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aabb6e72c1401874659dad3fff387f25d85e49d6/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e1e2456ed7e06c2341893118659efaee35fc391", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1e2456ed7e06c2341893118659efaee35fc391", "html_url": "https://github.com/rust-lang/rust/commit/5e1e2456ed7e06c2341893118659efaee35fc391"}], "stats": {"total": 236, "additions": 118, "deletions": 118}, "files": [{"sha": "ba9ec904bae4caba87dfd70229fac948bd1149ec", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -704,15 +704,15 @@ pub fn collect_crate_types(session: &Session,\n                 }\n                 Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"invalid `crate_type` \\\n                                       value\".to_string());\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"`crate_type` requires a \\"}, {"sha": "63c8f9d9d7c1c1162f689a17b73642611aef4f64", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -81,36 +81,36 @@ impl LintPass for WhileTrue {\n     }\n }\n \n-declare_lint!(UNNECESSARY_TYPECAST, Allow,\n+declare_lint!(UNUSED_TYPECASTS, Allow,\n               \"detects unnecessary type casts, that can be removed\")\n \n pub struct UnusedCasts;\n \n impl LintPass for UnusedCasts {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_TYPECAST)\n+        lint_array!(UNUSED_TYPECASTS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprCast(ref expr, ref ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n                 if ty::get(ty::expr_ty(cx.tcx, &**expr)).sty == ty::get(t_t).sty {\n-                    cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n+                    cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n-declare_lint!(UNSIGNED_NEGATE, Warn,\n+declare_lint!(UNSIGNED_NEGATION, Warn,\n               \"using an unary minus operator on unsigned type\")\n \n-declare_lint!(TYPE_LIMITS, Warn,\n+declare_lint!(UNUSED_COMPARISONS, Warn,\n               \"comparisons made useless by limits of the types involved\")\n \n-declare_lint!(TYPE_OVERFLOW, Warn,\n+declare_lint!(OVERFLOWING_LITERALS, Warn,\n               \"literal out of range for its type\")\n \n pub struct TypeLimits {\n@@ -128,7 +128,7 @@ impl TypeLimits {\n \n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSIGNED_NEGATE, TYPE_LIMITS, TYPE_OVERFLOW)\n+        lint_array!(UNSIGNED_NEGATION, UNUSED_COMPARISONS, OVERFLOWING_LITERALS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -138,7 +138,7 @@ impl LintPass for TypeLimits {\n                     ast::ExprLit(ref lit) => {\n                         match lit.node {\n                             ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n-                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n+                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int literal may \\\n                                              be unintentional\");\n                             },\n@@ -149,7 +149,7 @@ impl LintPass for TypeLimits {\n                         let t = ty::expr_ty(cx.tcx, &**expr);\n                         match ty::get(t).sty {\n                             ty::ty_uint(_) => {\n-                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n+                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int variable may \\\n                                              be unintentional\");\n                             },\n@@ -167,7 +167,7 @@ impl LintPass for TypeLimits {\n             },\n             ast::ExprBinary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n-                    cx.span_lint(TYPE_LIMITS, e.span,\n+                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             },\n@@ -185,7 +185,7 @@ impl LintPass for TypeLimits {\n \n                                 if (negative && v > (min.abs() as u64)) ||\n                                    (!negative && v > (max.abs() as u64)) {\n-                                    cx.span_lint(TYPE_OVERFLOW, e.span,\n+                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                                  \"literal out of range for its type\");\n                                     return;\n                                 }\n@@ -204,7 +204,7 @@ impl LintPass for TypeLimits {\n                             _ => fail!()\n                         };\n                         if  lit_val < min || lit_val > max {\n-                            cx.span_lint(TYPE_OVERFLOW, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -219,7 +219,7 @@ impl LintPass for TypeLimits {\n                             _ => fail!()\n                         };\n                         if lit_val < min || lit_val > max {\n-                            cx.span_lint(TYPE_OVERFLOW, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -330,23 +330,23 @@ impl LintPass for TypeLimits {\n     }\n }\n \n-declare_lint!(CTYPES, Warn,\n+declare_lint!(IMPROPER_CTYPES, Warn,\n               \"proper use of libc types in foreign modules\")\n \n-struct CTypesVisitor<'a, 'tcx: 'a> {\n+struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow().get_copy(&path_id) {\n             def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                self.cx.span_lint(CTYPES, sp,\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `int` in foreign module, while \\\n                                    libc::c_int or libc::c_long should be used\");\n             }\n             def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                self.cx.span_lint(CTYPES, sp,\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `uint` in foreign module, while \\\n                                    libc::c_uint or libc::c_ulong should be used\");\n             }\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n                 };\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {\n-                    self.cx.span_lint(CTYPES, sp,\n+                    self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                       \"found type without foreign-function-safe\n                                       representation annotation in foreign module, consider \\\n                                       adding a #[repr(...)] attribute to the type\");\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for CTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n             ast::TyPath(_, _, id) => self.check_def(ty.span, ty.id, id),\n@@ -378,16 +378,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub struct CTypes;\n+pub struct ImproperCTypes;\n \n-impl LintPass for CTypes {\n+impl LintPass for ImproperCTypes {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CTYPES)\n+        lint_array!(IMPROPER_CTYPES)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         fn check_ty(cx: &Context, ty: &ast::Ty) {\n-            let mut vis = CTypesVisitor { cx: cx };\n+            let mut vis = ImproperCTypesVisitor { cx: cx };\n             vis.visit_ty(ty);\n         }\n \n@@ -412,12 +412,12 @@ impl LintPass for CTypes {\n     }\n }\n \n-declare_lint!(OWNED_HEAP_MEMORY, Allow,\n+declare_lint!(BOX_POINTERS, Allow,\n               \"use of owned (Box type) heap memory\")\n \n-pub struct HeapMemory;\n+pub struct BoxPointers;\n \n-impl HeapMemory {\n+impl BoxPointers {\n     fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n         let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n@@ -438,14 +438,14 @@ impl HeapMemory {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(OWNED_HEAP_MEMORY, span, m.as_slice());\n+            cx.span_lint(BOX_POINTERS, span, m.as_slice());\n         }\n     }\n }\n \n-impl LintPass for HeapMemory {\n+impl LintPass for BoxPointers {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OWNED_HEAP_MEMORY)\n+        lint_array!(BOX_POINTERS)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -545,14 +545,14 @@ impl LintPass for RawPointerDeriving {\n     }\n }\n \n-declare_lint!(UNUSED_ATTRIBUTE, Warn,\n+declare_lint!(UNUSED_ATTRIBUTES, Warn,\n               \"detects attributes that were not used by the compiler\")\n \n-pub struct UnusedAttribute;\n+pub struct UnusedAttributes;\n \n-impl LintPass for UnusedAttribute {\n+impl LintPass for UnusedAttributes {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ATTRIBUTE)\n+        lint_array!(UNUSED_ATTRIBUTES)\n     }\n \n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n@@ -618,35 +618,35 @@ impl LintPass for UnusedAttribute {\n         }\n \n         if !attr::is_used(attr) {\n-            cx.span_lint(UNUSED_ATTRIBUTE, attr.span, \"unused attribute\");\n+            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             if CRATE_ATTRS.contains(&attr.name().get()) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n                     ast::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n-                cx.span_lint(UNUSED_ATTRIBUTE, attr.span, msg);\n+                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n             }\n         }\n     }\n }\n \n-declare_lint!(pub PATH_STATEMENT, Warn,\n+declare_lint!(pub PATH_STATEMENTS, Warn,\n               \"path statements with no effect\")\n \n-pub struct PathStatement;\n+pub struct PathStatements;\n \n-impl LintPass for PathStatement {\n+impl LintPass for PathStatements {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PATH_STATEMENT)\n+        lint_array!(PATH_STATEMENTS)\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n             ast::StmtSemi(ref expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENT, s.span,\n+                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENTS, s.span,\n                                                      \"path statement with no effect\"),\n                     _ => ()\n                 }\n@@ -659,14 +659,14 @@ impl LintPass for PathStatement {\n declare_lint!(pub UNUSED_MUST_USE, Warn,\n               \"unused result of a type flagged as #[must_use]\")\n \n-declare_lint!(pub UNUSED_RESULT, Allow,\n+declare_lint!(pub UNUSED_RESULTS, Allow,\n               \"unused result of an expression in a statement\")\n \n-pub struct UnusedResult;\n+pub struct UnusedResults;\n \n-impl LintPass for UnusedResult {\n+impl LintPass for UnusedResults {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUST_USE, UNUSED_RESULT)\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n@@ -702,7 +702,7 @@ impl LintPass for UnusedResult {\n             _ => {}\n         }\n         if !warned {\n-            cx.span_lint(UNUSED_RESULT, s.span, \"unused result\");\n+            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n         fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n@@ -966,14 +966,14 @@ impl LintPass for NonSnakeCase {\n     }\n }\n \n-declare_lint!(pub NON_UPPERCASE_STATICS, Warn,\n+declare_lint!(pub NON_UPPER_CASE_GLOBALS, Warn,\n               \"static constants should have uppercase identifiers\")\n \n-pub struct NonUppercaseStatics;\n+pub struct NonUpperCaseGlobals;\n \n-impl LintPass for NonUppercaseStatics {\n+impl LintPass for NonUpperCaseGlobals {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_UPPERCASE_STATICS)\n+        lint_array!(NON_UPPER_CASE_GLOBALS)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -986,7 +986,7 @@ impl LintPass for NonUppercaseStatics {\n                 // ones (some scripts don't have a concept of\n                 // upper/lowercase)\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPERCASE_STATICS, it.span,\n+                    cx.span_lint(NON_UPPER_CASE_GLOBALS, it.span,\n                         format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n@@ -1003,7 +1003,7 @@ impl LintPass for NonUppercaseStatics {\n             (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPERCASE_STATICS, path1.span,\n+                    cx.span_lint(NON_UPPER_CASE_GLOBALS, path1.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n@@ -1015,19 +1015,19 @@ impl LintPass for NonUppercaseStatics {\n     }\n }\n \n-declare_lint!(UNNECESSARY_PARENS, Warn,\n+declare_lint!(UNUSED_PARENS, Warn,\n               \"`if`, `match`, `while` and `return` do not need parentheses\")\n \n-pub struct UnnecessaryParens;\n+pub struct UnusedParens;\n \n-impl UnnecessaryParens {\n+impl UnusedParens {\n     fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n                                      struct_lit_needs_parens: bool) {\n         match value.node {\n             ast::ExprParen(ref inner) => {\n                 let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n                 if !necessary {\n-                    cx.span_lint(UNNECESSARY_PARENS, value.span,\n+                    cx.span_lint(UNUSED_PARENS, value.span,\n                                  format!(\"unnecessary parentheses around {}\",\n                                          msg).as_slice())\n                 }\n@@ -1071,9 +1071,9 @@ impl UnnecessaryParens {\n     }\n }\n \n-impl LintPass for UnnecessaryParens {\n+impl LintPass for UnusedParens {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_PARENS)\n+        lint_array!(UNUSED_PARENS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1108,14 +1108,14 @@ impl LintPass for UnnecessaryParens {\n     }\n }\n \n-declare_lint!(UNNECESSARY_IMPORT_BRACES, Allow,\n+declare_lint!(UNUSED_IMPORT_BRACES, Allow,\n               \"unnecessary braces around an imported item\")\n \n-pub struct UnnecessaryImportBraces;\n+pub struct UnusedImportBraces;\n \n-impl LintPass for UnnecessaryImportBraces {\n+impl LintPass for UnusedImportBraces {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_IMPORT_BRACES)\n+        lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n     fn check_view_item(&mut self, cx: &Context, view_item: &ast::ViewItem) {\n@@ -1128,7 +1128,7 @@ impl LintPass for UnnecessaryImportBraces {\n                                 ast::PathListIdent {ref name, ..} => {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n-                                    cx.span_lint(UNNECESSARY_IMPORT_BRACES, view_item.span,\n+                                    cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n                                                  m.as_slice());\n                                 },\n                                 _ => ()\n@@ -1167,21 +1167,21 @@ impl LintPass for UnusedUnsafe {\n     }\n }\n \n-declare_lint!(UNSAFE_BLOCK, Allow,\n+declare_lint!(UNSAFE_BLOCKS, Allow,\n               \"usage of an `unsafe` block\")\n \n-pub struct UnsafeBlock;\n+pub struct UnsafeBlocks;\n \n-impl LintPass for UnsafeBlock {\n+impl LintPass for UnsafeBlocks {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSAFE_BLOCK)\n+        lint_array!(UNSAFE_BLOCKS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-                cx.span_lint(UNSAFE_BLOCK, blk.span, \"usage of an `unsafe` block\");\n+                cx.span_lint(UNSAFE_BLOCKS, blk.span, \"usage of an `unsafe` block\");\n             }\n             _ => ()\n         }\n@@ -1266,14 +1266,14 @@ impl LintPass for UnusedMut {\n     }\n }\n \n-declare_lint!(UNNECESSARY_ALLOCATION, Warn,\n+declare_lint!(UNUSED_ALLOCATION, Warn,\n               \"detects unnecessary allocations that can be eliminated\")\n \n-pub struct UnnecessaryAllocation;\n+pub struct UnusedAllocation;\n \n-impl LintPass for UnnecessaryAllocation {\n+impl LintPass for UnusedAllocation {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_ALLOCATION)\n+        lint_array!(UNUSED_ALLOCATION)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1288,11 +1288,11 @@ impl LintPass for UnnecessaryAllocation {\n                     ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n                         match autoref {\n                             &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n-                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use & instead\");\n                             }\n                             &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n-                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use &mut instead\");\n                             }\n                             _ => ()\n@@ -1306,7 +1306,7 @@ impl LintPass for UnnecessaryAllocation {\n     }\n }\n \n-declare_lint!(MISSING_DOC, Allow,\n+declare_lint!(MISSING_DOCS, Allow,\n               \"detects missing documentation for public members\")\n \n pub struct MissingDoc {\n@@ -1358,15 +1358,15 @@ impl MissingDoc {\n             }\n         });\n         if !has_doc {\n-            cx.span_lint(MISSING_DOC, sp,\n+            cx.span_lint(MISSING_DOCS, sp,\n                 format!(\"missing documentation for {}\", desc).as_slice());\n         }\n     }\n }\n \n impl LintPass for MissingDoc {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_DOC)\n+        lint_array!(MISSING_DOCS)\n     }\n \n     fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n@@ -1569,19 +1569,19 @@ impl LintPass for Stability {\n declare_lint!(pub UNUSED_IMPORTS, Warn,\n               \"imports that are never used\")\n \n-declare_lint!(pub UNUSED_EXTERN_CRATE, Allow,\n+declare_lint!(pub UNUSED_EXTERN_CRATES, Allow,\n               \"extern crates that are never used\")\n \n-declare_lint!(pub UNNECESSARY_QUALIFICATION, Allow,\n+declare_lint!(pub UNUSED_QUALIFICATIONS, Allow,\n               \"detects unnecessarily qualified names\")\n \n-declare_lint!(pub UNRECOGNIZED_LINT, Warn,\n+declare_lint!(pub UNKNOWN_LINTS, Warn,\n               \"unrecognized lint attribute\")\n \n-declare_lint!(pub UNUSED_VARIABLE, Warn,\n+declare_lint!(pub UNUSED_VARIABLES, Warn,\n               \"detect variables which are not used in any way\")\n \n-declare_lint!(pub DEAD_ASSIGNMENT, Warn,\n+declare_lint!(pub UNUSED_ASSIGNMENTS, Warn,\n               \"detect assignments that will never be read\")\n \n declare_lint!(pub DEAD_CODE, Warn,\n@@ -1596,13 +1596,13 @@ declare_lint!(pub WARNINGS, Warn,\n declare_lint!(pub UNKNOWN_FEATURES, Deny,\n               \"unknown features found in crate-level #[feature] directives\")\n \n-declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n+declare_lint!(pub UNKNOWN_CRATE_TYPES, Deny,\n               \"unknown crate type found in #[crate_type] directive\")\n \n-declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n+declare_lint!(pub VARIANT_SIZE_DIFFERENCES, Allow,\n               \"detects enums with widely varying variant sizes\")\n \n-declare_lint!(pub TRANSMUTE_FAT_PTR, Allow,\n+declare_lint!(pub FAT_PTR_TRANSMUTES, Allow,\n               \"detects transmutes of fat pointers\")\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n@@ -1613,17 +1613,17 @@ impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n             UNUSED_IMPORTS,\n-            UNUSED_EXTERN_CRATE,\n-            UNNECESSARY_QUALIFICATION,\n-            UNRECOGNIZED_LINT,\n-            UNUSED_VARIABLE,\n-            DEAD_ASSIGNMENT,\n+            UNUSED_EXTERN_CRATES,\n+            UNUSED_QUALIFICATIONS,\n+            UNKNOWN_LINTS,\n+            UNUSED_VARIABLES,\n+            UNUSED_ASSIGNMENTS,\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n             WARNINGS,\n             UNKNOWN_FEATURES,\n-            UNKNOWN_CRATE_TYPE,\n-            VARIANT_SIZE_DIFFERENCE\n+            UNKNOWN_CRATE_TYPES,\n+            VARIANT_SIZE_DIFFERENCES\n         )\n     }\n }"}, {"sha": "08d597403b7986ab646f32bc3c1eedf4d9f44a88", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -175,20 +175,20 @@ impl LintStore {\n                      HardwiredLints,\n                      WhileTrue,\n                      UnusedCasts,\n-                     CTypes,\n-                     HeapMemory,\n-                     UnusedAttribute,\n-                     PathStatement,\n-                     UnusedResult,\n+                     ImproperCTypes,\n+                     BoxPointers,\n+                     UnusedAttributes,\n+                     PathStatements,\n+                     UnusedResults,\n                      NonCamelCaseTypes,\n                      NonSnakeCase,\n-                     NonUppercaseStatics,\n-                     UnnecessaryParens,\n-                     UnnecessaryImportBraces,\n+                     NonUpperCaseGlobals,\n+                     UnusedParens,\n+                     UnusedImportBraces,\n                      UnusedUnsafe,\n-                     UnsafeBlock,\n+                     UnsafeBlocks,\n                      UnusedMut,\n-                     UnnecessaryAllocation,\n+                     UnusedAllocation,\n                      Stability,\n         )\n \n@@ -199,12 +199,12 @@ impl LintStore {\n         )\n \n         add_lint_group!(sess, \"bad_style\",\n-                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPERCASE_STATICS)\n+                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS)\n \n         add_lint_group!(sess, \"unused\",\n-                        UNUSED_IMPORTS, UNUSED_VARIABLE, DEAD_ASSIGNMENT, DEAD_CODE,\n-                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATE, UNUSED_MUST_USE,\n-                        UNUSED_UNSAFE, UNUSED_RESULT, PATH_STATEMENT)\n+                        UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n+                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATES, UNUSED_MUST_USE,\n+                        UNUSED_UNSAFE, UNUSED_RESULTS, PATH_STATEMENTS)\n \n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                                            (*lint_id, level, span))\n                                                       .collect(),\n                                 None => {\n-                                    self.span_lint(builtin::UNRECOGNIZED_LINT, span,\n+                                    self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n                                                        level.as_str(), lint_name).as_slice());\n                                     continue;\n@@ -713,7 +713,7 @@ impl LintPass for GatherNodeLevels {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             ast::ItemEnum(..) => {\n-                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCE);\n+                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n                 let lvlsrc = cx.lints.get_level_source(lint_id);\n                 match lvlsrc {\n                     (lvl, _) if lvl != Allow => {"}, {"sha": "ac9df3597705078fe35852f85236cbfcaa3573d6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -1629,11 +1629,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n                                 *name));\n                 } else {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1651,7 +1651,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.ir.tcx.sess.add_lint(lint::builtin::DEAD_ASSIGNMENT, id, sp,\n+                self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "06ebd70977ff88fda693bcb523548daa8d37d26c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -5232,7 +5232,7 @@ impl<'a> Resolver<'a> {\n             match (def, unqualified_def) {\n                 (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n                     self.session\n-                        .add_lint(lint::builtin::UNNECESSARY_QUALIFICATION,\n+                        .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                                   id,\n                                   path.span,\n                                   \"unnecessary qualification\".to_string());\n@@ -6125,7 +6125,7 @@ impl<'a> Resolver<'a> {\n                 match self.session.cstore.find_extern_mod_stmt_cnum(id)\n                 {\n                     Some(crate_num) => if !self.used_crates.contains(&crate_num) {\n-                    self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATE,\n+                    self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n                                           id,\n                                           vi.span,\n                                           \"unused extern crate\".to_string());"}, {"sha": "ebc46bb2bfc945d39370d1ac12fd66fb1078d7f1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -2078,7 +2078,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n     let levels = ccx.tcx().node_lint_levels.borrow();\n-    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCE);\n+    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n     let lvlsrc = match levels.find(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n         Some(&lvlsrc) => lvlsrc,\n@@ -2115,7 +2115,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     if largest > slargest * 3 && slargest > 0 {\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n-        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCE,\n+        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCES,\n                             lvlsrc, Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\","}, {"sha": "f463f258ad550765e15abb0951f24e465cd036a6", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aabb6e72c1401874659dad3fff387f25d85e49d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=aabb6e72c1401874659dad3fff387f25d85e49d6", "patch": "@@ -122,7 +122,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n         if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n            ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n             ccx.sess()\n-               .add_lint(::lint::builtin::TRANSMUTE_FAT_PTR,\n+               .add_lint(::lint::builtin::FAT_PTR_TRANSMUTES,\n                          transmute_restriction.id,\n                          transmute_restriction.span,\n                          format!(\"Transmuting fat pointer types; {} to {}.\\"}]}