{"sha": "6ad10844db51b950306d49070932562246e06616", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDEwODQ0ZGI1MWI5NTAzMDZkNDkwNzA5MzI1NjIyNDZlMDY2MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-22T05:40:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-22T05:40:51Z"}, "message": "Auto merge of #36585 - jonathandturner:misc_error_touchups, r=nrc\n\nAdd the ability to merge spans to codemap\n\nThis PR adds the ability to merge Spans.  To do so, it builds on the Codemap's ability to verify the locations of spans, namely that following can be verified:\n\n* the expn_id of both spans much match\n* the lhs span needs to end on the same line the rhs span begins\n* the lhs span must start at or before the rhs span\n\nIf all of these are met, a new span is returned that is min(lo), max(hi) of the two spans.\n\nThis PR also removes an older Span merge, as this new functionality subsumes it.\n\nr? @nrc", "tree": {"sha": "9f8c203f92a9d5f21d5c9f56f6cee01a6aec9e56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f8c203f92a9d5f21d5c9f56f6cee01a6aec9e56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad10844db51b950306d49070932562246e06616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad10844db51b950306d49070932562246e06616", "html_url": "https://github.com/rust-lang/rust/commit/6ad10844db51b950306d49070932562246e06616", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad10844db51b950306d49070932562246e06616/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf592fa40ca4104b59b867817881ca056f408ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf592fa40ca4104b59b867817881ca056f408ad", "html_url": "https://github.com/rust-lang/rust/commit/1cf592fa40ca4104b59b867817881ca056f408ad"}, {"sha": "e4b18422ad3ee6bf1e749ccd337a25736a78c0bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4b18422ad3ee6bf1e749ccd337a25736a78c0bb", "html_url": "https://github.com/rust-lang/rust/commit/e4b18422ad3ee6bf1e749ccd337a25736a78c0bb"}], "stats": {"total": 96, "additions": 78, "deletions": 18}, "files": [{"sha": "bc599a8207656aadff7a97317ce884f9c7bbd3bb", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ad10844db51b950306d49070932562246e06616/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad10844db51b950306d49070932562246e06616/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=6ad10844db51b950306d49070932562246e06616", "patch": "@@ -81,6 +81,7 @@ pub trait CodeMapper {\n     fn span_to_string(&self, sp: Span) -> String;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n+    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n }\n \n impl CodeSuggestion {"}, {"sha": "6d68ce3646d53b41ba8f3e43fb7013c00ae569dc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6ad10844db51b950306d49070932562246e06616/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad10844db51b950306d49070932562246e06616/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=6ad10844db51b950306d49070932562246e06616", "patch": "@@ -364,6 +364,46 @@ impl CodeMap {\n         }\n     }\n \n+    /// Returns `Some(span)`, a union of the lhs and rhs span.  The lhs must precede the rhs. If\n+    /// there are gaps between lhs and rhs, the resulting union will cross these gaps.\n+    /// For this to work, the spans have to be:\n+    ///    * the expn_id of both spans much match\n+    ///    * the lhs span needs to end on the same line the rhs span begins\n+    ///    * the lhs span must start at or before the rhs span\n+    pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n+        use std::cmp;\n+\n+        // make sure we're at the same expansion id\n+        if sp_lhs.expn_id != sp_rhs.expn_id {\n+            return None;\n+        }\n+\n+        let lhs_end = match self.lookup_line(sp_lhs.hi) {\n+            Ok(x) => x,\n+            Err(_) => return None\n+        };\n+        let rhs_begin = match self.lookup_line(sp_rhs.lo) {\n+            Ok(x) => x,\n+            Err(_) => return None\n+        };\n+\n+        // if we must cross lines to merge, don't merge\n+        if lhs_end.line != rhs_begin.line {\n+            return None;\n+        }\n+\n+        // ensure these follow the expected order and we don't overlap\n+        if (sp_lhs.lo <= sp_rhs.lo) && (sp_lhs.hi <= sp_rhs.lo) {\n+            Some(Span {\n+                lo: cmp::min(sp_lhs.lo, sp_rhs.lo),\n+                hi: cmp::max(sp_lhs.hi, sp_rhs.hi),\n+                expn_id: sp_lhs.expn_id,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn span_to_string(&self, sp: Span) -> String {\n         if sp == COMMAND_LINE_SP {\n             return \"<command line option>\".to_string();\n@@ -819,6 +859,9 @@ impl CodeMapper for CodeMap {\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n         self.macro_backtrace(span)\n     }\n+    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n+        self.merge_spans(sp_lhs, sp_rhs)\n+    }\n }\n \n // _____________________________________________________________________________\n@@ -1072,6 +1115,40 @@ mod tests {\n                     blork.rs:1:1: 1:12\\n  `first line.`\\n\");\n     }\n \n+    /// Test merging two spans on the same line\n+    #[test]\n+    fn span_merging() {\n+        let cm = CodeMap::new();\n+        let inputtext  = \"bbbb BB bb CCC\\n\";\n+        let selection1 = \"     ~~       \\n\";\n+        let selection2 = \"           ~~~\\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let span1 = span_from_selection(inputtext, selection1);\n+        let span2 = span_from_selection(inputtext, selection2);\n+\n+        if let Some(sp) = cm.merge_spans(span1, span2) {\n+            let sstr = cm.span_to_expanded_string(sp);\n+            assert_eq!(sstr, \"blork.rs:1:6: 1:15\\n`BB bb CCC`\\n\");\n+        }\n+        else {\n+            assert!(false);\n+        }\n+    }\n+\n+    /// Test failing to merge two spans on different lines\n+    #[test]\n+    fn span_merging_fail() {\n+        let cm = CodeMap::new();\n+        let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n+        let selection1 = \"     ~~\\n      \\n\";\n+        let selection2 = \"       \\n   ~~~\\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let span1 = span_from_selection(inputtext, selection1);\n+        let span2 = span_from_selection(inputtext, selection2);\n+\n+        assert!(cm.merge_spans(span1, span2).is_none());\n+    }\n+\n     /// Returns the span corresponding to the `n`th occurrence of\n     /// `substring` in `source_text`.\n     trait CodeMapExtension {"}, {"sha": "13dcf7b188b70b4c551a8229cb774ed5992f362e", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ad10844db51b950306d49070932562246e06616/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad10844db51b950306d49070932562246e06616/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6ad10844db51b950306d49070932562246e06616", "patch": "@@ -97,24 +97,6 @@ impl Span {\n         self.lo == other.lo && self.hi == other.hi\n     }\n \n-    /// Returns `Some(span)`, a union of `self` and `other`, on overlap.\n-    pub fn merge(self, other: Span) -> Option<Span> {\n-        if self.expn_id != other.expn_id {\n-            return None;\n-        }\n-\n-        if (self.lo <= other.lo && self.hi > other.lo) ||\n-           (self.lo >= other.lo && self.lo < other.hi) {\n-            Some(Span {\n-                lo: cmp::min(self.lo, other.lo),\n-                hi: cmp::max(self.hi, other.hi),\n-                expn_id: self.expn_id,\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n     pub fn trim_start(self, other: Span) -> Option<Span> {\n         if self.hi > other.hi {"}]}