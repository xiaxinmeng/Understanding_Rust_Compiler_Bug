{"sha": "76c1160ffa626fc5f07b309420e6666eb79a3311", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzExNjBmZmE2MjZmYzVmMDdiMzA5NDIwZTY2NjZlYjc5YTMzMTE=", "commit": {"author": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-05-10T15:35:33Z"}, "committer": {"name": "Veetaha", "email": "veetaha2@gmail.com", "date": "2020-06-18T11:50:56Z"}, "message": "Migrate flycheck to fully-lsp-compatible progress reports (introduce ra_progress crate)", "tree": {"sha": "faa1e1bab885988042fb735f89c7bc5c59127a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa1e1bab885988042fb735f89c7bc5c59127a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c1160ffa626fc5f07b309420e6666eb79a3311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c1160ffa626fc5f07b309420e6666eb79a3311", "html_url": "https://github.com/rust-lang/rust/commit/76c1160ffa626fc5f07b309420e6666eb79a3311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c1160ffa626fc5f07b309420e6666eb79a3311/comments", "author": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8126fcace3c5e7db01c755b91eb45a9c632cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8126fcace3c5e7db01c755b91eb45a9c632cfd", "html_url": "https://github.com/rust-lang/rust/commit/2f8126fcace3c5e7db01c755b91eb45a9c632cfd"}], "stats": {"total": 723, "additions": 361, "deletions": 362}, "files": [{"sha": "08e9c10d82c7a4ce204e630cb7742518c0216cc2", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -963,6 +963,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"log\",\n+ \"ra_progress\",\n  \"ra_toolchain\",\n  \"serde_json\",\n ]\n@@ -1075,6 +1076,7 @@ dependencies = [\n  \"ra_hir\",\n  \"ra_ide_db\",\n  \"ra_prof\",\n+ \"ra_progress\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"rand\",\n@@ -1162,6 +1164,13 @@ dependencies = [\n  \"ra_arena\",\n ]\n \n+[[package]]\n+name = \"ra_progress\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+]\n+\n [[package]]\n name = \"ra_project_model\"\n version = \"0.1.0\"\n@@ -1388,6 +1397,7 @@ dependencies = [\n  \"ra_mbe\",\n  \"ra_proc_macro_srv\",\n  \"ra_prof\",\n+ \"ra_progress\",\n  \"ra_project_model\",\n  \"ra_syntax\",\n  \"ra_text_edit\","}, {"sha": "838973963b9694ba84ca623ba015d826ce7f6249", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -14,3 +14,4 @@ cargo_metadata = \"0.10.0\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n ra_toolchain = { path = \"../ra_toolchain\" }\n+ra_progress = { path = \"../ra_progress\" }"}, {"sha": "7b9f48eb025b0c801f085390397f34c933c5465f", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -3,6 +3,7 @@\n //! LSP diagnostics based on the output of the command.\n \n use std::{\n+    fmt,\n     io::{self, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n@@ -16,6 +17,9 @@ pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n };\n \n+type Progress = ra_progress::Progress<(), String>;\n+type ProgressSource = ra_progress::ProgressSource<(), String>;\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand {\n@@ -31,6 +35,17 @@ pub enum FlycheckConfig {\n     },\n }\n \n+impl fmt::Display for FlycheckConfig {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {}\", command),\n+            FlycheckConfig::CustomCommand { command, args } => {\n+                write!(f, \"{} {}\", command, args.join(\" \"))\n+            }\n+        }\n+    }\n+}\n+\n /// Flycheck wraps the shared state and communication machinery used for\n /// running `cargo check` (or other compatible command) and providing\n /// diagnostics based on the output.\n@@ -44,11 +59,15 @@ pub struct Flycheck {\n }\n \n impl Flycheck {\n-    pub fn new(config: FlycheckConfig, workspace_root: PathBuf) -> Flycheck {\n+    pub fn new(\n+        config: FlycheckConfig,\n+        workspace_root: PathBuf,\n+        progress_src: ProgressSource,\n+    ) -> Flycheck {\n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n         let handle = jod_thread::spawn(move || {\n-            FlycheckThread::new(config, workspace_root).run(&task_send, &cmd_recv);\n+            FlycheckThread::new(config, workspace_root, progress_src).run(&task_send, &cmd_recv);\n         });\n         Flycheck { task_recv, cmd_send, handle }\n     }\n@@ -66,16 +85,6 @@ pub enum CheckTask {\n \n     /// Request adding a diagnostic with fixes included to a file\n     AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n-\n-    /// Request check progress notification to client\n-    Status(Status),\n-}\n-\n-#[derive(Debug)]\n-pub enum Status {\n-    Being,\n-    Progress(String),\n-    End,\n }\n \n pub enum CheckCommand {\n@@ -87,6 +96,8 @@ struct FlycheckThread {\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n     last_update_req: Option<Instant>,\n+    progress_src: ProgressSource,\n+    progress: Option<Progress>,\n     // XXX: drop order is significant\n     message_recv: Receiver<CheckEvent>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n@@ -98,11 +109,17 @@ struct FlycheckThread {\n }\n \n impl FlycheckThread {\n-    fn new(config: FlycheckConfig, workspace_root: PathBuf) -> FlycheckThread {\n+    fn new(\n+        config: FlycheckConfig,\n+        workspace_root: PathBuf,\n+        progress_src: ProgressSource,\n+    ) -> FlycheckThread {\n         FlycheckThread {\n             config,\n             workspace_root,\n+            progress_src,\n             last_update_req: None,\n+            progress: None,\n             message_recv: never(),\n             check_process: None,\n         }\n@@ -140,9 +157,9 @@ impl FlycheckThread {\n         }\n     }\n \n-    fn clean_previous_results(&self, task_send: &Sender<CheckTask>) {\n+    fn clean_previous_results(&mut self, task_send: &Sender<CheckTask>) {\n         task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-        task_send.send(CheckTask::Status(Status::End)).unwrap();\n+        self.progress = None;\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -161,18 +178,17 @@ impl FlycheckThread {\n         }\n     }\n \n-    fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n+    fn handle_message(&mut self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n-                task_send.send(CheckTask::Status(Status::Being)).unwrap();\n+                self.progress = Some(self.progress_src.begin(()));\n             }\n-\n-            CheckEvent::End => {\n-                task_send.send(CheckTask::Status(Status::End)).unwrap();\n-            }\n-\n+            CheckEvent::End => self.progress = None,\n             CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n-                task_send.send(CheckTask::Status(Status::Progress(msg.target.name))).unwrap();\n+                self.progress\n+                    .as_mut()\n+                    .expect(\"check process reported progress without the 'Begin' notification\")\n+                    .report(msg.target.name);\n             }\n \n             CheckEvent::Msg(Message::CompilerMessage(msg)) => {"}, {"sha": "722652fb2dca80e11732a86070bb64e694548b92", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -29,6 +29,7 @@ ra_fmt = { path = \"../ra_fmt\" }\n ra_prof = { path = \"../ra_prof\" }\n test_utils = { path = \"../test_utils\" }\n ra_assists = { path = \"../ra_assists\" }\n+ra_progress = { path = \"../ra_progress\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`."}, {"sha": "51dc1f041ca51edadfd997253a76d06738594d5b", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -241,11 +241,8 @@ impl Analysis {\n         self.with_db(|db| status::status(&*db))\n     }\n \n-    pub fn prime_caches<P>(&self, files: Vec<FileId>, report_progress: P) -> Cancelable<()>\n-    where\n-        P: FnMut(usize) + std::panic::UnwindSafe,\n-    {\n-        self.with_db(|db| prime_caches::prime_caches(db, files, report_progress))\n+    pub fn prime_caches(&self, files: Vec<FileId>) -> Cancelable<()> {\n+        self.with_db(|db| prime_caches::prime_caches(db, files))\n     }\n \n     /// Gets the text of the source file."}, {"sha": "c5ab5a1d87ba18d94068ec8bceb6514525d998ec", "filename": "crates/ra_ide/src/prime_caches.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_ide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_ide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fprime_caches.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -5,13 +5,8 @@\n \n use crate::{FileId, RootDatabase};\n \n-pub(crate) fn prime_caches(\n-    db: &RootDatabase,\n-    files: Vec<FileId>,\n-    mut report_progress: impl FnMut(usize),\n-) {\n-    for (i, file) in files.into_iter().enumerate() {\n+pub(crate) fn prime_caches(db: &RootDatabase, files: Vec<FileId>) {\n+    for file in files {\n         let _ = crate::syntax_highlighting::highlight(db, file, None, false);\n-        report_progress(i);\n     }\n }"}, {"sha": "c7f7c6dd3421e452f74fdddfb873d945f6cc2da0", "filename": "crates/ra_progress/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_progress%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_progress%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_progress%2FCargo.toml?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"ra_progress\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+crossbeam-channel = { version = \"0.4\" }"}, {"sha": "0ff1f846ca1b9726362b029e62f45288b5b7d102", "filename": "crates/ra_progress/src/lib.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_progress%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Fra_progress%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_progress%2Fsrc%2Flib.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -0,0 +1,129 @@\n+//! General-purpose instrumentation for progress reporting.\n+//!\n+//! Note:\n+//! Most of the methods accept `&mut self` just to be more restrictive (for forward compat)\n+//! even tho for some of them we can weaken this requirement to shared reference (`&self`).\n+\n+use crossbeam_channel::Receiver;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+pub enum ProgressStatus<B, P> {\n+    Begin(B),\n+    Progress(P),\n+    End,\n+}\n+\n+pub struct Progress<B, P>(Option<crossbeam_channel::Sender<ProgressStatus<B, P>>>);\n+impl<B, P> Progress<B, P> {\n+    pub fn report(&mut self, payload: P) {\n+        self.report_with(|| payload);\n+    }\n+\n+    pub fn report_with(&mut self, payload: impl FnOnce() -> P) {\n+        self.send_status(|| ProgressStatus::Progress(payload()));\n+    }\n+\n+    fn send_status(&self, status: impl FnOnce() -> ProgressStatus<B, P>) {\n+        if let Some(sender) = &self.0 {\n+            sender.try_send(status()).expect(\"progress report must not block\");\n+        }\n+    }\n+}\n+\n+impl<B, P> Drop for Progress<B, P> {\n+    fn drop(&mut self) {\n+        self.send_status(|| ProgressStatus::End);\n+    }\n+}\n+\n+pub struct ProgressSource<B, P>(Option<crossbeam_channel::Sender<ProgressStatus<B, P>>>);\n+impl<B, P> ProgressSource<B, P> {\n+    pub fn real_if(real: bool) -> (Receiver<ProgressStatus<B, P>>, Self) {\n+        if real {\n+            let (sender, receiver) = crossbeam_channel::unbounded();\n+            (receiver, Self(Some(sender)))\n+        } else {\n+            (crossbeam_channel::never(), Self(None))\n+        }\n+    }\n+\n+    pub fn begin(&mut self, payload: B) -> Progress<B, P> {\n+        self.begin_with(|| payload)\n+    }\n+\n+    pub fn begin_with(&mut self, payload: impl FnOnce() -> B) -> Progress<B, P> {\n+        let progress = Progress(self.0.clone());\n+        progress.send_status(|| ProgressStatus::Begin(payload()));\n+        progress\n+    }\n+}\n+\n+impl<B, P> Clone for ProgressSource<B, P> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+\n+impl<B, P> fmt::Debug for ProgressSource<B, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"ProgressSource\").field(&self.0).finish()\n+    }\n+}\n+\n+pub type U32ProgressStatus = ProgressStatus<U32ProgressReport, U32ProgressReport>;\n+\n+#[derive(Debug)]\n+pub struct U32ProgressReport {\n+    pub processed: u32,\n+    pub total: u32,\n+}\n+impl U32ProgressReport {\n+    pub fn percentage(&self) -> f64 {\n+        f64::from(100 * self.processed) / f64::from(self.total)\n+    }\n+    pub fn to_message(&self, prefix: &str, unit: &str) -> String {\n+        format!(\"{} ({}/{} {})\", prefix, self.processed, self.total, unit)\n+    }\n+}\n+\n+pub struct U32Progress {\n+    inner: Progress<U32ProgressReport, U32ProgressReport>,\n+    processed: u32,\n+    total: u32,\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct IsDone(pub bool);\n+\n+impl U32Progress {\n+    pub fn report(&mut self, new_processed: u32) -> IsDone {\n+        if self.processed < new_processed {\n+            self.processed = new_processed;\n+            self.inner.report(U32ProgressReport { processed: new_processed, total: self.total });\n+        }\n+        IsDone(self.processed >= self.total)\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct U32ProgressSource {\n+    inner: ProgressSource<U32ProgressReport, U32ProgressReport>,\n+}\n+\n+impl U32ProgressSource {\n+    pub fn real_if(\n+        real: bool,\n+    ) -> (Receiver<ProgressStatus<U32ProgressReport, U32ProgressReport>>, Self) {\n+        let (recv, inner) = ProgressSource::real_if(real);\n+        (recv, Self { inner })\n+    }\n+\n+    pub fn begin(&mut self, initial: u32, total: u32) -> U32Progress {\n+        U32Progress {\n+            inner: self.inner.begin(U32ProgressReport { processed: initial, total }),\n+            processed: initial,\n+            total,\n+        }\n+    }\n+}"}, {"sha": "22f6b45ddca7a6a78b2080434cb81dc300685238", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -48,6 +48,7 @@ hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n ra_proc_macro_srv = { path = \"../ra_proc_macro_srv\" }\n+ra_progress = { path = \"../ra_progress\" }\n \n [target.'cfg(windows)'.dependencies]\n winapi = \"0.3.8\""}, {"sha": "2d854cecf25107c7bee03a4eec84b35f86c86cbe", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -26,14 +26,19 @@ use crate::{\n     LspError, Result,\n };\n use ra_db::{CrateId, ExternSourceId};\n+use ra_progress::{ProgressSource, ProgressStatus};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n+fn create_flycheck(\n+    workspaces: &[ProjectWorkspace],\n+    config: &FlycheckConfig,\n+    progress_src: &ProgressSource<(), String>,\n+) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n-    workspaces.iter().find_map(|w| match w {\n+    workspaces.iter().find_map(move |w| match w {\n         ProjectWorkspace::Cargo { cargo, .. } => {\n             let cargo_project_root = cargo.workspace_root().to_path_buf();\n-            Some(Flycheck::new(config.clone(), cargo_project_root))\n+            Some(Flycheck::new(config.clone(), cargo_project_root, progress_src.clone()))\n         }\n         ProjectWorkspace::Json { .. } => {\n             log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n@@ -59,6 +64,8 @@ pub struct GlobalState {\n     pub flycheck: Option<Flycheck>,\n     pub diagnostics: DiagnosticCollection,\n     pub proc_macro_client: ProcMacroClient,\n+    pub flycheck_progress_src: ProgressSource<(), String>,\n+    pub flycheck_progress_receiver: Receiver<ProgressStatus<(), String>>,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -158,7 +165,12 @@ impl GlobalState {\n         }\n         change.set_crate_graph(crate_graph);\n \n-        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n+        let (flycheck_progress_receiver, flycheck_progress_src) =\n+            ProgressSource::real_if(config.client_caps.work_done_progress);\n+        let flycheck = config\n+            .check\n+            .as_ref()\n+            .and_then(|c| create_flycheck(&workspaces, c, &flycheck_progress_src));\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n@@ -171,6 +183,8 @@ impl GlobalState {\n             task_receiver,\n             latest_requests: Default::default(),\n             flycheck,\n+            flycheck_progress_src,\n+            flycheck_progress_receiver,\n             diagnostics: Default::default(),\n             proc_macro_client,\n         }\n@@ -179,16 +193,18 @@ impl GlobalState {\n     pub fn update_configuration(&mut self, config: Config) {\n         self.analysis_host.update_lru_capacity(config.lru_capacity);\n         if config.check != self.config.check {\n-            self.flycheck =\n-                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n+            self.flycheck = config\n+                .check\n+                .as_ref()\n+                .and_then(|it| create_flycheck(&self.workspaces, it, &self.flycheck_progress_src));\n         }\n \n         self.config = config;\n     }\n \n     /// Returns a vec of libraries\n     /// FIXME: better API here\n-    pub fn process_changes(&mut self, roots_scanned: &mut usize) -> bool {\n+    pub fn process_changes(&mut self, roots_scanned: &mut u32) -> bool {\n         let changes = self.vfs.write().commit_changes();\n         if changes.is_empty() {\n             return false;"}, {"sha": "740c52e21ff6637fe412eff7bac533a7001e7562", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 137, "deletions": 86, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -4,11 +4,11 @@\n mod handlers;\n mod subscriptions;\n pub(crate) mod pending_requests;\n-mod progress;\n mod lsp_utils;\n \n use std::{\n     borrow::Cow,\n+    convert::TryFrom,\n     env,\n     error::Error,\n     fmt,\n@@ -20,12 +20,8 @@ use std::{\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n-use lsp_types::{\n-    DidChangeTextDocumentParams, NumberOrString, TextDocumentContentChangeEvent, WorkDoneProgress,\n-    WorkDoneProgressBegin, WorkDoneProgressCreateParams, WorkDoneProgressEnd,\n-    WorkDoneProgressReport,\n-};\n-use ra_flycheck::{CheckTask, Status};\n+use lsp_types::{DidChangeTextDocumentParams, NumberOrString, TextDocumentContentChangeEvent};\n+use ra_flycheck::CheckTask;\n use ra_ide::{Canceled, FileId, LineIndex};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n@@ -48,7 +44,12 @@ use crate::{\n };\n pub use lsp_utils::show_message;\n use lsp_utils::{is_canceled, notification_cast, notification_is, notification_new, request_new};\n-use progress::{IsDone, PrimeCachesProgressNotifier, WorkspaceAnalysisProgressNotifier};\n+use ra_progress::{\n+    IsDone, ProgressStatus, U32Progress, U32ProgressReport, U32ProgressSource, U32ProgressStatus,\n+};\n+\n+const FLYCHECK_PROGRESS_TOKEN: &str = \"rustAnalyzer/flycheck\";\n+const ROOTS_SCANNED_PROGRESS_TOKEN: &str = \"rustAnalyzer/rootsScanned\";\n \n #[derive(Debug)]\n pub struct LspError {\n@@ -95,7 +96,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     }\n \n     let mut loop_state = LoopState::default();\n-\n     let mut global_state = {\n         let workspaces = {\n             if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n@@ -169,13 +169,16 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         GlobalState::new(workspaces, config.lru_capacity, &globs, config)\n     };\n \n-    loop_state.roots_total = global_state.vfs.read().n_roots();\n+    loop_state.roots_total = u32::try_from(global_state.vfs.read().n_roots())\n+        .expect(\"Wow, your project is so huge, that it cannot fit into u32...\");\n+\n     loop_state.roots_scanned = 0;\n-    loop_state.roots_progress = Some(WorkspaceAnalysisProgressNotifier::begin(\n-        connection.sender.clone(),\n-        loop_state.next_request_id(),\n-        loop_state.roots_total,\n-    ));\n+    let mut roots_scanned_progress_receiver = {\n+        let (recv, mut progress_src) =\n+            U32ProgressSource::real_if(global_state.config.client_caps.work_done_progress);\n+        loop_state.roots_progress = Some(progress_src.begin(0, loop_state.roots_total));\n+        recv\n+    };\n \n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n@@ -198,6 +201,18 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n+                },\n+                recv(global_state.flycheck_progress_receiver) -> status => match status {\n+                    Ok(status) => Event::ProgressReport(ProgressReport::Flycheck(status)),\n+                    Err(RecvError) => return Err(\"check watcher died\".into()),\n+                },\n+                recv(roots_scanned_progress_receiver) -> status => match status {\n+                    Ok(status) => Event::ProgressReport(ProgressReport::RootsScanned(status)),\n+                    Err(RecvError) => {\n+                        // Roots analysis has finished, we no longer need this receiver\n+                        roots_scanned_progress_receiver = never();\n+                        continue;\n+                    }\n                 }\n             };\n             if let Event::Msg(Message::Request(req)) = &event {\n@@ -228,7 +243,7 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n #[derive(Debug)]\n enum Task {\n     Respond(Response),\n-    Notify(Notification),\n+    SendMessage(Message),\n     Diagnostic(DiagnosticTask),\n }\n \n@@ -237,6 +252,13 @@ enum Event {\n     Task(Task),\n     Vfs(VfsTask),\n     CheckWatcher(CheckTask),\n+    ProgressReport(ProgressReport),\n+}\n+\n+#[derive(Debug)]\n+enum ProgressReport {\n+    Flycheck(ProgressStatus<(), String>),\n+    RootsScanned(U32ProgressStatus),\n }\n \n impl fmt::Debug for Event {\n@@ -253,7 +275,7 @@ impl fmt::Debug for Event {\n                     return debug_verbose_not(not, f);\n                 }\n             }\n-            Event::Task(Task::Notify(not)) => {\n+            Event::Task(Task::SendMessage(Message::Notification(not))) => {\n                 if notification_is::<lsp_types::notification::PublishDiagnostics>(not) {\n                     return debug_verbose_not(not, f);\n                 }\n@@ -272,20 +294,21 @@ impl fmt::Debug for Event {\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n             Event::CheckWatcher(it) => fmt::Debug::fmt(it, f),\n+            Event::ProgressReport(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n }\n \n-#[derive(Debug, Default)]\n+#[derive(Default)]\n struct LoopState {\n     next_request_id: u64,\n     pending_responses: FxHashSet<RequestId>,\n     pending_requests: PendingRequests,\n     subscriptions: Subscriptions,\n     workspace_loaded: bool,\n-    roots_progress: Option<WorkspaceAnalysisProgressNotifier>,\n-    roots_scanned: usize,\n-    roots_total: usize,\n+    roots_progress: Option<U32Progress>,\n+    roots_scanned: u32,\n+    roots_total: u32,\n     configuration_request_id: Option<RequestId>,\n }\n \n@@ -326,6 +349,9 @@ fn loop_turn(\n             global_state.vfs.write().handle_task(task);\n         }\n         Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n+        Event::ProgressReport(report) => {\n+            on_progress_report(report, task_sender, loop_state, global_state)\n+        }\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 global_state,\n@@ -384,7 +410,13 @@ fn loop_turn(\n     }\n \n     if show_progress {\n-        send_workspace_analisys_progress(loop_state);\n+        if let Some(progress) = &mut loop_state.roots_progress {\n+            if loop_state.workspace_loaded\n+                || progress.report(loop_state.roots_scanned) == IsDone(true)\n+            {\n+                loop_state.roots_progress = None;\n+            }\n+        }\n     }\n \n     if state_changed && loop_state.workspace_loaded {\n@@ -397,22 +429,7 @@ fn loop_turn(\n         pool.execute({\n             let subs = loop_state.subscriptions.subscriptions();\n             let snap = global_state.snapshot();\n-\n-            let total = subs.len();\n-\n-            let mut progress = PrimeCachesProgressNotifier::begin(\n-                connection.sender.clone(),\n-                loop_state.next_request_id(),\n-                total,\n-            );\n-\n-            move || {\n-                snap.analysis()\n-                    .prime_caches(subs, move |i| {\n-                        progress.report(i + 1);\n-                    })\n-                    .unwrap_or_else(|_: Canceled| ());\n-            }\n+            move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n     }\n \n@@ -431,6 +448,87 @@ fn loop_turn(\n     Ok(())\n }\n \n+fn on_progress_report(\n+    report: ProgressReport,\n+    task_sender: &Sender<Task>,\n+    loop_state: &mut LoopState,\n+    global_state: &GlobalState,\n+) {\n+    let end_report =\n+        || lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message: None });\n+    let mut create_progress = |token: &'static str| {\n+        let create_progress_req = request_new::<lsp_types::request::WorkDoneProgressCreate>(\n+            loop_state.next_request_id(),\n+            lsp_types::WorkDoneProgressCreateParams {\n+                token: lsp_types::ProgressToken::String(token.to_string()),\n+            },\n+        );\n+        task_sender.send(Task::SendMessage(create_progress_req.into())).unwrap();\n+    };\n+\n+    let (token, progress) = match report {\n+        ProgressReport::Flycheck(status) => {\n+            let command = global_state\n+                .config\n+                .check\n+                .as_ref()\n+                .expect(\"There should be config, since flycheck is active\");\n+\n+            let progress = match status {\n+                ProgressStatus::Begin(()) => {\n+                    create_progress(FLYCHECK_PROGRESS_TOKEN);\n+                    lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n+                        title: \"\".to_string(),\n+                        cancellable: Some(false),\n+                        message: Some(command.to_string()),\n+                        percentage: None,\n+                    })\n+                }\n+                ProgressStatus::Progress(target) => {\n+                    lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n+                        cancellable: Some(false),\n+                        message: Some(format!(\"{} [{}]\", command, target)),\n+                        percentage: None,\n+                    })\n+                }\n+                ProgressStatus::End => end_report(),\n+            };\n+            (FLYCHECK_PROGRESS_TOKEN, progress)\n+        }\n+        ProgressReport::RootsScanned(status) => {\n+            fn to_message(report: &U32ProgressReport) -> String {\n+                report.to_message(\"analyzing the workspace\", \"packages\")\n+            }\n+            let progress = match status {\n+                ProgressStatus::Begin(report) => {\n+                    create_progress(ROOTS_SCANNED_PROGRESS_TOKEN);\n+                    lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n+                        title: \"rust-analyzer\".to_string(),\n+                        cancellable: Some(false),\n+                        message: Some(to_message(&report)),\n+                        percentage: Some(report.percentage()),\n+                    })\n+                }\n+                ProgressStatus::Progress(report) => {\n+                    lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n+                        cancellable: Some(false),\n+                        message: Some(to_message(&report)),\n+                        percentage: Some(report.percentage()),\n+                    })\n+                }\n+                ProgressStatus::End => end_report(),\n+            };\n+            (ROOTS_SCANNED_PROGRESS_TOKEN, progress)\n+        }\n+    };\n+    let params = lsp_types::ProgressParams {\n+        token: lsp_types::ProgressToken::String(token.to_string()),\n+        value: lsp_types::ProgressParamsValue::WorkDone(progress),\n+    };\n+    let not = notification_new::<lsp_types::notification::Progress>(params);\n+    task_sender.send(Task::SendMessage(not.into())).unwrap()\n+}\n+\n fn on_task(\n     task: Task,\n     msg_sender: &Sender<Message>,\n@@ -445,9 +543,7 @@ fn on_task(\n                 msg_sender.send(response.into()).unwrap();\n             }\n         }\n-        Task::Notify(n) => {\n-            msg_sender.send(n.into()).unwrap();\n-        }\n+        Task::SendMessage(msg) => msg_sender.send(msg).unwrap(),\n         Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, state),\n     }\n }\n@@ -718,42 +814,6 @@ fn on_check_task(\n                 )))?;\n             }\n         }\n-\n-        CheckTask::Status(status) => {\n-            if global_state.config.client_caps.work_done_progress {\n-                let progress = match status {\n-                    Status::Being => {\n-                        lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n-                            title: \"Running `cargo check`\".to_string(),\n-                            cancellable: Some(false),\n-                            message: None,\n-                            percentage: None,\n-                        })\n-                    }\n-                    Status::Progress(target) => {\n-                        lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n-                            cancellable: Some(false),\n-                            message: Some(target),\n-                            percentage: None,\n-                        })\n-                    }\n-                    Status::End => {\n-                        lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd {\n-                            message: None,\n-                        })\n-                    }\n-                };\n-\n-                let params = lsp_types::ProgressParams {\n-                    token: lsp_types::ProgressToken::String(\n-                        \"rustAnalyzer/cargoWatcher\".to_string(),\n-                    ),\n-                    value: lsp_types::ProgressParamsValue::WorkDone(progress),\n-                };\n-                let not = notification_new::<lsp_types::notification::Progress>(params);\n-                task_sender.send(Task::Notify(not)).unwrap();\n-            }\n-        }\n     };\n \n     Ok(())\n@@ -771,15 +831,6 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n     }\n }\n \n-fn send_workspace_analisys_progress(loop_state: &mut LoopState) {\n-    if let Some(progress) = &mut loop_state.roots_progress {\n-        if loop_state.workspace_loaded || progress.report(loop_state.roots_scanned) == IsDone(true)\n-        {\n-            loop_state.roots_progress = None;\n-        }\n-    }\n-}\n-\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,"}, {"sha": "c790227972bb346fd8a79d4d6d20f9a378122c97", "filename": "crates/rust-analyzer/src/main_loop/lsp_utils.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Flsp_utils.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -1,10 +1,16 @@\n+//! Utilities for LSP-related boilerplate code.\n+\n use crossbeam_channel::Sender;\n use lsp_server::{Message, Notification, Request, RequestId};\n use ra_db::Canceled;\n use serde::{de::DeserializeOwned, Serialize};\n use std::error::Error;\n \n-pub fn show_message(typ: lsp_types::MessageType, message: impl Into<String>, sender: &Sender<Message>) {\n+pub fn show_message(\n+    typ: lsp_types::MessageType,\n+    message: impl Into<String>,\n+    sender: &Sender<Message>,\n+) {\n     let message = message.into();\n     let params = lsp_types::ShowMessageParams { typ, message };\n     let not = notification_new::<lsp_types::notification::ShowMessage>(params);"}, {"sha": "610e026ca28695f4bf39cea168cd470f31ee4fc1", "filename": "crates/rust-analyzer/src/main_loop/progress.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/2f8126fcace3c5e7db01c755b91eb45a9c632cfd/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fprogress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8126fcace3c5e7db01c755b91eb45a9c632cfd/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fprogress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fprogress.rs?ref=2f8126fcace3c5e7db01c755b91eb45a9c632cfd", "patch": "@@ -1,129 +0,0 @@\n-use super::lsp_utils::{notification_new, request_new};\n-use crossbeam_channel::Sender;\n-use lsp_server::{Message, RequestId};\n-use lsp_types::{\n-    WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressCreateParams, WorkDoneProgressEnd,\n-    WorkDoneProgressReport,\n-};\n-\n-const PRIME_CACHES_PROGRESS_TOKEN: &str = \"rustAnalyzer/primeCaches\";\n-const WORKSPACE_ANALYSIS_PROGRESS_TOKEN: &str = \"rustAnalyzer/workspaceAnalysis\";\n-\n-#[derive(Debug)]\n-pub(crate) struct PrimeCachesProgressNotifier(ProgressNotifier);\n-\n-impl Drop for PrimeCachesProgressNotifier {\n-    fn drop(&mut self) {\n-        self.0.end(\"done priming caches\".to_owned());\n-    }\n-}\n-\n-impl PrimeCachesProgressNotifier {\n-    pub(crate) fn begin(sender: Sender<Message>, req_id: RequestId, total: usize) -> Self {\n-        let me = Self(ProgressNotifier {\n-            sender,\n-            processed: 0,\n-            total,\n-            token: PRIME_CACHES_PROGRESS_TOKEN,\n-            label: \"priming caches\",\n-        });\n-        me.0.begin(req_id);\n-        me\n-    }\n-\n-    pub(crate) fn report(&mut self, processed: usize) -> IsDone {\n-        self.0.report(processed)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct WorkspaceAnalysisProgressNotifier(ProgressNotifier);\n-\n-impl Drop for WorkspaceAnalysisProgressNotifier {\n-    fn drop(&mut self) {\n-        self.0.end(\"done analyzing workspace\".to_owned());\n-    }\n-}\n-\n-impl WorkspaceAnalysisProgressNotifier {\n-    pub(crate) fn begin(sender: Sender<Message>, req_id: RequestId, total: usize) -> Self {\n-        let me = Self(ProgressNotifier {\n-            sender,\n-            total,\n-            processed: 0,\n-            token: WORKSPACE_ANALYSIS_PROGRESS_TOKEN,\n-            label: \"analyzing packages\",\n-        });\n-        me.0.begin(req_id);\n-        me\n-    }\n-\n-    pub(crate) fn report(&mut self, processed: usize) -> IsDone {\n-        self.0.report(processed)\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct IsDone(pub bool);\n-\n-#[derive(Debug)]\n-struct ProgressNotifier {\n-    sender: Sender<Message>,\n-    token: &'static str,\n-    label: &'static str,\n-    processed: usize,\n-    total: usize,\n-}\n-\n-impl ProgressNotifier {\n-    fn begin(&self, req_id: RequestId) {\n-        let create_req = request_new::<lsp_types::request::WorkDoneProgressCreate>(\n-            req_id,\n-            WorkDoneProgressCreateParams {\n-                token: lsp_types::ProgressToken::String(self.token.to_owned()),\n-            },\n-        );\n-        self.sender.send(create_req.into()).unwrap();\n-        self.send_notification(WorkDoneProgress::Begin(WorkDoneProgressBegin {\n-            cancellable: None,\n-            title: \"rust-analyzer\".to_owned(),\n-            percentage: Some(self.percentage()),\n-            message: Some(self.create_progress_message()),\n-        }));\n-    }\n-\n-    fn report(&mut self, processed: usize) -> IsDone {\n-        if self.processed != processed {\n-            self.processed = processed;\n-\n-            self.send_notification(WorkDoneProgress::Report(WorkDoneProgressReport {\n-                cancellable: None,\n-                percentage: Some(self.percentage()),\n-                message: Some(self.create_progress_message()),\n-            }));\n-        }\n-        IsDone(processed >= self.total)\n-    }\n-\n-    fn end(&mut self, message: String) {\n-        self.send_notification(WorkDoneProgress::End(WorkDoneProgressEnd {\n-            message: Some(message),\n-        }));\n-    }\n-\n-    fn send_notification(&self, progress: WorkDoneProgress) {\n-        let notif = notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n-            token: lsp_types::ProgressToken::String(self.token.to_owned()),\n-            value: lsp_types::ProgressParamsValue::WorkDone(progress),\n-        });\n-        self.sender.send(notif.into()).unwrap();\n-    }\n-\n-    fn create_progress_message(&self) -> String {\n-        format!(\"{} ({}/{})\", self.label, self.processed, self.total)\n-    }\n-\n-    fn percentage(&self) -> f64 {\n-        (100 * self.processed) as f64 / self.total as f64\n-    }\n-}"}, {"sha": "c68cdf862e7082b57023a01636ff12e53bcad303", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -212,7 +212,7 @@ impl Server {\n                     ProgressParams {\n                         token: lsp_types::ProgressToken::String(ref token),\n                         value: ProgressParamsValue::WorkDone(WorkDoneProgress::End(_)),\n-                    } if token == \"rustAnalyzer/workspaceAnalysis\" => true,\n+                    } if token == \"rustAnalyzer/rootsScanned\" => true,\n                     _ => false,\n                 }\n             }"}, {"sha": "16a94fceb1bc80f363aa23a97f1d6ca2782dbb1e", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76c1160ffa626fc5f07b309420e6666eb79a3311/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/76c1160ffa626fc5f07b309420e6666eb79a3311/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=76c1160ffa626fc5f07b309420e6666eb79a3311", "patch": "@@ -5,7 +5,6 @@ import { promises as fs, PathLike } from \"fs\";\n \n import * as commands from './commands';\n import { activateInlayHints } from './inlay_hints';\n-import { activateStatusDisplay } from './status_display';\n import { Ctx } from './ctx';\n import { Config, NIGHTLY_TAG } from './config';\n import { log, assert, isValidExecutable } from './util';\n@@ -103,8 +102,6 @@ export async function activate(context: vscode.ExtensionContext) {\n \n     ctx.pushCleanup(activateTaskProvider(workspaceFolder));\n \n-    activateStatusDisplay(ctx);\n-\n     activateInlayHints(ctx);\n \n     vscode.workspace.onDidChangeConfiguration("}, {"sha": "f9cadc8a2258c0834f3fa6a74a5efb935bcecdaf", "filename": "editors/code/src/status_display.ts", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2f8126fcace3c5e7db01c755b91eb45a9c632cfd/editors%2Fcode%2Fsrc%2Fstatus_display.ts", "raw_url": "https://github.com/rust-lang/rust/raw/2f8126fcace3c5e7db01c755b91eb45a9c632cfd/editors%2Fcode%2Fsrc%2Fstatus_display.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fstatus_display.ts?ref=2f8126fcace3c5e7db01c755b91eb45a9c632cfd", "patch": "@@ -1,100 +0,0 @@\n-import * as vscode from 'vscode';\n-\n-import { WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressReport, WorkDoneProgressEnd, Disposable } from 'vscode-languageclient';\n-\n-import { Ctx } from './ctx';\n-\n-const spinnerFrames = ['\u280b', '\u2819', '\u2839', '\u2838', '\u283c', '\u2834', '\u2826', '\u2827', '\u2807', '\u280f'];\n-\n-export function activateStatusDisplay(ctx: Ctx) {\n-    const statusDisplay = new StatusDisplay(ctx.config.checkOnSave.command);\n-    ctx.pushCleanup(statusDisplay);\n-    const client = ctx.client;\n-    if (client != null) {\n-        ctx.pushCleanup(client.onProgress(\n-            WorkDoneProgress.type,\n-            'rustAnalyzer/cargoWatcher',\n-            params => statusDisplay.handleProgressNotification(params)\n-        ));\n-    }\n-}\n-\n-class StatusDisplay implements Disposable {\n-    packageName?: string;\n-\n-    private i: number = 0;\n-    private statusBarItem: vscode.StatusBarItem;\n-    private command: string;\n-    private timer?: NodeJS.Timeout;\n-\n-    constructor(command: string) {\n-        this.statusBarItem = vscode.window.createStatusBarItem(\n-            vscode.StatusBarAlignment.Left,\n-            10,\n-        );\n-        this.command = command;\n-        this.statusBarItem.hide();\n-    }\n-\n-    show() {\n-        this.packageName = undefined;\n-\n-        this.timer =\n-            this.timer ||\n-            setInterval(() => {\n-                this.tick();\n-                this.refreshLabel();\n-            }, 300);\n-\n-        this.statusBarItem.show();\n-    }\n-\n-    hide() {\n-        if (this.timer) {\n-            clearInterval(this.timer);\n-            this.timer = undefined;\n-        }\n-\n-        this.statusBarItem.hide();\n-    }\n-\n-    dispose() {\n-        if (this.timer) {\n-            clearInterval(this.timer);\n-            this.timer = undefined;\n-        }\n-\n-        this.statusBarItem.dispose();\n-    }\n-\n-    refreshLabel() {\n-        if (this.packageName) {\n-            this.statusBarItem.text = `${spinnerFrames[this.i]} cargo ${this.command} [${this.packageName}]`;\n-        } else {\n-            this.statusBarItem.text = `${spinnerFrames[this.i]} cargo ${this.command}`;\n-        }\n-    }\n-\n-    handleProgressNotification(params: WorkDoneProgressBegin | WorkDoneProgressReport | WorkDoneProgressEnd) {\n-        switch (params.kind) {\n-            case 'begin':\n-                this.show();\n-                break;\n-\n-            case 'report':\n-                if (params.message) {\n-                    this.packageName = params.message;\n-                    this.refreshLabel();\n-                }\n-                break;\n-\n-            case 'end':\n-                this.hide();\n-                break;\n-        }\n-    }\n-\n-    private tick() {\n-        this.i = (this.i + 1) % spinnerFrames.length;\n-    }\n-}"}]}