{"sha": "a3b83c6224498875d7bacf8f3ad553abe0ecc196", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYjgzYzYyMjQ0OTg4NzVkN2JhY2Y4ZjNhZDU1M2FiZTBlY2MxOTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-29T23:21:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-30T18:40:44Z"}, "message": "rustc: Translate \"deriving\" for monomorphic intra-crate enums. r=brson", "tree": {"sha": "f95770212b79f95ec87d051c85b4d00bf4f3647c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f95770212b79f95ec87d051c85b4d00bf4f3647c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3b83c6224498875d7bacf8f3ad553abe0ecc196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b83c6224498875d7bacf8f3ad553abe0ecc196", "html_url": "https://github.com/rust-lang/rust/commit/a3b83c6224498875d7bacf8f3ad553abe0ecc196", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3b83c6224498875d7bacf8f3ad553abe0ecc196/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "675c272dadc8cd7e529fda64904c87e8243fe94f", "url": "https://api.github.com/repos/rust-lang/rust/commits/675c272dadc8cd7e529fda64904c87e8243fe94f", "html_url": "https://github.com/rust-lang/rust/commit/675c272dadc8cd7e529fda64904c87e8243fe94f"}], "stats": {"total": 252, "additions": 214, "deletions": 38}, "files": [{"sha": "4410d79438084e6326ef45b56b6a784a0de8bb33", "filename": "src/rustc/middle/trans/deriving.rs", "status": "modified", "additions": 182, "deletions": 38, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a3b83c6224498875d7bacf8f3ad553abe0ecc196/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b83c6224498875d7bacf8f3ad553abe0ecc196/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=a3b83c6224498875d7bacf8f3ad553abe0ecc196", "patch": "@@ -2,18 +2,18 @@\n // enums and structs only; other types cannot be automatically derived.\n \n use lib::llvm::llvm;\n-use middle::trans::base::{finish_fn, get_insn_ctxt, get_item_val};\n+use middle::trans::base::{GEP_enum, finish_fn, get_insn_ctxt, get_item_val};\n use middle::trans::base::{new_fn_ctxt, sub_block, top_scope_block};\n-use middle::trans::build::{Br, CondBr, GEPi, Load, PointerCast, Store};\n-use middle::trans::build::{ValueRef};\n+use middle::trans::build::{AddCase, Br, CondBr, GEPi, Load, PointerCast};\n+use middle::trans::build::{Store, Switch, Unreachable, ValueRef};\n use middle::trans::callee;\n use middle::trans::callee::{ArgVals, Callee, DontAutorefArg, Method};\n use middle::trans::callee::{MethodData};\n use middle::trans::common;\n-use middle::trans::common::{C_bool, T_ptr, block, crate_ctxt};\n+use middle::trans::common::{C_bool, C_int, T_ptr, block, crate_ctxt};\n use middle::trans::expr::SaveIn;\n use middle::trans::type_of::type_of;\n-use middle::typeck::method_static;\n+use middle::typeck::{method_origin, method_static};\n use syntax::ast;\n use syntax::ast::{def_id, ident, node_id, ty_param};\n use syntax::ast_map::path;\n@@ -41,9 +41,13 @@ pub fn trans_deriving_impl(ccx: @crate_ctxt, _path: path, _name: ident,\n                 trans_deriving_struct_method(ccx, llfn, impl_def_id,\n                                              self_ty.ty);\n             }\n+            ty::ty_enum(*) => {\n+                trans_deriving_enum_method(ccx, llfn, impl_def_id,\n+                                           self_ty.ty);\n+            }\n             _ => {\n-                ccx.tcx.sess.unimpl(~\"translation of non-struct deriving \\\n-                                      method\");\n+                ccx.tcx.sess.bug(~\"translation of non-struct deriving \\\n+                                   method\");\n             }\n         }\n     }\n@@ -76,40 +80,12 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt, llfn: ValueRef,\n     // Iterate over every element of the struct.\n     for ccx.tcx.deriving_struct_methods.get(impl_did).eachi\n             |i, derived_method_info| {\n-        let target_method_def_id;\n-        match *derived_method_info {\n-            method_static(did) => target_method_def_id = did,\n-            _ => fail ~\"derived method didn't resolve to a static method\"\n-        }\n-\n-        let fn_expr_ty =\n-            ty::lookup_item_type(ccx.tcx, target_method_def_id).ty;\n-\n         let llselfval = GEPi(bcx, llselfval, [0, 0, i]);\n         let llotherval = GEPi(bcx, llotherval, [0, 0, i]);\n \n-        // XXX: Cross-crate won't work!\n-        let llfn = get_item_val(ccx, target_method_def_id.node);\n-        let cb: &fn(block) -> Callee = |block| {\n-            Callee {\n-                bcx: block,\n-                data: Method(MethodData {\n-                    llfn: llfn,\n-                    llself: llselfval,\n-                    self_ty: struct_field_tys[i].mt.ty,\n-                    self_mode: ast::by_copy\n-                })\n-            }\n-        };\n-\n-        bcx = callee::trans_call_inner(bcx,\n-                                       None,\n-                                       fn_expr_ty,\n-                                       ty::mk_bool(ccx.tcx),\n-                                       cb,\n-                                       ArgVals(~[llotherval]),\n-                                       SaveIn(fcx.llretptr),\n-                                       DontAutorefArg);\n+        let self_ty = struct_field_tys[i].mt.ty;\n+        bcx = call_substructure_method(bcx, derived_method_info, self_ty,\n+                                       llselfval, llotherval);\n \n         // Return immediately if the call returned false.\n         let next_block = sub_block(top_bcx, ~\"next\");\n@@ -124,3 +100,171 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt, llfn: ValueRef,\n     finish_fn(fcx, lltop);\n }\n \n+fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n+                              impl_did: def_id, self_ty: ty::t) {\n+    let _icx = ccx.insn_ctxt(\"trans_deriving_enum_method\");\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n+    let top_bcx = top_scope_block(fcx, None);\n+    let lltop = top_bcx.llbb;\n+    let mut bcx = top_bcx;\n+\n+    let llselfty = type_of(ccx, self_ty);\n+    let llselfval = PointerCast(bcx, fcx.llenv, T_ptr(llselfty));\n+    let llotherval = llvm::LLVMGetParam(llfn, 2);\n+\n+    let enum_id, enum_substs, enum_variant_infos;\n+    match ty::get(self_ty).sty {\n+        ty::ty_enum(found_enum_id, ref found_enum_substs) => {\n+            enum_id = found_enum_id;\n+            enum_substs = copy *found_enum_substs;\n+            enum_variant_infos = ty::substd_enum_variants(\n+                ccx.tcx, enum_id, &enum_substs);\n+        }\n+        _ => {\n+            ccx.tcx.sess.bug(~\"passed non-enum to \\\n+                               trans_deriving_enum_method\");\n+        }\n+    }\n+\n+    // Create the \"no match\" basic block. This is a basic block that does\n+    // nothing more than return false.\n+    let nomatch_bcx = sub_block(top_bcx, ~\"no_match\");\n+    Store(nomatch_bcx, C_bool(false), fcx.llretptr);\n+    Br(nomatch_bcx, fcx.llreturn);\n+\n+    // Create the \"unreachable\" basic block.\n+    let unreachable_bcx = sub_block(top_bcx, ~\"unreachable\");\n+    Unreachable(unreachable_bcx);\n+\n+    // Get the deriving enum method info.\n+    let deriving_enum_methods = ccx.tcx.deriving_enum_methods.get(impl_did);\n+    let n_variants = deriving_enum_methods.len();\n+\n+    if n_variants != 1 {\n+        // Grab the two discriminants.\n+        let llselfdiscrim = Load(bcx, GEPi(bcx, llselfval, [0, 0]));\n+        let llotherdiscrim = Load(bcx, GEPi(bcx, llotherval, [0, 0]));\n+\n+        // Skip over the discriminants and compute the address of the payload.\n+        let llselfpayload = GEPi(bcx, llselfval, [0, 1]);\n+        let llotherpayload = GEPi(bcx, llotherval, [0, 1]);\n+\n+        // Create basic blocks for the outer switch.\n+        let outer_bcxs = vec::from_fn(\n+            deriving_enum_methods.len(),\n+            |i| sub_block(top_bcx, fmt!(\"outer_%u\", i)));\n+\n+        // For each basic block in the outer switch...\n+        for outer_bcxs.eachi |self_variant_index, bcx| {\n+            // Create the matching basic block for the inner switch.\n+            let top_match_bcx = sub_block(top_bcx, fmt!(\"maybe_match_%u\",\n+                                                        self_variant_index));\n+            let mut match_bcx = top_match_bcx;\n+\n+            // Compare each variant.\n+            for deriving_enum_methods[self_variant_index].eachi\n+                    |i, derived_method_info| {\n+                let variant_def_id =\n+                        enum_variant_infos[self_variant_index].id;\n+                let llselfval = GEP_enum(match_bcx, llselfpayload, enum_id,\n+                                         variant_def_id, enum_substs.tps, i);\n+                let llotherval = GEP_enum(match_bcx, llotherpayload,\n+                                          enum_id, variant_def_id,\n+                                          enum_substs.tps, i);\n+\n+                let self_ty = enum_variant_infos[self_variant_index].args[i];\n+                match_bcx = call_substructure_method(match_bcx,\n+                                                     derived_method_info,\n+                                                     self_ty,\n+                                                     llselfval,\n+                                                     llotherval);\n+\n+                // Return immediately if the call to the substructure returned\n+                // false.\n+                let next_bcx = sub_block(\n+                    top_bcx, fmt!(\"next_%u_%u\", self_variant_index, i));\n+                let llcond = Load(match_bcx, fcx.llretptr);\n+                CondBr(match_bcx, llcond, next_bcx.llbb, fcx.llreturn);\n+                match_bcx = next_bcx;\n+            }\n+\n+            // Finish up the matching block.\n+            Store(match_bcx, C_bool(true), fcx.llretptr);\n+            Br(match_bcx, fcx.llreturn);\n+\n+            // Build the inner switch.\n+            let llswitch = Switch(\n+                *bcx, llotherdiscrim, unreachable_bcx.llbb, n_variants);\n+            for uint::range(0, n_variants) |other_variant_index| {\n+                let discriminant =\n+                    enum_variant_infos[other_variant_index].disr_val;\n+                if self_variant_index == other_variant_index {\n+                    // This is the potentially-matching case.\n+                    AddCase(llswitch,\n+                            C_int(ccx, discriminant),\n+                            top_match_bcx.llbb);\n+                } else {\n+                    // This is always a non-matching case.\n+                    AddCase(llswitch,\n+                            C_int(ccx, discriminant),\n+                            nomatch_bcx.llbb);\n+                }\n+            }\n+        }\n+\n+        // Now build the outer switch.\n+        let llswitch = Switch(top_bcx, llselfdiscrim, unreachable_bcx.llbb,\n+                              n_variants);\n+        for outer_bcxs.eachi |self_variant_index, outer_bcx| {\n+            let discriminant =\n+                enum_variant_infos[self_variant_index].disr_val;\n+            AddCase(llswitch, C_int(ccx, discriminant), outer_bcx.llbb);\n+        }\n+    } else {\n+        ccx.tcx.sess.unimpl(~\"degenerate enum deriving\");\n+    }\n+\n+    // Finish up the function.\n+    finish_fn(fcx, lltop);\n+}\n+\n+fn call_substructure_method(bcx: block,\n+                            derived_method_info: &method_origin,\n+                            self_ty: ty::t,\n+                            llselfval: ValueRef,\n+                            llotherval: ValueRef) -> block {\n+    let fcx = bcx.fcx;\n+    let ccx = fcx.ccx;\n+\n+    let target_method_def_id;\n+    match *derived_method_info {\n+        method_static(did) => target_method_def_id = did,\n+        _ => fail ~\"derived method didn't resolve to a static method\"\n+    }\n+\n+    let fn_expr_ty = ty::lookup_item_type(ccx.tcx, target_method_def_id).ty;\n+\n+    // XXX: Cross-crate won't work!\n+    let llfn = get_item_val(ccx, target_method_def_id.node);\n+    let cb: &fn(block) -> Callee = |block| {\n+        Callee {\n+            bcx: block,\n+            data: Method(MethodData {\n+                llfn: llfn,\n+                llself: llselfval,\n+                self_ty: self_ty,\n+                self_mode: ast::by_copy\n+            })\n+        }\n+    };\n+\n+    callee::trans_call_inner(bcx,\n+                             None,\n+                             fn_expr_ty,\n+                             ty::mk_bool(ccx.tcx),\n+                             cb,\n+                             ArgVals(~[llotherval]),\n+                             SaveIn(fcx.llretptr),\n+                             DontAutorefArg)\n+}\n+"}, {"sha": "1a49bcd312c7598766311c90e5111fcc732cac48", "filename": "src/test/run-pass/enum-deriving-simple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3b83c6224498875d7bacf8f3ad553abe0ecc196/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b83c6224498875d7bacf8f3ad553abe0ecc196/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs?ref=a3b83c6224498875d7bacf8f3ad553abe0ecc196", "patch": "@@ -0,0 +1,32 @@\n+trait MyEq {\n+    pure fn eq(other: &self) -> bool;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+enum B {\n+    C(A),\n+    D(A),\n+    E(A)\n+}\n+\n+impl A : MyEq {\n+    pure fn eq(other: &A) -> bool {\n+        unsafe { io::println(\"in eq\"); }\n+        self.x == other.x\n+    }\n+}\n+\n+impl B : MyEq;\n+\n+fn main() {\n+    let c = C(A { x: 15 });\n+    let d = D(A { x: 30 });\n+    let e = C(A { x: 30 });\n+    assert c.eq(&c);\n+    assert !c.eq(&d);\n+    assert !c.eq(&e);\n+}\n+"}]}