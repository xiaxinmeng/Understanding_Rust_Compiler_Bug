{"sha": "88d96b269c77a0de2c143c797aeb61e928f32e03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZDk2YjI2OWM3N2EwZGUyYzE0M2M3OTdhZWI2MWU5MjhmMzJlMDM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-14T15:55:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: support overriding region printing in ty::print::Printer.", "tree": {"sha": "c35c91c16c64af4f037a2e7b85eecb66afcb9028", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35c91c16c64af4f037a2e7b85eecb66afcb9028"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88d96b269c77a0de2c143c797aeb61e928f32e03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88d96b269c77a0de2c143c797aeb61e928f32e03", "html_url": "https://github.com/rust-lang/rust/commit/88d96b269c77a0de2c143c797aeb61e928f32e03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88d96b269c77a0de2c143c797aeb61e928f32e03/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc914aa88a525eb6d78d0331fc59fa2d0a60b3b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc914aa88a525eb6d78d0331fc59fa2d0a60b3b6", "html_url": "https://github.com/rust-lang/rust/commit/fc914aa88a525eb6d78d0331fc59fa2d0a60b3b6"}], "stats": {"total": 336, "additions": 199, "deletions": 137}, "files": [{"sha": "768839bf60fdcaca1fe47bcb17cea2ebece963b7", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=88d96b269c77a0de2c143c797aeb61e928f32e03", "patch": "@@ -457,6 +457,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type Error = NonTrivialPath;\n \n             type Path = Vec<String>;\n+            type Region = !;\n+\n+            fn print_region(\n+                self: PrintCx<'_, '_, '_, Self>,\n+                _region: ty::Region<'_>,\n+            ) -> Result<Self::Region, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n \n             fn path_crate(\n                 self: PrintCx<'_, '_, '_, Self>,"}, {"sha": "cf47840b022ee02aae6a4624dd01608b45584305", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 164, "deletions": 10, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=88d96b269c77a0de2c143c797aeb61e928f32e03", "patch": "@@ -1,6 +1,7 @@\n use crate::hir::def::Namespace;\n use crate::hir::map::DefPathData;\n use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::middle::region;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n@@ -67,7 +68,7 @@ pub struct RegionHighlightMode {\n     /// This is used when you have a signature like `fn foo(x: &u32,\n     /// y: &'a u32)` and we want to give a name to the region of the\n     /// reference `x`.\n-    pub(crate) highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n }\n \n impl RegionHighlightMode {\n@@ -114,7 +115,7 @@ impl RegionHighlightMode {\n     }\n \n     /// Returns `Some(n)` with the number to use for the given region, if any.\n-    pub(crate) fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n         self\n             .highlight_regions\n             .iter()\n@@ -250,6 +251,7 @@ pub trait Printer: Sized {\n     type Error;\n \n     type Path;\n+    type Region;\n \n     fn print_def_path(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -271,6 +273,11 @@ pub trait Printer: Sized {\n         self.default_print_impl_path(impl_def_id, substs, ns, self_ty, trait_ref)\n     }\n \n+    fn print_region(\n+        self: PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error>;\n+\n     fn path_crate(\n         self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n@@ -310,7 +317,7 @@ pub trait Printer: Sized {\n }\n \n /// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = Self> + fmt::Write {\n+pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = Self, Region = Self> + fmt::Write {\n     /// Enter a nested print context, for pretty-printing\n     /// nested components in some larger context.\n     fn nest<'a, 'gcx, 'tcx, E>(\n@@ -329,9 +336,26 @@ pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = Self> + fmt::Write {\n         })\n     }\n \n-    fn region_highlight_mode(&self) -> RegionHighlightMode {\n-        RegionHighlightMode::default()\n+    /// Return `true` if the region should be printed in path generic args\n+    /// even when it's `'_`, such as in e.g. `Foo<'_, '_, '_>`.\n+    fn always_print_region_in_paths(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n     }\n+\n+    // HACK(eddyb) Trying to print a lifetime might not print anything, which\n+    // may need special handling in the caller (of `ty::RegionKind::print`).\n+    // To avoid printing to a temporary string (which isn't even supported),\n+    // the `print_region_outputs_anything` method can instead be used to\n+    // determine this, ahead of time.\n+    //\n+    // NB: this must be kept in sync with the implementation of `print_region`.\n+    fn print_region_outputs_anything(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> bool;\n }\n \n macro_rules! nest {\n@@ -795,10 +819,13 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n \n         let start = if ns == Namespace::ValueNS { \"::<\" } else { \"<\" };\n \n-        // Don't print any regions if they're all erased.\n+        // Don't print `'_` if there's no printed region.\n         let print_regions = params.iter().any(|param| {\n             match substs[param.index as usize].unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                UnpackedKind::Lifetime(r) => {\n+                    self.always_print_region_in_paths(r) ||\n+                    self.print_region_outputs_anything(r)\n+                }\n                 _ => false,\n             }\n         });\n@@ -827,7 +854,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                         continue;\n                     }\n                     start_or_continue(&mut self, start, \", \")?;\n-                    if !region.display_outputs_anything(&self) {\n+                    if !self.print_region_outputs_anything(region) {\n                         // This happens when the value of the region\n                         // parameter is not easily serialized. This may be\n                         // because the user omitted it in the first place,\n@@ -873,6 +900,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n+    type Region = Self;\n \n     fn print_def_path(\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -929,6 +957,80 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self.default_print_def_path(def_id, substs, ns, projections)\n     }\n \n+    fn print_region(\n+        mut self: PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        // Watch out for region highlights.\n+        let highlight = self.printer.region_highlight_mode;\n+        if let Some(n) = highlight.region_highlighted(region) {\n+            write!(self.printer, \"'{}\", n)?;\n+            return Ok(self.printer);\n+        }\n+\n+        if self.config.is_verbose {\n+            return region.print_debug(self);\n+        }\n+\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                if data.name != \"'_\" {\n+                    write!(self.printer, \"{}\", data.name)?;\n+                }\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        write!(self.printer, \"{}\", name)?;\n+                        return Ok(self.printer);\n+                    }\n+                }\n+\n+                if let Some((region, counter)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        write!(self.printer, \"'{}\", counter)?;\n+                    }\n+                }\n+            }\n+            ty::ReScope(scope) if self.config.identify_regions => {\n+                match scope.data {\n+                    region::ScopeData::Node =>\n+                        write!(self.printer, \"'{}s\", scope.item_local_id().as_usize())?,\n+                    region::ScopeData::CallSite =>\n+                        write!(self.printer, \"'{}cs\", scope.item_local_id().as_usize())?,\n+                    region::ScopeData::Arguments =>\n+                        write!(self.printer, \"'{}as\", scope.item_local_id().as_usize())?,\n+                    region::ScopeData::Destruction =>\n+                        write!(self.printer, \"'{}ds\", scope.item_local_id().as_usize())?,\n+                    region::ScopeData::Remainder(first_statement_index) => write!(self.printer,\n+                        \"'{}_{}rs\",\n+                        scope.item_local_id().as_usize(),\n+                        first_statement_index.index()\n+                    )?,\n+                }\n+            }\n+            ty::ReVar(region_vid) if self.config.identify_regions => {\n+                write!(self.printer, \"{:?}\", region_vid)?;\n+            }\n+            ty::ReVar(_) => {}\n+            ty::ReScope(_) |\n+            ty::ReErased => {}\n+            ty::ReStatic => write!(self.printer, \"'static\")?,\n+            ty::ReEmpty => write!(self.printer, \"'<empty>\")?,\n+\n+            // The user should never encounter these in unsubstituted form.\n+            ty::ReClosureBound(vid) => write!(self.printer, \"{:?}\", vid)?,\n+        }\n+\n+        Ok(self.printer)\n+    }\n+\n     fn path_crate(\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n@@ -1018,7 +1120,59 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         })\n     }\n \n-    fn region_highlight_mode(&self) -> RegionHighlightMode {\n-        self.region_highlight_mode\n+    fn always_print_region_in_paths(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        *region != ty::ReErased\n+    }\n+\n+    fn print_region_outputs_anything(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        let highlight = self.printer.region_highlight_mode;\n+        if highlight.region_highlighted(region).is_some() {\n+            return true;\n+        }\n+\n+        if self.config.is_verbose {\n+            return true;\n+        }\n+\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                data.name != \"\" && data.name != \"'_\"\n+            }\n+\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some((region, _)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            ty::ReScope(_) |\n+            ty::ReVar(_) if self.config.identify_regions => true,\n+\n+            ty::ReVar(_) |\n+            ty::ReScope(_) |\n+            ty::ReErased => false,\n+\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReClosureBound(_) => true,\n+        }\n     }\n }"}, {"sha": "e14741f55ef194a32213e1bbb5400343be3b1290", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 126, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=88d96b269c77a0de2c143c797aeb61e928f32e03", "patch": "@@ -1,6 +1,5 @@\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n-use crate::middle::region;\n use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n use crate::ty::{Bool, Char, Adt};\n use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n@@ -487,72 +486,7 @@ impl fmt::Debug for ty::BoundRegion {\n define_print! {\n     () ty::RegionKind, (self, cx) {\n         display {\n-            // Watch out for region highlights.\n-            let highlight = cx.printer.region_highlight_mode();\n-            if let Some(n) = highlight.region_highlighted(self) {\n-                p!(write(\"'{}\", n));\n-                return Ok(cx.printer);\n-            }\n-\n-            if cx.config.is_verbose {\n-                return self.print_debug(cx);\n-            }\n-\n-            // These printouts are concise.  They do not contain all the information\n-            // the user might want to diagnose an error, but there is basically no way\n-            // to fit that into a short string.  Hence the recommendation to use\n-            // `explain_region()` or `note_and_explain_region()`.\n-            match *self {\n-                ty::ReEarlyBound(ref data) => {\n-                    if data.name != \"'_\" {\n-                        p!(write(\"{}\", data.name))\n-                    }\n-                }\n-                ty::ReLateBound(_, br) |\n-                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-                ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                    if let ty::BrNamed(_, name) = br {\n-                        if name != \"\" && name != \"'_\" {\n-                            p!(write(\"{}\", name));\n-                            return Ok(cx.printer);\n-                        }\n-                    }\n-\n-                    if let Some((region, counter)) = highlight.highlight_bound_region {\n-                        if br == region {\n-                            p!(write(\"'{}\", counter));\n-                        }\n-                    }\n-                }\n-                ty::ReScope(scope) if cx.config.identify_regions => {\n-                    match scope.data {\n-                        region::ScopeData::Node =>\n-                            p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n-                        region::ScopeData::CallSite =>\n-                            p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n-                        region::ScopeData::Arguments =>\n-                            p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n-                        region::ScopeData::Destruction =>\n-                            p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n-                        region::ScopeData::Remainder(first_statement_index) => p!(write(\n-                            \"'{}_{}rs\",\n-                            scope.item_local_id().as_usize(),\n-                            first_statement_index.index()\n-                        )),\n-                    }\n-                }\n-                ty::ReVar(region_vid) if cx.config.identify_regions => {\n-                    p!(write(\"{:?}\", region_vid));\n-                }\n-                ty::ReVar(_) => {}\n-                ty::ReScope(_) |\n-                ty::ReErased => {}\n-                ty::ReStatic => p!(write(\"'static\")),\n-                ty::ReEmpty => p!(write(\"'<empty>\")),\n-\n-                // The user should never encounter these in unsubstituted form.\n-                ty::ReClosureBound(vid) => p!(write(\"{:?}\", vid)),\n-            }\n+            return cx.print_region(self);\n         }\n         debug {\n             match *self {\n@@ -594,63 +528,6 @@ define_print! {\n     }\n }\n \n-// HACK(eddyb) Trying to print a lifetime might not print anything, which\n-// may need special handling in the caller (of `ty::RegionKind::print`).\n-// To avoid printing to a temporary string, the `display_outputs_anything`\n-// method can instead be used to determine this, ahead of time.\n-//\n-// NB: this must be kept in sync with the printing logic above.\n-impl ty::RegionKind {\n-    // HACK(eddyb) `pub(crate)` only for `ty::print`.\n-    pub(crate) fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool\n-        where P: PrettyPrinter\n-    {\n-        let highlight = cx.printer.region_highlight_mode();\n-        if highlight.region_highlighted(self).is_some() {\n-            return true;\n-        }\n-\n-        if cx.config.is_verbose {\n-            return true;\n-        }\n-\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                data.name != \"\" && data.name != \"'_\"\n-            }\n-\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n-                        return true;\n-                    }\n-                }\n-\n-                if let Some((region, _)) = highlight.highlight_bound_region {\n-                    if br == region {\n-                        return true;\n-                    }\n-                }\n-\n-                false\n-            }\n-\n-            ty::ReScope(_) |\n-            ty::ReVar(_) if cx.config.identify_regions => true,\n-\n-            ty::ReVar(_) |\n-            ty::ReScope(_) |\n-            ty::ReErased => false,\n-\n-            ty::ReStatic |\n-            ty::ReEmpty |\n-            ty::ReClosureBound(_) => true,\n-        }\n-    }\n-}\n-\n define_print! {\n     () ty::FreeRegion, (self, cx) {\n         debug {\n@@ -830,7 +707,7 @@ define_print! {\n                 }\n                 Ref(r, ty, mutbl) => {\n                     p!(write(\"&\"));\n-                    if r.display_outputs_anything(&cx) {\n+                    if cx.print_region_outputs_anything(r) {\n                         p!(print_display(r), write(\" \"));\n                     }\n                     p!(print(ty::TypeAndMut { ty, mutbl }))\n@@ -889,7 +766,7 @@ define_print! {\n                     ));\n                 }\n                 Dynamic(data, r) => {\n-                    let print_r = r.display_outputs_anything(&cx);\n+                    let print_r = cx.print_region_outputs_anything(r);\n                     if print_r {\n                         p!(write(\"(\"));\n                     }"}, {"sha": "912f8149513c620b1fe747905249243aec6e2d7a", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=88d96b269c77a0de2c143c797aeb61e928f32e03", "patch": "@@ -409,6 +409,14 @@ impl Printer for SymbolPath {\n     type Error = fmt::Error;\n \n     type Path = Self;\n+    type Region = Self;\n+\n+    fn print_region(\n+        self: PrintCx<'_, '_, '_, Self>,\n+        _region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        Ok(self.printer)\n+    }\n \n     fn path_crate(\n         mut self: PrintCx<'_, '_, '_, Self>,\n@@ -511,7 +519,14 @@ impl Printer for SymbolPath {\n     }\n }\n \n-impl PrettyPrinter for SymbolPath {}\n+impl PrettyPrinter for SymbolPath {\n+    fn print_region_outputs_anything(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n+    }\n+}\n \n impl fmt::Write for SymbolPath {\n     fn write_str(&mut self, s: &str) -> fmt::Result {"}, {"sha": "bceae24b1b44fc184eddd5b424763ca99fea0112", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d96b269c77a0de2c143c797aeb61e928f32e03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=88d96b269c77a0de2c143c797aeb61e928f32e03", "patch": "@@ -4233,6 +4233,14 @@ where F: Fn(DefId) -> Def {\n         type Error = !;\n \n         type Path = Vec<String>;\n+        type Region = ();\n+\n+        fn print_region(\n+            self: PrintCx<'_, '_, '_, Self>,\n+            _region: ty::Region<'_>,\n+        ) -> Result<Self::Region, Self::Error> {\n+            Ok(())\n+        }\n \n         fn path_crate(\n             self: PrintCx<'_, '_, '_, Self>,"}]}