{"sha": "91ddf3e76a17e7c890de182ae20571fde62ee753", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZGRmM2U3NmExN2U3Yzg5MGRlMTgyYWUyMDU3MWZkZTYyZWU3NTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-31T10:13:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-31T10:13:46Z"}, "message": "Auto merge of #85266 - cjgillot:hir-dep-clean, r=michaelwoerister\n\nRemove obsolete workaround.\n\nThe regression test for #62649 appears to pass even without the workaround.", "tree": {"sha": "2ed5dad3a984469080eec235cf702163183db7f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ed5dad3a984469080eec235cf702163183db7f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91ddf3e76a17e7c890de182ae20571fde62ee753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91ddf3e76a17e7c890de182ae20571fde62ee753", "html_url": "https://github.com/rust-lang/rust/commit/91ddf3e76a17e7c890de182ae20571fde62ee753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91ddf3e76a17e7c890de182ae20571fde62ee753/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7baa7afd0fc8061c5b815a7aab9b40d1cd406ce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7baa7afd0fc8061c5b815a7aab9b40d1cd406ce8", "html_url": "https://github.com/rust-lang/rust/commit/7baa7afd0fc8061c5b815a7aab9b40d1cd406ce8"}, {"sha": "4f8e34cbf86e10e8bde7469bdfd539da57ae1de4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8e34cbf86e10e8bde7469bdfd539da57ae1de4", "html_url": "https://github.com/rust-lang/rust/commit/4f8e34cbf86e10e8bde7469bdfd539da57ae1de4"}], "stats": {"total": 120, "additions": 47, "deletions": 73}, "files": [{"sha": "8ffd98326f1c86ce022a72a9747820a1442b22f8", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=91ddf3e76a17e7c890de182ae20571fde62ee753", "patch": "@@ -1,6 +1,6 @@\n use crate::arena::Arena;\n-use crate::hir::map::{HirOwnerData, Map};\n-use crate::hir::{IndexedHir, Owner, OwnerNodes, ParentedNode};\n+use crate::hir::map::Map;\n+use crate::hir::{IndexedHir, OwnerNodes, ParentedNode};\n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -28,7 +28,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// Source map\n     source_map: &'a SourceMap,\n \n-    map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n+    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n     parenting: FxHashMap<LocalDefId, HirId>,\n \n     /// The parent of this node\n@@ -107,9 +107,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             current_dep_node_owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n             definitions,\n             hcx,\n-            map: (0..definitions.def_index_count())\n-                .map(|_| HirOwnerData { signature: None, with_bodies: None })\n-                .collect(),\n+            map: IndexVec::from_fn_n(|_| None, definitions.def_index_count()),\n             parenting: FxHashMap::default(),\n         };\n         collector.insert_entry(\n@@ -124,7 +122,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(mut self) -> IndexedHir<'hir> {\n         // Insert bodies into the map\n         for (id, body) in self.krate.bodies.iter() {\n-            let bodies = &mut self.map[id.hir_id.owner].with_bodies.as_mut().unwrap().bodies;\n+            let bodies = &mut self.map[id.hir_id.owner].as_mut().unwrap().bodies;\n             assert!(bodies.insert(id.hir_id.local_id, body).is_none());\n         }\n         IndexedHir { map: self.map, parenting: self.parenting }\n@@ -137,22 +135,13 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let data = &mut self.map[id.owner];\n \n-        if data.with_bodies.is_none() {\n-            data.with_bodies = Some(arena.alloc(OwnerNodes {\n+        if i == 0 {\n+            debug_assert!(data.is_none());\n+            *data = Some(arena.alloc(OwnerNodes {\n                 hash,\n                 nodes: IndexVec::new(),\n                 bodies: FxHashMap::default(),\n             }));\n-        }\n-\n-        let nodes = data.with_bodies.as_mut().unwrap();\n-\n-        if i == 0 {\n-            // Overwrite the dummy hash with the real HIR owner hash.\n-            nodes.hash = hash;\n-\n-            debug_assert!(data.signature.is_none());\n-            data.signature = Some(self.arena.alloc(Owner { node: entry.node }));\n \n             let dk_parent = self.definitions.def_key(id.owner).parent;\n             if let Some(dk_parent) = dk_parent {\n@@ -168,13 +157,16 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 debug_assert_eq!(self.parenting.get(&id.owner), Some(&entry.parent));\n             }\n         } else {\n-            assert_eq!(entry.parent.owner, id.owner);\n-            insert_vec_map(\n-                &mut nodes.nodes,\n-                id.local_id,\n-                ParentedNode { parent: entry.parent.local_id, node: entry.node },\n-            );\n+            debug_assert_eq!(entry.parent.owner, id.owner);\n         }\n+\n+        let data = data.as_mut().unwrap();\n+\n+        insert_vec_map(\n+            &mut data.nodes,\n+            id.local_id,\n+            ParentedNode { parent: entry.parent.local_id, node: entry.node },\n+        );\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {"}, {"sha": "07b39c97c492a23d88928177f3884accbd0ed318", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=91ddf3e76a17e7c890de182ae20571fde62ee753", "patch": "@@ -1,6 +1,6 @@\n use self::collector::NodeCollector;\n \n-use crate::hir::{AttributeMap, HirOwnerData, IndexedHir};\n+use crate::hir::{AttributeMap, IndexedHir};\n use crate::middle::cstore::CrateStore;\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n@@ -953,7 +953,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n         .filter_map(|(def_id, hod)| {\n             let def_path_hash = tcx.definitions.def_path_hash(def_id);\n             let mut hasher = StableHasher::new();\n-            hod.with_bodies.as_ref()?.hash_stable(&mut hcx, &mut hasher);\n+            hod.as_ref()?.hash_stable(&mut hcx, &mut hasher);\n             AttributeMap { map: &tcx.untracked_crate.attrs, prefix: def_id }\n                 .hash_stable(&mut hcx, &mut hasher);\n             Some((def_path_hash, hasher.finish()))"}, {"sha": "b8407833c903b23d8fcd15e59679cb7ce3befd52", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=91ddf3e76a17e7c890de182ae20571fde62ee753", "patch": "@@ -15,23 +15,25 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::*;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::DUMMY_SP;\n use std::collections::BTreeMap;\n \n-#[derive(Debug)]\n-struct HirOwnerData<'hir> {\n-    signature: Option<&'hir Owner<'hir>>,\n-    with_bodies: Option<&'hir mut OwnerNodes<'hir>>,\n-}\n-\n+/// Result of HIR indexing.\n #[derive(Debug)]\n pub struct IndexedHir<'hir> {\n-    map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n+    /// Contents of the HIR owned by each definition. None for definitions that are not HIR owners.\n+    // The `mut` comes from construction time, and is harmless since we only ever hand out\n+    // immutable refs to IndexedHir.\n+    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n+    /// Map from each owner to its parent's HirId inside another owner.\n+    // This map is separate from `map` to eventually allow for per-owner indexing.\n     parenting: FxHashMap<LocalDefId, HirId>,\n }\n \n-#[derive(Debug)]\n+/// Top-level HIR node for current owner. This only contains the node for which\n+/// `HirId::local_id == 0`, and excludes bodies.\n+#[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n     node: Node<'tcx>,\n }\n@@ -43,6 +45,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     }\n }\n \n+/// HIR node coupled with its parent's id in the same HIR owner.\n+///\n+/// The parent is trash when the node is a HIR owner.\n #[derive(Clone, Debug)]\n pub struct ParentedNode<'tcx> {\n     parent: ItemLocalId,\n@@ -51,8 +56,12 @@ pub struct ParentedNode<'tcx> {\n \n #[derive(Debug)]\n pub struct OwnerNodes<'tcx> {\n+    /// Pre-computed hash of the full HIR.\n     hash: Fingerprint,\n+    /// Full HIR for the current owner.\n+    // The zeroth node's parent is trash, but is never accessed.\n     nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n+    /// Content of local bodies.\n     bodies: FxHashMap<ItemLocalId, &'tcx Body<'tcx>>,\n }\n \n@@ -65,6 +74,8 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n     }\n }\n \n+/// Attributes owner by a HIR owner. It is build as a slice inside the attributes map, restricted\n+/// to the nodes whose `HirId::owner` is `prefix`.\n #[derive(Copy, Clone)]\n pub struct AttributeMap<'tcx> {\n     map: &'tcx BTreeMap<HirId, &'tcx [Attribute]>,\n@@ -127,8 +138,12 @@ pub fn provide(providers: &mut Providers) {\n     providers.index_hir = map::index_hir;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n-    providers.hir_owner = |tcx, id| tcx.index_hir(()).map[id].signature;\n-    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].with_bodies.as_deref();\n+    providers.hir_owner = |tcx, id| {\n+        let owner = tcx.index_hir(()).map[id].as_ref()?;\n+        let node = owner.nodes[ItemLocalId::new(0)].as_ref()?.node;\n+        Some(Owner { node })\n+    };\n+    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].as_deref();\n     providers.hir_owner_parent = |tcx, id| {\n         let index = tcx.index_hir(());\n         index.parenting.get(&id).copied().unwrap_or(CRATE_HIR_ID)"}, {"sha": "9974f2bb8cac312366b3ce174e49169feffdb823", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=91ddf3e76a17e7c890de182ae20571fde62ee753", "patch": "@@ -47,7 +47,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner(key: LocalDefId) -> Option<&'tcx crate::hir::Owner<'tcx>> {\n+    query hir_owner(key: LocalDefId) -> Option<crate::hir::Owner<'tcx>> {\n         eval_always\n         desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }"}, {"sha": "b4191c135b4f9b425a3052b92a7b1fac7c5d8637", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ddf3e76a17e7c890de182ae20571fde62ee753/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=91ddf3e76a17e7c890de182ae20571fde62ee753", "patch": "@@ -3,7 +3,7 @@\n //! manage the caches, and so forth.\n \n use super::queries;\n-use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::ty::query::on_disk_cache;\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -57,39 +57,6 @@ impl QueryContext for QueryCtxt<'tcx> {\n     }\n \n     fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n-        // FIXME: This match is just a workaround for incremental bugs and should\n-        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-        // bug that must be fixed before removing this.\n-        match dep_node.kind {\n-            DepKind::hir_owner | DepKind::hir_owner_nodes => {\n-                if let Some(def_id) = dep_node.extract_def_id(**self) {\n-                    let def_id = def_id.expect_local();\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if def_id != hir_id.owner {\n-                        // This `DefPath` does not have a\n-                        // corresponding `DepNode` (e.g. a\n-                        // struct field), and the ` DefPath`\n-                        // collided with the `DefPath` of a\n-                        // proper item that existed in the\n-                        // previous compilation session.\n-                        //\n-                        // Since the given `DefPath` does not\n-                        // denote the item that previously\n-                        // existed, we just fail to mark green.\n-                        return false;\n-                    }\n-                } else {\n-                    // If the node does not exist anymore, we\n-                    // just fail to mark green.\n-                    return false;\n-                }\n-            }\n-            _ => {\n-                // For other kinds of nodes it's OK to be\n-                // forced.\n-            }\n-        }\n-\n         debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n \n         // We must avoid ever having to call `force_from_dep_node()` for a"}]}