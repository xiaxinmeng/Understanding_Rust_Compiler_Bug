{"sha": "fcec62820376bd7652e254113e44ae46ac6d22f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZWM2MjgyMDM3NmJkNzY1MmUyNTQxMTNlNDRhZTQ2YWM2ZDIyZjQ=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-04T23:07:26Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-04T23:40:17Z"}, "message": "Enable creation of backwarding vtables (issue #702), but don't start\nusing them yet.  Also, refactor process_fwding_mthd into separate\nfunctions to handle backwarding and forwarding, and refactor\ncreate_vtbl to be more digestible.", "tree": {"sha": "3578dfbca95030e2576065ddd4b90cd288ef164b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3578dfbca95030e2576065ddd4b90cd288ef164b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcec62820376bd7652e254113e44ae46ac6d22f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcec62820376bd7652e254113e44ae46ac6d22f4", "html_url": "https://github.com/rust-lang/rust/commit/fcec62820376bd7652e254113e44ae46ac6d22f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcec62820376bd7652e254113e44ae46ac6d22f4/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d180793f04ece462d2053c1a04ea2b0d73b4ee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d180793f04ece462d2053c1a04ea2b0d73b4ee2", "html_url": "https://github.com/rust-lang/rust/commit/4d180793f04ece462d2053c1a04ea2b0d73b4ee2"}], "stats": {"total": 392, "additions": 232, "deletions": 160}, "files": [{"sha": "8249dde311196402e2fcbbb52505080d4e52e2cc", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 232, "deletions": 160, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/fcec62820376bd7652e254113e44ae46ac6d22f4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcec62820376bd7652e254113e44ae46ac6d22f4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fcec62820376bd7652e254113e44ae46ac6d22f4", "patch": "@@ -5649,7 +5649,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     // Create a vtable for the anonymous object.\n \n     // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n-    // so we need to roll our own.\n+    // so we need to roll our own.  NB: wrapper_obj includes only outer\n+    // methods, not inner ones.\n     let wrapper_obj: ast::_obj =\n         {fields:\n              std::ivec::map(ast::obj_field_from_anon_obj_field,\n@@ -6451,59 +6452,149 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n     log_fn_time(cx.ccx, str::connect_ivec(cx.path, \"::\"), start, end);\n }\n \n+// process_bkwding_mthd: Create the backwarding function that appears in a\n+// backwarding vtable slot.\n+//\n+// Backwarding functions are used in situations where method calls dispatch\n+// back through an outer object.  For example, suppose an inner object has\n+// methods foo and bar, and bar contains the call self.foo().  We extend that\n+// object with a foo method that overrides the inner foo.  Now, a call to\n+// outer.bar() should send us to to inner.bar() via a normal forwarding\n+// function, and then to self.foo().  But inner.bar() was already compiled\n+// under the assumption that self.foo() is inner.foo(), when we really want to\n+// reach outer.foo().  So, we give 'self' a vtable of backwarding functions,\n+// one for each method on inner, each of which takes all the same arguments as\n+// the corresponding method on inner does, calls that method on outer, and\n+// returns the value returned from that call.\n+fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n+                       ty_params: &ast::ty_param[], outer_obj_ty: ty::t,\n+                       additional_field_tys: &ty::t[]) -> ValueRef {\n+\n+    // Create a local context that's aware of the name of the method we're\n+    // creating.\n+    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n+\n+    // Make up a name for the backwarding function.\n+    let fn_name: str = \"backwarding_fn\";\n+    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n+                                                      fn_name);\n+\n+    // Get the backwarding function's type and declare it.\n+    let llbackwarding_fn_ty: TypeRef =\n+        type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n+                        std::ivec::len[ast::ty_param](ty_params));\n+    let llbackwarding_fn: ValueRef =\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n+\n+    // Create a new function context and block context for the backwarding\n+    // function, holding onto a pointer to the first block.\n+    let fcx = new_fn_ctxt(cx, sp, llbackwarding_fn);\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+\n+    // The self-object will arrive in the backwarding function via the llenv\n+    // argument.\n+    let llself_obj_ptr = fcx.llenv;\n+\n+    // The 'llretptr' that will arrive in the backwarding function we're\n+    // creating also needs to be the correct type.  Cast it to the method's\n+    // return type, if necessary.\n+    let llretptr = fcx.llretptr;\n+    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n+        let llretty = type_of_inner(cx.ccx, sp, m.output);\n+        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n+    }\n+\n+    // Now we need the outer object's vtable.  Increment llself_obj_ptr to get\n+    // at it.\n+    let llouter_obj_vtbl =\n+        bcx.build.GEP(llself_obj_ptr,\n+                      ~[C_int(0), C_int(1)]);\n+    llouter_obj_vtbl = bcx.build.Load(llouter_obj_vtbl);\n+\n+    // Get the index of the method we want.\n+    let ix: uint = 0u;\n+    alt ty::struct(bcx_tcx(bcx), outer_obj_ty) {\n+      ty::ty_obj(methods) {\n+        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n+      }\n+      _ {\n+        // Shouldn't happen.\n+        cx.ccx.sess.bug(\"process_bkwding_mthd(): non-object type passed \\\n+                        as outer_obj_ty\");\n+      }\n+    }\n+\n+    // Pick out the method being backwarded to from the vtable.\n+    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n+    llouter_obj_vtbl = bcx.build.PointerCast(llouter_obj_vtbl, vtbl_type);\n+\n+    let llouter_mthd =\n+        bcx.build.GEP(llouter_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n+\n+    // Set up the outer method to be called.\n+    let outer_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n+    let llouter_mthd_ty =\n+        type_of_fn_full(bcx_ccx(bcx), sp,\n+                        ty::ty_fn_proto(bcx_tcx(bcx), outer_mthd_ty), true,\n+                        m.inputs, m.output,\n+                        std::ivec::len[ast::ty_param](ty_params));\n+    llouter_mthd =\n+        bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n+    llouter_mthd = bcx.build.Load(llouter_mthd);\n+\n+    // Set up the three implicit arguments to the outer method we'll need\n+    // to call.\n+    let self_arg = llself_obj_ptr;\n+    let llouter_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_arg];\n+\n+    // Copy the explicit arguments that are being passed into the forwarding\n+    // function (they're in fcx.llargs) to llouter_mthd_args.\n+\n+    let a: uint = 3u; // retptr, task ptr, env come first\n+    let passed_arg: ValueRef = llvm::LLVMGetParam(llbackwarding_fn, a);\n+    for arg: ty::arg  in m.inputs {\n+        if arg.mode == ty::mo_val {\n+            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n+        }\n+        llouter_mthd_args += ~[passed_arg];\n+        a += 1u;\n+    }\n+\n+    // And, finally, call the outer method.\n+    bcx.build.FastCall(llouter_mthd, llouter_mthd_args);\n+\n+    bcx.build.RetVoid();\n+    finish_fn(fcx, lltop);\n+\n+    ret llbackwarding_fn;\n+\n+}\n+\n // process_fwding_mthd: Create the forwarding function that appears in a\n // vtable slot for method calls that need to forward to another object.  A\n // helper function for create_vtbl.\n //\n-// We use forwarding functions in two situations:\n-//\n-//  (1) Forwarding: For method calls that fall through to an inner object, For\n-//      example, suppose an inner object has method foo and we extend it with\n-//      a method bar.  The only version of 'foo' we have is on the inner\n-//      object, but we would like to be able to call outer.foo().  So we use a\n-//      forwarding function to make the foo method available on the outer\n-//      object.  It takes all the same arguments as the foo method on the\n-//      inner object does, calls inner.foo() with those arguments, and then\n-//      returns the value returned from that call.  (The inner object won't\n-//      exist until run-time, but we know its type statically.)\n-//\n-//  (2) Backwarding: For method calls that dispatch back through an outer\n-//      object.  For example, suppose an inner object has methods foo and bar,\n-//      and bar contains the call self.foo().  We extend that object with a\n-//      foo method that overrides the inner foo.  Now, a call to outer.bar()\n-//      should send us to to inner.bar() via a normal forwarding function, and\n-//      then to self.foo().  But inner.bar() was already compiled under the\n-//      assumption that self.foo() is inner.foo(), when we really want to\n-//      reach outer.foo().  So, we give 'self' a vtable of backwarding\n-//      functions, one for each method on inner, each of which takes all the\n-//      same arguments as the corresponding method on inner does, calls that\n-//      method on outer, and returns the value returned from that call.\n-\n+// Forwarding functions are used for method calls that fall through to an\n+// inner object.  For example, suppose an inner object has method foo and we\n+// extend it with a method bar.  The only version of 'foo' we have is on the\n+// inner object, but we would like to be able to call outer.foo().  So we use\n+// a forwarding function to make the foo method available on the outer object.\n+// It takes all the same arguments as the foo method on the inner object does,\n+// calls inner.foo() with those arguments, and then returns the value returned\n+// from that call.  (The inner object won't exist until run-time, but we know\n+// its type statically.)\n fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &ast::ty_param[], target_obj_ty: ty::t,\n-                       backwarding_vtbl: option::t[ValueRef],\n+                       ty_params: &ast::ty_param[], inner_obj_ty: ty::t,\n+                       backwarding_vtbl: ValueRef,\n                        additional_field_tys: &ty::t[]) -> ValueRef {\n \n-    // NB: target_obj_ty is the type of the object being forwarded to.\n-    // Depending on whether this is a forwarding or backwarding function, it\n-    // will be either the inner obj's type or the outer obj's type,\n-    // respectively.\n-\n     // Create a local context that's aware of the name of the method we're\n     // creating.\n     let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n \n     // Make up a name for the forwarding function.\n-    let fn_name: str = \"\";\n-    alt (backwarding_vtbl) {\n-      // NB: If we have a backwarding_vtbl, that *doesn't* mean that we're\n-      // currently processing a backwarding fn.  It's the opposite: it means\n-      // that we have already processed them, and now we're creating\n-      // forwarding fns that *use* a vtable full of them.\n-      none. { fn_name = \"backwarding_fn\"; }\n-      some(_) { fn_name = \"forwarding_fn\"; }\n-    }\n-\n+    let fn_name: str = \"forwarding_fn\";\n     let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n                                                       fn_name);\n \n@@ -6524,28 +6615,19 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // argument.\n     let llself_obj_ptr = fcx.llenv;\n \n-    // Do backwarding if necessary.\n-    alt (backwarding_vtbl) {\n-      none. {\n-        // NB: As before, this means that we are processing a backwarding fn\n-        // right now.\n-      }\n-      some(bv) {\n-        // NB: As before, this means that we are processing a forwarding fn\n-        // right now.\n+    // Grab the vtable out of the self-object and replace it with the\n+    // backwarding vtable.  FIXME (issue #702): Not quite ready to turn this\n+    // behavior on yet.\n \n-        // Grab the vtable out of the self-object and replace it with the\n-        // backwarding vtable.\n-        let llself_obj_vtbl =\n-            bcx.build.GEP(llself_obj_ptr, ~[C_int(0),\n-                                            C_int(abi::obj_field_vtbl)]);\n-        let llbv = bcx.build.PointerCast(bv, T_ptr(T_empty_struct()));\n-        bcx.build.Store(llbv, llself_obj_vtbl);\n+    // let llself_obj_vtbl =\n+    //     bcx.build.GEP(llself_obj_ptr, ~[C_int(0),\n+    //                                     C_int(abi::obj_field_vtbl)]);\n+    // let llbv = bcx.build.PointerCast(backwarding_vtbl,\n+    //                                  T_ptr(T_empty_struct()));\n+    // bcx.build.Store(llbv, llself_obj_vtbl);\n \n-        // NB: llself_obj is now a freakish combination of outer object body\n-        // and backwarding (inner-object) vtable.\n-      }\n-    }\n+    // NB: llself_obj is now a freakish combination of outer object body\n+    // and backwarding (inner-object) vtable.\n \n     // The 'llretptr' that will arrive in the forwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n@@ -6592,14 +6674,6 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Tuple type for body:\n     // [tydesc, [typaram, ...], [field, ...], inner_obj]\n \n-    // NB: When we're creating a forwarding fn, target_obj_ty is indeed the\n-    // type of the inner object, so it makes sense to have 'target_obj_ty'\n-    // appear here.  When we're creating a backwarding fn, though,\n-    // target_obj_ty is the outer object's type, so instead, we need to use\n-    // the extra inner type we passed along.\n-\n-    let inner_obj_ty = target_obj_ty;\n-\n     let body_ty: ty::t =\n         ty::mk_imm_tup(cx.ccx.tcx,\n                        ~[tydesc_ty, typarams_ty, fields_ty, inner_obj_ty]);\n@@ -6626,7 +6700,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Get the index of the method we want.\n     let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), target_obj_ty) {\n+    alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n       ty::ty_obj(methods) {\n         ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n       }\n@@ -6720,6 +6794,54 @@ tag vtbl_mthd {\n     fwding_mthd(@ty::method);\n }\n \n+// Alphabetize ast::methods by ident.  A helper for create_vtbl.\n+fn ast_mthd_lteq(a: &@ast::method, b: &@ast::method) -> bool {\n+    ret str::lteq(a.node.ident, b.node.ident);\n+}\n+\n+// Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n+fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n+    alt a {\n+      normal_mthd(ma) {\n+        alt b {\n+          normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n+        }\n+      }\n+      fwding_mthd(ma) {\n+        alt b {\n+          normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n+        }\n+      }\n+    }\n+}\n+\n+// Used by create_vtbl to filter a list of methods to remove the ones that we\n+// don't need forwarding slots for.\n+fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n+                addtl_meths: (@ast::method)[]) ->\n+    option::t[vtbl_mthd] {\n+\n+    // Since m is a fwding_mthd, and we're checking to see if it's in\n+    // addtl_meths (which only contains normal_mthds), we can't just check if\n+    // it's a member of addtl_meths.  Instead, we have to go through\n+    // addtl_meths and see if there's some method in it that has the same name\n+    // as m.\n+    alt m {\n+      fwding_mthd(fm) {\n+        for am: @ast::method in addtl_meths {\n+            if str::eq(am.node.ident, fm.ident) { ret none; }\n+        }\n+        ret some(fwding_mthd(fm));\n+      }\n+      normal_mthd(_) {\n+        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n+                        normal_mthds in meths here\");\n+      }\n+    }\n+}\n+\n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n@@ -6728,32 +6850,36 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n                additional_field_tys: &ty::t[]) -> ValueRef {\n \n     let llmethods: ValueRef[] = ~[];\n-    let meths: vtbl_mthd[] = ~[];\n-    let backwarding_vtbl: option::t[ValueRef] = none;\n \n     alt inner_obj_ty {\n       none. {\n+        // Sort and process all the methods.\n+        let meths =\n+            std::sort::ivector::merge_sort[@ast::method]\n+            (bind ast_mthd_lteq(_, _), ob.methods);\n \n-        // If there's no inner_obj, then we don't need any forwarding\n-        // slots.  Just use the object's regular methods.\n-        for m: @ast::method  in ob.methods { meths += ~[normal_mthd(m)]; }\n+        for m: @ast::method in meths {\n+            llmethods += ~[process_normal_mthd(cx, m, outer_obj_ty,\n+                                               ty_params)];\n+        }\n       }\n       some(inner_obj_ty) {\n-        // Handle forwarding slots.\n-\n         // If this vtable is being created for an extended object, then the\n         // vtable needs to contain 'forwarding slots' for methods that were on\n-        // the original object and are not being overloaded by the extended\n+        // the original object and are not being overridden by the extended\n         // one.  So, to find the set of methods that we need forwarding slots\n         // for, we need to take the set difference of inner_obj_methods\n-        // (methods on the original object) and ob.methods (methods on the\n-        // object being added).\n+        // (methods on the original object) and ob.methods (methods being\n+        // added, whether entirely new or overriding).\n \n-        // If we're here, then inner_obj_ty and llinner_obj_ty are the type of\n-        // the inner object, and \"ob\" is the wrapper object.  We need to take\n-        // apart inner_obj_ty (it had better have an object type with\n-        // methods!) and put those original methods onto the list of methods\n-        // we need forwarding methods for.\n+        // inner_obj_ty is the type of the inner object being forwarded to,\n+        // and \"ob\" is the wrapper object.  We need to take apart\n+        // inner_obj_ty, which is the type of the object being forwarded to\n+        // (it had better have an object type with methods!) and put those\n+        // original methods onto the list of methods we need forwarding\n+        // methods for.\n+\n+        let meths: vtbl_mthd[] = ~[];\n \n         // Gather up methods on the original object in 'meths'.\n         alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n@@ -6763,97 +6889,43 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n             }\n           }\n           _ {\n-            // Shouldn't happen.\n             cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n                             non-object\");\n           }\n         }\n \n         // Now, filter out any methods that we don't need forwarding slots\n-        // for, because they're being replaced.\n-        fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n-                        addtl_meths: (@ast::method)[]) ->\n-           option::t[vtbl_mthd] {\n-\n-            alt m {\n-              fwding_mthd(fm) {\n-                // Since fm is a fwding_mthd, and we're checking to see if\n-                // it's in addtl_meths (which only contains normal_mthds), we\n-                // can't just check if fm is a member of addtl_meths.\n-                // Instead, we have to go through addtl_meths and see if\n-                // there's some method in it that has the same name as fm.\n-                for am: @ast::method  in addtl_meths {\n-                    if str::eq(am.node.ident, fm.ident) { ret none; }\n-                }\n-                ret some(fwding_mthd(fm));\n-              }\n-              normal_mthd(_) {\n-                // Should never happen.\n-                cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n-                                normal_mthds in meths here\");\n-              }\n-            }\n-        }\n+        // for, because they're being overridden.\n         let f = bind filtering_fn(cx, _, ob.methods);\n         meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n \n+        // And now add the additional ones, both overriding ones and entirely\n+        // new ones.  These will just be normal methods.\n+        for m: @ast::method in ob.methods { meths += ~[normal_mthd(m)]; }\n \n-        // And now add the additional ones (both replacements and entirely new\n-        // ones).  These'll just be normal methods.\n-        for m: @ast::method  in ob.methods { meths += ~[normal_mthd(m)]; }\n-      }\n-    }\n+        // Sort all the methods and process them.\n+        meths =\n+            std::sort::ivector::merge_sort[vtbl_mthd]\n+            (bind vtbl_mthd_lteq(_, _), meths);\n \n-    // Sort all the methods.\n-    fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n-        alt a {\n-          normal_mthd(ma) {\n-            alt b {\n-              normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n-              fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n-            }\n-          }\n-          fwding_mthd(ma) {\n-            alt b {\n-              normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n-              fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n-            }\n-          }\n-        }\n-    }\n-    meths =\n-        std::sort::ivector::merge_sort[vtbl_mthd](bind vtbl_mthd_lteq(_, _),\n-                                                  meths);\n+        let backwarding_vtbl: ValueRef =\n+            create_backwarding_vtbl(cx, sp, inner_obj_ty, outer_obj_ty);\n \n-    // Now that we have our list of methods, we can process them in order.\n-    for m: vtbl_mthd in meths {\n-        alt m {\n-          normal_mthd(nm) {\n-            llmethods += ~[process_normal_mthd(cx, nm, outer_obj_ty,\n-                                               ty_params)];\n-          }\n-\n-          // If we have to process a forwarding method, then we need to know\n-          // about the inner_obj's type as well as the outer object's type.\n-          fwding_mthd(fm) {\n-            alt inner_obj_ty {\n-              none. {\n-                // This shouldn't happen; if we're trying to process a\n-                // forwarding method, then we should always have a\n-                // inner_obj_ty.\n-                cx.ccx.sess.bug(\"create_vtbl(): trying to create \\\n-                                forwarding method without a type \\\n-                                of object to forward to\");\n+        for m: vtbl_mthd in meths {\n+            alt m {\n+              normal_mthd(nm) {\n+                llmethods +=\n+                    ~[process_normal_mthd(cx, nm, outer_obj_ty, ty_params)];\n               }\n-              some(t) {\n+              fwding_mthd(fm) {\n                 llmethods +=\n-                    ~[process_fwding_mthd(cx, sp, fm, ty_params, t,\n+                    ~[process_fwding_mthd(cx, sp, fm, ty_params, inner_obj_ty,\n                                           backwarding_vtbl,\n                                           additional_field_tys)];\n               }\n             }\n-          }\n         }\n+      }\n     }\n \n     let vtbl = C_struct(llmethods);\n@@ -6895,8 +6967,8 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n     for m: ty::method in meths {\n         // We pass outer_obj_ty to process_fwding_mthd() because it's\n         // the one being forwarded to.\n-        llmethods += ~[process_fwding_mthd(\n-            cx, sp, @m, ~[], outer_obj_ty, none, ~[])];\n+        llmethods += ~[process_bkwding_mthd(\n+            cx, sp, @m, ~[], outer_obj_ty, ~[])];\n     }\n \n     let vtbl = C_struct(llmethods);"}]}