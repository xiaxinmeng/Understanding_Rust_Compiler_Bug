{"sha": "8e945dcd817a07d2d952acf431a6bc12a4246061", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTQ1ZGNkODE3YTA3ZDJkOTUyYWNmNDMxYTZiYzEyYTQyNDYwNjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-26T23:42:17Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-26T23:45:01Z"}, "message": "Remove native glues. All calls to C are direct now.", "tree": {"sha": "0baf69232ee5b15073e324a9e3df82d73c2bb078", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0baf69232ee5b15073e324a9e3df82d73c2bb078"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e945dcd817a07d2d952acf431a6bc12a4246061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e945dcd817a07d2d952acf431a6bc12a4246061", "html_url": "https://github.com/rust-lang/rust/commit/8e945dcd817a07d2d952acf431a6bc12a4246061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e945dcd817a07d2d952acf431a6bc12a4246061/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e5f6c8830b2842165e86112b0ab9b53c15d621", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e5f6c8830b2842165e86112b0ab9b53c15d621", "html_url": "https://github.com/rust-lang/rust/commit/89e5f6c8830b2842165e86112b0ab9b53c15d621"}], "stats": {"total": 271, "additions": 10, "deletions": 261}, "files": [{"sha": "bfe601c15a396bbd56f454e91e6db63474d44d7b", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=8e945dcd817a07d2d952acf431a6bc12a4246061", "patch": "@@ -69,14 +69,6 @@ const int closure_elt_ty_params = 3;\n \n const int worst_case_glue_call_args = 7;\n \n-const int n_native_glues = 8;\n-\n-tag native_glue_type {\n-    ngt_rust;\n-    ngt_pure_rust;\n-    ngt_cdecl;\n-}\n-\n fn memcpy_glue_name() -> str {\n     ret \"rust_memcpy_glue\";\n }\n@@ -89,16 +81,6 @@ fn vec_append_glue_name() -> str {\n     ret \"rust_vec_append_glue\";\n }\n \n-fn native_glue_name(int n, native_glue_type ngt) -> str {\n-    auto prefix;\n-    alt (ngt) {\n-        case (ngt_rust)         { prefix = \"rust_native_rust_\"; }\n-        case (ngt_pure_rust)    { prefix = \"rust_native_pure_rust_\"; }\n-        case (ngt_cdecl)        { prefix = \"rust_native_cdecl_\"; }\n-    }\n-    ret prefix + util::common::istr(n);\n-}\n-\n fn yield_glue_name() -> str {\n     ret \"rust_yield_glue\";\n }"}, {"sha": "01d4038488fbd3c887afc88dda17c2d43ef68730", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 1, "deletions": 186, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=8e945dcd817a07d2d952acf431a6bc12a4246061", "patch": "@@ -5,193 +5,8 @@ import std::vec;\n import std::os::target_os;\n import util::common::istr;\n \n-const int wordsz = 4;\n-\n-fn wstr(int i) -> str {\n-    ret istr(i * wordsz);\n-}\n-\n-fn start() -> vec[str] {\n-    ret [\".cfi_startproc\"];\n-}\n-\n-fn end() -> vec[str] {\n-    ret [\".cfi_endproc\"];\n-}\n-\n-fn save_callee_saves() -> vec[str] {\n-    ret [\"pushl %ebp\",\n-            \"pushl %edi\",\n-            \"pushl %esi\",\n-            \"pushl %ebx\"];\n-}\n-\n-fn save_callee_saves_with_cfi() -> vec[str] {\n-    auto offset = 8;\n-    auto t;\n-    t  = [\"pushl %ebp\"];\n-    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n-    t += [\".cfi_offset %ebp, -\" + istr(offset)];\n-\n-    t += [\"pushl %edi\"];\n-    offset += 4;\n-    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n-\n-    t += [\"pushl %esi\"];\n-    offset += 4;\n-    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n-\n-    t += [\"pushl %ebx\"];\n-    offset += 4;\n-    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n-    ret t;\n-}\n-\n-fn restore_callee_saves() -> vec[str] {\n-    ret [\"popl  %ebx\",\n-            \"popl  %esi\",\n-            \"popl  %edi\",\n-            \"popl  %ebp\"];\n-}\n-\n-fn load_esp_from_rust_sp_first_arg() -> vec[str] {\n-    ret [\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%ecx), %esp\"];\n-}\n-\n-fn load_esp_from_runtime_sp_first_arg() -> vec[str] {\n-    ret [\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%ecx), %esp\"];\n-}\n-\n-fn store_esp_to_rust_sp_first_arg() -> vec[str] {\n-    ret [\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\"];\n-}\n-\n-fn store_esp_to_runtime_sp_first_arg() -> vec[str] {\n-    ret [\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%ecx)\"];\n-}\n-\n-fn load_esp_from_rust_sp_second_arg() -> vec[str] {\n-    ret [\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%edx), %esp\"];\n-}\n-\n-fn load_esp_from_runtime_sp_second_arg() -> vec[str] {\n-    ret [\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%edx), %esp\"];\n-}\n-\n-fn store_esp_to_rust_sp_second_arg() -> vec[str] {\n-    ret [\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%edx)\"];\n-}\n-\n-fn store_esp_to_runtime_sp_second_arg() -> vec[str] {\n-    ret [\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%edx)\"];\n-}\n-\n-fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n-\n-    let bool pass_task;\n-    alt (ngt) {\n-        case (abi::ngt_rust)         { pass_task = true; }\n-        case (abi::ngt_pure_rust)    { pass_task = true; }\n-        case (abi::ngt_cdecl)        { pass_task = false; }\n-    }\n-\n-    /*\n-     * 0, 4, 8, 12 are callee-saves\n-     * 16 is retpc\n-     * 20 .. (5+i) * 4 are args\n-     *\n-     * ecx is taskptr\n-     * edx is callee\n-     *\n-     */\n-\n-    fn copy_arg(bool pass_task, uint i) -> str {\n-        if (i == 0u && pass_task) {\n-            ret \"movl  %edx, (%esp)\";\n-        }\n-        auto dst_off = wstr(0 + (i as int));\n-        auto src_off;\n-        if (pass_task) {\n-            src_off = wstr(4 + (i as int));\n-        } else {\n-            src_off = wstr(5 + (i as int));\n-        }\n-        auto m = [\"movl  \" + src_off + \"(%ebp),%eax\",\n-                     \"movl  %eax,\" + dst_off + \"(%esp)\"];\n-        ret str::connect(m, \"\\n\\t\");\n-    }\n-\n-    auto carg = bind copy_arg(pass_task, _);\n-\n-    ret\n-        start()\n-        + save_callee_saves_with_cfi()\n-\n-        + [\"movl  %esp, %ebp     # ebp = rust_sp\"]\n-        + [\".cfi_def_cfa_register %ebp\"]\n-\n-        + store_esp_to_rust_sp_second_arg()\n-        + load_esp_from_runtime_sp_second_arg()\n-\n-        + [\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n-              \"andl  $~0xf, %esp    # align esp down\"]\n-\n-        + vec::init_fn[str](carg, (n_args) as uint)\n-\n-        +  [\"movl  %edx, %edi     # save task from edx to edi\",\n-               \"call  *%ecx          # call *%ecx\",\n-               \"movl  %edi, %edx     # restore edi-saved task to edx\"]\n-\n-        + load_esp_from_rust_sp_second_arg()\n-        + restore_callee_saves()\n-        + [\"ret\"]\n-        + end();\n-\n-}\n-\n-\n-fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n-    auto sym = prefix + name;\n-    ret \"\\t.globl \" + sym + \"\\n\" +\n-        \"\\t.balign \" + istr(align) + \"\\n\" +\n-        sym + \":\\n\" +\n-        \"\\t\" + str::connect(insns, \"\\n\\t\");\n-}\n-\n-\n-fn decl_native_glue(int align, str prefix, abi::native_glue_type ngt, uint n)\n-        -> str {\n-    let int i = n as int;\n-    ret decl_glue(align, prefix,\n-                  abi::native_glue_name(i, ngt),\n-                  native_glue(i, ngt));\n-}\n-\n-fn get_symbol_prefix() -> str {\n-    if (str::eq(target_os(), \"macos\") ||\n-        str::eq(target_os(), \"win32\")) {\n-        ret \"_\";\n-    } else {\n-        ret \"\";\n-    }\n-}\n-\n fn get_module_asm() -> str {\n-    auto align = 4;\n-\n-    auto prefix = get_symbol_prefix();\n-\n-    let vec[str] glues =\n-        []\n-        + vec::init_fn[str](bind decl_native_glue(align, prefix,\n-            abi::ngt_rust, _), (abi::n_native_glues + 1) as uint)\n-        + vec::init_fn[str](bind decl_native_glue(align, prefix,\n-            abi::ngt_pure_rust, _), (abi::n_native_glues + 1) as uint)\n-        + vec::init_fn[str](bind decl_native_glue(align, prefix,\n-            abi::ngt_cdecl, _), (abi::n_native_glues + 1) as uint);\n-\n-\n-    ret str::connect(glues, \"\\n\\n\");\n+    ret \"\";\n }\n \n fn get_meta_sect_name() -> str {"}, {"sha": "a5d57f9066b58cd958da74dfd07b2d476870e53a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 57, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8e945dcd817a07d2d952acf431a6bc12a4246061", "patch": "@@ -56,9 +56,6 @@ state obj namegen(mutable int i) {\n type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n \n type glue_fns = rec(ValueRef yield_glue,\n-                    vec[ValueRef] native_glues_rust,\n-                    vec[ValueRef] native_glues_pure_rust,\n-                    vec[ValueRef] native_glues_cdecl,\n                     ValueRef no_op_type_glue,\n                     ValueRef vec_append_glue);\n \n@@ -80,10 +77,7 @@ type tydesc_info = rec(ty::t ty,\n  * please make sure you link it in at runtime\". This could be a reference to\n  * C code found in a C library, or rust code found in a rust crate.\n  *\n- * A \"native\" is a combination of an extern that references C code, plus a\n- * glue-code stub that \"looks like\" a rust function, emitted here, plus a\n- * generic N-ary bit of asm glue (found over in back/x86::rs) that performs a\n- * control transfer into C from rust. Natives may be normal C library code.\n+ * A \"native\" is an extern that references C code. Called with cdecl.\n  *\n  * An upcall is a native call generated by the compiler (not corresponding to\n  * any user-written call in the code) into librustrt, to perform some helper\n@@ -1048,32 +1042,6 @@ fn decl_glue(ModuleRef llmod, type_names tn, &str s) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn([T_taskptr(tn)], T_void()));\n }\n \n-fn decl_native_glue(ModuleRef llmod, &type_names tn,\n-                    abi::native_glue_type ngt, uint _n) -> ValueRef {\n-    let bool pass_task;\n-    alt (ngt) {\n-        case (abi::ngt_rust)         { pass_task = true; }\n-        case (abi::ngt_pure_rust)    { pass_task = true; }\n-        case (abi::ngt_cdecl)        { pass_task = false; }\n-    }\n-\n-    // It doesn't actually matter what type we come up with here, at the\n-    // moment, as we cast the native function pointers to int before passing\n-    // them to the indirect native-invocation glue.  But eventually we'd like\n-    // to call them directly, once we have a calling convention worked out.\n-    let int n = _n as int;\n-    let str s = abi::native_glue_name(n, ngt);\n-    let vec[TypeRef] args = [T_int()]; // callee\n-\n-    if (!pass_task) {\n-        args += [T_int()]; // taskptr, will not be passed\n-    }\n-\n-    args += vec::init_elt[TypeRef](T_int(), n as uint);\n-\n-    ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n-}\n-\n fn get_extern_fn(&hashmap[str, ValueRef] externs,\n                  ModuleRef llmod, &str name,\n                  uint cc, TypeRef ty) -> ValueRef {\n@@ -1108,27 +1076,16 @@ fn trans_native_call(&builder b, @glue_fns glues, ValueRef lltaskptr,\n                      &hashmap[str, ValueRef] externs,\n                      &type_names tn, ModuleRef llmod, &str name,\n                      bool pass_task, &vec[ValueRef] args) -> ValueRef {\n+\n     let int n = (vec::len[ValueRef](args) as int);\n     let ValueRef llnative = get_simple_extern_fn(externs, llmod, name, n);\n-    llnative = llvm::LLVMConstPointerCast(llnative, T_int());\n-\n-    let ValueRef llglue;\n-    if (pass_task) {\n-        llglue = glues.native_glues_rust.(n);\n-    } else {\n-        llglue = glues.native_glues_cdecl.(n);\n-    }\n-    let vec[ValueRef] call_args = [llnative];\n-\n-    if (!pass_task) {\n-        call_args += [lltaskptr];\n-    }\n \n+    let vec[ValueRef] call_args = [];\n     for (ValueRef a in args) {\n         call_args += [b.ZExtOrBitCast(a, T_int())];\n     }\n \n-    ret b.FastCall(llglue, call_args);\n+    ret b.Call(llnative, call_args);\n }\n \n fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n@@ -8030,16 +7987,6 @@ fn trans_vec_append_glue(@local_ctxt cx, &ast::span sp) {\n \n fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n     ret @rec(yield_glue = decl_glue(llmod, tn, abi::yield_glue_name()),\n-\n-             native_glues_rust =\n-                 vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n-                    abi::ngt_rust, _), abi::n_native_glues + 1 as uint),\n-             native_glues_pure_rust =\n-                 vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n-                    abi::ngt_pure_rust, _), abi::n_native_glues + 1 as uint),\n-             native_glues_cdecl =\n-                 vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n-                    abi::ngt_cdecl, _), abi::n_native_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }"}, {"sha": "0a58e6a76eee795c547bfd27ba96f4878667d135", "filename": "src/test/run-pass/lib-task.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Ftest%2Frun-pass%2Flib-task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Ftest%2Frun-pass%2Flib-task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-task.rs?ref=8e945dcd817a07d2d952acf431a6bc12a4246061", "patch": "@@ -1,3 +1,8 @@\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+\n use std;\n import std::_task;\n "}]}