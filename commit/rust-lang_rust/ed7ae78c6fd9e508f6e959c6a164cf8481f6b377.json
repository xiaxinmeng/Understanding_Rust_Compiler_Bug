{"sha": "ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkN2FlNzhjNmZkOWU1MDhmNmU5NTljNmExNjRjZjg0ODFmNmIzNzc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-17T16:54:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-17T16:54:08Z"}, "message": "ServerWorld", "tree": {"sha": "556e8d4daffefa64dcdc5db8e75299514a0e85e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/556e8d4daffefa64dcdc5db8e75299514a0e85e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "html_url": "https://github.com/rust-lang/rust/commit/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41570f60bf268c97223a864b8aa11a339929f55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/41570f60bf268c97223a864b8aa11a339929f55a", "html_url": "https://github.com/rust-lang/rust/commit/41570f60bf268c97223a864b8aa11a339929f55a"}], "stats": {"total": 428, "additions": 246, "deletions": 182}, "files": [{"sha": "084a9d7694d3155408d89ab13d47da6d8ec89314", "filename": "code/src/extension.ts", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/code%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/code%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fsrc%2Fextension.ts?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -60,14 +60,18 @@ export function activate(context: vscode.ExtensionContext) {\n     vscode.workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent) => {\n         let doc = event.document\n         if (doc.languageId != \"rust\") return\n-        // We need to order this after LS updates, but there's no API for that.\n-        // Hence, good old setTimeout.\n-        setTimeout(() => {\n+        afterLs(() => {\n             textDocumentContentProvider.eventEmitter.fire(uris.syntaxTree)\n-        }, 10)\n+        })\n     }, null, context.subscriptions)\n }\n \n+// We need to order this after LS updates, but there's no API for that.\n+// Hence, good old setTimeout.\n+function afterLs(f) {\n+    setTimeout(f, 10)\n+}\n+\n export function deactivate(): Thenable<void> {\n     if (!client) {\n         return undefined;\n@@ -118,7 +122,9 @@ function startServer() {\n                 if (editor == null) return\n                 if (!editor.selection.isEmpty) return\n                 let position = client.protocol2CodeConverter.asPosition(params)\n-                editor.selection = new vscode.Selection(position, position);\n+                afterLs(() => {\n+                    editor.selection = new vscode.Selection(position, position)\n+                })\n             }\n         )\n     })"}, {"sha": "b1093fe8336f90adb3d0307ce88065130bcb1c1a", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -40,6 +40,7 @@ const INDEXING_THRESHOLD: usize = 128;\n \n pub type FileResolver = dyn Fn(FileId, &Path) -> Option<FileId> + Send + Sync;\n \n+#[derive(Debug)]\n pub struct WorldState {\n     data: Arc<WorldData>\n }"}, {"sha": "4b2515835a4b25dc2e0c1efbbf74c198b555fc01", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -71,13 +71,11 @@ fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<Synta\n         .find(|node| !node.kind().is_trivia())\n }\n \n-fn find_non_trivia_leaf(syntax: SyntaxNodeRef, offset: TextUnit) -> Option<SyntaxNodeRef> {\n-    find_leaf_at_offset(syntax, offset)\n-        .find(|leaf| !leaf.kind().is_trivia())\n-}\n-\n pub fn find_node<'a, N: AstNode<&'a SyntaxRoot>>(syntax: SyntaxNodeRef<'a>, offset: TextUnit) -> Option<N> {\n-    let leaf = find_non_trivia_leaf(syntax, offset)?;\n+    let leaves = find_leaf_at_offset(syntax, offset);\n+    let leaf = leaves.clone()\n+        .find(|leaf| !leaf.kind().is_trivia())\n+        .or_else(|| leaves.right_biased())?;\n     ancestors(leaf)\n         .filter_map(N::cast)\n         .next()"}, {"sha": "cc422671045c245b9ec68e300f6c1b935b0caef5", "filename": "crates/libeditor/tests/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -1,11 +1,8 @@\n extern crate libeditor;\n extern crate libsyntax2;\n-extern crate itertools;\n #[macro_use]\n extern crate assert_eq_text;\n \n-use std::fmt;\n-use itertools::Itertools;\n use assert_eq_text::{assert_eq_dbg};\n use libeditor::{\n     File, TextUnit, TextRange, ActionResult, CursorPosition,\n@@ -118,6 +115,11 @@ fn test_add_derive() {\n         \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n         |file, off| add_derive(file, off).map(|f| f()),\n     );\n+    check_action(\n+        \"struct Foo { <|> a: i32, }\",\n+        \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n+        |file, off| add_derive(file, off).map(|f| f()),\n+    );\n     check_action(\n         \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n         \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\","}, {"sha": "fc905691418174920f651f39c0e792479491922b", "filename": "crates/server/src/conv.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fconv.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -6,7 +6,10 @@ use libeditor::{LineIndex, LineCol, Edit, AtomEdit};\n use libsyntax2::{SyntaxKind, TextUnit, TextRange};\n use libanalysis::FileId;\n \n-use {Result, PathMap};\n+use {\n+    Result,\n+    server_world::ServerWorld,\n+};\n \n pub trait Conv {\n     type Output;\n@@ -126,57 +129,52 @@ impl<T: ConvWith> ConvWith for Option<T> {\n }\n \n impl<'a> TryConvWith for &'a Url {\n-    type Ctx = PathMap;\n+    type Ctx = ServerWorld;\n     type Output = FileId;\n-    fn try_conv_with(self, path_map: &PathMap) -> Result<FileId> {\n-        let path = self.to_file_path()\n-            .map_err(|()| format_err!(\"invalid uri: {}\", self))?;\n-        path_map.get_id(&path).ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<FileId> {\n+        world.uri_to_file_id(self)\n     }\n }\n \n impl TryConvWith for FileId {\n-    type Ctx = PathMap;\n+    type Ctx = ServerWorld;\n     type Output = Url;\n-    fn try_conv_with(self, path_map: &PathMap) -> Result<Url> {\n-        let path = path_map.get_path(self);\n-        let url = Url::from_file_path(path)\n-            .map_err(|()| format_err!(\"can't convert path to url: {}\", path.display()))?;\n-        Ok(url)\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<Url> {\n+        world.file_id_to_uri(self)\n     }\n }\n \n impl<'a> TryConvWith for &'a TextDocumentItem {\n-    type Ctx = PathMap;\n+    type Ctx = ServerWorld;\n     type Output = FileId;\n-    fn try_conv_with(self, path_map: &PathMap) -> Result<FileId> {\n-        self.uri.try_conv_with(path_map)\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<FileId> {\n+        self.uri.try_conv_with(world)\n     }\n }\n \n impl<'a> TryConvWith for &'a VersionedTextDocumentIdentifier {\n-    type Ctx = PathMap;\n+    type Ctx = ServerWorld;\n     type Output = FileId;\n-    fn try_conv_with(self, path_map: &PathMap) -> Result<FileId> {\n-        self.uri.try_conv_with(path_map)\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<FileId> {\n+        self.uri.try_conv_with(world)\n     }\n }\n \n impl<'a> TryConvWith for &'a TextDocumentIdentifier {\n-    type Ctx = PathMap;\n+    type Ctx = ServerWorld;\n     type Output = FileId;\n-    fn try_conv_with(self, path_map: &PathMap) -> Result<FileId> {\n-        self.uri.try_conv_with(path_map)\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<FileId> {\n+        world.uri_to_file_id(&self.uri)\n     }\n }\n \n pub fn to_location(\n     file_id: FileId,\n     range: TextRange,\n-    path_map: &PathMap,\n+    world: &ServerWorld,\n     line_index: &LineIndex,\n ) -> Result<Location> {\n-        let url = file_id.try_conv_with(path_map)?;\n+        let url = file_id.try_conv_with(world)?;\n         let loc = Location::new(\n             url,\n             range.conv_with(line_index),"}, {"sha": "5e4c0fe7e533d24b2f193c088577a50f81363a98", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -27,15 +27,14 @@ mod conv;\n mod main_loop;\n mod vfs;\n mod path_map;\n+mod server_world;\n \n use threadpool::ThreadPool;\n use crossbeam_channel::bounded;\n use flexi_logger::{Logger, Duplicate};\n-use libanalysis::WorldState;\n \n use ::{\n     io::{Io, RawMsg, RawResponse, RawRequest, RawNotification},\n-    path_map::PathMap,\n };\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -116,7 +115,6 @@ enum Task {\n \n fn initialized(io: &mut Io) -> Result<()> {\n     {\n-        let mut world = WorldState::new();\n         let mut pool = ThreadPool::new(4);\n         let (task_sender, task_receiver) = bounded::<Task>(16);\n         let (fs_events_receiver, watcher) = vfs::watch(vec![\n@@ -125,7 +123,6 @@ fn initialized(io: &mut Io) -> Result<()> {\n         info!(\"lifecycle: handshake finished, server ready to serve requests\");\n         let res = main_loop::main_loop(\n             io,\n-            &mut world,\n             &mut pool,\n             task_sender,\n             task_receiver.clone(),"}, {"sha": "675f69bec58b3e61118cad3f534a3f4974fa6cec", "filename": "crates/server/src/main_loop/handlers.rs", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -5,35 +5,33 @@ use languageserver_types::{\n     Command, TextDocumentIdentifier, WorkspaceEdit,\n     SymbolInformation, Position,\n };\n-use libanalysis::{World, Query};\n+use libanalysis::{Query};\n use libeditor::{self, CursorPosition};\n use libsyntax2::TextUnit;\n use serde_json::{to_value, from_value};\n \n use ::{\n-    PathMap,\n     req::{self, Decoration}, Result,\n     conv::{Conv, ConvWith, TryConvWith, MapConvWith, to_location},\n+    server_world::ServerWorld,\n };\n \n pub fn handle_syntax_tree(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::SyntaxTreeParams,\n ) -> Result<String> {\n-    let id = params.text_document.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(id)?;\n+    let id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(id)?;\n     Ok(libeditor::syntax_tree(&file))\n }\n \n pub fn handle_extend_selection(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::ExtendSelectionParams,\n ) -> Result<req::ExtendSelectionResult> {\n-    let file_id = params.text_document.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let selections = params.selections.into_iter()\n         .map_conv_with(&line_index)\n         .map(|r| libeditor::extend_selection(&file, r).unwrap_or(r))\n@@ -43,13 +41,12 @@ pub fn handle_extend_selection(\n }\n \n pub fn handle_find_matching_brace(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::FindMatchingBraceParams,\n ) -> Result<Vec<Position>> {\n-    let file_id = params.text_document.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let res = params.offsets\n         .into_iter()\n         .map_conv_with(&line_index)\n@@ -62,13 +59,12 @@ pub fn handle_find_matching_brace(\n }\n \n pub fn handle_document_symbol(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::DocumentSymbolParams,\n ) -> Result<Option<req::DocumentSymbolResponse>> {\n-    let file_id = params.text_document.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n@@ -102,13 +98,12 @@ pub fn handle_document_symbol(\n }\n \n pub fn handle_code_action(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::CodeActionParams,\n ) -> Result<Option<Vec<Command>>> {\n-    let file_id = params.text_document.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let offset = params.range.conv_with(&line_index).start();\n     let mut ret = Vec::new();\n \n@@ -127,8 +122,7 @@ pub fn handle_code_action(\n }\n \n pub fn handle_workspace_symbol(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let all_symbols = params.query.contains(\"#\");\n@@ -143,25 +137,25 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n-    let mut res = exec_query(&world, &path_map, query)?;\n+    let mut res = exec_query(&world, query)?;\n     if res.is_empty() && !all_symbols {\n         let mut query = Query::new(params.query);\n         query.limit(128);\n-        res = exec_query(&world, &path_map, query)?;\n+        res = exec_query(&world, query)?;\n     }\n \n     return Ok(Some(res));\n \n-    fn exec_query(world: &World, path_map: &PathMap, query: Query) -> Result<Vec<SymbolInformation>> {\n+    fn exec_query(world: &ServerWorld, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for (file_id, symbol) in world.world_symbols(query) {\n-            let line_index = world.file_line_index(file_id)?;\n+        for (file_id, symbol) in world.analysis().world_symbols(query) {\n+            let line_index = world.analysis().file_line_index(file_id)?;\n             let info = SymbolInformation {\n                 name: symbol.name.to_string(),\n                 kind: symbol.kind.conv(),\n                 location: to_location(\n                     file_id, symbol.node_range,\n-                    path_map, &line_index\n+                    world, &line_index\n                 )?,\n                 container_name: None,\n             };\n@@ -172,28 +166,26 @@ pub fn handle_workspace_symbol(\n }\n \n pub fn handle_goto_definition(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n-    let file_id = params.text_document.try_conv_with(&path_map)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let offset = params.position.conv_with(&line_index);\n     let mut res = Vec::new();\n-    for (file_id, symbol) in world.approximately_resolve_symbol(file_id, offset)? {\n-        let line_index = world.file_line_index(file_id)?;\n+    for (file_id, symbol) in world.analysis().approximately_resolve_symbol(file_id, offset)? {\n+        let line_index = world.analysis().file_line_index(file_id)?;\n         let location = to_location(\n             file_id, symbol.node_range,\n-            &path_map, &line_index,\n+            &world, &line_index,\n         )?;\n         res.push(location)\n     }\n     Ok(Some(req::GotoDefinitionResponse::Array(res)))\n }\n \n pub fn handle_execute_command(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     mut params: req::ExecuteCommandParams,\n ) -> Result<(req::ApplyWorkspaceEditParams, Option<Position>)> {\n     if params.command.as_str() != \"apply_code_action\" {\n@@ -204,13 +196,13 @@ pub fn handle_execute_command(\n     }\n     let arg = params.arguments.pop().unwrap();\n     let arg: ActionRequest = from_value(arg)?;\n-    let file_id = arg.text_document.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n+    let file_id = arg.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n     let action_result = match arg.id {\n         ActionId::FlipComma => libeditor::flip_comma(&file, arg.offset).map(|f| f()),\n         ActionId::AddDerive => libeditor::add_derive(&file, arg.offset).map(|f| f()),\n     }.ok_or_else(|| format_err!(\"command not applicable\"))?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let mut changes = HashMap::new();\n     changes.insert(\n         arg.text_document.uri,\n@@ -265,13 +257,12 @@ impl ActionId {\n }\n \n pub fn publish_diagnostics(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     uri: Url\n ) -> Result<req::PublishDiagnosticsParams> {\n-    let file_id = uri.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = world.uri_to_file_id(&uri)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let diagnostics = libeditor::diagnostics(&file)\n         .into_iter()\n         .map(|d| Diagnostic {\n@@ -286,13 +277,12 @@ pub fn publish_diagnostics(\n }\n \n pub fn publish_decorations(\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     uri: Url\n ) -> Result<req::PublishDecorationsParams> {\n-    let file_id = uri.try_conv_with(&path_map)?;\n-    let file = world.file_syntax(file_id)?;\n-    let line_index = world.file_line_index(file_id)?;\n+    let file_id = world.uri_to_file_id(&uri)?;\n+    let file = world.analysis().file_syntax(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let decorations = libeditor::highlight(&file)\n         .into_iter()\n         .map(|h| Decoration {"}, {"sha": "ad7c480dc60df7006a9fb175eaa414359e7a0730", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 40, "deletions": 85, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -1,21 +1,20 @@\n mod handlers;\n \n use std::{\n-    collections::{HashSet, HashMap},\n+    collections::{HashSet},\n };\n \n use threadpool::ThreadPool;\n use crossbeam_channel::{Sender, Receiver};\n use languageserver_types::Url;\n-use libanalysis::{World, WorldState, FileId};\n use serde_json::to_value;\n \n use {\n     req, dispatch,\n-    Task, Result, PathMap,\n+    Task, Result,\n     io::{Io, RawMsg, RawRequest, RawNotification},\n-    vfs::{FileEvent, FileEventKind},\n-    conv::TryConvWith,\n+    vfs::FileEvent,\n+    server_world::{ServerWorldState, ServerWorld},\n     main_loop::handlers::{\n         handle_syntax_tree,\n         handle_extend_selection,\n@@ -32,17 +31,16 @@ use {\n \n pub(super) fn main_loop(\n     io: &mut Io,\n-    world: &mut WorldState,\n     pool: &mut ThreadPool,\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n     fs_events_receiver: Receiver<Vec<FileEvent>>,\n ) -> Result<()> {\n     info!(\"server initialized, serving requests\");\n+    let mut state = ServerWorldState::new();\n+\n     let mut next_request_id = 0;\n     let mut pending_requests: HashSet<u64> = HashSet::new();\n-    let mut path_map = PathMap::new();\n-    let mut mem_map: HashMap<FileId, Option<String>> = HashMap::new();\n     let mut fs_events_receiver = Some(&fs_events_receiver);\n     loop {\n         enum Event {\n@@ -91,37 +89,17 @@ pub(super) fn main_loop(\n             }\n             Event::Fs(events) => {\n                 trace!(\"fs change, {} events\", events.len());\n-                let changes = events.into_iter()\n-                    .map(|event| {\n-                        let text = match event.kind {\n-                            FileEventKind::Add(text) => Some(text),\n-                            FileEventKind::Remove => None,\n-                        };\n-                        (event.path, text)\n-                    })\n-                    .map(|(path, text)| {\n-                        (path_map.get_or_insert(path), text)\n-                    })\n-                    .filter_map(|(id, text)| {\n-                        if mem_map.contains_key(&id) {\n-                            mem_map.insert(id, text);\n-                            None\n-                        } else {\n-                            Some((id, text))\n-                        }\n-                    });\n-\n-                world.change_files(changes);\n+                state.apply_fs_changes(events);\n             }\n             Event::Msg(msg) => {\n                 match msg {\n                     RawMsg::Request(req) => {\n-                        if !on_request(io, world, &path_map, pool, &task_sender, req)? {\n+                        if !on_request(io, &state, pool, &task_sender, req)? {\n                             return Ok(());\n                         }\n                     }\n                     RawMsg::Notification(not) => {\n-                        on_notification(io, world, &mut path_map, pool, &task_sender, not, &mut mem_map)?\n+                        on_notification(io, &mut state, pool, &task_sender, not)?\n                     }\n                     RawMsg::Response(resp) => {\n                         if !pending_requests.remove(&resp.id) {\n@@ -136,45 +114,40 @@ pub(super) fn main_loop(\n \n fn on_request(\n     io: &mut Io,\n-    world: &WorldState,\n-    path_map: &PathMap,\n+    world: &ServerWorldState,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n     req: RawRequest,\n ) -> Result<bool> {\n     let mut req = Some(req);\n     handle_request_on_threadpool::<req::SyntaxTree>(\n-        &mut req, pool, path_map, world, sender, handle_syntax_tree,\n+        &mut req, pool, world, sender, handle_syntax_tree,\n     )?;\n     handle_request_on_threadpool::<req::ExtendSelection>(\n-        &mut req, pool, path_map, world, sender, handle_extend_selection,\n+        &mut req, pool, world, sender, handle_extend_selection,\n     )?;\n     handle_request_on_threadpool::<req::FindMatchingBrace>(\n-        &mut req, pool, path_map, world, sender, handle_find_matching_brace,\n+        &mut req, pool, world, sender, handle_find_matching_brace,\n     )?;\n     handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n-        &mut req, pool, path_map, world, sender, handle_document_symbol,\n+        &mut req, pool, world, sender, handle_document_symbol,\n     )?;\n     handle_request_on_threadpool::<req::CodeActionRequest>(\n-        &mut req, pool, path_map, world, sender, handle_code_action,\n+        &mut req, pool, world, sender, handle_code_action,\n     )?;\n     handle_request_on_threadpool::<req::WorkspaceSymbol>(\n-        &mut req, pool, path_map, world, sender, handle_workspace_symbol,\n+        &mut req, pool, world, sender, handle_workspace_symbol,\n     )?;\n     handle_request_on_threadpool::<req::GotoDefinition>(\n-        &mut req, pool, path_map, world, sender, handle_goto_definition,\n+        &mut req, pool, world, sender, handle_goto_definition,\n     )?;\n     dispatch::handle_request::<req::ExecuteCommand, _>(&mut req, |params, resp| {\n         io.send(RawMsg::Response(resp.into_response(Ok(None))?));\n \n-        let world = world.snapshot({\n-            let pm = path_map.clone();\n-            move |id, path| pm.resolve(id, path)\n-        });\n-        let path_map = path_map.clone();\n+        let world = world.snapshot();\n         let sender = sender.clone();\n         pool.execute(move || {\n-            let (edit, cursor) = match handle_execute_command(world, path_map, params) {\n+            let (edit, cursor) = match handle_execute_command(world, params) {\n                 Ok(res) => res,\n                 Err(e) => return sender.send(Task::Die(e)),\n             };\n@@ -221,60 +194,48 @@ fn on_request(\n \n fn on_notification(\n     io: &mut Io,\n-    world: &mut WorldState,\n-    path_map: &mut PathMap,\n+    state: &mut ServerWorldState,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n     not: RawNotification,\n-    mem_map: &mut HashMap<FileId, Option<String>>,\n ) -> Result<()> {\n     let mut not = Some(not);\n     dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n         let uri = params.text_document.uri;\n         let path = uri.to_file_path()\n             .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        let file_id = path_map.get_or_insert(path);\n-        mem_map.insert(file_id, None);\n-        world.change_file(file_id, Some(params.text_document.text));\n+        state.add_mem_file(path, params.text_document.text);\n         update_file_notifications_on_threadpool(\n             pool,\n-            world.snapshot({\n-                let pm = path_map.clone();\n-                move |id, path| pm.resolve(id, path)\n-            }),\n-            path_map.clone(),\n+            state.snapshot(),\n             sender.clone(),\n             uri,\n         );\n         Ok(())\n     })?;\n     dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n-        let file_id = params.text_document.try_conv_with(path_map)?;\n+        let uri = params.text_document.uri;\n+        let path = uri.to_file_path()\n+            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n         let text = params.content_changes.pop()\n             .ok_or_else(|| format_err!(\"empty changes\"))?\n             .text;\n-        world.change_file(file_id, Some(text));\n+        state.change_mem_file(path.as_path(), text)?;\n         update_file_notifications_on_threadpool(\n             pool,\n-            world.snapshot({\n-                let pm = path_map.clone();\n-                move |id, path| pm.resolve(id, path)\n-            }),\n-            path_map.clone(),\n+            state.snapshot(),\n             sender.clone(),\n-            params.text_document.uri,\n+            uri,\n         );\n         Ok(())\n     })?;\n     dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n-        let file_id = params.text_document.try_conv_with(path_map)?;\n-        let text = match mem_map.remove(&file_id) {\n-            Some(text) => text,\n-            None => bail!(\"unmatched close notification\"),\n-        };\n-        world.change_file(file_id, text);\n+        let uri = params.text_document.uri;\n+        let path = uri.to_file_path()\n+            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+        state.remove_mem_file(path.as_path())?;\n         let not = req::PublishDiagnosticsParams {\n-            uri: params.text_document.uri,\n+            uri,\n             diagnostics: Vec::new(),\n         };\n         let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n@@ -291,21 +252,16 @@ fn on_notification(\n fn handle_request_on_threadpool<R: req::ClientRequest>(\n     req: &mut Option<RawRequest>,\n     pool: &ThreadPool,\n-    path_map: &PathMap,\n-    world: &WorldState,\n+    world: &ServerWorldState,\n     sender: &Sender<Task>,\n-    f: fn(World, PathMap, R::Params) -> Result<R::Result>,\n+    f: fn(ServerWorld, R::Params) -> Result<R::Result>,\n ) -> Result<()>\n {\n     dispatch::handle_request::<R, _>(req, |params, resp| {\n-        let world = world.snapshot({\n-            let pm = path_map.clone();\n-            move |id, path| pm.resolve(id, path)\n-        });\n-        let path_map = path_map.clone();\n+        let world = world.snapshot();\n         let sender = sender.clone();\n         pool.execute(move || {\n-            let res = f(world, path_map, params);\n+            let res = f(world, params);\n             let task = match resp.into_response(res) {\n                 Ok(resp) => Task::Respond(resp),\n                 Err(e) => Task::Die(e),\n@@ -318,13 +274,12 @@ fn handle_request_on_threadpool<R: req::ClientRequest>(\n \n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n-    world: World,\n-    path_map: PathMap,\n+    world: ServerWorld,\n     sender: Sender<Task>,\n     uri: Url,\n ) {\n     pool.execute(move || {\n-        match publish_diagnostics(world.clone(), path_map.clone(), uri.clone()) {\n+        match publish_diagnostics(world.clone(), uri.clone()) {\n             Err(e) => {\n                 error!(\"failed to compute diagnostics: {:?}\", e)\n             }\n@@ -333,7 +288,7 @@ fn update_file_notifications_on_threadpool(\n                 sender.send(Task::Notify(not));\n             }\n         }\n-        match publish_decorations(world, path_map.clone(), uri) {\n+        match publish_decorations(world, uri) {\n             Err(e) => {\n                 error!(\"failed to compute decorations: {:?}\", e)\n             }"}, {"sha": "c0d2efb8638790243abcb335573438ee7f7e08c2", "filename": "crates/server/src/server_world.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7ae78c6fd9e508f6e959c6a164cf8481f6b377/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=ed7ae78c6fd9e508f6e959c6a164cf8481f6b377", "patch": "@@ -0,0 +1,117 @@\n+use std::{\n+    path::{PathBuf, Path},\n+    collections::HashMap,\n+};\n+\n+use languageserver_types::Url;\n+use libanalysis::{FileId, WorldState, World};\n+\n+use {\n+    Result,\n+    path_map::PathMap,\n+    vfs::{FileEvent, FileEventKind},\n+};\n+\n+#[derive(Debug)]\n+pub struct ServerWorldState {\n+    pub analysis: WorldState,\n+    pub path_map: PathMap,\n+    pub mem_map: HashMap<FileId, Option<String>>,\n+}\n+\n+#[derive(Clone)]\n+pub struct ServerWorld {\n+    pub analysis: World,\n+    pub path_map: PathMap,\n+}\n+\n+impl ServerWorldState {\n+    pub fn new() -> ServerWorldState {\n+        ServerWorldState {\n+            analysis: WorldState::new(),\n+            path_map: PathMap::new(),\n+            mem_map: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn apply_fs_changes(&mut self, events: Vec<FileEvent>) {\n+        let pm = &mut self.path_map;\n+        let mm = &mut self.mem_map;\n+        let changes = events.into_iter()\n+            .map(|event| {\n+                let text = match event.kind {\n+                    FileEventKind::Add(text) => Some(text),\n+                    FileEventKind::Remove => None,\n+                };\n+                (event.path, text)\n+            })\n+            .map(|(path, text)| {\n+                (pm.get_or_insert(path), text)\n+            })\n+            .filter_map(|(id, text)| {\n+                if mm.contains_key(&id) {\n+                    mm.insert(id, text);\n+                    None\n+                } else {\n+                    Some((id, text))\n+                }\n+            });\n+\n+        self.analysis.change_files(changes);\n+    }\n+\n+    pub fn add_mem_file(&mut self, path: PathBuf, text: String) {\n+        let file_id = self.path_map.get_or_insert(path);\n+        self.mem_map.insert(file_id, None);\n+        self.analysis.change_file(file_id, Some(text));\n+    }\n+\n+    pub fn change_mem_file(&mut self, path: &Path, text: String) -> Result<()> {\n+        let file_id = self.path_map.get_id(path).ok_or_else(|| {\n+            format_err!(\"change to unknown file: {}\", path.display())\n+        })?;\n+        self.analysis.change_file(file_id, Some(text));\n+        Ok(())\n+    }\n+\n+    pub fn remove_mem_file(&mut self, path: &Path) -> Result<()> {\n+        let file_id = self.path_map.get_id(path).ok_or_else(|| {\n+            format_err!(\"change to unknown file: {}\", path.display())\n+        })?;\n+        let text = match self.mem_map.remove(&file_id) {\n+            Some(text) => text,\n+            None => bail!(\"unmatched close notification\"),\n+        };\n+        self.analysis.change_file(file_id, text);\n+        Ok(())\n+    }\n+\n+    pub fn snapshot(&self) -> ServerWorld {\n+        let pm = self.path_map.clone();\n+        ServerWorld {\n+            analysis: self.analysis.snapshot(move |id, path| {\n+                pm.resolve(id, path)\n+            }),\n+            path_map: self.path_map.clone()\n+        }\n+    }\n+}\n+\n+impl ServerWorld {\n+    pub fn analysis(&self) -> &World {\n+        &self.analysis\n+    }\n+\n+    pub fn uri_to_file_id(&self, uri: &Url) -> Result<FileId> {\n+        let path = uri.to_file_path()\n+            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+        self.path_map.get_id(&path).ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))\n+    }\n+\n+    pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {\n+        let path = self.path_map.get_path(id);\n+        let url = Url::from_file_path(path)\n+            .map_err(|()| format_err!(\"can't convert path to url: {}\", path.display()))?;\n+        Ok(url)\n+    }\n+}"}]}