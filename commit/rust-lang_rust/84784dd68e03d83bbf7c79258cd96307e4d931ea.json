{"sha": "84784dd68e03d83bbf7c79258cd96307e4d931ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0Nzg0ZGQ2OGUwM2Q4M2JiZjdjNzkyNThjZDk2MzA3ZTRkOTMxZWE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-09T13:35:04Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:42:10Z"}, "message": "Eagerly convert ranges to IntRange\n\nThat way no `ConstantRange` or `ConstantValue` ever needs to be\nconverted to `IntRange`.", "tree": {"sha": "cae2c7078d0a7fa9328695a5768819b3f2844a2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cae2c7078d0a7fa9328695a5768819b3f2844a2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84784dd68e03d83bbf7c79258cd96307e4d931ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84784dd68e03d83bbf7c79258cd96307e4d931ea", "html_url": "https://github.com/rust-lang/rust/commit/84784dd68e03d83bbf7c79258cd96307e4d931ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84784dd68e03d83bbf7c79258cd96307e4d931ea/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b8bfefa0014bc091acc433f15aa98d37b52e0ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8bfefa0014bc091acc433f15aa98d37b52e0ba", "html_url": "https://github.com/rust-lang/rust/commit/6b8bfefa0014bc091acc433f15aa98d37b52e0ba"}], "stats": {"total": 121, "additions": 63, "deletions": 58}, "files": [{"sha": "312b414fd2a7a2d095a29081047f4d75a7beb9a0", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/84784dd68e03d83bbf7c79258cd96307e4d931ea/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84784dd68e03d83bbf7c79258cd96307e4d931ea/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=84784dd68e03d83bbf7c79258cd96307e4d931ea", "patch": "@@ -593,8 +593,7 @@ enum Constructor<'tcx> {\n     ConstantValue(&'tcx ty::Const<'tcx>, Span),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange<'tcx>),\n-    // TODO: non-integer\n-    /// Ranges of literal values (`2.0..=5.2`).\n+    /// Ranges of non-integer literal values (`2.0..=5.2`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length `n`.\n     FixedLenSlice(u64),\n@@ -636,13 +635,10 @@ impl<'tcx> Constructor<'tcx> {\n     }\n \n     fn is_integral_range(&self) -> bool {\n-        let ty = match self {\n-            ConstantValue(value, _) => value.ty,\n-            ConstantRange(_, _, ty, _, _) => ty,\n+        match self {\n             IntRange(_) => return true,\n             _ => return false,\n         };\n-        IntRange::is_integral(ty)\n     }\n \n     fn variant_index_for_adt<'a>(\n@@ -669,7 +665,7 @@ impl<'tcx> Constructor<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         other_ctors: &Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n-        match *self {\n+        match self {\n             // Those constructors can only match themselves.\n             Single | Variant(_) => {\n                 if other_ctors.iter().any(|c| c == self) {\n@@ -678,7 +674,7 @@ impl<'tcx> Constructor<'tcx> {\n                     vec![self.clone()]\n                 }\n             }\n-            FixedLenSlice(self_len) => {\n+            &FixedLenSlice(self_len) => {\n                 let overlaps = |c: &Constructor<'_>| match *c {\n                     FixedLenSlice(other_len) => other_len == self_len,\n                     VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n@@ -749,41 +745,39 @@ impl<'tcx> Constructor<'tcx> {\n \n                 remaining_ctors\n             }\n-            IntRange(..) | ConstantRange(..) | ConstantValue(..) => {\n-                if let Some(self_range) = IntRange::from_ctor(tcx, param_env, self) {\n-                    let mut remaining_ranges = vec![self_range.clone()];\n-                    let other_ranges = other_ctors\n-                        .into_iter()\n-                        .filter_map(|c| IntRange::from_ctor(tcx, param_env, c));\n-                    for other_range in other_ranges {\n-                        if other_range == self_range {\n-                            // If the `self` range appears directly in a `match` arm, we can\n-                            // eliminate it straight away.\n-                            remaining_ranges = vec![];\n-                        } else {\n-                            // Otherwise explicitely compute the remaining ranges.\n-                            remaining_ranges = other_range.subtract_from(remaining_ranges);\n-                        }\n+            IntRange(self_range) => {\n+                let mut remaining_ranges = vec![self_range.clone()];\n+                let other_ranges =\n+                    other_ctors.into_iter().filter_map(|c| IntRange::from_ctor(tcx, param_env, c));\n+                for other_range in other_ranges {\n+                    if other_range == *self_range {\n+                        // If the `self` range appears directly in a `match` arm, we can\n+                        // eliminate it straight away.\n+                        remaining_ranges = vec![];\n+                    } else {\n+                        // Otherwise explicitely compute the remaining ranges.\n+                        remaining_ranges = other_range.subtract_from(remaining_ranges);\n+                    }\n \n-                        // If the ranges that have been considered so far already cover the entire\n-                        // range of values, we can return early.\n-                        if remaining_ranges.is_empty() {\n-                            break;\n-                        }\n+                    // If the ranges that have been considered so far already cover the entire\n+                    // range of values, we can return early.\n+                    if remaining_ranges.is_empty() {\n+                        break;\n                     }\n+                }\n \n-                    // Convert the ranges back into constructors\n-                    remaining_ranges.into_iter().map(IntRange).collect()\n+                // Convert the ranges back into constructors\n+                remaining_ranges.into_iter().map(IntRange).collect()\n+            }\n+            ConstantRange(..) | ConstantValue(..) => {\n+                if other_ctors.iter().any(|c| {\n+                    c == self\n+                        // FIXME(Nadrieril): This condition looks fishy\n+                        || IntRange::from_ctor(tcx, param_env, c).is_some()\n+                }) {\n+                    vec![]\n                 } else {\n-                    if other_ctors.iter().any(|c| {\n-                        c == self\n-                             // FIXME(Nadrieril): This condition looks fishy\n-                             || IntRange::from_ctor(tcx, param_env, c).is_some()\n-                    }) {\n-                        vec![]\n-                    } else {\n-                        vec![self.clone()]\n-                    }\n+                    vec![self.clone()]\n                 }\n             }\n             // This constructor is never covered by anything else\n@@ -1285,6 +1279,10 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n+    fn is_singleton(&self) -> bool {\n+        self.range.start() == self.range.end()\n+    }\n+\n     fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         // Don't treat `usize`/`isize` exhaustively unless the `precise_pointer_size_matching`\n         // feature is enabled.\n@@ -1363,15 +1361,13 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     fn from_ctor(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n+        _param_env: ty::ParamEnv<'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         match ctor {\n-            ConstantRange(lo, hi, ty, end, span) => Self::from_range(tcx, *lo, *hi, ty, end, *span),\n-            ConstantValue(val, span) => Self::from_const(tcx, param_env, val, *span),\n             IntRange(range) => Some(range.clone()),\n             _ => None,\n         }\n@@ -1747,14 +1743,23 @@ fn pat_constructor<'tcx>(\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(Variant(adt_def.variants[variant_index].def_id))\n         }\n-        PatKind::Constant { value } => Some(ConstantValue(value, pat.span)),\n-        PatKind::Range(PatRange { lo, hi, end }) => Some(ConstantRange(\n-            lo.eval_bits(tcx, param_env, lo.ty),\n-            hi.eval_bits(tcx, param_env, hi.ty),\n-            lo.ty,\n-            end,\n-            pat.span,\n-        )),\n+        PatKind::Constant { value } => {\n+            if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n+                Some(IntRange(int_range))\n+            } else {\n+                Some(ConstantValue(value, pat.span))\n+            }\n+        }\n+        PatKind::Range(PatRange { lo, hi, end }) => {\n+            let ty = lo.ty;\n+            let lo = lo.eval_bits(tcx, param_env, lo.ty);\n+            let hi = hi.eval_bits(tcx, param_env, hi.ty);\n+            if let Some(int_range) = IntRange::from_range(tcx, lo, hi, ty, &end, pat.span) {\n+                Some(IntRange(int_range))\n+            } else {\n+                Some(ConstantRange(lo, hi, ty, end, pat.span))\n+            }\n+        }\n         PatKind::Array { .. } => match pat.ty.kind {\n             ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(tcx, param_env))),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n@@ -1897,13 +1902,13 @@ fn split_grouped_constructors<'p, 'tcx>(\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            IntRange(..) | ConstantRange(..)\n-                if IntRange::should_treat_range_exhaustively(tcx, ty) =>\n-            {\n-                // We only care about finding all the subranges within the range of the constructor\n-                // range. Anything else is irrelevant, because it is guaranteed to result in\n-                // `NotUseful`, which is the default case anyway, and can be ignored.\n-                let ctor_range = IntRange::from_ctor(tcx, param_env, &ctor).unwrap();\n+            IntRange(ctor_range) if IntRange::should_treat_range_exhaustively(tcx, ty) => {\n+                // Fast-track if the range is trivial. In particular, don't do the overlapping\n+                // ranges check.\n+                if ctor_range.is_singleton() {\n+                    split_ctors.push(IntRange(ctor_range));\n+                    continue;\n+                }\n \n                 /// Represents a border between 2 integers. Because the intervals spanning borders\n                 /// must be able to cover every integer, we need to be able to represent"}]}