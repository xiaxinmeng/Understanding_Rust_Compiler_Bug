{"sha": "a8ecaa19796e6d302f82b05f533ab99bd9522644", "node_id": "C_kwDOAAsO6NoAKGE4ZWNhYTE5Nzk2ZTZkMzAyZjgyYjA1ZjUzM2FiOTliZDk1MjI2NDQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-13T13:09:40Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-13T13:15:27Z"}, "message": "Restructure `find_path` into a separate functions for modules and non-module items\n\nAlso renames `prefer_core` imports config to `prefer_no_std` and changes the behavior of no_std path searching by preferring `core` paths `over` alloc", "tree": {"sha": "4f2773040db8012d507413299728563458f9c3de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f2773040db8012d507413299728563458f9c3de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8ecaa19796e6d302f82b05f533ab99bd9522644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ecaa19796e6d302f82b05f533ab99bd9522644", "html_url": "https://github.com/rust-lang/rust/commit/a8ecaa19796e6d302f82b05f533ab99bd9522644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8ecaa19796e6d302f82b05f533ab99bd9522644/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1a4ba3e84f021dd3e8eeaaca0eecaa758f8d32c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a4ba3e84f021dd3e8eeaaca0eecaa758f8d32c", "html_url": "https://github.com/rust-lang/rust/commit/b1a4ba3e84f021dd3e8eeaaca0eecaa758f8d32c"}], "stats": {"total": 491, "additions": 291, "deletions": 200}, "files": [{"sha": "b94b50004093ccdee496da7c23884e9a46428b5b", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 219, "deletions": 141, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -1,6 +1,6 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use std::iter;\n+use std::{cmp::Ordering, iter};\n \n use hir_expand::name::{known, AsName, Name};\n use rustc_hash::FxHashSet;\n@@ -20,59 +20,25 @@ pub fn find_path(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n-    prefer_core: bool,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     let _p = profile::span(\"find_path\");\n-    find_path_inner(db, item, from, None, prefer_core)\n+    find_path_inner(db, item, from, None, prefer_no_std)\n }\n \n pub fn find_path_prefixed(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     prefix_kind: PrefixKind,\n-    prefer_core: bool,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     let _p = profile::span(\"find_path_prefixed\");\n-    find_path_inner(db, item, from, Some(prefix_kind), prefer_core)\n+    find_path_inner(db, item, from, Some(prefix_kind), prefer_no_std)\n }\n \n const MAX_PATH_LEN: usize = 15;\n \n-trait ModPathExt {\n-    fn starts_with_std(&self) -> bool;\n-    fn can_start_with_std(&self) -> bool;\n-}\n-\n-impl ModPathExt for ModPath {\n-    fn starts_with_std(&self) -> bool {\n-        self.segments().first() == Some(&known::std)\n-    }\n-\n-    // Can we replace the first segment with `std::` and still get a valid, identical path?\n-    fn can_start_with_std(&self) -> bool {\n-        let first_segment = self.segments().first();\n-        first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n-    }\n-}\n-\n-fn check_self_super(def_map: &DefMap, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    if item == ItemInNs::Types(from.into()) {\n-        // - if the item is the module we're in, use `self`\n-        Some(ModPath::from_segments(PathKind::Super(0), None))\n-    } else if let Some(parent_id) = def_map[from.local_id].parent {\n-        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n-        let parent_id = def_map.module_id(parent_id);\n-        if item == ItemInNs::Types(ModuleDefId::ModuleId(parent_id)) {\n-            Some(ModPath::from_segments(PathKind::Super(1), None))\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum PrefixKind {\n     /// Causes paths to always start with either `self`, `super`, `crate` or a crate-name.\n@@ -100,149 +66,247 @@ impl PrefixKind {\n         self == &PrefixKind::ByCrate\n     }\n }\n+\n /// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId\n fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     prefixed: Option<PrefixKind>,\n-    prefer_core: bool,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n-    // FIXME: Do fast path for std/core libs?\n+    // - if the item is a builtin, it's in scope\n+    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n+        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n+    }\n \n-    let mut visited_modules = FxHashSet::default();\n     let def_map = from.def_map(db);\n-    find_path_inner_(\n+    let crate_root = def_map.crate_root(db);\n+    // - if the item is a module, jump straight to module search\n+    if let ItemInNs::Types(ModuleDefId::ModuleId(module_id)) = item {\n+        let mut visited_modules = FxHashSet::default();\n+        return find_path_for_module(\n+            db,\n+            &def_map,\n+            &mut visited_modules,\n+            crate_root,\n+            from,\n+            module_id,\n+            MAX_PATH_LEN,\n+            prefixed,\n+            prefer_no_std || db.crate_supports_no_std(crate_root.krate),\n+        );\n+    }\n+\n+    // - if the item is already in scope, return the name under which it is\n+    let scope_name = find_in_scope(db, &def_map, from, item);\n+    if prefixed.is_none() {\n+        if let Some(scope_name) = scope_name {\n+            return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n+        }\n+    }\n+\n+    // - if the item is in the prelude, return the name from there\n+    if let Some(value) = find_in_prelude(db, &crate_root.def_map(db), item, from) {\n+        return value;\n+    }\n+\n+    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n+        // - if the item is an enum variant, refer to it via the enum\n+        if let Some(mut path) = find_path_inner(\n+            db,\n+            ItemInNs::Types(variant.parent.into()),\n+            from,\n+            prefixed,\n+            prefer_no_std,\n+        ) {\n+            let data = db.enum_data(variant.parent);\n+            path.push_segment(data.variants[variant.local_id].name.clone());\n+            return Some(path);\n+        }\n+        // If this doesn't work, it seems we have no way of referring to the\n+        // enum; that's very weird, but there might still be a reexport of the\n+        // variant somewhere\n+    }\n+\n+    let mut visited_modules = FxHashSet::default();\n+\n+    calculate_best_path(\n         db,\n         &def_map,\n-        from,\n-        item,\n+        &mut visited_modules,\n+        crate_root,\n         MAX_PATH_LEN,\n+        item,\n+        from,\n         prefixed,\n-        &mut visited_modules,\n-        prefer_core,\n+        prefer_no_std || db.crate_supports_no_std(crate_root.krate),\n+        scope_name,\n     )\n }\n \n-fn find_path_inner_(\n+fn find_path_for_module(\n     db: &dyn DefDatabase,\n     def_map: &DefMap,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+    crate_root: ModuleId,\n     from: ModuleId,\n-    item: ItemInNs,\n+    module_id: ModuleId,\n     max_len: usize,\n-    mut prefixed: Option<PrefixKind>,\n-    visited_modules: &mut FxHashSet<ModuleId>,\n-    prefer_core: bool,\n+    prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     if max_len == 0 {\n         return None;\n     }\n \n     // Base cases:\n-\n     // - if the item is already in scope, return the name under which it is\n-    let scope_name = def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n-    });\n+    let scope_name = find_in_scope(db, def_map, from, ItemInNs::Types(module_id.into()));\n     if prefixed.is_none() {\n         if let Some(scope_name) = scope_name {\n             return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n         }\n     }\n \n-    // - if the item is a builtin, it's in scope\n-    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n-        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n-    }\n-\n     // - if the item is the crate root, return `crate`\n-    let crate_root = def_map.crate_root(db);\n-    if item == ItemInNs::Types(ModuleDefId::ModuleId(crate_root)) {\n+    if module_id == crate_root {\n         return Some(ModPath::from_segments(PathKind::Crate, None));\n     }\n \n+    // - if relative paths are fine, check if we are searching for a parent\n     if prefixed.filter(PrefixKind::is_absolute).is_none() {\n-        if let modpath @ Some(_) = check_self_super(&def_map, item, from) {\n+        if let modpath @ Some(_) = find_self_super(&def_map, module_id, from) {\n             return modpath;\n         }\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     let root_def_map = crate_root.def_map(db);\n-    if let ItemInNs::Types(ModuleDefId::ModuleId(item)) = item {\n-        for (name, &def_id) in root_def_map.extern_prelude() {\n-            if item == def_id {\n-                let name = scope_name.unwrap_or_else(|| name.clone());\n-\n-                let name_already_occupied_in_type_ns = def_map\n-                    .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-                        def_map[local_id]\n-                            .scope\n-                            .type_(&name)\n-                            .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n-                    })\n-                    .is_some();\n-                let kind = if name_already_occupied_in_type_ns {\n-                    cov_mark::hit!(ambiguous_crate_start);\n-                    PathKind::Abs\n-                } else {\n-                    PathKind::Plain\n-                };\n-                return Some(ModPath::from_segments(kind, Some(name)));\n-            }\n+    for (name, &def_id) in root_def_map.extern_prelude() {\n+        if module_id == def_id {\n+            let name = scope_name.unwrap_or_else(|| name.clone());\n+\n+            let name_already_occupied_in_type_ns = def_map\n+                .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+                    def_map[local_id]\n+                        .scope\n+                        .type_(&name)\n+                        .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n+                })\n+                .is_some();\n+            let kind = if name_already_occupied_in_type_ns {\n+                cov_mark::hit!(ambiguous_crate_start);\n+                PathKind::Abs\n+            } else {\n+                PathKind::Plain\n+            };\n+            return Some(ModPath::from_segments(kind, Some(name)));\n         }\n     }\n \n-    // - if the item is in the prelude, return the name from there\n+    if let Some(value) = find_in_prelude(db, &root_def_map, ItemInNs::Types(module_id.into()), from)\n+    {\n+        return value;\n+    }\n+    calculate_best_path(\n+        db,\n+        def_map,\n+        visited_modules,\n+        crate_root,\n+        max_len,\n+        ItemInNs::Types(module_id.into()),\n+        from,\n+        prefixed,\n+        prefer_no_std,\n+        scope_name,\n+    )\n+}\n+\n+fn find_in_scope(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    from: ModuleId,\n+    item: ItemInNs,\n+) -> Option<Name> {\n+    def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n+    })\n+}\n+\n+fn find_in_prelude(\n+    db: &dyn DefDatabase,\n+    root_def_map: &DefMap,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Option<Option<ModPath>> {\n     if let Some(prelude_module) = root_def_map.prelude() {\n         // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n         let prelude_def_map = prelude_module.def_map(db);\n         let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n             if vis.is_visible_from(db, from) {\n-                return Some(ModPath::from_segments(PathKind::Plain, Some(name.clone())));\n+                return Some(Some(ModPath::from_segments(PathKind::Plain, Some(name.clone()))));\n             }\n         }\n     }\n+    None\n+}\n \n-    // Recursive case:\n-    // - if the item is an enum variant, refer to it via the enum\n-    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n-        if let Some(mut path) =\n-            find_path(db, ItemInNs::Types(variant.parent.into()), from, prefer_core)\n-        {\n-            let data = db.enum_data(variant.parent);\n-            path.push_segment(data.variants[variant.local_id].name.clone());\n-            return Some(path);\n+fn find_self_super(def_map: &DefMap, item: ModuleId, from: ModuleId) -> Option<ModPath> {\n+    if item == from {\n+        // - if the item is the module we're in, use `self`\n+        Some(ModPath::from_segments(PathKind::Super(0), None))\n+    } else if let Some(parent_id) = def_map[from.local_id].parent {\n+        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+        let parent_id = def_map.module_id(parent_id);\n+        if item == parent_id {\n+            Some(ModPath::from_segments(PathKind::Super(1), None))\n+        } else {\n+            None\n         }\n-        // If this doesn't work, it seems we have no way of referring to the\n-        // enum; that's very weird, but there might still be a reexport of the\n-        // variant somewhere\n+    } else {\n+        None\n     }\n+}\n \n-    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n-    let prefer_no_std = prefer_core || db.crate_supports_no_std(crate_root.krate);\n+fn calculate_best_path(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+    crate_root: ModuleId,\n+    max_len: usize,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    mut prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n+    scope_name: Option<Name>,\n+) -> Option<ModPath> {\n+    if max_len <= 1 {\n+        return None;\n+    }\n     let mut best_path = None;\n-    let mut best_path_len = max_len;\n-\n+    // Recursive case:\n+    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n     if item.krate(db) == Some(from.krate) {\n+        let mut best_path_len = max_len;\n         // Item was defined in the same crate that wants to import it. It cannot be found in any\n         // dependency in this case.\n-        // FIXME: this should have a fast path that doesn't look through the prelude again?\n         for (module_id, name) in find_local_import_locations(db, item, from) {\n             if !visited_modules.insert(module_id) {\n                 cov_mark::hit!(recursive_imports);\n                 continue;\n             }\n-            if let Some(mut path) = find_path_inner_(\n+            if let Some(mut path) = find_path_for_module(\n                 db,\n                 def_map,\n+                visited_modules,\n+                crate_root,\n                 from,\n-                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                module_id,\n                 best_path_len - 1,\n                 prefixed,\n-                visited_modules,\n-                prefer_core,\n+                prefer_no_std,\n             ) {\n                 path.push_segment(name);\n \n@@ -265,15 +329,16 @@ fn find_path_inner_(\n             import_map.import_info_for(item).and_then(|info| {\n                 // Determine best path for containing module and append last segment from `info`.\n                 // FIXME: we should guide this to look up the path locally, or from the same crate again?\n-                let mut path = find_path_inner_(\n+                let mut path = find_path_for_module(\n                     db,\n                     def_map,\n+                    visited_modules,\n                     from,\n-                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n-                    best_path_len - 1,\n+                    crate_root,\n+                    info.container,\n+                    max_len - 1,\n                     prefixed,\n-                    visited_modules,\n-                    prefer_core,\n+                    prefer_no_std,\n                 )?;\n                 cov_mark::hit!(partially_imported);\n                 path.push_segment(info.path.segments.last()?.clone());\n@@ -289,16 +354,12 @@ fn find_path_inner_(\n             best_path = Some(new_path);\n         }\n     }\n-\n-    // If the item is declared inside a block expression, don't use a prefix, as we don't handle\n-    // that correctly (FIXME).\n-    if let Some(item_module) = item.as_module_def_id().and_then(|did| did.module(db)) {\n-        if item_module.def_map(db).block_id().is_some() && prefixed.is_some() {\n+    if let Some(module) = item.module(db) {\n+        if module.def_map(db).block_id().is_some() && prefixed.is_some() {\n             cov_mark::hit!(prefixed_in_block_expression);\n             prefixed = Some(PrefixKind::Plain);\n         }\n     }\n-\n     match prefixed.map(PrefixKind::prefix) {\n         Some(prefix) => best_path.or_else(|| {\n             scope_name.map(|scope_name| ModPath::from_segments(prefix, Some(scope_name)))\n@@ -308,29 +369,48 @@ fn find_path_inner_(\n }\n \n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n-    if old_path.starts_with_std() && new_path.can_start_with_std() {\n-        if prefer_no_std {\n-            cov_mark::hit!(prefer_no_std_paths);\n-            new_path\n-        } else {\n-            cov_mark::hit!(prefer_std_paths);\n-            old_path\n+    const STD_CRATES: [Name; 3] = [known::std, known::core, known::alloc];\n+    match (old_path.segments().first(), new_path.segments().first()) {\n+        (Some(old), Some(new)) if STD_CRATES.contains(old) && STD_CRATES.contains(new) => {\n+            let rank = match prefer_no_std {\n+                false => |name: &Name| match name {\n+                    name if name == &known::core => 0,\n+                    name if name == &known::alloc => 0,\n+                    name if name == &known::std => 1,\n+                    _ => unreachable!(),\n+                },\n+                true => |name: &Name| match name {\n+                    name if name == &known::core => 2,\n+                    name if name == &known::alloc => 1,\n+                    name if name == &known::std => 0,\n+                    _ => unreachable!(),\n+                },\n+            };\n+            let nrank = rank(new);\n+            let orank = rank(old);\n+            match nrank.cmp(&orank) {\n+                Ordering::Less => old_path,\n+                Ordering::Equal => {\n+                    if new_path.len() < old_path.len() {\n+                        new_path\n+                    } else {\n+                        old_path\n+                    }\n+                }\n+                Ordering::Greater => new_path,\n+            }\n         }\n-    } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n-        if prefer_no_std {\n-            cov_mark::hit!(prefer_no_std_paths);\n-            old_path\n-        } else {\n-            cov_mark::hit!(prefer_std_paths);\n-            new_path\n+        _ => {\n+            if new_path.len() < old_path.len() {\n+                new_path\n+            } else {\n+                old_path\n+            }\n         }\n-    } else if new_path.len() < old_path.len() {\n-        new_path\n-    } else {\n-        old_path\n     }\n }\n \n+// FIXME: Remove allocations\n /// Finds locations in `from.krate` from which `item` can be imported by `from`.\n fn find_local_import_locations(\n     db: &dyn DefDatabase,\n@@ -490,8 +570,8 @@ $0\n         \"#,\n             \"E::A\",\n             \"E::A\",\n-            \"E::A\",\n-            \"E::A\",\n+            \"crate::E::A\",\n+            \"self::E::A\",\n         );\n     }\n \n@@ -810,7 +890,6 @@ pub use super::foo;\n \n     #[test]\n     fn prefer_std_paths_over_alloc() {\n-        cov_mark::check!(prefer_std_paths);\n         check_found_path(\n             r#\"\n //- /main.rs crate:main deps:alloc,std\n@@ -835,7 +914,6 @@ pub mod sync {\n \n     #[test]\n     fn prefer_core_paths_over_std() {\n-        cov_mark::check!(prefer_no_std_paths);\n         check_found_path(\n             r#\"\n //- /main.rs crate:main deps:core,std"}, {"sha": "a40656fd6a42b128d8976fd793a8a497218aaf8c", "filename": "crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -457,8 +457,15 @@ impl ItemInNs {\n     /// Returns the crate defining this item (or `None` if `self` is built-in).\n     pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n         match self {\n-            ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate),\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => id.module(db).map(|m| m.krate),\n             ItemInNs::Macros(id) => Some(id.module(db).krate),\n         }\n     }\n+\n+    pub fn module(&self, db: &dyn DefDatabase) -> Option<ModuleId> {\n+        match self {\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => id.module(db),\n+            ItemInNs::Macros(id) => Some(id.module(db)),\n+        }\n+    }\n }"}, {"sha": "b5974a0cfc9642202a5975c28f5b325f89715a91", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -585,9 +585,9 @@ impl Module {\n         self,\n         db: &dyn DefDatabase,\n         item: impl Into<ItemInNs>,\n-        prefer_core: bool,\n+        prefer_no_std: bool,\n     ) -> Option<ModPath> {\n-        hir_def::find_path::find_path(db, item.into().into(), self.into(), prefer_core)\n+        hir_def::find_path::find_path(db, item.into().into(), self.into(), prefer_no_std)\n     }\n \n     /// Finds a path that can be used to refer to the given item from within\n@@ -597,14 +597,14 @@ impl Module {\n         db: &dyn DefDatabase,\n         item: impl Into<ItemInNs>,\n         prefix_kind: PrefixKind,\n-        prefer_core: bool,\n+        prefer_no_std: bool,\n     ) -> Option<ModPath> {\n         hir_def::find_path::find_path_prefixed(\n             db,\n             item.into().into(),\n             self.into(),\n             prefix_kind,\n-            prefer_core,\n+            prefer_no_std,\n         )\n     }\n }"}, {"sha": "60d1588a44e54dba41e753f2511ffd879ac64f73", "filename": "crates/ide-assists/src/assist_config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fassist_config.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -13,5 +13,5 @@ pub struct AssistConfig {\n     pub snippet_cap: Option<SnippetCap>,\n     pub allowed: Option<Vec<AssistKind>>,\n     pub insert_use: InsertUseConfig,\n-    pub prefer_core: bool,\n+    pub prefer_no_std: bool,\n }"}, {"sha": "73f4db4e5ff2ba065a20ee39c7aa368ff91f754e", "filename": "crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -87,7 +87,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n             .into_iter()\n             .filter_map(|variant| {\n                 Some((\n-                    build_pat(ctx.db(), module, variant, ctx.config.prefer_core)?,\n+                    build_pat(ctx.db(), module, variant, ctx.config.prefer_no_std)?,\n                     variant.should_be_hidden(ctx.db(), module.krate()),\n                 ))\n             })\n@@ -133,7 +133,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n                     .iter()\n                     .any(|variant| variant.should_be_hidden(ctx.db(), module.krate()));\n                 let patterns = variants.into_iter().filter_map(|variant| {\n-                    build_pat(ctx.db(), module, variant, ctx.config.prefer_core)\n+                    build_pat(ctx.db(), module, variant, ctx.config.prefer_no_std)\n                 });\n \n                 (ast::Pat::from(make::tuple_pat(patterns)), is_hidden)\n@@ -354,12 +354,12 @@ fn build_pat(\n     db: &RootDatabase,\n     module: hir::Module,\n     var: ExtendedVariant,\n-    prefer_core: bool,\n+    prefer_no_std: bool,\n ) -> Option<ast::Pat> {\n     match var {\n         ExtendedVariant::Variant(var) => {\n             let path =\n-                mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var), prefer_core)?);\n+                mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var), prefer_no_std)?);\n \n             // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n             let pat: ast::Pat = match var.source(db)?.value.kind() {"}, {"sha": "e257218ba937686275d3c8f78f998d0f49e4d073", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<\n     let mut proposed_imports = import_assets.search_for_imports(\n         &ctx.sema,\n         ctx.config.insert_use.prefix_kind,\n-        ctx.config.prefer_core,\n+        ctx.config.prefer_no_std,\n     );\n     if proposed_imports.is_empty() {\n         return None;"}, {"sha": "95d11abe8bc0f6fea075297b0c1473e81ec7a77b", "filename": "crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -\n             _ => return None,\n         };\n \n-        mod_path_to_ast(&module.find_use_path(ctx.db(), src_type_def, ctx.config.prefer_core)?)\n+        mod_path_to_ast(&module.find_use_path(ctx.db(), src_type_def, ctx.config.prefer_no_std)?)\n     };\n \n     let dest_type = match &ast_trait {"}, {"sha": "d6c8ea785f84aa87f1b2904e06ddcdab103eafc1", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -152,7 +152,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                         ctx.sema.db,\n                         ModuleDef::from(control_flow_enum),\n                         ctx.config.insert_use.prefix_kind,\n-                        ctx.config.prefer_core,\n+                        ctx.config.prefer_no_std,\n                     );\n \n                     if let Some(mod_path) = mod_path {"}, {"sha": "8d5cab283d0616d3297e864a782f61e4965975cd", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -409,7 +409,7 @@ fn process_references(\n                     ctx.sema.db,\n                     *enum_module_def,\n                     ctx.config.insert_use.prefix_kind,\n-                    ctx.config.prefer_core,\n+                    ctx.config.prefer_no_std,\n                 );\n                 if let Some(mut mod_path) = mod_path {\n                     mod_path.pop_segment();"}, {"sha": "8f4405a8c869cf9273e481775f98bff95e63a24b", "filename": "crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -59,7 +59,7 @@ fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());\n     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;\n     let trait_path =\n-        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_core)?;\n+        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_no_std)?;\n \n     let field_type = field.ty()?;\n     let field_name = field.name()?;\n@@ -100,7 +100,7 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());\n     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;\n     let trait_path =\n-        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_core)?;\n+        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_no_std)?;\n \n     let field_type = field.ty()?;\n     let target = field.syntax().text_range();"}, {"sha": "9cda74d9e0d31e4c41c65ed99b396d1cec982545", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -63,7 +63,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n                 let type_path = current_module.find_use_path(\n                     ctx.sema.db,\n                     item_for_path_search(ctx.sema.db, item_in_ns)?,\n-                    ctx.config.prefer_core,\n+                    ctx.config.prefer_no_std,\n                 )?;\n \n                 let expr = use_trivial_constructor("}, {"sha": "e57d1d065d6229361ca68604e8ace6c8b9331c1d", "filename": "crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -47,7 +47,7 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n     let receiver_path = current_module.find_use_path(\n         ctx.sema.db,\n         item_for_path_search(ctx.sema.db, item_in_ns)?,\n-        ctx.config.prefer_core,\n+        ctx.config.prefer_no_std,\n     )?;\n \n     let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);"}, {"sha": "4b2af550bc5e4902c15bdf4a158ba6ee0bef6326", "filename": "crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -38,7 +38,7 @@ use crate::{\n pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n     let mut proposed_imports =\n-        import_assets.search_for_relative_paths(&ctx.sema, ctx.config.prefer_core);\n+        import_assets.search_for_relative_paths(&ctx.sema, ctx.config.prefer_no_std);\n     if proposed_imports.is_empty() {\n         return None;\n     }"}, {"sha": "9fd5e1886d206ef3dad043c6e29f2a4eb88b1219", "filename": "crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -85,7 +85,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n     })\n     .flat_map(|trait_| {\n         current_module\n-            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_), ctx.config.prefer_core)\n+            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_), ctx.config.prefer_no_std)\n             .as_ref()\n             .map(mod_path_to_ast)\n             .zip(Some(trait_))"}, {"sha": "dbbc56958f1e2ede4419e6887073c662bdc9f40e", "filename": "crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -67,7 +67,7 @@ pub(crate) fn replace_qualified_name_with_use(\n                 ctx.sema.db,\n                 module,\n                 ctx.config.insert_use.prefix_kind,\n-                ctx.config.prefer_core,\n+                ctx.config.prefer_no_std,\n             )\n         })\n         .flatten();"}, {"sha": "258144bae3d08dfad368fa824804d9c4f3128674", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -29,7 +29,7 @@ pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n         group: true,\n         skip_glob_imports: true,\n     },\n-    prefer_core: false,\n+    prefer_no_std: false,\n };\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {"}, {"sha": "97b90c62dd7775b1073181148bb6ae5ea27826c9", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -551,9 +551,11 @@ fn enum_variants_with_paths(\n     }\n \n     for variant in variants {\n-        if let Some(path) =\n-            ctx.module.find_use_path(ctx.db, hir::ModuleDef::from(variant), ctx.config.prefer_core)\n-        {\n+        if let Some(path) = ctx.module.find_use_path(\n+            ctx.db,\n+            hir::ModuleDef::from(variant),\n+            ctx.config.prefer_no_std,\n+        ) {\n             // Variants with trivial paths are already added by the existing completion logic,\n             // so we should avoid adding these twice\n             if path.segments().len() > 1 {"}, {"sha": "3192b21cfb2e2da3ae3bd49b5e560c561fa58fd1", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -168,7 +168,7 @@ pub(crate) fn complete_expr_path(\n                             .find_use_path(\n                                 ctx.db,\n                                 hir::ModuleDef::from(strukt),\n-                                ctx.config.prefer_core,\n+                                ctx.config.prefer_no_std,\n                             )\n                             .filter(|it| it.len() > 1);\n \n@@ -187,7 +187,11 @@ pub(crate) fn complete_expr_path(\n                     hir::Adt::Union(un) => {\n                         let path = ctx\n                             .module\n-                            .find_use_path(ctx.db, hir::ModuleDef::from(un), ctx.config.prefer_core)\n+                            .find_use_path(\n+                                ctx.db,\n+                                hir::ModuleDef::from(un),\n+                                ctx.config.prefer_no_std,\n+                            )\n                             .filter(|it| it.len() > 1);\n \n                         acc.add_union_literal(ctx, un, path, None);"}, {"sha": "364969af9c9abc8aa6721d9ccbdfa1f515915251", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -265,7 +265,7 @@ fn import_on_the_fly(\n             .search_for_imports(\n                 &ctx.sema,\n                 ctx.config.insert_use.prefix_kind,\n-                ctx.config.prefer_core,\n+                ctx.config.prefer_no_std,\n             )\n             .into_iter()\n             .filter(ns_filter)\n@@ -313,7 +313,7 @@ fn import_on_the_fly_pat_(\n             .search_for_imports(\n                 &ctx.sema,\n                 ctx.config.insert_use.prefix_kind,\n-                ctx.config.prefer_core,\n+                ctx.config.prefer_no_std,\n             )\n             .into_iter()\n             .filter(ns_filter)\n@@ -352,7 +352,7 @@ fn import_on_the_fly_method(\n     let user_input_lowercased = potential_import_name.to_lowercase();\n \n     import_assets\n-        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind, ctx.config.prefer_core)\n+        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind, ctx.config.prefer_no_std)\n         .into_iter()\n         .filter(|import| {\n             !ctx.is_item_hidden(&import.item_to_import)"}, {"sha": "a0f5e81b4fb6c3396efd9d1ec7093e6402f43e85", "filename": "crates/ide-completion/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fconfig.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -17,7 +17,7 @@ pub struct CompletionConfig {\n     pub callable: Option<CallableSnippets>,\n     pub snippet_cap: Option<SnippetCap>,\n     pub insert_use: InsertUseConfig,\n-    pub prefer_core: bool,\n+    pub prefer_no_std: bool,\n     pub snippets: Vec<Snippet>,\n }\n "}, {"sha": "8d21f4fce0a2b324a3fc112c23ac2faef9560afa", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -238,7 +238,7 @@ pub fn resolve_completion_edits(\n                     db,\n                     candidate,\n                     config.insert_use.prefix_kind,\n-                    config.prefer_core,\n+                    config.prefer_no_std,\n                 )\n             })\n             .find(|mod_path| mod_path.to_string() == full_import_path);"}, {"sha": "f3b8eae4fe8cd8c25fff08afa889326e37da642e", "filename": "crates/ide-completion/src/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fsnippet.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -178,7 +178,7 @@ fn import_edits(ctx: &CompletionContext<'_>, requires: &[GreenNode]) -> Option<V\n             ctx.db,\n             item,\n             ctx.config.insert_use.prefix_kind,\n-            ctx.config.prefer_core,\n+            ctx.config.prefer_no_std,\n         )?;\n         Some((path.len() > 1).then(|| LocatedImport::new(path.clone(), item, item, None)))\n     };"}, {"sha": "9e2beb9ee328862289fd507f504a4e79767ec903", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -66,7 +66,7 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     enable_private_editable: false,\n     callable: Some(CallableSnippets::FillArguments),\n     snippet_cap: SnippetCap::new(true),\n-    prefer_core: false,\n+    prefer_no_std: false,\n     insert_use: InsertUseConfig {\n         granularity: ImportGranularity::Crate,\n         prefix_kind: PrefixKind::Plain,"}, {"sha": "40a6a3e8970fb770428c092b901ad23bc1bf7536", "filename": "crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -212,20 +212,20 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n         prefix_kind: PrefixKind,\n-        prefer_core: bool,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n-        self.search_for(sema, Some(prefix_kind), prefer_core)\n+        self.search_for(sema, Some(prefix_kind), prefer_no_std)\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n     pub fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n-        prefer_core: bool,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n-        self.search_for(sema, None, prefer_core)\n+        self.search_for(sema, None, prefer_no_std)\n     }\n \n     pub fn path_fuzzy_name_to_exact(&mut self, case_sensitive: bool) {\n@@ -244,7 +244,7 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n         prefixed: Option<PrefixKind>,\n-        prefer_core: bool,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for\");\n \n@@ -255,7 +255,7 @@ impl ImportAssets {\n                 item_for_path_search(sema.db, item)?,\n                 &self.module_with_candidate,\n                 prefixed,\n-                prefer_core,\n+                prefer_no_std,\n             )\n         };\n \n@@ -568,12 +568,12 @@ fn get_mod_path(\n     item_to_search: ItemInNs,\n     module_with_candidate: &Module,\n     prefixed: Option<PrefixKind>,\n-    prefer_core: bool,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     if let Some(prefix_kind) = prefixed {\n-        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind, prefer_core)\n+        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind, prefer_no_std)\n     } else {\n-        module_with_candidate.find_use_path(db, item_to_search, prefer_core)\n+        module_with_candidate.find_use_path(db, item_to_search, prefer_no_std)\n     }\n }\n "}, {"sha": "3034295196b42a32a26882259e2338facaa52cc6", "filename": "crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -137,7 +137,7 @@ pub(crate) fn json_in_items(\n                                         sema.db,\n                                         it,\n                                         config.insert_use.prefix_kind,\n-                                        config.prefer_core,\n+                                        config.prefer_no_std,\n                                     ) {\n                                         insert_use(\n                                             &scope,\n@@ -153,7 +153,7 @@ pub(crate) fn json_in_items(\n                                         sema.db,\n                                         it,\n                                         config.insert_use.prefix_kind,\n-                                        config.prefer_core,\n+                                        config.prefer_no_std,\n                                     ) {\n                                         insert_use(\n                                             &scope,"}, {"sha": "7f140eb6a74a6223dbdf26da59289184e1354e75", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -124,7 +124,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n                         let type_path = current_module?.find_use_path(\n                             ctx.sema.db,\n                             item_for_path_search(ctx.sema.db, item_in_ns)?,\n-                            ctx.config.prefer_core,\n+                            ctx.config.prefer_no_std,\n                         )?;\n \n                         use_trivial_constructor("}, {"sha": "ae299f0584148937c64b897e7cf658359a5c7069", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -150,7 +150,7 @@ pub struct DiagnosticsConfig {\n     pub expr_fill_default: ExprFillDefaultMode,\n     // FIXME: We may want to include a whole `AssistConfig` here\n     pub insert_use: InsertUseConfig,\n-    pub prefer_core: bool,\n+    pub prefer_no_std: bool,\n }\n \n impl DiagnosticsConfig {\n@@ -171,7 +171,7 @@ impl DiagnosticsConfig {\n                 group: false,\n                 skip_glob_imports: false,\n             },\n-            prefer_core: false,\n+            prefer_no_std: false,\n         }\n     }\n }"}, {"sha": "8504712c4bd5dd8580239cf6c0908be1d8e0da90", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -262,8 +262,8 @@ config_data! {\n         imports_group_enable: bool                           = \"true\",\n         /// Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n         imports_merge_glob: bool           = \"true\",\n-        /// Prefer to use imports of the core crate over the std crate.\n-        imports_prefer_core: bool                     = \"false\",\n+        /// Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\n+        imports_prefer_no_std: bool                     = \"false\",\n         /// The path structure for newly inserted paths to use.\n         imports_prefix: ImportPrefixDef               = \"\\\"plain\\\"\",\n \n@@ -922,7 +922,7 @@ impl Config {\n                 ExprFillDefaultDef::Default => ExprFillDefaultMode::Default,\n             },\n             insert_use: self.insert_use_config(),\n-            prefer_core: self.data.imports_prefer_core,\n+            prefer_no_std: self.data.imports_prefer_no_std,\n         }\n     }\n \n@@ -1138,7 +1138,7 @@ impl Config {\n                 CallableCompletionDef::None => None,\n             },\n             insert_use: self.insert_use_config(),\n-            prefer_core: self.data.imports_prefer_core,\n+            prefer_no_std: self.data.imports_prefer_no_std,\n             snippet_cap: SnippetCap::new(try_or_def!(\n                 self.caps\n                     .text_document\n@@ -1166,7 +1166,7 @@ impl Config {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n             insert_use: self.insert_use_config(),\n-            prefer_core: self.data.imports_prefer_core,\n+            prefer_no_std: self.data.imports_prefer_no_std,\n         }\n     }\n "}, {"sha": "96b1cb6b12713d5f0c666d8791cdb890a1d20e43", "filename": "crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -145,7 +145,7 @@ fn integrated_completion_benchmark() {\n                 skip_glob_imports: true,\n             },\n             snippets: Vec::new(),\n-            prefer_core: false,\n+            prefer_no_std: false,\n         };\n         let position =\n             FilePosition { file_id, offset: TextSize::try_from(completion_offset).unwrap() };\n@@ -183,7 +183,7 @@ fn integrated_completion_benchmark() {\n                 skip_glob_imports: true,\n             },\n             snippets: Vec::new(),\n-            prefer_core: false,\n+            prefer_no_std: false,\n         };\n         let position =\n             FilePosition { file_id, offset: TextSize::try_from(completion_offset).unwrap() };"}, {"sha": "e596e08f2cd3358bd21f170cd86e3f99c155b2b7", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -353,10 +353,10 @@ Group inserted imports by the https://rust-analyzer.github.io/manual.html#auto-i\n --\n Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n --\n-[[rust-analyzer.imports.prefer.core]]rust-analyzer.imports.prefer.core (default: `false`)::\n+[[rust-analyzer.imports.prefer.no.std]]rust-analyzer.imports.prefer.no.std (default: `false`)::\n +\n --\n-Prefer to use imports of the core crate over the std crate.\n+Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\n --\n [[rust-analyzer.imports.prefix]]rust-analyzer.imports.prefix (default: `\"plain\"`)::\n +"}, {"sha": "6aa74ce92afb963ed8493c78843e916b2fbda9f2", "filename": "editors/code/package.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ecaa19796e6d302f82b05f533ab99bd9522644/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/a8ecaa19796e6d302f82b05f533ab99bd9522644/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=a8ecaa19796e6d302f82b05f533ab99bd9522644", "patch": "@@ -798,8 +798,8 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n-                \"rust-analyzer.imports.prefer.core\": {\n-                    \"markdownDescription\": \"Prefer to use imports of the core crate over the std crate.\",\n+                \"rust-analyzer.imports.prefer.no.std\": {\n+                    \"markdownDescription\": \"Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\",\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },"}]}