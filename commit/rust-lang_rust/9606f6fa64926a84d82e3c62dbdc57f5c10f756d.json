{"sha": "9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MDZmNmZhNjQ5MjZhODRkODJlM2M2MmRiZGM1N2Y1YzEwZjc1NmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-14T16:20:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-14T16:20:35Z"}, "message": "Auto merge of #61817 - eddyb:begone-gcx-attempt-2, r=oli-obk\n\nUnify all uses of 'gcx and 'tcx.\n\nThis is made possible by @Zoxc landing #57214 (see https://github.com/rust-lang/rust/pull/57214#issuecomment-465036053 for the decision).\n\nA bit of context for the approach: just like #61722, this is *not* how I originally intended to go about this, but @Zoxc and my own experimentation independently resulted in the same conclusion:\nThe interim alias `type TyCx<'tcx> = TyCtxt<'tcx, 'tcx>;` attempt required more work (adding `use`s), even only for handling the `TyCtxt<'tcx, 'tcx>` case and not the general `TyCtxt<'gcx, 'tcx>` one.\n\nWhat this PR is based on is the realization that `'gcx` is a special-enough name that it can be replaced, without caring for context, with `'tcx`, and then repetitions of the name `'tcx` be compacted away.\nAfter that, only a small number of error categories remained, each category easily dealt with with either more mass replacements (e.g. `TyCtxt<'tcx, '_>` -> `TyCtxt<'tcx>`) or by hand.\n\nFor the `rustfmt` commit, I used https://github.com/rust-lang/rustfmt/issues/1324#issuecomment-482109952, and manually filtered out some noise, like in #61735 and #61722, and like the latter, there was also a weird bug to work around.\nIt should be reviewed separately, and dropped if unwanted (in this PR it's pretty significant).\n\ncc @rust-lang/compiler r? @nikomatsakis", "tree": {"sha": "3924fbb3a1d240971e05cd150d387462e4201408", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3924fbb3a1d240971e05cd150d387462e4201408"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "html_url": "https://github.com/rust-lang/rust/commit/9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc550d4295a654f9e7c621d957d81fbf1426c70b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc550d4295a654f9e7c621d957d81fbf1426c70b", "html_url": "https://github.com/rust-lang/rust/commit/fc550d4295a654f9e7c621d957d81fbf1426c70b"}, {"sha": "afc39bbf2447844569e872468f9440d430b81a46", "url": "https://api.github.com/repos/rust-lang/rust/commits/afc39bbf2447844569e872468f9440d430b81a46", "html_url": "https://github.com/rust-lang/rust/commit/afc39bbf2447844569e872468f9440d430b81a46"}], "stats": {"total": 7818, "additions": 3627, "deletions": 4191}, "files": [{"sha": "139c144fbcf4e20db63fc9ccaba07fc7a7d2661a", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -8,7 +8,7 @@ use crate::hir::{self, PatKind};\n use crate::hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     owner_def_id: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     graph: CFGGraph,\n@@ -30,7 +30,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break`\n }\n \n-pub fn construct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &hir::Body) -> CFG {\n+pub fn construct<'tcx>(tcx: TyCtxt<'tcx>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n "}, {"sha": "dbc462ee49b37e43761d39c0f27ae84309220264", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,7 +12,7 @@ pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n pub struct LabelledCFG<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges"}, {"sha": "db168d99a08016cad54d0f750ef25d360dc9b520", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -49,7 +49,7 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &hir::Body) -> CFG {\n+    pub fn new<'tcx>(tcx: TyCtxt<'tcx>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n "}, {"sha": "f7647167a7578292dafaf537d12a06332c6efac4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -204,10 +204,10 @@ macro_rules! define_dep_nodes {\n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n             #[inline(always)]\n-            pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                       dep: DepConstructor<'gcx>)\n+            pub fn new<'a, 'tcx>(tcx: TyCtxt<'tcx>,\n+                                       dep: DepConstructor<'tcx>)\n                                        -> DepNode\n-                where 'gcx: 'a + 'tcx,\n+                where 'tcx: 'a,\n                       'tcx: 'a\n             {\n                 match dep {\n@@ -307,7 +307,7 @@ macro_rules! define_dep_nodes {\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n             #[inline]\n-            pub fn extract_def_id(&self, tcx: TyCtxt<'_, '_>) -> Option<DefId> {\n+            pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n                     tcx.def_path_hash_to_def_id.as_ref()?\n@@ -400,7 +400,7 @@ impl DefPathHash {\n \n impl DefId {\n     #[inline(always)]\n-    pub fn to_dep_node(self, tcx: TyCtxt<'_, '_>, kind: DepKind) -> DepNode {\n+    pub fn to_dep_node(self, tcx: TyCtxt<'_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }\n }\n@@ -442,50 +442,50 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n ]);\n \n pub trait RecoverKey<'tcx>: Sized {\n-    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self>;\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n }\n \n impl RecoverKey<'tcx> for CrateNum {\n-    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.krate)\n     }\n }\n \n impl RecoverKey<'tcx> for DefId {\n-    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx)\n     }\n }\n \n impl RecoverKey<'tcx> for DefIndex {\n-    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.index)\n     }\n }\n \n-trait DepNodeParams<'gcx: 'tcx, 'tcx>: fmt::Debug {\n+trait DepNodeParams<'tcx>: fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'gcx, 'tcx>) -> Fingerprint {\n+    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: TyCtxt<'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, T> DepNodeParams<'gcx, 'tcx> for T\n+impl<'tcx, T> DepNodeParams<'tcx> for T\n where\n     T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n-    default fn to_fingerprint(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n \n@@ -494,58 +494,58 @@ where\n         hasher.finish()\n     }\n \n-    default fn to_debug_str(&self, _: TyCtxt<'gcx, 'tcx>) -> String {\n+    default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for DefId {\n+impl<'tcx> DepNodeParams<'tcx> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for DefIndex {\n+impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n         tcx.hir().definitions().def_path_hash(*self).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(DefId::local(*self))\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for CrateNum {\n+impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n         let def_id = DefId {\n             krate: *self,\n             index: CRATE_DEF_INDEX,\n         };\n         tcx.def_path_hash(def_id).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.crate_name(*self).as_str().to_string()\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for (DefId, DefId) {\n+impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n         let (def_id_0, def_id_1) = *self;\n \n         let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n@@ -554,7 +554,7 @@ impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for (DefId, DefId) {\n         def_path_hash_0.0.combine(def_path_hash_1.0)\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         let (def_id_0, def_id_1) = *self;\n \n         format!(\"({}, {})\",\n@@ -563,13 +563,13 @@ impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for (DefId, DefId) {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for HirId {\n+impl<'tcx> DepNodeParams<'tcx> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n         let HirId {\n             owner,\n             local_id,"}, {"sha": "c2e3c12cea8ed2f8d28e44de5e4605c2a7b69612", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -557,7 +557,7 @@ impl DepGraph {\n     /// a node index can be found for that node.\n     pub fn try_mark_green_and_read(\n         &self,\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         dep_node: &DepNode,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n@@ -569,7 +569,7 @@ impl DepGraph {\n \n     pub fn try_mark_green(\n         &self,\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         dep_node: &DepNode,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!dep_node.kind.is_eval_always());\n@@ -603,7 +603,7 @@ impl DepGraph {\n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<'tcx>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         data: &DepGraphData,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode,\n@@ -790,7 +790,7 @@ impl DepGraph {\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         data: &DepGraphData,\n         dep_node_index: DepNodeIndex,\n         did_allocation: bool,\n@@ -841,7 +841,7 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) {\n+    pub fn exec_cache_promotions<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n             data.colors.values.indices().filter_map(|prev_index| {"}, {"sha": "e5eda14cdbe61e5b083baf01aaff9526c1b8b9b4", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -33,7 +33,7 @@ impl DepGraphSafe for DefId {\n \n /// The type context itself can be used to access all kinds of tracked\n /// state, but those accesses should always generate read events.\n-impl<'gcx, 'tcx> DepGraphSafe for TyCtxt<'gcx, 'tcx> {}\n+impl<'tcx> DepGraphSafe for TyCtxt<'tcx> {}\n \n /// Tuples make it easy to build up state.\n impl<A, B> DepGraphSafe for (A, B)"}, {"sha": "4b84d56858cca6afbfa1cf0f759c2b7a1ff1ca39", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -88,7 +88,7 @@ impl Target {\n }\n \n struct CheckAttrVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl CheckAttrVisitor<'tcx> {\n@@ -347,7 +347,7 @@ fn is_c_like_enum(item: &hir::Item) -> bool {\n     }\n }\n \n-fn check_mod_attrs<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_attrs<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CheckAttrVisitor { tcx }.as_deep_visitor()"}, {"sha": "debed38361a1453371546f962f022a6cfc6fef42", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -177,7 +177,7 @@ impl DefId {\n         LocalDefId::from_def_id(self)\n     }\n \n-    pub fn describe_as_module(&self, tcx: TyCtxt<'_, '_>) -> String {\n+    pub fn describe_as_module(&self, tcx: TyCtxt<'_>) -> String {\n         if self.is_local() && self.index == CRATE_DEF_INDEX {\n             format!(\"top-level module\")\n         } else {"}, {"sha": "5a548ce8d9ff4f4543d0e9c98073a103421f273e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -415,8 +415,8 @@ impl<'a> LoweringContext<'a> {\n         /// needed from arbitrary locations in the crate,\n         /// e.g., the number of lifetime generic parameters\n         /// declared for every type and trait definition.\n-        struct MiscCollector<'lcx, 'interner: 'lcx> {\n-            lctx: &'lcx mut LoweringContext<'interner>,\n+        struct MiscCollector<'tcx, 'interner: 'tcx> {\n+            lctx: &'tcx mut LoweringContext<'interner>,\n             hir_id_owner: Option<NodeId>,\n         }\n \n@@ -460,8 +460,8 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n-            fn visit_pat(&mut self, p: &'lcx Pat) {\n+        impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n+            fn visit_pat(&mut self, p: &'tcx Pat) {\n                 match p.node {\n                     // Doesn't generate a HIR node\n                     PatKind::Paren(..) => {},\n@@ -475,7 +475,7 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n-            fn visit_item(&mut self, item: &'lcx Item) {\n+            fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n                 match item.node {\n@@ -507,7 +507,7 @@ impl<'a> LoweringContext<'a> {\n                 });\n             }\n \n-            fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n+            fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n \n                 match item.node {\n@@ -523,21 +523,21 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n \n-            fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n+            fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n                 self.with_hir_id_owner(Some(item.id), |this| {\n                     visit::walk_impl_item(this, item);\n                 });\n             }\n \n-            fn visit_foreign_item(&mut self, i: &'lcx ForeignItem) {\n+            fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n                 // Ignore patterns in foreign items\n                 self.with_hir_id_owner(None, |this| {\n                     visit::walk_foreign_item(this, i)\n                 });\n             }\n \n-            fn visit_ty(&mut self, t: &'lcx Ty) {\n+            fn visit_ty(&mut self, t: &'tcx Ty) {\n                 match t.node {\n                     // Mirrors the case in visit::walk_ty\n                     TyKind::BareFn(ref f) => {\n@@ -561,11 +561,11 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        struct ItemLowerer<'lcx, 'interner: 'lcx> {\n-            lctx: &'lcx mut LoweringContext<'interner>,\n+        struct ItemLowerer<'tcx, 'interner: 'tcx> {\n+            lctx: &'tcx mut LoweringContext<'interner>,\n         }\n \n-        impl<'lcx, 'interner> ItemLowerer<'lcx, 'interner> {\n+        impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n             fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n             where\n                 F: FnOnce(&mut Self),\n@@ -581,8 +581,8 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n-            fn visit_mod(&mut self, m: &'lcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n+        impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n+            fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n                 self.lctx.modules.insert(n, hir::ModuleItems {\n                     items: BTreeSet::new(),\n                     trait_items: BTreeSet::new(),\n@@ -595,7 +595,7 @@ impl<'a> LoweringContext<'a> {\n                 self.lctx.current_module = old;\n             }\n \n-            fn visit_item(&mut self, item: &'lcx Item) {\n+            fn visit_item(&mut self, item: &'tcx Item) {\n                 let mut item_hir_id = None;\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n                     if let Some(hir_item) = lctx.lower_item(item) {\n@@ -626,7 +626,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n \n-            fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n+            fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n                     let hir_item = lctx.lower_trait_item(item);\n                     let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n@@ -637,7 +637,7 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_trait_item(self, item);\n             }\n \n-            fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n+            fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n                     let hir_item = lctx.lower_impl_item(item);\n                     let id = hir::ImplItemId { hir_id: hir_item.hir_id };"}, {"sha": "1a4fe35c530bbc37c71ddbc3d0f6f8ecad25be41", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -55,7 +55,7 @@ impl Visitor<'tcx> for LocalCollector {\n }\n \n struct CaptureCollector<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     locals: &'a FxHashSet<HirId>,\n     upvars: FxIndexMap<HirId, hir::Upvar>,\n }"}, {"sha": "4ef4d70ee1dcdd7625459beee80a134bccd02f8a", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -61,12 +61,12 @@ pub enum NodeIdHashingMode {\n /// We could also just store a plain reference to the hir::Crate but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n-struct BodyResolver<'gcx>(&'gcx hir::Crate);\n+struct BodyResolver<'tcx>(&'tcx hir::Crate);\n \n-impl<'gcx> BodyResolver<'gcx> {\n+impl<'tcx> BodyResolver<'tcx> {\n     // Return a reference to the hir::Body with the given BodyId.\n     // DOES NOT DO ANY TRACKING, use carefully.\n-    fn body(self, id: hir::BodyId) -> &'gcx hir::Body {\n+    fn body(self, id: hir::BodyId) -> &'tcx hir::Body {\n         self.0.body(id)\n     }\n }\n@@ -205,8 +205,8 @@ for &'b mut T {\n     }\n }\n \n-impl StableHashingContextProvider<'lcx> for TyCtxt<'gcx, 'lcx> {\n-    fn get_stable_hashing_context(&self) -> StableHashingContext<'lcx> {\n+impl StableHashingContextProvider<'tcx> for TyCtxt<'tcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'tcx> {\n         (*self).create_stable_hashing_context()\n     }\n }"}, {"sha": "4f618457d6c6a9773c4bac251572c2a4c16ad136", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -506,12 +506,12 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n     (pos.0 - source_file_start.0, width as u32)\n }\n \n-\n-\n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for feature_gate::Features {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         // Unfortunately we cannot exhaustively list fields here, since the\n         // struct is macro generated.\n         self.declared_lang_features.hash_stable(hcx, hasher);"}, {"sha": "9b144b1ba3d2ade28403a903ad59c15be1276a54", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,9 +11,10 @@ use crate::middle::region;\n use crate::ty;\n use crate::mir;\n \n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-for &'gcx ty::List<T>\n-    where T: HashStable<StableHashingContext<'a>> {\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for &'tcx ty::List<T>\n+where\n+    T: HashStable<StableHashingContext<'a>>,\n+{\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -40,8 +41,9 @@ for &'gcx ty::List<T>\n     }\n }\n \n-impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::List<T>\n-    where T: HashStable<StableHashingContext<'a>>\n+impl<'a, 'tcx, T> ToStableHashKey<StableHashingContext<'a>> for &'tcx ty::List<T>\n+where\n+    T: HashStable<StableHashingContext<'a>>,\n {\n     type KeyType = Fingerprint;\n \n@@ -54,7 +56,7 @@ impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::List<T\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::subst::Kind<'gcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::Kind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -117,20 +119,24 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     }\n }\n \n-impl<'gcx, 'tcx> HashStable<StableHashingContext<'gcx>> for ty::ConstVid<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::ConstVid<'tcx> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.index.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundVar {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for ty::BoundVar {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.index().hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "0bb939889a89ab85fdd336765c43c035611d69f4", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -30,25 +30,25 @@ use super::*;\n use crate::ty::Const;\n use crate::ty::relate::{Relate, TypeRelation};\n \n-pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct At<'a, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    at: At<'a, 'gcx, 'tcx>,\n+pub struct Trace<'a, 'tcx: 'a> {\n+    at: At<'a, 'tcx>,\n     a_is_expected: bool,\n     trace: TypeTrace<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[inline]\n-    pub fn at(&'a self,\n-              cause: &'a ObligationCause<'tcx>,\n-              param_env: ty::ParamEnv<'tcx>)\n-              -> At<'a, 'gcx, 'tcx>\n-    {\n+    pub fn at(\n+        &'a self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> At<'a, 'tcx> {\n         At { infcx: self, cause, param_env }\n     }\n }\n@@ -61,7 +61,7 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n                 -> TypeTrace<'tcx>;\n }\n \n-impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> At<'a, 'tcx> {\n     /// Hacky routine for equating two impl headers in coherence.\n     pub fn eq_impl_headers(self,\n                            expected: &ty::ImplHeader<'tcx>,\n@@ -186,31 +186,26 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n     /// error-reporting, but doesn't actually perform any operation\n     /// yet (this is useful when you want to set the trace using\n     /// distinct values from those you wish to operate upon).\n-    pub fn trace<T>(self,\n-                    expected: T,\n-                    actual: T)\n-                    -> Trace<'a, 'gcx, 'tcx>\n-        where T: ToTrace<'tcx>\n+    pub fn trace<T>(self, expected: T, actual: T) -> Trace<'a, 'tcx>\n+    where\n+        T: ToTrace<'tcx>,\n     {\n         self.trace_exp(true, expected, actual)\n     }\n \n     /// Like `trace`, but the expected value is determined by the\n     /// boolean argument (if true, then the first argument `a` is the\n     /// \"expected\" value).\n-    pub fn trace_exp<T>(self,\n-                        a_is_expected: bool,\n-                        a: T,\n-                        b: T)\n-                        -> Trace<'a, 'gcx, 'tcx>\n-        where T: ToTrace<'tcx>\n+    pub fn trace_exp<T>(self, a_is_expected: bool, a: T, b: T) -> Trace<'a, 'tcx>\n+    where\n+        T: ToTrace<'tcx>,\n     {\n         let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n         Trace { at: self, trace: trace, a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n     /// Makes `expected <: actual`."}, {"sha": "b4779eec65f4c722f6fa59ab89dcc068f93fe377", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use smallvec::SmallVec;\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Canonicalizes a query value `V`. When we canonicalize a query,\n     /// we not only canonicalize unbound inference variables, but we\n     /// *also* replace all free regions whatsoever. So for example a\n@@ -41,9 +41,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         value: &V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'gcx, V>\n+    ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+        V: TypeFoldable<'tcx> + Lift<'tcx>,\n     {\n         self.tcx\n             .sess\n@@ -85,9 +85,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// out the [chapter in the rustc guide][c].\n     ///\n     /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(&self, value: &V) -> Canonicalized<'gcx, V>\n+    pub fn canonicalize_response<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+        V: TypeFoldable<'tcx> + Lift<'tcx>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -99,9 +99,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         )\n     }\n \n-    pub fn canonicalize_user_type_annotation<V>(&self, value: &V) -> Canonicalized<'gcx, V>\n+    pub fn canonicalize_user_type_annotation<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+        V: TypeFoldable<'tcx> + Lift<'tcx>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -130,9 +130,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         value: &V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'gcx, V>\n+    ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+        V: TypeFoldable<'tcx> + Lift<'tcx>,\n     {\n         self.tcx\n             .sess\n@@ -160,7 +160,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n trait CanonicalizeRegionMode {\n     fn canonicalize_free_region(\n         &self,\n-        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx>;\n \n@@ -172,7 +172,7 @@ struct CanonicalizeQueryResponse;\n impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n     fn canonicalize_free_region(\n         &self,\n-        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n@@ -221,7 +221,7 @@ struct CanonicalizeUserTypeAnnotation;\n impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n     fn canonicalize_free_region(\n         &self,\n-        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n@@ -244,7 +244,7 @@ struct CanonicalizeAllFreeRegions;\n impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n     fn canonicalize_free_region(\n         &self,\n-        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         canonicalizer.canonical_var_for_region_in_root_universe(r)\n@@ -260,7 +260,7 @@ struct CanonicalizeFreeRegionsOtherThanStatic;\n impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n     fn canonicalize_free_region(\n         &self,\n-        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         if let ty::ReStatic = r {\n@@ -275,9 +275,9 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n     }\n }\n \n-struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct Canonicalizer<'cx, 'tcx: 'cx> {\n+    infcx: Option<&'cx InferCtxt<'cx, 'tcx>>,\n+    tcx: TyCtxt<'tcx>,\n     variables: SmallVec<[CanonicalVarInfo; 8]>,\n     query_state: &'cx mut OriginalQueryValues<'tcx>,\n     // Note that indices is only used once `var_values` is big enough to be\n@@ -289,8 +289,8 @@ struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     binder_index: ty::DebruijnIndex,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -495,18 +495,18 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     /// The main `canonicalize` method, shared impl of\n     /// `canonicalize_query` and `canonicalize_response`.\n     fn canonicalize<V>(\n         value: &V,\n-        infcx: Option<&InferCtxt<'_, 'gcx, 'tcx>>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        infcx: Option<&InferCtxt<'_, 'tcx>>,\n+        tcx: TyCtxt<'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeRegionMode,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'gcx, V>\n+    ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+        V: TypeFoldable<'tcx> + Lift<'tcx>,\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::KEEP_IN_LOCAL_TCX |"}, {"sha": "8b1c34a487f5cbed83341da244939c6e4422b7da", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -44,15 +44,15 @@ mod substitute;\n /// variables have been rewritten to \"canonical vars\". These are\n /// numbered starting from 0 in order of first appearance.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub struct Canonical<'gcx, V> {\n+pub struct Canonical<'tcx, V> {\n     pub max_universe: ty::UniverseIndex,\n-    pub variables: CanonicalVarInfos<'gcx>,\n+    pub variables: CanonicalVarInfos<'tcx>,\n     pub value: V,\n }\n \n-pub type CanonicalVarInfos<'gcx> = &'gcx List<CanonicalVarInfo>;\n+pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n \n-impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n+impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n \n /// A set of values corresponding to the canonical variables from some\n /// `Canonical`. You can give these values to\n@@ -194,10 +194,10 @@ pub struct QueryResponse<'tcx, R> {\n     pub value: R,\n }\n \n-pub type Canonicalized<'gcx, V> = Canonical<'gcx, <V as Lift<'gcx>>::Lifted>;\n+pub type Canonicalized<'tcx, V> = Canonical<'tcx, <V as Lift<'tcx>>::Lifted>;\n \n-pub type CanonicalizedQueryResponse<'gcx, T> =\n-    &'gcx Canonical<'gcx, QueryResponse<'gcx, <T as Lift<'gcx>>::Lifted>>;\n+pub type CanonicalizedQueryResponse<'tcx, T> =\n+    &'tcx Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>;\n \n /// Indicates whether or not we were able to prove the query to be\n /// true.\n@@ -254,7 +254,7 @@ impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n     }\n }\n \n-impl<'gcx, V> Canonical<'gcx, V> {\n+impl<'tcx, V> Canonical<'tcx, V> {\n     /// Allows you to map the `value` of a canonical while keeping the\n     /// same set of bound variables.\n     ///\n@@ -278,7 +278,7 @@ impl<'gcx, V> Canonical<'gcx, V> {\n     /// let ty: Ty<'tcx> = ...;\n     /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n     /// ```\n-    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'gcx, W> {\n+    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'tcx, W> {\n         let Canonical {\n             max_universe,\n             variables,\n@@ -294,7 +294,7 @@ impl<'gcx, V> Canonical<'gcx, V> {\n \n pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n     /// inference variables and applies it to the canonical value.\n     /// Returns both the instantiated result *and* the substitution S.\n@@ -478,7 +478,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n     /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n     /// we'll return a substitution `subst` with:\n     /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n+    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n         use crate::ty::subst::UnpackedKind;\n \n         CanonicalVarValues {"}, {"sha": "8b11ebf9b924b7d5af7909c0295ed256355620b4", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -29,7 +29,7 @@ use crate::ty::subst::{Kind, UnpackedKind};\n use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n-impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n+impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n     /// canonical key `canonical_key`, this method will create a new\n     /// inference context, instantiate the key, and run your operation\n@@ -42,20 +42,19 @@ impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     ///\n     /// (It might be mildly nicer to implement this on `TyCtxt`, and\n     /// not `InferCtxtBuilder`, but that is a bit tricky right now.\n-    /// In part because we would need a `for<'gcx: 'tcx>` sort of\n+    /// In part because we would need a `for<'tcx>` sort of\n     /// bound for the closure and in part because it is convenient to\n     /// have `'tcx` be free on this function so that we can talk about\n     /// `K: TypeFoldable<'tcx>`.)\n     pub fn enter_canonical_trait_query<K, R>(\n-        &'tcx mut self,\n+        &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'gcx, 'tcx>, &mut dyn TraitEngine<'tcx>, K)\n-            -> Fallible<R>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, R>>\n+        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n-        R: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n-        Canonical<'gcx, <QueryResponse<'gcx, R> as Lift<'gcx>>::Lifted>: ArenaAllocatable,\n+        R: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n+        Canonical<'tcx, <QueryResponse<'tcx, R> as Lift<'tcx>>::Lifted>: ArenaAllocatable,\n     {\n         self.enter_with_canonical(\n             DUMMY_SP,\n@@ -73,7 +72,7 @@ impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This method is meant to be invoked as the final step of a canonical query\n     /// implementation. It is given:\n     ///\n@@ -98,10 +97,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, T>>\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n     where\n-        T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n-        Canonical<'gcx, <QueryResponse<'gcx, T> as Lift<'gcx>>::Lifted>: ArenaAllocatable,\n+        T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n+        Canonical<'tcx, <QueryResponse<'tcx, T> as Lift<'tcx>>::Lifted>: ArenaAllocatable,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n         let canonical_result = self.canonicalize_response(&query_response);\n@@ -126,10 +125,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn make_query_response_ignoring_pending_obligations<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n-        answer: T\n-    ) -> Canonical<'gcx, QueryResponse<'gcx, <T as Lift<'gcx>>::Lifted>>\n+        answer: T,\n+    ) -> Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>\n     where\n-        T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n+        T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n     {\n         self.canonicalize_response(&QueryResponse {\n             var_values: inference_vars,\n@@ -148,7 +147,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Result<QueryResponse<'tcx, T>, NoSolution>\n     where\n-        T: Debug + TypeFoldable<'tcx> + Lift<'gcx>,\n+        T: Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n     {\n         let tcx = self.tcx;\n \n@@ -567,7 +566,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'gcx> {\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints\n             .iter()\n             .map(move |constraint| {\n@@ -647,7 +646,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n /// Given the region obligations and constraints scraped from the infcx,\n /// creates query region constraints.\n pub fn make_query_outlives<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> Vec<QueryRegionConstraint<'tcx>> {"}, {"sha": "1234b96ab110c2f382e23ecfb83594eb397a3f2f", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ use crate::ty::{self, TyCtxt};\n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n-    pub fn substitute(&self, tcx: TyCtxt<'_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    pub fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -29,7 +29,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     /// V, replacing each of the canonical variables.\n     pub fn substitute_projected<T>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         var_values: &CanonicalVarValues<'tcx>,\n         projection_fn: impl FnOnce(&V) -> &T,\n     ) -> T\n@@ -46,7 +46,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n /// must be values for the set of canonical variables that appear in\n /// `value`.\n pub(super) fn substitute_value<'a, 'tcx, T>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     var_values: &CanonicalVarValues<'tcx>,\n     value: &'a T,\n ) -> T"}, {"sha": "23550569f7ccfc6a57146f5ea61886ce1dd92312", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -44,8 +44,8 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n-pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n-    pub infcx: &'infcx InferCtxt<'infcx, 'gcx, 'tcx>,\n+pub struct CombineFields<'infcx, 'tcx: 'infcx> {\n+    pub infcx: &'infcx InferCtxt<'infcx, 'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -57,15 +57,15 @@ pub enum RelationDir {\n     SubtypeOf, SupertypeOf, EqTo\n }\n \n-impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n+impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     pub fn super_combine_tys<R>(\n         &self,\n         relation: &mut R,\n         a: Ty<'tcx>,\n         b: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n-        R: TypeRelation<'gcx, 'tcx>,\n+        R: TypeRelation<'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -125,7 +125,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n     where\n-        R: TypeRelation<'gcx, 'tcx>,\n+        R: TypeRelation<'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -208,24 +208,24 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn equate<'a>(&'a mut self, a_is_expected: bool) -> Equate<'a, 'infcx, 'gcx, 'tcx> {\n+    pub fn equate<'a>(&'a mut self, a_is_expected: bool) -> Equate<'a, 'infcx, 'tcx> {\n         Equate::new(self, a_is_expected)\n     }\n \n-    pub fn sub<'a>(&'a mut self, a_is_expected: bool) -> Sub<'a, 'infcx, 'gcx, 'tcx> {\n+    pub fn sub<'a>(&'a mut self, a_is_expected: bool) -> Sub<'a, 'infcx, 'tcx> {\n         Sub::new(self, a_is_expected)\n     }\n \n-    pub fn lub<'a>(&'a mut self, a_is_expected: bool) -> Lub<'a, 'infcx, 'gcx, 'tcx> {\n+    pub fn lub<'a>(&'a mut self, a_is_expected: bool) -> Lub<'a, 'infcx, 'tcx> {\n         Lub::new(self, a_is_expected)\n     }\n \n-    pub fn glb<'a>(&'a mut self, a_is_expected: bool) -> Glb<'a, 'infcx, 'gcx, 'tcx> {\n+    pub fn glb<'a>(&'a mut self, a_is_expected: bool) -> Glb<'a, 'infcx, 'tcx> {\n         Glb::new(self, a_is_expected)\n     }\n \n@@ -355,8 +355,8 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct Generalizer<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n     /// The span, used when creating new type variables and things.\n     span: Span,\n@@ -415,8 +415,8 @@ struct Generalization<'tcx> {\n     needs_wf: bool,\n }\n \n-impl TypeRelation<'gcx, 'tcx> for Generalizer<'_, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "39d8241e6b4273b3b2226dd6dbc7580b8f4f2e27", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,23 +11,24 @@ use crate::mir::interpret::ConstValue;\n use crate::infer::unify_key::replace_if_possible;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n-pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+pub struct Equate<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> Equate<'combine, 'infcx, 'gcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n-        -> Equate<'combine, 'infcx, 'gcx, 'tcx>\n-    {\n+impl<'combine, 'infcx, 'tcx> Equate<'combine, 'infcx, 'tcx> {\n+    pub fn new(\n+        fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Equate<'combine, 'infcx, 'tcx> {\n         Equate { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl TypeRelation<'gcx, 'tcx> for Equate<'combine, 'infcx, 'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "04d29a8db1c35808b876eeaf2092b253fec2d8b0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -67,7 +67,7 @@ mod need_type_info;\n \n pub mod nice_region_error;\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn note_and_explain_region(\n         self,\n         region_scope_tree: &region::ScopeTree,\n@@ -282,7 +282,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n         region_scope_tree: &region::ScopeTree,\n@@ -445,13 +445,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::print::Printer;\n         use ty::subst::Kind;\n \n-        struct AbsolutePathPrinter<'gcx, 'tcx> {\n-            tcx: TyCtxt<'gcx, 'tcx>,\n+        struct AbsolutePathPrinter<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n         }\n \n         struct NonTrivialPath;\n \n-        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'gcx, 'tcx> {\n+        impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             type Error = NonTrivialPath;\n \n             type Path = Vec<String>;\n@@ -460,7 +460,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type DynExistential = !;\n             type Const = !;\n \n-            fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx> {\n+            fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n                 self.tcx\n             }\n \n@@ -1546,7 +1546,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn report_inference_failure(\n         &self,\n         var_origin: RegionVariableOrigin,"}, {"sha": "362a680f53c9a94771a2238d0648c36f8ec2fca3", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,16 +9,16 @@ use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n-struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct FindLocalByTypeVisitor<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     target_ty: Ty<'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    found_local_pattern: Option<&'gcx Pat>,\n-    found_arg_pattern: Option<&'gcx Pat>,\n+    hir_map: &'a hir::map::Map<'tcx>,\n+    found_local_pattern: Option<&'tcx Pat>,\n+    found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n     fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_type_opt(hir_id)\n@@ -47,20 +47,20 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.hir_map)\n     }\n \n-    fn visit_local(&mut self, local: &'gcx Local) {\n+    fn visit_local(&mut self, local: &'tcx Local) {\n         if let (None, Some(ty)) = (self.found_local_pattern, self.node_matches_type(local.hir_id)) {\n             self.found_local_pattern = Some(&*local.pat);\n             self.found_ty = Some(ty);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n-    fn visit_body(&mut self, body: &'gcx Body) {\n+    fn visit_body(&mut self, body: &'tcx Body) {\n         for argument in &body.arguments {\n             if let (None, Some(ty)) = (\n                 self.found_arg_pattern,\n@@ -74,8 +74,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-\n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn extract_type_name(\n         &self,\n         ty: Ty<'tcx>,\n@@ -102,8 +101,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n-        ty: Ty<'tcx>\n-    ) -> DiagnosticBuilder<'gcx> {\n+        ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n@@ -229,8 +228,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn need_type_info_err_in_generator(\n         &self,\n         span: Span,\n-        ty: Ty<'tcx>\n-    ) -> DiagnosticBuilder<'gcx> {\n+        ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n "}, {"sha": "6bd2c04d51281f751a2dc96473e8ea7155adb91a", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -5,7 +5,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n use crate::util::common::ErrorReported;\n \n-impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n     ///\n     /// Consider a case where we have"}, {"sha": "fa95ea1013253cf6433bd8affe87924e022af819", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -5,7 +5,7 @@ use crate::middle::resolve_lifetime as rl;\n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n \n-impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// This function calls the `visit_ty` method for the parameters\n     /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n     /// contains the anonymous type.\n@@ -60,9 +60,9 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     // to the anonymous region.\n     fn find_component_for_bound_region(\n         &self,\n-        arg: &'gcx hir::Ty,\n+        arg: &'tcx hir::Ty,\n         br: &ty::BoundRegion,\n-    ) -> Option<(&'gcx hir::Ty)> {\n+    ) -> Option<(&'tcx hir::Ty)> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n             tcx: self.tcx(),\n             bound_region: *br,\n@@ -81,23 +81,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n // walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n-struct FindNestedTypeVisitor<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct FindNestedTypeVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     // The bound_region corresponding to the Refree(freeregion)\n     // associated with the anonymous region we are looking for.\n     bound_region: ty::BoundRegion,\n     // The type where the anonymous lifetime appears\n     // for e.g., Vec<`&u8`> and <`&u8`>\n-    found_type: Option<&'gcx hir::Ty>,\n+    found_type: Option<&'tcx hir::Ty>,\n     current_index: ty::DebruijnIndex,\n }\n \n-impl Visitor<'gcx> for FindNestedTypeVisitor<'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n         match arg.node {\n             hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n@@ -208,15 +208,15 @@ impl Visitor<'gcx> for FindNestedTypeVisitor<'gcx, 'tcx> {\n // and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n-struct TyPathVisitor<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct TyPathVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     found_it: bool,\n     bound_region: ty::BoundRegion,\n     current_index: ty::DebruijnIndex,\n }\n \n-impl Visitor<'gcx> for TyPathVisitor<'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n@@ -267,7 +267,7 @@ impl Visitor<'gcx> for TyPathVisitor<'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n         // ignore nested types\n         //\n         // If you have a type like `Foo<'a, &Ty>` we"}, {"sha": "541d9a96dbe603f48f156d59a59fda6a130c595f", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ mod outlives_closure;\n mod static_impl_trait;\n mod util;\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n         match *error {\n             ConcreteFailure(..) | SubSupConflict(..) => {}\n@@ -30,24 +30,24 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct NiceRegionError<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+pub struct NiceRegionError<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,\n     tables: Option<&'cx ty::TypeckTables<'tcx>>,\n }\n \n-impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n     pub fn new(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n         error: RegionResolutionError<'tcx>,\n         tables: Option<&'cx ty::TypeckTables<'tcx>>,\n     ) -> Self {\n         Self { infcx, error: Some(error), regions: None, tables }\n     }\n \n     pub fn new_from_span(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n         span: Span,\n         sub: ty::Region<'tcx>,\n         sup: ty::Region<'tcx>,\n@@ -56,7 +56,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         Self { infcx, error: None, regions: Some((span, sub, sup)), tables }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "51bee49b70fc01d333e7315f5d9fca514f999f1f", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -5,7 +5,7 @@ use crate::hir::{FunctionRetTy, TyKind};\n use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n-impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {"}, {"sha": "0d98a024977d9c9399d857d27592f5c163eaab44", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use crate::hir::Node;\n use crate::util::common::ErrorReported;\n use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n-impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when binding escapes a closure.\n     ///\n     /// Consider a case where we have"}, {"sha": "b4fb018920647f916f7d4689bd02ecee211a875b", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -13,7 +13,7 @@ use crate::ty::print::{Print, RegionHighlightMode, FmtPrinter};\n \n use std::fmt::{self, Write};\n \n-impl NiceRegionError<'me, 'gcx, 'tcx> {\n+impl NiceRegionError<'me, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n     pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'me>> {\n@@ -321,14 +321,14 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n     ) {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n-        struct Highlighted<'gcx, 'tcx, T> {\n-            tcx: TyCtxt<'gcx, 'tcx>,\n+        struct Highlighted<'tcx, T> {\n+            tcx: TyCtxt<'tcx>,\n             highlight: RegionHighlightMode,\n             value: T,\n         }\n \n-        impl<'gcx, 'tcx, T> Highlighted<'gcx, 'tcx, T> {\n-            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'gcx, 'tcx, U> {\n+        impl<'tcx, T> Highlighted<'tcx, T> {\n+            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n                 Highlighted {\n                     tcx: self.tcx,\n                     highlight: self.highlight,\n@@ -337,12 +337,11 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'gcx, 'tcx, T> fmt::Display for Highlighted<'gcx, 'tcx, T>\n+        impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n         where\n             T: for<'a, 'b, 'c> Print<\n-                'gcx,\n                 'tcx,\n-                FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n+                FmtPrinter<'a, 'tcx, &'b mut fmt::Formatter<'c>>,\n                 Error = fmt::Error,\n             >,\n         {"}, {"sha": "9d405d4ea40c91476f54d2a1ed08f0e14fda9c4f", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,7 +6,7 @@ use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n use crate::util::common::ErrorReported;\n use errors::Applicability;\n \n-impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         if let Some(ref error) = self.error {"}, {"sha": "017f36b020988145c3a4979c1504136ff3278407", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -24,7 +24,7 @@ pub(super) struct AnonymousArgInfo<'tcx> {\n     pub is_first: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n     // &hir::Arg of the function argument corresponding to the anonymous"}, {"sha": "cc7c13cea7d925d605c2aea97a2154fbbd2c53eb", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -4,7 +4,7 @@ use crate::ty::{self, Region};\n use crate::ty::error::TypeError;\n use errors::DiagnosticBuilder;\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin(&self,\n                                      err: &mut DiagnosticBuilder<'_>,\n                                      origin: &SubregionOrigin<'tcx>) {"}, {"sha": "645f2b023380031aaff0aa6796c00a00be4136f1", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -41,17 +41,16 @@ use std::collections::hash_map::Entry;\n use super::InferCtxt;\n use super::unify_key::ToType;\n \n-pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct TypeFreshener<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     ty_freshen_count: u32,\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n     const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::Const<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n-               -> TypeFreshener<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,\n@@ -113,8 +112,8 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "59364862c649b51b7a56cfa5bf5ad9e456f52d4d", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,7 +22,7 @@ fn const_vars_since_snapshot<'tcx>(\n     }).collect())\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// This rather funky routine is used while processing expected\n     /// types. What happens here is that we want to propagate a\n     /// coercion through the return type of a fn to its\n@@ -133,17 +133,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct InferenceFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct InferenceFudger<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     type_vars: (Range<TyVid>, Vec<TypeVariableOrigin>),\n     int_vars: Range<IntVid>,\n     float_vars: Range<FloatVid>,\n     region_vars: (Range<RegionVid>, Vec<RegionVariableOrigin>),\n     const_vars: (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>),\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "7f184d3424f2f69d80e2ac584f07b5a0371507ea", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -8,23 +8,24 @@ use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+pub struct Glb<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> Glb<'combine, 'infcx, 'gcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n-        -> Glb<'combine, 'infcx, 'gcx, 'tcx>\n-    {\n+impl<'combine, 'infcx, 'tcx> Glb<'combine, 'infcx, 'tcx> {\n+    pub fn new(\n+        fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Glb<'combine, 'infcx, 'tcx> {\n         Glb { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl TypeRelation<'gcx, 'tcx> for Glb<'combine, 'infcx, 'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n@@ -85,10 +86,8 @@ impl TypeRelation<'gcx, 'tcx> for Glb<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n-    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n-{\n-    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx, 'tcx> {\n+    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "542ac4931ecfa47aa3a0a78498c215a1973fff4f", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n use crate::ty::{self, Binder, TypeFoldable};\n use crate::mir::interpret::ConstValue;\n \n-impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n         a: &Binder<T>,\n@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Replaces all regions (resp. types) bound by `binder` with placeholder\n     /// regions (resp. types) and return a map indicating which bound-region\n     /// placeholder region. This is the first step of checking subtyping"}, {"sha": "c7766636e04e0e5fbf2f3e7c1b4d9071d62ec886", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -27,8 +27,8 @@ use crate::ty::TyVar;\n use crate::ty::{self, Ty};\n use crate::ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f, 'gcx: 'f + 'tcx, 'tcx: 'f>: TypeRelation<'gcx, 'tcx> {\n-    fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n+pub trait LatticeDir<'f, 'tcx: 'f>: TypeRelation<'tcx> {\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n@@ -41,11 +41,14 @@ pub trait LatticeDir<'f, 'gcx: 'f + 'tcx, 'tcx: 'f>: TypeRelation<'gcx, 'tcx> {\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n-                                            a: Ty<'tcx>,\n-                                            b: Ty<'tcx>)\n-                                            -> RelateResult<'tcx, Ty<'tcx>>\n-    where L: LatticeDir<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn super_lattice_tys<'a, 'tcx, L>(\n+    this: &mut L,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+) -> RelateResult<'tcx, Ty<'tcx>>\n+where\n+    L: LatticeDir<'a, 'tcx>,\n+    'tcx: 'a,\n {\n     debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),"}, {"sha": "aa4bbcad6d5bc5468713d63809e629d71d9a6fb3", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -44,10 +44,10 @@ graphs will be printed.                                                     \\n\\\n \");\n }\n \n-pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n+pub fn maybe_print_constraints_for<'a, 'tcx>(\n     region_data: &RegionConstraintData<'tcx>,\n-    region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n-{\n+    region_rels: &RegionRelations<'a, 'tcx>,\n+) {\n     let tcx = region_rels.tcx;\n     let context = region_rels.context;\n \n@@ -107,9 +107,9 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n     }\n }\n \n-struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct ConstraintGraph<'a, 'tcx: 'a> {\n     graph_name: String,\n-    region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n+    region_rels: &'a RegionRelations<'a, 'tcx>,\n     map: &'a BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n     node_ids: FxHashMap<Node, usize>,\n }\n@@ -126,11 +126,12 @@ enum Edge<'tcx> {\n     EnclScope(region::Scope, region::Scope),\n }\n \n-impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n-    fn new(name: String,\n-           region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n-           map: &'a ConstraintMap<'tcx>)\n-           -> ConstraintGraph<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n+    fn new(\n+        name: String,\n+        region_rels: &'a RegionRelations<'a, 'tcx>,\n+        map: &'a ConstraintMap<'tcx>,\n+    ) -> ConstraintGraph<'a, 'tcx> {\n         let mut i = 0;\n         let mut node_ids = FxHashMap::default();\n         {\n@@ -161,7 +162,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n     type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id<'_> {\n@@ -215,7 +216,7 @@ fn edge_to_nodes(e: &Edge<'_>) -> (Node, Node) {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n     type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn nodes(&self) -> dot::Nodes<'_, Node> {\n@@ -246,10 +247,11 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n-fn dump_region_data_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                                       map: &ConstraintMap<'tcx>,\n-                                       path: &str)\n-                                       -> io::Result<()> {\n+fn dump_region_data_to<'a, 'tcx>(\n+    region_rels: &RegionRelations<'a, 'tcx>,\n+    map: &ConstraintMap<'tcx>,\n+    path: &str,\n+) -> io::Result<()> {\n     debug!(\"dump_region_data map (len: {}) path: {}\",\n            map.len(),\n            path);"}, {"sha": "16f5a9d3b36c4944be2937f8af2e3ad48946dc1c", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -30,13 +30,10 @@ mod graphviz;\n /// assuming such values can be found. It returns the final values of\n /// all the variables as well as a set of errors that must be reported.\n pub fn resolve<'tcx>(\n-    region_rels: &RegionRelations<'_, '_, 'tcx>,\n+    region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n-) -> (\n-    LexicalRegionResolutions<'tcx>,\n-    Vec<RegionResolutionError<'tcx>>,\n-) {\n+) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver {\n@@ -96,14 +93,14 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph<'tcx> = Graph<(), Constraint<'tcx>>;\n \n-struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n+struct LexicalResolver<'cx, 'tcx: 'cx> {\n+    region_rels: &'cx RegionRelations<'cx, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.region_rels.tcx\n     }\n \n@@ -136,14 +133,14 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n     /// Initially, the value for all variables is set to `'empty`, the\n     /// empty region. The `expansion` phase will grow this larger.\n-    fn construct_var_data(&self, tcx: TyCtxt<'_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n+    fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n             values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars())\n         }\n     }\n \n-    fn dump_constraints(&self, free_regions: &RegionRelations<'_, '_, 'tcx>) {\n+    fn dump_constraints(&self, free_regions: &RegionRelations<'_, 'tcx>) {\n         debug!(\n             \"----() Start constraint listing (context={:?}) ()----\",\n             free_regions.context\n@@ -785,7 +782,7 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n }\n \n impl<'tcx> LexicalRegionResolutions<'tcx> {\n-    fn normalize<T>(&self, tcx: TyCtxt<'_, 'tcx>, value: T) -> T\n+    fn normalize<T>(&self, tcx: TyCtxt<'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "2a9f5856eb8552d6b94fe2f7df268184faaa5c2a", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -8,23 +8,24 @@ use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+pub struct Lub<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> Lub<'combine, 'infcx, 'gcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n-        -> Lub<'combine, 'infcx, 'gcx, 'tcx>\n-    {\n+impl<'combine, 'infcx, 'tcx> Lub<'combine, 'infcx, 'tcx> {\n+    pub fn new(\n+        fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Lub<'combine, 'infcx, 'tcx> {\n         Lub { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl TypeRelation<'gcx, 'tcx> for Lub<'combine, 'infcx, 'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n@@ -85,10 +86,8 @@ impl TypeRelation<'gcx, 'tcx> for Lub<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n-    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n-{\n-    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx, 'tcx> {\n+    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "47a276b2bcc57ebc755557ca3bb62b8ac0613b4f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -91,7 +91,7 @@ impl SuppressRegionErrors {\n     /// Indicates that the MIR borrowck will repeat these region\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n-    pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_>) -> Self {\n+    pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n         match tcx.borrowck_mode() {\n             // If we're on Migrate mode, report AST region errors\n             BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n@@ -102,8 +102,8 @@ impl SuppressRegionErrors {\n     }\n }\n \n-pub struct InferCtxt<'a, 'gcx, 'tcx> {\n-    pub tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct InferCtxt<'a, 'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n \n     /// During type-checking/inference of a body, `in_progress_tables`\n     /// contains a reference to the tables being built up, which are\n@@ -464,22 +464,22 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n \n /// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n /// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)`.\n-pub struct InferCtxtBuilder<'gcx: 'tcx, 'tcx> {\n-    global_tcx: TyCtxt<'gcx, 'gcx>,\n+/// `F: for<'b, 'tcx> where 'tcx FnOnce(InferCtxt<'b, 'tcx>)`.\n+pub struct InferCtxtBuilder<'tcx> {\n+    global_tcx: TyCtxt<'tcx>,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n }\n \n-impl TyCtxt<'gcx, 'gcx> {\n-    pub fn infer_ctxt<'tcx>(self) -> InferCtxtBuilder<'gcx, 'tcx> {\n+impl TyCtxt<'tcx> {\n+    pub fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n             fresh_tables: None,\n         }\n     }\n }\n \n-impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n+impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n     pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n@@ -495,10 +495,10 @@ impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     /// the bound values in `C` to their instantiated values in `V`\n     /// (in other words, `S(C) = V`).\n     pub fn enter_with_canonical<T, R>(\n-        &'tcx mut self,\n+        &mut self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n-        f: impl for<'a> FnOnce(InferCtxt<'a, 'gcx, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n+        f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n     ) -> R\n     where\n         T: TypeFoldable<'tcx>,\n@@ -510,7 +510,7 @@ impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'gcx, 'tcx>) -> R) -> R {\n+    pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref fresh_tables,\n@@ -567,7 +567,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     /// Extracts `value`, registering any obligations into `fulfill_cx`.\n     pub fn into_value_registering_obligations(\n         self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> T {\n         let InferOk { value, obligations } = self;\n@@ -598,7 +598,7 @@ pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -614,7 +614,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'gcx, 'tcx> {\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n         freshen::TypeFreshener::new(self)\n     }\n \n@@ -677,7 +677,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> CombineFields<'a, 'gcx, 'tcx> {\n+    ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n@@ -1548,13 +1548,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct ShallowResolver<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct ShallowResolver<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> ShallowResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n     #[inline(always)]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n         ShallowResolver { infcx }\n     }\n \n@@ -1599,8 +1599,8 @@ impl<'a, 'gcx, 'tcx> ShallowResolver<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -1624,7 +1624,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'gcx, 'tcx> TypeTrace<'tcx> {\n+impl<'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.cause.span\n     }\n@@ -1641,7 +1641,7 @@ impl<'gcx, 'tcx> TypeTrace<'tcx> {\n         }\n     }\n \n-    pub fn dummy(tcx: TyCtxt<'gcx, 'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: ObligationCause::dummy(),\n             values: Types(ExpectedFound {"}, {"sha": "2c821d0ae15c1dbdb24b3cc6d8f7c34cb9101e6b", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -38,11 +38,11 @@ pub enum NormalizationStrategy {\n     Eager,\n }\n \n-pub struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+pub struct TypeRelating<'me, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n \n     /// Callback to use when we deduce an outlives relationship\n     delegate: D,\n@@ -135,12 +135,12 @@ struct BoundRegionScope<'tcx> {\n #[derive(Copy, Clone)]\n struct UniversallyQuantified(bool);\n \n-impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n+impl<'me, 'tcx, D> TypeRelating<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     pub fn new(\n-        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        infcx: &'me InferCtxt<'me, 'tcx>,\n         delegate: D,\n         ambient_variance: ty::Variance,\n     ) -> Self {\n@@ -416,15 +416,15 @@ trait VidValuePair<'tcx>: Debug {\n     /// for more details on why we want them.\n     fn vid_scopes<D: TypeRelatingDelegate<'tcx>>(\n         &self,\n-        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n     ) -> &'r mut Vec<BoundRegionScope<'tcx>>;\n \n     /// Given a generalized type G that should replace the vid, relate\n     /// G to the value, putting G on whichever side the vid would have\n     /// appeared.\n     fn relate_generalized_ty<D>(\n         &self,\n-        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        relate: &mut TypeRelating<'_, 'tcx, D>,\n         generalized_ty: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n@@ -442,7 +442,7 @@ impl VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n \n     fn vid_scopes<D>(\n         &self,\n-        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n     ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n     where\n         D: TypeRelatingDelegate<'tcx>,\n@@ -452,7 +452,7 @@ impl VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n \n     fn relate_generalized_ty<D>(\n         &self,\n-        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        relate: &mut TypeRelating<'_, 'tcx, D>,\n         generalized_ty: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n@@ -474,7 +474,7 @@ impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n \n     fn vid_scopes<D>(\n         &self,\n-        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n     ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n     where\n         D: TypeRelatingDelegate<'tcx>,\n@@ -484,7 +484,7 @@ impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n \n     fn relate_generalized_ty<D>(\n         &self,\n-        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        relate: &mut TypeRelating<'_, 'tcx, D>,\n         generalized_ty: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n@@ -494,11 +494,11 @@ impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n     }\n }\n \n-impl<D> TypeRelation<'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+impl<D> TypeRelation<'tcx> for TypeRelating<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -798,11 +798,11 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n /// scopes.\n ///\n /// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+struct TypeGeneralizer<'me, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx> + 'me,\n {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n \n     delegate: &'me mut D,\n \n@@ -823,11 +823,11 @@ where\n     universe: ty::UniverseIndex,\n }\n \n-impl<D> TypeRelation<'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+impl<D> TypeRelation<'tcx> for TypeGeneralizer<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "8e9af8b39385fb6a59ba772dc5e1b82397dce937", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -73,7 +73,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     pub origin: hir::ExistTyOrigin,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n@@ -430,8 +430,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        instantiated_ty: Ty<'gcx>,\n-    ) -> Ty<'gcx> {\n+        instantiated_ty: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n         debug!(\n             \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n             def_id, instantiated_ty\n@@ -446,7 +446,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n         let id_substs = InternalSubsts::identity_for_item(gcx, def_id);\n-        let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> = opaque_defn\n+        let map: FxHashMap<Kind<'tcx>, Kind<'tcx>> = opaque_defn\n             .substs\n             .iter()\n             .enumerate()\n@@ -470,7 +470,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         // We can unwrap here because our reverse mapper always\n-        // produces things with 'gcx lifetime, though the type folder\n+        // produces things with 'tcx lifetime, though the type folder\n         // obscures that.\n         let definition_ty = gcx.lift(&definition_ty).unwrap();\n \n@@ -491,14 +491,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct OpaqueTypeOutlivesVisitor<'a, 'gcx, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct OpaqueTypeOutlivesVisitor<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     least_region: ty::Region<'tcx>,\n     span: Span,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, '_, 'tcx>\n-{\n+impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         t.skip_binder().visit_with(self);\n         false // keep visiting\n@@ -552,27 +551,27 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, '_, 'tcx>\n     }\n }\n \n-struct ReverseMapper<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct ReverseMapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n \n     /// If errors have already been reported in this fn, we suppress\n     /// our own errors because they are sometimes derivative.\n     tainted_by_errors: bool,\n \n     opaque_type_def_id: DefId,\n-    map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+    map: FxHashMap<Kind<'tcx>, Kind<'tcx>>,\n     map_missing_regions_to_empty: bool,\n \n     /// initially `Some`, set to `None` once error has been reported\n     hidden_ty: Option<Ty<'tcx>>,\n }\n \n-impl ReverseMapper<'gcx, 'tcx> {\n+impl ReverseMapper<'tcx> {\n     fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n-        map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+        map: FxHashMap<Kind<'tcx>, Kind<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n     ) -> Self {\n         Self {\n@@ -599,8 +598,8 @@ impl ReverseMapper<'gcx, 'tcx> {\n     }\n }\n \n-impl TypeFolder<'gcx, 'tcx> for ReverseMapper<'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -724,16 +723,16 @@ impl TypeFolder<'gcx, 'tcx> for ReverseMapper<'gcx, 'tcx> {\n     }\n }\n \n-struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct Instantiator<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     parent_def_id: DefId,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n     fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n         debug!(\"instantiate_opaque_types_in_map(value={:?})\", value);\n         let tcx = self.infcx.tcx;\n@@ -944,7 +943,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// and `opaque_hir_id` is the `HirId` of the definition of the existential type `Baz`.\n /// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n pub fn may_define_existential_type(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {"}, {"sha": "4b5df444148be3ebe8b154684635e59543ed8de8", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -67,7 +67,7 @@ pub struct OutlivesEnvironment<'tcx> {\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n+impl<'a, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut env = OutlivesEnvironment {\n             param_env,\n@@ -160,7 +160,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n     pub fn add_implied_bounds(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'a, 'tcx>,\n         fn_sig_tys: &[Ty<'tcx>],\n         body_id: hir::HirId,\n         span: Span,\n@@ -190,11 +190,8 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     /// contain inference variables, it must be supplied, in which\n     /// case we will register \"givens\" on the inference context. (See\n     /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(\n-        &mut self,\n-        infcx: Option<&InferCtxt<'a, 'gcx, 'tcx>>,\n-        outlives_bounds: I,\n-    ) where\n+    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'a, 'tcx>>, outlives_bounds: I)\n+    where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n         // Record relationships such as `T:'x` that don't go into the"}, {"sha": "1250995a59c106787707c905d08c192387d23241", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -28,9 +28,9 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details.\n-    pub fn lub_free_regions<'gcx>(\n+    pub fn lub_free_regions(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         r_a: Region<'tcx>,\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n@@ -91,7 +91,7 @@ impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {\n         self.relation.maybe_map(|&fr| tcx.lift(&fr))\n                      .map(|relation| FreeRegionMap { relation })\n     }"}, {"sha": "671718b1008e22ac022b201c092e45ece837d440", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -69,7 +69,7 @@ use crate::ty::outlives::Component;\n use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::UnpackedKind;\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n     /// from within the scope of `body_id`. These regions are enqueued\n     /// and later processed by regionck, when full type information is\n@@ -226,15 +226,15 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n /// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n /// accrues them into the `region_obligations` code, but for NLL we\n /// use something else.\n-pub struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx, D>\n+pub struct TypeOutlives<'cx, 'tcx: 'cx, D>\n where\n     D: TypeOutlivesDelegate<'tcx>,\n {\n     // See the comments on `process_registered_region_obligations` for the meaning\n     // of these fields.\n     delegate: D,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    verify_bound: VerifyBoundCx<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    verify_bound: VerifyBoundCx<'cx, 'tcx>,\n }\n \n pub trait TypeOutlivesDelegate<'tcx> {\n@@ -254,13 +254,13 @@ pub trait TypeOutlivesDelegate<'tcx> {\n     );\n }\n \n-impl<'cx, 'gcx, 'tcx, D> TypeOutlives<'cx, 'gcx, 'tcx, D>\n+impl<'cx, 'tcx, D> TypeOutlives<'cx, 'tcx, D>\n where\n     D: TypeOutlivesDelegate<'tcx>,\n {\n     pub fn new(\n         delegate: D,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -487,7 +487,7 @@ where\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {\n     fn push_sub_region_constraint(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,"}, {"sha": "96335e1052ee3472588d14641abdb79b694d9f96", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,16 +12,16 @@ use crate::util::captures::Captures;\n /// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n /// accrues them into the `region_obligations` code, but for NLL we\n /// use something else.\n-pub struct VerifyBoundCx<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct VerifyBoundCx<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'tcx>,\n     region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -102,7 +102,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     pub fn projection_declared_bounds_from_trait(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'tcx> {\n         self.declared_projection_bounds_from_trait(projection_ty)\n     }\n \n@@ -244,7 +244,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     fn declared_projection_bounds_from_trait(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'tcx> {\n         debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n         let tcx = self.tcx;\n         self.region_bounds_declared_on_associated_item(projection_ty.item_def_id)\n@@ -284,7 +284,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     fn region_bounds_declared_on_associated_item(\n         &self,\n         assoc_item_def_id: DefId,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'tcx> {\n         let tcx = self.tcx;\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();"}, {"sha": "30f6137289abf3d72ecfdd4807701f98173dcbeb", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// refactor the constraint set.\n     pub fn leak_check(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         overly_polymorphic: bool,\n         placeholder_map: &PlaceholderMap<'tcx>,\n         _snapshot: &CombinedSnapshot<'_, 'tcx>,\n@@ -109,7 +109,7 @@ impl<'tcx> TaintSet<'tcx> {\n \n     fn fixed_point(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         undo_log: &[UndoLog<'tcx>],\n         verifys: &[Verify<'tcx>],\n     ) {"}, {"sha": "f2235fe8d6d1245868a8167a6d83499f05250b40", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -700,7 +700,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn lub_regions(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -722,7 +722,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn glb_regions(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -744,7 +744,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn opportunistic_resolve_var(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n         let vid = self.unification_table.probe_value(rid).min_vid;\n@@ -760,7 +760,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     fn combine_vars(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         t: CombineMapType,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -849,8 +849,8 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+impl<'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),"}, {"sha": "810c64185a71d82422caa0e6ff2c113b74dcb7f0", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,19 +12,19 @@ use crate::ty::fold::{TypeFolder, TypeVisitor};\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticVarResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct OpportunisticVarResolver<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> OpportunisticVarResolver<'a, 'tcx> {\n     #[inline]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n         OpportunisticVarResolver { infcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -50,18 +50,18 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gc\n /// The opportunistic type and region resolver is similar to the\n /// opportunistic type resolver, but also opportunistically resolves\n /// regions. It is useful for canonicalization.\n-pub struct OpportunisticTypeAndRegionResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct OpportunisticTypeAndRegionResolver<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n         OpportunisticTypeAndRegionResolver { infcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -101,20 +101,20 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n /// type variables that don't yet have a value. The first unresolved type is stored.\n /// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n-pub struct UnresolvedTypeFinder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct UnresolvedTypeFinder<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n \n     /// Used to find the type parameter name and location for error reporting.\n-    pub first_unresolved: Option<(Ty<'tcx>,Option<Span>)>,\n+    pub first_unresolved: Option<(Ty<'tcx>, Option<Span>)>,\n }\n \n-impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n         UnresolvedTypeFinder { infcx, first_unresolved: None }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n@@ -157,9 +157,9 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx>\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                        value: &T) -> FixupResult<'tcx, T>\n-    where T : TypeFoldable<'tcx>\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: &T) -> FixupResult<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n     let result = value.fold_with(&mut full_resolver);\n@@ -171,13 +171,13 @@ pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n // N.B. This type is not public because the protocol around checking the\n // `err` field is not enforcable otherwise.\n-struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct FullTypeResolver<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     err: Option<FixupError<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "ed84e3f63ae1b80e5770f0271544d8a1c36c7bc0", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,15 +11,16 @@ use crate::mir::interpret::ConstValue;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+pub struct Sub<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> Sub<'combine, 'infcx, 'gcx, 'tcx> {\n-    pub fn new(f: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n-        -> Sub<'combine, 'infcx, 'gcx, 'tcx>\n-    {\n+impl<'combine, 'infcx, 'tcx> Sub<'combine, 'infcx, 'tcx> {\n+    pub fn new(\n+        f: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Sub<'combine, 'infcx, 'tcx> {\n         Sub { fields: f, a_is_expected: a_is_expected }\n     }\n \n@@ -31,9 +32,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Sub<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeRelation<'gcx, 'tcx> for Sub<'combine, 'infcx, 'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R"}, {"sha": "846611db05427b373af9de31549aa15fb88a2bd7", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,7 +10,7 @@ use std::marker::PhantomData;\n use std::cell::RefMut;\n \n pub trait ToType {\n-    fn to_type<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -52,7 +52,7 @@ impl UnifyKey for ty::RegionVid {\n }\n \n impl ToType for IntVarValue {\n-    fn to_type<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -72,7 +72,7 @@ impl UnifyKey for ty::FloatVid {\n impl EqUnifyValue for FloatVarValue {}\n \n impl ToType for FloatVarValue {\n-    fn to_type<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(self.0)\n     }\n }"}, {"sha": "468d909e5497b89de34ef38bb590f66dc3957b58", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -509,7 +509,7 @@ impl LintStore {\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n \n     /// Side-tables for the body we are in.\n     // FIXME: Make this lazy to avoid running the TypeckTables query?\n@@ -781,10 +781,10 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// ```\n     pub fn get_def_path(&self, def_id: DefId) -> Vec<Symbol> {\n         pub struct AbsolutePathPrinter<'tcx> {\n-            pub tcx: TyCtxt<'tcx, 'tcx>,\n+            pub tcx: TyCtxt<'tcx>,\n         }\n \n-        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n+        impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             type Error = !;\n \n             type Path = Vec<Symbol>;\n@@ -793,7 +793,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             type DynExistential = ();\n             type Const = ();\n \n-            fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+            fn tcx(&self) -> TyCtxt<'tcx> {\n                 self.tcx\n             }\n \n@@ -1372,7 +1372,7 @@ macro_rules! late_lint_pass_impl {\n late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     module_def_id: DefId,\n     pass: T,\n ) {\n@@ -1404,7 +1404,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n }\n \n pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     module_def_id: DefId,\n     builtin_lints: T,\n ) {\n@@ -1423,7 +1423,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     }\n }\n \n-fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx, 'tcx>, pass: T) {\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -1456,10 +1456,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n     })\n }\n \n-fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    builtin_lints: T,\n-) {\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n     let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n@@ -1491,7 +1488,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n /// Performs lint checking on a crate.\n pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     builtin_lints: impl FnOnce() -> T + Send,\n ) {\n     join(|| {"}, {"sha": "70c0e83517af0c98d3f56d0e14e66ddee772e685", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -761,12 +761,12 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n     return err\n }\n \n-pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_>, id: hir::HirId) -> bool {\n+pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     let attrs = tcx.hir().attrs_by_hir_id(id);\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n-fn lint_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> &'tcx LintLevelMap {\n+fn lint_levels<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n         levels: LintLevelSets::builder(tcx.sess),\n@@ -787,7 +787,7 @@ fn lint_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> &'tcx LintLevel\n \n struct LintLevelMapBuilder<'tcx> {\n     levels: levels::LintLevelsBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl LintLevelMapBuilder<'tcx> {"}, {"sha": "09fa924efc7ab0b467821d714e5217a802325c49", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -195,7 +195,7 @@ macro_rules! CloneLiftImpls {\n         $(\n             impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n                 type Lifted = Self;\n-                fn lift_to_tcx<'gcx>(&self, _: $crate::ty::TyCtxt<'gcx, $tcx>) -> Option<Self> {\n+                fn lift_to_tcx(&self, _: $crate::ty::TyCtxt<$tcx>) -> Option<Self> {\n                     Some(Clone::clone(self))\n                 }\n             }\n@@ -218,7 +218,7 @@ macro_rules! CloneTypeFoldableImpls {\n     (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n         $(\n             impl<$tcx> $crate::ty::fold::TypeFoldable<$tcx> for $ty {\n-                fn super_fold_with<'gcx: $tcx, F: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                fn super_fold_with<F: $crate::ty::fold::TypeFolder<$tcx>>(\n                     &self,\n                     _: &mut F\n                 ) -> $ty {\n@@ -264,7 +264,7 @@ macro_rules! BraceStructLiftImpl {\n         {\n             type Lifted = $lifted;\n \n-            fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<$lifted> {\n+            fn lift_to_tcx(&self, tcx: TyCtxt<$tcx>) -> Option<$lifted> {\n                 $(let $field = tcx.lift(&self.$field)?;)*\n                 Some(Self::Lifted { $($field),* })\n             }\n@@ -283,7 +283,7 @@ macro_rules! EnumLiftImpl {\n         {\n             type Lifted = $lifted;\n \n-            fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<$lifted> {\n+            fn lift_to_tcx(&self, tcx: TyCtxt<$tcx>) -> Option<$lifted> {\n                 EnumLiftImpl!(@Variants(self, tcx) input($($variants)*) output())\n             }\n         }\n@@ -332,7 +332,7 @@ macro_rules! BraceStructTypeFoldableImpl {\n         impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n             $(where $($wc)*)*\n         {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+            fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n                 &self,\n                 folder: &mut V,\n             ) -> Self {\n@@ -359,7 +359,7 @@ macro_rules! TupleStructTypeFoldableImpl {\n         impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n             $(where $($wc)*)*\n         {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+            fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n                 &self,\n                 folder: &mut V,\n             ) -> Self {\n@@ -386,7 +386,7 @@ macro_rules! EnumTypeFoldableImpl {\n         impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n             $(where $($wc)*)*\n         {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+            fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n                 &self,\n                 folder: &mut V,\n             ) -> Self {"}, {"sha": "2e9e1ac582f812e8169c09b1b95d2dae983d3280", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -211,7 +211,7 @@ pub trait CrateStore {\n     fn crates_untracked(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata;\n+    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx>) -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -226,7 +226,7 @@ pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n // In order to get this left-to-right dependency ordering, we perform a\n // topological sort of all crates putting the leaves at the right-most\n // positions.\n-pub fn used_crates(tcx: TyCtxt<'_, '_>, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n+pub fn used_crates(tcx: TyCtxt<'_>, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n     let mut libs = tcx.crates()\n         .iter()\n         .cloned()"}, {"sha": "0356e7e10724d81696d2ff77c6478f5a6c05088c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -26,7 +26,7 @@ use syntax_pos;\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: hir::HirId) -> bool {\n+fn should_explore<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> bool {\n     match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n@@ -40,7 +40,7 @@ fn should_explore<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: hir::HirId) -> bool {\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<hir::HirId>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n@@ -302,7 +302,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n }\n \n fn has_allow_dead_code_or_lang_attr(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     id: hir::HirId,\n     attrs: &[ast::Attribute],\n ) -> bool {\n@@ -354,7 +354,7 @@ fn has_allow_dead_code_or_lang_attr(\n struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n     struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n@@ -425,7 +425,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n }\n \n fn create_and_seed_worklist<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n ) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n@@ -453,7 +453,7 @@ fn create_and_seed_worklist<'tcx>(\n }\n \n fn find_live<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n ) -> FxHashSet<hir::HirId> {\n@@ -474,7 +474,7 @@ fn find_live<'tcx>(\n }\n \n struct DeadVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     live_symbols: FxHashSet<hir::HirId>,\n }\n \n@@ -662,7 +662,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     }\n }\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "879da6413e28a9f9cc8a400bcbe60c8fa5565faa", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -81,7 +81,7 @@ pub enum Linkage {\n     Dynamic,\n }\n \n-pub fn calculate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn calculate<'tcx>(tcx: TyCtxt<'tcx>) {\n     let sess = &tcx.sess;\n     let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n@@ -92,7 +92,7 @@ pub fn calculate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     sess.dependency_formats.set(fmts);\n }\n \n-fn calculate_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: config::CrateType) -> DependencyList {\n+fn calculate_type<'tcx>(tcx: TyCtxt<'tcx>, ty: config::CrateType) -> DependencyList {\n     let sess = &tcx.sess;\n \n     if !sess.opts.output_types.should_codegen() {\n@@ -241,7 +241,7 @@ fn calculate_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: config::CrateType) -> Depen\n }\n \n fn add_library(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n     link: LinkagePreference,\n     m: &mut FxHashMap<CrateNum, LinkagePreference>,\n@@ -267,7 +267,7 @@ fn add_library(\n     }\n }\n \n-fn attempt_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DependencyList> {\n+fn attempt_static<'tcx>(tcx: TyCtxt<'tcx>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n     let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n@@ -324,7 +324,7 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n \n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n-fn verify_ok<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, list: &[Linkage]) {\n+fn verify_ok<'tcx>(tcx: TyCtxt<'tcx>, list: &[Linkage]) {\n     let sess = &tcx.sess;\n     if list.len() == 0 {\n         return"}, {"sha": "d9e7caebb982992a0281e5cc9ea68f72f0461584", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n }\n \n-fn entry_fn(tcx: TyCtxt<'_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n+fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let any_exe = tcx.sess.crate_types.borrow().iter().any(|ty| {\n@@ -140,10 +140,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n     }\n }\n \n-fn configure_main(\n-    tcx: TyCtxt<'_, '_>,\n-    visitor: &EntryContext<'_, '_>,\n-) -> Option<(DefId, EntryFnType)> {\n+fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n         Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n@@ -179,7 +176,7 @@ fn configure_main(\n     }\n }\n \n-pub fn find_entry_point(tcx: TyCtxt<'_, '_>) -> Option<(DefId, EntryFnType)> {\n+pub fn find_entry_point(tcx: TyCtxt<'_>) -> Option<(DefId, EntryFnType)> {\n     tcx.entry_fn(LOCAL_CRATE)\n }\n "}, {"sha": "202788093046acf35ce508e660af3eb3487df4bb", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -38,7 +38,7 @@ pub enum ExportedSymbol<'tcx> {\n }\n \n impl<'tcx> ExportedSymbol<'tcx> {\n-    pub fn symbol_name(&self, tcx: TyCtxt<'tcx, '_>) -> ty::SymbolName {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => {\n                 tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n@@ -52,11 +52,7 @@ impl<'tcx> ExportedSymbol<'tcx> {\n         }\n     }\n \n-    pub fn compare_stable(\n-        &self,\n-        tcx: TyCtxt<'tcx, '_>,\n-        other: &ExportedSymbol<'tcx>,\n-    ) -> cmp::Ordering {\n+    pub fn compare_stable(&self, tcx: TyCtxt<'tcx>, other: &ExportedSymbol<'tcx>) -> cmp::Ordering {\n         match *self {\n             ExportedSymbol::NonGeneric(self_def_id) => match *other {\n                 ExportedSymbol::NonGeneric(other_def_id) => {\n@@ -91,13 +87,13 @@ impl<'tcx> ExportedSymbol<'tcx> {\n     }\n }\n \n-pub fn metadata_symbol_name(tcx: TyCtxt<'_, '_>) -> String {\n+pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n     format!(\"rust_metadata_{}_{}\",\n             tcx.original_crate_name(LOCAL_CRATE),\n             tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'gcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {"}, {"sha": "61770e6f4870510a2821824e3770221120ed21a7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -202,7 +202,7 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id(tcx: TyCtxt<'_, '_>, trait_id: DefId) -> OverloadedCallType {\n+    fn from_trait_id(tcx: TyCtxt<'_>, trait_id: DefId) -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items().fn_once_trait(), FnOnceOverloadedCall),\n             (tcx.lang_items().fn_mut_trait(), FnMutOverloadedCall),\n@@ -219,7 +219,7 @@ impl OverloadedCallType {\n         bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id(tcx: TyCtxt<'_, '_>, method_id: DefId) -> OverloadedCallType {\n+    fn from_method_id(tcx: TyCtxt<'_>, method_id: DefId) -> OverloadedCallType {\n         let method = tcx.associated_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container.id())\n     }\n@@ -229,8 +229,8 @@ impl OverloadedCallType {\n // The ExprUseVisitor type\n //\n // This is the code that actually walks the tree.\n-pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n+pub struct ExprUseVisitor<'a, 'tcx: 'a> {\n+    mc: mc::MemCategorizationContext<'a, 'tcx>,\n     delegate: &'a mut dyn Delegate<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -254,7 +254,7 @@ macro_rules! return_if_err {\n     )\n }\n \n-impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// Creates the ExprUseVisitor, configuring it with the various options provided:\n     ///\n     /// - `delegate` -- who receives the callbacks\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(\n         delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body_owner: DefId,\n         param_env: ty::ParamEnv<'tcx>,\n         region_scope_tree: &'a region::ScopeTree,\n@@ -287,15 +287,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n-    pub fn with_infer(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n-                      infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                      body_owner: DefId,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      region_scope_tree: &'a region::ScopeTree,\n-                      tables: &'a ty::TypeckTables<'tcx>)\n-                      -> Self\n-    {\n+impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n+    pub fn with_infer(\n+        delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        body_owner: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+    ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::with_infer(\n                 infcx,\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&body.value);\n     }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.mc.tcx\n     }\n \n@@ -974,12 +974,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn copy_or_move<'a, 'gcx, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n-                                param_env: ty::ParamEnv<'tcx>,\n-                                cmt: &mc::cmt_<'tcx>,\n-                                move_reason: MoveReason)\n-                                -> ConsumeMode\n-{\n+fn copy_or_move<'a, 'tcx>(\n+    mc: &mc::MemCategorizationContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cmt: &mc::cmt_<'tcx>,\n+    move_reason: MoveReason,\n+) -> ConsumeMode {\n     if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {"}, {"sha": "a8a7df08469aac15454141e45409db34f4cb02b7", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,8 +15,8 @@ use crate::ty::{self, TyCtxt, Region};\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n-pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct RegionRelations<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'tcx>,\n \n     /// The context used to fetch the region maps.\n     pub context: DefId,\n@@ -28,9 +28,9 @@ pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         context: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         free_regions: &'a FreeRegionMap<'tcx>,"}, {"sha": "e8d68e0b7a7aa409948c4293cbee35a8b20f0c7e", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::{Span, sym};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n-fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ItemVisitor { tcx }.as_deep_visitor()\n@@ -25,18 +25,18 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n struct ItemVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n struct ExprVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: &'tcx ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n-fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     let (def, substs) = match ty.sty {\n         ty::Adt(def, substs) => (def, substs),\n         _ => return ty"}, {"sha": "d7abdb8ecbe1023caac6feb33b557ae8bd675e63", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -106,7 +106,7 @@ impl LanguageItems {\n \n struct LanguageItemCollector<'tcx> {\n     items: LanguageItems,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     /// A mapping from the name of the lang item to its order and the form it must be of.\n     item_refs: FxHashMap<&'static str, (usize, Target)>,\n }\n@@ -160,7 +160,7 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n }\n \n impl LanguageItemCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>) -> LanguageItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n         let mut item_refs = FxHashMap::default();\n \n         $( item_refs.insert($name, ($variant as usize, $target)); )*\n@@ -217,7 +217,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n }\n \n /// Traverse and collect all the lang items in all crates.\n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> LanguageItems {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n     // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n \n@@ -402,7 +402,7 @@ language_item_table! {\n     Rc,                          \"rc\",                 rc,                      Target::Struct;\n }\n \n-impl<'tcx, 'gcx> TyCtxt<'tcx, 'gcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally abort compilation.\n     pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {"}, {"sha": "9c131ce63428b3845dffc7e0970e7c8dc3029705", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -38,12 +38,12 @@ impl LibFeatures {\n }\n \n pub struct LibFeatureCollector<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     lib_features: LibFeatures,\n }\n \n impl LibFeatureCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>) -> LibFeatureCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> LibFeatureCollector<'tcx> {\n         LibFeatureCollector {\n             tcx,\n             lib_features: LibFeatures::new(),\n@@ -142,7 +142,7 @@ impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n     }\n }\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> LibFeatures {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     intravisit::walk_crate(&mut collector, tcx.hir().krate());\n     collector.lib_features"}, {"sha": "260935a38d6d452df1831a95c07691d1d25b6056", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -150,7 +150,7 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_>) -> String {\n+fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n     let cm = tcx.sess.source_map();\n     match lnk {\n         UpvarNode(s) => {\n@@ -181,7 +181,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n-fn check_mod_liveness<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_liveness<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n@@ -257,7 +257,7 @@ enum VarKind {\n }\n \n struct IrMaps<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body_owner: DefId,\n     num_live_nodes: usize,\n     num_vars: usize,\n@@ -269,7 +269,7 @@ struct IrMaps<'tcx> {\n }\n \n impl IrMaps<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>, body_owner: DefId) -> IrMaps<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, body_owner: DefId) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n             body_owner,"}, {"sha": "3b21b81df7b434bc51e6a7867d3f773fc9f79e28", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -287,14 +287,14 @@ impl HirNode for hir::Pat {\n }\n \n #[derive(Clone)]\n-pub struct MemCategorizationContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct MemCategorizationContext<'a, 'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n     pub body_owner: DefId,\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n-    infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n+    infcx: Option<&'a InferCtxt<'a, 'tcx>>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -340,7 +340,7 @@ impl MutabilityCategory {\n     }\n \n     fn from_local(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         tables: &ty::TypeckTables<'_>,\n         id: ast::NodeId,\n     ) -> MutabilityCategory {\n@@ -402,14 +402,14 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body_owner: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n         rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n-    ) -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+    ) -> MemCategorizationContext<'a, 'tcx> {\n         MemCategorizationContext {\n             tcx,\n             body_owner,\n@@ -422,7 +422,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Creates a `MemCategorizationContext` during type inference.\n     /// This is used during upvar analysis and a few other places.\n     /// Because the typeck tables are not yet complete, the results\n@@ -432,11 +432,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     ///   temporaries may be overly conservative;\n     /// - similarly, as the results of upvar analysis are not yet\n     ///   known, the results around upvar accesses may be incorrect.\n-    pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                      body_owner: DefId,\n-                      region_scope_tree: &'a region::ScopeTree,\n-                      tables: &'a ty::TypeckTables<'tcx>)\n-                      -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    pub fn with_infer(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        body_owner: DefId,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+    ) -> MemCategorizationContext<'a, 'tcx> {\n         let tcx = infcx.tcx;\n \n         // Subtle: we can't do rvalue promotion analysis until the\n@@ -586,10 +587,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n-        fn helper<'a, 'gcx, 'tcx>(mc: &MemCategorizationContext<'a, 'gcx, 'tcx>,\n-                                  expr: &hir::Expr,\n-                                  adjustments: &[adjustment::Adjustment<'tcx>])\n-                                  -> McResult<cmt_<'tcx>> {\n+        fn helper<'a, 'tcx>(\n+            mc: &MemCategorizationContext<'a, 'tcx>,\n+            expr: &hir::Expr,\n+            adjustments: &[adjustment::Adjustment<'tcx>],\n+        ) -> McResult<cmt_<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -1518,7 +1520,7 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    pub fn descriptive_string(&self, tcx: TyCtxt<'_, '_>) -> Cow<'static, str> {\n+    pub fn descriptive_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match self.cat {\n             Categorization::StaticItem => {\n                 \"static item\".into()"}, {"sha": "363ccd74c08d9dcdffe3550d2d1ad2dcb978723e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -27,7 +27,7 @@ use crate::hir::intravisit;\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx>, item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n@@ -43,7 +43,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx>, item: &hir::Item, attrs: Codeg\n }\n \n fn method_might_be_inlined<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_item: &hir::ImplItem,\n     impl_src: DefId,\n ) -> bool {\n@@ -67,7 +67,7 @@ fn method_might_be_inlined<'tcx>(\n // Information needed while computing reachability.\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: HirIdSet,\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n // trait items are used from inlinable code through method call syntax or UFCS, or their\n // trait is a lang item.\n struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n     worklist: &'a mut Vec<hir::HirId>,\n }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n #[derive(Clone, HashStable)]\n pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n-fn reachable_set<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n+fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "8b1eeeb7f51b72e649111026020f95f4e53f6ecb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -169,7 +169,7 @@ impl Scope {\n         self.id\n     }\n \n-    pub fn node_id(&self, tcx: TyCtxt<'_, '_>, scope_tree: &ScopeTree) -> ast::NodeId {\n+    pub fn node_id(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> ast::NodeId {\n         match scope_tree.root_body {\n             Some(hir_id) => {\n                 tcx.hir().hir_to_node_id(hir::HirId {\n@@ -184,7 +184,7 @@ impl Scope {\n     /// Returns the span of this `Scope`. Note that in general the\n     /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n-    pub fn span(&self, tcx: TyCtxt<'_, '_>, scope_tree: &ScopeTree) -> Span {\n+    pub fn span(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> Span {\n         let node_id = self.node_id(tcx, scope_tree);\n         if node_id == ast::DUMMY_NODE_ID {\n             return DUMMY_SP;\n@@ -359,7 +359,7 @@ pub struct Context {\n }\n \n struct RegionResolutionVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     // The number of expressions and patterns visited in the current body\n     expr_and_pat_count: usize,\n@@ -646,11 +646,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope<'gcx>(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        br: &ty::EarlyBoundRegion,\n-    ) -> Scope {\n+    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n@@ -679,7 +675,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, fr: &ty::FreeRegion) -> Scope {\n+    pub fn free_scope(&self, tcx: TyCtxt<'tcx>, fr: &ty::FreeRegion) -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n                 tcx.parent(def_id).unwrap()\n@@ -1334,7 +1330,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n     }\n }\n \n-fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ScopeTree {\n+fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n         return tcx.region_scope_tree(closure_base_def_id);"}, {"sha": "8bc3158bd3c7de3fdd9d8f441f05c1257b9719e1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -218,7 +218,7 @@ impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n });\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n@@ -368,7 +368,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// entire crate. You should not read the result of this query\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n-fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, for_krate: CrateNum) -> &'tcx ResolveLifetimes {\n+fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx>, for_krate: CrateNum) -> &'tcx ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -395,7 +395,7 @@ fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, for_krate: CrateNum) -> &'tc\n     tcx.arena.alloc(rl)\n }\n \n-fn krate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> NamedRegionMap {\n+fn krate<'tcx>(tcx: TyCtxt<'tcx>) -> NamedRegionMap {\n     let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {\n         defs: Default::default(),\n@@ -1098,7 +1098,7 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_>, params: &P<[hir::GenericParam]>) {\n+fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &P<[hir::GenericParam]>) {\n     let lifetime_params: Vec<_> = params\n         .iter()\n         .filter_map(|param| match param.kind {\n@@ -1125,12 +1125,7 @@ fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_>, params: &P<[hir::G\n     }\n }\n \n-fn signal_shadowing_problem(\n-    tcx: TyCtxt<'_, '_>,\n-    name: ast::Name,\n-    orig: Original,\n-    shadower: Shadower,\n-) {\n+fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: ast::Name, orig: Original, shadower: Shadower) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n         struct_span_err!(\n@@ -1166,7 +1161,7 @@ fn signal_shadowing_problem(\n // if one of the label shadows a lifetime or another label.\n fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     struct GatherLabels<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<ast::Ident>,\n     }\n@@ -1215,7 +1210,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n \n     fn check_if_label_shadows_lifetime(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         mut scope: ScopeRef<'_>,\n         label: ast::Ident,\n     ) {\n@@ -1253,7 +1248,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(tcx: TyCtxt<'_, '_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n+fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n         match item.node {\n@@ -1310,7 +1305,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_, '_>) -> HirIdMap<Vec<ObjectL\n /// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n /// for each type parameter.\n fn object_lifetime_defaults_for_item(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     generics: &hir::Generics,\n ) -> Vec<ObjectLifetimeDefault> {\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound]) {"}, {"sha": "19d127a565fc327d9e5e3084cf334fb66e64844c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -106,7 +106,7 @@ impl_stable_hash_for!(struct self::Index<'tcx> {\n \n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<DeprecationEntry>,\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n }\n \n struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     access_levels: &'a AccessLevels,\n }\n \n@@ -390,7 +390,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n }\n \n impl<'tcx> Index<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx, 'tcx>) -> Index<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n         let is_staged_api =\n             tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n             tcx.features().staged_api;\n@@ -466,7 +466,7 @@ impl<'tcx> Index<'tcx> {\n \n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n-fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n \n@@ -502,7 +502,7 @@ pub fn deprecation_in_effect(since: &str) -> bool {\n }\n \n struct Checker<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n /// Result of `TyCtxt::eval_stability`.\n@@ -521,7 +521,7 @@ pub enum EvalResult {\n     Unmarked,\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n@@ -827,7 +827,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n@@ -836,7 +836,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n /// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn check_unused_or_stable_features<'tcx>(tcx: TyCtxt<'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n@@ -921,7 +921,7 @@ pub fn check_unused_or_stable_features<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n fn unnecessary_stable_feature_lint<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     span: Span,\n     feature: Symbol,\n     since: Symbol,"}, {"sha": "422ff3f2fd366a7097611b0e37b40b5eeed02491", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -18,13 +18,13 @@ macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n struct Context<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     items: &'a mut lang_items::LanguageItems,\n }\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n                              items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n@@ -60,7 +60,7 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n /// Not all lang items are always required for each compilation, particularly in\n /// the case of panic=abort. In these situations some lang items are injected by\n /// crates and don't actually need to be defined in libstd.\n-pub fn whitelisted(tcx: TyCtxt<'_, '_>, lang_item: lang_items::LangItem) -> bool {\n+pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: lang_items::LangItem) -> bool {\n     // If we're not compiling with unwinding, we won't actually need these\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n@@ -72,7 +72,7 @@ pub fn whitelisted(tcx: TyCtxt<'_, '_>, lang_item: lang_items::LangItem) -> bool\n     false\n }\n \n-fn verify<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n+fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n                     items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n@@ -142,7 +142,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx, 'gcx> TyCtxt<'tcx, 'gcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n         let lang_items = self.lang_items();\n         let did = Some(item_def_id);"}, {"sha": "e8113b4516cda4b4a8a40999e1f0d233c47e6ccb", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -74,16 +74,16 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n+impl<'tcx> ConstEvalErr<'tcx> {\n     pub fn struct_error(\n         &self,\n-        tcx: TyCtxtAt<'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx>,\n         message: &str,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         self.struct_generic(tcx, message, None)\n     }\n \n-    pub fn report_as_error(&self, tcx: TyCtxtAt<'gcx, 'tcx>, message: &str) -> ErrorHandled {\n+    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n         let err = self.struct_error(tcx, message);\n         match err {\n             Ok(mut err) => {\n@@ -96,7 +96,7 @@ impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n     pub fn report_as_lint(\n         &self,\n-        tcx: TyCtxtAt<'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx>,\n         message: &str,\n         lint_root: hir::HirId,\n         span: Option<Span>,\n@@ -129,7 +129,7 @@ impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n     fn struct_generic(\n         &self,\n-        tcx: TyCtxtAt<'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx>,\n         message: &str,\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n@@ -170,7 +170,7 @@ impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n     }\n }\n \n-pub fn struct_error<'gcx, 'tcx>(tcx: TyCtxtAt<'gcx, 'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n+pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n "}, {"sha": "a36c78802295537206cc101527701fa83125d96e", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -66,7 +66,7 @@ enum AllocDiscriminant {\n \n pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     encoder: &mut E,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n     let alloc: GlobalAlloc<'tcx> ="}, {"sha": "008a57bddfe8eb180a96788e4c2b58e12333c312", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -1240,8 +1240,8 @@ impl<'tcx> Terminator<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    pub fn if_<'gcx>(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+    pub fn if_(\n+        tcx: TyCtxt<'tcx>,\n         cond: Operand<'tcx>,\n         t: BasicBlock,\n         f: BasicBlock,\n@@ -2324,7 +2324,7 @@ impl<'tcx> Operand<'tcx> {\n     /// with given `DefId` and substs. Since this is used to synthesize\n     /// MIR, assumes `user_ty` is None.\n     pub fn function_handle(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         span: Span,\n@@ -2795,7 +2795,7 @@ impl UserTypeProjection {\n CloneTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n@@ -3012,8 +3012,8 @@ pub struct GeneratorLayout<'tcx> {\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct BorrowCheckResult<'gcx> {\n-    pub closure_requirements: Option<ClosureRegionRequirements<'gcx>>,\n+pub struct BorrowCheckResult<'tcx> {\n+    pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }\n \n@@ -3068,7 +3068,7 @@ pub struct BorrowCheckResult<'gcx> {\n /// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct ClosureRegionRequirements<'gcx> {\n+pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n     /// and `'2`. This is just used for a sanity check later on, to\n@@ -3078,7 +3078,7 @@ pub struct ClosureRegionRequirements<'gcx> {\n \n     /// Requirements between the various free regions defined in\n     /// indices.\n-    pub outlives_requirements: Vec<ClosureOutlivesRequirement<'gcx>>,\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement<'tcx>>,\n }\n \n /// Indicates an outlives constraint between a type or between two\n@@ -3262,7 +3262,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n@@ -3430,7 +3430,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match self {\n             &Place::Projection(ref p) => Place::Projection(p.fold_with(folder)),\n             _ => self.clone(),\n@@ -3447,7 +3447,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n@@ -3519,7 +3519,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n             Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n@@ -3536,7 +3536,7 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n@@ -3562,7 +3562,7 @@ impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         *self\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n@@ -3571,7 +3571,7 @@ impl<'tcx> TypeFoldable<'tcx> for Field {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         *self\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n@@ -3580,7 +3580,7 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n }\n \n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         self.clone()\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n@@ -3589,7 +3589,7 @@ impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {\n             span: self.span.clone(),\n             ty: self.ty.fold_with(folder),"}, {"sha": "39ae48b303abff5de6b4e240efe0c78ef7305622", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -48,7 +48,7 @@ pub enum MonoItem<'tcx> {\n }\n \n impl<'tcx> MonoItem<'tcx> {\n-    pub fn size_estimate(&self, tcx: TyCtxt<'tcx, 'tcx>) -> usize {\n+    pub fn size_estimate(&self, tcx: TyCtxt<'tcx>) -> usize {\n         match *self {\n             MonoItem::Fn(instance) => {\n                 // Estimate the size of a function based on how many statements\n@@ -72,7 +72,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn symbol_name(&self, tcx: TyCtxt<'tcx, 'tcx>) -> SymbolName {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> SymbolName {\n         match *self {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => {\n@@ -87,7 +87,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn instantiation_mode(&self, tcx: TyCtxt<'tcx, 'tcx>) -> InstantiationMode {\n+    pub fn instantiation_mode(&self, tcx: TyCtxt<'tcx>) -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n                 tcx.sess.opts.optimize != OptLevel::No\n@@ -131,7 +131,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Linkage> {\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'tcx>) -> Option<Linkage> {\n         let def_id = match *self {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n             MonoItem::Static(def_id) => def_id,\n@@ -167,7 +167,7 @@ impl<'tcx> MonoItem<'tcx> {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    pub fn is_instantiable(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n+    pub fn is_instantiable(&self, tcx: TyCtxt<'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n@@ -179,7 +179,7 @@ impl<'tcx> MonoItem<'tcx> {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    pub fn to_string(&self, tcx: TyCtxt<'tcx, 'tcx>, debug: bool) -> String {\n+    pub fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {\n         return match *self {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance, debug)\n@@ -194,7 +194,7 @@ impl<'tcx> MonoItem<'tcx> {\n         };\n \n         fn to_string_internal<'tcx>(\n-            tcx: TyCtxt<'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             prefix: &str,\n             instance: Instance<'tcx>,\n             debug: bool,\n@@ -207,7 +207,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn local_span(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Span> {\n+    pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir().as_local_hir_id(def.def_id())\n@@ -333,7 +333,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n \n-    pub fn estimate_size(&mut self, tcx: TyCtxt<'tcx, 'tcx>) {\n+    pub fn estimate_size(&mut self, tcx: TyCtxt<'tcx>) {\n         // Estimate the size of a codegen unit as (approximately) the number of MIR\n         // statements it corresponds to.\n         self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n@@ -359,7 +359,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         WorkProductId::from_cgu_name(&self.name().as_str())\n     }\n \n-    pub fn work_product(&self, tcx: TyCtxt<'_, '_>) -> WorkProduct {\n+    pub fn work_product(&self, tcx: TyCtxt<'_>) -> WorkProduct {\n         let work_product_id = self.work_product_id();\n         tcx.dep_graph\n            .previous_work_product(&work_product_id)\n@@ -370,14 +370,14 @@ impl<'tcx> CodegenUnit<'tcx> {\n \n     pub fn items_in_deterministic_order(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Vec<(MonoItem<'tcx>, (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n         pub struct ItemSortKey(Option<HirId>, SymbolName);\n \n-        fn item_sort_key<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item: MonoItem<'tcx>) -> ItemSortKey {\n+        fn item_sort_key<'tcx>(tcx: TyCtxt<'tcx>, item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n                 MonoItem::Fn(ref instance) => {\n                     match instance.def {\n@@ -413,7 +413,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         items\n     }\n \n-    pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx, 'tcx>) -> DepNode {\n+    pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n         DepNode::new(tcx, DepConstructor::CompileCodegenUnit(self.name().clone()))\n     }\n }\n@@ -443,13 +443,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     }\n }\n \n-pub struct CodegenUnitNameBuilder<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct CodegenUnitNameBuilder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     cache: FxHashMap<CrateNum, String>,\n }\n \n-impl CodegenUnitNameBuilder<'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n+impl CodegenUnitNameBuilder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n         CodegenUnitNameBuilder {\n             tcx,\n             cache: Default::default(),"}, {"sha": "afabcdfadd03c15de8fce7d45954a6bc165a2543", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,7 +21,7 @@ pub struct PlaceTy<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PlaceTy<'_>, 16);\n \n-impl<'gcx, 'tcx> PlaceTy<'tcx> {\n+impl<'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n         PlaceTy { ty, variant_index: None }\n     }\n@@ -33,7 +33,7 @@ impl<'gcx, 'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n-    pub fn field_ty(self, tcx: TyCtxt<'gcx, 'tcx>, f: &Field) -> Ty<'tcx> {\n+    pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: &Field) -> Ty<'tcx> {\n         let answer = match self.ty.sty {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n@@ -56,7 +56,7 @@ impl<'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Convenience wrapper around `projection_ty_core` for\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n-    pub fn projection_ty(self, tcx: TyCtxt<'gcx, 'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n+    pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n         self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n     }\n \n@@ -67,7 +67,7 @@ impl<'gcx, 'tcx> PlaceTy<'tcx> {\n     /// (which should be trivial when `T` = `Ty`).\n     pub fn projection_ty_core<V, T>(\n         self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n@@ -118,7 +118,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> PlaceTy<'tcx>\n+    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n@@ -139,7 +139,7 @@ pub enum RvalueInitializationState {\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>\n+    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> Ty<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n@@ -221,7 +221,7 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl<'tcx> Operand<'tcx> {\n-    pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>\n+    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> Ty<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n@@ -234,12 +234,7 @@ impl<'tcx> Operand<'tcx> {\n }\n \n impl<'tcx> BinOp {\n-    pub fn ty<'gcx>(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        lhs_ty: Ty<'tcx>,\n-        rhs_ty: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx>, lhs_ty: Ty<'tcx>, rhs_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // FIXME: handle SIMD correctly\n         match self {\n             &BinOp::Add | &BinOp::Sub | &BinOp::Mul | &BinOp::Div | &BinOp::Rem |"}, {"sha": "d89cf8eb3e843aa59117a6565640626bf8bafd3b", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -48,11 +48,11 @@ pub struct AutoTraitInfo<'cx> {\n }\n \n pub struct AutoTraitFinder<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'tcx> AutoTraitFinder<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n         AutoTraitFinder { tcx }\n     }\n \n@@ -79,7 +79,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         ty: Ty<'tcx>,\n         orig_env: ty::ParamEnv<'tcx>,\n         trait_did: DefId,\n-        auto_trait_callback: impl for<'i> Fn(&InferCtxt<'_, 'tcx, 'i>, AutoTraitInfo<'i>) -> A,\n+        auto_trait_callback: impl Fn(&InferCtxt<'_, 'tcx>, AutoTraitInfo<'tcx>) -> A,\n     ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n \n@@ -270,16 +270,16 @@ impl AutoTraitFinder<'tcx> {\n     // the final synthesized generics: we don't want our generated docs page to contain something\n     // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n     // 'user_env', which only holds the predicates that will actually be displayed to the user.\n-    fn evaluate_predicates<'b, 'c>(\n+    fn evaluate_predicates(\n         &self,\n-        infcx: &InferCtxt<'b, 'tcx, 'c>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         trait_did: DefId,\n-        ty: Ty<'c>,\n-        param_env: ty::ParamEnv<'c>,\n-        user_env: ty::ParamEnv<'c>,\n-        fresh_preds: &mut FxHashSet<ty::Predicate<'c>>,\n+        ty: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        user_env: ty::ParamEnv<'tcx>,\n+        fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         only_projections: bool,\n-    ) -> Option<(ty::ParamEnv<'c>, ty::ParamEnv<'c>)> {\n+    ) -> Option<(ty::ParamEnv<'tcx>, ty::ParamEnv<'tcx>)> {\n         let tcx = infcx.tcx;\n \n         let mut select = SelectionContext::with_negative(&infcx, true);\n@@ -617,20 +617,14 @@ impl AutoTraitFinder<'tcx> {\n         }\n     }\n \n-    fn evaluate_nested_obligations<\n-        'b,\n-        'c,\n-        'd,\n-        'cx,\n-        T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>,\n-    >(\n+    fn evaluate_nested_obligations(\n         &self,\n         ty: Ty<'_>,\n-        nested: T,\n-        computed_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n-        fresh_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n-        predicates: &'b mut VecDeque<ty::PolyTraitPredicate<'cx>>,\n-        select: &mut SelectionContext<'c, 'd, 'cx>,\n+        nested: impl Iterator<Item = Obligation<'tcx, ty::Predicate<'tcx>>>,\n+        computed_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n+        fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n+        predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,\n+        select: &mut SelectionContext<'_, 'tcx>,\n         only_projections: bool,\n     ) -> bool {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n@@ -822,23 +816,23 @@ impl AutoTraitFinder<'tcx> {\n         return true;\n     }\n \n-    pub fn clean_pred<'c, 'd, 'cx>(\n+    pub fn clean_pred(\n         &self,\n-        infcx: &InferCtxt<'c, 'd, 'cx>,\n-        p: ty::Predicate<'cx>,\n-    ) -> ty::Predicate<'cx> {\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        p: ty::Predicate<'tcx>,\n+    ) -> ty::Predicate<'tcx> {\n         infcx.freshen(p)\n     }\n }\n \n // Replaces all ReVars in a type with ty::Region's, using the provided map\n-pub struct RegionReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+pub struct RegionReplacer<'a, 'tcx> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n "}, {"sha": "0c7c94b684a9fc43ec98825ec36dd5e80fc75d84", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -29,8 +29,8 @@ impl FulfillmentContext<'tcx> {\n }\n \n fn in_environment(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    obligation: PredicateObligation<'tcx>\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    obligation: PredicateObligation<'tcx>,\n ) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n     assert!(!infcx.is_in_snapshot());\n     let obligation = infcx.resolve_vars_if_possible(&obligation);\n@@ -52,7 +52,7 @@ fn in_environment(\n impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn normalize_projection_type(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         _param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         _cause: ObligationCause<'tcx>,\n@@ -62,15 +62,15 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n     fn register_predicate_obligation(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     ) {\n         self.obligations.insert(in_environment(infcx, obligation));\n     }\n \n     fn select_all_or_error(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         self.select_where_possible(infcx)?;\n \n@@ -89,7 +89,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n     fn select_where_possible(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         let mut errors = Vec::new();\n         let mut next_round = FxHashSet::default();"}, {"sha": "bb4095333f19db96bc17894e2f426d2f00c5eced", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -19,7 +19,7 @@ use crate::ty::fold::TypeFoldable;\n /// obligations *could be* resolved if we wanted to.\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n pub fn codegen_fulfill_obligation<'tcx>(\n-    ty: TyCtxt<'tcx, 'tcx>,\n+    ty: TyCtxt<'tcx>,\n     (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n ) -> Vtable<'tcx, ()> {\n     // Remove any references to regions; this helps improve caching.\n@@ -73,7 +73,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n     })\n }\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Monomorphizes a type from the AST by first applying the\n     /// in-scope substitutions and then normalizing any associated\n     /// types.\n@@ -115,19 +115,19 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n \n // # Global Cache\n \n-pub struct ProjectionCache<'gcx> {\n-    data: PhantomData<&'gcx ()>\n+pub struct ProjectionCache<'tcx> {\n+    data: PhantomData<&'tcx ()>,\n }\n \n-impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n-    type Key = Ty<'gcx>;\n-    type Value = Ty<'gcx>;\n+impl<'tcx> DepTrackingMapConfig for ProjectionCache<'tcx> {\n+    type Key = Ty<'tcx>;\n+    type Value = Ty<'tcx>;\n     fn to_dep_kind() -> DepKind {\n         DepKind::TraitSelect\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Finishes processes any obligations that remain in the\n     /// fulfillment context, and then returns the result with all type\n     /// variables removed and regions erased. Because this is intended\n@@ -137,11 +137,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// type inference variables that appear in `result` to be\n     /// unified, and hence we need to process those obligations to get\n     /// the complete picture of the type.\n-    fn drain_fulfillment_cx_or_panic<T>(&self,\n-                                        fulfill_cx: &mut FulfillmentContext<'tcx>,\n-                                        result: &T)\n-                                        -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    fn drain_fulfillment_cx_or_panic<T>(\n+        &self,\n+        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+        result: &T,\n+    ) -> T::Lifted\n+    where\n+        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n     {\n         debug!(\"drain_fulfillment_cx_or_panic()\");\n "}, {"sha": "d8087af60acdf3abe8be2523ff50822434cde0d4", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -48,8 +48,8 @@ pub fn add_placeholder_note(err: &mut errors::DiagnosticBuilder<'_>) {\n /// If there are types that satisfy both impls, invokes `on_overlap`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n-pub fn overlapping_impls<'gcx, F1, F2, R>(\n-    tcx: TyCtxt<'gcx, 'gcx>,\n+pub fn overlapping_impls<'tcx, F1, F2, R>(\n+    tcx: TyCtxt<'tcx>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n@@ -87,11 +87,11 @@ where\n     })\n }\n \n-fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-                                       param_env: ty::ParamEnv<'tcx>,\n-                                       impl_def_id: DefId)\n-                                       -> ty::ImplHeader<'tcx>\n-{\n+fn with_fresh_ty_vars<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl_def_id: DefId,\n+) -> ty::ImplHeader<'tcx> {\n     let tcx = selcx.tcx();\n     let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n@@ -111,8 +111,8 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn overlap<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     a_def_id: DefId,\n     b_def_id: DefId,\n ) -> Option<OverlapResult<'tcx>> {\n@@ -122,7 +122,7 @@ fn overlap<'cx, 'gcx, 'tcx>(\n }\n \n fn overlap_within_probe(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     a_def_id: DefId,\n     b_def_id: DefId,\n     snapshot: &CombinedSnapshot<'_, 'tcx>,\n@@ -183,8 +183,8 @@ fn overlap_within_probe(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-pub fn trait_ref_is_knowable<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn trait_ref_is_knowable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> Option<Conflict> {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n@@ -229,8 +229,8 @@ pub fn trait_ref_is_knowable<'gcx, 'tcx>(\n     }\n }\n \n-pub fn trait_ref_is_local_or_fundamental<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn trait_ref_is_local_or_fundamental<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> bool {\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n@@ -247,8 +247,8 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn orphan_check<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     impl_def_id: DefId,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n@@ -355,7 +355,7 @@ pub fn orphan_check<'gcx, 'tcx>(\n /// Note that this function is never called for types that have both type\n /// parameters and inference variables.\n fn orphan_check_trait_ref<'tcx>(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     trait_ref: ty::TraitRef<'tcx>,\n     in_crate: InCrate,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n@@ -431,7 +431,7 @@ fn orphan_check_trait_ref<'tcx>(\n     }\n }\n \n-fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n+fn uncovered_tys<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(ty) {\n@@ -450,7 +450,7 @@ fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n     }\n }\n \n-fn ty_is_local(tcx: TyCtxt<'_, '_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n+fn ty_is_local(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     ty_is_local_constructor(ty, in_crate) ||\n         fundamental_ty(ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }"}, {"sha": "b96126c7b67354e0c1b3a90d53444bdb6afe9582", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use super::{ObligationCause, PredicateObligation};\n pub trait TraitEngine<'tcx>: 'tcx {\n     fn normalize_projection_type(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n@@ -20,7 +20,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     /// parameters (except for `Self`).\n     fn register_bound(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n@@ -40,18 +40,18 @@ pub trait TraitEngine<'tcx>: 'tcx {\n \n     fn register_predicate_obligation(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     );\n \n     fn select_all_or_error(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n \n     fn select_where_possible(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n@@ -60,15 +60,15 @@ pub trait TraitEngine<'tcx>: 'tcx {\n pub trait TraitEngineExt<'tcx> {\n     fn register_predicate_obligations(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     );\n }\n \n impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n     fn register_predicate_obligations(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     ) {\n         for obligation in obligations {\n@@ -78,7 +78,7 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n }\n \n impl dyn TraitEngine<'tcx> {\n-    pub fn new(tcx: TyCtxt<'_, 'tcx>) -> Box<Self> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Box<Self> {\n         if tcx.sess.opts.debugging_opts.chalk {\n             Box::new(ChalkFulfillmentContext::new())\n         } else {"}, {"sha": "42bde3563492f497df085dc35ddb340f6ae84273", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -38,7 +38,7 @@ use syntax::ast;\n use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n                                      errors: &[FulfillmentError<'tcx>],\n                                      body_id: Option<hir::BodyId>,\n@@ -1249,10 +1249,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n-        fn build_fn_sig_string<'gcx, 'tcx>(\n-            tcx: TyCtxt<'gcx, 'tcx>,\n-            trait_ref: &ty::TraitRef<'tcx>,\n-        ) -> String {\n+        fn build_fn_sig_string<'tcx>(tcx: TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n@@ -1296,7 +1293,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn recursive_type_with_infinite_size_error(self,\n                                                    type_def_id: DefId)\n                                                    -> DiagnosticBuilder<'tcx>\n@@ -1342,7 +1339,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>,\n                               body_id: Option<hir::BodyId>) {\n         // Unable to successfully determine, probably means\n@@ -1454,13 +1451,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         pred: ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n+        struct ParamToVarFolder<'a, 'tcx: 'a> {\n+            infcx: &'a InferCtxt<'a, 'tcx>,\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n         }\n \n-        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.infcx.tcx }\n+        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Param(ty::ParamTy {name, .. }) = ty.sty {"}, {"sha": "5e2c949c7d8d60a35acb0e45a038ef78a62092b7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -68,7 +68,7 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n+impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n@@ -95,8 +95,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     /// Attempts to select obligations using `selcx`.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+    fn select(\n+        &mut self,\n+        selcx: &mut SelectionContext<'a, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();\n@@ -143,13 +145,13 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// `SomeTrait` or a where-clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    fn normalize_projection_type<'a, 'gcx>(&mut self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                 param_env: ty::ParamEnv<'tcx>,\n-                                 projection_ty: ty::ProjectionTy<'tcx>,\n-                                 cause: ObligationCause<'tcx>)\n-                                 -> Ty<'tcx>\n-    {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx> {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n \n@@ -172,10 +174,11 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         normalized_ty\n     }\n \n-    fn register_predicate_obligation<'a, 'gcx>(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                     obligation: PredicateObligation<'tcx>)\n-    {\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_vars_if_possible(&obligation);\n@@ -190,11 +193,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         });\n     }\n \n-    fn select_all_or_error<'a, 'gcx>(\n+    fn select_all_or_error(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>\n-    ) -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         self.select_where_possible(infcx)?;\n \n         let errors: Vec<_> =\n@@ -209,10 +211,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         }\n     }\n \n-    fn select_where_possible<'a, 'gcx>(&mut self,\n-                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                             -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n@@ -222,9 +224,9 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     }\n }\n \n-struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n-    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n-    register_region_obligations: bool\n+struct FulfillProcessor<'a, 'b: 'a, 'tcx: 'b> {\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    register_region_obligations: bool,\n }\n \n fn mk_pending(os: Vec<PredicateObligation<'tcx>>) -> Vec<PendingPredicateObligation<'tcx>> {\n@@ -234,7 +236,7 @@ fn mk_pending(os: Vec<PredicateObligation<'tcx>>) -> Vec<PendingPredicateObligat\n     }).collect()\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n+impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     type Obligation = PendingPredicateObligation<'tcx>;\n     type Error = FulfillmentErrorCode<'tcx>;\n \n@@ -514,9 +516,10 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n }\n \n /// Returns the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n-{\n+fn trait_ref_type_vars<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    t: ty::PolyTraitRef<'tcx>,\n+) -> Vec<Ty<'tcx>> {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n      .map(|t| selcx.infcx().resolve_vars_if_possible(&t))"}, {"sha": "f5c91a77517cdc2e676f2b6a67b627de22013fcb", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -140,7 +140,7 @@ pub struct ObligationCause<'tcx> {\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n-    pub fn span<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Span {\n+    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. } |\n             ObligationCauseCode::MainFunctionType |\n@@ -363,9 +363,9 @@ impl<'tcx> DomainGoal<'tcx> {\n }\n \n impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal<'gcx>(\n+    pub fn from_poly_domain_goal(\n         domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> GoalKind<'tcx> {\n         match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),\n@@ -643,8 +643,8 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n     def_id: DefId,\n@@ -711,7 +711,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n }\n \n fn do_normalize_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     region_context: DefId,\n     cause: ObligationCause<'tcx>,\n     elaborated_env: ty::ParamEnv<'tcx>,\n@@ -796,7 +796,7 @@ fn do_normalize_predicates<'tcx>(\n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     region_context: DefId,\n     unnormalized_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -904,14 +904,15 @@ pub fn normalize_param_env_or_error<'tcx>(\n     )\n }\n \n-pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+pub fn fully_normalize<'a, 'tcx, T>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n     mut fulfill_cx: FulfillmentContext<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    value: &T)\n-    -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n+    value: &T,\n+) -> Result<T, Vec<FulfillmentError<'tcx>>>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n     let selcx = &mut SelectionContext::new(infcx);\n@@ -937,7 +938,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n /// encountered an error or one of the predicates did not hold. Used\n /// when creating vtables to check for unsatisfiable methods.\n fn normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     predicates: Vec<ty::Predicate<'tcx>>,\n ) -> bool {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n@@ -966,7 +967,7 @@ fn normalize_and_test_predicates<'tcx>(\n }\n \n fn substitute_normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     key: (DefId, SubstsRef<'tcx>),\n ) -> bool {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n@@ -984,7 +985,7 @@ fn substitute_normalize_and_test_predicates<'tcx>(\n /// that come from `trait_ref`, including its supertraits.\n #[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n fn vtable_methods<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n     debug!(\"vtable_methods({:?})\", trait_ref);\n@@ -1185,7 +1186,7 @@ pub trait ExClauseFold<'tcx>\n where\n     Self: chalk_engine::context::Context + Clone,\n {\n-    fn fold_ex_clause_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(\n+    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n         ex_clause: &chalk_engine::ExClause<Self>,\n         folder: &mut F,\n     ) -> chalk_engine::ExClause<Self>;\n@@ -1204,18 +1205,18 @@ where\n     type LiftedDelayedLiteral: Debug + 'tcx;\n     type LiftedLiteral: Debug + 'tcx;\n \n-    fn lift_ex_clause_to_tcx<'gcx>(\n+    fn lift_ex_clause_to_tcx(\n         ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Option<Self::LiftedExClause>;\n \n-    fn lift_delayed_literal_to_tcx<'gcx>(\n+    fn lift_delayed_literal_to_tcx(\n         ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Option<Self::LiftedDelayedLiteral>;\n \n-    fn lift_literal_to_tcx<'gcx>(\n+    fn lift_literal_to_tcx(\n         ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Option<Self::LiftedLiteral>;\n }"}, {"sha": "cfd5cfa897daf23ce4f8be6318dd30310a000f48", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -83,7 +83,7 @@ pub enum MethodViolationCode {\n     UndispatchableReceiver,\n }\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the object safety violations that affect\n     /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n@@ -702,6 +702,6 @@ impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     }\n }\n \n-pub(super) fn is_object_safe_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId) -> bool {\n+pub(super) fn is_object_safe_provider<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> bool {\n     tcx.object_safety_violations(trait_def_id).is_empty()\n }"}, {"sha": "0a42b6b46f2c90b17b56974567014821226aac9d", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -36,7 +36,7 @@ impl OnUnimplementedNote {\n }\n \n fn parse_error(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     span: Span,\n     message: &str,\n     label: &str,\n@@ -52,9 +52,9 @@ fn parse_error(\n     ErrorReported\n }\n \n-impl<'gcx, 'tcx> OnUnimplementedDirective {\n+impl<'tcx> OnUnimplementedDirective {\n     fn parse(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n         items: &[NestedMetaItem],\n         span: Span,\n@@ -134,7 +134,7 @@ impl<'gcx, 'tcx> OnUnimplementedDirective {\n     }\n \n     pub fn of_item(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n         impl_def_id: DefId,\n     ) -> Result<Option<Self>, ErrorReported> {\n@@ -166,7 +166,7 @@ impl<'gcx, 'tcx> OnUnimplementedDirective {\n \n     pub fn evaluate(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n         options: &[(Symbol, Option<String>)],\n     ) -> OnUnimplementedNote {\n@@ -214,9 +214,9 @@ impl<'gcx, 'tcx> OnUnimplementedDirective {\n     }\n }\n \n-impl<'gcx, 'tcx> OnUnimplementedFormatString {\n+impl<'tcx> OnUnimplementedFormatString {\n     fn try_parse(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n         from: LocalInternedString,\n         err_sp: Span,\n@@ -228,7 +228,7 @@ impl<'gcx, 'tcx> OnUnimplementedFormatString {\n \n     fn verify(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n         span: Span,\n     ) -> Result<(), ErrorReported> {\n@@ -274,7 +274,7 @@ impl<'gcx, 'tcx> OnUnimplementedFormatString {\n \n     pub fn format(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n         options: &FxHashMap<Symbol, String>,\n     ) -> String {"}, {"sha": "d189bb231163eadfe377447f6fc7d4d96c774961", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 122, "deletions": 135, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -183,12 +183,10 @@ impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n ///\n /// If successful, this may result in additional obligations. Also returns\n /// the projection cache key used to track these additional obligations.\n-pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation: &PolyProjectionObligation<'tcx>)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-              MismatchedProjectionTypes<'tcx>>\n-{\n+pub fn poly_project_and_unify_type<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &PolyProjectionObligation<'tcx>,\n+) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n     debug!(\"poly_project_and_unify_type(obligation={:?})\",\n            obligation);\n \n@@ -210,12 +208,10 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n ///     <T as Trait>::U == V\n ///\n /// If successful, this may result in additional obligations.\n-fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation: &ProjectionObligation<'tcx>)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-              MismatchedProjectionTypes<'tcx>>\n-{\n+fn project_and_unify_type<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionObligation<'tcx>,\n+) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n \n@@ -253,26 +249,28 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n-pub fn normalize<'a, 'b, 'gcx, 'tcx, T>(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n-                                        param_env: ty::ParamEnv<'tcx>,\n-                                        cause: ObligationCause<'tcx>,\n-                                        value: &T)\n-                                        -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx>\n+pub fn normalize<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    value: &T,\n+) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     normalize_with_depth(selcx, param_env, cause, 0, value)\n }\n \n /// As `normalize`, but with a custom depth.\n-pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    value: &T)\n-    -> Normalized<'tcx, T>\n-\n-    where T : TypeFoldable<'tcx>\n+    value: &T,\n+) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n     let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth);\n@@ -287,21 +285,21 @@ pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n     }\n }\n \n-struct AssocTypeNormalizer<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n-    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+struct AssocTypeNormalizer<'a, 'b: 'a, 'tcx: 'b> {\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n-    fn new(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>,\n-           cause: ObligationCause<'tcx>,\n-           depth: usize)\n-           -> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx>\n-    {\n+impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n+    fn new(\n+        selcx: &'a mut SelectionContext<'b, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        depth: usize,\n+    ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         AssocTypeNormalizer {\n             selcx,\n             param_env,\n@@ -322,8 +320,8 @@ impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n         self.selcx.tcx()\n     }\n \n@@ -456,15 +454,14 @@ impl<'tcx,T> Normalized<'tcx,T> {\n /// there are unresolved type variables in the projection, we will\n /// substitute a fresh type variable `$X` and generate a new\n /// obligation `<T as Trait>::Item == $X` for later.\n-pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n-    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+pub fn normalize_projection_type<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>)\n-    -> Ty<'tcx>\n-{\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n     opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth,\n                                   obligations)\n         .unwrap_or_else(move || {\n@@ -501,15 +498,14 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n /// often immediately appended to another obligations vector. So now this\n /// function takes an obligations vector and appends to it directly, which is\n /// slightly uglier but avoids the need for an extra short-lived allocation.\n-fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n-    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>)\n-    -> Option<Ty<'tcx>>\n-{\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Option<Ty<'tcx>> {\n     let infcx = selcx.infcx();\n \n     let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n@@ -705,9 +701,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n /// If there are unresolved type variables, then we need to include\n /// any subobligations that bind them, at least until those type\n /// variables are fully resolved.\n-fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                                                 result: &NormalizedTy<'tcx>)\n-                                                 -> NormalizedTy<'tcx> {\n+fn prune_cache_value_obligations<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    result: &NormalizedTy<'tcx>,\n+) -> NormalizedTy<'tcx> {\n     if infcx.unresolved_type_vars(&result.value).is_none() {\n         return NormalizedTy { value: result.value, obligations: vec![] };\n     }\n@@ -763,14 +760,13 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// that may yet turn out to be wrong. This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n /// can occur yet. But it seems risky at best.\n-fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> PredicateObligation<'tcx>\n-{\n+    depth: usize,\n+) -> PredicateObligation<'tcx> {\n     let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n     Obligation {\n         cause,\n@@ -799,13 +795,13 @@ fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n-fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                      param_env: ty::ParamEnv<'tcx>,\n-                                      projection_ty: ty::ProjectionTy<'tcx>,\n-                                      cause: ObligationCause<'tcx>,\n-                                      depth: usize)\n-                                      -> NormalizedTy<'tcx>\n-{\n+fn normalize_to_error<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+) -> NormalizedTy<'tcx> {\n     let trait_ref = projection_ty.trait_ref(selcx.tcx()).to_poly_trait_ref();\n     let trait_obligation = Obligation { cause,\n                                         recursion_depth: depth,\n@@ -836,7 +832,7 @@ struct Progress<'tcx> {\n }\n \n impl<'tcx> Progress<'tcx> {\n-    fn error<'gcx>(tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n+    fn error(tcx: TyCtxt<'tcx>) -> Self {\n         Progress {\n             ty: tcx.types.err,\n             obligations: vec![],\n@@ -861,11 +857,10 @@ impl<'tcx> Progress<'tcx> {\n ///\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n-fn project_type<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>)\n-    -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n-{\n+fn project_type<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n     debug!(\"project(obligation={:?})\",\n            obligation);\n \n@@ -925,12 +920,12 @@ fn project_type<'cx, 'gcx, 'tcx>(\n /// The first thing we have to do is scan through the parameter\n /// environment to see whether there are any projection predicates\n /// there that can answer this question.\n-fn assemble_candidates_from_param_env<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn assemble_candidates_from_param_env<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n@@ -950,12 +945,12 @@ fn assemble_candidates_from_param_env<'cx, 'gcx, 'tcx>(\n /// ```\n ///\n /// Here, for example, we could conclude that the result is `i32`.\n-fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     let tcx = selcx.tcx();\n@@ -986,14 +981,15 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n                                         bounds)\n }\n \n-fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n-    env_predicates: I)\n-    where I: IntoIterator<Item=ty::Predicate<'tcx>>\n+    env_predicates: I,\n+) where\n+    I: IntoIterator<Item = ty::Predicate<'tcx>>,\n {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\",\n            obligation);\n@@ -1029,12 +1025,12 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n     }\n }\n \n-fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn assemble_candidates_from_impls<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n@@ -1177,13 +1173,12 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     });\n }\n \n-fn confirm_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate: ProjectionTyCandidate<'tcx>)\n-    -> Progress<'tcx>\n-{\n+    candidate: ProjectionTyCandidate<'tcx>,\n+) -> Progress<'tcx> {\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\",\n            candidate,\n            obligation);\n@@ -1200,13 +1195,12 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n     }\n }\n \n-fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_select_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    vtable: Selection<'tcx>)\n-    -> Progress<'tcx>\n-{\n+    vtable: Selection<'tcx>,\n+) -> Progress<'tcx> {\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),\n@@ -1230,12 +1224,11 @@ fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     }\n }\n \n-fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>)\n-    -> Progress<'tcx>\n-{\n+fn confirm_object_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+) -> Progress<'tcx> {\n     let self_ty = obligation_trait_ref.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n@@ -1295,12 +1288,11 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     confirm_param_env_candidate(selcx, obligation, env_predicate)\n }\n \n-fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_generator_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let gen_sig = vtable.substs.poly_sig(vtable.generator_def_id, selcx.tcx());\n     let Normalized {\n         value: gen_sig,\n@@ -1348,12 +1340,11 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n-fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized {\n@@ -1370,12 +1361,11 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n-fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_closure_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n     let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n@@ -1402,13 +1392,12 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n-fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_callable_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: ty::PolyFnSig<'tcx>,\n-    flag: util::TupleArgumentsFlag)\n-    -> Progress<'tcx>\n-{\n+    flag: util::TupleArgumentsFlag,\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n     debug!(\"confirm_callable_candidate({:?},{:?})\",\n@@ -1437,8 +1426,8 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     confirm_param_env_candidate(selcx, obligation, predicate)\n }\n \n-fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_param_env_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n ) -> Progress<'tcx> {\n@@ -1478,12 +1467,11 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     }\n }\n \n-fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+fn confirm_impl_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let VtableImplData { impl_def_id, substs, nested } = impl_vtable;\n \n     let tcx = selcx.tcx();\n@@ -1521,12 +1509,11 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n-    selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n+fn assoc_ty_def<'cx, 'tcx>(\n+    selcx: &SelectionContext<'cx, 'tcx>,\n     impl_def_id: DefId,\n-    assoc_ty_def_id: DefId)\n-    -> specialization_graph::NodeItem<ty::AssocItem>\n-{\n+    assoc_ty_def_id: DefId,\n+) -> specialization_graph::NodeItem<ty::AssocItem> {\n     let tcx = selcx.tcx();\n     let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1608,11 +1595,11 @@ pub struct ProjectionCacheKey<'tcx> {\n     ty: ty::ProjectionTy<'tcx>\n }\n \n-impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n-    pub fn from_poly_projection_predicate(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-                                          predicate: &ty::PolyProjectionPredicate<'tcx>)\n-                                          -> Option<Self>\n-    {\n+impl<'cx, 'tcx> ProjectionCacheKey<'tcx> {\n+    pub fn from_poly_projection_predicate(\n+        selcx: &mut SelectionContext<'cx, 'tcx>,\n+        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<Self> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use"}, {"sha": "46403a38c99bd14bef7887b197db62e0ff5adc84", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,7 +6,7 @@ use syntax::source_map::Span;\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt};\n \n-impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n     /// of \"kinds\" (types, regions) that must be outlive the execution\n     /// of the destructor. These basically correspond to data that the\n@@ -85,7 +85,7 @@ pub struct DropckOutlivesResult<'tcx> {\n }\n \n impl<'tcx> DropckOutlivesResult<'tcx> {\n-    pub fn report_overflows(&self, tcx: TyCtxt<'_, 'tcx>, span: Span, ty: Ty<'tcx>) {\n+    pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n         if let Some(overflow_ty) = self.overflows.iter().next() {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n@@ -101,7 +101,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n \n     pub fn into_kinds_reporting_overflows(\n         self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> Vec<Kind<'tcx>> {\n@@ -185,7 +185,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n-pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's"}, {"sha": "031e3424847862e0b457d8506083a3c2dfcbfb1b", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -3,7 +3,7 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::traits::{EvaluationResult, PredicateObligation, SelectionContext,\n              TraitQueryMode, OverflowError};\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)\n     /// in the given `ParamEnv`.\n     pub fn predicate_may_hold("}, {"sha": "50476721e8247897f11be89ee9d1e22ebde329d5", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n \n-impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Normalize `value` in the context of the inference context,\n     /// yielding a resulting type, or an error if `value` cannot be\n     /// normalized. If you don't care about regions, you should prefer\n@@ -73,17 +73,17 @@ pub struct NormalizationResult<'tcx> {\n     pub normalized_ty: Ty<'tcx>,\n }\n \n-struct QueryNormalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct QueryNormalizer<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n     cause: &'cx ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     error: bool,\n     anon_depth: usize,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "3218ff062ce5ebc508a71a554a7eab6435fd2d0c", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,7 +10,7 @@\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Erase the regions in `value` and then fully normalize all the\n     /// types found within. The result will also have regions erased.\n     ///\n@@ -63,12 +63,12 @@ impl<'tcx> TyCtxt<'tcx, 'tcx> {\n }\n \n struct NormalizeAfterErasingRegionsFolder<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl TypeFolder<'tcx, 'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+impl TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n "}, {"sha": "40bd18738b52810da04def083205e48dc46a0b4d", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce\n     /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before"}, {"sha": "05a4d4336a7c260a2cf0f724e5708bf728194342", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,25 +21,25 @@ impl<'tcx> AscribeUserType<'tcx> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx> {\n+impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'gcx, 'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }"}, {"sha": "72550e23460e65ed805d80143caeeeeee4301484", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,9 +14,9 @@ pub struct CustomTypeOp<F, G> {\n }\n \n impl<F, G> CustomTypeOp<F, G> {\n-    pub fn new<'gcx, 'tcx, R>(closure: F, description: G) -> Self\n+    pub fn new<'tcx, R>(closure: F, description: G) -> Self\n     where\n-        F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n+        F: FnOnce(&InferCtxt<'_, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n         G: Fn() -> String,\n     {\n         CustomTypeOp {\n@@ -26,9 +26,9 @@ impl<F, G> CustomTypeOp<F, G> {\n     }\n }\n \n-impl<'gcx, 'tcx, F, R, G> super::TypeOp<'gcx, 'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n where\n-    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'gcx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n+    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n     G: Fn() -> String,\n {\n     type Output = R;\n@@ -38,7 +38,7 @@ where\n     /// (they will be given over to the NLL region solver).\n     fn fully_perform(\n         self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n         if cfg!(debug_assertions) {\n             info!(\"fully_perform({:?})\", self);\n@@ -59,8 +59,8 @@ where\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n-fn scrape_region_constraints<'gcx, 'tcx, R>(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+fn scrape_region_constraints<'tcx, R>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<(R, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n     let mut fulfill_cx = TraitEngine::new(infcx.tcx);"}, {"sha": "e8ec304f918a3d97fb8acf53b301a56e31c114a4", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,11 +14,11 @@ impl<'tcx> Eq<'tcx> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n+impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'gcx, 'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Eq<'tcx>>,\n     ) -> Option<Self::QueryResponse> {\n         if key.value.a == key.value.b {\n@@ -29,14 +29,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_eq(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }"}, {"sha": "3beb4d64656c547d55e8e1b44949ad24215f22cc", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,20 +14,20 @@ impl<'tcx> ImpliedOutlivesBounds<'tcx> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<'tcx> {\n+impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n     type QueryResponse = Vec<OutlivesBound<'tcx>>;\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'gcx, 'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         // FIXME this `unchecked_map` is only necessary because the\n         // query is defined as taking a `ParamEnvAnd<Ty>`; it should\n         // take a `ImpliedOutlivesBounds` instead\n@@ -40,7 +40,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, Self::QueryResponse>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n         v\n     }"}, {"sha": "b298edfec594432d1a06b58699b58f0bf53a66a0", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -23,15 +23,15 @@ pub mod subtype;\n /// \"Type ops\" are used in NLL to perform some particular action and\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n-pub trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n+pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     type Output;\n \n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n     fn fully_perform(\n         self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)>;\n }\n \n@@ -44,16 +44,14 @@ pub trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n /// which produces the resulting query region constraints.\n ///\n /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n-pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n-    fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'gcx>\n-{\n-    type QueryResponse: TypeFoldable<'tcx> + Lift<'gcx>;\n+pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'tcx> {\n+    type QueryResponse: TypeFoldable<'tcx> + Lift<'tcx>;\n \n     /// Give query the option for a simple fast path that never\n     /// actually hits the tcx cache lookup etc. Return `Some(r)` with\n     /// a final result or `None` to do the full path.\n     fn try_fast_path(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse>;\n \n@@ -64,29 +62,29 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     /// bad, because it would create subregion relationships that are\n     /// not captured in the return value.\n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>>;\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>>;\n \n     /// Casts a lifted query result (which is in the gcx lifetime)\n     /// into the tcx lifetime. This is always just an identity cast,\n     /// but the generic code doesn't realize it -- put another way, in\n-    /// the generic code, we have a `Lifted<'gcx, Self::QueryResponse>`\n+    /// the generic code, we have a `Lifted<'tcx, Self::QueryResponse>`\n     /// and we want to convert that to a `Self::QueryResponse`. This is\n     /// not a priori valid, so we can't do it -- but in practice, it\n     /// is always a no-op (e.g., the lifted form of a type,\n-    /// `Ty<'gcx>`, is a subtype of `Ty<'tcx>`). So we have to push\n+    /// `Ty<'tcx>`, is a subtype of `Ty<'tcx>`). So we have to push\n     /// the operation into the impls that know more specifically what\n     /// `QueryResponse` is. This operation would (maybe) be nicer with\n     /// something like HKTs or GATs, since then we could make\n-    /// `QueryResponse` parametric and `'gcx` and `'tcx` etc.\n+    /// `QueryResponse` parametric and `'tcx` and `'tcx` etc.\n     fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResponse<'gcx, Self::QueryResponse>,\n+        lifted_query_result: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>>;\n \n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n     ) -> Fallible<Self::QueryResponse> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n@@ -133,15 +131,15 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, Q> TypeOp<'gcx, 'tcx> for ParamEnvAnd<'tcx, Q>\n+impl<'tcx, Q> TypeOp<'tcx> for ParamEnvAnd<'tcx, Q>\n where\n-    Q: QueryTypeOp<'gcx, 'tcx>,\n+    Q: QueryTypeOp<'tcx>,\n {\n     type Output = Q::QueryResponse;\n \n     fn fully_perform(\n         self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n         let mut qrc = vec![];\n         let r = Q::fully_perform_into(self, infcx, &mut qrc)?;"}, {"sha": "5a768d9d58fcda1f8ebcf9bd8723b51a8aa48e91", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -18,13 +18,13 @@ where\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, T> super::QueryTypeOp<'gcx, 'tcx> for Normalize<T>\n+impl<'tcx, T> super::QueryTypeOp<'tcx> for Normalize<T>\n where\n-    T: Normalizable<'gcx, 'tcx>,\n+    T: Normalizable<'tcx>,\n {\n     type QueryResponse = T;\n \n-    fn try_fast_path(_tcx: TyCtxt<'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n+    fn try_fast_path(_tcx: TyCtxt<'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n         if !key.value.value.has_projections() {\n             Some(key.value.value)\n         } else {\n@@ -33,99 +33,87 @@ where\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, T>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, T>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, T>> {\n         T::shrink_to_tcx_lifetime(v)\n     }\n }\n \n-pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx> + Copy {\n+pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx> + Copy {\n     fn type_op_method(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>>;\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>>;\n \n-    /// Converts from the `'gcx` (lifted) form of `Self` into the `tcx`\n+    /// Converts from the `'tcx` (lifted) form of `Self` into the `tcx`\n     /// form of `Self`.\n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>>;\n }\n \n-impl Normalizable<'gcx, 'tcx> for Ty<'tcx>\n-where\n-    'gcx: 'tcx,\n-{\n+impl Normalizable<'tcx> for Ty<'tcx> {\n     fn type_op_method(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }\n \n-impl Normalizable<'gcx, 'tcx> for ty::Predicate<'tcx>\n-where\n-    'gcx: 'tcx,\n-{\n+impl Normalizable<'tcx> for ty::Predicate<'tcx> {\n     fn type_op_method(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }\n \n-impl Normalizable<'gcx, 'tcx> for ty::PolyFnSig<'tcx>\n-where\n-    'gcx: 'tcx,\n-{\n+impl Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n     fn type_op_method(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }\n \n-impl Normalizable<'gcx, 'tcx> for ty::FnSig<'tcx>\n-where\n-    'gcx: 'tcx,\n-{\n+impl Normalizable<'tcx> for ty::FnSig<'tcx> {\n     fn type_op_method(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }"}, {"sha": "d4b36356ffb06bc532a12c8cc2adc53f1a9fbca5", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,14 +15,11 @@ impl<'tcx> DropckOutlives<'tcx> {\n     }\n }\n \n-impl super::QueryTypeOp<'gcx, 'tcx> for DropckOutlives<'tcx>\n-where\n-    'gcx: 'tcx,\n-{\n+impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n     type QueryResponse = DropckOutlivesResult<'tcx>;\n \n     fn try_fast_path(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n@@ -33,9 +30,9 @@ where\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         // Subtle: note that we are not invoking\n         // `infcx.at(...).dropck_outlives(...)` here, but rather the\n         // underlying `dropck_outlives` query. This same underlying\n@@ -58,7 +55,7 @@ where\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResponse<'gcx, Self::QueryResponse>,\n+        lifted_query_result: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n         lifted_query_result\n     }"}, {"sha": "1efe66326d7249d2d130d25bd47d45257dfcbd81", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -13,11 +13,11 @@ impl<'tcx> ProvePredicate<'tcx> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n+impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         // Proving Sized, very often on \"obviously sized\" types like\n@@ -38,14 +38,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }"}, {"sha": "71c74999c27627509c05332231b9369d963bed72", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -17,10 +17,10 @@ impl<'tcx> Subtype<'tcx> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n+impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     type QueryResponse = ();\n \n-    fn try_fast_path(_tcx: TyCtxt<'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n+    fn try_fast_path(_tcx: TyCtxt<'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n         if key.value.sub == key.value.sup {\n             Some(())\n         } else {\n@@ -29,14 +29,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n+        tcx: TyCtxt<'tcx>,\n+        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_subtype(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n     ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }"}, {"sha": "329a243d2d7f2ee4f82d3ca3ad460a6c0ff7c392", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -50,15 +50,15 @@ use std::iter;\n use std::rc::Rc;\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n-pub struct SelectionContext<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+pub struct SelectionContext<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n     /// Freshener used specifically for entries on the obligation\n     /// stack. This ensures that all entries on the stack at one time\n     /// will have the same set of placeholder entries, which is\n     /// important for checking for trait bounds that recursively\n     /// require themselves.\n-    freshener: TypeFreshener<'cx, 'gcx, 'tcx>,\n+    freshener: TypeFreshener<'cx, 'tcx>,\n \n     /// If `true`, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n@@ -300,7 +300,7 @@ enum SelectionCandidate<'tcx> {\n \n impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n     type Lifted = SelectionCandidate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         Some(match *self {\n             BuiltinCandidate { has_nested } => BuiltinCandidate { has_nested },\n             ImplCandidate(def_id) => ImplCandidate(def_id),\n@@ -487,8 +487,8 @@ pub struct EvaluationCache<'tcx> {\n     hashmap: Lock<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>,\n }\n \n-impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n@@ -500,9 +500,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     pub fn intercrate(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n         mode: IntercrateMode,\n-    ) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+    ) -> SelectionContext<'cx, 'tcx> {\n         debug!(\"intercrate({:?})\", mode);\n         SelectionContext {\n             infcx,\n@@ -515,9 +515,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     pub fn with_negative(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n         allow_negative_impls: bool,\n-    ) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+    ) -> SelectionContext<'cx, 'tcx> {\n         debug!(\"with_negative({:?})\", allow_negative_impls);\n         SelectionContext {\n             infcx,\n@@ -530,9 +530,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     pub fn with_query_mode(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n         query_mode: TraitQueryMode,\n-    ) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+    ) -> SelectionContext<'cx, 'tcx> {\n         debug!(\"with_query_mode({:?})\", query_mode);\n         SelectionContext {\n             infcx,\n@@ -564,15 +564,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.intercrate_ambiguity_causes.take().unwrap_or(vec![])\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n+    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n+    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n         self.infcx\n     }\n \n@@ -3989,7 +3989,7 @@ impl<T: Clone> WithDepNode<T> {\n         }\n     }\n \n-    pub fn get(&self, tcx: TyCtxt<'_, '_>) -> T {\n+    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n         tcx.dep_graph.read_index(self.dep_node);\n         self.cached_value.clone()\n     }"}, {"sha": "3d47e94fb007c8c883103e39994ca355d2499637", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -69,12 +69,13 @@ pub struct OverlapError {\n /// through associated type projection. We deal with such cases by using\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n-pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                        param_env: ty::ParamEnv<'tcx>,\n-                                        source_impl: DefId,\n-                                        source_substs: SubstsRef<'tcx>,\n-                                        target_node: specialization_graph::Node)\n-                                        -> SubstsRef<'tcx> {\n+pub fn translate_substs<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    source_impl: DefId,\n+    source_substs: SubstsRef<'tcx>,\n+    target_node: specialization_graph::Node,\n+) -> SubstsRef<'tcx> {\n     debug!(\"translate_substs({:?}, {:?}, {:?}, {:?})\",\n            param_env, source_impl, source_substs, target_node);\n     let source_trait_ref = infcx.tcx\n@@ -110,7 +111,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// that impl, a less specialized impl, or the trait default,\n /// whichever applies.\n pub fn find_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     item: &ty::AssocItem,\n     substs: SubstsRef<'tcx>,\n@@ -150,7 +151,7 @@ pub fn find_associated_item<'tcx>(\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n pub(super) fn specializes<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     (impl1_def_id, impl2_def_id): (DefId, DefId),\n ) -> bool {\n     debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n@@ -209,11 +210,12 @@ pub(super) fn specializes<'tcx>(\n /// generics of `target_impl`, including both those needed to unify with\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n-fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                       param_env: ty::ParamEnv<'tcx>,\n-                                       source_trait_ref: ty::TraitRef<'tcx>,\n-                                       target_impl: DefId)\n-                                       -> Result<SubstsRef<'tcx>, ()> {\n+fn fulfill_implication<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    source_trait_ref: ty::TraitRef<'tcx>,\n+    target_impl: DefId,\n+) -> Result<SubstsRef<'tcx>, ()> {\n     debug!(\"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n            param_env, source_trait_ref, target_impl);\n \n@@ -286,7 +288,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n // Query provider for `specialization_graph_of`.\n pub(super) fn specialization_graph_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_id: DefId,\n ) -> &'tcx specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n@@ -390,7 +392,7 @@ pub(super) fn specialization_graph_provider<'tcx>(\n \n /// Recovers the \"impl X for Y\" signature from `impl_def_id` and returns it as a\n /// string.\n-fn to_pretty_impl_header(tcx: TyCtxt<'_, '_>, impl_def_id: DefId) -> Option<String> {\n+fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n     let trait_ref = if let Some(tr) = tcx.impl_trait_ref(impl_def_id) {"}, {"sha": "f736c5ef9b1c0fefb7f5c224332e1512870ac22e", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -81,9 +81,9 @@ enum Inserted {\n     ShouldRecurseOn(DefId),\n }\n \n-impl<'gcx, 'tcx> Children {\n+impl<'tcx> Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n-    fn insert_blindly(&mut self, tcx: TyCtxt<'gcx, 'tcx>, impl_def_id: DefId) {\n+    fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n             debug!(\"insert_blindly: impl_def_id={:?} sty={:?}\", impl_def_id, sty);\n@@ -97,7 +97,7 @@ impl<'gcx, 'tcx> Children {\n     /// Removes an impl from this set of children. Used when replacing\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n-    fn remove_existing(&mut self, tcx: TyCtxt<'gcx, 'tcx>, impl_def_id: DefId) {\n+    fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n@@ -116,7 +116,7 @@ impl<'gcx, 'tcx> Children {\n     /// specialization relationships.\n     fn insert(\n         &mut self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n         simplified_self: Option<SimplifiedType>,\n     ) -> Result<Inserted, OverlapError> {\n@@ -278,7 +278,7 @@ impl<I, J> Iterator for PotentialSiblings<I, J>\n     }\n }\n \n-impl<'gcx, 'tcx> Graph {\n+impl<'tcx> Graph {\n     pub fn new() -> Graph {\n         Graph {\n             parent: Default::default(),\n@@ -291,7 +291,7 @@ impl<'gcx, 'tcx> Graph {\n     /// information about the area of overlap is returned in the `Err`.\n     pub fn insert(\n         &mut self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n     ) -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n@@ -383,12 +383,7 @@ impl<'gcx, 'tcx> Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(\n-        &mut self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        parent: DefId,\n-        child: DefId,\n-    ) {\n+    pub fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n@@ -413,7 +408,7 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl<'gcx, 'tcx> Node {\n+impl<'tcx> Node {\n     pub fn is_from_trait(&self) -> bool {\n         match *self {\n             Node::Trait(..) => true,\n@@ -422,7 +417,7 @@ impl<'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'gcx, 'tcx>) -> ty::AssocItemsIterator<'gcx, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'tcx>) -> ty::AssocItemsIterator<'tcx> {\n         tcx.associated_items(self.def_id())\n     }\n \n@@ -471,18 +466,18 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'gcx, 'tcx> Ancestors<'gcx> {\n+impl<'tcx> Ancestors<'tcx> {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n     #[inline]\n     pub fn defs(\n         self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_item_name: Ident,\n         trait_item_kind: ty::AssocKind,\n         trait_def_id: DefId,\n-    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'gcx> + 'tcx {\n+    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'tcx> + 'tcx {\n         self.flat_map(move |node| {\n             use crate::ty::AssocKind::*;\n             node.items(tcx).filter(move |impl_item| match (trait_item_kind, impl_item.kind) {\n@@ -505,7 +500,7 @@ impl<'gcx, 'tcx> Ancestors<'gcx> {\n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n pub fn ancestors(\n-    tcx: TyCtxt<'tcx, '_>,\n+    tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n     start_from_impl: DefId,\n ) -> Ancestors<'tcx> {"}, {"sha": "129a400d28f4cb8fe3dab7e2bf30c584afaad0c8", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -446,7 +446,7 @@ impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n     type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             super::Unimplemented => Some(super::Unimplemented),\n             super::OutputTypeParameterMismatch(a, b, ref err) => {\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n     type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             super::ReturnNoExpression => Some(super::ReturnNoExpression),\n             super::MiscObligation => Some(super::MiscObligation),\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.parent_trait_ref).and_then(|trait_ref|\n             tcx.lift(&*self.parent_code)\n                .map(|code| traits::DerivedObligationCause {\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.code).map(|code| traits::ObligationCause {\n             span: self.span,\n             body_id: self.body_id,\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n // For codegen only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.clone() {\n             traits::VtableImpl(traits::VtableImplData {\n                 impl_def_id,\n@@ -691,7 +691,7 @@ EnumLiftImpl! {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n     type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.clauses).map(|clauses| {\n             traits::Environment {\n                 clauses,\n@@ -702,7 +702,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n \n impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n     type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.environment).and_then(|environment| {\n             tcx.lift(&self.goal).map(|goal| {\n                 traits::InEnvironment {\n@@ -721,7 +721,7 @@ where\n {\n     type Lifted = C::LiftedExClause;\n \n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n     }\n }\n@@ -733,7 +733,7 @@ where\n {\n     type Lifted = C::LiftedDelayedLiteral;\n \n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n     }\n }\n@@ -745,7 +745,7 @@ where\n {\n     type Lifted = C::LiftedLiteral;\n \n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n     }\n }\n@@ -754,7 +754,7 @@ where\n // TypeFoldable implementations.\n \n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         traits::Obligation {\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n@@ -887,7 +887,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))\n             .collect::<SmallVec<[_; 8]>>();\n@@ -900,7 +900,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = (**self).fold_with(folder);\n         folder.tcx().mk_goal(v)\n     }\n@@ -941,7 +941,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))\n             .collect::<SmallVec<[_; 8]>>();\n@@ -959,7 +959,7 @@ where\n     C::Substitution: Clone,\n     C::RegionConstraint: Clone,\n {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         <C as traits::ExClauseFold>::fold_ex_clause_with(\n             self,\n             folder,"}, {"sha": "b6a1ab9fe709a376eb29cff155d59ba2630eaaad", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 44, "deletions": 51, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,10 +12,7 @@ use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    pred: &ty::Predicate<'tcx>,\n-) -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -46,13 +43,13 @@ fn anonymize_predicate<'gcx, 'tcx>(\n     }\n }\n \n-struct PredicateSet<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct PredicateSet<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n-impl PredicateSet<'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n+impl PredicateSet<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n         Self { tcx: tcx, set: Default::default() }\n     }\n \n@@ -71,7 +68,7 @@ impl PredicateSet<'gcx, 'tcx> {\n     }\n }\n \n-impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'gcx, 'tcx> {\n+impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         for pred in iter {\n             self.insert(pred.as_ref());\n@@ -89,36 +86,36 @@ impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'gcx, 'tcx> {\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n /// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'gcx, 'tcx> {\n+pub struct Elaborator<'tcx> {\n     stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'gcx, 'tcx>,\n+    visited: PredicateSet<'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn elaborate_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'gcx, 'tcx> {\n+) -> Elaborator<'tcx> {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n-pub fn elaborate_trait_refs<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn elaborate_trait_refs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'gcx, 'tcx> {\n+) -> Elaborator<'tcx> {\n     let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate()).collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n-pub fn elaborate_predicates<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn elaborate_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>,\n-) -> Elaborator<'gcx, 'tcx> {\n+) -> Elaborator<'tcx> {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n     Elaborator { stack: predicates, visited }\n }\n \n-impl Elaborator<'gcx, 'tcx> {\n+impl Elaborator<'tcx> {\n     pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n@@ -230,7 +227,7 @@ impl Elaborator<'gcx, 'tcx> {\n     }\n }\n \n-impl Iterator for Elaborator<'gcx, 'tcx> {\n+impl Iterator for Elaborator<'tcx> {\n     type Item = ty::Predicate<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -252,19 +249,19 @@ impl Iterator for Elaborator<'gcx, 'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'gcx, 'tcx> = FilterToTraits<Elaborator<'gcx, 'tcx>>;\n+pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n \n-pub fn supertraits<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn supertraits<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'gcx, 'tcx> {\n+) -> Supertraits<'tcx> {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn transitive_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'gcx, 'tcx> {\n+) -> Supertraits<'tcx> {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n@@ -280,8 +277,8 @@ pub fn transitive_bounds<'gcx, 'tcx>(\n /// `Read + Write + Sync + Send`.\n /// Expansion is done via a DFS (depth-first search), and the `visited` field\n /// is used to avoid cycles.\n-pub struct TraitAliasExpander<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct TraitAliasExpander<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n }\n \n@@ -337,18 +334,18 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n     }\n }\n \n-pub fn expand_trait_aliases<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn expand_trait_aliases<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n-) -> TraitAliasExpander<'gcx, 'tcx> {\n+) -> TraitAliasExpander<'tcx> {\n     let items: Vec<_> = trait_refs\n         .into_iter()\n         .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n         .collect();\n     TraitAliasExpander { tcx, stack: items }\n }\n \n-impl<'gcx, 'tcx> TraitAliasExpander<'gcx, 'tcx> {\n+impl<'tcx> TraitAliasExpander<'tcx> {\n     /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n     /// to the definition, pushes the resulting expansion onto `self.stack`, and returns `false`.\n     /// Otherwise, immediately returns `true` if `item` is a regular trait, or `false` if it is a\n@@ -393,7 +390,7 @@ impl<'gcx, 'tcx> TraitAliasExpander<'gcx, 'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> Iterator for TraitAliasExpander<'gcx, 'tcx> {\n+impl<'tcx> Iterator for TraitAliasExpander<'tcx> {\n     type Item = TraitAliasExpansionInfo<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -414,24 +411,21 @@ impl<'gcx, 'tcx> Iterator for TraitAliasExpander<'gcx, 'tcx> {\n // Iterator over def-IDs of supertraits\n ///////////////////////////////////////////////////////////////////////////\n \n-pub struct SupertraitDefIds<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct SupertraitDefIds<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     stack: Vec<DefId>,\n     visited: FxHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    trait_def_id: DefId,\n-) -> SupertraitDefIds<'gcx, 'tcx> {\n+pub fn supertrait_def_ids<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> SupertraitDefIds<'tcx> {\n     SupertraitDefIds {\n         tcx,\n         stack: vec![trait_def_id],\n         visited: Some(trait_def_id).into_iter().collect(),\n     }\n }\n \n-impl Iterator for SupertraitDefIds<'gcx, 'tcx> {\n+impl Iterator for SupertraitDefIds<'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n@@ -489,13 +483,12 @@ impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                                param_env: ty::ParamEnv<'tcx>,\n-                                                impl_def_id: DefId,\n-                                                impl_substs: SubstsRef<'tcx>,)\n-                                                -> (ty::TraitRef<'tcx>,\n-                                                    Vec<PredicateObligation<'tcx>>)\n-{\n+pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: SubstsRef<'tcx>,\n+) -> (ty::TraitRef<'tcx>, Vec<PredicateObligation<'tcx>>) {\n     let impl_trait_ref =\n         selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref =\n@@ -552,7 +545,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn predicate_for_trait_def(self,\n                                    param_env: ty::ParamEnv<'tcx>,\n                                    cause: ObligationCause<'tcx>,"}, {"sha": "6e10dc03a2869e6a7b9e50d4c706ee1ad8aa7b84", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -19,19 +19,19 @@ use crate::mir::interpret::ConstValue;\n /// Like subtyping, matching is really a binary relation, so the only\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n-pub struct Match<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct Match<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl Match<'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>) -> Match<'gcx, 'tcx> {\n+impl Match<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Match<'tcx> {\n         Match { tcx }\n     }\n }\n \n-impl TypeRelation<'gcx, 'tcx> for Match<'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for Match<'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,"}, {"sha": "9ba99768215a692ea2729c4d0779430b21f55dde", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -103,12 +103,8 @@ pub struct OverloadedDeref<'tcx> {\n     pub mutbl: hir::Mutability,\n }\n \n-impl<'gcx, 'tcx> OverloadedDeref<'tcx> {\n-    pub fn method_call(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        source: Ty<'tcx>,\n-    ) -> (DefId, SubstsRef<'tcx>) {\n+impl<'tcx> OverloadedDeref<'tcx> {\n+    pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n             hir::MutImmutable => tcx.lang_items().deref_trait(),\n             hir::MutMutable => tcx.lang_items().deref_mut_trait()"}, {"sha": "224f7d5f28dc359bfcf1ed2bfe47ca2a10ff32a7", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -108,7 +108,7 @@ pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n }\n \n pub trait TyDecoder<'tcx>: Decoder {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn peek_byte(&self) -> u8;\n "}, {"sha": "65b83224ae521d7736eb573581d0a69731279bab", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,7 +6,7 @@ use syntax_pos::symbol::{sym, Symbol};\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {\n@@ -69,7 +69,7 @@ impl<'tcx> TyCtxt<'tcx, 'tcx> {\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n-    fn is_const_fn_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn is_const_fn_raw<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n@@ -83,7 +83,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn is_promotable_const_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn is_promotable_const_fn<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) && match tcx.lookup_stability(def_id) {\n             Some(stab) => {\n                 if cfg!(debug_assertions) && stab.promotable {\n@@ -101,7 +101,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn const_fn_is_allowed_fn_ptr<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn const_fn_is_allowed_fn_ptr<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) &&\n             tcx.lookup_stability(def_id)\n                 .map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)"}, {"sha": "e5d06532b3a169408589991ebfaa4bc9fa4acfc9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 96, "deletions": 110, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -115,7 +115,7 @@ pub struct CtxtInterners<'tcx> {\n     const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n-impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n+impl<'tcx> CtxtInterners<'tcx> {\n     fn new(arena: &'tcx SyncDroplessArena) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n@@ -137,9 +137,9 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     /// Intern a type\n     #[inline(never)]\n     fn intern_ty(\n-        local: &CtxtInterners<'gcx>,\n-        global: &CtxtInterners<'gcx>,\n-        st: TyKind<'tcx>\n+        local: &CtxtInterners<'tcx>,\n+        global: &CtxtInterners<'tcx>,\n+        st: TyKind<'tcx>,\n     ) -> Ty<'tcx> {\n         let flags = super::flags::FlagComputation::for_sty(&st);\n \n@@ -164,7 +164,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n \n                 // This is safe because all the types the ty_struct can point to\n                 // already is in the local arena or the global arena\n-                let ty_struct: TyS<'gcx> = unsafe {\n+                let ty_struct: TyS<'tcx> = unsafe {\n                     mem::transmute(ty_struct)\n                 };\n \n@@ -180,7 +180,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n \n                 // This is safe because all the types the ty_struct can point to\n                 // already is in the global arena\n-                let ty_struct: TyS<'gcx> = unsafe {\n+                let ty_struct: TyS<'tcx> = unsafe {\n                     mem::transmute(ty_struct)\n                 };\n \n@@ -750,7 +750,7 @@ impl<'tcx> TypeckTables<'tcx> {\n \n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -857,11 +857,10 @@ BraceStructLiftImpl! {\n     }\n }\n \n-\n /// Canonicalized user type annotation.\n-pub type CanonicalUserType<'gcx> = Canonical<'gcx, UserType<'gcx>>;\n+pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n \n-impl CanonicalUserType<'gcx> {\n+impl CanonicalUserType<'tcx> {\n     /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n     /// i.e., each thing is mapped to a canonical variable with the same index.\n     pub fn is_identity(&self) -> bool {\n@@ -1016,14 +1015,14 @@ pub struct FreeRegionInfo {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n-pub struct TyCtxt<'gcx: 'tcx, 'tcx> {\n-    gcx: &'gcx GlobalCtxt<'gcx>,\n-    interners: &'gcx CtxtInterners<'gcx>,\n+pub struct TyCtxt<'tcx> {\n+    gcx: &'tcx GlobalCtxt<'tcx>,\n+    interners: &'tcx CtxtInterners<'tcx>,\n     dummy: PhantomData<&'tcx ()>,\n }\n \n-impl<'gcx> Deref for TyCtxt<'gcx, '_> {\n-    type Target = &'gcx GlobalCtxt<'gcx>;\n+impl<'tcx> Deref for TyCtxt<'tcx> {\n+    type Target = &'tcx GlobalCtxt<'tcx>;\n     #[inline(always)]\n     fn deref(&self) -> &Self::Target {\n         &self.gcx\n@@ -1119,10 +1118,10 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Gets the global `TyCtxt`.\n     #[inline]\n-    pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx> {\n+    pub fn global_tcx(self) -> TyCtxt<'tcx> {\n         TyCtxt {\n             gcx: self.gcx,\n             interners: &self.gcx.global_interners,\n@@ -1131,25 +1130,26 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn hir(self) -> &'tcx hir_map::Map<'gcx> {\n+    pub fn hir(self) -> &'tcx hir_map::Map<'tcx> {\n         &self.hir_map\n     }\n \n-    pub fn alloc_steal_mir(self, mir: Body<'gcx>) -> &'gcx Steal<Body<'gcx>> {\n+    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n-    pub fn alloc_adt_def(self,\n-                         did: DefId,\n-                         kind: AdtKind,\n-                         variants: IndexVec<VariantIdx, ty::VariantDef>,\n-                         repr: ReprOptions)\n-                         -> &'gcx ty::AdtDef {\n+    pub fn alloc_adt_def(\n+        self,\n+        did: DefId,\n+        kind: AdtKind,\n+        variants: IndexVec<VariantIdx, ty::VariantDef>,\n+        repr: ReprOptions,\n+    ) -> &'tcx ty::AdtDef {\n         let def = ty::AdtDef::new(self, did, kind, variants, repr);\n         self.arena.alloc(def)\n     }\n \n-    pub fn intern_const_alloc(self, alloc: Allocation) -> &'gcx Allocation {\n+    pub fn intern_const_alloc(self, alloc: Allocation) -> &'tcx Allocation {\n         self.allocation_interner.borrow_mut().intern(alloc, |alloc| {\n             self.arena.alloc(alloc)\n         })\n@@ -1163,13 +1163,13 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         self.alloc_map.lock().create_memory_alloc(alloc)\n     }\n \n-    pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n+    pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n         self.stability_interner.borrow_mut().intern(stab, |stab| {\n             self.arena.alloc(stab)\n         })\n     }\n \n-    pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n+    pub fn intern_layout(self, layout: LayoutDetails) -> &'tcx LayoutDetails {\n         self.layout_interner.borrow_mut().intern(layout, |layout| {\n             self.arena.alloc(layout)\n         })\n@@ -1201,7 +1201,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     /// Like lift, but only tries in the global tcx.\n-    pub fn lift_to_global<T: ?Sized + Lift<'gcx>>(self, value: &T) -> Option<T::Lifted> {\n+    pub fn lift_to_global<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self.global_tcx())\n     }\n \n@@ -1343,11 +1343,11 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         self.sess.consider_optimizing(&cname, msg)\n     }\n \n-    pub fn lib_features(self) -> &'gcx middle::lib_features::LibFeatures {\n+    pub fn lib_features(self) -> &'tcx middle::lib_features::LibFeatures {\n         self.get_lib_features(LOCAL_CRATE)\n     }\n \n-    pub fn lang_items(self) -> &'gcx middle::lang_items::LanguageItems {\n+    pub fn lang_items(self) -> &'tcx middle::lang_items::LanguageItems {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n@@ -1385,15 +1385,15 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         else { None }\n     }\n \n-    pub fn stability(self) -> &'gcx stability::Index<'gcx> {\n+    pub fn stability(self) -> &'tcx stability::Index<'tcx> {\n         self.stability_index(LOCAL_CRATE)\n     }\n \n-    pub fn crates(self) -> &'gcx [CrateNum] {\n+    pub fn crates(self) -> &'tcx [CrateNum] {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n-    pub fn features(self) -> &'gcx feature_gate::Features {\n+    pub fn features(self) -> &'tcx feature_gate::Features {\n         self.features_query(LOCAL_CRATE)\n     }\n \n@@ -1666,22 +1666,21 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn encode_metadata(self)\n         -> EncodedMetadata\n     {\n         self.cstore.encode_metadata(self)\n     }\n }\n \n-impl<'gcx> GlobalCtxt<'gcx> {\n+impl<'tcx> GlobalCtxt<'tcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n     /// `interners` is a slot passed so we can create a CtxtInterners\n     /// with the same lifetime as `arena`.\n-    pub fn enter_local<'tcx, F, R>(&'gcx self, f: F) -> R\n+    pub fn enter_local<F, R>(&'tcx self, f: F) -> R\n     where\n-        F: FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n-        'gcx: 'tcx,\n+        F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n         let tcx = TyCtxt {\n             gcx: self,\n@@ -1722,15 +1721,15 @@ impl<'gcx> GlobalCtxt<'gcx> {\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n \n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n                     type Lifted = $lifted;\n-                    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                         if tcx.interners.arena.in_arena(*self as *const _) {\n                             return Some(unsafe { mem::transmute(*self) });\n                         }\n@@ -1749,7 +1748,7 @@ macro_rules! nop_list_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n                     type Lifted = &'tcx List<$lifted>;\n-                    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                         if self.is_empty() {\n                             return Some(List::empty());\n                         }\n@@ -1809,14 +1808,14 @@ pub mod tls {\n     /// you should also have access to an ImplicitCtxt through the functions\n     /// in this module.\n     #[derive(Clone)]\n-    pub struct ImplicitCtxt<'a, 'gcx: 'tcx, 'tcx> {\n+    pub struct ImplicitCtxt<'a, 'tcx> {\n         /// The current TyCtxt. Initially created by `enter_global` and updated\n         /// by `enter_local` with a new local interner\n-        pub tcx: TyCtxt<'gcx, 'tcx>,\n+        pub tcx: TyCtxt<'tcx>,\n \n         /// The current query job, if any. This is updated by JobOwner::start in\n         /// ty::query::plumbing when executing a query\n-        pub query: Option<Lrc<query::QueryJob<'gcx>>>,\n+        pub query: Option<Lrc<query::QueryJob<'tcx>>>,\n \n         /// Where to store diagnostics for the current query job, if any.\n         /// This is updated by JobOwner::start in ty::query::plumbing when executing a query\n@@ -1924,9 +1923,9 @@ pub mod tls {\n \n     /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n     #[inline]\n-    pub fn enter_context<'a, 'gcx: 'tcx, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'gcx, 'tcx>,\n-                                                     f: F) -> R\n-        where F: FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n+    where\n+        F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n     {\n         set_tlv(context as *const _ as usize, || {\n             f(&context)\n@@ -1937,9 +1936,9 @@ pub mod tls {\n     /// creating a initial TyCtxt and ImplicitCtxt.\n     /// This happens once per rustc session and TyCtxts only exists\n     /// inside the `f` function.\n-    pub fn enter_global<'gcx, F, R>(gcx: &'gcx GlobalCtxt<'gcx>, f: F) -> R\n+    pub fn enter_global<'tcx, F, R>(gcx: &'tcx GlobalCtxt<'tcx>, f: F) -> R\n     where\n-        F: FnOnce(TyCtxt<'gcx, 'gcx>) -> R,\n+        F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n         // Update GCX_PTR to indicate there's a GlobalCtxt available\n         GCX_PTR.with(|lock| {\n@@ -1977,7 +1976,7 @@ pub mod tls {\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n     where\n-        F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n+        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n     {\n         let gcx = GCX_PTR.with(|lock| *lock.lock());\n         assert!(gcx != 0);\n@@ -2000,63 +1999,65 @@ pub mod tls {\n     /// Allows access to the current ImplicitCtxt in a closure if one is available\n     #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R\n+    where\n+        F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n     {\n         let context = get_tlv();\n         if context == 0 {\n             f(None)\n         } else {\n             // We could get a ImplicitCtxt pointer from another thread.\n             // Ensure that ImplicitCtxt is Sync\n-            sync::assert_sync::<ImplicitCtxt<'_, '_, '_>>();\n+            sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n \n-            unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_, '_>))) }\n+            unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n         }\n     }\n \n     /// Allows access to the current ImplicitCtxt.\n     /// Panics if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with_context<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n     {\n         with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n     }\n \n     /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n     /// interner as the tcx argument passed in. This means the closure is given an ImplicitCtxt\n-    /// with the same 'gcx lifetime as the TyCtxt passed in.\n+    /// with the same 'tcx lifetime as the TyCtxt passed in.\n     /// This will panic if you pass it a TyCtxt which has a different global interner from\n     /// the current ImplicitCtxt's tcx field.\n     #[inline]\n-    pub fn with_related_context<'gcx, 'tcx1, F, R>(tcx: TyCtxt<'gcx, 'tcx1>, f: F) -> R\n+    pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n     where\n-        F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R,\n+        F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n     {\n         with_context(|context| {\n             unsafe {\n                 assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-                let context: &ImplicitCtxt<'_, '_, '_> = mem::transmute(context);\n+                let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n                 f(context)\n             }\n         })\n     }\n \n     /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n     /// interner and local interner as the tcx argument passed in. This means the closure\n-    /// is given an ImplicitCtxt with the same 'tcx and 'gcx lifetimes as the TyCtxt passed in.\n+    /// is given an ImplicitCtxt with the same 'tcx and 'tcx lifetimes as the TyCtxt passed in.\n     /// This will panic if you pass it a TyCtxt which has a different global interner or\n     /// a different local interner from the current ImplicitCtxt's tcx field.\n     #[inline]\n-    pub fn with_fully_related_context<'gcx, 'tcx, F, R>(tcx: TyCtxt<'gcx, 'tcx>, f: F) -> R\n+    pub fn with_fully_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n     where\n-        F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R,\n+        F: for<'b> FnOnce(&ImplicitCtxt<'b, 'tcx>) -> R,\n     {\n         with_context(|context| {\n             unsafe {\n                 assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n                 assert!(ptr_eq(context.tcx.interners, tcx.interners));\n-                let context: &ImplicitCtxt<'_, '_, '_> = mem::transmute(context);\n+                let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n                 f(context)\n             }\n         })\n@@ -2067,7 +2068,7 @@ pub mod tls {\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n     where\n-        F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n+        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n     {\n         with_context(|context| f(context.tcx))\n     }\n@@ -2077,7 +2078,7 @@ pub mod tls {\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n     where\n-        F: for<'gcx, 'tcx> FnOnce(Option<TyCtxt<'gcx, 'tcx>>) -> R,\n+        F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n     {\n         with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n     }\n@@ -2101,7 +2102,7 @@ macro_rules! sty_debug_print {\n                 all_infer: usize,\n             }\n \n-            pub fn go(tcx: TyCtxt<'_, '_>) {\n+            pub fn go(tcx: TyCtxt<'_>) {\n                 let mut total = DebugStat {\n                     total: 0,\n                     lt_infer: 0,\n@@ -2154,7 +2155,7 @@ macro_rules! sty_debug_print {\n     }}\n }\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n@@ -2196,8 +2197,8 @@ impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<TyKind<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a TyKind<'lcx> {\n+impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n         &self.0.sty\n     }\n }\n@@ -2217,20 +2218,20 @@ impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, List<Ty<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n+impl<'tcx> Borrow<[Ty<'tcx>]> for Interned<'tcx, List<Ty<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Ty<'tcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>> {\n+impl<'tcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>> {\n     fn borrow<'a>(&'a self) -> &'a [CanonicalVarInfo] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a [Kind<'lcx>] {\n+impl<'tcx> Borrow<[Kind<'tcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a [Kind<'tcx>] {\n         &self.0[..]\n     }\n }\n@@ -2248,42 +2249,40 @@ impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<GoalKind<'lcx>> for Interned<'tcx, GoalKind<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a GoalKind<'lcx> {\n+impl<'tcx> Borrow<GoalKind<'tcx>> for Interned<'tcx, GoalKind<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a GoalKind<'tcx> {\n         &self.0\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n-    for Interned<'tcx, List<ExistentialPredicate<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n+impl<'tcx> Borrow<[ExistentialPredicate<'tcx>]>\n+    for Interned<'tcx, List<ExistentialPredicate<'tcx>>>\n+{\n+    fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'tcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n-    for Interned<'tcx, List<Predicate<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Predicate<'lcx>] {\n+impl<'tcx> Borrow<[Predicate<'tcx>]> for Interned<'tcx, List<Predicate<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Predicate<'tcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Const<'lcx> {\n+impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Const<'tcx> {\n         &self.0\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Clause<'lcx>]>\n-for Interned<'tcx, List<Clause<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Clause<'lcx>] {\n+impl<'tcx> Borrow<[Clause<'tcx>]> for Interned<'tcx, List<Clause<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Clause<'tcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Goal<'lcx>]>\n-for Interned<'tcx, List<Goal<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Goal<'lcx>] {\n+impl<'tcx> Borrow<[Goal<'tcx>]> for Interned<'tcx, List<Goal<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Goal<'tcx>] {\n         &self.0[..]\n     }\n }\n@@ -2293,21 +2292,10 @@ macro_rules! intern_method {\n                                             $alloc_method:expr,\n                                             $alloc_to_key:expr,\n                                             $keep_in_local_tcx:expr) -> $ty:ty) => {\n-        impl<'gcx, $lt_tcx> TyCtxt<'gcx, $lt_tcx> {\n+        impl<$lt_tcx> TyCtxt<$lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n                 let key = ($alloc_to_key)(&v);\n \n-                let alloc = |v, interners: &'gcx CtxtInterners<'gcx>| {\n-                    // This transmutes $alloc<'tcx> to $alloc<'gcx>\n-                    let v = unsafe {\n-                        mem::transmute(v)\n-                    };\n-                    let i: &$lt_tcx $ty = $alloc_method(&interners.arena, v);\n-                    // Cast to 'gcx\n-                    let i = unsafe { mem::transmute(i) };\n-                    Interned(i)\n-                };\n-\n                 // HACK(eddyb) Depend on flags being accurate to\n                 // determine that all contents are in the global tcx.\n                 // See comments on Lift for why we can't use that.\n@@ -2321,11 +2309,11 @@ macro_rules! intern_method {\n                                 v);\n                         }\n \n-                        alloc(v, &self.interners)\n+                        Interned($alloc_method(&self.interners.arena, v))\n                     }).0\n                 } else {\n                     self.global_interners.$name.borrow_mut().intern_ref(key, || {\n-                        alloc(v, &self.global_interners)\n+                        Interned($alloc_method(&self.global_interners.arena, v))\n                     }).0\n                 }\n             }\n@@ -2403,7 +2391,7 @@ intern_method! {\n     ) -> List<CanonicalVarInfo>\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n     /// that is, a `fn` type that is equivalent in every way for being\n     /// unsafe.\n@@ -2772,7 +2760,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'gcx> {\n+    pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'tcx> {\n         if ts.len() == 0 {\n             List::empty()\n         } else {\n@@ -2938,7 +2926,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n-    pub fn in_scope_traits(self, id: HirId) -> Option<&'gcx StableVec<TraitCandidate>> {\n+    pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {\n         self.in_scope_traits_map(id.owner)\n             .and_then(|map| map.get(&id.local_id))\n     }\n@@ -2954,9 +2942,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n             .unwrap_or(false)\n     }\n \n-    pub fn object_lifetime_defaults(self, id: HirId)\n-        -> Option<&'gcx [ObjectLifetimeDefault]>\n-    {\n+    pub fn object_lifetime_defaults(self, id: HirId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n         self.object_lifetime_defaults_map(id.owner)\n             .and_then(|map| map.get(&id.local_id).map(|v| &**v))\n     }"}, {"sha": "999b4eff85697ef1abb85ca799555a94dc41af57", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -8,13 +8,13 @@ pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n }\n \n-fn erase_regions_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+fn erase_regions_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n     ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n@@ -32,12 +32,12 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n }\n \n-struct RegionEraserVisitor<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct RegionEraserVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n "}, {"sha": "d5e0450035038b2f4ba35d517646395bccbfb121", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -183,8 +183,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     }\n }\n \n-impl<'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'gcx, 'lcx>) -> Cow<'static, str> {\n+impl<'tcx> ty::TyS<'tcx> {\n+    pub fn sort_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match self.sty {\n             ty::Bool | ty::Char | ty::Int(_) |\n             ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n@@ -249,7 +249,7 @@ impl<'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder<'_>,\n                                      err: &TypeError<'tcx>,"}, {"sha": "7aab1aef3b895d839c1a6f0363b33aed519148af", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -55,8 +55,8 @@ pub enum SimplifiedTypeGen<D>\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn simplify_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'_>,\n     can_simplify_params: bool,\n ) -> Option<SimplifiedType> {"}, {"sha": "8b98a2916a76693b13c6de3042a714023f73c621", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -45,8 +45,8 @@ use crate::util::nodemap::FxHashSet;\n /// To implement this conveniently, use the\n /// `BraceStructTypeFoldableImpl` etc macros found in `macros.rs`.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self;\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n@@ -155,8 +155,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'gcx: 'tcx, 'tcx>: Sized {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx>;\n+pub trait TypeFolder<'tcx>: Sized {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -198,25 +198,25 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'gcx, 'tcx, F, G, H>\n+pub struct BottomUpFolder<'tcx, F, G, H>\n where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n     H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    pub tcx: TyCtxt<'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n     pub ty_op: F,\n     pub lt_op: G,\n     pub ct_op: H,\n }\n \n-impl<'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'gcx, 'tcx, F, G, H>\n+impl<'tcx, F, G, H> TypeFolder<'tcx> for BottomUpFolder<'tcx, F, G, H>\n where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n     H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n         }\n \n@@ -239,7 +239,7 @@ where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n@@ -365,8 +365,8 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n \n-pub struct RegionFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct RegionFolder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     skipped_regions: &'a mut bool,\n \n     /// Stores the index of a binder *just outside* the stuff we have\n@@ -381,13 +381,13 @@ pub struct RegionFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n         &'a mut (dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx> + 'a),\n }\n \n-impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     #[inline]\n     pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         skipped_regions: &'a mut bool,\n         fold_region_fn: &'a mut dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n-    ) -> RegionFolder<'a, 'gcx, 'tcx> {\n+    ) -> RegionFolder<'a, 'tcx> {\n         RegionFolder {\n             tcx,\n             skipped_regions,\n@@ -397,8 +397,8 @@ impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n         }\n \n@@ -430,8 +430,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n // Bound vars replacer\n \n /// Replaces the escaping bound vars (late bound regions or bound types) in a type.\n-struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct BoundVarReplacer<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n \n     /// As with `RegionFolder`, represents the index of a binder *just outside*\n     /// the ones we have visited.\n@@ -442,13 +442,8 @@ struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a),\n }\n \n-impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn new<F, G, H>(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        fld_r: &'a mut F,\n-        fld_t: &'a mut G,\n-        fld_c: &'a mut H,\n-    ) -> Self\n+impl<'a, 'tcx> BoundVarReplacer<'a, 'tcx> {\n+    fn new<F, G, H>(tcx: TyCtxt<'tcx>, fld_r: &'a mut F, fld_t: &'a mut G, fld_c: &'a mut H) -> Self\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n@@ -464,8 +459,8 @@ impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n         }\n \n@@ -549,7 +544,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Replaces all regions bound by the given `Binder` with the\n     /// results returned by the closure; the closure is expected to\n     /// return a free region (relative to this binder), and hence the\n@@ -729,15 +724,15 @@ enum Direction {\n     Out,\n }\n \n-struct Shifter<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct Shifter<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n     direction: Direction,\n }\n \n-impl Shifter<'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n+impl Shifter<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, amount: u32, direction: Direction) -> Self {\n         Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n@@ -747,8 +742,8 @@ impl Shifter<'gcx, 'tcx> {\n     }\n }\n \n-impl TypeFolder<'gcx, 'tcx> for Shifter<'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+impl TypeFolder<'tcx> for Shifter<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n         }\n \n@@ -826,8 +821,8 @@ impl TypeFolder<'gcx, 'tcx> for Shifter<'gcx, 'tcx> {\n     }\n }\n \n-pub fn shift_region<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn shift_region<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     region: ty::Region<'tcx>,\n     amount: u32,\n ) -> ty::Region<'tcx> {\n@@ -841,7 +836,7 @@ pub fn shift_region<'gcx, 'tcx>(\n     }\n }\n \n-pub fn shift_vars<'gcx, 'tcx, T>(tcx: TyCtxt<'gcx, 'tcx>, value: &T, amount: u32) -> T\n+pub fn shift_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: &T, amount: u32) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -851,7 +846,7 @@ where\n     value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n }\n \n-pub fn shift_out_vars<'gcx, 'tcx, T>(tcx: TyCtxt<'gcx, 'tcx>, value: &T, amount: u32) -> T\n+pub fn shift_out_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: &T, amount: u32) -> T\n where\n     T: TypeFoldable<'tcx>,\n {"}, {"sha": "b22bd21e9de43badf8137f619703a10346582453", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,7 +21,7 @@ pub struct DefIdForest {\n     root_ids: SmallVec<[DefId; 1]>,\n }\n \n-impl<'gcx, 'tcx> DefIdForest {\n+impl<'tcx> DefIdForest {\n     /// Creates an empty forest.\n     pub fn empty() -> DefIdForest {\n         DefIdForest {\n@@ -32,7 +32,7 @@ impl<'gcx, 'tcx> DefIdForest {\n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full(tcx: TyCtxt<'gcx, 'tcx>) -> DefIdForest {\n+    pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n@@ -52,12 +52,12 @@ impl<'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Tests whether the forest contains a given DefId.\n-    pub fn contains(&self, tcx: TyCtxt<'gcx, 'tcx>, id: DefId) -> bool {\n+    pub fn contains(&self, tcx: TyCtxt<'tcx>, id: DefId) -> bool {\n         self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n     }\n \n     /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'gcx, 'tcx>, iter: I) -> DefIdForest\n+    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n     where\n         I: IntoIterator<Item = DefIdForest>,\n     {\n@@ -94,7 +94,7 @@ impl<'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'gcx, 'tcx>, iter: I) -> DefIdForest\n+    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n     where\n         I: IntoIterator<Item = DefIdForest>,\n     {"}, {"sha": "5ce750849f42d55fa395285eda5cd48129f1b373", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -51,7 +51,7 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n     /// # Example\n     /// ```rust\n@@ -106,9 +106,9 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> AdtDef {\n+impl<'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n@@ -120,11 +120,11 @@ impl<'gcx, 'tcx> AdtDef {\n     }\n }\n \n-impl<'gcx, 'tcx> VariantDef {\n+impl<'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind,\n     ) -> DefIdForest {\n@@ -146,11 +146,11 @@ impl<'gcx, 'tcx> VariantDef {\n     }\n }\n \n-impl<'gcx, 'tcx> FieldDef {\n+impl<'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n     ) -> DefIdForest {\n@@ -176,9 +176,9 @@ impl<'gcx, 'tcx> FieldDef {\n     }\n }\n \n-impl<'gcx, 'tcx> TyS<'tcx> {\n+impl<'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>) -> DefIdForest {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),\n "}, {"sha": "457d018f017d76fcf3855ca307eb2b887e234130", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -43,7 +43,7 @@ pub enum InstanceDef<'tcx> {\n }\n \n impl<'tcx> Instance<'tcx> {\n-    pub fn ty(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n         tcx.subst_and_normalize_erasing_regions(\n             self.substs,\n@@ -52,7 +52,7 @@ impl<'tcx> Instance<'tcx> {\n         )\n     }\n \n-    fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx, 'tcx>) -> PolyFnSig<'tcx> {\n+    fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n         let ty = self.ty(tcx);\n         match ty.sty {\n             ty::FnDef(..) |\n@@ -102,7 +102,7 @@ impl<'tcx> Instance<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let mut fn_sig = self.fn_sig_noadjust(tcx);\n         if let InstanceDef::VtableShim(..) = self.def {\n             // Modify fn(self, ...) to fn(self: *mut Self, ...)\n@@ -133,11 +133,11 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs(&self, tcx: TyCtxt<'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n+    pub fn attrs(&self, tcx: TyCtxt<'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n \n-    pub fn is_inline(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n+    pub fn is_inline(&self, tcx: TyCtxt<'tcx>) -> bool {\n         use crate::hir::map::DefPathData;\n         let def_id = match *self {\n             ty::InstanceDef::Item(def_id) => def_id,\n@@ -150,7 +150,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n-    pub fn requires_local(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n+    pub fn requires_local(&self, tcx: TyCtxt<'tcx>) -> bool {\n         if self.is_inline(tcx) {\n             return true\n         }\n@@ -200,7 +200,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> Instance<'tcx> {\n+impl<'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: SubstsRef<'tcx>)\n                -> Instance<'tcx> {\n         assert!(!substs.has_escaping_bound_vars(),\n@@ -209,7 +209,7 @@ impl<'b, 'tcx> Instance<'tcx> {\n         Instance { def: InstanceDef::Item(def_id), substs: substs }\n     }\n \n-    pub fn mono(tcx: TyCtxt<'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n+    pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n         Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n     }\n \n@@ -237,7 +237,7 @@ impl<'b, 'tcx> Instance<'tcx> {\n     /// in a monomorphic context (i.e., like during codegen), then it is guaranteed to return\n     /// `Some`.\n     pub fn resolve(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n@@ -291,7 +291,7 @@ impl<'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_for_vtable(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n@@ -312,7 +312,7 @@ impl<'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_closure(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         substs: ty::ClosureSubsts<'tcx>,\n         requested_kind: ty::ClosureKind,\n@@ -325,14 +325,14 @@ impl<'b, 'tcx> Instance<'tcx> {\n         }\n     }\n \n-    pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n+    pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n         let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n         let substs = tcx.intern_substs(&[ty.into()]);\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n     }\n \n     pub fn fn_once_adapter_instance(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         closure_did: DefId,\n         substs: ty::ClosureSubsts<'tcx>,\n     ) -> Instance<'tcx> {\n@@ -366,7 +366,7 @@ impl<'b, 'tcx> Instance<'tcx> {\n }\n \n fn resolve_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_item: &ty::AssocItem,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_id: DefId,"}, {"sha": "6cee2709b636da0309dabcbf4358d9b214bbfeda", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -29,10 +29,10 @@ use rustc_target::abi::call::{\n };\n \n pub trait IntegerExt {\n-    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n     fn repr_discr<'tcx>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         repr: &ReprOptions,\n         min: i128,\n@@ -41,7 +41,7 @@ pub trait IntegerExt {\n }\n \n impl IntegerExt for Integer {\n-    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n             (I8, false) => tcx.types.u8,\n             (I16, false) => tcx.types.u16,\n@@ -77,7 +77,7 @@ impl IntegerExt for Integer {\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n     fn repr_discr<'tcx>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         repr: &ReprOptions,\n         min: i128,\n@@ -126,11 +126,11 @@ impl IntegerExt for Integer {\n }\n \n pub trait PrimitiveExt {\n-    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx>;\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n impl PrimitiveExt for Primitive {\n-    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             Float(FloatTy::F32) => tcx.types.f32,\n@@ -172,7 +172,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n }\n \n fn layout_raw<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n@@ -226,7 +226,7 @@ enum StructKind {\n     Prefixed(Size, Align),\n }\n \n-impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutDetails {\n         let dl = self.data_layout();\n         let b_align = b.value.align(dl);\n@@ -1221,7 +1221,7 @@ enum SavedLocalEligibility {\n // Also included in the layout are the upvars and the discriminant.\n // These are included as fields on the \"outer\" layout; they are not part\n // of any variant.\n-impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     /// Compute the eligibility and assignment of each local.\n     fn generator_saved_local_eligibility(&self, info: &GeneratorLayout<'tcx>)\n     -> (BitSet<GeneratorSavedLocal>, IndexVec<GeneratorSavedLocal, SavedLocalEligibility>) {\n@@ -1606,7 +1606,7 @@ pub enum SizeSkeleton<'tcx> {\n impl<'tcx> SizeSkeleton<'tcx> {\n     pub fn compute(\n         ty: Ty<'tcx>,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         debug_assert!(!ty.has_infer_types());\n@@ -1728,21 +1728,21 @@ impl<'tcx> SizeSkeleton<'tcx> {\n }\n \n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n }\n \n pub trait HasParamEnv<'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n }\n \n-impl<'gcx, 'tcx> HasDataLayout for TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.data_layout\n     }\n }\n \n-impl<'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'gcx> {\n+impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.global_tcx()\n     }\n }\n@@ -1759,8 +1759,8 @@ impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n     }\n }\n \n-impl<'gcx, 'tcx, T: HasTyCtxt<'gcx>> HasTyCtxt<'gcx> for LayoutCx<'tcx, T> {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'gcx> {\n+impl<'tcx, T: HasTyCtxt<'tcx>> HasTyCtxt<'tcx> for LayoutCx<'tcx, T> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.tcx()\n     }\n }\n@@ -1797,7 +1797,7 @@ impl<T, E> MaybeResult<T> for Result<T, E> {\n \n pub type TyLayout<'tcx> = ::rustc_target::abi::TyLayout<'tcx, Ty<'tcx>>;\n \n-impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n+impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -1824,7 +1824,7 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n     }\n }\n \n-impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx, 'tcx>> {\n+impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -1856,7 +1856,7 @@ impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx, 'tcx>> {\n }\n \n // Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n-impl TyCtxt<'tcx, '_> {\n+impl TyCtxt<'tcx> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n@@ -1870,7 +1870,7 @@ impl TyCtxt<'tcx, '_> {\n     }\n }\n \n-impl ty::query::TyCtxtAt<'tcx, '_> {\n+impl ty::query::TyCtxtAt<'tcx> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n@@ -2190,7 +2190,7 @@ struct Niche {\n impl Niche {\n     fn reserve<'tcx>(\n         &self,\n-        cx: &LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>>,\n+        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n         count: u128,\n     ) -> Option<(u128, Scalar)> {\n         if count > self.available {\n@@ -2206,7 +2206,7 @@ impl Niche {\n     }\n }\n \n-impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) traverse already optimized enums.\n@@ -2442,24 +2442,27 @@ impl_stable_hash_for!(struct crate::ty::layout::AbiAndPrefAlign {\n     pref\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Align {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for Align {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Size {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for Size {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n-{\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {"}, {"sha": "c932586c078bde19d3aa955e8dddd35843085195", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 66, "deletions": 82, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -213,7 +213,7 @@ impl AssocItem {\n         }\n     }\n \n-    pub fn signature<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> String {\n+    pub fn signature<'tcx>(&self, tcx: TyCtxt<'tcx>) -> String {\n         match self.kind {\n             ty::AssocKind::Method => {\n                 // We skip the binder here because the binder would deanonymize all\n@@ -259,14 +259,14 @@ pub trait DefIdTree: Copy {\n     }\n }\n \n-impl<'gcx, 'tcx> DefIdTree for TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         self.def_key(id).parent.map(|index| DefId { index: index, ..id })\n     }\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_, '_>) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_>) -> Self {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n@@ -569,7 +569,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::TyS<'gcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -592,7 +592,7 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n \n-pub type CanonicalTy<'gcx> = Canonical<'gcx, Ty<'gcx>>;\n+pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n extern {\n     /// A dummy type used to force List to by unsized without requiring fat pointers\n@@ -912,7 +912,7 @@ pub struct Generics {\n     pub has_late_bound_regions: Option<Span>,\n }\n \n-impl<'gcx, 'tcx> Generics {\n+impl<'tcx> Generics {\n     pub fn count(&self) -> usize {\n         self.parent_count + self.params.len()\n     }\n@@ -934,7 +934,7 @@ impl<'gcx, 'tcx> Generics {\n         own_counts\n     }\n \n-    pub fn requires_monomorphization(&self, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n+    pub fn requires_monomorphization(&self, tcx: TyCtxt<'tcx>) -> bool {\n         if self.own_requires_monomorphization() {\n             return true;\n         }\n@@ -960,7 +960,7 @@ impl<'gcx, 'tcx> Generics {\n     pub fn region_param(\n         &'tcx self,\n         param: &EarlyBoundRegion,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n@@ -975,11 +975,7 @@ impl<'gcx, 'tcx> Generics {\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n-    pub fn type_param(\n-        &'tcx self,\n-        param: &ParamTy,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> &'tcx GenericParamDef {\n+    pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -993,11 +989,7 @@ impl<'gcx, 'tcx> Generics {\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n-    pub fn const_param(\n-        &'tcx self,\n-        param: &ParamConst,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> &GenericParamDef {\n+    pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -1021,10 +1013,10 @@ pub struct GenericPredicates<'tcx> {\n impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n \n-impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n+impl<'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n@@ -1034,7 +1026,7 @@ impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n \n     pub fn instantiate_own(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n@@ -1044,7 +1036,7 @@ impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n \n     fn instantiate_into(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         instantiated: &mut InstantiatedPredicates<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) {\n@@ -1056,15 +1048,15 @@ impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n         );\n     }\n \n-    pub fn instantiate_identity(&self, tcx: TyCtxt<'gcx, 'tcx>) -> InstantiatedPredicates<'tcx> {\n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'tcx>) -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_identity_into(tcx, &mut instantiated);\n         instantiated\n     }\n \n     fn instantiate_identity_into(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         instantiated: &mut InstantiatedPredicates<'tcx>,\n     ) {\n         if let Some(def_id) = self.parent {\n@@ -1075,7 +1067,7 @@ impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n \n     pub fn instantiate_supertrait(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         poly_trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> InstantiatedPredicates<'tcx> {\n         assert_eq!(self.parent, None);\n@@ -1142,15 +1134,15 @@ impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> Predicate<'tcx> {\n+impl<'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n     pub fn subst_supertrait(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> ty::Predicate<'tcx> {\n         // The interaction between HRTB and supertraits is not entirely\n@@ -1309,7 +1301,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_>) -> PolyTraitRef<'tcx> {\n+    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our\n@@ -1771,8 +1763,9 @@ impl<'tcx, T> ParamEnvAnd<'tcx, T> {\n     }\n }\n \n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n-    where T: HashStable<StableHashingContext<'a>>\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'tcx, T>\n+where\n+    T: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1853,7 +1846,7 @@ pub struct VariantDef {\n     pub recovered: bool,\n }\n \n-impl<'gcx, 'tcx> VariantDef {\n+impl<'tcx> VariantDef {\n     /// Creates a new `VariantDef`.\n     ///\n     /// `variant_did` is the `DefId` that identifies the enum variant (if this `VariantDef`\n@@ -1871,7 +1864,7 @@ impl<'gcx, 'tcx> VariantDef {\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n     /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         ident: Ident,\n         variant_did: Option<DefId>,\n         ctor_def_id: Option<DefId>,\n@@ -2084,7 +2077,7 @@ impl_stable_hash_for!(struct ReprOptions {\n });\n \n impl ReprOptions {\n-    pub fn new(tcx: TyCtxt<'_, '_>, did: DefId) -> ReprOptions {\n+    pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n         let mut max_align = 0;\n@@ -2157,10 +2150,10 @@ impl ReprOptions {\n     }\n }\n \n-impl<'gcx, 'tcx> AdtDef {\n+impl<'tcx> AdtDef {\n     /// Creates a new `AdtDef`.\n     fn new(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         did: DefId,\n         kind: AdtKind,\n         variants: IndexVec<VariantIdx, VariantDef>,\n@@ -2300,7 +2293,7 @@ impl<'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns `true` if this type has a destructor.\n-    pub fn has_dtor(&self, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n+    pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n     }\n \n@@ -2311,7 +2304,7 @@ impl<'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'gcx, 'tcx>) -> &'tcx GenericPredicates<'gcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> &'tcx GenericPredicates<'tcx> {\n         tcx.predicates_of(self.did)\n     }\n \n@@ -2363,11 +2356,7 @@ impl<'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn eval_explicit_discr(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        expr_did: DefId,\n-    ) -> Option<Discr<'tcx>> {\n+    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty();\n         let repr_type = self.repr.discr_type();\n         let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), expr_did);\n@@ -2412,8 +2401,8 @@ impl<'gcx, 'tcx> AdtDef {\n     #[inline]\n     pub fn discriminants(\n         &'tcx self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2443,7 +2432,7 @@ impl<'gcx, 'tcx> AdtDef {\n     #[inline]\n     pub fn discriminant_for_variant(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n@@ -2480,7 +2469,7 @@ impl<'gcx, 'tcx> AdtDef {\n         (expr_did, variant_index.as_u32() - explicit_index)\n     }\n \n-    pub fn destructor(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Destructor> {\n+    pub fn destructor(&self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n         tcx.adt_destructor(self.did)\n     }\n \n@@ -2494,11 +2483,11 @@ impl<'gcx, 'tcx> AdtDef {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n \n-    fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n+    fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             Bool | Char | Int(..) | Uint(..) | Float(..) |\n             RawPtr(..) | Ref(..) | FnDef(..) | FnPtr(_) |\n@@ -2575,8 +2564,8 @@ impl<'gcx, 'tcx> AdtDef {\n     }\n }\n \n-impl<'gcx, 'tcx> FieldDef {\n-    pub fn ty(&self, tcx: TyCtxt<'gcx, 'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n+impl<'tcx> FieldDef {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }\n }\n@@ -2602,7 +2591,7 @@ impl<'tcx> ClosureKind {\n     // This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n-    pub fn trait_did(&self, tcx: TyCtxt<'tcx, 'tcx>) -> DefId {\n+    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n         match *self {\n             ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n             ClosureKind::FnMut => {\n@@ -2630,7 +2619,7 @@ impl<'tcx> ClosureKind {\n \n     /// Returns the representative scalar type for this closure kind.\n     /// See `TyS::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'_, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self {\n             ty::ClosureKind::Fn => tcx.types.i8,\n             ty::ClosureKind::FnMut => tcx.types.i16,\n@@ -2712,12 +2701,12 @@ impl BorrowKind {\n }\n \n #[derive(Debug, Clone)]\n-pub enum Attributes<'gcx> {\n+pub enum Attributes<'tcx> {\n     Owned(Lrc<[ast::Attribute]>),\n-    Borrowed(&'gcx [ast::Attribute])\n+    Borrowed(&'tcx [ast::Attribute]),\n }\n \n-impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n+impl<'tcx> ::std::ops::Deref for Attributes<'tcx> {\n     type Target = [ast::Attribute];\n \n     fn deref(&self) -> &[ast::Attribute] {\n@@ -2767,15 +2756,15 @@ pub enum ImplOverlapKind {\n     Issue33140\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n-    pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn body_tables(self, body: hir::BodyId) -> &'tcx TypeckTables<'tcx> {\n         self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n     /// Returns an iterator of the `DefId`s for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n-    pub fn body_owners(self) -> impl Iterator<Item = DefId> + Captures<'gcx> + 'tcx {\n+    pub fn body_owners(self) -> impl Iterator<Item = DefId> + Captures<'tcx> + 'tcx {\n         self.hir().krate()\n                   .body_ids\n                   .iter()\n@@ -2899,7 +2888,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn associated_items(self, def_id: DefId) -> AssocItemsIterator<'gcx, 'tcx> {\n+    pub fn associated_items(self, def_id: DefId) -> AssocItemsIterator<'tcx> {\n         // Ideally, we would use `-> impl Iterator` here, but it falls\n         // afoul of the conservative \"capture [restrictions]\" we put\n         // in place, so we use a hand-written iterator.\n@@ -3007,9 +2996,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n-    pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n-                        -> &'gcx Body<'gcx>\n-    {\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {\n             ty::InstanceDef::Item(did) => {\n                 self.optimized_mir(did)\n@@ -3027,7 +3014,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     /// Gets the attributes of a definition.\n-    pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n+    pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n         if let Some(id) = self.hir().as_local_hir_id(did) {\n             Attributes::Borrowed(self.hir().attrs_by_hir_id(id))\n         } else {\n@@ -3122,13 +3109,13 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n }\n \n-pub struct AssocItemsIterator<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    def_ids: &'gcx [DefId],\n+pub struct AssocItemsIterator<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    def_ids: &'tcx [DefId],\n     next_index: usize,\n }\n \n-impl Iterator for AssocItemsIterator<'_, '_> {\n+impl Iterator for AssocItemsIterator<'_> {\n     type Item = AssocItem;\n \n     fn next(&mut self) -> Option<AssocItem> {\n@@ -3138,7 +3125,7 @@ impl Iterator for AssocItemsIterator<'_, '_> {\n     }\n }\n \n-fn associated_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> AssocItem {\n+fn associated_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n@@ -3183,7 +3170,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n ///       such.\n ///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n-fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> AdtSizedConstraint<'tcx> {\n+fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AdtSizedConstraint<'tcx> {\n     let def = tcx.adt_def(def_id);\n \n     let result = tcx.mk_type_list(def.variants.iter().flat_map(|v| {\n@@ -3197,7 +3184,7 @@ fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> AdtSize\n     AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx [DefId] {\n+fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(id);\n     match item.node {\n@@ -3220,14 +3207,14 @@ fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tc\n     }\n }\n \n-fn def_span<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Span {\n+fn def_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n     tcx.hir().span_if_local(def_id).unwrap()\n }\n \n /// If the given `DefId` describes an item belonging to a trait,\n /// returns the `DefId` of the trait that the trait item belongs to;\n /// otherwise, returns `None`.\n-fn trait_of_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n+fn trait_of_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<DefId> {\n     tcx.opt_associated_item(def_id)\n         .and_then(|associated_item| {\n             match associated_item.container {\n@@ -3238,7 +3225,7 @@ fn trait_of_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<DefId>\n }\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n-pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Option<DefId> {\n+pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         if let Node::Item(item) = tcx.hir().get_by_hir_id(hir_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n@@ -3250,7 +3237,7 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Option<DefId> {\n }\n \n /// See `ParamEnv` struct definition for details.\n-fn param_env<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n+fn param_env<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n         return param_env(tcx, parent);\n@@ -3285,25 +3272,22 @@ fn param_env<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n-fn crate_disambiguator<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> CrateDisambiguator {\n+fn crate_disambiguator<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> CrateDisambiguator {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.sess.local_crate_disambiguator()\n }\n \n-fn original_crate_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> Symbol {\n+fn original_crate_name<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> Symbol {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.crate_name.clone()\n }\n \n-fn crate_hash<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> Svh {\n+fn crate_hash<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.hir().crate_hash\n }\n \n-fn instance_def_size_estimate<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    instance_def: InstanceDef<'tcx>,\n-) -> usize {\n+fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx>, instance_def: InstanceDef<'tcx>) -> usize {\n     match instance_def {\n         InstanceDef::Item(..) |\n         InstanceDef::DropGlue(..) => {\n@@ -3318,7 +3302,7 @@ fn instance_def_size_estimate<'tcx>(\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<Ty<'tcx>> {\n+fn issue33140_self_ty<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Ty<'tcx>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx.impl_trait_ref(def_id).unwrap_or_else(|| {"}, {"sha": "7d1403d1e9662dd6f41cc9a7e3afb82b2b4f2540", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -45,7 +45,7 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(&self, ty0: Ty<'tcx>,"}, {"sha": "092e7c6f3fffb6050dfacaa407836d2bef119660", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -13,7 +13,7 @@ pub mod obsolete;\n \n // FIXME(eddyb) false positive, the lifetime parameters are used with `P:  Printer<...>`.\n #[allow(unused_lifetimes)]\n-pub trait Print<'gcx, 'tcx, P> {\n+pub trait Print<'tcx, P> {\n     type Output;\n     type Error;\n \n@@ -28,7 +28,7 @@ pub trait Print<'gcx, 'tcx, P> {\n ///\n /// For pretty-printing/formatting in particular, see `PrettyPrinter`.\n // FIXME(eddyb) find a better name, this is more general than \"printing\".\n-pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n+pub trait Printer<'tcx>: Sized {\n     type Error;\n \n     type Path;\n@@ -37,7 +37,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     type DynExistential;\n     type Const;\n \n-    fn tcx(&'a self) -> TyCtxt<'gcx, 'tcx>;\n+    fn tcx(&'a self) -> TyCtxt<'tcx>;\n \n     fn print_def_path(\n         self,\n@@ -302,41 +302,39 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::RegionKind {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::RegionKind {\n     type Output = P::Region;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_region(self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::Region<'_> {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Region<'_> {\n     type Output = P::Region;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_region(self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for Ty<'tcx> {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     type Output = P::Type;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_type(self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n-    for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n-{\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     type Output = P::DynExistential;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_dyn_existential(self)\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for &'tcx ty::Const<'tcx> {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for &'tcx ty::Const<'tcx> {\n     type Output = P::Const;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {"}, {"sha": "16fb334803926fd2359cf150187976179cdd4690", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -17,17 +17,13 @@ use syntax::ast;\n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n pub struct DefPathBasedNames<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     omit_disambiguators: bool,\n     omit_local_crate_name: bool,\n }\n \n impl DefPathBasedNames<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        omit_disambiguators: bool,\n-        omit_local_crate_name: bool,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, omit_disambiguators: bool, omit_local_crate_name: bool) -> Self {\n         DefPathBasedNames { tcx, omit_disambiguators, omit_local_crate_name }\n     }\n "}, {"sha": "b79d7f06cd6aa85444f40000ba1cffd37791611f", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -166,16 +166,16 @@ impl RegionHighlightMode {\n }\n \n /// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n-    Printer<'gcx, 'tcx,\n+pub trait PrettyPrinter<'tcx>:\n+    Printer<\n+        'tcx,\n         Error = fmt::Error,\n         Path = Self,\n         Region = Self,\n         Type = Self,\n         DynExistential = Self,\n         Const = Self,\n-    > +\n-    fmt::Write\n+    > + fmt::Write\n {\n     /// Like `print_def_path` but for value paths.\n     fn print_value_path(\n@@ -186,21 +186,17 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n         self.print_def_path(def_id, substs)\n     }\n \n-    fn in_binder<T>(\n-        self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n         value.skip_binder().print(self)\n     }\n \n     /// Print comma-separated elements.\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n     {\n         if let Some(first) = elems.next() {\n             self = first.print(self)?;\n@@ -931,10 +927,10 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n-pub struct FmtPrinter<'a, 'gcx, 'tcx, F>(Box<FmtPrinterData<'a, 'gcx, 'tcx, F>>);\n+pub struct FmtPrinter<'a, 'tcx, F>(Box<FmtPrinterData<'a, 'tcx, F>>);\n \n-pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct FmtPrinterData<'a, 'tcx, F> {\n+    tcx: TyCtxt<'tcx>,\n     fmt: F,\n \n     empty_path: bool,\n@@ -949,21 +945,21 @@ pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n     pub name_resolver: Option<Box<&'a dyn Fn(ty::sty::TyVid) -> Option<String>>>,\n }\n \n-impl<F> Deref for FmtPrinter<'a, 'gcx, 'tcx, F> {\n-    type Target = FmtPrinterData<'a, 'gcx, 'tcx, F>;\n+impl<F> Deref for FmtPrinter<'a, 'tcx, F> {\n+    type Target = FmtPrinterData<'a, 'tcx, F>;\n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n \n-impl<F> DerefMut for FmtPrinter<'_, '_, '_, F> {\n+impl<F> DerefMut for FmtPrinter<'_, '_, F> {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         &mut self.0\n     }\n }\n \n-impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n+impl<F> FmtPrinter<'a, 'tcx, F> {\n+    pub fn new(tcx: TyCtxt<'tcx>, fmt: F, ns: Namespace) -> Self {\n         FmtPrinter(Box::new(FmtPrinterData {\n             tcx,\n             fmt,\n@@ -978,7 +974,7 @@ impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n     }\n }\n \n-impl TyCtxt<'_, '_> {\n+impl TyCtxt<'_> {\n     // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n     // (but also some things just print a `DefId` generally so maybe we need this?)\n     fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n@@ -1010,13 +1006,13 @@ impl TyCtxt<'_, '_> {\n     }\n }\n \n-impl<F: fmt::Write> fmt::Write for FmtPrinter<'_, '_, '_, F> {\n+impl<F: fmt::Write> fmt::Write for FmtPrinter<'_, '_, F> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         self.fmt.write_str(s)\n     }\n }\n \n-impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n@@ -1025,7 +1021,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&'a self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&'a self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -1222,7 +1218,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     }\n }\n \n-impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n     fn infer_ty_name(&self, id: ty::TyVid) -> Option<String> {\n         self.0.name_resolver.as_ref().and_then(|func| func(id))\n     }\n@@ -1239,11 +1235,9 @@ impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F>\n         Ok(self)\n     }\n \n-    fn in_binder<T>(\n-        self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n         self.pretty_in_binder(value)\n     }\n@@ -1317,7 +1311,7 @@ impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F>\n }\n \n // HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n-impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n+impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n     pub fn pretty_print_region(\n         mut self,\n         region: ty::Region<'_>,\n@@ -1416,12 +1410,10 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n \n // HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n // `region_index` and `used_region_names`.\n-impl<F: fmt::Write> FmtPrinter<'_, 'gcx, 'tcx, F> {\n-    pub fn pretty_in_binder<T>(\n-        mut self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, fmt::Error>\n-        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n+impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n+    pub fn pretty_in_binder<T>(mut self, value: &ty::Binder<T>) -> Result<Self, fmt::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {\n@@ -1510,9 +1502,9 @@ impl<F: fmt::Write> FmtPrinter<'_, 'gcx, 'tcx, F> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, T, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n-    for ty::Binder<T>\n-    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n+impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::Binder<T>\n+where\n+    T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>,\n {\n     type Output = P;\n     type Error = P::Error;\n@@ -1521,10 +1513,10 @@ impl<'gcx: 'tcx, 'tcx, T, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx, T, U, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n-    for ty::OutlivesPredicate<T, U>\n-    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n-          U: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n+impl<'tcx, T, U, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::OutlivesPredicate<T, U>\n+where\n+    T: Print<'tcx, P, Output = P, Error = P::Error>,\n+    U: Print<'tcx, P, Output = P, Error = P::Error>,\n {\n     type Output = P;\n     type Error = P::Error;\n@@ -1552,7 +1544,7 @@ macro_rules! forward_display_to_print {\n \n macro_rules! define_print_and_forward_display {\n     (($self:ident, $cx:ident): $($ty:ty $print:block)+) => {\n-        $(impl<'gcx: 'tcx, 'tcx, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for $ty {\n+        $(impl<'tcx, P: PrettyPrinter<'tcx>> Print<'tcx, P> for $ty {\n             type Output = P;\n             type Error = fmt::Error;\n             fn print(&$self, $cx: P) -> Result<Self::Output, Self::Error> {\n@@ -1585,7 +1577,7 @@ forward_display_to_print! {\n     &'tcx ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n-    // because `for<'gcx: 'tcx, 'tcx>` isn't possible yet.\n+    // because `for<'tcx>` isn't possible yet.\n     ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n     ty::Binder<ty::TraitRef<'tcx>>,\n     ty::Binder<ty::FnSig<'tcx>>,"}, {"sha": "13d93f173e845b38b099632bcef357c6b7b3a704", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -31,36 +31,36 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: TyCtxt<'tcx, '_>) -> &'a Lock<QueryCache<'tcx, Self>>;\n+    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Lock<QueryCache<'tcx, Self>>;\n \n-    fn to_dep_node(tcx: TyCtxt<'tcx, '_>, key: &Self::Key) -> DepNode;\n+    fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn compute(tcx: TyCtxt<'tcx, '_>, key: Self::Key) -> Self::Value;\n+    fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value;\n \n     fn hash_result(\n         hcx: &mut StableHashingContext<'_>,\n         result: &Self::Value\n     ) -> Option<Fingerprint>;\n \n-    fn handle_cycle_error(tcx: TyCtxt<'tcx, '_>, error: CycleError<'tcx>) -> Self::Value;\n+    fn handle_cycle_error(tcx: TyCtxt<'tcx>, error: CycleError<'tcx>) -> Self::Value;\n }\n \n pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_>, key: Self::Key) -> Cow<'static, str>;\n+    fn describe(tcx: TyCtxt<'_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n-    fn cache_on_disk(_: TyCtxt<'tcx, 'tcx>, _: Self::Key) -> bool {\n+    fn cache_on_disk(_: TyCtxt<'tcx>, _: Self::Key) -> bool {\n         false\n     }\n \n-    fn try_load_from_disk(_: TyCtxt<'tcx, 'tcx>, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n+    fn try_load_from_disk(_: TyCtxt<'tcx>, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n         bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n \n impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n-    default fn describe(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Cow<'static, str> {\n+    default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()\n         } else {\n@@ -71,7 +71,7 @@ impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_>, _: CrateNum) -> Cow<'static, str> {\n+    fn describe(_tcx: TyCtxt<'_>, _: CrateNum) -> Cow<'static, str> {\n         \"running analysis passes on this crate\".into()\n     }\n }\n@@ -80,12 +80,12 @@ macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n             #[inline]\n-            fn cache_on_disk($tcx: TyCtxt<'tcx, 'tcx>, $key: Self::Key) -> bool {\n+            fn cache_on_disk($tcx: TyCtxt<'tcx>, $key: Self::Key) -> bool {\n                 $cond\n             }\n \n             #[inline]\n-            fn try_load_from_disk(tcx: TyCtxt<'tcx, 'tcx>,\n+            fn try_load_from_disk(tcx: TyCtxt<'tcx>,\n                                       id: SerializedDepNodeIndex)\n                                       -> Option<Self::Value> {\n                 tcx.queries.on_disk_cache.try_load_query_result(tcx, id)"}, {"sha": "dcc467a61b5416fbed4ba659c1e193be1dd9069c", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -75,9 +75,9 @@ impl<'tcx> QueryJob<'tcx> {\n \n     /// Awaits for the query job to complete.\n     #[cfg(parallel_compiler)]\n-    pub(super) fn r#await<'lcx>(\n+    pub(super) fn r#await(\n         &self,\n-        tcx: TyCtxt<'tcx, 'lcx>,\n+        tcx: TyCtxt<'tcx>,\n         span: Span,\n     ) -> Result<(), CycleError<'tcx>> {\n         tls::with_related_context(tcx, move |icx| {\n@@ -100,11 +100,7 @@ impl<'tcx> QueryJob<'tcx> {\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn find_cycle_in_stack<'lcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'lcx>,\n-        span: Span,\n-    ) -> CycleError<'tcx> {\n+    pub(super) fn find_cycle_in_stack(&self, tcx: TyCtxt<'tcx>, span: Span) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n         let mut cycle = Vec::new();\n@@ -338,7 +334,7 @@ fn connected_to_root<'tcx>(\n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n-    tcx: TyCtxt<'tcx, '_>,\n+    tcx: TyCtxt<'tcx>,\n     queries: &'a [T],\n     f: F,\n ) -> &'a T {\n@@ -366,7 +362,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n fn remove_cycle<'tcx>(\n     jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n-    tcx: TyCtxt<'tcx, '_>,\n+    tcx: TyCtxt<'tcx>,\n ) -> bool {\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();\n@@ -505,7 +501,7 @@ pub unsafe fn handle_deadlock() {\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n-fn deadlock(tcx: TyCtxt<'_, '_>, registry: &rayon_core::Registry) {\n+fn deadlock(tcx: TyCtxt<'_>, registry: &rayon_core::Registry) {\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();"}, {"sha": "30a3e53dddfbba39c73d4f5442105626e64fc75c", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,15 +22,15 @@ pub(super) trait Key: Clone + Hash + Eq + Debug {\n \n     /// In the event that a cycle occurs, if no explicit span has been\n     /// given for a query with key `self`, what span should we use?\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span;\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n \n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n@@ -40,7 +40,7 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n         LOCAL_CRATE\n     }\n \n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n@@ -50,7 +50,7 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n         self.instance.query_crate()\n     }\n \n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.instance.default_span(tcx)\n     }\n }\n@@ -59,7 +59,7 @@ impl Key for CrateNum {\n     fn query_crate(&self) -> CrateNum {\n         *self\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -68,7 +68,7 @@ impl Key for DefIndex {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -77,7 +77,7 @@ impl Key for DefId {\n     fn query_crate(&self) -> CrateNum {\n         self.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(*self)\n     }\n }\n@@ -86,7 +86,7 @@ impl Key for (DefId, DefId) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n@@ -95,7 +95,7 @@ impl Key for (CrateNum, DefId) {\n     fn query_crate(&self) -> CrateNum {\n         self.0\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n@@ -104,7 +104,7 @@ impl Key for (DefId, SimplifiedType) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n@@ -113,7 +113,7 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n@@ -122,7 +122,7 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.1.def_id())\n     }\n }\n@@ -131,7 +131,7 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -140,7 +140,7 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n@@ -149,7 +149,7 @@ impl<'tcx> Key for ty::Const<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -158,7 +158,7 @@ impl<'tcx> Key for Ty<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -167,7 +167,7 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -176,7 +176,7 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n     fn query_crate(&self) -> CrateNum {\n         self.value.query_crate()\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.value.default_span(tcx)\n     }\n }\n@@ -185,7 +185,7 @@ impl<'tcx> Key for traits::Environment<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -194,7 +194,7 @@ impl Key for InternedString {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -209,7 +209,7 @@ where\n         LOCAL_CRATE\n     }\n \n-    fn default_span(&self, _tcx: TyCtxt<'_, '_>) -> Span {\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }"}, {"sha": "6f83991a2daa2b331ca7932517f65c9096fd5ef6", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -156,11 +156,7 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn serialize<'tcx, E>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        encoder: &mut E,\n-    ) -> Result<(), E::Error>\n+    pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n         E: ty_codec::TyEncoder,\n     {\n@@ -316,7 +312,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n             return Ok(());\n \n-            fn sorted_cnums_including_local_crate(tcx: TyCtxt<'_, '_>) -> Vec<CrateNum> {\n+            fn sorted_cnums_including_local_crate(tcx: TyCtxt<'_>) -> Vec<CrateNum> {\n                 let mut cnums = vec![LOCAL_CRATE];\n                 cnums.extend_from_slice(&tcx.crates()[..]);\n                 cnums.sort_unstable();\n@@ -330,7 +326,7 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Loads a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics<'tcx>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> Vec<Diagnostic> {\n         let diagnostics: Option<EncodedDiagnostics> = self.load_indexed(\n@@ -359,7 +355,7 @@ impl<'sess> OnDiskCache<'sess> {\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> Option<T>\n     where\n@@ -389,7 +385,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n     fn load_indexed<'tcx, T>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n         index: &FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n         debug_tag: &'static str,\n@@ -430,7 +426,7 @@ impl<'sess> OnDiskCache<'sess> {\n     // Session that don't occur in the current one. For these, the mapping\n     // maps to None.\n     fn compute_cnum_map(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         prev_cnums: &[(u32, String, CrateDisambiguator)],\n     ) -> IndexVec<CrateNum, Option<CrateNum>> {\n         tcx.dep_graph.with_ignore(|| {\n@@ -464,7 +460,7 @@ impl<'sess> OnDiskCache<'sess> {\n /// we use for crate metadata decoding in that it can rebase spans and\n /// eventually will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n     cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n@@ -532,7 +528,7 @@ fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n \n impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -751,7 +747,7 @@ impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n //- ENCODING -------------------------------------------------------------------\n \n struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n@@ -1080,7 +1076,7 @@ impl<'a> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'a> {\n }\n \n fn encode_query_results<'a, 'tcx, Q, E>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     encoder: &mut CacheEncoder<'a, 'tcx, E>,\n     query_result_index: &mut EncodedQueryResultIndex,\n ) -> Result<(), E::Error>"}, {"sha": "48e68167f824c5e3af0531ce582aae5f2fc8b933", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -104,11 +104,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    pub(super) fn try_get(\n-        tcx: TyCtxt<'tcx, '_>,\n-        span: Span,\n-        key: &Q::Key,\n-    ) -> TryGetJob<'a, 'tcx, Q> {\n+    pub(super) fn try_get(tcx: TyCtxt<'tcx>, span: Span, key: &Q::Key) -> TryGetJob<'a, 'tcx, Q> {\n         let cache = Q::query_cache(tcx);\n         loop {\n             let mut lock = cache.borrow_mut();\n@@ -247,22 +243,22 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     Cycle(D::Value),\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Executes a job by changing the ImplicitCtxt to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n     pub(super) fn start_query<F, R>(\n         self,\n-        job: Lrc<QueryJob<'gcx>>,\n+        job: Lrc<QueryJob<'tcx>>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: F,\n     ) -> R\n     where\n-        F: for<'lcx> FnOnce(TyCtxt<'gcx, 'lcx>) -> R,\n+        F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n         // The TyCtxt stored in TLS has the same global interner lifetime\n-        // as `self`, so we use `with_related_context` to relate the 'gcx lifetimes\n+        // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n         // when accessing the ImplicitCtxt\n         tls::with_related_context(self, move |current_icx| {\n             // Update the ImplicitCtxt to point to our new query job\n@@ -285,11 +281,11 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<'gcx>,\n+        CycleError { usage, cycle: stack }: CycleError<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n-        let fix_span = |span: Span, query: &Query<'gcx>| {\n+        let fix_span = |span: Span, query: &Query<'tcx>| {\n             self.sess.source_map().def_span(query.default_span(self, span))\n         };\n \n@@ -351,11 +347,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     #[inline(never)]\n-    pub(super) fn get_query<Q: QueryDescription<'gcx>>(\n-        self,\n-        span: Span,\n-        key: Q::Key)\n-    -> Q::Value {\n+    pub(super) fn get_query<Q: QueryDescription<'tcx>>(self, span: Span, key: Q::Key) -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\",\n                Q::NAME.as_str(),\n                key,\n@@ -439,14 +431,13 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         result\n     }\n \n-    fn load_from_disk_and_cache_in_memory<Q: QueryDescription<'gcx>>(\n+    fn load_from_disk_and_cache_in_memory<Q: QueryDescription<'tcx>>(\n         self,\n         key: Q::Key,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node_index: DepNodeIndex,\n-        dep_node: &DepNode\n-    ) -> Q::Value\n-    {\n+        dep_node: &DepNode,\n+    ) -> Q::Value {\n         // Note this function can be called concurrently from the same query\n         // We must ensure that this is handled correctly\n \n@@ -507,7 +498,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n \n     #[inline(never)]\n     #[cold]\n-    fn incremental_verify_ich<Q: QueryDescription<'gcx>>(\n+    fn incremental_verify_ich<Q: QueryDescription<'tcx>>(\n         self,\n         result: &Q::Value,\n         dep_node: &DepNode,\n@@ -533,12 +524,12 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn force_query_with_job<Q: QueryDescription<'gcx>>(\n+    fn force_query_with_job<Q: QueryDescription<'tcx>>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'_, 'gcx, Q>,\n-        dep_node: DepNode)\n-    -> (Q::Value, DepNodeIndex) {\n+        job: JobOwner<'_, 'tcx, Q>,\n+        dep_node: DepNode,\n+    ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in DepGraph::try_mark_green()\n@@ -597,7 +588,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n     ///\n     /// Note: The optimization is only available during incr. comp.\n-    pub(super) fn ensure_query<Q: QueryDescription<'gcx>>(self, key: Q::Key) -> () {\n+    pub(super) fn ensure_query<Q: QueryDescription<'tcx>>(self, key: Q::Key) -> () {\n         let dep_node = Q::to_dep_node(self, &key);\n \n         if dep_node.kind.is_eval_always() {\n@@ -623,12 +614,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn force_query<Q: QueryDescription<'gcx>>(\n-        self,\n-        key: Q::Key,\n-        span: Span,\n-        dep_node: DepNode\n-    ) {\n+    fn force_query<Q: QueryDescription<'tcx>>(self, key: Q::Key, span: Span, dep_node: DepNode) {\n         profq_msg!(\n             self,\n             ProfileQueriesMsg::QueryBegin(span.data(),\n@@ -873,7 +859,7 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            pub fn describe(&self, tcx: TyCtxt<'_, '_>) -> Cow<'static, str> {\n+            pub fn describe(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n                 let (r, name) = match *self {\n                     $(Query::$name(key) => {\n                         (queries::$name::describe(tcx, key), stringify!($name))\n@@ -887,7 +873,7 @@ macro_rules! define_queries_inner {\n             }\n \n             // FIXME(eddyb) Get more valid Span's on queries.\n-            pub fn default_span(&self, tcx: TyCtxt<$tcx, '_>, span: Span) -> Span {\n+            pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n                 if !span.is_dummy() {\n                     return span;\n                 }\n@@ -953,20 +939,20 @@ macro_rules! define_queries_inner {\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<$tcx, '_>) -> &'a Lock<QueryCache<$tcx, Self>> {\n+            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Lock<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n             #[allow(unused)]\n             #[inline(always)]\n-            fn to_dep_node(tcx: TyCtxt<$tcx, '_>, key: &Self::Key) -> DepNode {\n+            fn to_dep_node(tcx: TyCtxt<$tcx>, key: &Self::Key) -> DepNode {\n                 use crate::dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n \n             #[inline]\n-            fn compute(tcx: TyCtxt<'tcx, '_>, key: Self::Key) -> Self::Value {\n+            fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 __query_compute::$name(move || {\n                     let provider = tcx.queries.providers.get(key.query_crate())\n                         // HACK(eddyb) it's possible crates may be loaded after\n@@ -987,19 +973,19 @@ macro_rules! define_queries_inner {\n             }\n \n             fn handle_cycle_error(\n-                tcx: TyCtxt<'tcx, '_>,\n+                tcx: TyCtxt<'tcx>,\n                 error: CycleError<'tcx>\n             ) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx, error])\n             }\n         })*\n \n         #[derive(Copy, Clone)]\n-        pub struct TyCtxtEnsure<'gcx, 'tcx> {\n-            pub tcx: TyCtxt<'gcx, 'tcx>,\n+        pub struct TyCtxtEnsure<'tcx> {\n+            pub tcx: TyCtxt<'tcx>,\n         }\n \n-        impl TyCtxtEnsure<$tcx, 'lcx> {\n+        impl TyCtxtEnsure<$tcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) {\n@@ -1008,24 +994,24 @@ macro_rules! define_queries_inner {\n         }\n \n         #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'gcx, 'tcx> {\n-            pub tcx: TyCtxt<'gcx, 'tcx>,\n+        pub struct TyCtxtAt<'tcx> {\n+            pub tcx: TyCtxt<'tcx>,\n             pub span: Span,\n         }\n \n-        impl Deref for TyCtxtAt<'gcx, 'tcx> {\n-            type Target = TyCtxt<'gcx, 'tcx>;\n+        impl Deref for TyCtxtAt<'tcx> {\n+            type Target = TyCtxt<'tcx>;\n             #[inline(always)]\n             fn deref(&self) -> &Self::Target {\n                 &self.tcx\n             }\n         }\n \n-        impl TyCtxt<$tcx, 'lcx> {\n+        impl TyCtxt<$tcx> {\n             /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n             /// are executed instead of just returing their results.\n             #[inline(always)]\n-            pub fn ensure(self) -> TyCtxtEnsure<$tcx, 'lcx> {\n+            pub fn ensure(self) -> TyCtxtEnsure<$tcx> {\n                 TyCtxtEnsure {\n                     tcx: self,\n                 }\n@@ -1034,7 +1020,7 @@ macro_rules! define_queries_inner {\n             /// Returns a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n             #[inline(always)]\n-            pub fn at(self, span: Span) -> TyCtxtAt<$tcx, 'lcx> {\n+            pub fn at(self, span: Span) -> TyCtxtAt<$tcx> {\n                 TyCtxtAt {\n                     tcx: self,\n                     span\n@@ -1048,7 +1034,7 @@ macro_rules! define_queries_inner {\n             })*\n         }\n \n-        impl TyCtxtAt<$tcx, 'lcx> {\n+        impl TyCtxtAt<$tcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n@@ -1089,12 +1075,12 @@ macro_rules! define_provider_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n         pub struct Providers<$tcx> {\n-            $(pub $name: fn(TyCtxt<$tcx, $tcx>, $K) -> $R,)*\n+            $(pub $name: fn(TyCtxt<$tcx>, $K) -> $R,)*\n         }\n \n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n-                $(fn $name<$tcx>(_: TyCtxt<$tcx, $tcx>, key: $K) -> $R {\n+                $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n                     bug!(\"tcx.{}({:?}) unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n@@ -1147,7 +1133,7 @@ macro_rules! define_provider_struct {\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n-pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> bool {\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n@@ -1233,7 +1219,7 @@ macro_rules! impl_load_from_cache {\n         impl DepNode {\n             // Check whether the query invocation corresponding to the given\n             // DepNode is eligible for on-disk-caching.\n-            pub fn cache_on_disk(&self, tcx: TyCtxt<'_, '_>) -> bool {\n+            pub fn cache_on_disk(&self, tcx: TyCtxt<'_>) -> bool {\n                 use crate::ty::query::queries;\n                 use crate::ty::query::QueryDescription;\n \n@@ -1251,7 +1237,7 @@ macro_rules! impl_load_from_cache {\n             // above `cache_on_disk` methods returns true.\n             // Also, as a sanity check, it expects that the corresponding query\n             // invocation has been marked as green already.\n-            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt<'_, '_>) {\n+            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n                 match self.kind {\n                     $(DepKind::$dep_kind => {\n                         debug_assert!(tcx.dep_graph"}, {"sha": "0149f75716477401e449225d4fc0dd37041cfee0", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -4,36 +4,36 @@ use crate::ty::util::NeedsDrop;\n use syntax::symbol::InternedString;\n \n pub(super) trait Value<'tcx>: Sized {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> Self;\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self;\n }\n \n impl<'tcx, T> Value<'tcx> for T {\n-    default fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> T {\n+    default fn from_cycle_error(tcx: TyCtxt<'tcx>) -> T {\n         tcx.sess.abort_if_errors();\n         bug!(\"Value::from_cycle_error called without errors\");\n     }\n }\n \n impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.types.err\n     }\n }\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n-    fn from_cycle_error(_: TyCtxt<'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n         ty::SymbolName { name: InternedString::intern(\"<error>\") }\n     }\n }\n \n impl<'tcx> Value<'tcx> for NeedsDrop {\n-    fn from_cycle_error(_: TyCtxt<'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n         NeedsDrop(false)\n     }\n }\n \n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n         AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))\n     }\n }"}, {"sha": "98fd5d1a9818dce9e97539fd21d980e15930cb7e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 92, "deletions": 267, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,8 +22,8 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-pub trait TypeRelation<'gcx: 'tcx, 'tcx>: Sized {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx>;\n+pub trait TypeRelation<'tcx>: Sized {\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n@@ -94,27 +94,22 @@ pub trait TypeRelation<'gcx: 'tcx, 'tcx>: Sized {\n }\n \n pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self) -> RelateResult<'tcx, Self>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a;\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: &Self,\n+        b: &Self,\n+    ) -> RelateResult<'tcx, Self>;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::TypeAndMut<'tcx>,\n         b: &ty::TypeAndMut<'tcx>,\n-    ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n                a,\n@@ -133,17 +128,12 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-pub fn relate_substs<'a, 'gcx, 'tcx, R>(\n+pub fn relate_substs<R: TypeRelation<'tcx>>(\n     relation: &mut R,\n     variances: Option<&[ty::Variance]>,\n     a_subst: SubstsRef<'tcx>,\n     b_subst: SubstsRef<'tcx>,\n-) -> RelateResult<'tcx, SubstsRef<'tcx>>\n-where\n-    R: TypeRelation<'gcx, 'tcx>,\n-    'gcx: 'a + 'tcx,\n-    'tcx: 'a,\n-{\n+) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n     let tcx = relation.tcx();\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n@@ -155,16 +145,11 @@ where\n }\n \n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::FnSig<'tcx>,\n         b: &ty::FnSig<'tcx>,\n-    ) -> RelateResult<'tcx, ty::FnSig<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::FnSig<'tcx>> {\n         let tcx = relation.tcx();\n \n         if a.c_variadic != b.c_variadic {\n@@ -199,16 +184,11 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ast::Unsafety,\n         b: &ast::Unsafety,\n-    ) -> RelateResult<'tcx, ast::Unsafety>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ast::Unsafety> {\n         if a != b {\n             Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n         } else {\n@@ -218,16 +198,11 @@ impl<'tcx> Relate<'tcx> for ast::Unsafety {\n }\n \n impl<'tcx> Relate<'tcx> for abi::Abi {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &abi::Abi,\n         b: &abi::Abi,\n-    ) -> RelateResult<'tcx, abi::Abi>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, abi::Abi> {\n         if a == b {\n             Ok(*a)\n         } else {\n@@ -237,16 +212,11 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::ProjectionTy<'tcx>,\n         b: &ty::ProjectionTy<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n                 expected_found(relation, &a.item_def_id, &b.item_def_id)))\n@@ -261,16 +231,11 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::ExistentialProjection<'tcx>,\n         b: &ty::ExistentialProjection<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n                 expected_found(relation, &a.item_def_id, &b.item_def_id)))\n@@ -287,16 +252,11 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n         b: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>> {\n         // To be compatible, `a` and `b` must be for precisely the\n         // same set of traits and item names. We always require that\n         // projection bounds lists are sorted by trait-def-id and item-name,\n@@ -314,16 +274,11 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::TraitRef<'tcx>,\n         b: &ty::TraitRef<'tcx>,\n-    ) -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n@@ -335,16 +290,11 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::ExistentialTraitRef<'tcx>,\n         b: &ty::ExistentialTraitRef<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n@@ -365,16 +315,11 @@ TupleStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &GeneratorWitness<'tcx>,\n         b: &GeneratorWitness<'tcx>,\n-    ) -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n         let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n@@ -383,33 +328,23 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &Ty<'tcx>,\n         b: &Ty<'tcx>,\n-    ) -> RelateResult<'tcx, Ty<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n         relation.tys(a, b)\n     }\n }\n \n /// The main \"type relation\" routine. Note that this does not handle\n /// inference artifacts, so you should filter those out before calling\n /// it.\n-pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(\n+pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n     relation: &mut R,\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n-) -> RelateResult<'tcx, Ty<'tcx>>\n-where\n-    R: TypeRelation<'gcx, 'tcx>,\n-    'gcx: 'a + 'tcx,\n-    'tcx: 'a,\n-{\n+) -> RelateResult<'tcx, Ty<'tcx>> {\n     let tcx = relation.tcx();\n     debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n     match (&a.sty, &b.sty) {\n@@ -604,16 +539,11 @@ where\n /// The main \"const relation\" routine. Note that this does not handle\n /// inference artifacts, so you should filter those out before calling\n /// it.\n-pub fn super_relate_consts<'a, 'gcx, 'tcx, R>(\n+pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     relation: &mut R,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n-) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n-where\n-    R: TypeRelation<'gcx, 'tcx>,\n-    'gcx: 'a + 'tcx,\n-    'tcx: 'a,\n-{\n+) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n@@ -688,12 +618,11 @@ where\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self) -> RelateResult<'tcx, Self>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: &Self,\n+        b: &Self,\n+    ) -> RelateResult<'tcx, Self> {\n         if a.len() != b.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n@@ -713,134 +642,97 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::ClosureSubsts<'tcx>,\n         b: &ty::ClosureSubsts<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::GeneratorSubsts<'tcx>,\n         b: &ty::GeneratorSubsts<'tcx>,\n-    ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &SubstsRef<'tcx>,\n         b: &SubstsRef<'tcx>,\n-    ) -> RelateResult<'tcx, SubstsRef<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n         relate_substs(relation, None, a, b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::Region<'tcx>,\n         b: &ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         relation.regions(*a, *b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &&'tcx ty::Const<'tcx>,\n         b: &&'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         relation.consts(*a, *b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::Binder<T>,\n         b: &ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::Binder<T>> {\n         relation.binders(a, b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Rc<T>, b: &Rc<T>) -> RelateResult<'tcx, Rc<T>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: &Rc<T>,\n+        b: &Rc<T>,\n+    ) -> RelateResult<'tcx, Rc<T>> {\n         let a: &T = a;\n         let b: &T = b;\n         Ok(Rc::new(relation.relate(a, b)?))\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Box<T>, b: &Box<T>) -> RelateResult<'tcx, Box<T>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: &Box<T>,\n+        b: &Box<T>,\n+    ) -> RelateResult<'tcx, Box<T>> {\n         let a: &T = a;\n         let b: &T = b;\n         Ok(Box::new(relation.relate(a, b)?))\n     }\n }\n \n impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &Kind<'tcx>,\n         b: &Kind<'tcx>,\n-    ) -> RelateResult<'tcx, Kind<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'a + 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, Kind<'tcx>> {\n         match (a.unpack(), b.unpack()) {\n             (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n                 Ok(relation.relate(&a_lt, &b_lt)?.into())\n@@ -865,33 +757,23 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::TraitPredicate<'tcx>,\n         b: &ty::TraitPredicate<'tcx>,\n-    ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>> {\n         Ok(ty::TraitPredicate {\n             trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n         })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &ty::ProjectionPredicate<'tcx>,\n         b: &ty::ProjectionPredicate<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>> {\n         Ok(ty::ProjectionPredicate {\n             projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n             ty: relation.relate(&a.ty, &b.ty)?,\n@@ -900,16 +782,11 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::WhereClause<'tcx>,\n         b: &traits::WhereClause<'tcx>,\n-    ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::WhereClause<'tcx>> {\n         use crate::traits::WhereClause::*;\n         match (a, b) {\n             (Implemented(a_pred), Implemented(b_pred)) => {\n@@ -940,16 +817,11 @@ impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::WellFormed<'tcx>,\n         b: &traits::WellFormed<'tcx>,\n-    ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::WellFormed<'tcx>> {\n         use crate::traits::WellFormed::*;\n         match (a, b) {\n             (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n@@ -960,16 +832,11 @@ impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::FromEnv<'tcx>,\n         b: &traits::FromEnv<'tcx>,\n-    ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::FromEnv<'tcx>> {\n         use crate::traits::FromEnv::*;\n         match (a, b) {\n             (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n@@ -980,16 +847,11 @@ impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::DomainGoal<'tcx>,\n         b: &traits::DomainGoal<'tcx>,\n-    ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>> {\n         use crate::traits::DomainGoal::*;\n         match (a, b) {\n             (Holds(a_wc), Holds(b_wc)) => Ok(Holds(relation.relate(a_wc, b_wc)?)),\n@@ -1006,16 +868,11 @@ impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::Goal<'tcx>,\n         b: &traits::Goal<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::Goal<'tcx>> {\n         use crate::traits::GoalKind::*;\n         match (a, b) {\n             (Implies(a_clauses, a_goal), Implies(b_clauses, b_goal)) => {\n@@ -1055,16 +912,11 @@ impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::Goals<'tcx>,\n         b: &traits::Goals<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::Goals<'tcx>> {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n         }\n@@ -1076,16 +928,11 @@ impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::Clause<'tcx>,\n         b: &traits::Clause<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::Clause<'tcx>> {\n         use crate::traits::Clause::*;\n         match (a, b) {\n             (Implies(a_clause), Implies(b_clause)) => {\n@@ -1104,16 +951,11 @@ impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::Clauses<'tcx>,\n         b: &traits::Clauses<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::Clauses<'tcx>> {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n         }\n@@ -1125,16 +967,11 @@ impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::ProgramClause<'tcx>,\n         b: &traits::ProgramClause<'tcx>,\n-    ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>> {\n         Ok(traits::ProgramClause {\n             goal: relation.relate(&a.goal, &b.goal)?,\n             hypotheses: relation.relate(&a.hypotheses, &b.hypotheses)?,\n@@ -1144,16 +981,11 @@ impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::Environment<'tcx>,\n         b: &traits::Environment<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::Environment<'tcx>> {\n         Ok(traits::Environment {\n             clauses: relation.relate(&a.clauses, &b.clauses)?,\n         })\n@@ -1164,16 +996,11 @@ impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n where\n     G: Relate<'tcx>,\n {\n-    fn relate<'a, 'gcx, R>(\n+    fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: &traits::InEnvironment<'tcx, G>,\n         b: &traits::InEnvironment<'tcx, G>,\n-    ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n-    where\n-        R: TypeRelation<'gcx, 'tcx>,\n-        'gcx: 'tcx,\n-        'tcx: 'a,\n-    {\n+    ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>> {\n         Ok(traits::InEnvironment {\n             environment: relation.relate(&a.environment, &b.environment)?,\n             goal: relation.relate(&a.goal, &b.goal)?,\n@@ -1184,12 +1011,10 @@ where\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R, a: &T, b: &T) -> ExpectedFound<T>\n+pub fn expected_found<R, T>(relation: &mut R, a: &T, b: &T) -> ExpectedFound<T>\n where\n-    R: TypeRelation<'gcx, 'tcx>,\n+    R: TypeRelation<'tcx>,\n     T: Clone,\n-    'gcx: 'a + 'tcx,\n-    'tcx: 'a,\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }"}, {"sha": "a4efb566e13e885ed91c0581579fe56b142c56b0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -337,14 +337,14 @@ CloneTypeFoldableAndLiftImpls! {\n // FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n     type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| {\n             tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n         })\n@@ -353,7 +353,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             Some(ref x) => tcx.lift(x).map(Some),\n             None => Some(None)\n@@ -363,7 +363,7 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n \n impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     type Lifted = Result<T::Lifted, E::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             Ok(ref x) => tcx.lift(x).map(Ok),\n             Err(ref e) => tcx.lift(e).map(Err)\n@@ -373,14 +373,14 @@ impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     type Lifted = Box<T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&**self).map(Box::new)\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -397,14 +397,14 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self[..])\n     }\n }\n \n impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     type Lifted = IndexVec<I, T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         self.iter()\n             .map(|e| tcx.lift(e))\n             .collect()\n@@ -413,7 +413,7 @@ impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| ty::TraitRef {\n             def_id: self.def_id,\n             substs,\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef {\n             def_id: self.def_id,\n             substs,\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n     type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::ExistentialPredicate::Trait(x) => {\n                 tcx.lift(x).map(ty::ExistentialPredicate::Trait)\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref,\n         })\n@@ -459,7 +459,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n         tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n             a_is_expected: self.a_is_expected,\n             a,\n@@ -470,14 +470,14 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n \n impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ProjectionTy {\n                 item_def_id: self.item_def_id,\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty, self.ty)).map(|(projection_ty, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty,\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ExistentialProjection {\n                 substs,\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::Predicate::Trait(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::Trait)\n@@ -554,14 +554,14 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(self.skip_binder()).map(ty::Binder::bind)\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n \n impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n     type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.param_env).and_then(|param_env| {\n             tcx.lift(&self.value).map(|value| {\n                 ty::ParamEnvAnd {\n@@ -588,7 +588,7 @@ impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ClosureSubsts { substs }\n         })\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n     type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::GeneratorSubsts { substs }\n         })\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.kind).and_then(|kind| {\n             tcx.lift(&self.target).map(|target| {\n                 ty::adjustment::Adjustment { kind, target }\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n     type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::adjustment::Adjust::NeverToAny =>\n                 Some(ty::adjustment::Adjust::NeverToAny),\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.region).map(|region| {\n             ty::adjustment::OverloadedDeref {\n                 region,\n@@ -647,7 +647,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::adjustment::AutoBorrow::Ref(r, m) => {\n                 tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.yield_ty, self.return_ty))\n            .map(|(yield_ty, return_ty)| {\n                ty::GenSig {\n@@ -674,7 +674,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.inputs_and_output).map(|x| {\n             ty::FnSig {\n                 inputs_and_output: x,\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.expected).and_then(|expected| {\n             tcx.lift(&self.found).map(|found| {\n                 ty::error::ExpectedFound {\n@@ -702,7 +702,7 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         use crate::ty::error::TypeError::*;\n \n         Some(match *self {\n@@ -739,7 +739,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::InstanceDef::Item(def_id) =>\n                 Some(ty::InstanceDef::Item(def_id)),\n@@ -795,7 +795,7 @@ BraceStructLiftImpl! {\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n \n@@ -804,8 +804,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n+impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n@@ -822,7 +822,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Rc::new((**self).fold_with(folder))\n     }\n \n@@ -832,7 +832,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let content: T = (**self).fold_with(folder);\n         box content\n     }\n@@ -843,7 +843,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n \n@@ -853,7 +853,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>().into_boxed_slice()\n     }\n \n@@ -862,12 +862,12 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.map_bound_ref(|ty| ty.fold_with(folder))\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_binder(self)\n     }\n \n@@ -885,7 +885,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_existential_predicates(&v)\n     }\n@@ -904,7 +904,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_type_list(&v)\n     }\n@@ -915,7 +915,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_projs(&v)\n     }\n@@ -926,7 +926,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::ty::InstanceDef::*;\n         Self {\n             substs: self.substs.fold_with(folder),\n@@ -976,7 +976,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Self {\n             instance: self.instance.fold_with(folder),\n             promoted: self.promoted\n@@ -989,7 +989,7 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n             ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n             ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n@@ -1041,7 +1041,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_ty(*self)\n     }\n \n@@ -1124,11 +1124,11 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_region(*self)\n     }\n \n@@ -1189,7 +1189,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_predicates(&v)\n     }\n@@ -1274,7 +1274,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|x| x.fold_with(folder)).collect()\n     }\n \n@@ -1310,7 +1310,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let ty = self.ty.fold_with(folder);\n         let val = self.val.fold_with(folder);\n         folder.tcx().mk_const(ty::Const {\n@@ -1319,7 +1319,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n         })\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_const(*self)\n     }\n \n@@ -1333,7 +1333,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ConstValue::ByRef(ptr, alloc) => ConstValue::ByRef(ptr, alloc),\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n@@ -1360,7 +1360,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n "}, {"sha": "810a26d373648ee254230b3ba08434f86607b64f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 65, "deletions": 77, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -324,7 +324,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Divides the closure substs into their respective\n     /// components. Single source of truth with respect to the\n     /// ordering.\n-    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> SplitClosureSubsts<'tcx> {\n+    fn split(self, def_id: DefId, tcx: TyCtxt<'_>) -> SplitClosureSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count;\n         SplitClosureSubsts {\n@@ -338,7 +338,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     pub fn upvar_tys(\n         self,\n         def_id: DefId,\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n@@ -353,15 +353,15 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; may return a type\n     /// variable during inference. To get the closure kind during\n     /// inference, use `infcx.closure_kind(def_id, substs)`.\n-    pub fn closure_kind_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n+    pub fn closure_kind_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).closure_kind_ty\n     }\n \n     /// Returns the type representing the closure signature for this\n     /// closure; may contain type variables during inference. To get\n     /// the closure signature during inference, use\n     /// `infcx.fn_sig(def_id)`.\n-    pub fn closure_sig_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n+    pub fn closure_sig_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).closure_sig_ty\n     }\n \n@@ -370,7 +370,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_kind()`.\n-    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'tcx, 'tcx>) -> ty::ClosureKind {\n+    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n@@ -379,7 +379,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_sig()`.\n-    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n@@ -403,7 +403,7 @@ struct SplitGeneratorSubsts<'tcx> {\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n-    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> SplitGeneratorSubsts<'tcx> {\n+    fn split(self, def_id: DefId, tcx: TyCtxt<'_>) -> SplitGeneratorSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count;\n         SplitGeneratorSubsts {\n@@ -419,15 +419,15 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// It contains a tuple of all the types that could end up on a generator frame.\n     /// The state transformation MIR pass may only produce layouts which mention types\n     /// in this tuple. Upvars are not counted here.\n-    pub fn witness(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n+    pub fn witness(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).witness\n     }\n \n     #[inline]\n     pub fn upvar_tys(\n         self,\n         def_id: DefId,\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitGeneratorSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n@@ -440,12 +440,12 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     }\n \n     /// Returns the type representing the yield type of the generator.\n-    pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n+    pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).yield_ty\n     }\n \n     /// Returns the type representing the return type of the generator.\n-    pub fn return_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n+    pub fn return_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).return_ty\n     }\n \n@@ -455,21 +455,21 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// N.B., some bits of the code prefers to see this wrapped in a\n     /// binder, but it never contains bound regions. Probably this\n     /// function should be removed.\n-    pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> PolyGenSig<'tcx> {\n+    pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_>) -> PolyGenSig<'tcx> {\n         ty::Binder::dummy(self.sig(def_id, tcx))\n     }\n \n     /// Returns the \"generator signature\", which consists of its yield\n     /// and return types.\n-    pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> GenSig<'tcx> {\n+    pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_>) -> GenSig<'tcx> {\n         ty::GenSig {\n             yield_ty: self.yield_ty(def_id, tcx),\n             return_ty: self.return_ty(def_id, tcx),\n         }\n     }\n }\n \n-impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n+impl<'tcx> GeneratorSubsts<'tcx> {\n     /// Generator have not been resumed yet\n     pub const UNRESUMED: usize = 0;\n     /// Generator has returned / is completed\n@@ -483,7 +483,7 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// The valid variant indices of this Generator.\n     #[inline]\n-    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'gcx, 'tcx>) -> Range<VariantIdx> {\n+    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'tcx>) -> Range<VariantIdx> {\n         // FIXME requires optimized MIR\n         let num_variants = tcx.generator_layout(def_id).variant_fields.len();\n         (VariantIdx::new(0)..VariantIdx::new(num_variants))\n@@ -495,7 +495,7 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     pub fn discriminant_for_variant(\n         &self,\n         def_id: DefId,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n         // Generators don't support explicit discriminant values, so they are\n@@ -510,8 +510,8 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     pub fn discriminants(\n         &'tcx self,\n         def_id: DefId,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n         self.variant_range(def_id, tcx).map(move |index| {\n             (index, Discr { val: index.as_usize() as u128, ty: self.discr_ty(tcx) })\n         })\n@@ -531,7 +531,7 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// The type of the state discriminant used in the generator type.\n     #[inline]\n-    pub fn discr_ty(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn discr_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.types.u32\n     }\n \n@@ -545,8 +545,8 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     pub fn state_tys(\n         self,\n         def_id: DefId,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> impl Iterator<Item = impl Iterator<Item = Ty<'tcx>> + Captures<'gcx>> {\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl Iterator<Item = impl Iterator<Item = Ty<'tcx>> + Captures<'tcx>> {\n         let layout = tcx.generator_layout(def_id);\n         layout.variant_fields.iter().map(move |variant| {\n             variant.iter().map(move |field| {\n@@ -558,11 +558,7 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n     #[inline]\n-    pub fn prefix_tys(\n-        self,\n-        def_id: DefId,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> impl Iterator<Item = Ty<'tcx>> {\n+    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = Ty<'tcx>> {\n         self.upvar_tys(def_id, tcx)\n     }\n }\n@@ -578,7 +574,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     pub fn upvar_tys(\n         self,\n         def_id: DefId,\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let upvar_kinds = match self {\n             UpvarSubsts::Closure(substs) => substs.split(def_id, tcx).upvar_kinds,\n@@ -605,10 +601,10 @@ pub enum ExistentialPredicate<'tcx> {\n     AutoTrait(DefId),\n }\n \n-impl<'gcx, 'tcx> ExistentialPredicate<'tcx> {\n+impl<'tcx> ExistentialPredicate<'tcx> {\n     /// Compares via an ordering that will not change if modules are reordered or other changes are\n     /// made to the tree. In particular, this ordering is preserved across incremental compilations.\n-    pub fn stable_cmp(&self, tcx: TyCtxt<'gcx, 'tcx>, other: &Self) -> Ordering {\n+    pub fn stable_cmp(&self, tcx: TyCtxt<'tcx>, other: &Self) -> Ordering {\n         use self::ExistentialPredicate::*;\n         match (*self, *other) {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n@@ -624,8 +620,8 @@ impl<'gcx, 'tcx> ExistentialPredicate<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n+impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n@@ -757,7 +753,7 @@ impl<'tcx> TraitRef<'tcx> {\n \n     /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`\n     /// are the parameters defined on trait.\n-    pub fn identity<'gcx>(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n+    pub fn identity(tcx: TyCtxt<'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n         TraitRef {\n             def_id,\n             substs: InternalSubsts::identity_for_item(tcx, def_id),\n@@ -778,7 +774,7 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn from_method(\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n@@ -822,7 +818,7 @@ pub struct ExistentialTraitRef<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-impl<'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n+impl<'tcx> ExistentialTraitRef<'tcx> {\n     pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'b {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n@@ -832,7 +828,7 @@ impl<'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     }\n \n     pub fn erase_self_ty(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n     ) -> ty::ExistentialTraitRef<'tcx> {\n         // Assert there is a Self.\n@@ -848,7 +844,7 @@ impl<'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>) -> ty::TraitRef<'tcx> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::TraitRef<'tcx> {\n         // otherwise the escaping vars would be captured by the binder\n         // debug_assert!(!self_ty.has_escaping_bound_vars());\n \n@@ -870,7 +866,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'_, 'tcx>, self_ty: Ty<'tcx>) -> ty::PolyTraitRef<'tcx> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::PolyTraitRef<'tcx> {\n         self.map_bound(|trait_ref| trait_ref.with_self_ty(tcx, self_ty))\n     }\n }\n@@ -1004,7 +1000,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n     /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         trait_ref: ty::TraitRef<'tcx>,\n         item_name: Ident,\n     ) -> ProjectionTy<'tcx> {\n@@ -1022,7 +1018,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// Extracts the underlying trait reference from this projection.\n     /// For example, if this is a projection of `<T as Iterator>::Item`,\n     /// then this function would return a `T: Iterator` trait reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_, '_>) -> ty::TraitRef<'tcx> {\n+    pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::TraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::TraitRef {\n             def_id,\n@@ -1126,7 +1122,7 @@ pub struct ParamTy {\n     pub name: InternedString,\n }\n \n-impl<'gcx, 'tcx> ParamTy {\n+impl<'tcx> ParamTy {\n     pub fn new(index: u32, name: InternedString) -> ParamTy {\n         ParamTy { index, name: name }\n     }\n@@ -1139,7 +1135,7 @@ impl<'gcx, 'tcx> ParamTy {\n         ParamTy::new(def.index, def.name)\n     }\n \n-    pub fn to_ty(self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n \n@@ -1158,7 +1154,7 @@ pub struct ParamConst {\n     pub name: InternedString,\n }\n \n-impl<'gcx, 'tcx> ParamConst {\n+impl<'tcx> ParamConst {\n     pub fn new(index: u32, name: InternedString) -> ParamConst {\n         ParamConst { index, name }\n     }\n@@ -1167,7 +1163,7 @@ impl<'gcx, 'tcx> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n \n-    pub fn to_const(self, tcx: TyCtxt<'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+    pub fn to_const(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n         tcx.mk_const_param(self.index, self.name, ty)\n     }\n }\n@@ -1422,12 +1418,12 @@ pub struct ExistentialProjection<'tcx> {\n \n pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n \n-impl<'tcx, 'gcx> ExistentialProjection<'tcx> {\n+impl<'tcx> ExistentialProjection<'tcx> {\n     /// Extracts the underlying existential trait reference from this projection.\n     /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n     /// then this function would return a `exists T. T: Iterator` existential trait\n     /// reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_, '_>) -> ty::ExistentialTraitRef<'tcx> {\n+    pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::ExistentialTraitRef{\n             def_id,\n@@ -1437,7 +1433,7 @@ impl<'tcx, 'gcx> ExistentialProjection<'tcx> {\n \n     pub fn with_self_ty(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::ProjectionPredicate<'tcx> {\n         // otherwise the escaping regions would be captured by the binders\n@@ -1453,10 +1449,10 @@ impl<'tcx, 'gcx> ExistentialProjection<'tcx> {\n     }\n }\n \n-impl<'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+impl<'tcx> PolyExistentialProjection<'tcx> {\n     pub fn with_self_ty(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::PolyProjectionPredicate<'tcx> {\n         self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n@@ -1670,7 +1666,7 @@ impl RegionKind {\n     /// of the impl, and for all the other highlighted regions, it\n     /// would return the `DefId` of the function. In other cases (not shown), this\n     /// function might return the `DefId` of a closure.\n-    pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_>) -> DefId {\n+    pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_>) -> DefId {\n         match self {\n             ty::ReEarlyBound(br) => {\n                 tcx.parent(br.def_id).unwrap()\n@@ -1682,7 +1678,7 @@ impl RegionKind {\n }\n \n /// Type utilities\n-impl<'gcx, 'tcx> TyS<'tcx> {\n+impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_unit(&self) -> bool {\n         match self.sty {\n@@ -1705,7 +1701,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n     /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n     /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n     /// size, to account for partial initialisation. See #49298 for details.)\n-    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n+    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'tcx>) -> bool {\n         // FIXME(varkor): we can make this less conversative by substituting concrete\n         // type arguments.\n         match self.sty {\n@@ -1817,15 +1813,15 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             Array(ty, _) | Slice(ty) => ty,\n             Str => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             Adt(def, substs) => {\n                 def.non_enum_variant().fields[0].ty(tcx, substs)\n@@ -1834,7 +1830,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn simd_size(&self, _cx: TyCtxt<'_, '_>) -> usize {\n+    pub fn simd_size(&self, _cx: TyCtxt<'_>) -> usize {\n         match self.sty {\n             Adt(def, _) => def.non_enum_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n@@ -2054,7 +2050,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n             FnDef(def_id, substs) => {\n                 tcx.fn_sig(def_id).subst(tcx, substs)\n@@ -2102,7 +2098,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n     /// If the type contains variants, returns the valid range of variant indices.\n     /// FIXME This requires the optimized MIR in the case of generators.\n     #[inline]\n-    pub fn variant_range(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Range<VariantIdx>> {\n+    pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n         match self.sty {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => Some(substs.variant_range(def_id, tcx)),\n@@ -2116,7 +2112,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn discriminant_for_variant(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.sty {\n@@ -2207,7 +2203,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n     ///\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n-    pub fn is_trivially_sized(&self, tcx: TyCtxt<'_, 'tcx>) -> bool {\n+    pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.sty {\n             ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n@@ -2257,19 +2253,15 @@ static_assert_size!(Const<'_>, 40);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]\n-    pub fn from_scalar(tcx: TyCtxt<'_, 'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n+    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n         tcx.mk_const(Self {\n             val: ConstValue::Scalar(val),\n             ty,\n         })\n     }\n \n     #[inline]\n-    pub fn from_bits(\n-        tcx: TyCtxt<'_, 'tcx>,\n-        bits: u128,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> &'tcx Self {\n+    pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n@@ -2278,22 +2270,22 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn zero_sized(tcx: TyCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+    pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]\n-    pub fn from_bool(tcx: TyCtxt<'_, 'tcx>, v: bool) -> &'tcx Self {\n+    pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> &'tcx Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n-    pub fn from_usize(tcx: TyCtxt<'_, 'tcx>, n: u64) -> &'tcx Self {\n+    pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> &'tcx Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n-    pub fn to_bits(&self, tcx: TyCtxt<'_, 'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n+    pub fn to_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         if self.ty != ty.value {\n             return None;\n         }\n@@ -2308,19 +2300,15 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bits(\n-        &self,\n-        tcx: TyCtxt<'_, '_>,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Option<u128> {\n+    pub fn assert_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         assert_eq!(self.ty, ty.value);\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n         self.val.try_to_bits(size)\n     }\n \n     #[inline]\n-    pub fn assert_bool(&self, tcx: TyCtxt<'_, '_>) -> Option<bool> {\n+    pub fn assert_bool(&self, tcx: TyCtxt<'_>) -> Option<bool> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n@@ -2329,18 +2317,18 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_usize(&self, tcx: TyCtxt<'_, '_>) -> Option<u64> {\n+    pub fn assert_usize(&self, tcx: TyCtxt<'_>) -> Option<u64> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, tcx: TyCtxt<'_, '_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n+    pub fn unwrap_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n         self.assert_bits(tcx, ty).unwrap_or_else(||\n             bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n     }\n \n     #[inline]\n-    pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_>) -> u64 {\n+    pub fn unwrap_usize(&self, tcx: TyCtxt<'_>) -> u64 {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }"}, {"sha": "79dcd327f52d4882af0ec38840ab37bb06855d1c", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> Kind<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n     type Lifted = Kind<'tcx>;\n \n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n             UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n             UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n@@ -182,9 +182,9 @@ pub type InternalSubsts<'tcx> = List<Kind<'tcx>>;\n \n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n-impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n+impl<'a, 'tcx> InternalSubsts<'tcx> {\n     /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n-    pub fn identity_for_item(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+    pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n@@ -194,7 +194,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n     /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n     /// variant (which has a `DefId`).\n-    pub fn bound_vars_for_item(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+    pub fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             match param.kind {\n                 ty::GenericParamDefKind::Type { .. } => {\n@@ -230,7 +230,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n-    pub fn for_item<F>(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n+    pub fn for_item<F>(tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n     where\n         F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n@@ -241,12 +241,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         tcx.intern_substs(&substs)\n     }\n \n-    pub fn extend_to<F>(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        def_id: DefId,\n-        mut mk_kind: F,\n-    ) -> SubstsRef<'tcx>\n+    pub fn extend_to<F>(&self, tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n     where\n         F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n@@ -259,7 +254,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n \n     fn fill_item<F>(\n         substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         defs: &ty::Generics,\n         mk_kind: &mut F,\n     ) where\n@@ -373,21 +368,21 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// parameters (e.g., method parameters) on top of that base.\n     pub fn rebase_onto(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         source_ancestor: DefId,\n         target_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n     }\n \n-    pub fn truncate_to(&self, tcx: TyCtxt<'gcx, 'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {\n+    pub fn truncate_to(&self, tcx: TyCtxt<'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n \n         // If folding doesn't change the substs, it's faster to avoid\n@@ -414,25 +409,15 @@ impl<'tcx> serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx>: Sized {\n-    fn subst<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: &[Kind<'tcx>]) -> Self {\n+    fn subst(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned<'gcx>(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        substs: &[Kind<'tcx>],\n-        span: Option<Span>,\n-    ) -> Self;\n+    fn subst_spanned(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>], span: Option<Span>) -> Self;\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned<'gcx>(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        substs: &[Kind<'tcx>],\n-        span: Option<Span>,\n-    ) -> T {\n+    fn subst_spanned(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>], span: Option<Span>) -> T {\n         let mut folder = SubstFolder { tcx,\n                                        substs,\n                                        span,\n@@ -446,8 +431,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct SubstFolder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     substs: &'a [Kind<'tcx>],\n \n     /// The location for which the substitution is performed, if available.\n@@ -463,8 +448,8 @@ struct SubstFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     binders_passed: u32,\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.binders_passed += 1;\n@@ -547,7 +532,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.get(p.index as usize).map(|k| k.unpack());"}, {"sha": "c40d4d5b9cc35ec15facb8ef144494f3601f1b24", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -46,7 +46,7 @@ pub struct TraitImpls {\n     non_blanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n }\n \n-impl<'gcx, 'tcx> TraitDef {\n+impl<'tcx> TraitDef {\n     pub fn new(def_id: DefId,\n                unsafety: hir::Unsafety,\n                paren_sugar: bool,\n@@ -66,14 +66,14 @@ impl<'gcx, 'tcx> TraitDef {\n \n     pub fn ancestors(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         of_impl: DefId,\n-    ) -> specialization_graph::Ancestors<'gcx> {\n+    ) -> specialization_graph::Ancestors<'tcx> {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn for_each_impl<F: FnMut(DefId)>(self, def_id: DefId, mut f: F) {\n         let impls = self.trait_impls_of(def_id);\n \n@@ -151,7 +151,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n \n // Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_id: DefId,\n ) -> &'tcx TraitImpls {\n     let mut impls = TraitImpls::default();"}, {"sha": "a3b99f143d055ea7a9d729082d64cc1fc19fac6e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -51,10 +51,10 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n \n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n-    pub fn wrap_incr<'gcx>(self, tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n+    pub fn wrap_incr(self, tcx: TyCtxt<'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n-    pub fn checked_add<'gcx>(self, tcx: TyCtxt<'gcx, 'tcx>, n: u128) -> (Self, bool) {\n+    pub fn checked_add(self, tcx: TyCtxt<'tcx>, n: u128) -> (Self, bool) {\n         let (int, signed) = match self.ty.sty {\n             Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n             Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n@@ -104,17 +104,13 @@ impl<'tcx> Discr<'tcx> {\n }\n \n pub trait IntTypeExt {\n-    fn to_ty<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        val: Option<Discr<'tcx>>,\n-    ) -> Option<Discr<'tcx>>;\n-    fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Discr<'tcx>;\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'tcx>(&self, tcx: TyCtxt<'tcx>, val: Option<Discr<'tcx>>) -> Option<Discr<'tcx>>;\n+    fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Discr<'tcx>;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             SignedInt(ast::IntTy::I8)       => tcx.types.i8,\n             SignedInt(ast::IntTy::I16)      => tcx.types.i16,\n@@ -131,18 +127,14 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Discr<'tcx> {\n+    fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Discr<'tcx> {\n         Discr {\n             val: 0,\n             ty: self.to_ty(tcx)\n         }\n     }\n \n-    fn disr_incr<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        val: Option<Discr<'tcx>>,\n-    ) -> Option<Discr<'tcx>> {\n+    fn disr_incr<'tcx>(&self, tcx: TyCtxt<'tcx>, val: Option<Discr<'tcx>>) -> Option<Discr<'tcx>> {\n         if let Some(val) = val {\n             assert_eq!(self.to_ty(tcx), val.ty);\n             let (new, oflo) = val.checked_add(tcx, 1);\n@@ -183,7 +175,7 @@ pub enum Representability {\n impl<'tcx> ty::ParamEnv<'tcx> {\n     pub fn can_type_implement_copy(\n         self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         self_type: Ty<'tcx>,\n     ) -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n@@ -232,7 +224,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n@@ -253,7 +245,7 @@ impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         if let ty::Adt(def, substs) = ty.sty {\n             for field in def.all_fields() {\n@@ -628,18 +620,18 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     ) -> Result<Ty<'tcx>, Ty<'tcx>> {\n         use crate::ty::fold::TypeFolder;\n \n-        struct OpaqueTypeExpander<'gcx, 'tcx> {\n+        struct OpaqueTypeExpander<'tcx> {\n             // Contains the DefIds of the opaque types that are currently being\n             // expanded. When we expand an opaque type we insert the DefId of\n             // that type, and when we finish expanding that type we remove the\n             // its DefId.\n             seen_opaque_tys: FxHashSet<DefId>,\n             primary_def_id: DefId,\n             found_recursion: bool,\n-            tcx: TyCtxt<'gcx, 'tcx>,\n+            tcx: TyCtxt<'tcx>,\n         }\n \n-        impl<'gcx, 'tcx> OpaqueTypeExpander<'gcx, 'tcx> {\n+        impl<'tcx> OpaqueTypeExpander<'tcx> {\n             fn expand_opaque_ty(\n                 &mut self,\n                 def_id: DefId,\n@@ -662,8 +654,8 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpaqueTypeExpander<'gcx, 'tcx> {\n-            fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+        impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n+            fn tcx(&self) -> TyCtxt<'tcx> {\n                 self.tcx\n             }\n \n@@ -701,7 +693,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// winds up being reported as an error during NLL borrow check.\n     pub fn is_copy_modulo_regions(\n         &'tcx self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         span: Span,\n     ) -> bool {\n@@ -714,11 +706,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(\n-        &'tcx self,\n-        tcx_at: TyCtxtAt<'tcx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n+    pub fn is_sized(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n@@ -731,7 +719,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// effectively an implementation detail.\n     pub fn is_freeze(\n         &'tcx self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         span: Span,\n     ) -> bool {\n@@ -745,7 +733,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n     #[inline]\n-    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0\n     }\n \n@@ -764,7 +752,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: TyCtxt<'tcx, 'tcx>, sp: Span) -> Representability {\n+    pub fn is_representable(&'tcx self, tcx: TyCtxt<'tcx>, sp: Span) -> Representability {\n         // Iterate until something non-representable is found\n         fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n             iter.fold(Representability::Representable, |r1, r2| {\n@@ -779,7 +767,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n \n         fn are_inner_types_recursive<'tcx>(\n-            tcx: TyCtxt<'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n@@ -839,7 +827,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n         fn is_type_structurally_recursive<'tcx>(\n-            tcx: TyCtxt<'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n@@ -860,7 +848,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n \n         fn is_type_structurally_recursive_inner<'tcx>(\n-            tcx: TyCtxt<'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n@@ -937,7 +925,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n     tcx.infer_ctxt()\n@@ -950,7 +938,7 @@ fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'t\n         ))\n }\n \n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n     tcx.infer_ctxt()\n@@ -963,7 +951,7 @@ fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'\n         ))\n }\n \n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n     tcx.infer_ctxt()\n@@ -979,10 +967,7 @@ fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> NeedsDrop {\n+fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {"}, {"sha": "6b2f00e5f703fd18b8ca57cf940b2e09d4ff087c", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,13 +15,13 @@ use crate::mir::interpret::ConstValue;\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n-pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                   param_env: ty::ParamEnv<'tcx>,\n-                                   body_id: hir::HirId,\n-                                   ty: Ty<'tcx>,\n-                                   span: Span)\n-                                   -> Option<Vec<traits::PredicateObligation<'tcx>>>\n-{\n+pub fn obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n     let mut wf = WfPredicates { infcx,\n                                 param_env,\n                                 body_id,\n@@ -41,25 +41,25 @@ pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n-pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                         param_env: ty::ParamEnv<'tcx>,\n-                                         body_id: hir::HirId,\n-                                         trait_ref: &ty::TraitRef<'tcx>,\n-                                         span: Span)\n-                                         -> Vec<traits::PredicateObligation<'tcx>>\n-{\n+pub fn trait_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    trait_ref: &ty::TraitRef<'tcx>,\n+    span: Span,\n+) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n \n-pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             param_env: ty::ParamEnv<'tcx>,\n-                                             body_id: hir::HirId,\n-                                             predicate: &ty::Predicate<'tcx>,\n-                                             span: Span)\n-                                             -> Vec<traits::PredicateObligation<'tcx>>\n-{\n+pub fn predicate_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    predicate: &ty::Predicate<'tcx>,\n+    span: Span,\n+) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n@@ -101,8 +101,8 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     wf.normalize()\n }\n \n-struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct WfPredicates<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n     span: Span,\n@@ -138,7 +138,7 @@ enum Elaborate {\n     None,\n }\n \n-impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n@@ -508,8 +508,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn object_region_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n ) -> Vec<ty::Region<'tcx>> {\n     // Since we don't actually *know* the self type for an object,"}, {"sha": "4a36d441d3d9f755dd61c29938634f8f930c0bf3", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -231,7 +231,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n }\n \n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,"}, {"sha": "4d03b58179db0f6600f093c19321dec7398cfd05", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -45,7 +45,7 @@ pub enum PatternSource<'tcx> {\n ///\n /// In this latter case, this function will return `PatternSource::LetDecl`\n /// with a reference to the let\n-fn get_pattern_source<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n+fn get_pattern_source<'tcx>(tcx: TyCtxt<'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n     let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n "}, {"sha": "b1854a06693cc8b8c2db327ea8b23d04a5f8f124", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -251,7 +251,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'tcx> { self.bccx.tcx }\n \n     /// Guarantees that `cmt` is assignable, or reports an error.\n     fn guarantee_assignment_valid(&mut self,"}, {"sha": "9b0dce50dd0cb17f7cf219063ef7413d4d815a04", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -53,7 +53,7 @@ pub struct LoanDataFlowOperator;\n \n pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) {\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().borrowck(body_owner_def_id);\n     });\n@@ -73,7 +73,7 @@ pub struct AnalysisData<'tcx> {\n     pub move_data: move_data::FlowedMoveData<'tcx>,\n }\n \n-fn borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, owner_def_id: DefId) -> &'tcx BorrowCheckResult {\n+fn borrowck<'tcx>(tcx: TyCtxt<'tcx>, owner_def_id: DefId) -> &'tcx BorrowCheckResult {\n     assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n@@ -193,7 +193,7 @@ where\n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body_id: hir::BodyId,\n     cfg: &cfg::CFG,\n ) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n@@ -220,7 +220,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n // Type definitions\n \n pub struct BorrowckCtxt<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     // tables for the current thing we are checking; set to\n     // Some in `borrowck_fn` and cleared later\n@@ -388,7 +388,7 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_, '_>) -> HirId {\n+fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n     let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n     match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {"}, {"sha": "9feea64f182359524209a43b5aa5854a15c8a5df", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -223,7 +223,7 @@ impl MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'tcx, 'tcx>, lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n+    pub fn move_path(&self, tcx: TyCtxt<'tcx>, lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         if let Some(&index) = self.path_map.borrow().get(&lp) {\n             return index;\n         }\n@@ -312,7 +312,7 @@ impl MoveData<'tcx> {\n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n     pub fn add_move(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         orig_lp: Rc<LoanPath<'tcx>>,\n         id: hir::ItemLocalId,\n         kind: MoveKind,\n@@ -344,7 +344,7 @@ impl MoveData<'tcx> {\n \n     fn add_move_helper(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         lp: Rc<LoanPath<'tcx>>,\n         id: hir::ItemLocalId,\n         kind: MoveKind,\n@@ -372,7 +372,7 @@ impl MoveData<'tcx> {\n     /// `span`.\n     pub fn add_assignment(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         lp: Rc<LoanPath<'tcx>>,\n         assign_id: hir::ItemLocalId,\n         span: Span,\n@@ -405,7 +405,7 @@ impl MoveData<'tcx> {\n \n     fn add_assignment_helper(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         lp: Rc<LoanPath<'tcx>>,\n         assign_id: hir::ItemLocalId,\n         span: Span,"}, {"sha": "f5d311b35d738987b3205fdd4fa90518721232b7", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -27,7 +27,7 @@ pub enum EntryOrExit {\n \n #[derive(Clone)]\n pub struct DataFlowContext<'tcx, O> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -225,7 +225,7 @@ pub enum KillFrom {\n \n impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n     pub fn new(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         analysis_name: &'static str,\n         body: Option<&hir::Body>,\n         cfg: &cfg::CFG,"}, {"sha": "02a05fd1102006e634433529ff67b866d952bc80", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_, '_>, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {"}, {"sha": "4735588f29a02507df33b38fa48753b3526b2636", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -367,7 +367,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn wasm_import_module(tcx: TyCtxt<'_, '_>, id: DefId) -> Option<CString> {\n+fn wasm_import_module(tcx: TyCtxt<'_>, id: DefId) -> Option<CString> {\n     tcx.wasm_import_module_map(id.krate)\n         .get(&id)\n         .map(|s| CString::new(&s[..]).unwrap())"}, {"sha": "3638730707f3f6046f573f363cbb8844203c703f", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -89,7 +89,7 @@ pub fn create_informational_target_machine(\n }\n \n pub fn create_target_machine(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE), find_features)()"}, {"sha": "04645dacfec58c7d9795e7da2f2c2a3588a8ffd4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -41,8 +41,8 @@ use rustc::hir::CodegenFnAttrs;\n \n use crate::value::Value;\n \n-pub fn write_compressed_metadata<'gcx>(\n-    tcx: TyCtxt<'gcx, 'gcx>,\n+pub fn write_compressed_metadata<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     metadata: &EncodedMetadata,\n     llvm_module: &mut ModuleLlvm,\n ) {\n@@ -103,7 +103,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-pub fn compile_codegen_unit(tcx: TyCtxt<'tcx, 'tcx>, cgu_name: InternedString) {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n@@ -124,7 +124,7 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'tcx, 'tcx>, cgu_name: InternedString) {\n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n \n     fn module_codegen<'tcx>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         cgu_name: InternedString,\n     ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);"}, {"sha": "9102ba91df816da8779d1037a717c0bf335b6762", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -66,7 +66,7 @@ impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.cx.tcx\n     }\n }"}, {"sha": "967fe877fd1ad1bc532a1416e5ef3d4f6220116b", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -35,7 +35,7 @@ use crate::abi::Abi;\n /// `llvm::Context` so that several compilation units may be optimized in parallel.\n /// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n pub struct CodegenCx<'ll, 'tcx: 'll> {\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n     pub tls_model: llvm::ThreadLocalMode,\n@@ -141,7 +141,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n }\n \n pub unsafe fn create_module(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     llcx: &'ll llvm::Context,\n     mod_name: &str,\n ) -> &'ll llvm::Module {\n@@ -208,7 +208,7 @@ pub unsafe fn create_module(\n \n impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     crate fn new(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         codegen_unit: Arc<CodegenUnit<'tcx>>,\n         llvm_module: &'ll crate::ModuleLlvm,\n     ) -> Self {\n@@ -839,7 +839,7 @@ impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "d43adc9cb92c5252035898ae7bd4cadd25b16a65", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -894,7 +894,7 @@ fn pointer_type_metadata(\n }\n \n pub fn compile_unit_metadata(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     codegen_unit_name: &str,\n     debug_context: &CrateDebugContext<'ll, '_>,\n ) -> &'ll DIDescriptor {"}, {"sha": "a0dd767a3a8ff7625c13616b7b375ff26a8b1e78", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -105,31 +105,27 @@ mod va_arg;\n pub struct LlvmCodegenBackend(());\n \n impl ExtraBackendMethods for LlvmCodegenBackend {\n-    fn new_metadata(&self, tcx: TyCtxt<'_, '_>, mod_name: &str) -> ModuleLlvm {\n+    fn new_metadata(&self, tcx: TyCtxt<'_>, mod_name: &str) -> ModuleLlvm {\n         ModuleLlvm::new_metadata(tcx, mod_name)\n     }\n \n-    fn write_compressed_metadata<'gcx>(\n+    fn write_compressed_metadata<'tcx>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'gcx>,\n+        tcx: TyCtxt<'tcx>,\n         metadata: &EncodedMetadata,\n         llvm_module: &mut ModuleLlvm,\n     ) {\n         base::write_compressed_metadata(tcx, metadata, llvm_module)\n     }\n-    fn codegen_allocator<'gcx>(\n+    fn codegen_allocator<'tcx>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'gcx>,\n+        tcx: TyCtxt<'tcx>,\n         mods: &mut ModuleLlvm,\n         kind: AllocatorKind,\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        cgu_name: InternedString,\n-    ) {\n+    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n         base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory(\n@@ -288,7 +284,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n     fn codegen_crate<'tcx>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>,\n@@ -367,7 +363,7 @@ unsafe impl Send for ModuleLlvm { }\n unsafe impl Sync for ModuleLlvm { }\n \n impl ModuleLlvm {\n-    fn new(tcx: TyCtxt<'_, '_>, mod_name: &str) -> Self {\n+    fn new(tcx: TyCtxt<'_>, mod_name: &str) -> Self {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;\n@@ -379,7 +375,7 @@ impl ModuleLlvm {\n         }\n     }\n \n-    fn new_metadata(tcx: TyCtxt<'_, '_>, mod_name: &str) -> Self {\n+    fn new_metadata(tcx: TyCtxt<'_>, mod_name: &str) -> Self {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;"}, {"sha": "c605c2e47c9433c8f3a5cd659160455cb494c9d2", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -25,7 +25,7 @@ pub struct LinkerInfo {\n }\n \n impl LinkerInfo {\n-    pub fn new(tcx: TyCtxt<'_, '_>) -> LinkerInfo {\n+    pub fn new(tcx: TyCtxt<'_>) -> LinkerInfo {\n         LinkerInfo {\n             exports: tcx.sess.crate_types.borrow().iter().map(|&c| {\n                 (c, exported_symbols(tcx, c))\n@@ -1012,7 +1012,7 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n }\n \n-fn exported_symbols(tcx: TyCtxt<'_, '_>, crate_type: CrateType) -> Vec<String> {\n+fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n     if let Some(ref exports) = tcx.sess.target.target.options.override_export_symbols {\n         return exports.clone()\n     }"}, {"sha": "aeff73c7e5216b064c6a1e789f477784319584bf", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,7 +21,7 @@ pub type ExportedSymbols = FxHashMap<\n     Arc<Vec<(String, SymbolExportLevel)>>,\n >;\n \n-pub fn threshold(tcx: TyCtxt<'_, '_>) -> SymbolExportLevel {\n+pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n@@ -47,7 +47,7 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n }\n \n fn reachable_non_generics_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     cnum: CrateNum,\n ) -> &'tcx DefIdMap<SymbolExportLevel> {\n     assert_eq!(cnum, LOCAL_CRATE);\n@@ -157,7 +157,7 @@ fn reachable_non_generics_provider<'tcx>(\n     tcx.arena.alloc(reachable_non_generics)\n }\n \n-fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     let export_threshold = threshold(tcx);\n \n     if let Some(&level) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n@@ -167,12 +167,12 @@ fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id\n     }\n }\n \n-fn is_reachable_non_generic_provider_extern<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_reachable_non_generic_provider_extern<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n }\n \n fn exported_symbols_provider_local<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     cnum: CrateNum,\n ) -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n     assert_eq!(cnum, LOCAL_CRATE);\n@@ -274,7 +274,7 @@ fn exported_symbols_provider_local<'tcx>(\n }\n \n fn upstream_monomorphizations_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     cnum: CrateNum,\n ) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n     debug_assert!(cnum == LOCAL_CRATE);\n@@ -323,14 +323,14 @@ fn upstream_monomorphizations_provider<'tcx>(\n }\n \n fn upstream_monomorphizations_for_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n     debug_assert!(!def_id.is_local());\n     tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }\n \n-fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_, '_>, def_id: DefId) -> bool {\n+fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&hir_id)\n     } else {\n@@ -352,7 +352,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n     providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n }\n \n-fn symbol_export_level(tcx: TyCtxt<'_, '_>, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "309187ca2eaa3e14244967044e31df5dbe1a9ff0", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -375,7 +375,7 @@ fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n \n pub fn start_async_codegen<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     metadata: EncodedMetadata,\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n     total_cgus: usize,\n@@ -996,7 +996,7 @@ enum MainThreadWorkerState {\n \n fn start_executing_work<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     crate_info: &CrateInfo,\n     shared_emitter: SharedEmitter,\n     codegen_worker_send: Sender<Message<B>>,\n@@ -1863,7 +1863,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n     pub fn submit_pre_codegened_module_to_llvm(\n         &self,\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         module: ModuleCodegen<B::Module>,\n     ) {\n         self.wait_for_signal_to_codegen_item();\n@@ -1874,7 +1874,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         submit_codegened_module_to_llvm(&self.backend, tcx, module, cost);\n     }\n \n-    pub fn codegen_finished(&self, tcx: TyCtxt<'_, '_>) {\n+    pub fn codegen_finished(&self, tcx: TyCtxt<'_>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n         drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n@@ -1913,7 +1913,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     module: ModuleCodegen<B::Module>,\n     cost: u64,\n ) {\n@@ -1926,7 +1926,7 @@ pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n \n pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     module: CachedModuleCodegen,\n ) {\n     let llvm_work_item = WorkItem::CopyPostLtoArtifacts(module);\n@@ -1938,7 +1938,7 @@ pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n \n pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     module: CachedModuleCodegen,\n ) {\n     let filename = pre_lto_bitcode_filename(&module.name);\n@@ -1963,7 +1963,7 @@ pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n     format!(\"{}.{}\", module_name, PRE_LTO_BC_EXT)\n }\n \n-fn msvc_imps_needed(tcx: TyCtxt<'_, '_>) -> bool {\n+fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     // This should never be true (because it's not supported). If it is true,\n     // something is wrong with commandline arg validation.\n     assert!(!(tcx.sess.opts.cg.linker_plugin_lto.enabled() &&"}, {"sha": "ca686453b6d4e7adf642828c111678a424dc8777", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -480,7 +480,7 @@ pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n \n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>,\n@@ -702,7 +702,7 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     }\n }\n \n-fn assert_and_save_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+fn assert_and_save_dep_graph<'tcx>(tcx: TyCtxt<'tcx>) {\n     time(tcx.sess,\n          \"assert dep graph\",\n          || ::rustc_incremental::assert_dep_graph(tcx));\n@@ -713,7 +713,7 @@ fn assert_and_save_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n impl CrateInfo {\n-    pub fn new(tcx: TyCtxt<'_, '_>) -> CrateInfo {\n+    pub fn new(tcx: TyCtxt<'_>) -> CrateInfo {\n         let mut info = CrateInfo {\n             panic_runtime: None,\n             compiler_builtins: None,\n@@ -779,7 +779,7 @@ impl CrateInfo {\n     }\n }\n \n-fn is_codegened_item(tcx: TyCtxt<'_, '_>, id: DefId) -> bool {\n+fn is_codegened_item(tcx: TyCtxt<'_>, id: DefId) -> bool {\n     let (all_mono_items, _) =\n         tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     all_mono_items.contains(&id)\n@@ -849,7 +849,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n+fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return CguReuse::No\n     }"}, {"sha": "e22d4db6dcb9adcda30b517e7662c6da79990c5d", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -122,7 +122,7 @@ mod temp_stable_hash_impls {\n     }\n }\n \n-pub fn langcall(tcx: TyCtxt<'_, '_>, span: Option<Span>, msg: &str, li: LangItem) -> DefId {\n+pub fn langcall(tcx: TyCtxt<'_>, span: Option<Span>, msg: &str, li: LangItem) -> DefId {\n     tcx.lang_items().require(li).unwrap_or_else(|s| {\n         let msg = format!(\"{} {}\", msg, s);\n         match span {"}, {"sha": "8f0bb6ee1983730f9eabdb4d1c2cb0452a0455d0", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::fx::FxHashSet;\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e., type parameters) are always fully qualified.\n pub fn compute_debuginfo_type_name<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     t: Ty<'tcx>,\n     qualified: bool,\n ) -> String {\n@@ -22,7 +22,7 @@ pub fn compute_debuginfo_type_name<'tcx>(\n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n pub fn push_debuginfo_type_name<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     t: Ty<'tcx>,\n     qualified: bool,\n     output: &mut String,\n@@ -210,12 +210,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n     }\n \n-    fn push_item_name(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        def_id: DefId,\n-        qualified: bool,\n-        output: &mut String,\n-    ) {\n+    fn push_item_name(tcx: TyCtxt<'tcx>, def_id: DefId, qualified: bool, output: &mut String) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {\n@@ -233,7 +228,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'tcx>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         output: &mut String,\n         visited: &mut FxHashSet<Ty<'tcx>>,"}, {"sha": "2f95c9a7d8bb43a4568b52a475cc55724ced75ee", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -31,20 +31,20 @@ impl<'tcx, T> Backend<'tcx> for T where\n }\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n-    fn new_metadata(&self, sess: TyCtxt<'_, '_>, mod_name: &str) -> Self::Module;\n-    fn write_compressed_metadata<'gcx>(\n+    fn new_metadata(&self, sess: TyCtxt<'_>, mod_name: &str) -> Self::Module;\n+    fn write_compressed_metadata<'tcx>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'gcx>,\n+        tcx: TyCtxt<'tcx>,\n         metadata: &EncodedMetadata,\n         llvm_module: &mut Self::Module,\n     );\n-    fn codegen_allocator<'gcx>(\n+    fn codegen_allocator<'tcx>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'gcx>,\n+        tcx: TyCtxt<'tcx>,\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n     );\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx, 'tcx>, cgu_name: InternedString);\n+    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "7a7a50a25faf09fe62f2a2cc72c40cb99850a08e", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -35,7 +35,7 @@ pub trait CodegenBackend {\n     fn provide_extern(&self, _providers: &mut Providers<'_>);\n     fn codegen_crate<'tcx>(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>,"}, {"sha": "942c2d13fac8752457defab49c26ca0127026277", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -36,7 +36,7 @@ pub mod symbol_names_test;\n /// error in codegen. This is used to write compile-fail tests\n /// that actually test that compilation succeeds without\n /// reporting an error.\n-pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_, '_>) {\n+pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n     if let Some((def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n         if tcx.has_attr(def_id, sym::rustc_error) {\n             tcx.sess.span_fatal(tcx.def_span(def_id), \"compilation successful\");"}, {"sha": "ba74f79eba3029667f2bcff68e42bac0216e7bc8", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -112,7 +112,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn symbol_name(tcx: TyCtxt<'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n "}, {"sha": "22b7e0a2fb0c929619b19a971a760802ac4538c4", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ use std::fmt::{self, Write};\n use std::mem::{self, discriminant};\n \n pub(super) fn mangle(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n ) -> String {\n@@ -69,7 +69,7 @@ pub(super) fn mangle(\n }\n \n fn get_symbol_hash<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     // instance this name will be for\n     instance: Instance<'tcx>,\n@@ -180,7 +180,7 @@ impl SymbolPath {\n }\n \n struct SymbolPrinter<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     path: SymbolPath,\n \n     // When `true`, `finalize_pending_component` isn't used.\n@@ -194,7 +194,7 @@ struct SymbolPrinter<'tcx> {\n // `PrettyPrinter` aka pretty printing of e.g. types in paths,\n // symbol names should have their own printing machinery.\n \n-impl Printer<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n+impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n@@ -203,7 +203,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -360,18 +360,16 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n     }\n }\n \n-impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n+impl PrettyPrinter<'tcx> for SymbolPrinter<'tcx> {\n     fn region_should_not_be_omitted(\n         &self,\n         _region: ty::Region<'_>,\n     ) -> bool {\n         false\n     }\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n     {\n         if let Some(first) = elems.next() {\n             self = first.print(self)?;"}, {"sha": "8a54fb6bbc4cae6cd6b1fe9b17a9e6ccd398354d", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -13,7 +13,7 @@ use std::fmt::Write;\n use std::ops::Range;\n \n pub(super) fn mangle(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n ) -> String {\n@@ -76,7 +76,7 @@ struct BinderLevel {\n }\n \n struct SymbolMangler<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     compress: Option<Box<CompressionCaches<'tcx>>>,\n     binders: Vec<BinderLevel>,\n     out: String,\n@@ -214,7 +214,7 @@ impl SymbolMangler<'tcx> {\n     }\n }\n \n-impl Printer<'tcx, 'tcx> for SymbolMangler<'tcx> {\n+impl Printer<'tcx> for SymbolMangler<'tcx> {\n     type Error = !;\n \n     type Path = Self;\n@@ -223,7 +223,7 @@ impl Printer<'tcx, 'tcx> for SymbolMangler<'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n "}, {"sha": "f48d1f2853c52598b10a18644355f4e575bf0650", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,7 +11,7 @@ use syntax::symbol::{Symbol, sym};\n const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n const DEF_PATH: Symbol = sym::rustc_def_path;\n \n-pub fn report_symbol_names<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn report_symbol_names<'tcx>(tcx: TyCtxt<'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n@@ -26,7 +26,7 @@ pub fn report_symbol_names<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n struct SymbolNamesTest<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl SymbolNamesTest<'tcx> {"}, {"sha": "e70c510b779c15103b253ca4cb31925245dfa0cc", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -157,7 +157,7 @@ impl PpSourceMode {\n     fn call_with_pp_support<'tcx, A, F>(\n         &self,\n         sess: &'tcx Session,\n-        tcx: Option<TyCtxt<'tcx, 'tcx>>,\n+        tcx: Option<TyCtxt<'tcx>>,\n         f: F,\n     ) -> A\n     where\n@@ -188,7 +188,7 @@ impl PpSourceMode {\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, F>(&self, tcx: TyCtxt<'tcx, 'tcx>, f: F) -> A\n+    fn call_with_pp_support_hir<'tcx, A, F>(&self, tcx: TyCtxt<'tcx>, f: F) -> A\n     where\n         F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n     {\n@@ -269,7 +269,7 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n \n struct NoAnn<'hir> {\n     sess: &'hir Session,\n-    tcx: Option<TyCtxt<'hir, 'hir>>,\n+    tcx: Option<TyCtxt<'hir>>,\n }\n \n impl<'hir> PrinterSupport for NoAnn<'hir> {\n@@ -310,7 +310,7 @@ impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n \n struct IdentifiedAnnotation<'hir> {\n     sess: &'hir Session,\n-    tcx: Option<TyCtxt<'hir, 'hir>>,\n+    tcx: Option<TyCtxt<'hir>>,\n }\n \n impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n@@ -454,7 +454,7 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n }\n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: Cell<&'a ty::TypeckTables<'tcx>>,\n }\n \n@@ -617,7 +617,7 @@ impl UserIdentifiedItem {\n \n fn print_flowgraph<'tcx, W: Write>(\n     variants: Vec<borrowck_dot::Variant>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     code: blocks::Code<'tcx>,\n     mode: PpFlowGraphMode,\n     mut out: W,\n@@ -754,7 +754,7 @@ pub fn print_after_parsing(sess: &Session,\n }\n \n pub fn print_after_hir_lowering<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     input: &Input,\n     krate: &ast::Crate,\n     ppm: PpMode,\n@@ -866,7 +866,7 @@ pub fn print_after_hir_lowering<'tcx>(\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ppm: PpMode,\n     uii: Option<UserIdentifiedItem>,\n     ofile: Option<&Path>,"}, {"sha": "a43347a2197c3735d055bd260dca268aeddbe259", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -51,7 +51,7 @@ use std::io::Write;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub fn assert_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn assert_dep_graph<'tcx>(tcx: TyCtxt<'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n             dump_graph(tcx);\n@@ -90,7 +90,7 @@ type Sources = Vec<(Span, DefId, DepNode)>;\n type Targets = Vec<(Span, ast::Name, hir::HirId, DepNode)>;\n \n struct IfThisChanged<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     if_this_changed: Sources,\n     then_this_would_need: Targets,\n }\n@@ -184,11 +184,7 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n }\n \n-fn check_paths<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    if_this_changed: &Sources,\n-    then_this_would_need: &Targets,\n-) {\n+fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_would_need: &Targets) {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n         for &(target_span, _, _, _) in then_this_would_need {\n@@ -218,7 +214,7 @@ fn check_paths<'tcx>(\n     }\n }\n \n-fn dump_graph(tcx: TyCtxt<'_, '_>) {\n+fn dump_graph(tcx: TyCtxt<'_>) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| \"dep_graph\".to_string());\n     let query = tcx.dep_graph.query();\n "}, {"sha": "f502d0475460e04803c65112dffe40c50b93b05c", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -35,7 +35,7 @@ const MODULE: Symbol = sym::module;\n const CFG: Symbol = sym::cfg;\n const KIND: Symbol = sym::kind;\n \n-pub fn assert_module_sources<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn assert_module_sources<'tcx>(tcx: TyCtxt<'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n             return;\n@@ -60,7 +60,7 @@ pub fn assert_module_sources<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n struct AssertModuleSource<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     available_cgus: BTreeSet<String>,\n }\n "}, {"sha": "e2e4a4ebcb0567566fa1e5bf297fce06ce4bf6e2", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -206,7 +206,7 @@ impl Assertion {\n     }\n }\n \n-pub fn check_dirty_clean_annotations<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn check_dirty_clean_annotations<'tcx>(tcx: TyCtxt<'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.features().rustc_attrs {\n         return;\n@@ -235,7 +235,7 @@ pub fn check_dirty_clean_annotations<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n pub struct DirtyCleanVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n@@ -537,7 +537,7 @@ impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n ///\n /// Also make sure that the `label` and `except` fields do not\n /// both exist.\n-fn check_config(tcx: TyCtxt<'_, '_>, attr: &Attribute) -> bool {\n+fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n@@ -572,7 +572,7 @@ fn check_config(tcx: TyCtxt<'_, '_>, attr: &Attribute) -> bool {\n     }\n }\n \n-fn expect_associated_value(tcx: TyCtxt<'_, '_>, item: &NestedMetaItem) -> ast::Name {\n+fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n         value\n     } else {\n@@ -590,7 +590,7 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_>, item: &NestedMetaItem) -> ast::N\n // the HIR. It is used to verfiy that we really ran checks for all annotated\n // nodes.\n pub struct FindAllAttrs<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     attr_names: Vec<Symbol>,\n     found_attrs: Vec<&'tcx Attribute>,\n }"}, {"sha": "d9bcc0b2a83c7c1530a091ce7657dbff2fa16b55", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,7 +15,7 @@ use super::fs::*;\n use super::file_format;\n use super::work_product;\n \n-pub fn dep_graph_tcx_init<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn dep_graph_tcx_init<'tcx>(tcx: TyCtxt<'tcx>) {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return\n     }"}, {"sha": "49c79ec09f5e2c29b6a7a716572f1e6d28f84ff0", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,7 +15,7 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n-pub fn save_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn save_dep_graph<'tcx>(tcx: TyCtxt<'tcx>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n         let sess = tcx.sess;\n@@ -129,7 +129,7 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_, '_>, encoder: &mut Encoder) {\n+fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     // First encode the commandline arguments hash\n     tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n \n@@ -233,7 +233,7 @@ fn encode_work_product_index(work_products: &FxHashMap<WorkProductId, WorkProduc\n     serialized_products.encode(encoder).unwrap();\n }\n \n-fn encode_query_cache(tcx: TyCtxt<'_, '_>, encoder: &mut Encoder) {\n+fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     time(tcx.sess, \"serialize query result cache\", || {\n         tcx.serialize_query_result_cache(encoder).unwrap();\n     })"}, {"sha": "69cb696f4c580a3cb667dda3dd051591a840d3a5", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -791,14 +791,14 @@ pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n \n declare_box_region_type!(\n     pub BoxedGlobalCtxt,\n-    for('gcx),\n-    (&'gcx GlobalCtxt<'gcx>) -> ((), ())\n+    for('tcx),\n+    (&'tcx GlobalCtxt<'tcx>) -> ((), ())\n );\n \n impl BoxedGlobalCtxt {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx, 'tcx>) -> R,\n+        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n     {\n         self.access(|gcx| ty::tls::enter_global(gcx, |tcx| f(tcx)))\n     }\n@@ -811,7 +811,7 @@ pub fn create_global_ctxt(\n     resolutions: Resolutions,\n     outputs: OutputFilenames,\n     tx: mpsc::Sender<Box<dyn Any + Send>>,\n-    crate_name: &str\n+    crate_name: &str,\n ) -> BoxedGlobalCtxt {\n     let sess = compiler.session().clone();\n     let cstore = compiler.cstore.clone();\n@@ -866,7 +866,7 @@ pub fn create_global_ctxt(\n         });\n \n         yield BoxedGlobalCtxt::initial_yield(());\n-        box_region_allow_access!(for('gcx), (&'gcx GlobalCtxt<'gcx>), (gcx));\n+        box_region_allow_access!(for('tcx), (&'tcx GlobalCtxt<'tcx>), (gcx));\n \n         if sess.opts.debugging_opts.query_stats {\n             gcx.queries.print_stats();\n@@ -878,7 +878,7 @@ pub fn create_global_ctxt(\n \n /// Runs the resolution, type-checking, region checking and other\n /// miscellaneous analysis passes on the crate.\n-fn analysis<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Result<()> {\n+fn analysis<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Result<()> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let sess = tcx.sess;\n@@ -996,7 +996,7 @@ fn analysis<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Result<()> {\n }\n \n fn encode_and_write_metadata<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     outputs: &OutputFilenames,\n ) -> (middle::cstore::EncodedMetadata, bool) {\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -1059,7 +1059,7 @@ fn encode_and_write_metadata<'tcx>(\n /// be discarded.\n pub fn start_codegen<'tcx>(\n     codegen_backend: &dyn CodegenBackend,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     outputs: &OutputFilenames,\n ) -> Box<dyn Any> {"}, {"sha": "9e1ef6b022d9b9d46e686c3efce4878f3b09c4c5", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,11 +6,11 @@ use rustc::ty::query::Providers;\n use syntax::attr;\n use syntax::symbol::sym;\n \n-pub fn find<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DefId> {\n+pub fn find<'tcx>(tcx: TyCtxt<'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n }\n \n-fn proc_macro_decls_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Option<DefId> {\n+fn proc_macro_decls_static<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = Finder { decls: None };"}, {"sha": "ec8a9c6fbb2a8639dc7539f6e469eccb3a0830af", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -75,7 +75,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn lint_mod<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn lint_mod<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n "}, {"sha": "a843ee6d45d8feb0762e014daa628d50a935b987", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -519,11 +519,11 @@ enum FfiResult<'tcx> {\n     },\n }\n \n-fn is_zst<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n+fn is_zst<'tcx>(tcx: TyCtxt<'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n     tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n }\n \n-fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n@@ -556,7 +556,7 @@ fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n /// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n /// FIXME: This duplicates code in codegen.\n fn is_repr_nullable_ptr<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     ty_def: &'tcx ty::AdtDef,\n     substs: SubstsRef<'tcx>,"}, {"sha": "0474d2a2e3b3a788f320b2e706c09315ce422b2d", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -327,7 +327,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    #tcx: TyCtxt<'tcx, 'tcx>,\n+                    #tcx: TyCtxt<'tcx>,\n                     #id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     #block\n@@ -338,7 +338,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    tcx: TyCtxt<'tcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx>,\n                     id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n@@ -350,7 +350,7 @@ fn add_query_description_impl(\n         quote! {\n             #[inline]\n             #[allow(unused_variables)]\n-            fn cache_on_disk(#tcx: TyCtxt<'tcx, 'tcx>, #key: Self::Key) -> bool {\n+            fn cache_on_disk(#tcx: TyCtxt<'tcx>, #key: Self::Key) -> bool {\n                 #expr\n             }\n \n@@ -367,7 +367,7 @@ fn add_query_description_impl(\n         quote! {\n             #[allow(unused_variables)]\n             fn describe(\n-                #tcx: TyCtxt<'_, '_>,\n+                #tcx: TyCtxt<'_>,\n                 #key: #arg,\n             ) -> Cow<'static, str> {\n                 format!(#desc).into()"}, {"sha": "86536b179f222c19b4cf86ae4895b17479911fd0", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -40,11 +40,12 @@ macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n       $($name:ident => $compute:block)*) => {\n         pub fn provide_extern<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $name<$lt:$lt, T>($tcx: TyCtxt<$lt, $lt>, def_id_arg: T)\n-                                    -> <ty::queries::$name<$lt> as\n-                                        QueryConfig<$lt>>::Value\n-                where T: IntoArgs,\n-            {\n+            // HACK(eddyb) `$lt: $lt` forces `$lt` to be early-bound, which\n+            // allows the associated type in the return type to be normalized.\n+            $(fn $name<$lt: $lt, T: IntoArgs>(\n+                $tcx: TyCtxt<$lt>,\n+                def_id_arg: T,\n+            ) -> <ty::queries::$name<$lt> as QueryConfig<$lt>>::Value {\n                 #[allow(unused_variables)]\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n@@ -550,7 +551,7 @@ impl CrateStore for cstore::CStore {\n         self.do_postorder_cnums_untracked()\n     }\n \n-    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n+    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }\n "}, {"sha": "4bafe16b8e66d4130e38c3288db97b9763950c87", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -39,7 +39,7 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'a Session>,\n-    tcx: Option<TyCtxt<'tcx, 'tcx>>,\n+    tcx: Option<TyCtxt<'tcx>>,\n \n     // Cache the last used source_file for translating spans as an optimization.\n     last_source_file_index: usize,\n@@ -55,7 +55,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'a Session> { None }\n-    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx>> {\n+    fn tcx(self) -> Option<TyCtxt<'tcx>> {\n         None\n         }\n \n@@ -116,14 +116,14 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'a Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx, 'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n     fn cdata(self) -> Option<&'a CrateMetadata> {\n         Some(self.0)\n     }\n-    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx>> {\n+    fn tcx(self) -> Option<TyCtxt<'tcx>> {\n         Some(self.1)\n     }\n }\n@@ -148,7 +148,7 @@ impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n@@ -173,7 +173,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n@@ -548,7 +548,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn get_variant(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         item: &Entry<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> &'tcx ty::AdtDef {\n+    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -617,23 +617,23 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_predicates(\n         &self,\n         item_id: DefIndex,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n-    }\n+}\n \n     pub fn get_predicates_defined_on(\n         &self,\n         item_id: DefIndex,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n     }\n \n     pub fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         let super_predicates = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n-    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n \n@@ -701,19 +701,12 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(\n-        &self,\n-        id: DefIndex,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-    ) -> Option<ty::TraitRef<'tcx>> {\n+    pub fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    pub fn get_lib_features(\n-        &self,\n-        tcx: TyCtxt<'tcx, '_>,\n-    ) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    pub fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -722,7 +715,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [(DefId, usize)] {\n+    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -883,11 +876,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_optimized_mir(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        id: DefIndex,\n-    ) -> Option<Body<'tcx>> {\n+    pub fn maybe_get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Option<Body<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n@@ -1019,7 +1008,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_inherent_implementations_for_type(\n         &self,\n-        tcx: TyCtxt<'tcx, '_>,\n+        tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> &'tcx [DefId] {\n         tcx.arena.alloc_from_iter(self.entry(id)\n@@ -1030,7 +1019,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_implementations_for_trait(\n         &self,\n-        tcx: TyCtxt<'tcx, '_>,\n+        tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n         if self.proc_macros.is_some() {\n@@ -1085,7 +1074,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [ForeignModule] {\n+    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1096,7 +1085,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_dylib_dependency_formats(\n         &self,\n-        tcx: TyCtxt<'tcx, '_>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n         tcx.arena.alloc_from_iter(self.root\n             .dylib_dependency_formats\n@@ -1108,7 +1097,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [lang_items::LangItem] {\n+    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1131,7 +1120,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn exported_symbols(\n         &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n         if self.proc_macros.is_some() {\n             // If this crate is a custom derive crate, then we're not even going to\n@@ -1187,7 +1176,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let sig = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,"}, {"sha": "dbf140afda24da66333c8838ef1218004a7e03d9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -42,7 +42,7 @@ use rustc::hir::intravisit;\n \n pub struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n \n     entries_index: Index<'tcx>,\n \n@@ -1816,7 +1816,7 @@ impl EncodeContext<'tcx> {\n }\n \n struct ImplVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n@@ -1863,7 +1863,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n+pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n@@ -1905,7 +1905,7 @@ pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n     EncodedMetadata { raw_data: result }\n }\n \n-pub fn get_repr_options<'tcx, 'gcx>(tcx: TyCtxt<'tcx, 'gcx>, did: DefId) -> ReprOptions {\n+pub fn get_repr_options<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.sty {\n         ty::Adt(ref def, _) => return def.repr,"}, {"sha": "0ce103cfa40dc63b506c4ec4deb70265f0a8d26d", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<ForeignModule> {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),\n@@ -13,7 +13,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<ForeignModule> {\n }\n \n struct Collector<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     modules: Vec<ForeignModule>,\n }\n "}, {"sha": "cd6270046faabe18094a583e097ff76cdb1d03b2", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<String> {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };"}, {"sha": "7b335b3b4832d65566b0218b887f31870b356e1a", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<NativeLibrary> {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),\n@@ -29,7 +29,7 @@ pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n }\n \n struct Collector<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     libs: Vec<NativeLibrary>,\n }\n "}, {"sha": "f6f2cfbfc0886ae53869f712918db74ebd166a14", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -122,7 +122,7 @@ impl LocalsStateAtExit {\n \n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>,\n@@ -160,8 +160,8 @@ impl<'tcx> BorrowSet<'tcx> {\n     }\n }\n \n-struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct GatherBorrows<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n@@ -181,7 +181,7 @@ struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     locals_state_at_exit: LocalsStateAtExit,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n     fn visit_assign(\n         &mut self,\n         assigned_place: &mir::Place<'tcx>,\n@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n \n     /// If this is a two-phase borrow, then we will record it\n     /// as \"pending\" until we find the activating use."}, {"sha": "6a70a23729c2688b2b1201e2a10c58d4a54964ce", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -43,7 +43,7 @@ enum StorageDeadOrDrop<'tcx> {\n     Destructor(Ty<'tcx>),\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n         location: Location,\n@@ -1903,7 +1903,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// helps explain.\n     pub(super) fn emit(\n         &self,\n-        cx: &mut MirBorrowckCtxt<'_, '_, 'tcx>,\n+        cx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> String {\n         match self {"}, {"sha": "7eb296353a4949b71e43f4d3ed5bfc6db25cfcf0", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -18,7 +18,7 @@ use super::{MirBorrowckCtxt};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Adds a suggestion when a closure is invoked twice with a moved variable or when a closure\n     /// is moved after being invoked.\n     ///\n@@ -403,7 +403,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n     /// name where required.\n     pub(super) fn get_name_for_ty(&self, ty: Ty<'tcx>, counter: usize) -> String {\n@@ -547,7 +547,7 @@ impl UseSpans {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n         &self,"}, {"sha": "5a57db2a6724e857f9158703fc9572e2d3015735", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,20 +22,20 @@ use std::fmt;\n use std::rc::Rc;\n \n // (forced to be `pub` due to its use as an associated type below.)\n-crate struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    borrows: FlowAtLocation<'tcx, Borrows<'b, 'gcx, 'tcx>>,\n-    pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-    pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n+crate struct Flows<'b, 'tcx: 'b> {\n+    borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n+    pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n+    pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n \n     /// Polonius Output\n     pub polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n }\n \n-impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n+impl<'b, 'tcx> Flows<'b, 'tcx> {\n     crate fn new(\n-        borrows: FlowAtLocation<'tcx, Borrows<'b, 'gcx, 'tcx>>,\n-        uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n+        borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n+        uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n+        ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n         polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     ) -> Self {\n         Flows {\n@@ -70,7 +70,7 @@ macro_rules! each_flow {\n     };\n }\n \n-impl<'b, 'gcx, 'tcx> FlowsAtLocation for Flows<'b, 'gcx, 'tcx> {\n+impl<'b, 'tcx> FlowsAtLocation for Flows<'b, 'tcx> {\n     fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n         each_flow!(self, reset_to_entry_of(bb));\n     }\n@@ -92,7 +92,7 @@ impl<'b, 'gcx, 'tcx> FlowsAtLocation for Flows<'b, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n+impl<'b, 'tcx> fmt::Display for Flows<'b, 'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut s = String::new();\n "}, {"sha": "161a08c5773e7b2ae11be8db44ff943381f6f6a0", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -87,7 +87,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n+fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_body = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n@@ -100,11 +100,11 @@ fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResu\n     opt_closure_req\n }\n \n-fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    input_body: &Body<'gcx>,\n+fn do_mir_borrowck<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    input_body: &Body<'tcx>,\n     def_id: DefId,\n-) -> BorrowCheckResult<'gcx> {\n+) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n \n     let tcx = infcx.tcx;\n@@ -423,8 +423,8 @@ fn downgrade_if_error(diag: &mut Diagnostic) {\n     }\n }\n \n-pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+pub struct MirBorrowckCtxt<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n@@ -508,8 +508,8 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    type FlowState = Flows<'cx, 'gcx, 'tcx>;\n+impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n+    type FlowState = Flows<'cx, 'tcx>;\n \n     fn body(&self) -> &'cx Body<'tcx> {\n         self.body\n@@ -920,7 +920,7 @@ impl InitializationRequiringAction {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -933,7 +933,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: (AccessDepth, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let (sd, rw) = kind;\n \n@@ -996,7 +996,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) -> bool {\n         debug!(\n             \"check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n@@ -1148,7 +1148,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n@@ -1195,7 +1195,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         location: Location,\n         (rvalue, span): (&Rvalue<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n@@ -1382,7 +1382,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         location: Location,\n         (operand, span): (&Operand<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *operand {\n             Operand::Copy(ref place) => {\n@@ -1511,12 +1511,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_activations(\n-        &mut self,\n-        location: Location,\n-        span: Span,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n-    ) {\n+    fn check_activations(&mut self, location: Location, span: Span, flow_state: &Flows<'cx, 'tcx>) {\n         // Two-phase borrow support: For each activation that is newly\n         // generated at this statement, check if it interferes with\n         // another borrow.\n@@ -1547,13 +1542,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(\n         &mut self,\n         location: Location,\n         local: Local,\n         place_span: (&Place<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", local);\n \n@@ -1573,7 +1568,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n \n@@ -1641,7 +1636,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n \n@@ -1728,7 +1723,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         location: Location,\n         (place, span): (&Place<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n         // recur down place; dispatch to external checks when necessary\n@@ -1811,12 +1806,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        fn check_parent_of_field<'cx, 'gcx, 'tcx>(\n-            this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+        fn check_parent_of_field<'cx, 'tcx>(\n+            this: &mut MirBorrowckCtxt<'cx, 'tcx>,\n             location: Location,\n             base: &Place<'tcx>,\n             span: Span,\n-            flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+            flow_state: &Flows<'cx, 'tcx>,\n         ) {\n             // rust-lang/rust#21232: Until Rust allows reads from the\n             // initialized parts of partially initialized structs, we\n@@ -1905,7 +1900,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'tcx>,\n         location: Location,\n     ) -> bool {\n         debug!(\n@@ -2034,11 +2029,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         };\n     }\n \n-    fn is_local_ever_initialized(&self,\n-                                 local: Local,\n-                                 flow_state: &Flows<'cx, 'gcx, 'tcx>)\n-                                 -> Option<InitIndex>\n-    {\n+    fn is_local_ever_initialized(\n+        &self,\n+        local: Local,\n+        flow_state: &Flows<'cx, 'tcx>,\n+    ) -> Option<InitIndex> {\n         let mpi = self.move_data.rev_lookup.find_local(local);\n         let ii = &self.move_data.init_path_map[mpi];\n         for &index in ii {\n@@ -2050,11 +2045,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Adds the place into the used mutable variables set\n-    fn add_used_mut<'d>(\n-        &mut self,\n-        root_place: RootPlace<'d, 'tcx>,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n-    ) {\n+    fn add_used_mut<'d>(&mut self, root_place: RootPlace<'d, 'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n         match root_place {\n             RootPlace {\n                 place: Place::Base(PlaceBase::Local(local)),"}, {"sha": "402654c44ac157bad4814be0dda4b1979bc7d75e", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -96,7 +96,7 @@ impl BorrowedContentSource<'tcx> {\n         }\n     }\n \n-    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'_, 'tcx>) -> Option<Self> {\n+    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n         match func.sty {\n             ty::FnDef(def_id, substs) => {\n                 let trait_id = tcx.trait_of_item(def_id)?;\n@@ -119,7 +119,7 @@ impl BorrowedContentSource<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(crate) fn report_move_errors(&mut self, move_errors: Vec<(Place<'tcx>, MoveError<'tcx>)>) {\n         let grouped_errors = self.group_move_errors(move_errors);\n         for error in grouped_errors {"}, {"sha": "d3c23cfd65a66f125420d2f48e066b70b2ade697", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -24,7 +24,7 @@ pub(super) enum AccessKind {\n     Move,\n }\n \n-impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(super) fn report_mutability_error(\n         &mut self,\n         access_place: &Place<'tcx>,\n@@ -522,8 +522,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn suggest_ampmut_self<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn suggest_ampmut_self<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     local_decl: &mir::LocalDecl<'tcx>,\n ) -> (Span, String) {\n     let sp = local_decl.source_info.span;\n@@ -555,8 +555,8 @@ fn suggest_ampmut_self<'gcx, 'tcx>(\n //\n // This implementation attempts to emulate AST-borrowck prioritization\n // by trying (3.), then (2.) and finally falling back on (1.).\n-fn suggest_ampmut<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn suggest_ampmut<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n@@ -623,7 +623,7 @@ fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n ///    |        ---------- use `&'a mut String` here to make mutable\n /// ```\n fn annotate_struct_field(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     field: &mir::Field,\n ) -> Option<(Span, String)> {"}, {"sha": "18c542de27268428332274bd665e4edd5a5be03e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -13,8 +13,8 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty};\n use rustc::ty::subst::SubstsRef;\n \n-pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+pub(super) fn generate_constraints<'cx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'tcx>,\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n@@ -35,15 +35,15 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n-struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+struct ConstraintGeneration<'cg, 'cx: 'cg, 'tcx: 'cx> {\n+    infcx: &'cg InferCtxt<'cx, 'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n-impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n+impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.super_basic_block_data(bb, data);\n     }\n@@ -177,7 +177,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     }\n }\n \n-impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n+impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at"}, {"sha": "4d7ab90a4b3ef374c7f40413e298de97b5616321", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashSet;\n crate fn find<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n ) -> Option<Cause> {\n@@ -27,15 +27,15 @@ crate fn find<'tcx>(\n     uf.find()\n }\n \n-struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+struct UseFinder<'cx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n     regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n }\n \n-impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> UseFinder<'cx, 'tcx> {\n     fn find(&mut self) -> Option<Cause> {\n         let mut queue = VecDeque::new();\n         let mut visited = FxHashSet::default();\n@@ -99,9 +99,9 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+struct DefUseVisitor<'cx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     region_vid: RegionVid,\n     def_use_result: Option<DefUseResult>,\n }\n@@ -112,7 +112,7 @@ enum DefUseResult {\n     UseDrop { local: Local },\n }\n \n-impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'tcx> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n         let local_ty = self.body.local_decls[local].ty;\n "}, {"sha": "4bc2f7064bef4464ea24eb8fcff166997f3b81ad", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -51,9 +51,9 @@ impl BorrowExplanation {\n             _ => true,\n         }\n     }\n-    pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'gcx, 'tcx>(\n+    pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'tcx>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,\n@@ -207,7 +207,7 @@ impl BorrowExplanation {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns structured explanation for *why* the borrow contains the\n     /// point from `location`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d]."}, {"sha": "d84afeac1852352e71500112c7e849c00322d300", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,7 +15,7 @@ crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex>;\n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n     /// current `-Z` flags.\n-    fn enabled(tcx: TyCtxt<'_, '_>) -> bool;\n+    fn enabled(tcx: TyCtxt<'_>) -> bool;\n \n     fn write_to_dir(\n         &self,\n@@ -26,7 +26,7 @@ crate trait AllFactsExt {\n \n impl AllFactsExt for AllFacts {\n     /// Return\n-    fn enabled(tcx: TyCtxt<'_, '_>) -> bool {\n+    fn enabled(tcx: TyCtxt<'_>) -> bool {\n         tcx.sess.opts.debugging_opts.nll_facts\n             || tcx.sess.opts.debugging_opts.polonius\n     }"}, {"sha": "8ce9cf60eeb956280d2bb274ee7aadcc187f3dae", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -17,8 +17,8 @@ use rustc::mir::TerminatorKind;\n use rustc::mir::{Operand, BorrowKind};\n use rustc_data_structures::graph::dominators::Dominators;\n \n-pub(super) fn generate_invalidates<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(super) fn generate_invalidates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     body: &Body<'tcx>,\n@@ -43,8 +43,8 @@ pub(super) fn generate_invalidates<'gcx, 'tcx>(\n     }\n }\n \n-struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+struct InvalidationGenerator<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,\n@@ -54,7 +54,7 @@ struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n \n /// Visits the whole MIR and generates `invalidates()` facts.\n /// Most of the code implementing this was stolen from `borrow_check/mod.rs`.\n-impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n+impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n     fn visit_statement(\n         &mut self,\n         statement: &Statement<'tcx>,\n@@ -258,7 +258,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n+impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     /// Simulates mutation of a place.\n     fn mutate_place(\n         &mut self,"}, {"sha": "5dd7b7452733cf654692c199548448baff2935bc", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -46,8 +46,8 @@ use self::universal_regions::UniversalRegions;\n /// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n /// `compute_regions`.\n-pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n@@ -69,22 +69,22 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n /// Computes the (non-lexical) regions from the input MIR.\n ///\n /// This may result in errors being reported.\n-pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n-    param_env: ty::ParamEnv<'gcx>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n     Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n-    Option<ClosureRegionRequirements<'gcx>>,\n+    Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     let mut all_facts = if AllFacts::enabled(infcx.tcx) {\n         Some(AllFacts::default())\n@@ -210,8 +210,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     (regioncx, polonius_output, closure_region_requirements)\n }\n \n-fn dump_mir_results<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+fn dump_mir_results<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'_>,\n@@ -271,8 +271,8 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     };\n }\n \n-fn dump_annotation<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+fn dump_annotation<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n     body: &Body<'tcx>,\n     mir_def_id: DefId,\n     regioncx: &RegionInferenceContext<'tcx>,"}, {"sha": "04ff54e9a5e452871e5e8e79d969635645a7b847", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -239,7 +239,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n@@ -359,7 +359,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         _fr: RegionVid,\n         outlived_fr: RegionVid,\n@@ -424,7 +424,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n@@ -516,7 +516,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         fr_is_local: bool,\n@@ -585,7 +585,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn add_static_impl_trait_suggestion(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         diag: &mut DiagnosticBuilder<'_>,\n         fr: RegionVid,\n         // We need to pass `fr_name` - computing it again will label it twice.\n@@ -671,7 +671,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n@@ -752,7 +752,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, '_, 'tcx>, fr: RegionVid) -> bool {\n+    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, 'tcx>, fr: RegionVid) -> bool {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {"}, {"sha": "1ec30897e92dac80044c48ecdde438db25c13f01", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -151,7 +151,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and then return the name `'1` for us to use.\n     crate fn give_region_a_name(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n@@ -194,7 +194,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// named variants.\n     fn give_name_from_error_region(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -303,7 +303,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn get_named_span(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         error_region: &RegionKind,\n         name: InternedString,\n     ) -> Span {\n@@ -331,7 +331,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -359,7 +359,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         needle_fr: RegionVid,\n@@ -405,7 +405,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n@@ -461,7 +461,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to highlighting that closest type instead.\n     fn give_name_if_we_can_match_hir_ty(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n@@ -653,7 +653,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -675,7 +675,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// or be early bound (named, not in argument).\n     fn give_name_if_anonymous_region_appears_in_output(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -735,7 +735,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,"}, {"sha": "6ce925cc7d12a342e37af2cc8d723121b9e44a99", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::symbol::Symbol;\n impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_var_name_and_span_for_region(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n@@ -33,11 +33,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Search the upvars (if any) to find one that references fr. Return its index.\n-    crate fn get_upvar_index_for_region(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-    ) -> Option<usize> {\n+    crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n         let upvar_index = self\n             .universal_regions\n             .defining_ty\n@@ -69,7 +65,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// declared.\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n@@ -91,7 +87,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// user - in particular, index 0 is not the implicit self parameter.\n     crate fn get_argument_index_for_region(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n@@ -134,5 +130,4 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         (argument_name, argument_span)\n     }\n-\n }"}, {"sha": "2b38fcee4796006d78b97df371bda0dc8b60a0ef", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -370,7 +370,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n@@ -397,14 +397,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Performs region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n-    pub(super) fn solve<'gcx>(\n+    pub(super) fn solve(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n-    ) -> Option<ClosureRegionRequirements<'gcx>> {\n+    ) -> Option<ClosureRegionRequirements<'tcx>> {\n         common::time_ext(\n             infcx.tcx.sess.time_extended(),\n             Some(infcx.tcx.sess),\n@@ -413,14 +413,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         )\n     }\n \n-    fn solve_inner<'gcx>(\n+    fn solve_inner(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n-    ) -> Option<ClosureRegionRequirements<'gcx>> {\n+    ) -> Option<ClosureRegionRequirements<'tcx>> {\n         self.propagate_constraints(body);\n \n         // If this is a closure, we can propagate unsatisfied\n@@ -578,12 +578,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:\n     /// 'a`. See `TypeTest` for more details.\n-    fn check_type_tests<'gcx>(\n+    fn check_type_tests(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n-        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         let tcx = infcx.tcx;\n@@ -722,12 +722,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// The idea then is to lower the `T: 'X` constraint into multiple\n     /// bounds -- e.g., if `'X` is the union of two free lifetimes,\n     /// `'1` and `'2`, then we would create `T: '1` and `T: '2`.\n-    fn try_promote_type_test<'gcx>(\n+    fn try_promote_type_test(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n-        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n+        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'tcx>>,\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n@@ -794,7 +794,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// When we promote a type test `T: 'r`, we have to convert the\n     /// type `T` into something we can store in a query result (so\n-    /// something allocated for `'gcx`). This is problematic if `ty`\n+    /// something allocated for `'tcx`). This is problematic if `ty`\n     /// contains regions. During the course of NLL region checking, we\n     /// will have replaced all of those regions with fresh inference\n     /// variables. To create a test subject, we want to replace those\n@@ -803,11 +803,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// fallible process. Presuming we do find a suitable region, we\n     /// will represent it with a `ReClosureBound`, which is a\n     /// `RegionKind` variant that can be allocated in the gcx.\n-    fn try_promote_type_test_subject<'gcx>(\n+    fn try_promote_type_test_subject(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> Option<ClosureOutlivesSubject<'gcx>> {\n+    ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n         let gcx = tcx.global_tcx();\n \n@@ -943,7 +943,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -976,7 +976,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn eval_if_eq(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1022,7 +1022,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// higher-ranked things and so forth, and right now the inference\n     /// context is not permitted to make more inference variables. So\n     /// we use this kind of hacky solution.\n-    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, 'tcx>, value: T) -> T\n+    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -1102,13 +1102,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// If `propagated_outlives_requirements` is `Some`, then we will\n     /// push unsatisfied obligations into there. Otherwise, we'll\n     /// report them as errors.\n-    fn check_universal_regions<'gcx>(\n+    fn check_universal_regions(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n-        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n@@ -1147,14 +1147,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Things that are to be propagated are accumulated into the\n     /// `outlives_requirements` vector.\n-    fn check_universal_region<'gcx>(\n+    fn check_universal_region(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n-        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n@@ -1215,11 +1215,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n-        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n@@ -1280,9 +1280,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         Some(ErrorReported)\n     }\n \n-    fn check_bound_universal_region<'gcx>(\n+    fn check_bound_universal_region(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         _mir_def_id: DefId,\n         longer_fr: RegionVid,\n@@ -1365,25 +1365,25 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n+pub trait ClosureRegionRequirementsExt<'tcx> {\n     fn apply_requirements(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>;\n }\n \n-impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequirements<'gcx> {\n+impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx> {\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n@@ -1398,7 +1398,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// requirements.\n     fn apply_requirements(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>> {\n@@ -1453,7 +1453,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T"}, {"sha": "c1d1185cf177ad7fa4461cad12d263ffdcf30b08", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,7 +6,7 @@ use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, 'tcx>, body: &mut Body<'tcx>) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n \n@@ -16,10 +16,7 @@ pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, body: &mut Body<'tcx>\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n-pub fn renumber_regions<'tcx, T>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n-    value: &T,\n-) -> T\n+pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: &T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -33,11 +30,11 @@ where\n         })\n }\n \n-struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct NLLVisitor<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n     fn renumber_regions<T>(&mut self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -46,7 +43,7 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n     fn visit_body(&mut self, body: &mut Body<'tcx>) {\n         for promoted in body.promoted.iter_mut() {\n             self.visit_body(promoted);"}, {"sha": "d86702773e3f5adf141ac1a96bb620780047f5df", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -13,9 +13,9 @@ use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n-crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+crate struct ConstraintConversion<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -25,9 +25,9 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     crate fn new(\n-        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -150,9 +150,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx>\n-    for &'a mut ConstraintConversion<'b, 'gcx, 'tcx>\n-{\n+impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'b, 'tcx> {\n     fn push_sub_region_constraint(\n         &mut self,\n         _origin: SubregionOrigin<'tcx>,"}, {"sha": "ca42f249dc19b471cae0111d274045bc4fcdd0b5", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -55,7 +55,7 @@ crate struct CreateResult<'tcx> {\n }\n \n crate fn create(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n@@ -219,8 +219,8 @@ impl UniversalRegionRelations<'tcx> {\n     }\n }\n \n-struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n-    infcx: &'this InferCtxt<'this, 'gcx, 'tcx>,\n+struct UniversalRegionRelationsBuilder<'this, 'tcx: 'this> {\n+    infcx: &'this InferCtxt<'this, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -231,7 +231,7 @@ struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n     region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n-impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n+impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n     crate fn create(mut self) -> CreateResult<'tcx> {\n         let unnormalized_input_output_tys = self\n             .universal_regions"}, {"sha": "3954d62ad5c77e4f241e1ec9d5cb0f84f8203cbd", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::Span;\n \n use super::{Locations, TypeChecker};\n \n-impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n         body: &Body<'tcx>,"}, {"sha": "3b138bc1262575f419dad609fe45569b55c035fd", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -25,11 +25,11 @@ mod trace;\n ///\n /// N.B., this computation requires normalization; therefore, it must be\n /// performed before\n-pub(super) fn generate<'gcx, 'tcx>(\n-    typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+pub(super) fn generate<'tcx>(\n+    typeck: &mut TypeChecker<'_, 'tcx>,\n     body: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     location_table: &LocationTable,\n ) {\n@@ -75,7 +75,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n // some region `R` in its type where `R` is not known to outlive a free\n // region (i.e., where `R` may be valid for just a subset of the fn body).\n fn compute_live_locals(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     free_regions: &FxHashSet<RegionVid>,\n     body: &Body<'tcx>,\n ) -> Vec<Local> {"}, {"sha": "48e45e94525696c3e6b155c22bc76301389230f3", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -31,10 +31,10 @@ use std::rc::Rc;\n /// `dropck_outlives` result of the variable's type (in particular,\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n-    typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    typeck: &mut TypeChecker<'_, 'tcx>,\n     body: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     live_locals: Vec<Local>,\n     location_table: &LocationTable,\n@@ -58,15 +58,14 @@ pub(super) fn trace(\n }\n \n /// Contextual state for the type-liveness generator.\n-struct LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>\n+struct LivenessContext<'me, 'typeck, 'flow, 'tcx>\n where\n     'typeck: 'me,\n     'flow: 'me,\n     'tcx: 'typeck + 'flow,\n-    'gcx: 'tcx,\n {\n     /// Current type-checker, giving us our inference context etc.\n-    typeck: &'me mut TypeChecker<'typeck, 'gcx, 'tcx>,\n+    typeck: &'me mut TypeChecker<'typeck, 'tcx>,\n \n     /// Defines the `PointIndex` mapping\n     elements: &'me RegionValueElements,\n@@ -82,7 +81,7 @@ where\n \n     /// Results of dataflow tracking which variables (and paths) have been\n     /// initialized.\n-    flow_inits: &'me mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n+    flow_inits: &'me mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'flow, 'tcx>>,\n \n     /// Index indicating where each variable is assigned, used, or\n     /// dropped.\n@@ -97,14 +96,13 @@ struct DropData<'tcx> {\n     region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n-struct LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx>\n+struct LivenessResults<'me, 'typeck, 'flow, 'tcx>\n where\n     'typeck: 'me,\n     'flow: 'me,\n     'tcx: 'typeck + 'flow,\n-    'gcx: 'tcx,\n {\n-    cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>,\n+    cx: LivenessContext<'me, 'typeck, 'flow, 'tcx>,\n \n     /// Set of points that define the current local.\n     defs: HybridBitSet<PointIndex>,\n@@ -125,8 +123,8 @@ where\n     stack: Vec<PointIndex>,\n }\n \n-impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n-    fn new(cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>) -> Self {\n+impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n+    fn new(cx: LivenessContext<'me, 'typeck, 'flow, 'tcx>) -> Self {\n         let num_points = cx.elements.num_points();\n         LivenessResults {\n             cx,\n@@ -392,7 +390,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n     }\n }\n \n-impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n+impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// Returns `true` if the local variable (or some part of it) is initialized in\n     /// the terminator of `block`. We need to check this to determine if a\n     /// DROP of some local variable will have an effect -- note that\n@@ -504,7 +502,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n \n     fn make_all_regions_live(\n         elements: &RegionValueElements,\n-        typeck: &mut TypeChecker<'_, '_, 'tcx>,\n+        typeck: &mut TypeChecker<'_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n         live_at: &HybridBitSet<PointIndex>,\n         location_table: &LocationTable,\n@@ -536,7 +534,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n     }\n \n     fn compute_drop_data(\n-        typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        typeck: &mut TypeChecker<'_, 'tcx>,\n         dropped_ty: Ty<'tcx>,\n     ) -> DropData<'tcx> {\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);"}, {"sha": "77e0b54781c94968c08963a1535409097d1f4ea1", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -109,16 +109,16 @@ mod relate_tys;\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n-pub(crate) fn type_check<'gcx, 'tcx>(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'gcx>,\n+pub(crate) fn type_check<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n ) -> MirTypeckResults<'tcx> {\n@@ -175,16 +175,16 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     }\n }\n \n-fn type_check_internal<'a, 'gcx, 'tcx, R>(\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+fn type_check_internal<'a, 'tcx, R>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     mir_def_id: DefId,\n-    param_env: ty::ParamEnv<'gcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &'a Body<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n+    mut extra: impl FnMut(&mut TypeChecker<'a, 'tcx>) -> R,\n ) -> R where {\n     let mut checker = TypeChecker::new(\n         infcx,\n@@ -235,7 +235,7 @@ fn translate_outlives_facts(cx: &mut BorrowCheckContext<'_, '_>) {\n     }\n }\n \n-fn mirbug(tcx: TyCtxt<'_, '_>, span: Span, msg: &str) {\n+fn mirbug(tcx: TyCtxt<'_>, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n     // to avoid reporting bugs in those cases.\n@@ -251,15 +251,15 @@ enum FieldAccessError {\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n-    cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n+struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n+    cx: &'a mut TypeChecker<'b, 'tcx>,\n     body: &'b Body<'tcx>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n         if !span.is_dummy() {\n             self.last_span = *span;\n@@ -380,8 +380,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, body: &'b Body<'tcx>) -> Self {\n+impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n+    fn new(cx: &'a mut TypeChecker<'b, 'tcx>, body: &'b Body<'tcx>) -> Self {\n         TypeVerifier {\n             body,\n             mir_def_id: cx.mir_def_id,\n@@ -391,7 +391,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.cx.infcx.tcx\n     }\n \n@@ -455,7 +455,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 PlaceBase::Static(box Static { kind, ty: sty }) => {\n                     let sty = self.sanitize_type(place, sty);\n                     let check_err =\n-                        |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                        |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n                          place: &Place<'tcx>,\n                          ty,\n                          sty| {\n@@ -830,9 +830,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n /// constraints needed for it to be valid and well-typed. Along the\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n-struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'gcx>,\n+struct TypeChecker<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n@@ -895,7 +895,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n impl MirTypeckRegionConstraints<'tcx> {\n     fn placeholder_region(\n         &mut self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         placeholder: ty::PlaceholderRegion,\n     ) -> ty::Region<'tcx> {\n         let placeholder_index = self.placeholder_indices.insert(placeholder);\n@@ -977,12 +977,12 @@ impl Locations {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n-        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n         body: &'a Body<'tcx>,\n         mir_def_id: DefId,\n-        param_env: ty::ParamEnv<'gcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,\n         borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n@@ -1078,7 +1078,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory,\n-        op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n+        op: impl type_op::TypeOp<'tcx, Output = R>,\n     ) -> Fallible<R> {\n         let (r, opt_data) = op.fully_perform(self.infcx)?;\n \n@@ -1313,7 +1313,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -2504,7 +2504,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn prove_closure_bounds(\n         &mut self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         location: Location,\n@@ -2652,7 +2652,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n     where\n-        T: type_op::normalize::Normalizable<'gcx, 'tcx> + Copy,\n+        T: type_op::normalize::Normalizable<'tcx> + Copy,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         let param_env = self.param_env;"}, {"sha": "5ced356299fc9ebdc906424065490fd3db6108d3", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -17,7 +17,7 @@ use rustc::ty::{self, Ty};\n /// N.B., the type `a` is permitted to have unresolved inference\n /// variables, but not the type `b`.\n pub(super) fn relate_types<'tcx>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    infcx: &InferCtxt<'_, 'tcx>,\n     a: Ty<'tcx>,\n     v: ty::Variance,\n     b: Ty<'tcx>,\n@@ -34,8 +34,8 @@ pub(super) fn relate_types<'tcx>(\n     Ok(())\n }\n \n-struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'tcx: 'bccx> {\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n     borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n \n     /// Where (and why) is this relation taking place?\n@@ -45,9 +45,9 @@ struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     category: ConstraintCategory,\n }\n \n-impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n+impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n-        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        infcx: &'me InferCtxt<'me, 'tcx>,\n         borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n         locations: Locations,\n         category: ConstraintCategory,\n@@ -61,7 +61,7 @@ impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n+impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n     fn create_next_universe(&mut self) -> ty::UniverseIndex {\n         self.infcx.create_next_universe()\n     }"}, {"sha": "df0110ed3e39b37c126c40530a991cd83253f262", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n     /// match up with the upvar order in the HIR, typesystem, and MIR.\n-    pub fn upvar_tys(self, tcx: TyCtxt<'_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+    pub fn upvar_tys(self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n             DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),\n             DefiningTy::Generator(def_id, substs, _) => {\n@@ -194,7 +194,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// signature. This will also compute the relationships that are\n     /// known between those regions.\n     pub fn new(\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n@@ -218,7 +218,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// `'1: '2`, then the caller would impose the constraint that\n     /// `V[1]: V[2]`.\n     pub fn closure_mapping(\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         closure_substs: SubstsRef<'tcx>,\n         expected_num_vars: usize,\n         closure_base_def_id: DefId,\n@@ -305,7 +305,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// that this region imposes on others. The methods in this file\n     /// handle the part about dumping the inference context internal\n     /// state.\n-    crate fn annotate(&self, tcx: TyCtxt<'_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!(\n@@ -363,16 +363,16 @@ impl<'tcx> UniversalRegions<'tcx> {\n     }\n }\n \n-struct UniversalRegionsBuilder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct UniversalRegionsBuilder<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n     mir_def_id: DefId,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n \n-impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     fn build(self) -> UniversalRegions<'tcx> {\n         debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n \n@@ -639,7 +639,7 @@ trait InferCtxtExt<'tcx> {\n     );\n }\n \n-impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n@@ -744,7 +744,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n \n     /// Replaces all free regions in `value` with region vids, as\n     /// returned by `to_region_vid`.\n-    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, 'tcx>, value: &T) -> T\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'tcx>, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -757,7 +757,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n /// Iterates over the late-bound regions defined on fn_def_id and\n /// invokes `f` with the liberated form of each one.\n fn for_each_late_bound_region_defined_on<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {"}, {"sha": "aa2b177e54ed8607a211089b776fd48990702d6e", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,9 +22,9 @@ pub(super) enum Control {\n }\n \n /// Encapsulates the idea of iterating over every borrow that involves a particular path\n-pub(super) fn each_borrow_involving_path<'tcx, 'gcx: 'tcx, F, I, S>(\n+pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n     s: &mut S,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),"}, {"sha": "a8f28b64b4953e19103a6f3a16bf5f82d7f5106b", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,7 +12,7 @@ crate trait PlaceExt<'tcx> {\n     /// for borrows of raw pointer dereferents as well as shared references.\n     fn ignore_borrow(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool;\n@@ -21,7 +21,7 @@ crate trait PlaceExt<'tcx> {\n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n     fn ignore_borrow(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {"}, {"sha": "64ca00defc9c0583f7163b6381c66a629b8472a4", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -24,8 +24,8 @@ crate enum PlaceConflictBias {\n /// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n-crate fn places_conflict<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+crate fn places_conflict<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n@@ -46,8 +46,8 @@ crate fn places_conflict<'gcx, 'tcx>(\n /// access depth. The `bias` parameter is used to determine how the unknowable (comparing runtime\n /// array indices, for example) should be interpreted - this depends on what the caller wants in\n /// order to make the conservative choice and preserve soundness.\n-pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(super) fn borrow_conflicts_with_place<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n@@ -83,8 +83,8 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n     })\n }\n \n-fn place_components_conflict<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn place_components_conflict<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n@@ -298,8 +298,8 @@ fn place_components_conflict<'gcx, 'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_base_conflict<'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn place_base_conflict<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     elem1: &PlaceBase<'tcx>,\n     elem2: &PlaceBase<'tcx>,\n ) -> Overlap {\n@@ -365,8 +365,8 @@ fn place_base_conflict<'gcx: 'tcx, 'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_projection_conflict<'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn place_projection_conflict<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     pi1: &Projection<'tcx>,\n     pi2: &Projection<'tcx>,"}, {"sha": "b35bcc09a235b7872fb542e450849a5923fb3045", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -36,10 +36,9 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n     }\n }\n \n-\n-pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+pub(super) struct Prefixes<'cx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n     next: Option<&'cx Place<'tcx>>,\n }\n@@ -56,15 +55,11 @@ pub(super) enum PrefixSet {\n     Supporting,\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns an iterator over the prefixes of `place`\n     /// (inclusive) from longest to smallest, potentially\n     /// terminating the iteration early based on `kind`.\n-    pub(super) fn prefixes(\n-        &self,\n-        place: &'cx Place<'tcx>,\n-        kind: PrefixSet,\n-    ) -> Prefixes<'cx, 'gcx, 'tcx> {\n+    pub(super) fn prefixes(&self, place: &'cx Place<'tcx>, kind: PrefixSet) -> Prefixes<'cx, 'tcx> {\n         Prefixes {\n             next: Some(place),\n             kind,\n@@ -74,7 +69,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n     type Item = &'cx Place<'tcx>;\n     fn next(&mut self) -> Option<Self::Item> {\n         let mut cursor = self.next?;"}, {"sha": "e609ddbbe95ffba49bda4599b9f1bf3fdfff03f2", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::FxHashSet;\n \n use crate::borrow_check::MirBorrowckCtxt;\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Walks the MIR adding to the set of `used_mut` locals that will be ignored for the purposes\n     /// of the `unused_mut` lint.\n     ///\n@@ -46,13 +46,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n /// MIR visitor for collecting used mutable variables.\n /// The 'visit lifetime represents the duration of the MIR walk.\n-struct GatherUsedMutsVisitor<'visit, 'cx: 'visit, 'gcx: 'tcx, 'tcx: 'cx> {\n+struct GatherUsedMutsVisitor<'visit, 'cx: 'visit, 'tcx: 'cx> {\n     temporary_used_locals: FxHashSet<Local>,\n     never_initialized_mut_locals: &'visit mut FxHashSet<Local>,\n-    mbcx: &'visit mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+    mbcx: &'visit mut MirBorrowckCtxt<'cx, 'tcx>,\n }\n \n-impl GatherUsedMutsVisitor<'_, '_, '_, '_> {\n+impl GatherUsedMutsVisitor<'_, '_, '_> {\n     fn remove_never_initialized_mut_locals(&mut self, into: &Place<'_>) {\n         // Remove any locals that we found were initialized from the\n         // `never_initialized_mut_locals` set. At the end, the only remaining locals will\n@@ -65,7 +65,7 @@ impl GatherUsedMutsVisitor<'_, '_, '_, '_> {\n     }\n }\n \n-impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'gcx, 'tcx> {\n+impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n     fn visit_terminator_kind(\n         &mut self,\n         kind: &TerminatorKind<'tcx>,"}, {"sha": "69de8623628116bb6494cdc051a34962340433d1", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,7 +22,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n+pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -172,7 +172,7 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n fn liberated_closure_env_ty<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     closure_expr_id: hir::HirId,\n     body_id: hir::BodyId,\n ) -> Ty<'tcx> {\n@@ -489,7 +489,7 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, fn_def_id: DefId, abi: Abi) -> bool {\n+fn should_abort_on_panic<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, abi: Abi) -> bool {\n     // Not callable from C, so we can safely unwind through these\n     if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n \n@@ -515,7 +515,7 @@ fn should_abort_on_panic<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, fn_def_id: DefId, abi: A\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'gcx>(Ty<'gcx>, Option<Span>, Option<&'gcx hir::Pat>, Option<ImplicitSelfKind>);\n+struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Pat>, Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'tcx, A>(\n     hir: Cx<'a, 'tcx>,"}, {"sha": "7d05e7be26eb97a815160f6e0d612ea540365504", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -44,7 +44,7 @@ const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n@@ -53,7 +53,7 @@ pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n }\n \n pub(crate) fn eval_promoted<'mir, 'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -394,7 +394,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn find_foreign_static(\n         _def_id: DefId,\n-        _tcx: TyCtxtAt<'tcx, 'tcx>,\n+        _tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n@@ -467,7 +467,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n pub fn const_field<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n@@ -492,7 +492,7 @@ pub fn const_field<'tcx>(\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n pub fn const_variant_index<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n ) -> VariantIdx {\n@@ -512,7 +512,7 @@ pub fn error_to_const_error<'mir, 'tcx>(\n }\n \n fn validate_and_turn_into_const<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     constant: RawConst<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n@@ -555,7 +555,7 @@ fn validate_and_turn_into_const<'tcx>(\n }\n \n pub fn const_eval_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     // see comment in const_eval_provider for what we're doing here\n@@ -579,7 +579,7 @@ pub fn const_eval_provider<'tcx>(\n }\n \n pub fn const_eval_raw_provider<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n     // Because the constant is computed twice (once per value of `Reveal`), we are at risk of"}, {"sha": "e8a32477f1c3fbddc410ef4323c3a18ee4ca4529", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -46,8 +46,8 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n //\n // FIXME: we have to do something for moving slice patterns.\n-fn place_contents_drop_state_cannot_differ<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn place_contents_drop_state_cannot_differ<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     place: &mir::Place<'tcx>,\n ) -> bool {\n@@ -74,8 +74,8 @@ fn place_contents_drop_state_cannot_differ<'gcx, 'tcx>(\n     }\n }\n \n-pub(crate) fn on_lookup_result_bits<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn on_lookup_result_bits<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n@@ -93,17 +93,17 @@ pub(crate) fn on_lookup_result_bits<'gcx, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn on_all_children_bits<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn on_all_children_bits<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n     mut each_child: F,\n ) where\n     F: FnMut(MovePathIndex),\n {\n-    fn is_terminal_path<'gcx, 'tcx>(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+    fn is_terminal_path<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex,\n@@ -112,8 +112,8 @@ pub(crate) fn on_all_children_bits<'gcx, 'tcx, F>(\n             tcx, body, &move_data.move_paths[path].place)\n     }\n \n-    fn on_all_children_bits<'gcx, 'tcx, F>(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+    fn on_all_children_bits<'tcx, F>(\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n@@ -136,10 +136,10 @@ pub(crate) fn on_all_children_bits<'gcx, 'tcx, F>(\n     on_all_children_bits(tcx, body, move_data, move_path_index, &mut each_child);\n }\n \n-pub(crate) fn on_all_drop_children_bits<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn on_all_drop_children_bits<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n+    ctxt: &MoveDataParamEnv<'tcx>,\n     path: MovePathIndex,\n     mut each_child: F,\n ) where\n@@ -160,10 +160,10 @@ pub(crate) fn on_all_drop_children_bits<'gcx, 'tcx, F>(\n     })\n }\n \n-pub(crate) fn drop_flag_effects_for_function_entry<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_function_entry<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n+    ctxt: &MoveDataParamEnv<'tcx>,\n     mut callback: F,\n ) where\n     F: FnMut(MovePathIndex, DropFlagState),\n@@ -178,10 +178,10 @@ pub(crate) fn drop_flag_effects_for_function_entry<'gcx, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn drop_flag_effects_for_location<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_location<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n+    ctxt: &MoveDataParamEnv<'tcx>,\n     loc: Location,\n     mut callback: F,\n ) where\n@@ -211,8 +211,8 @@ pub(crate) fn drop_flag_effects_for_location<'gcx, 'tcx, F>(\n     );\n }\n \n-pub(crate) fn for_location_inits<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn for_location_inits<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     loc: Location,"}, {"sha": "ba1a22c8d42ebdef355720d3345a0191480b4d3b", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -29,8 +29,8 @@ newtype_index! {\n /// `BorrowIndex`, and maps each such index to a `BorrowData`\n /// describing the borrow. These indexes are used for representing the\n /// borrows in compact bitvectors.\n-pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct Borrows<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n@@ -133,9 +133,9 @@ fn precompute_borrows_out_of_scope<'tcx>(\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     crate fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n@@ -234,7 +234,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n     type Idx = BorrowIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n@@ -330,14 +330,14 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitSetOperator for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for Borrows<'a, 'tcx> {\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n         inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InitialFlow for Borrows<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = nothing is reserved or activated yet"}, {"sha": "50d9bbf4cc324c0e23d2a03c0b95ea76e7f82bb0", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 39, "deletions": 56, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -63,23 +63,19 @@ pub(super) mod borrows;\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeUninitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n-pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct MaybeInitializedPlaces<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n-    ) -> Self {\n+impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -118,23 +114,19 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeInitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n-pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct MaybeUninitializedPlaces<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n-    ) -> Self {\n+impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -172,23 +164,19 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 't\n /// Similarly, at a given `drop` statement, the set-difference between\n /// this data and `MaybeInitializedPlaces` yields the set of places\n /// that would require a dynamic drop-flag at that statement.\n-pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct DefinitelyInitializedPlaces<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n-    ) -> Self {\n+impl<'a, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -221,28 +209,23 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n ///     c = S;                                 // {a, b, c, d }\n /// }\n /// ```\n-pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub struct EverInitializedPlaces<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n-    ) -> Self {\n+impl<'a, 'tcx: 'a> EverInitializedPlaces<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-\n-impl<'a, 'gcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -253,7 +236,7 @@ impl<'a, 'gcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -264,7 +247,7 @@ impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -275,7 +258,7 @@ impl<'a, 'gcx, 'tcx> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -328,7 +311,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 't\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self) -> usize {\n@@ -386,7 +369,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx,\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -442,7 +425,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gc\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n     type Idx = InitIndex;\n     fn name() -> &'static str { \"ever_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -519,28 +502,28 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitSetOperator for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for MaybeInitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n         inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitSetOperator for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for MaybeUninitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n         inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitSetOperator for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for DefinitelyInitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n         inout_set.intersect(in_set) // \"definitely\" means we intersect effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitSetOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for EverInitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n         inout_set.union(in_set) // inits from both preds are in scope\n@@ -557,28 +540,28 @@ impl<'a, 'gcx, 'tcx> BitSetOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InitialFlow for MaybeInitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = uninitialized\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InitialFlow for MaybeUninitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         true // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no initialized variables by default"}, {"sha": "d8fbfa956a1064fca3ef2e731e1d58421f4a930f", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -116,13 +116,13 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n     return None;\n }\n \n-pub struct MoveDataParamEnv<'gcx, 'tcx> {\n+pub struct MoveDataParamEnv<'tcx> {\n     pub(crate) move_data: MoveData<'tcx>,\n-    pub(crate) param_env: ty::ParamEnv<'gcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     def_id: DefId,\n     attributes: &[ast::Attribute],\n@@ -138,13 +138,13 @@ where\n     flow_state.run(tcx, def_id, attributes, p)\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n+impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n where\n     BD: BitDenotation<'tcx>,\n {\n     pub(crate) fn run<P>(\n         self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         attributes: &[ast::Attribute],\n         p: P,"}, {"sha": "7c738b75e072261131cdbad1ec01e1793a42e192", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,15 +12,15 @@ use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, Move\n use super::{MoveError, InitIndex, Init, InitLocation, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n \n-struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+struct MoveDataBuilder<'a, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n-impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n+impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// This creates a MovePath for a given place, returning an `MovePathError`\n     /// if that place can't be moved from.\n     ///\n@@ -178,7 +178,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn finalize(\n         self\n     ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n@@ -202,9 +202,9 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub(super) fn gather_moves<'gcx, 'tcx>(\n+pub(super) fn gather_moves<'tcx>(\n     body: &Body<'tcx>,\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n     let mut builder = MoveDataBuilder::new(body, tcx);\n \n@@ -226,7 +226,7 @@ pub(super) fn gather_moves<'gcx, 'tcx>(\n     builder.finalize()\n }\n \n-impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn gather_args(&mut self) {\n         for arg in self.body.args_iter() {\n             let path = self.data.rev_lookup.locals[arg];\n@@ -253,12 +253,12 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct Gatherer<'b, 'a: 'b, 'gcx: 'tcx, 'tcx: 'a> {\n-    builder: &'b mut MoveDataBuilder<'a, 'gcx, 'tcx>,\n+struct Gatherer<'b, 'a: 'b, 'tcx: 'a> {\n+    builder: &'b mut MoveDataBuilder<'a, 'tcx>,\n     loc: Location,\n }\n \n-impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n+impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n             StatementKind::Assign(ref place, ref rval) => {"}, {"sha": "938450c63aefca3614318e3eab295b2205af6f81", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -205,7 +205,7 @@ impl fmt::Debug for Init {\n }\n \n impl Init {\n-    crate fn span<'gcx>(&self, body: &Body<'gcx>) -> Span {\n+    crate fn span<'tcx>(&self, body: &Body<'tcx>) -> Span {\n         match self.location {\n             InitLocation::Argument(local) => body.local_decls[local].source_info.span,\n             InitLocation::Statement(location) => body.source_info(location).span,\n@@ -305,10 +305,10 @@ impl<'tcx> MoveError<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> MoveData<'tcx> {\n+impl<'tcx> MoveData<'tcx> {\n     pub fn gather_moves(\n         body: &Body<'tcx>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         builder::gather_moves(body, tcx)\n     }"}, {"sha": "2cd04631118d1a023f318f137a0aeea254eb4791", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,7 +11,7 @@ crate enum LitToConstError {\n \n crate fn lit_to_const<'tcx>(\n     lit: &'tcx ast::LitKind,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     neg: bool,\n ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {"}, {"sha": "7740042c783fce12aac1ec9c6cee2e5b58c5c1c8", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,8 +22,8 @@ use crate::hair::constant::{lit_to_const, LitToConstError};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n \n     pub root_lint_level: hir::HirId,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -52,8 +52,7 @@ pub struct Cx<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n-               src_id: hir::HirId) -> Cx<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>, src_id: hir::HirId) -> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n         let tables = tcx.typeck_tables_of(src_def_id);\n@@ -200,7 +199,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -218,7 +217,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n }\n \n impl UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx()\n     }\n "}, {"sha": "1d7c450f69506f89792a1484b774edb0a682962c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -195,7 +195,7 @@ pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx\n }\n \n struct LiteralExpander<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl LiteralExpander<'tcx> {\n@@ -350,7 +350,7 @@ impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pattern<'tcx>; 2]>> for Matrix<'p, 'tc\n }\n \n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n@@ -365,7 +365,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n         f: F,\n@@ -829,7 +829,7 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n-    fn from_ctor(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> Option<IntRange<'tcx>> {\n+    fn from_ctor(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         fn is_integral<'tcx>(ty: Ty<'tcx>) -> bool {\n@@ -867,7 +867,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_pat(tcx: TyCtxt<'tcx, 'tcx>, mut pat: &Pattern<'tcx>) -> Option<IntRange<'tcx>> {\n+    fn from_pat(tcx: TyCtxt<'tcx>, mut pat: &Pattern<'tcx>) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n                 box PatternKind::Constant { value } => break ConstantValue(value),\n@@ -887,7 +887,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n-    fn signed_bias(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n+    fn signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n@@ -899,7 +899,7 @@ impl<'tcx> IntRange<'tcx> {\n \n     /// Converts a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n     fn range_to_ctor(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         r: RangeInclusive<u128>,\n     ) -> Constructor<'tcx> {\n@@ -917,7 +917,7 @@ impl<'tcx> IntRange<'tcx> {\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n     fn subtract_from(\n         self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         ranges: Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n         let ranges = ranges.into_iter().filter_map(|r| {\n@@ -987,7 +987,7 @@ enum MissingCtors<'tcx> {\n // to compute the full set.)\n fn compute_missing_ctors<'a, 'tcx: 'a>(\n     info: MissingCtorsInfo,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n     used_ctors: &Vec<Constructor<'tcx>>,\n ) -> MissingCtors<'tcx> {\n@@ -1423,7 +1423,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n // meaning all other types will compare unequal and thus equal patterns often do not cause the\n // second pattern to lint about unreachable match arms.\n fn slice_pat_covered_by_const<'tcx>(\n-    tcx: TyCtxt<'tcx, '_>,\n+    tcx: TyCtxt<'tcx>,\n     _span: Span,\n     const_val: &'tcx ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n@@ -1475,7 +1475,7 @@ fn slice_pat_covered_by_const<'tcx>(\n \n // Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n // constructor is a range or constant with an integer type.\n-fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n+fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     let ty = match ctor {\n         ConstantValue(value) => value.ty,\n         ConstantRange(_, _, ty, _) => ty,\n@@ -1521,7 +1521,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -1599,7 +1599,7 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n \n /// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &'p Pattern<'tcx>,\n ) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n@@ -1627,7 +1627,7 @@ fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n }\n \n fn constructor_covered_by_range<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {"}, {"sha": "e7fd308070c9b70879c77ab990980c0efb7b41ff", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -26,7 +26,7 @@ use std::slice;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-pub(crate) fn check_match<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n+pub(crate) fn check_match<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         tcx.hir().body_owned_by(id)\n     } else {\n@@ -48,7 +48,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n }\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body_owner: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "e0e14852c577a0fd1350d4b6f33406e9722c1bc1", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n }\n \n pub struct PatternContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n@@ -336,7 +336,7 @@ pub struct PatternContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Pattern<'tcx> {\n     pub fn from_hir(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n         tables: &'a ty::TypeckTables<'tcx>,\n         pat: &'tcx hir::Pat,\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> Pattern<'tcx> {\n \n impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> Self {\n@@ -1059,7 +1059,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n }\n \n impl UserAnnotatedTyHelpers<'tcx> for PatternContext<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -1247,7 +1247,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n }\n \n pub fn compare_const_vals<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,"}, {"sha": "4e014855df5e07272a3b0b89971503edf5481616", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::ty::{self, CanonicalUserType, TyCtxt, UserType};\n \n crate trait UserAnnotatedTyHelpers<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn tables(&self) -> &ty::TypeckTables<'tcx>;\n "}, {"sha": "f985c6000b5b28159936c14d69bce2319255a5b1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -31,7 +31,7 @@ pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxtAt<'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n@@ -170,7 +170,7 @@ where\n     M: Machine<'mir, 'tcx>,\n {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         *self.tcx\n     }\n }\n@@ -196,7 +196,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n+    pub fn new(tcx: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n         InterpretCx {\n             machine,\n             tcx,"}, {"sha": "5ca3531c98bb1b91a9c581adc2abe4f8af548d11", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,11 +10,11 @@ use std::fmt::Write;\n use rustc::mir::interpret::{Allocation, ConstValue};\n \n struct AbsolutePathPrinter<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     path: String,\n }\n \n-impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n+impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     type Error = std::fmt::Error;\n \n     type Path = Self;\n@@ -23,7 +23,7 @@ impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -167,18 +167,16 @@ impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n         }\n     }\n }\n-impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n+impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n     fn region_should_not_be_omitted(\n         &self,\n         _region: ty::Region<'_>,\n     ) -> bool {\n         false\n     }\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n     {\n         if let Some(first) = elems.next() {\n             self = first.print(self)?;\n@@ -212,7 +210,7 @@ impl Write for AbsolutePathPrinter<'_> {\n \n /// Produces an absolute path representation of the given type. See also the documentation on\n /// `std::any::type_name`\n-pub fn type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n+pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n     let alloc = alloc_type_name(tcx, ty);\n     tcx.mk_const(ty::Const {\n         val: ConstValue::Slice {\n@@ -225,7 +223,7 @@ pub fn type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const\n }\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-pub(super) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Allocation {\n+pub(super) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Allocation {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "58ee952879d9d500a7b7b30f14bce918b992e165", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -137,7 +137,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n         def_id: DefId,\n-        tcx: TyCtxtAt<'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer"}, {"sha": "e724c377df73de5581316736dfbe378964633c05", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -66,7 +66,7 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub(super) tcx: TyCtxtAt<'tcx, 'tcx>,\n+    pub(super) tcx: TyCtxtAt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -94,7 +94,7 @@ where\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxtAt<'tcx>) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n@@ -324,7 +324,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n         id: AllocId,\n-        tcx: TyCtxtAt<'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx>,\n         memory_extra: &M::MemoryExtra,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);"}, {"sha": "0032e84b266c8b3a1eec7890d8b0c7e2db96623c", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -46,7 +46,7 @@ pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n     pub fn observe_and_analyze(\n         &mut self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         span: Span,\n         memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>],"}, {"sha": "55151a9b33eb9d07cc94df51854dee5f712f01a0", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::{self, Body, TerminatorKind};\n use rustc::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n-pub fn check(tcx: TyCtxt<'tcx, 'tcx>, body: &Body<'tcx>, def_id: DefId) {\n+pub fn check(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n@@ -16,7 +16,7 @@ pub fn check(tcx: TyCtxt<'tcx, 'tcx>, body: &Body<'tcx>, def_id: DefId) {\n }\n \n fn check_fn_for_unconditional_recursion(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     fn_kind: FnKind<'_>,\n     body: &Body<'tcx>,\n     def_id: DefId,"}, {"sha": "e530c56ed6f3a5916bd98f1de9f4355a2697a1a0", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -282,7 +282,7 @@ impl<'tcx> InliningMap<'tcx> {\n }\n \n pub fn collect_crate_mono_items<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mode: MonoItemCollectionMode,\n ) -> (FxHashSet<MonoItem<'tcx>>, InliningMap<'tcx>) {\n     let roots = time(tcx.sess, \"collecting roots\", || {\n@@ -315,10 +315,7 @@ pub fn collect_crate_mono_items<'tcx>(\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    mode: MonoItemCollectionMode,\n-) -> Vec<MonoItem<'tcx>> {\n+fn collect_roots<'tcx>(tcx: TyCtxt<'tcx>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -349,7 +346,7 @@ fn collect_roots<'tcx>(\n \n // Collect all monomorphized items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     starting_point: MonoItem<'tcx>,\n     visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n@@ -417,7 +414,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(\n }\n \n fn record_accesses<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     caller: MonoItem<'tcx>,\n     callees: &[MonoItem<'tcx>],\n     inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n@@ -435,7 +432,7 @@ fn record_accesses<'tcx>(\n }\n \n fn check_recursion_limit<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     recursion_depths: &mut DefIdMap<usize>,\n ) -> (DefId, usize) {\n@@ -469,7 +466,7 @@ fn check_recursion_limit<'tcx>(\n     (def_id, recursion_depth)\n }\n \n-fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: Instance<'tcx>) {\n+fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n     let const_length = instance.substs.consts().flat_map(|ct| ct.ty.walk()).count();\n     debug!(\" => type length={}, const length={}\", type_length, const_length);\n@@ -519,7 +516,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: Instance<'tc\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: SubstsRef<'tcx>,\n@@ -684,7 +681,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n }\n \n fn visit_drop_use<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n     output: &mut Vec<MonoItem<'tcx>>,\n@@ -694,7 +691,7 @@ fn visit_drop_use<'tcx>(\n }\n \n fn visit_fn_use<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n     output: &mut Vec<MonoItem<'tcx>>,\n@@ -709,7 +706,7 @@ fn visit_fn_use<'tcx>(\n }\n \n fn visit_instance_use<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     instance: ty::Instance<'tcx>,\n     is_direct_call: bool,\n     output: &mut Vec<MonoItem<'tcx>>,\n@@ -748,7 +745,7 @@ fn visit_instance_use<'tcx>(\n // Returns true if we should codegen an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n // need a mono item.\n-fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instance<'tcx>) -> bool {\n+fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) -> bool {\n     let def_id = match instance.def {\n         ty::InstanceDef::Item(def_id) => def_id,\n         ty::InstanceDef::VtableShim(..) |\n@@ -783,7 +780,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instanc\n     return true;\n \n     fn is_available_upstream_generic<'tcx>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> bool {\n@@ -849,7 +846,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instanc\n /// Finally, there is also the case of custom unsizing coercions, e.g., for\n /// smart pointers such as `Rc` and `Arc`.\n fn find_vtable_types_for_unsizing<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     source_ty: Ty<'tcx>,\n     target_ty: Ty<'tcx>,\n ) -> (Ty<'tcx>, Ty<'tcx>) {\n@@ -923,7 +920,7 @@ fn create_fn_mono_item<'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n fn create_mono_items_for_vtable_methods<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_ty: Ty<'tcx>,\n     impl_ty: Ty<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n@@ -959,7 +956,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n //=-----------------------------------------------------------------------------\n \n struct RootCollector<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mode: MonoItemCollectionMode,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     entry_fn: Option<(DefId, EntryFnType)>,\n@@ -1117,13 +1114,13 @@ impl RootCollector<'_, 'v> {\n     }\n }\n \n-fn item_requires_monomorphization<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn item_requires_monomorphization<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n     generics.requires_monomorphization(tcx)\n }\n \n fn create_mono_items_for_default_impls<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n@@ -1188,11 +1185,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n }\n \n /// Scan the miri alloc in order to find function calls, closures, and drop-glue\n-fn collect_miri<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    alloc_id: AllocId,\n-    output: &mut Vec<MonoItem<'tcx>>,\n-) {\n+fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n     let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n     match alloc_kind {\n         Some(GlobalAlloc::Static(def_id)) => {\n@@ -1220,7 +1213,7 @@ fn collect_miri<'tcx>(\n \n /// Scan the MIR in order to find function calls, closures, and drop-glue\n fn collect_neighbours<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n@@ -1250,15 +1243,15 @@ fn collect_neighbours<'tcx>(\n     }\n }\n \n-fn def_id_to_string<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> String {\n+fn def_id_to_string<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> String {\n     let mut output = String::new();\n     let printer = DefPathBasedNames::new(tcx, false, false);\n     printer.push_def_path(def_id, &mut output);\n     output\n }\n \n fn collect_const<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     constant: &'tcx ty::Const<'tcx>,\n     param_substs: SubstsRef<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,"}, {"sha": "595e599c1150a930e74fdaa701335847b3c99643", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -48,7 +48,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn symbol_name(&self, tcx: TyCtxt<'tcx, 'tcx>) -> ty::SymbolName {\n+    fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => {\n@@ -62,7 +62,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n             }\n         }\n     }\n-    fn instantiation_mode(&self, tcx: TyCtxt<'tcx, 'tcx>) -> InstantiationMode {\n+    fn instantiation_mode(&self, tcx: TyCtxt<'tcx>) -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n                 tcx.sess.opts.optimize != OptLevel::No\n@@ -106,7 +106,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn explicit_linkage(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Linkage> {\n+    fn explicit_linkage(&self, tcx: TyCtxt<'tcx>) -> Option<Linkage> {\n         let def_id = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n             MonoItem::Static(def_id) => def_id,\n@@ -142,7 +142,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    fn is_instantiable(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n+    fn is_instantiable(&self, tcx: TyCtxt<'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n@@ -154,7 +154,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    fn to_string(&self, tcx: TyCtxt<'tcx, 'tcx>, debug: bool) -> String {\n+    fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {\n         return match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance, debug)\n@@ -169,7 +169,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n         };\n \n         fn to_string_internal<'a, 'tcx>(\n-            tcx: TyCtxt<'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             prefix: &str,\n             instance: Instance<'tcx>,\n             debug: bool,\n@@ -182,7 +182,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn local_span(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Span> {\n+    fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self.as_mono_item() {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir().as_local_hir_id(def.def_id())"}, {"sha": "b36cf49ef1e45bde977c78035f1847414945d540", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,7 +6,7 @@ pub mod collector;\n pub mod partitioning;\n \n pub fn custom_coerce_unsize_info<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     source_ty: Ty<'tcx>,\n     target_ty: Ty<'tcx>,\n ) -> CustomCoerceUnsized {"}, {"sha": "a821cb2cfdad275858cd64ea84cecac86d3112df", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -121,12 +121,12 @@ pub enum PartitioningStrategy {\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_>) -> InternedString {\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> InternedString {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n pub fn partition<'tcx, I>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mono_items: I,\n     strategy: PartitioningStrategy,\n     inlining_map: &InliningMap<'tcx>,\n@@ -203,10 +203,7 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_mono_items<'tcx, I>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    mono_items: I,\n-) -> PreInliningPartitioning<'tcx>\n+fn place_root_mono_items<'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I) -> PreInliningPartitioning<'tcx>\n where\n     I: Iterator<Item = MonoItem<'tcx>>,\n {\n@@ -280,7 +277,7 @@ where\n }\n \n fn mono_item_linkage_and_visibility(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n     export_generics: bool,\n@@ -298,7 +295,7 @@ fn mono_item_linkage_and_visibility(\n }\n \n fn mono_item_visibility(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n     export_generics: bool,\n@@ -443,7 +440,7 @@ fn mono_item_visibility(\n     }\n }\n \n-fn default_visibility(tcx: TyCtxt<'_, '_>, id: DefId, is_generic: bool) -> Visibility {\n+fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n     if !tcx.sess.target.target.options.default_hidden_visibility {\n         return Visibility::Default\n     }\n@@ -468,7 +465,7 @@ fn default_visibility(tcx: TyCtxt<'_, '_>, id: DefId, is_generic: bool) -> Visib\n }\n \n fn merge_codegen_units<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n     target_cgu_count: usize,\n ) {\n@@ -592,7 +589,7 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n }\n \n fn internalize_symbols<'tcx>(\n-    _tcx: TyCtxt<'tcx, 'tcx>,\n+    _tcx: TyCtxt<'tcx>,\n     partitioning: &mut PostInliningPartitioning<'tcx>,\n     inlining_map: &InliningMap<'tcx>,\n ) {\n@@ -659,7 +656,7 @@ fn internalize_symbols<'tcx>(\n }\n \n fn characteristic_def_id_of_mono_item<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mono_item: MonoItem<'tcx>,\n ) -> Option<DefId> {\n     match mono_item {\n@@ -708,8 +705,8 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n \n fn compute_codegen_unit_name(\n-    tcx: TyCtxt<'_, '_>,\n-    name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n+    tcx: TyCtxt<'_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n     def_id: DefId,\n     volatile: bool,\n     cache: &mut CguNameCache,\n@@ -763,13 +760,13 @@ fn compute_codegen_unit_name(\n }\n \n fn numbered_codegen_unit_name(\n-    name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n     index: usize,\n ) -> InternedString {\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>, label: &str, cgus: I)\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx>, label: &str, cgus: I)\n where\n     I: Iterator<Item = &'b CodegenUnit<'tcx>>,\n     'tcx: 'a + 'b,\n@@ -797,7 +794,7 @@ where\n }\n \n #[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx, 'tcx>, mono_items: I)\n+fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n where\n     I: Iterator<Item = &'a MonoItem<'tcx>>,\n {\n@@ -842,7 +839,7 @@ where\n }\n \n fn collect_and_partition_mono_items<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     cnum: CrateNum,\n ) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>) {\n     assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "f5a22ea09315f107ec1a10fcea3d0502f9655aaa", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -26,7 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -163,11 +163,7 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-    ty: Option<Ty<'tcx>>,\n-) -> Body<'tcx> {\n+fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>) -> Body<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n@@ -255,7 +251,7 @@ fn build_drop_shim<'tcx>(\n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n     pub body: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n-    pub tcx: TyCtxt<'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -270,7 +266,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n     fn body(&self) -> &'a Body<'tcx> { self.body }\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n         }\n     fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n@@ -305,7 +301,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n+fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n@@ -336,7 +332,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'t\n }\n \n struct CloneShimBuilder<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n@@ -345,7 +341,7 @@ struct CloneShimBuilder<'tcx> {\n }\n \n impl CloneShimBuilder<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Self {\n+    fn new(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Self {\n         // we must subst the self_ty because it's\n         // otherwise going to be TySelf and we can't index\n         // or access fields of a Place of type TySelf.\n@@ -685,7 +681,7 @@ impl CloneShimBuilder<'tcx> {\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n fn build_call_shim<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     rcvr_adjustment: Adjustment,\n     call_kind: CallKind,\n@@ -835,7 +831,7 @@ fn build_call_shim<'tcx>(\n     body\n }\n \n-pub fn build_adt_ctor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ctor_id: DefId) -> &'tcx Body<'tcx> {\n+pub fn build_adt_ctor<'tcx>(tcx: TyCtxt<'tcx>, ctor_id: DefId) -> &'tcx Body<'tcx> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span = tcx.hir().span_if_local(ctor_id)"}, {"sha": "c08c33bc6ff8b078855cd0906215970939eb2f38", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -31,12 +31,7 @@ pub use self::AddCallGuards::*;\n  */\n \n impl MirPass for AddCallGuards {\n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         self.add_call_guards(body);\n     }\n }"}, {"sha": "a111669f149821f856fe21a46621574a197f576d", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -40,23 +40,19 @@ use crate::util;\n pub struct AddMovesForPackedDrops;\n \n impl MirPass for AddMovesForPackedDrops {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n         add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    body: &mut Body<'tcx>,\n-    def_id: DefId,\n-) {\n+pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, def_id: DefId) {\n     let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n     patch.apply(body);\n }\n \n fn add_moves_for_packed_drops_patch<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     def_id: DefId,\n ) -> MirPatch<'tcx> {\n@@ -86,7 +82,7 @@ fn add_moves_for_packed_drops_patch<'tcx>(\n }\n \n fn add_move_for_packed_drop<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     patch: &mut MirPatch<'tcx>,\n     terminator: &Terminator<'tcx>,"}, {"sha": "ee040bf65901ce5a570b6f6a2402ff22c4a59bc3", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -48,7 +48,7 @@ fn is_stable<'tcx>(\n \n /// Determine whether this type may have a reference in it, recursing below compound types but\n /// not below references.\n-fn may_have_reference<'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n+fn may_have_reference<'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -74,12 +74,7 @@ fn may_have_reference<'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'gcx, 'tcx>) -> bool\n }\n \n impl MirPass for AddRetag {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "80a31efd0d3fe786bddf2e448e97657818f02f7e", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -25,7 +25,7 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n     violations: Vec<UnsafetyViolation>,\n     source_info: SourceInfo,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     /// Mark an `unsafe` block as used, so we don't lint it.\n     used_unsafe: FxHashSet<hir::HirId>,\n@@ -38,7 +38,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         min_const_fn: bool,\n         body: &'a Body<'tcx>,\n         source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         // sanity check\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n }\n \n fn check_unused_unsafe<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     used_unsafe: &FxHashSet<hir::HirId>,\n     unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>,\n@@ -506,7 +506,7 @@ fn check_unused_unsafe<'a, 'tcx>(\n     hir::intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> UnsafetyCheckResult {\n+fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def_id);\n \n     // N.B., this borrow is valid because all the consumers of\n@@ -545,7 +545,7 @@ fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Unsafe\n     }\n }\n \n-fn unsafe_derive_on_repr_packed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n+fn unsafe_derive_on_repr_packed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     let lint_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap_or_else(||\n         bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n@@ -566,7 +566,7 @@ fn unsafe_derive_on_repr_packed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n \n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     used_unsafe: &FxHashSet<hir::HirId>,\n     id: hir::HirId,\n ) -> Option<(String, hir::HirId)> {\n@@ -590,7 +590,7 @@ fn is_enclosed(\n     }\n }\n \n-fn report_unused_unsafe(tcx: TyCtxt<'_, '_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n+fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n     let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n@@ -602,7 +602,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_, '_>, used_unsafe: &FxHashSet<hir::HirId>\n     db.emit();\n }\n \n-fn builtin_derive_def_id<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n+fn builtin_derive_def_id<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n         if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n@@ -618,7 +618,7 @@ fn builtin_derive_def_id<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option\n     }\n }\n \n-pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n     // closures are handled by their parent fn."}, {"sha": "6ee14160bbd1b1e73dfd96e10d1a6db3f2337935", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -27,12 +27,7 @@ pub struct CleanupNonCodegenStatements;\n pub struct DeleteNonCodegenStatements;\n \n impl MirPass for CleanupNonCodegenStatements {\n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx, 'tcx>,\n-        _source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements;\n         delete.visit_body(body);\n     }"}, {"sha": "2ec5c192726b0e3d0cafb24478b02698ec2fb932", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -31,12 +31,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct ConstProp;\n \n impl MirPass for ConstProp {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -87,7 +82,7 @@ type Const<'tcx> = OpTy<'tcx>;\n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -115,15 +110,15 @@ impl<'mir, 'tcx> HasDataLayout for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n         body: &mut Body<'tcx>,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id());\n@@ -602,7 +597,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n }\n \n fn type_size_of<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<u64> {"}, {"sha": "c850b48e074ab4af211f4480c7864d190cf2faa5", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -30,12 +30,7 @@ use crate::util::def_use::DefUseAnalysis;\n pub struct CopyPropagation;\n \n impl MirPass for CopyPropagation {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {"}, {"sha": "1b42a0dffb8941f194255bbaa1f3493f86226678", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,12 +6,7 @@ use crate::util::expand_aggregate;\n pub struct Deaggregator;\n \n impl MirPass for Deaggregator {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "243820ba7d0278cd4ce347e227999e55d886c873", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -18,12 +18,7 @@ impl MirPass for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx, 'tcx>,\n-        _source: MirSource<'tcx>,\n-        _body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {\n     }\n }\n \n@@ -39,7 +34,7 @@ impl fmt::Display for Disambiguator {\n }\n \n pub fn on_mir_pass<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     pass_num: &dyn fmt::Display,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n@@ -57,7 +52,7 @@ pub fn on_mir_pass<'tcx>(\n     }\n }\n \n-pub fn emit_mir<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, outputs: &OutputFilenames) -> io::Result<()> {\n+pub fn emit_mir<'tcx>(tcx: TyCtxt<'tcx>, outputs: &OutputFilenames) -> io::Result<()> {\n     let path = outputs.path(OutputType::Mir);\n     let mut f = File::create(&path)?;\n     mir_util::write_mir_pretty(tcx, None, &mut f)?;"}, {"sha": "584a2fd1341d3c6e605a27c102cc95239fefc1af", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,7 +21,7 @@ use syntax_pos::Span;\n pub struct ElaborateDrops;\n \n impl MirPass for ElaborateDrops {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();\n@@ -74,10 +74,10 @@ impl MirPass for ElaborateDrops {\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything.\n fn find_dead_unwinds<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     def_id: hir::def_id::DefId,\n-    env: &MoveDataParamEnv<'tcx, 'tcx>,\n+    env: &MoveDataParamEnv<'tcx>,\n ) -> BitSet<BasicBlock> {\n     debug!(\"find_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n@@ -138,9 +138,9 @@ struct InitializationData {\n impl InitializationData {\n     fn apply_location<'tcx>(\n         &mut self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        env: &MoveDataParamEnv<'tcx, 'tcx>,\n+        env: &MoveDataParamEnv<'tcx>,\n         loc: Location,\n     ) {\n         drop_flag_effects_for_location(tcx, body, env, loc, |path, df| {\n@@ -186,7 +186,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         self.ctxt.body\n     }\n \n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.ctxt.tcx\n     }\n \n@@ -286,11 +286,11 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n }\n \n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n-    flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n-    flow_uninits: DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n+    env: &'a MoveDataParamEnv<'tcx>,\n+    flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx>>,\n+    flow_uninits: DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "5a29ea21a7a04eed60738429f836f0deea7efad4", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -11,11 +11,11 @@ use rustc::mir::visit::{MutVisitor, TyContext};\n use crate::transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl EraseRegionsVisitor<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx,\n         }\n@@ -50,7 +50,7 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n pub struct EraseRegions;\n \n impl MirPass for EraseRegions {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "9c7aedc12a27b7887e211be0258627d6ea4c4e16", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -169,7 +169,7 @@ struct SuspensionPoint {\n }\n \n struct TransformVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: SubstsRef<'tcx>,\n \n@@ -311,7 +311,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n }\n \n fn make_generator_state_argument_indirect<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     body: &mut Body<'tcx>,\n ) {\n@@ -336,7 +336,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n     DerefArgVisitor.visit_body(body);\n }\n \n-fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n@@ -415,7 +415,7 @@ struct LivenessInfo {\n }\n \n fn locals_live_across_suspend_points(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n@@ -678,7 +678,7 @@ impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n }\n \n fn compute_layout<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n     interior: Ty<'tcx>,\n@@ -800,7 +800,7 @@ fn insert_switch<'tcx>(\n     }\n }\n \n-fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n+fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -850,7 +850,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body:\n }\n \n fn create_generator_drop_shim<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n     def_id: DefId,\n     source: MirSource<'tcx>,\n@@ -942,7 +942,7 @@ fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n }\n \n fn insert_panic_block<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     message: AssertMessage<'tcx>,\n ) -> BasicBlock {\n@@ -974,7 +974,7 @@ fn insert_panic_block<'tcx>(\n }\n \n fn create_generator_resume_function<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     transform: TransformVisitor<'tcx>,\n     def_id: DefId,\n     source: MirSource<'tcx>,\n@@ -1092,12 +1092,7 @@ where\n }\n \n impl MirPass for StateTransform {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {"}, {"sha": "1cbdc2a2de26ef918b43112cb4666fb3fd1da228", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -38,20 +38,15 @@ struct CallSite<'tcx> {\n }\n \n impl MirPass for Inline {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }\n     }\n }\n \n struct Inliner<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n }\n \n@@ -634,7 +629,7 @@ impl Inliner<'tcx> {\n }\n \n fn type_size_of<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<u64> {"}, {"sha": "c338e1ebe936f2dd47d155cc007a269cd4fbb496", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,7 +12,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct InstCombine;\n \n impl MirPass for InstCombine {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -62,12 +62,12 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n /// Finds optimization opportunities on the MIR.\n struct OptimizationFinder<'b, 'tcx> {\n     body: &'b Body<'tcx>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     optimizations: OptimizationList<'tcx>,\n }\n \n impl OptimizationFinder<'b, 'tcx> {\n-    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'tcx, 'tcx>) -> OptimizationFinder<'b, 'tcx> {\n+    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'tcx>) -> OptimizationFinder<'b, 'tcx> {\n         OptimizationFinder {\n             body,\n             tcx,"}, {"sha": "f0aa189804f7de338010f953b9011e7d736037a0", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,12 +10,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct Lower128Bit;\n \n impl MirPass for Lower128Bit {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n         let target_default = tcx.sess.host.options.i128_lowering;\n         if !debugging_override.unwrap_or(target_default) {\n@@ -27,7 +22,7 @@ impl MirPass for Lower128Bit {\n }\n \n impl Lower128Bit {\n-    fn lower_128bit_ops<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+    fn lower_128bit_ops<'tcx>(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let mut new_blocks = Vec::new();\n         let cur_len = body.basic_blocks().len();\n \n@@ -128,7 +123,7 @@ fn check_lang_item_type<'tcx, D>(\n     lhs: &Operand<'tcx>,\n     rhs: &Operand<'tcx>,\n     local_decls: &D,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> DefId\n where\n     D: HasLocalDecls<'tcx>,\n@@ -148,7 +143,7 @@ where\n fn lower_to<'tcx, D>(\n     statement: &Statement<'tcx>,\n     local_decls: &D,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> Option<(LangItem, RhsKind)>\n where\n     D: HasLocalDecls<'tcx>,\n@@ -179,7 +174,7 @@ enum RhsKind {\n }\n \n impl RhsKind {\n-    fn ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Ty<'tcx>> {\n         match *self {\n             RhsKind::Unchanged => None,\n             RhsKind::ForceU128 => Some(tcx.types.u128),"}, {"sha": "04dce326e69de1edc1354772331b48d19f7c5a54", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -50,13 +50,13 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn is_mir_available<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_mir_available<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     tcx.mir_keys(def_id.krate).contains(&def_id)\n }\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n+fn mir_keys<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = DefIdSet::default();\n@@ -67,7 +67,7 @@ fn mir_keys<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n     // Additionally, tuple struct/variant constructors have MIR, but\n     // they don't have a BodyId, so we need to build them separately.\n     struct GatherCtors<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         set: &'a mut DefIdSet,\n     }\n     impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n@@ -94,7 +94,7 @@ fn mir_keys<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_built<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n@@ -141,16 +141,11 @@ pub trait MirPass {\n         default_name::<Self>()\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    );\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n     mir_phase: MirPhase,\n@@ -197,7 +192,7 @@ pub fn run_passes(\n     }\n }\n \n-fn mir_const<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_const<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -211,7 +206,7 @@ fn mir_const<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'\n     tcx.alloc_steal_mir(body)\n }\n \n-fn mir_validated(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_validated(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n@@ -228,7 +223,7 @@ fn mir_validated(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tc\n     tcx.alloc_steal_mir(body)\n }\n \n-fn optimized_mir<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n+fn optimized_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const"}, {"sha": "841db80fc7dbb093c73fb34e827cb58d5765d613", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,12 +9,12 @@ use crate::transform::{MirPass, MirSource};\n pub struct NoLandingPads;\n \n impl MirPass for NoLandingPads {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         NoLandingPads.visit_body(body);\n     }"}, {"sha": "84d3f8f4c462b00ac2999e654e48f02255310441", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -148,7 +148,7 @@ pub fn collect_temps(body: &Body<'_>,\n }\n \n struct Promoter<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     source: &'a mut Body<'tcx>,\n     promoted: Body<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n \n pub fn promote_candidates<'tcx>(\n     body: &mut Body<'tcx>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n ) {"}, {"sha": "c9fac3bbe259645573726fa7d34bdd411d8ec82f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -124,7 +124,7 @@ impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n }\n \n struct ConstCx<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n     body: &'a Body<'tcx>,\n@@ -652,7 +652,7 @@ impl Deref for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n+    fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(body);\n         let temps = promote_consts::collect_temps(body, &mut rpo);\n@@ -1468,7 +1468,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> (u8, &'tcx BitSet<Local>) {\n+fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> (u8, &'tcx BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1486,7 +1486,7 @@ fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> (u8, &'tcx\n pub struct QualifyAndPromoteConstants;\n \n impl MirPass for QualifyAndPromoteConstants {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         if body.return_ty().references_error() {\n             tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");\n@@ -1659,7 +1659,7 @@ impl MirPass for QualifyAndPromoteConstants {\n     }\n }\n \n-fn args_required_const(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n+fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n     let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n     let mut ret = FxHashSet::default();"}, {"sha": "9781300966ab97a17e6010fabaea68df012156b5", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -8,7 +8,7 @@ use syntax_pos::Span;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n+pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n@@ -75,7 +75,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'t\n     Ok(())\n }\n \n-fn check_ty(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n+fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.sty {\n             ty::Ref(_, _, hir::Mutability::MutMutable) => return Err((\n@@ -120,7 +120,7 @@ fn check_ty(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId)\n }\n \n fn check_rvalue(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     rvalue: &Rvalue<'tcx>,\n     span: Span,\n@@ -200,7 +200,7 @@ fn check_rvalue(\n }\n \n fn check_statement(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     statement: &Statement<'tcx>,\n ) -> McfResult {\n@@ -270,7 +270,7 @@ fn check_place(\n }\n \n fn check_terminator(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n@@ -366,7 +366,7 @@ fn check_terminator(\n /// for being called from stable `const fn`s (`min_const_fn`).\n ///\n /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n-fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     match &tcx.item_name(def_id).as_str()[..] {\n         | \"size_of\"\n         | \"min_align_of\""}, {"sha": "7b3cdc835ebb1231307e6b974c93b73694ea986a", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use crate::util::patch::MirPatch;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n@@ -19,12 +19,7 @@ pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'\n }\n \n impl MirPass for RemoveNoopLandingPads {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }"}, {"sha": "c4601229653cf2999d3e4f861ec6cf338262a838", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -25,7 +25,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl MirPass for SanityCheck {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -84,7 +84,7 @@ impl MirPass for SanityCheck {\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n pub fn sanity_check_via_rustc_peek<'tcx, O>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     def_id: DefId,\n     _attributes: &[ast::Attribute],\n@@ -103,7 +103,7 @@ pub fn sanity_check_via_rustc_peek<'tcx, O>(\n }\n \n fn each_block<'tcx, O>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     results: &DataflowResults<'tcx, O>,\n     bb: mir::BasicBlock,\n@@ -218,7 +218,7 @@ fn each_block<'tcx, O>(\n }\n \n fn is_rustc_peek<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     terminator: &'a Option<mir::Terminator<'tcx>>,\n ) -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {"}, {"sha": "ac15f52d9ec5b17a60b48f391d5c6ea61e12032c", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -57,12 +57,7 @@ impl MirPass for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -298,7 +293,7 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl MirPass for SimplifyLocals {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };\n         marker.visit_body(body);\n         // Return pointer and arguments are always live"}, {"sha": "0c63a8d9c96b1ad2446fed71ec0178563c48f796", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -19,12 +19,7 @@ impl MirPass for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "90b52b76155db3497aed872ed889d5317748f5ba", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -37,12 +37,7 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl MirPass for UniformArrayMoveOut {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx};\n@@ -55,7 +50,7 @@ impl MirPass for UniformArrayMoveOut {\n struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n@@ -164,12 +159,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n pub struct RestoreSubsliceArrayMoveOut;\n \n impl MirPass for RestoreSubsliceArrayMoveOut {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = RestoreDataCollector {"}, {"sha": "6245d9c208b69339ee26a029bc33541360ce28cd", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::*;\n /// than its containing struct (because it is within a packed\n /// struct).\n pub fn is_disaligned<'tcx, L>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     local_decls: &L,\n     param_env: ty::ParamEnv<'tcx>,\n     place: &Place<'tcx>,\n@@ -34,7 +34,7 @@ where\n     }\n }\n \n-fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx, 'tcx>, local_decls: &L, place: &Place<'tcx>) -> bool\n+fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'tcx>) -> bool\n where\n     L: HasLocalDecls<'tcx>,\n {"}, {"sha": "f1aaa857dd3f3e6df354f2e84047294e16cb2856", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -788,7 +788,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     }\n }\n \n-impl BorrowckErrors<'tcx> for TyCtxt<'gcx, 'tcx> {\n+impl BorrowckErrors<'tcx> for TyCtxt<'tcx> {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         self,\n         sp: S,"}, {"sha": "0d7d6b4094ad48362efd944b1087e407d7703914", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -75,7 +75,7 @@ pub trait DropElaborator<'a, 'tcx: 'a>: fmt::Debug {\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n     fn body(&self) -> &'a Body<'tcx>;\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n@@ -126,7 +126,7 @@ where\n         place.ty(self.elaborator.body(), self.tcx()).ty\n     }\n \n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.elaborator.tcx()\n     }\n "}, {"sha": "7b154a9d46fa3c539e8e12c93dd1a451e49d0ce2", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -9,7 +9,7 @@ use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n pub fn write_mir_graphviz<'tcx, W>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     single: Option<DefId>,\n     w: &mut W,\n ) -> io::Result<()>\n@@ -35,7 +35,7 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n \n /// Write a graphviz DOT graph of the MIR.\n pub fn write_mir_fn_graphviz<'tcx, W>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     body: &Body<'_>,\n     w: &mut W,\n@@ -138,8 +138,8 @@ fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<'gcx, 'tcx, W: Write>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn write_graph_label<'tcx, W: Write>(\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     body: &Body<'_>,\n     w: &mut W,"}, {"sha": "cf0fc09472b6c520fc5c0805334e7a9189a6863a", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -255,7 +255,7 @@ fn block<'tcx>(\n }\n \n pub fn dump_mir<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n@@ -272,7 +272,7 @@ pub fn dump_mir<'tcx>(\n }\n \n fn dump_matched_mir_node<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n@@ -295,7 +295,7 @@ fn dump_matched_mir_node<'tcx>(\n }\n \n pub fn write_mir_fn<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     w: &mut dyn Write,"}, {"sha": "719029dbaac77bfdf339a2b161527f96e8ed03a6", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -21,10 +21,7 @@ pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-pub fn suggest_ref_mut<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    binding_span: Span,\n-) -> Option<(String)> {\n+pub fn suggest_ref_mut<'tcx>(tcx: TyCtxt<'tcx>, binding_span: Span) -> Option<(String)> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)"}, {"sha": "fc46adb702c8da389c94ea704884a039ec4700ac", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -62,8 +62,8 @@ pub enum PassWhere {\n ///   or `typeck` appears in the name.\n /// - `foo & nll | bar & typeck` == match if `foo` and `nll` both appear in the name\n ///   or `typeck` and `bar` both appear in the name.\n-pub fn dump_mir<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn dump_mir<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n@@ -93,11 +93,7 @@ pub fn dump_mir<'gcx, 'tcx, F>(\n     );\n }\n \n-pub fn dump_enabled<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    pass_name: &str,\n-    source: MirSource<'tcx>,\n-) -> bool {\n+pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, source: MirSource<'tcx>) -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return false,\n         Some(ref filters) => filters,\n@@ -117,8 +113,8 @@ pub fn dump_enabled<'gcx, 'tcx>(\n // `def_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn dump_matched_mir_node<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     node_path: &str,\n@@ -158,7 +154,7 @@ fn dump_matched_mir_node<'gcx, 'tcx, F>(\n /// Also used by other bits of code (e.g., NLL inference) that dump\n /// graphviz data or other things.\n fn dump_path(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     extension: &str,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n@@ -225,7 +221,7 @@ fn dump_path(\n /// bits of code (e.g., NLL inference) that dump graphviz data or\n /// other things, and hence takes the extension as an argument.\n pub(crate) fn create_dump_file(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     extension: &str,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n@@ -240,8 +236,8 @@ pub(crate) fn create_dump_file(\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn write_mir_pretty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     single: Option<DefId>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n@@ -279,8 +275,8 @@ pub fn write_mir_pretty<'gcx, 'tcx>(\n     Ok(())\n }\n \n-pub fn write_mir_fn<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn write_mir_fn<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n@@ -303,8 +299,8 @@ where\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn write_basic_block<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n     block: BasicBlock,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n@@ -370,13 +366,9 @@ where\n /// After we print the main statement, we sometimes dump extra\n /// information. There's often a lot of little things \"nuzzled up\" in\n /// a statement.\n-fn write_extra<'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    write: &mut dyn Write,\n-    mut visit_op: F,\n-) -> io::Result<()>\n+fn write_extra<'tcx, F>(tcx: TyCtxt<'tcx>, write: &mut dyn Write, mut visit_op: F) -> io::Result<()>\n where\n-    F: FnMut(&mut ExtraComments<'gcx, 'tcx>),\n+    F: FnMut(&mut ExtraComments<'tcx>),\n {\n     let mut extra_comments = ExtraComments {\n         _tcx: tcx,\n@@ -389,20 +381,20 @@ where\n     Ok(())\n }\n \n-struct ExtraComments<'gcx, 'tcx> {\n-    _tcx: TyCtxt<'gcx, 'tcx>, // don't need it now, but bet we will soon\n+struct ExtraComments<'tcx> {\n+    _tcx: TyCtxt<'tcx>, // don't need it now, but bet we will soon\n     comments: Vec<String>,\n }\n \n-impl ExtraComments<'gcx, 'tcx> {\n+impl ExtraComments<'tcx> {\n     fn push(&mut self, lines: &str) {\n         for line in lines.split('\\n') {\n             self.comments.push(line.to_string());\n         }\n     }\n }\n \n-impl Visitor<'tcx> for ExtraComments<'gcx, 'tcx> {\n+impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, ty, user_ty, literal } = constant;\n@@ -453,7 +445,7 @@ impl Visitor<'tcx> for ExtraComments<'gcx, 'tcx> {\n     }\n }\n \n-fn comment(tcx: TyCtxt<'_, '_>, SourceInfo { span, scope }: SourceInfo) -> String {\n+fn comment(tcx: TyCtxt<'_>, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\n         \"scope {} at {}\",\n         scope.index(),\n@@ -463,7 +455,7 @@ fn comment(tcx: TyCtxt<'_, '_>, SourceInfo { span, scope }: SourceInfo) -> Strin\n \n /// Prints local variables in a scope tree.\n fn write_scope_tree(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     body: &Body<'_>,\n     scope_tree: &FxHashMap<SourceScope, Vec<SourceScope>>,\n     w: &mut dyn Write,\n@@ -538,8 +530,8 @@ fn write_scope_tree(\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-pub fn write_mir_intro<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+pub fn write_mir_intro<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'_>,\n     w: &mut dyn Write,\n@@ -570,7 +562,7 @@ pub fn write_mir_intro<'gcx, 'tcx>(\n }\n \n fn write_mir_sig(\n-    tcx: TyCtxt<'_, '_>,\n+    tcx: TyCtxt<'_>,\n     src: MirSource<'tcx>,\n     body: &Body<'_>,\n     w: &mut dyn Write,\n@@ -642,7 +634,7 @@ fn write_user_type_annotations(body: &Body<'_>, w: &mut dyn Write) -> io::Result\n     Ok(())\n }\n \n-pub fn dump_mir_def_ids(tcx: TyCtxt<'_, '_>, single: Option<DefId>) -> Vec<DefId> {\n+pub fn dump_mir_def_ids(tcx: TyCtxt<'_>, single: Option<DefId>) -> Vec<DefId> {\n     if let Some(i) = single {\n         vec![i]\n     } else {"}, {"sha": "8f790d1328572d6e84be6deb59f83d785fe5f19f", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n use syntax::symbol::sym;\n \n-pub fn test_layout<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn test_layout<'tcx>(tcx: TyCtxt<'tcx>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n         tcx.hir()\n@@ -24,7 +24,7 @@ pub fn test_layout<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n struct VarianceTest<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n@@ -105,7 +105,7 @@ impl VarianceTest<'tcx> {\n }\n \n struct UnwrapLayoutCx<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n }\n \n@@ -119,7 +119,7 @@ impl LayoutOf for UnwrapLayoutCx<'tcx> {\n }\n \n impl HasTyCtxt<'tcx> for UnwrapLayoutCx<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "efa4bd65c0bcd073fc9d696785e0ee06c44728cc", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -45,7 +45,7 @@ struct CheckLoopVisitor<'a, 'hir: 'a> {\n     cx: Context,\n }\n \n-fn check_mod_loops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_loops<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckLoopVisitor {\n         sess: &tcx.sess,\n         hir_map: &tcx.hir(),"}, {"sha": "7230b69468126e2d4fc504e242312ef69a9f723d", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -39,7 +39,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     assert!(def_id.is_local());\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id)\n@@ -48,7 +48,7 @@ fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: D\n     tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n-fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ItemLocalSet {\n+fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ItemLocalSet {\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n         return tcx.rvalue_promotable_map(outer_def_id);\n@@ -75,7 +75,7 @@ fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     in_fn: bool,\n     in_static: bool,\n     mut_rvalue_borrows: HirIdSet,\n@@ -120,9 +120,9 @@ impl BitOr for Promotability {\n     }\n }\n \n-impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n+impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     // Returns true iff all the values of the type are promotable.\n-    fn type_promotability(&mut self, ty: Ty<'gcx>) -> Promotability {\n+    fn type_promotability(&mut self, ty: Ty<'tcx>) -> Promotability {\n         debug!(\"type_promotability({})\", ty);\n \n         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n@@ -593,7 +593,7 @@ fn check_adjustments<'a, 'tcx>(\n     Promotable\n }\n \n-impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: hir::HirId,\n                _consume_span: Span,"}, {"sha": "d3ac597160fd63464d54b568b6581c1f3548405a", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -30,11 +30,11 @@ impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n }\n \n /// Finds the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DefId> {\n+pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'tcx>) -> Option<DefId> {\n     tcx.plugin_registrar_fn(LOCAL_CRATE)\n }\n \n-fn plugin_registrar_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Option<DefId> {\n+fn plugin_registrar_fn<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = RegistrarFinder { registrars: Vec::new() };"}, {"sha": "c2cb2f4d1745e9b6a2f01d96b7c17c99d2cff729", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -49,7 +49,7 @@ mod error_codes;\n /// manually. Second, it doesn't visit some type components like signatures of fn types, or traits\n /// in `impl Trait`, see individual comments in `DefIdVisitorSkeleton::visit_ty`.\n trait DefIdVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n     fn shallow(&self) -> bool { false }\n     fn skip_assoc_tys(&self) -> bool { false }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n@@ -79,7 +79,7 @@ where\n {\n     def_id_visitor: &'v mut V,\n     visited_opaque_tys: FxHashSet<DefId>,\n-    dummy: PhantomData<TyCtxt<'tcx, 'tcx>>,\n+    dummy: PhantomData<TyCtxt<'tcx>>,\n }\n \n impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n@@ -224,7 +224,7 @@ where\n }\n \n fn def_id_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (ty::Visibility, Span, &'static str) {\n     match tcx.hir().as_local_hir_id(def_id) {\n@@ -329,19 +329,15 @@ fn def_id_visibility<'tcx>(\n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n fn item_tables<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     hir_id: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n ) -> &'a ty::TypeckTables<'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n-fn min<'tcx>(\n-    vis1: ty::Visibility,\n-    vis2: ty::Visibility,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-) -> ty::Visibility {\n+fn min<'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'tcx>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n \n@@ -352,7 +348,7 @@ fn min<'tcx>(\n /// in crates that have been updated to use pub(restricted).\n ////////////////////////////////////////////////////////////////////////////////\n struct PubRestrictedVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     has_pub_restricted: bool,\n }\n \n@@ -370,13 +366,13 @@ impl Visitor<'tcx> for PubRestrictedVisitor<'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     access_levels: &'a AccessLevels,\n     min: VL,\n }\n \n impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.tcx }\n     fn shallow(&self) -> bool { VL::SHALLOW }\n     fn skip_assoc_tys(&self) -> bool { true }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n@@ -394,7 +390,7 @@ trait VisibilityLike: Sized {\n     // associated types for which we can't determine visibility precisely.\n     fn of_impl<'a, 'tcx>(\n         hir_id: hir::HirId,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         access_levels: &'a AccessLevels,\n     ) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n@@ -438,7 +434,7 @@ impl VisibilityLike for Option<AccessLevel> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct EmbargoVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     // Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n@@ -830,7 +826,7 @@ impl ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n }\n \n impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.ev.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n             self.ev.update(hir_id, self.access_level);\n@@ -847,7 +843,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n //////////////////////////////////////////////////////////////////////////////////////\n \n struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n@@ -974,7 +970,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////////////////\n \n struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n     in_body: bool,\n@@ -1193,7 +1189,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n }\n \n impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         self.check_def_id(def_id, kind, descr)\n     }\n@@ -1207,7 +1203,7 @@ impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n@@ -1551,7 +1547,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct SearchInterfaceForPrivateItemsVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     item_id: hir::HirId,\n     item_def_id: DefId,\n     span: Span,\n@@ -1649,14 +1645,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n }\n \n impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         self.check_def_id(def_id, kind, descr)\n     }\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a HirIdSet,\n }\n@@ -1832,7 +1828,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n@@ -1859,7 +1855,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n-fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx AccessLevels {\n+fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx AccessLevels {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     // Build up a set of all exported items in the AST. This is a set of all\n@@ -1883,7 +1879,7 @@ fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tc\n     tcx.arena.alloc(visitor.access_levels)\n }\n \n-fn check_private_in_public<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) {\n+fn check_private_in_public<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "f9dd4436434f5a612895e5baee813c278f34e9b7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -77,7 +77,7 @@ macro_rules! access_from_vis {\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     dumper: &'ll mut JsonDumper<O>,\n \n     span: SpanUtils<'l>,"}, {"sha": "fb9f872880eaccac6f054fb787773e2fc03342e0", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -52,7 +52,7 @@ use log::{debug, error, info};\n \n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n     access_levels: &'l AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n@@ -1115,7 +1115,7 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n }\n \n pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     krate: &ast::Crate,\n     cratename: &str,\n     input: &'l Input,"}, {"sha": "2b678919ce41b0aba7cde4ae887a18c9000e7c3e", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 59, "deletions": 64, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -45,19 +45,19 @@ use std::marker::PhantomData;\n use self::unify::*;\n \n #[derive(Copy, Clone, Debug)]\n-crate struct ChalkArenas<'gcx> {\n-    _phantom: PhantomData<&'gcx ()>,\n+crate struct ChalkArenas<'tcx> {\n+    _phantom: PhantomData<&'tcx ()>,\n }\n \n #[derive(Copy, Clone)]\n-crate struct ChalkContext<'gcx> {\n-    _arenas: ChalkArenas<'gcx>,\n-    tcx: TyCtxt<'gcx, 'gcx>,\n+crate struct ChalkContext<'tcx> {\n+    _arenas: ChalkArenas<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n #[derive(Copy, Clone)]\n-crate struct ChalkInferenceContext<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+crate struct ChalkInferenceContext<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -126,12 +126,12 @@ impl context::Context for ChalkArenas<'tcx> {\n     }\n }\n \n-impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n+impl context::AggregateOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n     fn make_solution(\n         &self,\n-        root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        mut simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n-    ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n+        root_goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+        mut simplified_answers: impl context::AnswerStream<ChalkArenas<'tcx>>,\n+    ) -> Option<Canonical<'tcx, QueryResponse<'tcx, ()>>> {\n         use chalk_engine::SimplifiedAnswer;\n \n         debug!(\"make_solution(root_goal = {:?})\", root_goal);\n@@ -176,13 +176,10 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     }\n }\n \n-impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n+impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n     /// Returns `true` if this is a coinductive goal: basically proving that an auto trait\n     /// is implemented or proving that a trait reference is well-formed.\n-    fn is_coinductive(\n-        &self,\n-        goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>\n-    ) -> bool {\n+    fn is_coinductive(&self, goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>) -> bool {\n         use rustc::traits::{WellFormed, WhereClause};\n \n         let mut goal = goal.value.goal;\n@@ -216,8 +213,8 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     /// - the environment and goal found by substitution `S` into `arg`.\n     fn instantiate_ucanonical_goal<R>(\n         &self,\n-        arg: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'gcx>, Output = R>,\n+        arg: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+        op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'tcx>, Output = R>,\n     ) -> R {\n         self.tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, arg, |ref infcx, arg, subst| {\n             let chalk_infcx = &mut ChalkInferenceContext {\n@@ -230,8 +227,8 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     fn instantiate_ex_clause<R>(\n         &self,\n         _num_universes: usize,\n-        arg: &Canonical<'gcx, ChalkExClause<'gcx>>,\n-        op: impl context::WithInstantiatedExClause<ChalkArenas<'gcx>, Output = R>,\n+        arg: &Canonical<'tcx, ChalkExClause<'tcx>>,\n+        op: impl context::WithInstantiatedExClause<ChalkArenas<'tcx>, Output = R>,\n     ) -> R {\n         self.tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &arg.upcast(), |ref infcx, arg, _| {\n             let chalk_infcx = &mut ChalkInferenceContext {\n@@ -242,31 +239,31 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     }\n \n     /// Returns `true` if this solution has no region constraints.\n-    fn empty_constraints(ccs: &Canonical<'gcx, ConstrainedSubst<'gcx>>) -> bool {\n+    fn empty_constraints(ccs: &Canonical<'tcx, ConstrainedSubst<'tcx>>) -> bool {\n         ccs.value.constraints.is_empty()\n     }\n \n     fn inference_normalized_subst_from_ex_clause(\n-        canon_ex_clause: &'a Canonical<'gcx, ChalkExClause<'gcx>>,\n-    ) -> &'a CanonicalVarValues<'gcx> {\n+        canon_ex_clause: &'a Canonical<'tcx, ChalkExClause<'tcx>>,\n+    ) -> &'a CanonicalVarValues<'tcx> {\n         &canon_ex_clause.value.subst\n     }\n \n     fn inference_normalized_subst_from_subst(\n-        canon_subst: &'a Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> &'a CanonicalVarValues<'gcx> {\n+        canon_subst: &'a Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+    ) -> &'a CanonicalVarValues<'tcx> {\n         &canon_subst.value.subst\n     }\n \n     fn canonical(\n-        u_canon: &'a Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-    ) -> &'a Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>> {\n+        u_canon: &'a Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+    ) -> &'a Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>> {\n         u_canon\n     }\n \n     fn is_trivial_substitution(\n-        u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+        u_canon: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n     ) -> bool {\n         let subst = &canonical_subst.value.subst;\n         assert_eq!(u_canon.variables.len(), subst.var_values.len());\n@@ -297,7 +294,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n             })\n     }\n \n-    fn num_universes(canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>) -> usize {\n+    fn num_universes(canon: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>) -> usize {\n         canon.max_universe.index() + 1\n     }\n \n@@ -306,21 +303,21 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     /// but for the universes of universally quantified names.\n     fn map_goal_from_canonical(\n         _map: &UniverseMap,\n-        value: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-    ) -> Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>> {\n+        value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+    ) -> Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>> {\n         *value // FIXME universe maps not implemented yet\n     }\n \n     fn map_subst_from_canonical(\n         _map: &UniverseMap,\n-        value: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n+        value: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n         value.clone() // FIXME universe maps not implemented yet\n     }\n }\n \n-impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+impl context::InferenceTable<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'tcx>\n {\n     fn into_goal(&self, domain_goal: DomainGoal<'tcx>) -> Goal<'tcx> {\n         self.infcx.tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n@@ -363,8 +360,8 @@ impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+impl context::TruncateOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'tcx>\n {\n     fn truncate_goal(\n         &mut self,\n@@ -381,8 +378,8 @@ impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'tcx>\n {\n     fn program_clauses(\n         &self,\n@@ -418,35 +415,32 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     fn canonicalize_goal(\n         &mut self,\n         value: &InEnvironment<'tcx, Goal<'tcx>>,\n-    ) -> Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>> {\n+    ) -> Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>> {\n         let mut _orig_values = OriginalQueryValues::default();\n         self.infcx.canonicalize_query(value, &mut _orig_values)\n     }\n \n     fn canonicalize_ex_clause(\n         &mut self,\n         value: &ChalkExClause<'tcx>,\n-    ) -> Canonical<'gcx, ChalkExClause<'gcx>> {\n+    ) -> Canonical<'tcx, ChalkExClause<'tcx>> {\n         self.infcx.canonicalize_response(value)\n     }\n \n     fn canonicalize_constrained_subst(\n         &mut self,\n         subst: CanonicalVarValues<'tcx>,\n         constraints: Vec<RegionConstraint<'tcx>>,\n-    ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n+    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n         self.infcx.canonicalize_response(&ConstrainedSubst { subst, constraints })\n     }\n \n     fn u_canonicalize_goal(\n         &mut self,\n-        value: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-    ) -> (\n-        Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        UniverseMap,\n-    ) {\n+        value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+    ) -> (Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>, UniverseMap) {\n         (value.clone(), UniverseMap)\n-    }\n+}\n \n     fn invert_goal(\n         &mut self,\n@@ -470,15 +464,15 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn sink_answer_subset(\n         &self,\n-        value: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+        value: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n     ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n         value.clone()\n     }\n \n     fn lift_delayed_literal(\n         &self,\n         value: DelayedLiteral<ChalkArenas<'tcx>>,\n-    ) -> DelayedLiteral<ChalkArenas<'gcx>> {\n+    ) -> DelayedLiteral<ChalkArenas<'tcx>> {\n         match self.infcx.tcx.lift_to_global(&value) {\n             Some(literal) => literal,\n             None => bug!(\"cannot lift {:?}\", value),\n@@ -508,13 +502,13 @@ type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n \n type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;\n \n-impl Debug for ChalkContext<'gcx> {\n+impl Debug for ChalkContext<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"ChalkContext\")\n     }\n }\n \n-impl Debug for ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+impl Debug for ChalkInferenceContext<'cx, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"ChalkInferenceContext\")\n     }\n@@ -527,7 +521,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_ex_clause_to_tcx(\n         ex_clause: &ChalkExClause<'a>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Option<Self::LiftedExClause> {\n         Some(ChalkExClause {\n             subst: tcx.lift(&ex_clause.subst)?,\n@@ -539,7 +533,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_delayed_literal_to_tcx(\n         literal: &DelayedLiteral<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Option<Self::LiftedDelayedLiteral> {\n         Some(match literal {\n             DelayedLiteral::CannotProve(()) => DelayedLiteral::CannotProve(()),\n@@ -553,7 +547,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_literal_to_tcx(\n         literal: &Literal<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Option<Self::LiftedLiteral> {\n         Some(match literal {\n             Literal::Negative(goal) => Literal::Negative(tcx.lift(goal)?),\n@@ -563,7 +557,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n }\n \n impl ExClauseFold<'tcx> for ChalkArenas<'tcx> {\n-    fn fold_ex_clause_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(\n+    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n         ex_clause: &ChalkExClause<'tcx>,\n         folder: &mut F,\n     ) -> ChalkExClause<'tcx> {\n@@ -600,13 +594,13 @@ BraceStructLiftImpl! {\n     }\n }\n \n-trait Upcast<'tcx, 'gcx: 'tcx>: 'gcx {\n+trait Upcast<'tcx>: 'tcx {\n     type Upcasted: 'tcx;\n \n     fn upcast(&self) -> Self::Upcasted;\n }\n \n-impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for DelayedLiteral<ChalkArenas<'gcx>> {\n+impl<'tcx> Upcast<'tcx> for DelayedLiteral<ChalkArenas<'tcx>> {\n     type Upcasted = DelayedLiteral<ChalkArenas<'tcx>>;\n \n     fn upcast(&self) -> Self::Upcasted {\n@@ -621,7 +615,7 @@ impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for DelayedLiteral<ChalkArenas<'gcx>>\n     }\n }\n \n-impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for Literal<ChalkArenas<'gcx>> {\n+impl<'tcx> Upcast<'tcx> for Literal<ChalkArenas<'tcx>> {\n     type Upcasted = Literal<ChalkArenas<'tcx>>;\n \n     fn upcast(&self) -> Self::Upcasted {\n@@ -632,7 +626,7 @@ impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for Literal<ChalkArenas<'gcx>> {\n     }\n }\n \n-impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for ExClause<ChalkArenas<'gcx>> {\n+impl<'tcx> Upcast<'tcx> for ExClause<ChalkArenas<'tcx>> {\n     type Upcasted = ExClause<ChalkArenas<'tcx>>;\n \n     fn upcast(&self) -> Self::Upcasted {\n@@ -651,8 +645,9 @@ impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for ExClause<ChalkArenas<'gcx>> {\n     }\n }\n \n-impl<'tcx, 'gcx: 'tcx, T> Upcast<'tcx, 'gcx> for Canonical<'gcx, T>\n-    where T: Upcast<'tcx, 'gcx>\n+impl<'tcx, T> Upcast<'tcx> for Canonical<'tcx, T>\n+where\n+    T: Upcast<'tcx>,\n {\n     type Upcasted = Canonical<'tcx, T::Upcasted>;\n \n@@ -673,7 +668,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n crate fn evaluate_goal<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     goal: ChalkCanonicalGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {\n     use crate::lowering::Lower;"}, {"sha": "71e18d2b6f9499c7199df549adb1d5ea0861d1b1", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,7 +15,7 @@ use crate::generic_types;\n /// `Implemented(ty: Trait) :- Implemented(nested: Trait)...`\n /// where `Trait` is specified by `trait_def_id`.\n fn builtin_impl_clause(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     nested: &[Kind<'tcx>],\n     trait_def_id: DefId,\n@@ -43,7 +43,7 @@ fn builtin_impl_clause(\n }\n \n crate fn assemble_builtin_unsize_impls<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     unsize_def_id: DefId,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n@@ -119,7 +119,7 @@ crate fn assemble_builtin_unsize_impls<'tcx>(\n }\n \n crate fn assemble_builtin_sized_impls<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     sized_def_id: DefId,\n     ty: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>,\n@@ -223,7 +223,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n }\n \n crate fn assemble_builtin_copy_clone_impls<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n     ty: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>,"}, {"sha": "a49ca400f5a21014bf7e8b0b25819e91fe59f83a", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -19,7 +19,7 @@ use self::primitive::*;\n use self::builtin::*;\n \n fn assemble_clauses_from_impls<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n     clauses: &mut Vec<Clause<'tcx>>,\n ) {\n@@ -33,7 +33,7 @@ fn assemble_clauses_from_impls<'tcx>(\n }\n \n fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n     clauses: &mut Vec<Clause<'tcx>>,\n ) {\n@@ -48,7 +48,7 @@ fn assemble_clauses_from_assoc_ty_values<'tcx>(\n     });\n }\n \n-impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+impl ChalkInferenceContext<'cx, 'tcx> {\n     pub(super) fn program_clauses_impl(\n         &self,\n         environment: &Environment<'tcx>,"}, {"sha": "8e4b9da6de268304f7704321f67e80ea390ddffd", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,10 +15,7 @@ use crate::lowering::Lower;\n use crate::generic_types;\n use std::iter;\n \n-crate fn wf_clause_for_raw_ptr<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n-    mutbl: hir::Mutability,\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_raw_ptr<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n     let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n \n     let wf_clause = ProgramClause {\n@@ -33,7 +30,7 @@ crate fn wf_clause_for_raw_ptr<'tcx>(\n }\n \n crate fn wf_clause_for_fn_ptr<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     arity_and_output: usize,\n     variadic: bool,\n     unsafety: hir::Unsafety,\n@@ -53,7 +50,7 @@ crate fn wf_clause_for_fn_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, 'tcx>) -> Clauses<'tcx> {\n+crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'tcx>) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let slice_ty = tcx.mk_slice(ty);\n \n@@ -83,7 +80,7 @@ crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, 'tcx>) -> Clauses<'tcx> {\n }\n \n crate fn wf_clause_for_array<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     length: &'tcx ty::Const<'tcx>,\n ) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n@@ -114,7 +111,7 @@ crate fn wf_clause_for_array<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> Clauses<'tcx> {\n+crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'tcx>, arity: usize) -> Clauses<'tcx> {\n     let type_list = generic_types::type_list(tcx, arity);\n     let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n \n@@ -155,7 +152,7 @@ crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> Claus\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n+crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -179,7 +176,7 @@ crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability)\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_fn_def<'tcx>(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+crate fn wf_clause_for_fn_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     let fn_def = generic_types::fn_def(tcx, def_id);\n \n     let wf_clause = ProgramClause {"}, {"sha": "1e8b02659dc6a19c4342e13a5cc4cb341e267e54", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -25,16 +25,16 @@ use syntax_pos::DUMMY_SP;\n use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n use super::unify::*;\n \n-impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+impl context::ResolventOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'tcx>\n {\n     fn resolvent_clause(\n         &mut self,\n         environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n         subst: &CanonicalVarValues<'tcx>,\n         clause: &Clause<'tcx>,\n-    ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+    ) -> Fallible<Canonical<'tcx, ChalkExClause<'tcx>>> {\n         use chalk_engine::context::UnificationOps;\n \n         debug!(\"resolvent_clause(goal = {:?}, clause = {:?})\", goal, clause);\n@@ -106,8 +106,8 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         &mut self,\n         ex_clause: ChalkExClause<'tcx>,\n         selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n-        answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+        answer_table_goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n+        canonical_answer_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n     ) -> Fallible<ChalkExClause<'tcx>> {\n         debug!(\n             \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n@@ -139,15 +139,15 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-struct AnswerSubstitutor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct AnswerSubstitutor<'cx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n     environment: Environment<'tcx>,\n     answer_subst: CanonicalVarValues<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     ex_clause: ChalkExClause<'tcx>,\n }\n \n-impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+impl AnswerSubstitutor<'cx, 'tcx> {\n     fn unify_free_answer_var(\n         &mut self,\n         answer_var: ty::BoundVar,\n@@ -169,8 +169,8 @@ impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeRelation<'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "d66faa92336fe837b11c997bc8e8557d98dd3e18", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -10,12 +10,12 @@ crate struct UnificationResult<'tcx> {\n     crate constraints: Vec<super::RegionConstraint<'tcx>>,\n }\n \n-crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+crate fn unify<'me, 'tcx, T: Relate<'tcx>>(\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n     environment: Environment<'tcx>,\n     variance: ty::Variance,\n     a: &T,\n-    b: &T\n+    b: &T,\n ) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n     debug!(\"unify(\n         a = {:?},\n@@ -42,18 +42,15 @@ crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n     })\n }\n \n-struct ChalkTypeRelatingDelegate<'me, 'gcx: 'tcx, 'tcx: 'me> {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+struct ChalkTypeRelatingDelegate<'me, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n     environment: Environment<'tcx>,\n     goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n     constraints: Vec<super::RegionConstraint<'tcx>>,\n }\n \n-impl ChalkTypeRelatingDelegate<'me, 'gcx, 'tcx> {\n-    fn new(\n-        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n-        environment: Environment<'tcx>,\n-    ) -> Self {\n+impl ChalkTypeRelatingDelegate<'me, 'tcx> {\n+    fn new(infcx: &'me InferCtxt<'me, 'tcx>, environment: Environment<'tcx>) -> Self {\n         Self {\n             infcx,\n             environment,\n@@ -63,7 +60,7 @@ impl ChalkTypeRelatingDelegate<'me, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, '_, 'tcx> {\n+impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, 'tcx> {\n     fn create_next_universe(&mut self) -> ty::UniverseIndex {\n         self.infcx.create_next_universe()\n     }"}, {"sha": "3abd7e90cf10fbd111e1e78b9ed4007bf23a6f55", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -18,7 +18,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn dropck_outlives<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalTyGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n@@ -146,8 +146,8 @@ fn dropck_outlives<'tcx>(\n \n /// Returns a set of constraints that needs to be satisfied in\n /// order for `ty` to be valid for destruction.\n-fn dtorck_constraint_for_ty<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n+fn dtorck_constraint_for_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     span: Span,\n     for_ty: Ty<'tcx>,\n     depth: usize,\n@@ -280,7 +280,7 @@ fn dtorck_constraint_for_ty<'gcx, 'tcx>(\n \n /// Calculates the dtorck constraint for a type.\n crate fn adt_dtorck_constraint<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n     let def = tcx.adt_def(def_id);"}, {"sha": "360b6c25c36c0913946b42902f30a0a65bd8c855", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn evaluate_obligation<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n     tcx.infer_ctxt().enter_with_canonical("}, {"sha": "bd2ed94b18d594bbc3ad736a777682dc3d3b3972", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -6,23 +6,23 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n \n-crate fn bound(tcx: TyCtxt<'_, 'tcx>, index: u32) -> Ty<'tcx> {\n+crate fn bound(tcx: TyCtxt<'tcx>, index: u32) -> Ty<'tcx> {\n     let ty = ty::Bound(\n         ty::INNERMOST,\n         ty::BoundVar::from_u32(index).into()\n     );\n     tcx.mk_ty(ty)\n }\n \n-crate fn raw_ptr(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn raw_ptr(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     tcx.mk_ptr(ty::TypeAndMut {\n         ty: bound(tcx, 0),\n         mutbl,\n     })\n }\n \n crate fn fn_ptr(\n-    tcx: TyCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     arity_and_output: usize,\n     c_variadic: bool,\n     unsafety: hir::Unsafety,\n@@ -44,7 +44,7 @@ crate fn fn_ptr(\n     tcx.mk_fn_ptr(fn_sig)\n }\n \n-crate fn type_list(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n+crate fn type_list(tcx: TyCtxt<'tcx>, arity: usize) -> SubstsRef<'tcx> {\n     tcx.mk_substs(\n         (0..arity).into_iter()\n             .map(|i| ty::BoundVar::from(i))\n@@ -53,7 +53,7 @@ crate fn type_list(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n     )\n }\n \n-crate fn ref_ty(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn ref_ty(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -64,17 +64,17 @@ crate fn ref_ty(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     })\n }\n \n-crate fn fn_def(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn fn_def(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_ty(ty::FnDef(def_id, InternalSubsts::bound_vars_for_item(tcx, def_id)))\n }\n \n-crate fn closure(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn closure(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_closure(def_id, ty::ClosureSubsts {\n         substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n     })\n }\n \n-crate fn generator(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn generator(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_generator(def_id, ty::GeneratorSubsts {\n         substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n     }, hir::GeneratorMovability::Movable)"}, {"sha": "7f9ebdc79c27608f5000b0ad33151ba18432e71b", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -23,7 +23,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn implied_outlives_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     goal: CanonicalTyGoal<'tcx>,\n ) -> Result<\n     &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n@@ -37,9 +37,9 @@ fn implied_outlives_bounds<'tcx>(\n }\n \n fn compute_implied_outlives_bounds<'tcx>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>\n+    ty: Ty<'tcx>,\n ) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n     let tcx = infcx.tcx;\n "}, {"sha": "d1bad6b4d1ee21090a3448e7c7b74f05f8ab91c1", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,12 +12,12 @@ use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n \n struct ClauseVisitor<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     round: &'a mut FxHashSet<Clause<'tcx>>,\n }\n \n impl ClauseVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>, round: &'a mut FxHashSet<Clause<'tcx>>) -> Self {\n+    fn new(tcx: TyCtxt<'tcx>, round: &'a mut FxHashSet<Clause<'tcx>>) -> Self {\n         ClauseVisitor {\n             tcx,\n             round,\n@@ -128,7 +128,7 @@ impl ClauseVisitor<'a, 'tcx> {\n }\n \n crate fn program_clauses_for_env<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     environment: Environment<'tcx>,\n ) -> Clauses<'tcx> {\n     debug!(\"program_clauses_for_env(environment={:?})\", environment);\n@@ -160,7 +160,7 @@ crate fn program_clauses_for_env<'tcx>(\n     );\n }\n \n-crate fn environment<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n+crate fn environment<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Environment<'tcx> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n "}, {"sha": "2a6613101614d1e0077964e542d6a67c51921df5", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> IntoWellFormedGoal for DomainGoal<'tcx> {\n     }\n }\n \n-crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // FIXME(eddyb) this should only be using `def_kind`.\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::TypeNs(..) => match tcx.def_kind(def_id) {\n@@ -181,7 +181,7 @@ crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Cl\n     }\n }\n \n-fn program_clauses_for_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+fn program_clauses_for_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n \n     // Rule Implemented-From-Env (see rustc guide)\n@@ -294,7 +294,7 @@ fn program_clauses_for_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Cl\n     )\n }\n \n-fn program_clauses_for_impl(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+fn program_clauses_for_impl(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n         return List::empty();\n     }\n@@ -337,7 +337,7 @@ fn program_clauses_for_impl(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'\n     tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n }\n \n-pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // Rule WellFormed-Type\n     //\n     // `struct Ty<P1..Pn> where WC1, ..., WCm`\n@@ -412,7 +412,7 @@ pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId\n }\n \n pub fn program_clauses_for_associated_type_def<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule ProjectionEq-Placeholder\n@@ -550,7 +550,7 @@ pub fn program_clauses_for_associated_type_def<'tcx>(\n }\n \n pub fn program_clauses_for_associated_type_value<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule Normalize-From-Impl (see rustc guide)\n@@ -611,7 +611,7 @@ pub fn program_clauses_for_associated_type_value<'tcx>(\n     tcx.mk_clauses(iter::once(normalize_clause))\n }\n \n-pub fn dump_program_clauses<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n+pub fn dump_program_clauses<'tcx>(tcx: TyCtxt<'tcx>) {\n     if !tcx.features().rustc_attrs {\n         return;\n     }\n@@ -623,7 +623,7 @@ pub fn dump_program_clauses<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n struct ClauseDumper<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl ClauseDumper<'tcx> {"}, {"sha": "bfa1a80bb320fd248dc0ae807aff39d02cc57c8f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -12,7 +12,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn normalize_ty_after_erasing_regions<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Ty<'tcx> {\n     debug!(\"normalize_ty_after_erasing_regions(goal={:#?})\", goal);"}, {"sha": "7e0ca5b00183d9de971451c87bdd91e7798bec80", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -15,7 +15,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn normalize_projection_ty<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     goal: CanonicalProjectionGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n     debug!(\"normalize_provider(goal={:#?})\", goal);"}, {"sha": "dcbb0dffba8f29770679de4f020a1ee7217b6e5d", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -35,7 +35,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn type_op_ascribe_user_type<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -56,13 +56,13 @@ fn type_op_ascribe_user_type<'tcx>(\n         })\n }\n \n-struct AscribeUserTypeCx<'me, 'gcx: 'tcx, 'tcx: 'me> {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+struct AscribeUserTypeCx<'me, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n-impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n+impl AscribeUserTypeCx<'me, 'tcx> {\n     fn normalize<T>(&mut self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -94,7 +94,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         );\n     }\n \n-    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -167,7 +167,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n }\n \n fn type_op_eq<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -181,12 +181,12 @@ fn type_op_eq<'tcx>(\n }\n \n fn type_op_normalize<T>(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    infcx: &InferCtxt<'_, 'tcx>,\n     fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n ) -> Fallible<T>\n where\n-    T: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx>,\n+    T: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n {\n     let (param_env, Normalize { value }) = key.into_parts();\n     let Normalized { value, obligations } = infcx\n@@ -197,39 +197,39 @@ where\n }\n \n fn type_op_normalize_ty(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Ty<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_predicate(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Predicate<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, Predicate<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_fn_sig(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<FnSig<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, FnSig<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_poly_fn_sig(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<PolyFnSig<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, PolyFnSig<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_subtype<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -243,7 +243,7 @@ fn type_op_subtype<'tcx>(\n }\n \n fn type_op_prove_predicate<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()"}, {"sha": "c4d841ede07976c3bc66d1c97afe344cfeddf4cd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -40,8 +40,8 @@ use rustc_data_structures::fx::FxHashSet;\n #[derive(Debug)]\n pub struct PathSeg(pub DefId, pub usize);\n \n-pub trait AstConv<'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx>;\n+pub trait AstConv<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n@@ -115,7 +115,7 @@ enum GenericArgPosition {\n     MethodCall,\n }\n \n-impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n+impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(&self,\n         lifetime: &hir::Lifetime,\n         def: Option<&ty::GenericParamDef>)\n@@ -208,7 +208,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n     fn check_impl_trait(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         span: Span,\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n@@ -239,7 +239,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// Used specifically for function calls.\n     pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         span: Span,\n         def: &ty::Generics,\n         seg: &hir::PathSegment,\n@@ -271,7 +271,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// This is used both for datatypes and function calls.\n     fn check_generic_arg_count(\n-        tcx: TyCtxt<'_, '_>,\n+        tcx: TyCtxt<'_>,\n         span: Span,\n         def: &ty::Generics,\n         args: &hir::GenericArgs,\n@@ -462,7 +462,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n     pub fn create_substs_for_generic_args<'b>(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         parent_substs: &[Kind<'tcx>],\n         has_self: bool,\n@@ -1810,7 +1810,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         has_err\n     }\n \n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_, '_>, span: Span) {\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n         let mut err = struct_span_err!(tcx.sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n         err.span_label(span, \"associated type not allowed here\").emit();\n@@ -2415,14 +2415,14 @@ pub struct Bounds<'tcx> {\n     pub implicitly_sized: Option<Span>,\n }\n \n-impl<'gcx, 'tcx> Bounds<'tcx> {\n+impl<'tcx> Bounds<'tcx> {\n     /// Converts a bounds list into a flat set of predicates (like\n     /// where-clauses). Because some of our bounds listings (e.g.,\n     /// regions) don't include the self-type, you must supply the\n     /// self-type here (the `param_ty` parameter).\n     pub fn predicates(\n         &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         param_ty: Ty<'tcx>,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         // If it could be sized, and is, add the `Sized` predicate."}, {"sha": "9ffbbd384c6d59f2ebca88a5334ee586ae745d25", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -22,7 +22,7 @@ use std::cmp;\n \n use super::report_unexpected_variant_res;\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n     /// expression arm guard, and it points to the match discriminant to add context in type errors.\n     /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n@@ -41,7 +41,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     pub fn check_pat_walk(\n         &self,\n-        pat: &'gcx hir::Pat,\n+        pat: &'tcx hir::Pat,\n         mut expected: Ty<'tcx>,\n         mut def_bm: ty::BindingMode,\n         discrim_span: Option<Span>,\n@@ -613,9 +613,9 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     pub fn check_match(\n         &self,\n-        expr: &'gcx hir::Expr,\n-        discrim: &'gcx hir::Expr,\n-        arms: &'gcx [hir::Arm],\n+        expr: &'tcx hir::Expr,\n+        discrim: &'tcx hir::Expr,\n+        arms: &'tcx [hir::Arm],\n         expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n     ) -> Ty<'tcx> {\n@@ -769,7 +769,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n-    fn warn_arms_when_scrutinee_diverges(&self, arms: &'gcx [hir::Arm], source_if: bool) {\n+    fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm], source_if: bool) {\n         if self.diverges.get().always() {\n             let msg = if source_if { \"block in `if` expression\" } else { \"arm\" };\n             for arm in arms {\n@@ -782,8 +782,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     fn if_fallback_coercion(\n         &self,\n         span: Span,\n-        then_expr: &'gcx hir::Expr,\n-        coercion: &mut CoerceMany<'gcx, 'tcx, '_, rustc::hir::Arm>,\n+        then_expr: &'tcx hir::Expr,\n+        coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm>,\n     ) {\n         // If this `if` expr is the parent's function return expr,\n         // the cause of the type coercion is the return type, point at it. (#25228)\n@@ -839,8 +839,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     fn if_cause(\n         &self,\n         span: Span,\n-        then_expr: &'gcx hir::Expr,\n-        else_expr: &'gcx hir::Expr,\n+        then_expr: &'tcx hir::Expr,\n+        else_expr: &'tcx hir::Expr,\n         then_ty: Ty<'tcx>,\n         else_ty: Ty<'tcx>,\n     ) -> ObligationCause<'tcx> {\n@@ -941,8 +941,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     fn demand_discriminant_type(\n         &self,\n-        arms: &'gcx [hir::Arm],\n-        discrim: &'gcx hir::Expr,\n+        arms: &'tcx [hir::Arm],\n+        discrim: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         // Not entirely obvious: if matches may create ref bindings, we want to\n         // use the *precise* type of the discriminant, *not* some supertype, as\n@@ -1020,15 +1020,14 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     fn check_pat_struct(\n         &self,\n-        pat: &'gcx hir::Pat,\n+        pat: &'tcx hir::Pat,\n         qpath: &hir::QPath,\n-        fields: &'gcx [Spanned<hir::FieldPat>],\n+        fields: &'tcx [Spanned<hir::FieldPat>],\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n         discrim_span: Option<Span>,\n-    ) -> Ty<'tcx>\n-    {\n+    ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n         {\n@@ -1088,7 +1087,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         &self,\n         pat: &hir::Pat,\n         qpath: &hir::QPath,\n-        subpats: &'gcx [P<hir::Pat>],\n+        subpats: &'tcx [P<hir::Pat>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n@@ -1192,7 +1191,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         pat_id: hir::HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        fields: &'gcx [Spanned<hir::FieldPat>],\n+        fields: &'tcx [Spanned<hir::FieldPat>],\n         etc: bool,\n         def_bm: ty::BindingMode,\n     ) -> bool {"}, {"sha": "dc4969d7ad2db1c285bffd65d62f6c9d89502a70", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -20,8 +20,8 @@ enum AutoderefKind {\n     Overloaded,\n }\n \n-pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct Autoderef<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n@@ -31,10 +31,10 @@ pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     include_raw_pointers: bool,\n     span: Span,\n     silence_errors: bool,\n-    reached_recursion_limit: bool\n+    reached_recursion_limit: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n     type Item = (Ty<'tcx>, usize);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -85,14 +85,14 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               param_env: ty::ParamEnv<'tcx>,\n-               body_id: hir::HirId,\n-               span: Span,\n-               base_ty: Ty<'tcx>)\n-               -> Autoderef<'a, 'gcx, 'tcx>\n-    {\n+impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n+    pub fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+    ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             body_id,\n@@ -157,7 +157,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n     /// Returns the final type, generating an error if it is an\n     /// unresolved inference variable.\n-    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         fcx.structurally_resolved_type(self.span, self.cur_ty)\n     }\n \n@@ -172,13 +172,15 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, needs: Needs)\n-                        -> Vec<Adjustment<'tcx>> {\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs) -> Vec<Adjustment<'tcx>> {\n         fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n     }\n \n-    pub fn adjust_steps_as_infer_ok(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, needs: Needs)\n-                                    -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n+    pub fn adjust_steps_as_infer_ok(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        needs: Needs,\n+    ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n             .chain(iter::once(self.cur_ty));\n@@ -230,7 +232,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.reached_recursion_limit\n     }\n \n-    pub fn finalize(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+    pub fn finalize(self, fcx: &FnCtxt<'a, 'tcx>) {\n         fcx.register_predicates(self.into_obligations());\n     }\n \n@@ -239,11 +241,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn report_autoderef_recursion_limit_error<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    span: Span,\n-    ty: Ty<'tcx>,\n-) {\n+pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n     // We've reached the recursion limit, error gracefully.\n     let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n     let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\",\n@@ -264,8 +262,8 @@ pub fn report_autoderef_recursion_limit_error<'gcx, 'tcx>(\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n         Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n "}, {"sha": "0207f18ac81d541806c4ee294f4fc06cb671ea29", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called).\n-pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_, '_>, span: Span, trait_id: DefId) {\n+pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_>, span: Span, trait_id: DefId) {\n     if tcx.lang_items().drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, \"explicit destructor calls not allowed\")\n@@ -33,12 +33,12 @@ enum CallStep<'tcx> {\n     Overloaded(MethodCallee<'tcx>),\n }\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_call(\n         &self,\n-        call_expr: &'gcx hir::Expr,\n-        callee_expr: &'gcx hir::Expr,\n-        arg_exprs: &'gcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr,\n+        callee_expr: &'tcx hir::Expr,\n+        arg_exprs: &'tcx [hir::Expr],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n@@ -78,10 +78,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn try_overloaded_call_step(\n         &self,\n-        call_expr: &'gcx hir::Expr,\n-        callee_expr: &'gcx hir::Expr,\n-        arg_exprs: &'gcx [hir::Expr],\n-        autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n+        call_expr: &'tcx hir::Expr,\n+        callee_expr: &'tcx hir::Expr,\n+        arg_exprs: &'tcx [hir::Expr],\n+        autoderef: &Autoderef<'a, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n         debug!(\n@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         call_expr: &hir::Expr,\n         adjusted_ty: Ty<'tcx>,\n-        opt_arg_exprs: Option<&'gcx [hir::Expr]>,\n+        opt_arg_exprs: Option<&'tcx [hir::Expr]>,\n     ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in &[\n@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         call_expr: &hir::Expr,\n         callee_ty: Ty<'tcx>,\n-        arg_exprs: &'gcx [hir::Expr],\n+        arg_exprs: &'tcx [hir::Expr],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n@@ -440,7 +440,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn confirm_deferred_closure_call(\n         &self,\n         call_expr: &hir::Expr,\n-        arg_exprs: &'gcx [hir::Expr],\n+        arg_exprs: &'tcx [hir::Expr],\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -473,7 +473,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn confirm_overloaded_call(\n         &self,\n         call_expr: &hir::Expr,\n-        arg_exprs: &'gcx [hir::Expr],\n+        arg_exprs: &'tcx [hir::Expr],\n         expected: Expectation<'tcx>,\n         method_callee: MethodCallee<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -492,18 +492,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n #[derive(Debug)]\n-pub struct DeferredCallResolution<'gcx: 'tcx, 'tcx> {\n-    call_expr: &'gcx hir::Expr,\n-    callee_expr: &'gcx hir::Expr,\n+pub struct DeferredCallResolution<'tcx> {\n+    call_expr: &'tcx hir::Expr,\n+    callee_expr: &'tcx hir::Expr,\n     adjusted_ty: Ty<'tcx>,\n     adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n     closure_substs: ty::ClosureSubsts<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n-    pub fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+impl<'a, 'tcx> DeferredCallResolution<'tcx> {\n+    pub fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {:?}\", self);\n \n         // we should not be invoked until the closure kind has been"}, {"sha": "53101499af1dc283d82d8735fc04e73b8d59d3e7", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 51, "deletions": 44, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -74,7 +74,7 @@ enum PointerKind<'tcx> {\n     OfParam(&'tcx ty::ParamTy),\n }\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Returns the kind of unsize information of t, or None\n     /// if t is unknown.\n     fn pointer_kind(&self, t: Ty<'tcx>, span: Span) ->\n@@ -158,26 +158,28 @@ impl From<ErrorReported> for CastError {\n     }\n }\n \n-fn make_invalid_casting_error<'a, 'gcx, 'tcx>(sess: &'a Session,\n-                                              span: Span,\n-                                              expr_ty: Ty<'tcx>,\n-                                              cast_ty: Ty<'tcx>,\n-                                              fcx: &FnCtxt<'a, 'gcx, 'tcx>)\n-                                              -> DiagnosticBuilder<'a> {\n+fn make_invalid_casting_error<'a, 'tcx>(\n+    sess: &'a Session,\n+    span: Span,\n+    expr_ty: Ty<'tcx>,\n+    cast_ty: Ty<'tcx>,\n+    fcx: &FnCtxt<'a, 'tcx>,\n+) -> DiagnosticBuilder<'a> {\n     type_error_struct!(sess, span, expr_ty, E0606,\n                        \"casting `{}` as `{}` is invalid\",\n                        fcx.ty_to_string(expr_ty),\n                        fcx.ty_to_string(cast_ty))\n }\n \n-impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n-    pub fn new(fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-               expr: &'tcx hir::Expr,\n-               expr_ty: Ty<'tcx>,\n-               cast_ty: Ty<'tcx>,\n-               cast_span: Span,\n-               span: Span)\n-               -> Result<CastCheck<'tcx>, ErrorReported> {\n+impl<'a, 'tcx> CastCheck<'tcx> {\n+    pub fn new(\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        expr: &'tcx hir::Expr,\n+        expr_ty: Ty<'tcx>,\n+        cast_ty: Ty<'tcx>,\n+        cast_span: Span,\n+        span: Span,\n+    ) -> Result<CastCheck<'tcx>, ErrorReported> {\n         let check = CastCheck {\n             expr,\n             expr_ty,\n@@ -198,7 +200,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, e: CastError) {\n+    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'tcx>, e: CastError) {\n         match e {\n             CastError::ErrorReported => {\n                 // an error has already been reported\n@@ -326,7 +328,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         if self.cast_ty.references_error() || self.expr_ty.references_error() {\n             return;\n         }\n@@ -386,7 +388,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         err.emit();\n     }\n \n-    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         let type_asc_or = if fcx.tcx.features().type_ascription {\n@@ -412,7 +414,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         err.emit();\n     }\n \n-    pub fn check(mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+    pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n         self.expr_ty = fcx.structurally_resolved_type(self.span, self.expr_ty);\n         self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n@@ -443,7 +445,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     /// Checks a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n-    fn do_check(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Result<CastKind, CastError> {\n+    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n         use rustc::ty::cast::IntTy::*;\n         use rustc::ty::cast::CastTy::*;\n \n@@ -531,11 +533,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ptr_ptr_cast(&self,\n-                          fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                          m_expr: ty::TypeAndMut<'tcx>,\n-                          m_cast: ty::TypeAndMut<'tcx>)\n-                          -> Result<CastKind, CastError> {\n+    fn check_ptr_ptr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_expr: ty::TypeAndMut<'tcx>,\n+        m_cast: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\", m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n \n@@ -572,10 +575,11 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_fptr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_cast: ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError> {\n+    fn check_fptr_ptr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_cast: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // fptr-ptr cast. must be to thin ptr\n \n         match fcx.pointer_kind(m_cast.ty, self.span)? {\n@@ -585,10 +589,11 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ptr_addr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_expr: ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError> {\n+    fn check_ptr_addr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_expr: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // ptr-addr cast. must be from thin ptr\n \n         match fcx.pointer_kind(m_expr.ty, self.span)? {\n@@ -598,11 +603,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ref_cast(&self,\n-                      fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                      m_expr: ty::TypeAndMut<'tcx>,\n-                      m_cast: ty::TypeAndMut<'tcx>)\n-                      -> Result<CastKind, CastError> {\n+    fn check_ref_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_expr: ty::TypeAndMut<'tcx>,\n+        m_cast: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n@@ -623,10 +629,11 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         Err(CastError::IllegalCast)\n     }\n \n-    fn check_addr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_cast: TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError> {\n+    fn check_addr_ptr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_cast: TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // ptr-addr cast. pointer must be thin.\n         match fcx.pointer_kind(m_cast.ty, self.span)? {\n             None => Err(CastError::UnknownCastPtrKind),\n@@ -635,12 +642,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n         fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, AllowTwoPhase::No).is_ok()\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn type_is_known_to_be_sized_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         traits::type_known_to_meet_bound_modulo_regions(self, self.param_env, ty, lang_item, span)"}, {"sha": "6c0deededdc738b2513719c102d25f4dc10f6024", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -32,12 +32,12 @@ struct ClosureSignatures<'tcx> {\n     liberated_sig: ty::FnSig<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_expr_closure(\n         &self,\n         expr: &hir::Expr,\n         _capture: hir::CaptureClause,\n-        decl: &'gcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl,\n         body_id: hir::BodyId,\n         gen: Option<hir::GeneratorMovability>,\n         expected: Expectation<'tcx>,\n@@ -62,8 +62,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         expr: &hir::Expr,\n         opt_kind: Option<ty::ClosureKind>,\n-        decl: &'gcx hir::FnDecl,\n-        body: &'gcx hir::Body,\n+        decl: &'tcx hir::FnDecl,\n+        body: &'tcx hir::Body,\n         gen: Option<hir::GeneratorMovability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n@@ -592,7 +592,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n     ) -> ty::PolyFnSig<'tcx> {\n-        let astconv: &dyn AstConv<'_, '_> = self;\n+        let astconv: &dyn AstConv<'_> = self;\n \n         // First, convert the types that the user supplied (if any).\n         let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n@@ -624,7 +624,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n     fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n-        let astconv: &dyn AstConv<'_, '_> = self;\n+        let astconv: &dyn AstConv<'_> = self;\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them."}, {"sha": "a56196ccf82f54fac76de40b5b537f0d45f6cd5b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -71,8 +71,8 @@ use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos;\n \n-struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+struct Coerce<'a, 'tcx> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n     /// Determines whether or not allow_two_phase_borrow is set on any\n@@ -84,8 +84,8 @@ struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     allow_two_phase: AllowTwoPhase,\n }\n \n-impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n-    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n+impl<'a, 'tcx> Deref for Coerce<'a, 'tcx> {\n+    type Target = FnCtxt<'a, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n         &self.fcx\n     }\n@@ -120,10 +120,12 @@ fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n     })\n }\n \n-impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>,\n-           cause: ObligationCause<'tcx>,\n-           allow_two_phase: AllowTwoPhase) -> Self {\n+impl<'f, 'tcx> Coerce<'f, 'tcx> {\n+    fn new(\n+        fcx: &'f FnCtxt<'f, 'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        allow_two_phase: AllowTwoPhase,\n+    ) -> Self {\n         Coerce {\n             fcx,\n             cause,\n@@ -792,7 +794,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Attempt to coerce an expression to a type, and return the\n     /// adjusted type of the expression, if successful.\n     /// Adjustments are only recorded if the coercion succeeded.\n@@ -1004,29 +1006,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n /// }\n /// let final_ty = coerce.complete(fcx);\n /// ```\n-pub struct CoerceMany<'gcx, 'tcx, 'exprs, E>\n-    where 'gcx: 'tcx, E: 'exprs + AsCoercionSite,\n-{\n+pub struct CoerceMany<'tcx, 'exprs, E: AsCoercionSite> {\n     expected_ty: Ty<'tcx>,\n     final_ty: Option<Ty<'tcx>>,\n-    expressions: Expressions<'gcx, 'exprs, E>,\n+    expressions: Expressions<'tcx, 'exprs, E>,\n     pushed: usize,\n }\n \n /// The type of a `CoerceMany` that is storing up the expressions into\n /// a buffer. We use this in `check/mod.rs` for things like `break`.\n-pub type DynamicCoerceMany<'gcx, 'tcx> = CoerceMany<'gcx, 'tcx, 'gcx, P<hir::Expr>>;\n+pub type DynamicCoerceMany<'tcx> = CoerceMany<'tcx, 'tcx, P<hir::Expr>>;\n \n-enum Expressions<'gcx, 'exprs, E>\n-    where E: 'exprs + AsCoercionSite,\n-{\n-    Dynamic(Vec<&'gcx hir::Expr>),\n+enum Expressions<'tcx, 'exprs, E: AsCoercionSite> {\n+    Dynamic(Vec<&'tcx hir::Expr>),\n     UpFront(&'exprs [E]),\n }\n \n-impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n-    where 'gcx: 'tcx, E: 'exprs + AsCoercionSite,\n-{\n+impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// The usual case; collect the set of expressions dynamically.\n     /// If the full set of coercion sites is known before hand,\n     /// consider `with_coercion_sites()` instead to avoid allocation.\n@@ -1045,7 +1041,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         Self::make(expected_ty, Expressions::UpFront(coercion_sites))\n     }\n \n-    fn make(expected_ty: Ty<'tcx>, expressions: Expressions<'gcx, 'exprs, E>) -> Self {\n+    fn make(expected_ty: Ty<'tcx>, expressions: Expressions<'tcx, 'exprs, E>) -> Self {\n         CoerceMany {\n             expected_ty,\n             final_ty: None,\n@@ -1079,12 +1075,13 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     /// could coerce from. This will record `expression`, and later\n     /// calls to `coerce` may come back and add adjustments and things\n     /// if necessary.\n-    pub fn coerce<'a>(&mut self,\n-                      fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                      cause: &ObligationCause<'tcx>,\n-                      expression: &'gcx hir::Expr,\n-                      expression_ty: Ty<'tcx>)\n-    {\n+    pub fn coerce<'a>(\n+        &mut self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        expression: &'tcx hir::Expr,\n+        expression_ty: Ty<'tcx>,\n+    ) {\n         self.coerce_inner(fcx,\n                           cause,\n                           Some(expression),\n@@ -1104,12 +1101,13 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     /// The `augment_error` gives you a chance to extend the error\n     /// message, in case any results (e.g., we use this to suggest\n     /// removing a `;`).\n-    pub fn coerce_forced_unit<'a>(&mut self,\n-                                  fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                                  cause: &ObligationCause<'tcx>,\n-                                  augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n-                                  label_unit_as_expected: bool)\n-    {\n+    pub fn coerce_forced_unit<'a>(\n+        &mut self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n+        label_unit_as_expected: bool,\n+    ) {\n         self.coerce_inner(fcx,\n                           cause,\n                           None,\n@@ -1121,14 +1119,15 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     /// The inner coercion \"engine\". If `expression` is `None`, this\n     /// is a forced-unit case, and hence `expression_ty` must be\n     /// `Nil`.\n-    fn coerce_inner<'a>(&mut self,\n-                        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                        cause: &ObligationCause<'tcx>,\n-                        expression: Option<&'gcx hir::Expr>,\n-                        mut expression_ty: Ty<'tcx>,\n-                        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n-                        label_expression_as_expected: bool)\n-    {\n+    fn coerce_inner<'a>(\n+        &mut self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        expression: Option<&'tcx hir::Expr>,\n+        mut expression_ty: Ty<'tcx>,\n+        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n+        label_expression_as_expected: bool,\n+    ) {\n         // Incorporate whatever type inference information we have\n         // until now; in principle we might also want to process\n         // pending obligations, but doing so should only improve\n@@ -1270,9 +1269,9 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         err: TypeError<'tcx>,\n-        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+        fcx: &FnCtxt<'a, 'tcx>,\n         id: hir::HirId,\n-        expression: Option<(&'gcx hir::Expr, hir::HirId)>,\n+        expression: Option<(&'tcx hir::Expr, hir::HirId)>,\n     ) -> DiagnosticBuilder<'a> {\n         let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n \n@@ -1317,7 +1316,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         db\n     }\n \n-    pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty\n         } else {"}, {"sha": "088ac0e8ba6c8745920df176790d2c25ecc5449f", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -24,7 +24,7 @@ use super::{Inherited, FnCtxt, potentially_plural_count};\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n \n pub fn compare_impl_method<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n@@ -76,7 +76,7 @@ pub fn compare_impl_method<'tcx>(\n }\n \n fn compare_predicate_entailment<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n@@ -359,7 +359,7 @@ fn compare_predicate_entailment<'tcx>(\n }\n \n fn check_region_bounds_on_impl_method<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     span: Span,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n@@ -410,15 +410,16 @@ fn check_region_bounds_on_impl_method<'tcx>(\n     Ok(())\n }\n \n-fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n-                                                     param_env: ty::ParamEnv<'tcx>,\n-                                                     terr: &TypeError<'_>,\n-                                                     cause: &ObligationCause<'tcx>,\n-                                                     impl_m: &ty::AssocItem,\n-                                                     impl_sig: ty::FnSig<'tcx>,\n-                                                     trait_m: &ty::AssocItem,\n-                                                     trait_sig: ty::FnSig<'tcx>)\n-                                                     -> (Span, Option<Span>) {\n+fn extract_spans_for_error_reporting<'a, 'tcx>(\n+    infcx: &infer::InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    terr: &TypeError<'_>,\n+    cause: &ObligationCause<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_sig: ty::FnSig<'tcx>,\n+    trait_m: &ty::AssocItem,\n+    trait_sig: ty::FnSig<'tcx>,\n+) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n     let (impl_m_output, impl_m_iter) = match tcx.hir()\n@@ -500,7 +501,7 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n }\n \n fn compare_self_type<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n@@ -585,7 +586,7 @@ fn compare_self_type<'tcx>(\n }\n \n fn compare_number_of_generics<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n     _impl_span: Span,\n     trait_: &ty::AssocItem,\n@@ -700,7 +701,7 @@ fn compare_number_of_generics<'tcx>(\n }\n \n fn compare_number_of_method_arguments<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n@@ -785,7 +786,7 @@ fn compare_number_of_method_arguments<'tcx>(\n }\n \n fn compare_synthetic_generics<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n ) -> Result<(), ErrorReported> {\n@@ -958,7 +959,7 @@ fn compare_synthetic_generics<'tcx>(\n }\n \n pub fn compare_const_impl<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl_c: &ty::AssocItem,\n     impl_c_span: Span,\n     trait_c: &ty::AssocItem,"}, {"sha": "69a3f090b0a8de5f627a5be939ca2909215fc85f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "patch": "@@ -14,7 +14,7 @@ use errors::{Applicability, DiagnosticBuilder};\n \n use super::method::probe;\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {"}]}