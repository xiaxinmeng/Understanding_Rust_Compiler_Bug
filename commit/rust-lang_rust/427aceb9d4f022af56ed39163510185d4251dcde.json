{"sha": "427aceb9d4f022af56ed39163510185d4251dcde", "node_id": "C_kwDOAAsO6NoAKDQyN2FjZWI5ZDRmMDIyYWY1NmVkMzkxNjM1MTAxODVkNDI1MWRjZGU", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-13T18:52:41Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-14T13:20:39Z"}, "message": "Improve heuristics for format_args literal being suggestable\n\nSometimes, we want to create subspans and point at code in the literal\nif possible. But this doesn't always make sense, sometimes the literal\nmay come from macro expanded code and isn't actually there in the\nsource. Then, we can't really make these suggestions.\n\nThis now makes sure that the literal is actually there as we see it so\nthat we will not run into ICEs on weird literal transformations.", "tree": {"sha": "94b9ebdb780de04b194bfb7cd44474b8a343b272", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94b9ebdb780de04b194bfb7cd44474b8a343b272"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/427aceb9d4f022af56ed39163510185d4251dcde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/427aceb9d4f022af56ed39163510185d4251dcde", "html_url": "https://github.com/rust-lang/rust/commit/427aceb9d4f022af56ed39163510185d4251dcde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/427aceb9d4f022af56ed39163510185d4251dcde/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "729185338f1726f60ea2dc282fe6bbf0eb84cb17", "url": "https://api.github.com/repos/rust-lang/rust/commits/729185338f1726f60ea2dc282fe6bbf0eb84cb17", "html_url": "https://github.com/rust-lang/rust/commit/729185338f1726f60ea2dc282fe6bbf0eb84cb17"}], "stats": {"total": 36, "additions": 35, "deletions": 1}, "files": [{"sha": "1c5410c5658c61d91e4add7c7e1ea4e66b7cc30c", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/427aceb9d4f022af56ed39163510185d4251dcde/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/427aceb9d4f022af56ed39163510185d4251dcde/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=427aceb9d4f022af56ed39163510185d4251dcde", "patch": "@@ -14,6 +14,7 @@\n // We want to be able to build this crate with a stable compiler, so no\n // `#![feature]` attributes should be added.\n \n+use rustc_lexer::unescape;\n pub use Alignment::*;\n pub use Count::*;\n pub use Piece::*;\n@@ -324,7 +325,7 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let input_string_kind = find_width_map_from_snippet(snippet, style);\n+        let input_string_kind = find_width_map_from_snippet(s, snippet, style);\n         let (width_map, is_source_literal) = match input_string_kind {\n             InputStringKind::Literal { width_mappings } => (width_mappings, true),\n             InputStringKind::NotALiteral => (Vec::new(), false),\n@@ -892,6 +893,7 @@ impl<'a> Parser<'a> {\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n /// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n fn find_width_map_from_snippet(\n+    input: &str,\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n ) -> InputStringKind {\n@@ -904,8 +906,27 @@ fn find_width_map_from_snippet(\n         return InputStringKind::Literal { width_mappings: Vec::new() };\n     }\n \n+    // Strip quotes.\n     let snippet = &snippet[1..snippet.len() - 1];\n \n+    // Macros like `println` add a newline at the end. That technically doens't make them \"literals\" anymore, but it's fine\n+    // since we will never need to point our spans there, so we lie about it here by ignoring it.\n+    // Since there might actually be newlines in the source code, we need to normalize away all trailing newlines.\n+    // If we only trimmed it off the input, `format!(\"\\n\")` would cause a mismatch as here we they actually match up.\n+    // Alternatively, we could just count the trailing newlines and only trim one from the input if they don't match up.\n+    let input_no_nl = input.trim_end_matches('\\n');\n+    let Some(unescaped) = unescape_string(snippet) else {\n+        return InputStringKind::NotALiteral;\n+    };\n+\n+    let unescaped_no_nl = unescaped.trim_end_matches('\\n');\n+\n+    if unescaped_no_nl != input_no_nl {\n+        // The source string that we're pointing at isn't our input, so spans pointing at it will be incorrect.\n+        // This can for example happen with proc macros that respan generated literals.\n+        return InputStringKind::NotALiteral;\n+    }\n+\n     let mut s = snippet.char_indices();\n     let mut width_mappings = vec![];\n     while let Some((pos, c)) = s.next() {\n@@ -988,6 +1009,19 @@ fn find_width_map_from_snippet(\n     InputStringKind::Literal { width_mappings }\n }\n \n+fn unescape_string(string: &str) -> Option<string::String> {\n+    let mut buf = string::String::new();\n+    let mut ok = true;\n+    unescape::unescape_literal(string, unescape::Mode::Str, &mut |_, unescaped_char| {\n+        match unescaped_char {\n+            Ok(c) => buf.push(c),\n+            Err(_) => ok = false,\n+        }\n+    });\n+\n+    ok.then_some(buf)\n+}\n+\n // Assert a reasonable size for `Piece`\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Piece<'_>, 16);"}]}