{"sha": "922ed6f9473e2de0be716ce0116a1d5c91895c0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMmVkNmY5NDczZTJkZTBiZTcxNmNlMDExNmExZDVjOTE4OTVjMGI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-29T22:11:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:49Z"}, "message": "hello world test for a tcp server in libuv\n\n.. im now going to refactor the tcp request and server tests to utilize\neach other, so no more external network ugliness", "tree": {"sha": "aef16849e74b22f583ab3e0d8b6987113b225197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef16849e74b22f583ab3e0d8b6987113b225197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/922ed6f9473e2de0be716ce0116a1d5c91895c0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/922ed6f9473e2de0be716ce0116a1d5c91895c0b", "html_url": "https://github.com/rust-lang/rust/commit/922ed6f9473e2de0be716ce0116a1d5c91895c0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/922ed6f9473e2de0be716ce0116a1d5c91895c0b/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85e26eff6a7829dbe7db20fda350c5794c4bdc2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e26eff6a7829dbe7db20fda350c5794c4bdc2c", "html_url": "https://github.com/rust-lang/rust/commit/85e26eff6a7829dbe7db20fda350c5794c4bdc2c"}], "stats": {"total": 296, "additions": 257, "deletions": 39}, "files": [{"sha": "6c56871a771d17adc8dc74f98b9befe063a44eac", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 203, "deletions": 12, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/922ed6f9473e2de0be716ce0116a1d5c91895c0b/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/922ed6f9473e2de0be716ce0116a1d5c91895c0b/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=922ed6f9473e2de0be716ce0116a1d5c91895c0b", "patch": "@@ -218,7 +218,6 @@ fn gen_stub_uv_connect_t() -> uv_connect_t {\n     };\n }\n \n-// ref #1402 .. don't use this, like sockaddr_in\n // unix size: 16\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n@@ -310,8 +309,9 @@ native mod rustrt {\n     fn rust_uv_stop_op_cb(handle: *libc::c_void);\n     fn rust_uv_run(loop_handle: *libc::c_void);\n     fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n-    fn rust_uv_close_async(handle: *libc::c_void);\n-    fn rust_uv_close_timer(handle: *libc::c_void);\n+    fn rust_uv_hilvl_close(handle: *libc::c_void, cb: *u8);\n+    fn rust_uv_hilvl_close_async(handle: *libc::c_void);\n+    fn rust_uv_hilvl_close_timer(handle: *libc::c_void);\n     fn rust_uv_async_send(handle: *libc::c_void);\n     fn rust_uv_async_init(\n         loop_handle: *libc::c_void,\n@@ -338,10 +338,18 @@ native mod rustrt {\n         -> bool;\n     fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n         -> sockaddr_in;\n+    // FIXME ref #2064\n     fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n                            tcp_handle_ptr: *uv_tcp_t,\n                            ++after_cb: *u8,\n                            ++addr: *sockaddr_in) -> libc::c_int;\n+    // FIXME ref 2064\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n+                        ++addr: *sockaddr_in) -> libc::c_int;\n+    fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,\n+                      cb: *u8) -> libc::c_int;\n+    fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n+        -> libc::c_int;\n     fn rust_uv_write(req: *libc::c_void, stream: *libc::c_void,\n              ++buf_in: *uv_buf_t, buf_cnt: libc::c_int,\n              cb: *u8) -> libc::c_int;\n@@ -403,6 +411,7 @@ mod direct {\n         -> libc::c_int {\n         ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n     }\n+    // FIXME ref #2064\n     unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                           tcp_handle_ptr: *uv_tcp_t,\n                           addr_ptr: *sockaddr_in,\n@@ -414,10 +423,23 @@ mod direct {\n         ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n     }\n+    // FIXME ref #2064\n+    unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n+                       addr_ptr: *sockaddr_in) -> libc::c_int {\n+        ret rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n+                                     addr_ptr);\n+    }\n+\n+    unsafe fn listen(stream: *libc::c_void, backlog: libc::c_int,\n+                     cb: *u8) -> libc::c_int {\n+        ret rustrt::rust_uv_listen(stream, backlog, cb);\n+    }\n+\n+    unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n+        -> libc::c_int {\n+        ret rustrt::rust_uv_accept(server, client);\n+    }\n \n-    // TODO github #1402 -- the buf_in is a vector of pointers\n-    // to malloc'd buffers .. these will have to be translated\n-    // back into their value types in c. sigh.\n     unsafe fn write(req: *libc::c_void, stream: *libc::c_void,\n              buf_in: *[uv_buf_t], cb: *u8) -> libc::c_int {\n         let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n@@ -944,12 +966,12 @@ fn handle_op_close(handle: uv_handle, handle_ptr: *libc::c_void) {\n     alt handle {\n       uv_async(id, lp) {\n         let cb = process_close_async;\n-        rustrt::rust_uv_close(\n+        rustrt::rust_uv_hilvl_close(\n             handle_ptr, cb);\n       }\n       uv_timer(id, lp) {\n         let cb = process_close_timer;\n-        rustrt::rust_uv_close(\n+        rustrt::rust_uv_hilvl_close(\n             handle_ptr, cb);\n       }\n       _ {\n@@ -988,7 +1010,7 @@ crust fn process_close_async(\n     data: *uv_loop_data)\n     unsafe {\n     let id = get_handle_id_from(id_buf);\n-    rustrt::rust_uv_close_async(handle_ptr);\n+    rustrt::rust_uv_hilvl_close_async(handle_ptr);\n     // at this point, the handle and its data has been\n     // released. notify the rust loop to remove the\n     // handle and its data and call the user-supplied\n@@ -1002,7 +1024,7 @@ crust fn process_close_timer(\n     data: *uv_loop_data)\n     unsafe {\n     let id = get_handle_id_from(id_buf);\n-    rustrt::rust_uv_close_timer(handle_ptr);\n+    rustrt::rust_uv_hilvl_close_timer(handle_ptr);\n     process_close_common(id, data);\n }\n \n@@ -1187,11 +1209,10 @@ fn impl_uv_tcp_request() unsafe {\n \n         io::println(\"building addr...\");\n         let addr = direct::ip4_addr(\"74.125.227.16\", 80);\n+        // FIXME ref #2064\n         let addr_ptr = ptr::addr_of(addr);\n         io::println(#fmt(\"after build addr in rust. port: %u\",\n                          addr.sin_port as uint));\n-        //let addr: *libc::c_void = ptr::addr_of(addr_val) as\n-        //                            *libc::c_void;\n \n         // this should set up the connection request..\n         io::println(#fmt(\"before calling tcp_connect .. connect cb ptr: %u \",\n@@ -1265,6 +1286,176 @@ fn test_uv_tcp_request() unsafe {\n }\n // END TCP REQUEST TEST SUITE\n \n+crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n+    io::println(\"server stream closed, should exit loop...\");\n+}\n+\n+crust fn client_stream_after_close_cb(handle: *libc::c_void)\n+    unsafe {\n+    io::println(\"closed client stream, now server..\");\n+    let client_data = direct::get_data_for_uv_handle(\n+        handle) as\n+        *tcp_server_data;\n+    direct::close((*client_data).server as *libc::c_void,\n+                  server_after_close_cb);\n+}\n+\n+crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n+                           nread: libc::ssize_t,\n+                           ++buf: uv_buf_t) unsafe {\n+    if (nread > 0) {\n+        // we have data\n+        io::println(#fmt(\"read: data! nread: %d\", nread));\n+        \n+        // pull out the contents of the write from the client\n+        let buf_base = direct::get_base_from_buf(buf);\n+        let buf_len = direct::get_len_from_buf(buf);\n+        let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+        let request_str = str::from_bytes(bytes);\n+        io::println(\"client req to follow\");\n+        io::println(request_str);\n+        io::println(\"end of client read\");\n+        \n+        if (str::contains(request_str, \">>EOF<<\")) {\n+            let client_data = direct::get_data_for_uv_handle(\n+                client_stream_ptr as *libc::c_void) as\n+                *tcp_server_data;\n+            direct::read_stop(client_stream_ptr);\n+            direct::close(client_stream_ptr as *libc::c_void,\n+                          client_stream_after_close_cb)\n+        }\n+    }\n+    else if (nread == -1) {\n+        // err .. possibly EOF\n+        io::println(\"read: eof!\");\n+    }\n+    else {\n+        // nread == 0 .. do nothing, just free buf as below\n+        io::println(\"read: do nothing!\");\n+    }\n+    // when we're done\n+    direct::free_base_of_buf(buf);\n+    io::println(\"exiting on_read_cb\");\n+}\n+\n+crust fn server_connection_cb(server_stream_ptr: *uv_stream_t,\n+                              status: libc::c_int) unsafe {\n+    io::println(\"client connecting!\");\n+    let test_loop = direct::get_loop_for_uv_handle(\n+                           server_stream_ptr as *libc::c_void);\n+    let server_data = direct::get_data_for_uv_handle(\n+        server_stream_ptr as *libc::c_void) as *tcp_server_data;\n+    let client_stream_ptr = (*server_data).client;\n+    let client_init_result = direct::tcp_init(test_loop,\n+                                              client_stream_ptr);\n+    direct::set_data_for_uv_handle(\n+        client_stream_ptr as *libc::c_void,\n+        server_data as *libc::c_void);\n+    if (client_init_result == 0i32) {\n+        io::println(\"successfully initialized client stream\");\n+        let accept_result = direct::accept(server_stream_ptr as\n+                                             *libc::c_void,\n+                                           client_stream_ptr as\n+                                             *libc::c_void);\n+        if (accept_result == 0i32) {\n+            // start reading\n+            let read_result = direct::read_start(client_stream_ptr\n+                                                   as *uv_stream_t,\n+                                                 on_alloc_cb,\n+                                                 on_server_read_cb);\n+            if (read_result == 0i32) {\n+                io::println(\"successful server read start\");\n+            }\n+            else {\n+                io::println(#fmt(\"server_connection_cb: bad read:%d\",\n+                                read_result as int));\n+                assert false;\n+            }\n+        }\n+        else {\n+            io::println(#fmt(\"server_connection_cb: bad accept: %d\",\n+                        accept_result as int));\n+            assert false;\n+        }\n+    }\n+    else {\n+        io::println(#fmt(\"server_connection_cb: bad client init: %d\",\n+                    client_init_result as int));\n+        assert false;\n+    }\n+}\n+\n+type tcp_server_data = {\n+    client: *uv_tcp_t,\n+    server: *uv_tcp_t\n+};\n+\n+fn impl_uv_tcp_server(server_ip: str, server_port: int) unsafe {\n+    let test_loop = direct::loop_new();\n+    let tcp_server = direct::tcp_t();\n+    let tcp_server_ptr = ptr::addr_of(tcp_server);\n+\n+    let tcp_client = direct::tcp_t();\n+    let tcp_client_ptr = ptr::addr_of(tcp_client);\n+\n+    let server_data: tcp_server_data = {\n+        client: tcp_client_ptr,\n+        server: tcp_server_ptr\n+    };\n+    let server_data_ptr = ptr::addr_of(server_data);\n+    direct::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n+                                   server_data_ptr as *libc::c_void);\n+\n+    // uv_tcp_init()\n+    let tcp_init_result = direct::tcp_init(\n+        test_loop as *libc::c_void, tcp_server_ptr);\n+    if (tcp_init_result == 0i32) {\n+        let server_addr = direct::ip4_addr(server_ip, server_port);\n+        // FIXME ref #2064\n+        let server_addr_ptr = ptr::addr_of(server_addr);\n+\n+        // uv_tcp_bind()\n+        let bind_result = direct::tcp_bind(tcp_server_ptr,\n+                                           server_addr_ptr);\n+        if (bind_result == 0i32) {\n+            io::println(\"successful uv_tcp_bind, listening\");\n+\n+            // uv_listen()\n+            let listen_result = direct::listen(tcp_server_ptr as\n+                                                 *libc::c_void,\n+                                               128i32,\n+                                               server_connection_cb);\n+            if (listen_result == 0i32) {\n+                // uv_run()\n+                direct::run(test_loop);\n+            }\n+            else {\n+                io::println(#fmt(\"non-zero result on uv_listen: %d\",\n+                            listen_result as int));\n+                assert false;\n+            }\n+            \n+            direct::loop_delete(test_loop);\n+        }\n+        else {\n+            io::println(#fmt(\"non-zero result on uv_tcp_bind: %d\",\n+                        bind_result as int));\n+            assert false;\n+        }\n+    }\n+    else {\n+        io::println(#fmt(\"non-zero result on uv_tcp_init: %d\",\n+                    tcp_init_result as int));\n+        assert false;\n+    }\n+}\n+\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_tcp_server() unsafe {\n+    impl_uv_tcp_server(\"0.0.0.0\", 8888);\n+}\n+\n // struct size tests\n #[test]\n #[ignore(cfg(target_os = \"freebsd\"))]"}, {"sha": "7a6a79ce17bffcbd5e6d4ece2dbece6cce1812b7", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/922ed6f9473e2de0be716ce0116a1d5c91895c0b/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/922ed6f9473e2de0be716ce0116a1d5c91895c0b/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=922ed6f9473e2de0be716ce0116a1d5c91895c0b", "patch": "@@ -139,20 +139,25 @@ rust_uv_run(uv_loop_t* loop) {\n }\n \n extern \"C\" void\n-rust_uv_close(uv_handle_t* handle, crust_close_cb cb) {\n-        handle_data* data = (handle_data*)handle->data;\n-        data->close_cb = cb;\n-        uv_close(handle, native_close_cb);\n+rust_uv_close(uv_handle_t* handle, uv_close_cb cb) {\n+\tuv_close(handle, cb);\n+}\n+\n+extern \"C\" void\n+rust_uv_hilvl_close(uv_handle_t* handle, crust_close_cb cb) {\n+\thandle_data* data = (handle_data*)handle->data;\n+\tdata->close_cb = cb;\n+\tuv_close(handle, native_close_cb);\n }\n \n extern \"C\" void\n-rust_uv_close_async(uv_async_t* handle) {\n+rust_uv_hilvl_close_async(uv_async_t* handle) {\n   current_kernel_free(handle->data);\n   current_kernel_free(handle);\n }\n \n extern \"C\" void\n-rust_uv_close_timer(uv_async_t* handle) {\n+rust_uv_hilvl_close_timer(uv_async_t* handle) {\n   current_kernel_free(handle->data);\n   current_kernel_free(handle);\n }\n@@ -204,6 +209,43 @@ rust_uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n \treturn uv_tcp_init(loop, handle);\n }\n \n+extern \"C\" int\n+rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n+\t\t\t\t\tuv_tcp_t* tcp_ptr,\n+\t\t\t\t\tuv_connect_cb cb,\n+\t\t\t\t\tsockaddr_in* addr_ptr) {\n+\tprintf(\"inside rust_uv_tcp_connect\\n\");\n+\t// FIXME ref #2064\n+\tsockaddr_in addr = *addr_ptr;\n+\tprintf(\"before tcp_connect .. port: %d\\n\", addr.sin_port);\n+\tprintf(\"before tcp_connect.. tcp stream: %lu cb ptr: %lu\\n\",\n+\t\t   (unsigned long int)tcp_ptr, (unsigned long int)cb);\n+\tint result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n+\tprintf (\"leaving rust_uv_tcp_connect.. and result: %d\\n\",\n+\t\t\tresult);\n+\treturn result;\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_bind(uv_tcp_t* tcp_server, sockaddr_in* addr_ptr) {\n+\t// FIXME ref #2064\n+\tsockaddr_in addr = *addr_ptr;\n+\tprintf(\"before uv_tcp_bind .. tcp_server: %lu port: %d\\n\",\n+\t\t   (unsigned long int)tcp_server, addr.sin_port);\n+\treturn uv_tcp_bind(tcp_server, addr);\n+}\n+\n+extern \"C\" int\n+rust_uv_listen(uv_stream_t* stream, int backlog,\n+\t\t\t\t   uv_connection_cb cb) {\n+\treturn uv_listen(stream, backlog, cb);\n+}\n+\n+extern \"C\" int\n+rust_uv_accept(uv_stream_t* server, uv_stream_t* client) {\n+\treturn uv_accept(server, client);\n+}\n+\n extern \"C\" size_t\n rust_uv_helper_uv_tcp_t_size() {\n \treturn sizeof(uv_tcp_t);\n@@ -247,7 +289,6 @@ current_kernel_malloc_alloc_cb(uv_handle_t* handle,\n \treturn uv_buf_init(base_ptr, suggested_size);\n }\n \n-// FIXME see issue #1402\n extern \"C\" uv_buf_t\n rust_uv_buf_init(char* base, size_t len) {\n \treturn uv_buf_init(base, len);\n@@ -293,24 +334,6 @@ extern \"C\" uv_err_t\n rust_uv_last_error(uv_loop_t* loop) {\n \treturn uv_last_error(loop);\n }\n-extern \"C\" int\n-rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n-\t\t\t\t\tuv_tcp_t* tcp_ptr,\n-\t\t\t\t\tuv_connect_cb cb,\n-\t\t\t\t\tsockaddr_in* addr_ptr) {\n-\t//return uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n-\tprintf(\"inside rust_uv_tcp_connect\\n\");\n-\t//sockaddr_in addr_tmp = *((sockaddr_in*)addr_ptr);\n-\t//sockaddr_in addr = addr_tmp;\n-\tsockaddr_in addr = *addr_ptr;\n-\tprintf(\"before tcp_connect .. port: %d\\n\", addr.sin_port);\n-\t//int result = uv_tcp_connect(connect_ptr, tcp_ptr, loc_addr, cb);\n-\tprintf(\"before tcp_connect.. tcp stream: %lu cb ptr: %lu\\n\", (unsigned long int)tcp_ptr, (unsigned long int)cb);\n-\tint result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n-\tprintf (\"leaving rust_uv_tcp_connect.. and result: %d\\n\",\n-\t\t\tresult);\n-\treturn result;\n-}\n \n extern \"C\" int\n rust_uv_write(uv_write_t* req, uv_stream_t* handle,"}, {"sha": "3369f6a3048e22e64012c7c785f48744e3ab8097", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/922ed6f9473e2de0be716ce0116a1d5c91895c0b/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/922ed6f9473e2de0be716ce0116a1d5c91895c0b/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=922ed6f9473e2de0be716ce0116a1d5c91895c0b", "patch": "@@ -87,8 +87,9 @@ rust_uv_bind_op_cb\n rust_uv_stop_op_cb\n rust_uv_run\n rust_uv_close\n-rust_uv_close_async\n-rust_uv_close_timer\n+rust_uv_hilvl_close\n+rust_uv_hilvl_close_async\n+rust_uv_hilvl_close_timer\n rust_uv_async_send\n rust_uv_async_init\n rust_uv_timer_init\n@@ -101,6 +102,9 @@ rust_uv_last_error\n rust_uv_ip4_test_verify_port_val\n rust_uv_ip4_addr\n rust_uv_tcp_connect\n+rust_uv_tcp_bind\n+rust_uv_listen\n+rust_uv_accept\n rust_uv_write\n rust_uv_read_start\n rust_uv_read_stop"}]}