{"sha": "9e1c4361780e69ed54444a3b03fef0cbbc26b547", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMWM0MzYxNzgwZTY5ZWQ1NDQ0NGEzYjAzZmVmMGNiYmMyNmI1NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-26T03:54:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-26T03:54:00Z"}, "message": "Auto merge of #74225 - poliorcetics:std-thread-unsafe-op-in-unsafe-fn, r=joshtriplett\n\nStd/thread: deny unsafe op in unsafe fn\n\nPartial fix of #73904.\n\nThis encloses `unsafe` operations in `unsafe fn` in `libstd/thread`.\n`@rustbot` modify labels: F-unsafe-block-in-unsafe-fn", "tree": {"sha": "e2dce8f4355eef36de7e09fc8152c9a9827d2ac3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2dce8f4355eef36de7e09fc8152c9a9827d2ac3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e1c4361780e69ed54444a3b03fef0cbbc26b547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e1c4361780e69ed54444a3b03fef0cbbc26b547", "html_url": "https://github.com/rust-lang/rust/commit/9e1c4361780e69ed54444a3b03fef0cbbc26b547", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e1c4361780e69ed54444a3b03fef0cbbc26b547/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6622d1d05d1ea58cfd9b56cc3a91b2c17316c96", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6622d1d05d1ea58cfd9b56cc3a91b2c17316c96", "html_url": "https://github.com/rust-lang/rust/commit/c6622d1d05d1ea58cfd9b56cc3a91b2c17316c96"}, {"sha": "d01bd19573a14d53a035bae704bdcdab0680a283", "url": "https://api.github.com/repos/rust-lang/rust/commits/d01bd19573a14d53a035bae704bdcdab0680a283", "html_url": "https://github.com/rust-lang/rust/commit/d01bd19573a14d53a035bae704bdcdab0680a283"}], "stats": {"total": 171, "additions": 127, "deletions": 44}, "files": [{"sha": "d8db5d1aa69bb86940b89baa43b3989893d39534", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 107, "deletions": 36, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c4361780e69ed54444a3b03fef0cbbc26b547/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c4361780e69ed54444a3b03fef0cbbc26b547/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=9e1c4361780e69ed54444a3b03fef0cbbc26b547", "patch": "@@ -289,15 +289,23 @@ mod lazy {\n         }\n \n         pub unsafe fn get(&self) -> Option<&'static T> {\n-            (*self.inner.get()).as_ref()\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            unsafe { (*self.inner.get()).as_ref() }\n         }\n \n+        /// The caller must ensure that no reference is active: this method\n+        /// needs unique access.\n         pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n             // Execute the initialization up front, *then* move it into our slot,\n             // just in case initialization fails.\n             let value = init();\n             let ptr = self.inner.get();\n \n+            // SAFETY:\n+            //\n             // note that this can in theory just be `*ptr = Some(value)`, but due to\n             // the compiler will currently codegen that pattern with something like:\n             //\n@@ -310,22 +318,36 @@ mod lazy {\n             // value (an aliasing violation). To avoid setting the \"I'm running a\n             // destructor\" flag we just use `mem::replace` which should sequence the\n             // operations a little differently and make this safe to call.\n-            let _ = mem::replace(&mut *ptr, Some(value));\n-\n-            // After storing `Some` we want to get a reference to the contents of\n-            // what we just stored. While we could use `unwrap` here and it should\n-            // always work it empirically doesn't seem to always get optimized away,\n-            // which means that using something like `try_with` can pull in\n-            // panicking code and cause a large size bloat.\n-            match *ptr {\n-                Some(ref x) => x,\n-                None => hint::unreachable_unchecked(),\n+            //\n+            // The precondition also ensures that we are the only one accessing\n+            // `self` at the moment so replacing is fine.\n+            unsafe {\n+                let _ = mem::replace(&mut *ptr, Some(value));\n+            }\n+\n+            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n+            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n+            // will never be reached.\n+            unsafe {\n+                // After storing `Some` we want to get a reference to the contents of\n+                // what we just stored. While we could use `unwrap` here and it should\n+                // always work it empirically doesn't seem to always get optimized away,\n+                // which means that using something like `try_with` can pull in\n+                // panicking code and cause a large size bloat.\n+                match *ptr {\n+                    Some(ref x) => x,\n+                    None => hint::unreachable_unchecked(),\n+                }\n             }\n         }\n \n+        /// The other methods hand out references while taking &self.\n+        /// As such, callers of this method must ensure no `&` and `&mut` are\n+        /// available and used at the same time.\n         #[allow(unused)]\n         pub unsafe fn take(&mut self) -> Option<T> {\n-            (*self.inner.get()).take()\n+            // SAFETY: See doc comment for this method.\n+            unsafe { (*self.inner.get()).take() }\n         }\n     }\n }\n@@ -356,10 +378,17 @@ pub mod statik {\n         }\n \n         pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n-            let value = match self.inner.get() {\n-                Some(ref value) => value,\n-                None => self.inner.initialize(init),\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            let value = unsafe {\n+                match self.inner.get() {\n+                    Some(ref value) => value,\n+                    None => self.inner.initialize(init),\n+                }\n             };\n+\n             Some(value)\n         }\n     }\n@@ -414,9 +443,18 @@ pub mod fast {\n         }\n \n         pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            match self.inner.get() {\n-                Some(val) => Some(val),\n-                None => self.try_initialize(init),\n+            // SAFETY: See the definitions of `LazyKeyInner::get` and\n+            // `try_initialize` for more informations.\n+            //\n+            // The caller must ensure no mutable references are ever active to\n+            // the inner cell or the inner T when this is called.\n+            // The `try_initialize` is dependant on the passed `init` function\n+            // for this.\n+            unsafe {\n+                match self.inner.get() {\n+                    Some(val) => Some(val),\n+                    None => self.try_initialize(init),\n+                }\n             }\n         }\n \n@@ -429,8 +467,10 @@ pub mod fast {\n         // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n         #[inline(never)]\n         unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            if !mem::needs_drop::<T>() || self.try_register_dtor() {\n-                Some(self.inner.initialize(init))\n+            // SAFETY: See comment above (this function doc).\n+            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n+                // SAFETY: See comment above (his function doc).\n+                Some(unsafe { self.inner.initialize(init) })\n             } else {\n                 None\n             }\n@@ -442,8 +482,12 @@ pub mod fast {\n         unsafe fn try_register_dtor(&self) -> bool {\n             match self.dtor_state.get() {\n                 DtorState::Unregistered => {\n-                    // dtor registration happens before initialization.\n-                    register_dtor(self as *const _ as *mut u8, destroy_value::<T>);\n+                    // SAFETY: dtor registration happens before initialization.\n+                    // Passing `self` as a pointer while using `destroy_value<T>`\n+                    // is safe because the function will build a pointer to a\n+                    // Key<T>, which is the type of self and so find the correct\n+                    // size.\n+                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n                     self.dtor_state.set(DtorState::Registered);\n                     true\n                 }\n@@ -459,13 +503,21 @@ pub mod fast {\n     unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n         let ptr = ptr as *mut Key<T>;\n \n+        // SAFETY:\n+        //\n+        // The pointer `ptr` has been built just above and comes from\n+        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n+        // making it non-NUL and of the correct type.\n+        //\n         // Right before we run the user destructor be sure to set the\n         // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n         // causes future calls to `get` to run `try_initialize_drop` again,\n         // which will now fail, and return `None`.\n-        let value = (*ptr).inner.take();\n-        (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n-        drop(value);\n+        unsafe {\n+            let value = (*ptr).inner.take();\n+            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+            drop(value);\n+        }\n     }\n }\n \n@@ -503,21 +555,30 @@ pub mod os {\n             Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n         }\n \n+        /// It is a requirement for the caller to ensure that no mutable\n+        /// reference is active when this method is called.\n         pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n-            let ptr = self.os.get() as *mut Value<T>;\n+            // SAFETY: See the documentation for this method.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n             if ptr as usize > 1 {\n-                if let Some(ref value) = (*ptr).inner.get() {\n+                // SAFETY: the check ensured the pointer is safe (its destructor\n+                // is not running) + it is coming from a trusted source (self).\n+                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n                     return Some(value);\n                 }\n             }\n-            self.try_initialize(init)\n+            // SAFETY: At this point we are sure we have no value and so\n+            // initializing (or trying to) is safe.\n+            unsafe { self.try_initialize(init) }\n         }\n \n         // `try_initialize` is only called once per os thread local variable,\n         // except in corner cases where thread_local dtors reference other\n         // thread_local's, or it is being recursively initialized.\n         unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n-            let ptr = self.os.get() as *mut Value<T>;\n+            // SAFETY: No mutable references are ever handed out meaning getting\n+            // the value is ok.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n             if ptr as usize == 1 {\n                 // destructor is running\n                 return None;\n@@ -528,29 +589,39 @@ pub mod os {\n                 // local copy, so do that now.\n                 let ptr: Box<Value<T>> = box Value { inner: LazyKeyInner::new(), key: self };\n                 let ptr = Box::into_raw(ptr);\n-                self.os.set(ptr as *mut u8);\n+                // SAFETY: At this point we are sure there is no value inside\n+                // ptr so setting it will not affect anyone else.\n+                unsafe {\n+                    self.os.set(ptr as *mut u8);\n+                }\n                 ptr\n             } else {\n                 // recursive initialization\n                 ptr\n             };\n \n-            Some((*ptr).inner.initialize(init))\n+            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n+            // dereferenced safely.\n+            unsafe { Some((*ptr).inner.initialize(init)) }\n         }\n     }\n \n     unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n+        // SAFETY:\n+        //\n         // The OS TLS ensures that this key contains a NULL value when this\n         // destructor starts to run. We set it back to a sentinel value of 1 to\n         // ensure that any future calls to `get` for this thread will return\n         // `None`.\n         //\n         // Note that to prevent an infinite loop we reset it back to null right\n         // before we return from the destructor ourselves.\n-        let ptr = Box::from_raw(ptr as *mut Value<T>);\n-        let key = ptr.key;\n-        key.os.set(1 as *mut u8);\n-        drop(ptr);\n-        key.os.set(ptr::null_mut());\n+        unsafe {\n+            let ptr = Box::from_raw(ptr as *mut Value<T>);\n+            let key = ptr.key;\n+            key.os.set(1 as *mut u8);\n+            drop(ptr);\n+            key.os.set(ptr::null_mut());\n+        }\n     }\n }"}, {"sha": "8c353e2484ef2a6e7f5c836306dbb1f752c087ff", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c4361780e69ed54444a3b03fef0cbbc26b547/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c4361780e69ed54444a3b03fef0cbbc26b547/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=9e1c4361780e69ed54444a3b03fef0cbbc26b547", "patch": "@@ -144,6 +144,7 @@\n //! [`with`]: LocalKey::with\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n@@ -456,14 +457,23 @@ impl Builder {\n                 imp::Thread::set_name(name);\n             }\n \n-            thread_info::set(imp::guard::current(), their_thread);\n+            // SAFETY: the stack guard passed is the one for the current thread.\n+            // This means the current thread's stack and the new thread's stack\n+            // are properly set and protected from each other.\n+            thread_info::set(unsafe { imp::guard::current() }, their_thread);\n             let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n                 crate::sys_common::backtrace::__rust_begin_short_backtrace(f)\n             }));\n-            *their_packet.get() = Some(try_result);\n+            // SAFETY: `their_packet` as been built just above and moved by the\n+            // closure (it is an Arc<...>) and `my_packet` will be stored in the\n+            // same `JoinInner` as this closure meaning the mutation will be\n+            // safe (not modify it and affect a value far away).\n+            unsafe { *their_packet.get() = Some(try_result) };\n         };\n \n         Ok(JoinHandle(JoinInner {\n+            // SAFETY:\n+            //\n             // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n             // through FFI or otherwise used with low-level threading primitives that have no\n             // notion of or way to enforce lifetimes.\n@@ -475,12 +485,14 @@ impl Builder {\n             // Similarly, the `sys` implementation must guarantee that no references to the closure\n             // exist after the thread has terminated, which is signaled by `Thread::join`\n             // returning.\n-            native: Some(imp::Thread::new(\n-                stack_size,\n-                mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(Box::new(\n-                    main,\n-                )),\n-            )?),\n+            native: unsafe {\n+                Some(imp::Thread::new(\n+                    stack_size,\n+                    mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(\n+                        Box::new(main),\n+                    ),\n+                )?)\n+            },\n             thread: my_thread,\n             packet: Packet(my_packet),\n         }))"}]}