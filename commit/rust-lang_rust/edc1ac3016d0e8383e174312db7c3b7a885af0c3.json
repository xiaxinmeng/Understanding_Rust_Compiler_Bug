{"sha": "edc1ac3016d0e8383e174312db7c3b7a885af0c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzFhYzMwMTZkMGU4MzgzZTE3NDMxMmRiN2MzYjdhODg1YWYwYzM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-04-03T17:20:26Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-04-07T12:36:51Z"}, "message": "ICH: Centrally compute and cache DefPath hashes as part of DefPathTable.", "tree": {"sha": "4a105a039279db298011aefc3091b0e8a085c20f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a105a039279db298011aefc3091b0e8a085c20f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc1ac3016d0e8383e174312db7c3b7a885af0c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc1ac3016d0e8383e174312db7c3b7a885af0c3", "html_url": "https://github.com/rust-lang/rust/commit/edc1ac3016d0e8383e174312db7c3b7a885af0c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc1ac3016d0e8383e174312db7c3b7a885af0c3/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c5197d4878253804d91e0c30ed92e0a965b663", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c5197d4878253804d91e0c30ed92e0a965b663", "html_url": "https://github.com/rust-lang/rust/commit/b9c5197d4878253804d91e0c30ed92e0a965b663"}], "stats": {"total": 282, "additions": 152, "deletions": 130}, "files": [{"sha": "3f4390536b0428298c1bf74b83c451de74b15ce7", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -2697,7 +2697,7 @@ impl<'a> LoweringContext<'a> {\n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n         let id = self.next_id();\n-        let parent_def = self.parent_def;\n+        let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());"}, {"sha": "c1417f718b27abbecf88081040cf9a25adaab858", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -40,11 +40,9 @@ impl<'a> DefCollector<'a> {\n         }\n     }\n \n-    pub fn collect_root(&mut self) {\n-        let root = self.create_def_with_parent(None,\n-                                               CRATE_NODE_ID,\n-                                               DefPathData::CrateRoot,\n-                                               ITEM_LIKE_SPACE);\n+    pub fn collect_root(&mut self, crate_name: &str, crate_disambiguator: &str) {\n+        let root = self.definitions.create_root_def(crate_name,\n+                                                    crate_disambiguator);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n     }\n@@ -54,20 +52,11 @@ impl<'a> DefCollector<'a> {\n                   data: DefPathData,\n                   address_space: DefIndexAddressSpace)\n                   -> DefIndex {\n-        let parent_def = self.parent_def;\n+        let parent_def = self.parent_def.unwrap();\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions.create_def_with_parent(parent_def, node_id, data, address_space)\n     }\n \n-    fn create_def_with_parent(&mut self,\n-                              parent: Option<DefIndex>,\n-                              node_id: NodeId,\n-                              data: DefPathData,\n-                              address_space: DefIndexAddressSpace)\n-                              -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data, address_space)\n-    }\n-\n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n         let parent = self.parent_def;\n         self.parent_def = Some(parent_def);"}, {"sha": "6118df2ddfc899a527cf60077e86fb47ddbeb453", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 93, "deletions": 22, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n@@ -34,6 +34,7 @@ use util::nodemap::NodeMap;\n pub struct DefPathTable {\n     index_to_key: [Vec<DefKey>; 2],\n     key_to_index: FxHashMap<DefKey, DefIndex>,\n+    def_path_hashes: [Vec<u64>; 2],\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -44,6 +45,8 @@ impl Clone for DefPathTable {\n             index_to_key: [self.index_to_key[0].clone(),\n                            self.index_to_key[1].clone()],\n             key_to_index: self.key_to_index.clone(),\n+            def_path_hashes: [self.def_path_hashes[0].clone(),\n+                              self.def_path_hashes[1].clone()],\n         }\n     }\n }\n@@ -52,6 +55,7 @@ impl DefPathTable {\n \n     fn allocate(&mut self,\n                 key: DefKey,\n+                def_path_hash: u64,\n                 address_space: DefIndexAddressSpace)\n                 -> DefIndex {\n         let index = {\n@@ -62,6 +66,9 @@ impl DefPathTable {\n             index\n         };\n         self.key_to_index.insert(key, index);\n+        self.def_path_hashes[address_space.index()].push(def_path_hash);\n+        debug_assert!(self.def_path_hashes[address_space.index()].len() ==\n+                      self.index_to_key[address_space.index()].len());\n         index\n     }\n \n@@ -71,6 +78,12 @@ impl DefPathTable {\n                          [index.as_array_index()].clone()\n     }\n \n+    #[inline(always)]\n+    pub fn def_path_hash(&self, index: DefIndex) -> u64 {\n+        self.def_path_hashes[index.address_space().index()]\n+                            [index.as_array_index()]\n+    }\n+\n     #[inline(always)]\n     pub fn def_index_for_def_key(&self, key: &DefKey) -> Option<DefIndex> {\n         self.key_to_index.get(key).cloned()\n@@ -116,17 +129,28 @@ impl DefPathTable {\n \n impl Encodable for DefPathTable {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        // Index to key\n         self.index_to_key[DefIndexAddressSpace::Low.index()].encode(s)?;\n-        self.index_to_key[DefIndexAddressSpace::High.index()].encode(s)\n+        self.index_to_key[DefIndexAddressSpace::High.index()].encode(s)?;\n+\n+        // DefPath hashes\n+        self.def_path_hashes[DefIndexAddressSpace::Low.index()].encode(s)?;\n+        self.def_path_hashes[DefIndexAddressSpace::High.index()].encode(s)?;\n+\n+        Ok(())\n     }\n }\n \n impl Decodable for DefPathTable {\n     fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n         let index_to_key_lo: Vec<DefKey> = Decodable::decode(d)?;\n-        let index_to_key_high: Vec<DefKey> = Decodable::decode(d)?;\n+        let index_to_key_hi: Vec<DefKey> = Decodable::decode(d)?;\n \n-        let index_to_key = [index_to_key_lo, index_to_key_high];\n+        let def_path_hashes_lo: Vec<u64> = Decodable::decode(d)?;\n+        let def_path_hashes_hi: Vec<u64> = Decodable::decode(d)?;\n+\n+        let index_to_key = [index_to_key_lo, index_to_key_hi];\n+        let def_path_hashes = [def_path_hashes_lo, def_path_hashes_hi];\n \n         let mut key_to_index = FxHashMap();\n \n@@ -141,6 +165,7 @@ impl Decodable for DefPathTable {\n         Ok(DefPathTable {\n             index_to_key: index_to_key,\n             key_to_index: key_to_index,\n+            def_path_hashes: def_path_hashes,\n         })\n     }\n }\n@@ -184,6 +209,29 @@ pub struct DefKey {\n     pub disambiguated_data: DisambiguatedDefPathData,\n }\n \n+impl DefKey {\n+    fn compute_stable_hash(&self, parent_hash: u64) -> u64 {\n+        let mut hasher = StableHasher::new();\n+\n+        // We hash a 0u8 here to disambiguate between regular DefPath hashes,\n+        // and the special \"root_parent\" below.\n+        0u8.hash(&mut hasher);\n+        parent_hash.hash(&mut hasher);\n+        self.disambiguated_data.hash(&mut hasher);\n+        hasher.finish()\n+    }\n+\n+    fn root_parent_stable_hash(crate_name: &str, crate_disambiguator: &str) -> u64 {\n+        let mut hasher = StableHasher::new();\n+        // Disambiguate this from a regular DefPath hash,\n+        // see compute_stable_hash() above.\n+        1u8.hash(&mut hasher);\n+        crate_name.hash(&mut hasher);\n+        crate_disambiguator.hash(&mut hasher);\n+        hasher.finish()\n+    }\n+}\n+\n /// Pair of `DefPathData` and an integer disambiguator. The integer is\n /// normally 0, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n@@ -271,19 +319,6 @@ impl DefPath {\n \n         s\n     }\n-\n-    pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n-        debug!(\"deterministic_hash({:?})\", self);\n-        let mut state = StableHasher::new();\n-        self.deterministic_hash_to(tcx, &mut state);\n-        state.finish()\n-    }\n-\n-    pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.original_crate_name(self.krate).as_str().hash(state);\n-        tcx.crate_disambiguator(self.krate).as_str().hash(state);\n-        self.data.hash(state);\n-    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -338,6 +373,7 @@ impl Definitions {\n             table: DefPathTable {\n                 index_to_key: [vec![], vec![]],\n                 key_to_index: FxHashMap(),\n+                def_path_hashes: [vec![], vec![]],\n             },\n             node_to_def_index: NodeMap(),\n             def_index_to_node: [vec![], vec![]],\n@@ -359,6 +395,11 @@ impl Definitions {\n         self.table.def_key(index)\n     }\n \n+    #[inline(always)]\n+    pub fn def_path_hash(&self, index: DefIndex) -> u64 {\n+        self.table.def_path_hash(index)\n+    }\n+\n     pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n         self.table.def_index_for_def_key(&key)\n     }\n@@ -398,12 +439,38 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n+    /// Add a definition with a parent definition.\n+    pub fn create_root_def(&mut self,\n+                           crate_name: &str,\n+                           crate_disambiguator: &str)\n+                           -> DefIndex {\n+        let key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0\n+            }\n+        };\n+\n+        let parent_hash = DefKey::root_parent_stable_hash(crate_name,\n+                                                          crate_disambiguator);\n+        let def_path_hash = key.compute_stable_hash(parent_hash);\n+\n+        // Create the definition.\n+        let address_space = super::ITEM_LIKE_SPACE;\n+        let index = self.table.allocate(key, def_path_hash, address_space);\n+        assert!(self.def_index_to_node[address_space.index()].is_empty());\n+        self.def_index_to_node[address_space.index()].push(ast::CRATE_NODE_ID);\n+        self.node_to_def_index.insert(ast::CRATE_NODE_ID, index);\n+\n+        index\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n-                                  parent: Option<DefIndex>,\n+                                  parent: DefIndex,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n-                                  // is_owner: bool)\n                                   address_space: DefIndexAddressSpace)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n@@ -415,12 +482,13 @@ impl Definitions {\n                 data,\n                 self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        assert_eq!(parent.is_some(), data != DefPathData::CrateRoot);\n+        // The root node must be created with create_root_def()\n+        assert!(data != DefPathData::CrateRoot);\n \n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match.\n         let mut key = DefKey {\n-            parent: parent,\n+            parent: Some(parent),\n             disambiguated_data: DisambiguatedDefPathData {\n                 data: data,\n                 disambiguator: 0\n@@ -431,10 +499,13 @@ impl Definitions {\n             key.disambiguated_data.disambiguator += 1;\n         }\n \n+        let parent_hash = self.table.def_path_hash(parent);\n+        let def_path_hash = key.compute_stable_hash(parent_hash);\n+\n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = self.table.allocate(key, address_space);\n+        let index = self.table.allocate(key, def_path_hash, address_space);\n         assert_eq!(index.as_array_index(),\n                    self.def_index_to_node[address_space.index()].len());\n         self.def_index_to_node[address_space.index()].push(node_id);"}, {"sha": "03051dc0034204a7dde4cc65c3882432c3070ef2", "filename": "src/librustc/ich/def_path_hash.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b9c5197d4878253804d91e0c30ed92e0a965b663/src%2Flibrustc%2Fich%2Fdef_path_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c5197d4878253804d91e0c30ed92e0a965b663/src%2Flibrustc%2Fich%2Fdef_path_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fdef_path_hash.rs?ref=b9c5197d4878253804d91e0c30ed92e0a965b663", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir::def_id::DefId;\n-use ty::TyCtxt;\n-use util::nodemap::DefIdMap;\n-\n-pub struct DefPathHashes<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    data: DefIdMap<u64>,\n-}\n-\n-impl<'a, 'tcx> DefPathHashes<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        DefPathHashes {\n-            tcx: tcx,\n-            data: DefIdMap()\n-        }\n-    }\n-\n-    pub fn hash(&mut self, def_id: DefId) -> u64 {\n-        let tcx = self.tcx;\n-        *self.data.entry(def_id)\n-                  .or_insert_with(|| {\n-                      let def_path = tcx.def_path(def_id);\n-                      def_path.deterministic_hash(tcx)\n-                  })\n-    }\n-}"}, {"sha": "5ef30550f1155ec017d1eb3b713d248a85560807", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -10,7 +10,7 @@\n \n use hir;\n use hir::def_id::DefId;\n-use ich::{self, CachingCodemapView, DefPathHashes};\n+use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n \n@@ -32,7 +32,6 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n /// things (e.g. each DefId/DefPath is only hashed once).\n pub struct StableHashingContext<'a, 'tcx: 'a> {\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    def_path_hashes: DefPathHashes<'a, 'tcx>,\n     codemap: CachingCodemapView<'tcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n@@ -64,7 +63,6 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n \n         StableHashingContext {\n             tcx: tcx,\n-            def_path_hashes: DefPathHashes::new(tcx),\n             codemap: CachingCodemapView::new(tcx),\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n@@ -111,7 +109,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n \n     #[inline]\n     pub fn def_path_hash(&mut self, def_id: DefId) -> u64 {\n-        self.def_path_hashes.hash(def_id)\n+        self.tcx.def_path_hash(def_id)\n     }\n \n     #[inline]"}, {"sha": "f932c90a331e145509f86322f3692ee8cefcdf4c", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -11,12 +11,10 @@\n //! ICH - Incremental Compilation Hash\n \n pub use self::fingerprint::Fingerprint;\n-pub use self::def_path_hash::DefPathHashes;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode};\n \n mod fingerprint;\n-mod def_path_hash;\n mod caching_codemap_view;\n mod hcx;\n "}, {"sha": "ee0635ac9a179b7e02ea6fea51eb69703bc697b7", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -230,6 +230,7 @@ pub trait CrateStore {\n                     -> Option<DefId>;\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n+    fn def_path_hash(&self, def: DefId) -> u64;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -377,6 +378,9 @@ impl CrateStore for DummyCrateStore {\n     fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")\n     }\n+    fn def_path_hash(&self, def: DefId) -> u64 {\n+        bug!(\"wa\")\n+    }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }"}, {"sha": "292e30e3d41f19403353bfdd2a055ac4c1066daf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -2227,6 +2227,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn def_path_hash(self, def_id: DefId) -> u64 {\n+        if def_id.is_local() {\n+            self.hir.definitions().def_path_hash(def_id.index)\n+        } else {\n+            self.sess.cstore.def_path_hash(def_id)\n+        }\n+    }\n+\n     pub fn def_span(self, def_id: DefId) -> Span {\n         if let Some(id) = self.hir.as_local_node_id(def_id) {\n             self.hir.span(id)"}, {"sha": "fd8191303a9a60cb92e9f1bb9bd1340daba448f5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -13,7 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n use infer::InferCtxt;\n-use hir::map as hir_map;\n+// use hir::map as hir_map;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::ParameterEnvironment;\n@@ -441,13 +441,11 @@ impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n \n     fn def_id(&mut self, did: DefId) {\n         // Hash the DefPath corresponding to the DefId, which is independent\n-        // of compiler internal state.\n-        let path = self.tcx.def_path(did);\n-        self.def_path(&path)\n-    }\n-\n-    pub fn def_path(&mut self, def_path: &hir_map::DefPath) {\n-        def_path.deterministic_hash_to(self.tcx, &mut self.state);\n+        // of compiler internal state. We already have a stable hash value of\n+        // all DefPaths available via tcx.def_path_hash(), so we just feed that\n+        // into the hasher.\n+        let hash = self.tcx.def_path_hash(did);\n+        self.hash(hash);\n     }\n }\n "}, {"sha": "4e6c919c7f5691ed1d05350c1bb15ef07f45c05f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -647,8 +647,12 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n     crate_loader.preprocess(&krate);\n     let resolver_arenas = Resolver::arenas();\n-    let mut resolver =\n-        Resolver::new(sess, &krate, make_glob_map, &mut crate_loader, &resolver_arenas);\n+    let mut resolver = Resolver::new(sess,\n+                                     &krate,\n+                                     crate_name,\n+                                     make_glob_map,\n+                                     &mut crate_loader,\n+                                     &resolver_arenas);\n     resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n "}, {"sha": "b9b860222968b7b232050ca1cd5d46b36b0afa25", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -186,10 +186,6 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n                  .clone()\n     }\n \n-    pub fn lookup_def_path(&self, id: DefPathIndex) -> &DefPath {\n-        &self.directory.paths[id.index as usize]\n-    }\n-\n     pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n         node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }"}, {"sha": "1591503865e817a6180a0ea86c884a9cbe3886ed", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -258,24 +258,13 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n         index_map: FxHashMap()\n     };\n \n-    let mut def_id_hashes = FxHashMap();\n-\n     for (index, target) in preds.reduced_graph.all_nodes().iter().enumerate() {\n         let index = NodeIndex(index);\n         let def_id = match *target.data {\n             DepNode::MetaData(def_id) if def_id.is_local() => def_id,\n             _ => continue,\n         };\n \n-        let mut def_id_hash = |def_id: DefId| -> u64 {\n-            *def_id_hashes.entry(def_id)\n-                .or_insert_with(|| {\n-                    let index = builder.add(def_id);\n-                    let path = builder.lookup_def_path(index);\n-                    path.deterministic_hash(tcx)\n-                })\n-        };\n-\n         // To create the hash for each item `X`, we don't hash the raw\n         // bytes of the metadata (though in principle we\n         // could). Instead, we walk the predecessors of `MetaData(X)`\n@@ -295,7 +284,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                  .map(|index| preds.reduced_graph.node_data(index))\n                  .filter(|dep_node| HashContext::is_hashable(dep_node))\n                  .map(|dep_node| {\n-                     let hash_dep_node = dep_node.map_def(|&def_id| Some(def_id_hash(def_id)))\n+                     let hash_dep_node = dep_node.map_def(|&def_id| Some(tcx.def_path_hash(def_id)))\n                                                  .unwrap();\n                      let hash = preds.hashes[dep_node];\n                      (hash_dep_node, hash)"}, {"sha": "efcd2f007d66c5944466dcf6dabe541dc47be8eb", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -73,7 +73,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     predicates => { cdata.get_predicates(def_id.index, tcx) }\n     super_predicates => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n-        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx))\n+        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n     }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n@@ -370,6 +370,10 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n+    fn def_path_hash(&self, def: DefId) -> u64 {\n+        self.get_crate_data(def.krate).def_path_hash(def.index)\n+    }\n+\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));"}, {"sha": "cdbecb3ae2e428a2e8535dceafd73eef0d0db7f9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -492,10 +492,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_trait_def(&self,\n-                         item_id: DefIndex,\n-                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                         -> ty::TraitDef {\n+    pub fn get_trait_def(&self, item_id: DefIndex) -> ty::TraitDef {\n         let data = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self),\n             _ => bug!(),\n@@ -504,7 +501,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let def = ty::TraitDef::new(self.local_def_id(item_id),\n                                     data.unsafety,\n                                     data.paren_sugar,\n-                                    self.def_path(item_id).deterministic_hash(tcx));\n+                                    self.def_path_table.def_path_hash(item_id));\n \n         if data.has_default_impl {\n             def.record_has_default_impl();\n@@ -1053,6 +1050,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.def_path_table.def_key(index)\n     }\n@@ -1063,6 +1061,11 @@ impl<'a, 'tcx> CrateMetadata {\n         DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n     }\n \n+    #[inline]\n+    pub fn def_path_hash(&self, index: DefIndex) -> u64 {\n+        self.def_path_table.def_path_hash(index)\n+    }\n+\n     /// Imports the codemap from an external crate into the codemap of the crate\n     /// currently being compiled (the \"local crate\").\n     ///"}, {"sha": "d9900340a2e9f35613f67e9cae28e062298b703a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -1289,6 +1289,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n                krate: &Crate,\n+               crate_name: &str,\n                make_glob_map: MakeGlobMap,\n                crate_loader: &'a mut CrateLoader,\n                arenas: &'a ResolverArenas<'a>)\n@@ -1303,7 +1304,8 @@ impl<'a> Resolver<'a> {\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n         let mut definitions = Definitions::new();\n-        DefCollector::new(&mut definitions).collect_root();\n+        DefCollector::new(&mut definitions)\n+            .collect_root(crate_name, &session.local_crate_disambiguator().as_str());\n \n         let mut invocations = FxHashMap();\n         invocations.insert(Mark::root(),"}, {"sha": "3568c1ba8f4c153257f60af8c860a51a207d4097", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -101,22 +101,22 @@ use common::SharedCrateContext;\n use monomorphize::Instance;\n \n use rustc::middle::weak_lang_items;\n-use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n-use rustc::hir::map::definitions::{DefPath, DefPathData};\n+use rustc::hir::map::definitions::DefPathData;\n use rustc::util::common::record_time;\n \n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n-                             // path to the item this name is for\n-                             def_path: &DefPath,\n+                             // the DefId of the item this name is for\n+                             def_id: Option<DefId>,\n \n                              // type of the item, without any generic\n                              // parameters substituted; this is\n@@ -128,8 +128,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                              // if any.\n                              substs: Option<&'tcx Substs<'tcx>>)\n                              -> String {\n-    debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n-           def_path, substs);\n+    debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n     let tcx = scx.tcx();\n \n@@ -139,7 +138,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hasher.def_path(def_path);\n+        hasher.hash(def_id.map(|def_id| tcx.def_path_hash(def_id)));\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n@@ -224,8 +223,6 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n         return scx.tcx().item_name(def_id).as_str().to_string();\n     }\n \n-    let def_path = scx.tcx().def_path(def_id);\n-\n     // We want to compute the \"type\" of this item. Unfortunately, some\n     // kinds of items (e.g., closures) don't have an entry in the\n     // item-type array. So walk back up the find the closest parent\n@@ -256,10 +253,10 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n     // and should not matter anyhow.\n     let instance_ty = scx.tcx().erase_regions(&instance_ty);\n \n-    let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n+    let hash = get_symbol_hash(scx, Some(def_id), instance_ty, Some(substs));\n \n     let mut buffer = SymbolPathBuffer {\n-        names: Vec::with_capacity(def_path.data.len())\n+        names: Vec::new()\n     };\n \n     item_path::with_forced_absolute_paths(|| {\n@@ -288,11 +285,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                     t: Ty<'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n-    let empty_def_path = DefPath {\n-        data: vec![],\n-        krate: LOCAL_CRATE,\n-    };\n-    let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n+    let hash = get_symbol_hash(scx, None, t, None);\n     let path = [Symbol::intern(prefix).as_str()];\n     mangle(path.iter().cloned(), &hash)\n }"}, {"sha": "77ab076eba38604f89bc5dc3775ea204ead4ecc3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc1ac3016d0e8383e174312db7c3b7a885af0c3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=edc1ac3016d0e8383e174312db7c3b7a885af0c3", "patch": "@@ -806,7 +806,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         err.emit();\n     }\n \n-    let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n+    let def_path_hash = tcx.def_path_hash(def_id);\n     let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash);\n \n     if tcx.hir.trait_is_auto(def_id) {"}]}