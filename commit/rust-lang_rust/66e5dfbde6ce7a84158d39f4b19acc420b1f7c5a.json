{"sha": "66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTVkZmJkZTZjZTdhODQxNThkMzlmNGIxOWFjYzQyMGIxZjdjNWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-29T00:15:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-29T00:15:32Z"}, "message": "stdlib: Provide \"array\" as a friendlier shorthand for \"vec[mutable? T]\"", "tree": {"sha": "7771bde7edcf2797f0bbacc33b0b9fce195b2e25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7771bde7edcf2797f0bbacc33b0b9fce195b2e25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a", "html_url": "https://github.com/rust-lang/rust/commit/66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e300b8047f57920f518ab32eadef12d8e6047c5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e300b8047f57920f518ab32eadef12d8e6047c5d", "html_url": "https://github.com/rust-lang/rust/commit/e300b8047f57920f518ab32eadef12d8e6047c5d"}], "stats": {"total": 35, "additions": 18, "deletions": 17}, "files": [{"sha": "126bf363052c00e4a89466a0cecbe6b020f22905", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=66e5dfbde6ce7a84158d39f4b19acc420b1f7c5a", "patch": "@@ -6,6 +6,8 @@ type vbuf = rustrt.vbuf;\n \n type operator2[T,U,V] = fn(&T, &U) -> V;\n \n+type array[T] = vec[mutable? T];\n+\n native \"rust\" mod rustrt {\n     type vbuf;\n \n@@ -43,7 +45,7 @@ fn alloc_mut[T](uint n_elts) -> vec[mutable T] {\n     ret rustrt.vec_alloc_mut[vec[mutable T], T](n_elts);\n }\n \n-fn refcount[T](vec[mutable? T] v) -> uint {\n+fn refcount[T](array[T] v) -> uint {\n     auto r = rustrt.refcount[T](v);\n     if (r == dbg.const_refcount) {\n         ret r;\n@@ -116,29 +118,29 @@ fn init_elt_mut[T](&T t, uint n_elts) -> vec[mutable T] {\n     ret v;\n }\n \n-fn buf[T](vec[mutable? T] v) -> vbuf {\n+fn buf[T](array[T] v) -> vbuf {\n     ret rustrt.vec_buf[T](v, 0u);\n }\n \n-fn len[T](vec[mutable? T] v) -> uint {\n+fn len[T](array[T] v) -> uint {\n     ret rustrt.vec_len[T](v);\n }\n \n-fn len_set[T](vec[mutable? T] v, uint n) {\n+fn len_set[T](array[T] v, uint n) {\n     rustrt.vec_len_set[T](v, n);\n }\n \n-fn buf_off[T](vec[mutable? T] v, uint offset) -> vbuf {\n+fn buf_off[T](array[T] v, uint offset) -> vbuf {\n     check (offset < len[T](v));\n     ret rustrt.vec_buf[T](v, offset);\n }\n \n-fn print_debug_info[T](vec[mutable? T] v) {\n+fn print_debug_info[T](array[T] v) {\n     rustrt.vec_print_debug_info[T](v);\n }\n \n // Returns the last element of v.\n-fn last[T](vec[mutable? T] v) -> option.t[T] {\n+fn last[T](array[T] v) -> option.t[T] {\n     auto l = len[T](v);\n     if (l == 0u) {\n         ret none[T];\n@@ -147,7 +149,7 @@ fn last[T](vec[mutable? T] v) -> option.t[T] {\n }\n \n // Returns elements from [start..end) from v.\n-fn slice[T](vec[mutable? T] v, uint start, uint end) -> vec[T] {\n+fn slice[T](array[T] v, uint start, uint end) -> vec[T] {\n     check (start <= end);\n     check (end <= len[T](v));\n     auto result = alloc[T](end - start);\n@@ -159,15 +161,15 @@ fn slice[T](vec[mutable? T] v, uint start, uint end) -> vec[T] {\n     ret result;\n }\n \n-fn shift[T](&mutable vec[mutable? T] v) -> T {\n+fn shift[T](&mutable array[T] v) -> T {\n     auto ln = len[T](v);\n     check(ln > 0u);\n     auto e = v.(0);\n     v = slice[T](v, 1u, ln);\n     ret e;\n }\n \n-fn pop[T](&mutable vec[mutable? T] v) -> T {\n+fn pop[T](&mutable array[T] v) -> T {\n     auto ln = len[T](v);\n     check(ln > 0u);\n     ln -= 1u;\n@@ -176,18 +178,18 @@ fn pop[T](&mutable vec[mutable? T] v) -> T {\n     ret e;\n }\n \n-fn push[T](&mutable vec[mutable? T] v, &T t) {\n+fn push[T](&mutable array[T] v, &T t) {\n     v += vec(t);\n }\n \n-fn unshift[T](&mutable vec[mutable? T] v, &T t) {\n+fn unshift[T](&mutable array[T] v, &T t) {\n     auto res = alloc[T](len[T](v) + 1u);\n     res += vec(t);\n     res += v;\n     v = res;\n }\n \n-fn grow[T](&mutable vec[mutable? T] v, uint n, &T initval) {\n+fn grow[T](&mutable array[T] v, uint n, &T initval) {\n     let uint i = n;\n     while (i > 0u) {\n         i -= 1u;\n@@ -203,16 +205,15 @@ fn grow_set[T](&mutable vec[mutable T] v, uint index, &T initval, &T val) {\n     v.(index) = val;\n }\n \n-fn map[T, U](&option.operator[T,U] f, &vec[mutable? T] v) -> vec[U] {\n+fn map[T, U](&option.operator[T,U] f, &array[T] v) -> vec[U] {\n     let vec[U] u = alloc[U](len[T](v));\n     for (T ve in v) {\n         u += vec(f(ve));\n     }\n     ret u;\n }\n \n-fn map2[T,U,V](&operator2[T,U,V] f, &vec[mutable? T] v0, &vec[mutable? U] v1)\n-        -> vec[V] {\n+fn map2[T,U,V](&operator2[T,U,V] f, &array[T] v0, &array[U] v1) -> vec[V] {\n     auto v0_len = len[T](v0);\n     if (v0_len != len[U](v1)) {\n         fail;\n@@ -228,7 +229,7 @@ fn map2[T,U,V](&operator2[T,U,V] f, &vec[mutable? T] v0, &vec[mutable? U] v1)\n     ret u;\n }\n \n-fn find[T](fn (&T) -> bool f, &vec[mutable? T] v) -> option.t[T] {\n+fn find[T](fn (&T) -> bool f, &array[T] v) -> option.t[T] {\n     for (T elt in v) {\n         if (f(elt)) {\n             ret some[T](elt);"}]}