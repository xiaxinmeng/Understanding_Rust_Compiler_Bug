{"sha": "2474f42ae95bffea7c0bc713f92322bfec4d59a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NzRmNDJhZTk1YmZmZWE3YzBiYzcxM2Y5MjMyMmJmZWM0ZDU5YTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-03T04:56:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-03T04:56:59Z"}, "message": "Merge #4270\n\n4270: Improve derive macro completion r=edwin0cheng a=SomeoneToIgnore\n\n* Adds completions for standard derive macros (considering their dependencies on each other, so we don't get compile errors)\r\n* Adds completions for custom derive macros that are in scope, if the proc macro feature is enabled in the settings\r\n* Separates macro completion from other completions to avoid incorrect completion propositions\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "aa7eb8f934a1ce4bcd32bd106fbbd2adafef023f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa7eb8f934a1ce4bcd32bd106fbbd2adafef023f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2474f42ae95bffea7c0bc713f92322bfec4d59a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJerk8bCRBK7hj4Ov3rIwAAdHIIAKSjLrqre9Di1RnvsaNS8Mb7\nfT5Kmx+7KAKGrup2zU80bn+hXA6Cn0APDppLaQ6pXviSUNsX5gdXYx8d5Y/7kAB8\nI4VrRruSOU2e3VT14q53gEGO9DPI5GctXIpkRfhlWweiNtjIDo7tSg9ehToo3M+I\nxEFPIo95S5W8DNISMOdipspAeseqbjk3Ial3O98NyXZCTCEGRV/QUx4hmwogWVjQ\nPvNYC64k4NrUd5K8F7VgjjyDCS05M5/t7j8nPV8451wI3FllLPUfUxbD/C7iPRs+\nLWvXxk7kJAhfYrn0edAOrTZKRuZDWrAedVsdSnZIS59e/5TrKn/uz6NOlavsg3Q=\n=SJvR\n-----END PGP SIGNATURE-----\n", "payload": "tree aa7eb8f934a1ce4bcd32bd106fbbd2adafef023f\nparent 17bd79f4978f1bf7267b54f86d676eed44af02d0\nparent 2fd054f276e6fd75237b476622d03eef2f18430a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588481819 +0000\ncommitter GitHub <noreply@github.com> 1588481819 +0000\n\nMerge #4270\n\n4270: Improve derive macro completion r=edwin0cheng a=SomeoneToIgnore\n\n* Adds completions for standard derive macros (considering their dependencies on each other, so we don't get compile errors)\r\n* Adds completions for custom derive macros that are in scope, if the proc macro feature is enabled in the settings\r\n* Separates macro completion from other completions to avoid incorrect completion propositions\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2474f42ae95bffea7c0bc713f92322bfec4d59a7", "html_url": "https://github.com/rust-lang/rust/commit/2474f42ae95bffea7c0bc713f92322bfec4d59a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2474f42ae95bffea7c0bc713f92322bfec4d59a7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17bd79f4978f1bf7267b54f86d676eed44af02d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/17bd79f4978f1bf7267b54f86d676eed44af02d0", "html_url": "https://github.com/rust-lang/rust/commit/17bd79f4978f1bf7267b54f86d676eed44af02d0"}, {"sha": "2fd054f276e6fd75237b476622d03eef2f18430a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd054f276e6fd75237b476622d03eef2f18430a", "html_url": "https://github.com/rust-lang/rust/commit/2fd054f276e6fd75237b476622d03eef2f18430a"}], "stats": {"total": 348, "additions": 308, "deletions": 40}, "files": [{"sha": "a004363ee1a587b440db44e184013976b0b2567f", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=2474f42ae95bffea7c0bc713f92322bfec4d59a7", "patch": "@@ -19,7 +19,7 @@ use hir_def::{\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n     name::{name, AsName},\n-    MacroDefId,\n+    MacroDefId, MacroDefKind,\n };\n use hir_ty::{\n     autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n@@ -762,13 +762,12 @@ impl MacroDef {\n \n     /// Indicate it is a proc-macro\n     pub fn is_proc_macro(&self) -> bool {\n-        match self.id.kind {\n-            hir_expand::MacroDefKind::Declarative => false,\n-            hir_expand::MacroDefKind::BuiltIn(_) => false,\n-            hir_expand::MacroDefKind::BuiltInDerive(_) => false,\n-            hir_expand::MacroDefKind::BuiltInEager(_) => false,\n-            hir_expand::MacroDefKind::CustomDerive(_) => true,\n-        }\n+        matches!(self.id.kind, MacroDefKind::CustomDerive(_))\n+    }\n+\n+    /// Indicate it is a derive macro\n+    pub fn is_derive_macro(&self) -> bool {\n+        matches!(self.id.kind, MacroDefKind::CustomDerive(_) | MacroDefKind::BuiltInDerive(_))\n     }\n }\n "}, {"sha": "a0e06faa2e375ff532e3d2e44523e85fa75a9965", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=2474f42ae95bffea7c0bc713f92322bfec4d59a7", "patch": "@@ -65,21 +65,23 @@ pub(crate) fn completions(\n     let ctx = CompletionContext::new(db, position, config)?;\n \n     let mut acc = Completions::default();\n-\n-    complete_fn_param::complete_fn_param(&mut acc, &ctx);\n-    complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n-    complete_keyword::complete_use_tree_keyword(&mut acc, &ctx);\n-    complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n-    complete_snippet::complete_item_snippet(&mut acc, &ctx);\n-    complete_qualified_path::complete_qualified_path(&mut acc, &ctx);\n-    complete_unqualified_path::complete_unqualified_path(&mut acc, &ctx);\n-    complete_dot::complete_dot(&mut acc, &ctx);\n-    complete_record::complete_record(&mut acc, &ctx);\n-    complete_pattern::complete_pattern(&mut acc, &ctx);\n-    complete_postfix::complete_postfix(&mut acc, &ctx);\n-    complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n-    complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n-    complete_attribute::complete_attribute(&mut acc, &ctx);\n+    if ctx.attribute_under_caret.is_some() {\n+        complete_attribute::complete_attribute(&mut acc, &ctx);\n+    } else {\n+        complete_fn_param::complete_fn_param(&mut acc, &ctx);\n+        complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n+        complete_keyword::complete_use_tree_keyword(&mut acc, &ctx);\n+        complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n+        complete_snippet::complete_item_snippet(&mut acc, &ctx);\n+        complete_qualified_path::complete_qualified_path(&mut acc, &ctx);\n+        complete_unqualified_path::complete_unqualified_path(&mut acc, &ctx);\n+        complete_dot::complete_dot(&mut acc, &ctx);\n+        complete_record::complete_record(&mut acc, &ctx);\n+        complete_pattern::complete_pattern(&mut acc, &ctx);\n+        complete_postfix::complete_postfix(&mut acc, &ctx);\n+        complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n+        complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n+    }\n \n     Some(acc)\n }"}, {"sha": "20e6edc17944da920cecd8fbab03a688b5278b51", "filename": "crates/ra_ide/src/completion/complete_attribute.rs", "status": "modified", "additions": 280, "deletions": 13, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=2474f42ae95bffea7c0bc713f92322bfec4d59a7", "patch": "@@ -5,23 +5,26 @@\n \n use super::completion_context::CompletionContext;\n use super::completion_item::{CompletionItem, CompletionItemKind, CompletionKind, Completions};\n+use ast::AttrInput;\n use ra_syntax::{\n-    ast::{Attr, AttrKind},\n-    AstNode,\n+    ast::{self, AttrKind},\n+    AstNode, SyntaxKind,\n };\n+use rustc_hash::FxHashSet;\n \n-pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_attribute {\n-        return;\n-    }\n+pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let attribute = ctx.attribute_under_caret.as_ref()?;\n \n-    let is_inner = ctx\n-        .original_token\n-        .ancestors()\n-        .find_map(Attr::cast)\n-        .map(|attr| attr.kind() == AttrKind::Inner)\n-        .unwrap_or(false);\n+    match (attribute.path(), attribute.input()) {\n+        (Some(path), Some(AttrInput::TokenTree(token_tree))) if path.to_string() == \"derive\" => {\n+            complete_derive(acc, ctx, token_tree)\n+        }\n+        _ => complete_attribute_start(acc, ctx, attribute),\n+    }\n+    Some(())\n+}\n \n+fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n     for attr_completion in ATTRIBUTES {\n         let mut item = CompletionItem::new(\n             CompletionKind::Attribute,\n@@ -37,7 +40,7 @@ pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n             _ => {}\n         }\n \n-        if is_inner || !attr_completion.should_be_inner {\n+        if attribute.kind() == AttrKind::Inner || !attr_completion.should_be_inner {\n             acc.add(item);\n         }\n     }\n@@ -126,6 +129,106 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     },\n ];\n \n+fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, derive_input: ast::TokenTree) {\n+    if let Ok(existing_derives) = parse_derive_input(derive_input) {\n+        for derive_completion in DEFAULT_DERIVE_COMPLETIONS\n+            .into_iter()\n+            .filter(|completion| !existing_derives.contains(completion.label))\n+        {\n+            let mut label = derive_completion.label.to_owned();\n+            for dependency in derive_completion\n+                .dependencies\n+                .into_iter()\n+                .filter(|&&dependency| !existing_derives.contains(dependency))\n+            {\n+                label.push_str(\", \");\n+                label.push_str(dependency);\n+            }\n+            acc.add(\n+                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label)\n+                    .kind(CompletionItemKind::Attribute),\n+            );\n+        }\n+\n+        for custom_derive_name in get_derive_names_in_scope(ctx).difference(&existing_derives) {\n+            acc.add(\n+                CompletionItem::new(\n+                    CompletionKind::Attribute,\n+                    ctx.source_range(),\n+                    custom_derive_name,\n+                )\n+                .kind(CompletionItemKind::Attribute),\n+            );\n+        }\n+    }\n+}\n+\n+fn parse_derive_input(derive_input: ast::TokenTree) -> Result<FxHashSet<String>, ()> {\n+    match (derive_input.left_delimiter_token(), derive_input.right_delimiter_token()) {\n+        (Some(left_paren), Some(right_paren))\n+            if left_paren.kind() == SyntaxKind::L_PAREN\n+                && right_paren.kind() == SyntaxKind::R_PAREN =>\n+        {\n+            let mut input_derives = FxHashSet::default();\n+            let mut current_derive = String::new();\n+            for token in derive_input\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(|token| token.into_token())\n+                .skip_while(|token| token != &left_paren)\n+                .skip(1)\n+                .take_while(|token| token != &right_paren)\n+            {\n+                if SyntaxKind::COMMA == token.kind() {\n+                    if !current_derive.is_empty() {\n+                        input_derives.insert(current_derive);\n+                        current_derive = String::new();\n+                    }\n+                } else {\n+                    current_derive.push_str(token.to_string().trim());\n+                }\n+            }\n+\n+            if !current_derive.is_empty() {\n+                input_derives.insert(current_derive);\n+            }\n+            Ok(input_derives)\n+        }\n+        _ => Err(()),\n+    }\n+}\n+\n+fn get_derive_names_in_scope(ctx: &CompletionContext) -> FxHashSet<String> {\n+    let mut result = FxHashSet::default();\n+    ctx.scope().process_all_names(&mut |name, scope_def| {\n+        if let hir::ScopeDef::MacroDef(mac) = scope_def {\n+            if mac.is_derive_macro() {\n+                result.insert(name.to_string());\n+            }\n+        }\n+    });\n+    result\n+}\n+\n+struct DeriveCompletion {\n+    label: &'static str,\n+    dependencies: &'static [&'static str],\n+}\n+\n+/// Standard Rust derives and the information about their dependencies\n+/// (the dependencies are needed so that the main derive don't break the compilation when added)\n+const DEFAULT_DERIVE_COMPLETIONS: &[DeriveCompletion] = &[\n+    DeriveCompletion { label: \"Clone\", dependencies: &[] },\n+    DeriveCompletion { label: \"Copy\", dependencies: &[\"Clone\"] },\n+    DeriveCompletion { label: \"Debug\", dependencies: &[] },\n+    DeriveCompletion { label: \"Default\", dependencies: &[] },\n+    DeriveCompletion { label: \"Hash\", dependencies: &[] },\n+    DeriveCompletion { label: \"PartialEq\", dependencies: &[] },\n+    DeriveCompletion { label: \"Eq\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"PartialOrd\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"Ord\", dependencies: &[\"PartialOrd\", \"Eq\", \"PartialEq\"] },\n+];\n+\n #[cfg(test)]\n mod tests {\n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n@@ -135,6 +238,170 @@ mod tests {\n         do_completion(code, CompletionKind::Attribute)\n     }\n \n+    #[test]\n+    fn empty_derive_completion() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                    r\"\n+                    #[derive(<|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Clone\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Copy, Clone\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Copy, Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Debug\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Debug\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Default\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Default\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Eq, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Eq, PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Hash\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Hash\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Ord, PartialOrd, Eq, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Ord, PartialOrd, Eq, PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialOrd, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"PartialOrd, PartialEq\",\n+                kind: Attribute,\n+            },\n+        ]\n+            \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn no_completion_for_incorrect_derive() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                r\"\n+                    #[derive{<|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @\"[]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn derive_with_input_completion() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                    r\"\n+                    #[derive(serde::Serialize, PartialEq, <|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Clone\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Copy, Clone\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Copy, Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Debug\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Debug\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Default\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Default\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Eq\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Eq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Hash\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Hash\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Ord, PartialOrd, Eq\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Ord, PartialOrd, Eq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialOrd\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"PartialOrd\",\n+                kind: Attribute,\n+            },\n+        ]\n+            \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_attribute_completion() {\n         assert_debug_snapshot!("}, {"sha": "dd87bd119e1973317e53ff2d57046767a544c2a1", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=2474f42ae95bffea7c0bc713f92322bfec4d59a7", "patch": "@@ -58,7 +58,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_macro_call: bool,\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n-    pub(super) is_attribute: bool,\n+    pub(super) attribute_under_caret: Option<ast::Attr>,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -116,7 +116,7 @@ impl<'a> CompletionContext<'a> {\n             is_path_type: false,\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n-            is_attribute: false,\n+            attribute_under_caret: None,\n         };\n \n         let mut original_file = original_file.syntax().clone();\n@@ -200,6 +200,7 @@ impl<'a> CompletionContext<'a> {\n                 Some(ty)\n             })\n             .flatten();\n+        self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n \n         // First, let's try to complete a reference to some declaration.\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n@@ -318,7 +319,6 @@ impl<'a> CompletionContext<'a> {\n                 .and_then(|it| it.syntax().parent().and_then(ast::CallExpr::cast))\n                 .is_some();\n             self.is_macro_call = path.syntax().parent().and_then(ast::MacroCall::cast).is_some();\n-            self.is_attribute = path.syntax().parent().and_then(ast::Attr::cast).is_some();\n \n             self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n             self.has_type_args = segment.type_arg_list().is_some();"}, {"sha": "98c38d0095a98245c7b460a05714552528d52fd9", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2474f42ae95bffea7c0bc713f92322bfec4d59a7/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=2474f42ae95bffea7c0bc713f92322bfec4d59a7", "patch": "@@ -467,7 +467,7 @@ impl ast::TokenTree {\n \n     pub fn right_delimiter_token(&self) -> Option<SyntaxToken> {\n         self.syntax().last_child_or_token()?.into_token().filter(|it| match it.kind() {\n-            T!['{'] | T!['('] | T!['['] => true,\n+            T!['}'] | T![')'] | T![']'] => true,\n             _ => false,\n         })\n     }"}]}