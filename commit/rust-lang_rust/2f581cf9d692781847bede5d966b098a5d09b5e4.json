{"sha": "2f581cf9d692781847bede5d966b098a5d09b5e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNTgxY2Y5ZDY5Mjc4MTg0N2JlZGU1ZDk2NmIwOThhNWQwOWI1ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T09:40:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T09:40:15Z"}, "message": "Auto merge of #45435 - eddyb:binop-subtype-lhs, r=nikomatsakis\n\nrustc_typeck: use subtyping on the LHS of binops.\n\nFixes #45425.\n\nr? @nikomatsakis", "tree": {"sha": "0566c0b1b6bf26189d47eb9ed6f375d3aa4791f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0566c0b1b6bf26189d47eb9ed6f375d3aa4791f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f581cf9d692781847bede5d966b098a5d09b5e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f581cf9d692781847bede5d966b098a5d09b5e4", "html_url": "https://github.com/rust-lang/rust/commit/2f581cf9d692781847bede5d966b098a5d09b5e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f581cf9d692781847bede5d966b098a5d09b5e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "740286657a97770eca193062fd5e127c08c0808c", "url": "https://api.github.com/repos/rust-lang/rust/commits/740286657a97770eca193062fd5e127c08c0808c", "html_url": "https://github.com/rust-lang/rust/commit/740286657a97770eca193062fd5e127c08c0808c"}, {"sha": "1a7fb7dc78439a704f024609ce3dc0beb1386552", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7fb7dc78439a704f024609ce3dc0beb1386552", "html_url": "https://github.com/rust-lang/rust/commit/1a7fb7dc78439a704f024609ce3dc0beb1386552"}], "stats": {"total": 230, "additions": 156, "deletions": 74}, "files": [{"sha": "08cf6d3a59ec573a911c39a7a0596dfecdb25226", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -74,10 +74,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n-        if let Some(mut err) = self.demand_coerce_diag(expr, checked_ty, expected) {\n+    pub fn demand_coerce(&self,\n+                         expr: &hir::Expr,\n+                         checked_ty: Ty<'tcx>,\n+                         expected: Ty<'tcx>)\n+                         -> Ty<'tcx> {\n+        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected);\n+        if let Some(mut err) = err {\n             err.emit();\n         }\n+        ty\n     }\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n@@ -88,61 +94,64 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce_diag(&self,\n                               expr: &hir::Expr,\n                               checked_ty: Ty<'tcx>,\n-                              expected: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n+                              expected: Ty<'tcx>)\n+                              -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n \n-        if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n-            let cause = self.misc(expr.span);\n-            let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n+        let e = match self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n+            Ok(ty) => return (ty, None),\n+            Err(e) => e\n+        };\n \n-            // If the expected type is an enum with any variants whose sole\n-            // field is of the found type, suggest such variants. See Issue\n-            // #42764.\n-            if let ty::TyAdt(expected_adt, substs) = expected.sty {\n-                let mut compatible_variants = vec![];\n-                for variant in &expected_adt.variants {\n-                    if variant.fields.len() == 1 {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let mut variant_path = self.tcx.item_path_str(variant.did);\n-                            variant_path = variant_path.trim_left_matches(\"std::prelude::v1::\")\n-                                .to_string();\n-                            compatible_variants.push(variant_path);\n-                        }\n+        let cause = self.misc(expr.span);\n+        let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n+        let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n+\n+        // If the expected type is an enum with any variants whose sole\n+        // field is of the found type, suggest such variants. See Issue\n+        // #42764.\n+        if let ty::TyAdt(expected_adt, substs) = expected.sty {\n+            let mut compatible_variants = vec![];\n+            for variant in &expected_adt.variants {\n+                if variant.fields.len() == 1 {\n+                    let sole_field = &variant.fields[0];\n+                    let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                    if self.can_coerce(expr_ty, sole_field_ty) {\n+                        let mut variant_path = self.tcx.item_path_str(variant.did);\n+                        variant_path = variant_path.trim_left_matches(\"std::prelude::v1::\")\n+                            .to_string();\n+                        compatible_variants.push(variant_path);\n                     }\n                 }\n-                if !compatible_variants.is_empty() {\n-                    let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n-                    let suggestions = compatible_variants.iter()\n-                        .map(|v| format!(\"{}({})\", v, expr_text)).collect::<Vec<_>>();\n-                    err.span_suggestions(expr.span,\n-                                         \"try using a variant of the expected type\",\n-                                         suggestions);\n-                }\n             }\n+            if !compatible_variants.is_empty() {\n+                let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n+                let suggestions = compatible_variants.iter()\n+                    .map(|v| format!(\"{}({})\", v, expr_text)).collect::<Vec<_>>();\n+                err.span_suggestions(expr.span,\n+                                     \"try using a variant of the expected type\",\n+                                     suggestions);\n+            }\n+        }\n \n-            if let Some(suggestion) = self.check_ref(expr,\n-                                                     checked_ty,\n-                                                     expected) {\n-                err.help(&suggestion);\n-            } else {\n-                let mode = probe::Mode::MethodCall;\n-                let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n-                                                             mode,\n-                                                             expected,\n-                                                             checked_ty,\n-                                                             ast::DUMMY_NODE_ID);\n-                if suggestions.len() > 0 {\n-                    err.help(&format!(\"here are some functions which \\\n-                                       might fulfill your needs:\\n{}\",\n-                                      self.get_best_match(&suggestions).join(\"\\n\")));\n-                }\n+        if let Some(suggestion) = self.check_ref(expr,\n+                                                 checked_ty,\n+                                                 expected) {\n+            err.help(&suggestion);\n+        } else {\n+            let mode = probe::Mode::MethodCall;\n+            let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                         mode,\n+                                                         expected,\n+                                                         checked_ty,\n+                                                         ast::DUMMY_NODE_ID);\n+            if suggestions.len() > 0 {\n+                err.help(&format!(\"here are some functions which \\\n+                                   might fulfill your needs:\\n{}\",\n+                                  self.get_best_match(&suggestions).join(\"\\n\")));\n             }\n-            return Some(err);\n         }\n-        None\n+        (expected, Some(err))\n     }\n \n     fn format_method_suggestion(&self, method: &AssociatedItem) -> String {"}, {"sha": "26f7a7a37847768f98bfcee1940dd788fb42cca8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -2755,9 +2755,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_coercable_to_type(&self,\n                                     expr: &'gcx hir::Expr,\n                                     expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.check_expr_with_hint(expr, expected);\n-        self.demand_coerce(expr, ty, expected);\n-        ty\n+        self.check_expr_coercable_to_type_with_lvalue_pref(expr, expected, NoPreference)\n+    }\n+\n+    fn check_expr_coercable_to_type_with_lvalue_pref(&self,\n+                                                     expr: &'gcx hir::Expr,\n+                                                     expected: Ty<'tcx>,\n+                                                     lvalue_pref: LvaluePreference)\n+                                                     -> Ty<'tcx> {\n+        let ty = self.check_expr_with_expectation_and_lvalue_pref(\n+            expr,\n+            ExpectHasType(expected),\n+            lvalue_pref);\n+        self.demand_coerce(expr, ty, expected)\n     }\n \n     fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,"}, {"sha": "2d45f797ecb4d02612d2cfb137c3f197a75e5e29", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -12,7 +12,7 @@\n \n use super::FnCtxt;\n use super::method::MethodCallee;\n-use rustc::ty::{self, Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n+use rustc::ty::{self, Ty, TypeFoldable, NoPreference, PreferMutLvalue, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer::type_variable::TypeVariableOrigin;\n@@ -29,12 +29,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               lhs_expr: &'gcx hir::Expr,\n                               rhs_expr: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        let lhs_ty = self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n-\n-        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n-        let (rhs_ty, return_ty) =\n-            self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n-        let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n+        let (lhs_ty, rhs_ty, return_ty) =\n+            self.check_overloaded_binop(expr, lhs_expr, rhs_expr, op, IsAssign::Yes);\n \n         let ty = if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var()\n                     && is_builtin_binop(lhs_ty, rhs_ty, op) {\n@@ -73,27 +69,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                lhs_expr,\n                rhs_expr);\n \n-        let lhs_ty = self.check_expr(lhs_expr);\n-        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n-\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n+                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool);\n                 let lhs_diverges = self.diverges.get();\n-                self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-                self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n+                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool);\n \n                 // Depending on the LHS' value, the RHS can never execute.\n                 self.diverges.set(lhs_diverges);\n \n-                tcx.mk_bool()\n+                tcx.types.bool\n             }\n             _ => {\n                 // Otherwise, we always treat operators as if they are\n                 // overloaded. This is the way to be most flexible w/r/t\n                 // types that get inferred.\n-                let (rhs_ty, return_ty) =\n-                    self.check_overloaded_binop(expr, lhs_expr, lhs_ty,\n+                let (lhs_ty, rhs_ty, return_ty) =\n+                    self.check_overloaded_binop(expr, lhs_expr,\n                                                 rhs_expr, op, IsAssign::No);\n \n                 // Supply type inference hints if relevant. Probably these\n@@ -108,7 +101,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // deduce that the result type should be `u32`, even\n                 // though we don't know yet what type 2 has and hence\n                 // can't pin this down to a specific impl.\n-                let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n                 if\n                     !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n                     is_builtin_binop(lhs_ty, rhs_ty, op)\n@@ -164,17 +156,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_overloaded_binop(&self,\n                               expr: &'gcx hir::Expr,\n                               lhs_expr: &'gcx hir::Expr,\n-                              lhs_ty: Ty<'tcx>,\n                               rhs_expr: &'gcx hir::Expr,\n                               op: hir::BinOp,\n                               is_assign: IsAssign)\n-                              -> (Ty<'tcx>, Ty<'tcx>)\n+                              -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>)\n     {\n-        debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, is_assign={:?})\",\n+        debug!(\"check_overloaded_binop(expr.id={}, op={:?}, is_assign={:?})\",\n                expr.id,\n-               lhs_ty,\n+               op,\n                is_assign);\n \n+        let lhs_pref = match is_assign {\n+            IsAssign::Yes => PreferMutLvalue,\n+            IsAssign::No => NoPreference\n+        };\n+        // Find a suitable supertype of the LHS expression's type, by coercing to\n+        // a type variable, to pass as the `Self` to the trait, avoiding invariant\n+        // trait matching creating lifetime constraints that are too strict.\n+        // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n+        // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n+        let lhs_ty = self.check_expr_coercable_to_type_with_lvalue_pref(lhs_expr,\n+            self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n+            lhs_pref);\n+        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n+\n         // NB: As we have not yet type-checked the RHS, we don't have the\n         // type at hand. Make a variable to represent it. The whole reason\n         // for this indirection is so that, below, we can check the expr\n@@ -187,6 +192,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {\n             Ok(method) => {\n@@ -296,7 +302,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        (rhs_ty_var, return_ty)\n+        (lhs_ty, rhs_ty, return_ty)\n     }\n \n     fn check_str_addition(&self,"}, {"sha": "89f11edaec8622d5c6a6212f677c3823bbce6c55", "filename": "src/test/compile-fail/issue-41394.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -10,7 +10,7 @@\n \n enum Foo {\n     A = \"\" + 1\n-    //~^ ERROR binary operation `+` cannot be applied to type `&'static str`\n+    //~^ ERROR binary operation `+` cannot be applied to type `&str`\n }\n \n enum Bar {"}, {"sha": "efbc49fbece920f3b34c91f26dedab1762fe492d", "filename": "src/test/run-fail/binop-fail-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Frun-fail%2Fbinop-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Frun-fail%2Fbinop-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-3.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -12,6 +12,8 @@\n fn foo() -> ! {\n     panic!(\"quux\");\n }\n+\n+#[allow(resolve_trait_on_defaulted_unit)]\n fn main() {\n     foo() == foo(); // these types wind up being defaulted to ()\n }"}, {"sha": "cb489acf1d919d81ba6214162a75aeb79280bf77", "filename": "src/test/run-pass/issue-32008.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Frun-pass%2Fissue-32008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Frun-pass%2Fissue-32008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-32008.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that binary operators allow subtyping on both the LHS and RHS,\n+// and as such do not introduce unnecesarily strict lifetime constraints.\n+\n+use std::ops::Add;\n+\n+struct Foo;\n+\n+impl<'a> Add<&'a Foo> for &'a Foo {\n+    type Output = ();\n+    fn add(self, rhs: &'a Foo) {}\n+}\n+\n+fn try_to_add(input: &Foo) {\n+    let local = Foo;\n+\n+    // Manual reborrow worked even with invariant trait search.\n+    &*input + &local;\n+\n+    // Direct use of the reference on the LHS requires additional\n+    // subtyping before searching (invariantly) for `LHS: Add<RHS>`.\n+    input + &local;\n+}\n+\n+fn main() {\n+}"}, {"sha": "06ffa6b3dea93f5dcc26a1abcbd2b432e29105a6", "filename": "src/test/run-pass/issue-45425.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Frun-pass%2Fissue-45425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Frun-pass%2Fissue-45425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-45425.rs?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Add;\n+\n+fn ref_add<T>(a: &T, b: &T) -> T\n+where\n+    for<'x> &'x T: Add<&'x T, Output = T>,\n+{\n+    a + b\n+}\n+\n+fn main() {}"}, {"sha": "2782753f6c8e9f7ab3002e7c82a4db852dea6c47", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f581cf9d692781847bede5d966b098a5d09b5e4/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=2f581cf9d692781847bede5d966b098a5d09b5e4", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&'static str`\n+error[E0369]: binary operation `+` cannot be applied to type `&str`\n   --> $DIR/issue-39018.rs:12:13\n    |\n 12 |     let x = \"Hello \" + \"World!\";"}]}