{"sha": "188167c4b3ab42f1d0dc793365819afe28719df5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ODE2N2M0YjNhYjQyZjFkMGRjNzkzMzY1ODE5YWZlMjg3MTlkZjU=", "commit": {"author": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2014-01-11T23:47:30Z"}, "committer": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2014-01-11T23:47:30Z"}, "message": "Introduced a chapter that describes how to perform callbacks from C to Rust", "tree": {"sha": "1b053c64f097dcb9a3721cd5674316844a5382fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b053c64f097dcb9a3721cd5674316844a5382fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/188167c4b3ab42f1d0dc793365819afe28719df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/188167c4b3ab42f1d0dc793365819afe28719df5", "html_url": "https://github.com/rust-lang/rust/commit/188167c4b3ab42f1d0dc793365819afe28719df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/188167c4b3ab42f1d0dc793365819afe28719df5/comments", "author": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e866339126df3806f9cae95f2b91d38abaab32", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e866339126df3806f9cae95f2b91d38abaab32", "html_url": "https://github.com/rust-lang/rust/commit/33e866339126df3806f9cae95f2b91d38abaab32"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "4387d5d764e295a83da0e913f13a0874d3ce9679", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/188167c4b3ab42f1d0dc793365819afe28719df5/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/188167c4b3ab42f1d0dc793365819afe28719df5/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=188167c4b3ab42f1d0dc793365819afe28719df5", "patch": "@@ -249,6 +249,175 @@ fn main() {\n }\n ~~~~\n \n+# Callbacks from C code to Rust functions\n+\n+Some external libraries require the usage of callbacks. \n+E.g. because they start background threads and use callbacks to signal events\n+like the availability of new data.\n+It is possible to pass functions defined in Rust to an external library.\n+The requirement for this is that the callback function is marked as `extern`\n+with the correct calling convention to make it callable from C code.\n+\n+The callback function that can then be sent to through a registration call\n+to the C library and afterwards be invoked from there.\n+\n+A basic example is:\n+\n+Rust code:\n+~~~~\n+extern \"C\" fn callback(a:i32) {\n+    println!(\"I'm called from C with value {0}\", a);\n+}\n+\n+#[link(name = \"extlib\")]\n+extern {\n+   fn register_callback(cb: extern \"C\" fn(i32)) -> i32;\n+}\n+\n+fn main() {\n+    unsafe {\n+        register_callback(callback);\n+    }\n+    ... // Do sth. and wait for callbacks\n+}\n+~~~~\n+\n+C-Code:\n+~~~~\n+typedef void (*rust_callback)(int32_t);\n+rust_callback cb;\n+\n+int32_t register_callback(rust_callback callback) {\n+    cb = callback;\n+    return 1;\n+}\n+\n+void thread() {\n+  // do sth\n+  cb(7); // Will call callback(7) in Rust\n+}\n+~~~~\n+\n+Keep in mind that `callback()` will be called from a C thread and not from\n+a Rust thread or even your main thread. Therefore each data access is\n+especially unsafe and synchronization mechanisms must be used.\n+\n+## Targetting callbacks to Rust objects\n+\n+The former example showed how a global function can be called from C-Code.\n+However it is often desired that the callback is targetted to a special\n+Rust object. This could be the object that represents the wrapper for the\n+respective C object. \n+\n+This can be achieved by passing an unsafe pointer to the object down to the\n+C library. The C library can then include the pointer to the Rust object in\n+the notification. This will provide a unsafe possibility to access the \n+referenced Rust object in callback.\n+\n+If this mechanism is used it is absolutely necessary that no more callbacks\n+are performed  by C library after the respective Rust object get's\n+destroyed. This can be achieved by unregistering the callback it the object's\n+destructor and designing the library in a way that guarantees that no\n+callback will be performed after unregistration.\n+\n+## Sychronzing callbacks with channels\n+\n+As already explained accessing data of a Rust object in a callback is unsafe\n+without synchronisation. Channels in Rust provide a mechanism\n+which can be used to forward events into Rust tasks. The idea is to create a\n+channel where the writing end (`Chan`) is used exclusively from the C callback\n+to queue events. The reading end (`Port`) is used in the Rust task which owns\n+the wrapper object.\n+\n+Putting this together a wrapper for a library that uses a background thread\n+that sends events could look like:\n+\n+Rust code:\n+~~~~\n+\n+#[link(name = \"extlib\")]\n+extern {\n+   fn init(target: *ExtLibWrapper, cb: extern \"C\" fn(*ExtLibWrapper, EventData));\n+   fn unregister();\n+}\n+\n+struct EventData {\n+    ... // Contains data that describes the event\n+}\n+\n+pub struct ExtLibWrapper {\n+    // Channel is used privately\n+    priv chan: comm::Chan<EventData>,\n+    \n+    // The port is used by the Rust task to receive notifications\n+    port: comm::Port<EventData>\n+}\n+\n+impl ExtLibWrapper {\n+    pub fn new() -> ~ EventData {\n+        let (p,c):(Port<EventData>,Chan<EventData>) \n+                = comm::Chan::new();\n+\n+        let wrapper = ~ExtLibWrapper{chan:c, port:p};\n+\n+        unsafe {\n+            let wrapper_addr:*ExtLibWrapper = ptr::to_unsafe_ptr(wrapper);\n+            init(wrapper_addr, callback);\n+        }\n+    }\n+}\n+\n+impl Drop for ExtLibWrapper {\n+    fn drop(&mut self) {\n+        // Unregister to avoid further callbacks\n+        unsafe { unregister(); }\n+    }\n+}\n+\n+extern \"C\" fn callback(target: *ExtLibWrapper, data: EventData) {\n+    unsafe  {\n+        (*target).chan.send(data); // Forward the event data through channel\n+    }\n+}\n+~~~~\n+\n+C-Code:\n+~~~~\n+typedef void (*rust_callback)(void* target, EventData data);\n+void* rust_target;\n+rust_callback cb;\n+mutex mtx; // Example mutex\n+\n+void init(void* target, rust_callback callback) {\n+    rust_target = target;\n+    cb = callback;\n+}\n+\n+void background_thread() {\n+    // do sth\n+  \n+    // Lock the mutex to guarantee that callback is not performed after Rust\n+    // object is destroyed\n+    mutex_lock(mtx); \n+    if (rust_target != 0) cb(rust_target, event_data);\n+    mutex_unlock(mtx);\n+  \n+    // do sth\n+}\n+\n+void unregister() {\n+    mutex_lock(mtx);\n+    rust_target = 0;\n+    mutex_unlock(mtx);\n+}\n+~~~~\n+\n+Remark: This example will not work correctly if more than a single \n+`ExtLibWrapper` object is created. If this is required additional handles\n+have to be introduced which identify each object. E.g. `ExtLibWrapper` would\n+have to store the member of the associated C object as member and pass it\n+on each function call.\n+\n # Linking\n \n The `link` attribute on `extern` blocks provides the basic building block for"}]}