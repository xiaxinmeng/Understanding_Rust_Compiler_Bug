{"sha": "36695a37c52a0e6cc582247a506ab0b3c764b48f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2Njk1YTM3YzUyYTBlNmNjNTgyMjQ3YTUwNmFiMGIzYzc2NGI0OGY=", "commit": {"author": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2017-12-31T16:40:34Z"}, "committer": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2018-01-30T23:22:19Z"}, "message": "Implement extensible syscall interface for wasm", "tree": {"sha": "4d445b84a19f743550725e4f87373ff5bffae921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d445b84a19f743550725e4f87373ff5bffae921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36695a37c52a0e6cc582247a506ab0b3c764b48f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36695a37c52a0e6cc582247a506ab0b3c764b48f", "html_url": "https://github.com/rust-lang/rust/commit/36695a37c52a0e6cc582247a506ab0b3c764b48f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36695a37c52a0e6cc582247a506ab0b3c764b48f/comments", "author": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "def3269a71be2e737cad27418a3dad9f5bd6cd32", "url": "https://api.github.com/repos/rust-lang/rust/commits/def3269a71be2e737cad27418a3dad9f5bd6cd32", "html_url": "https://github.com/rust-lang/rust/commit/def3269a71be2e737cad27418a3dad9f5bd6cd32"}], "stats": {"total": 544, "additions": 346, "deletions": 198}, "files": [{"sha": "69647f37eecc6a8e98334bb13eb78d6fe06234ba", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 84, "deletions": 65, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -28,14 +28,76 @@ let m = new WebAssembly.Module(buffer);\n \n let memory = null;\n \n+function viewstruct(data, fields) {\n+  return new Uint32Array(memory.buffer).subarray(data/4, data/4 + fields);\n+}\n+\n function copystr(a, b) {\n-  if (memory === null) {\n-    return null\n-  }\n-  let view = new Uint8Array(memory.buffer).slice(a, a + b);\n+  let view = new Uint8Array(memory.buffer).subarray(a, a + b);\n   return String.fromCharCode.apply(null, view);\n }\n \n+function syscall_write([fd, ptr, len]) {\n+  let s = copystr(ptr, len);\n+  switch (fd) {\n+    case 1: process.stdout.write(s); break;\n+    case 2: process.stderr.write(s); break;\n+  }\n+}\n+\n+function syscall_exit([code]) {\n+  process.exit(code);\n+}\n+\n+function syscall_args(params) {\n+  let [ptr, len] = params;\n+\n+  // Calculate total required buffer size\n+  let totalLen = -1;\n+  for (let i = 2; i < process.argv.length; ++i) {\n+    totalLen += Buffer.byteLength(process.argv[i]) + 1;\n+  }\n+  if (totalLen < 0) { totalLen = 0; }\n+  params[2] = totalLen;\n+\n+  // If buffer is large enough, copy data\n+  if (len >= totalLen) {\n+    let view = new Uint8Array(memory.buffer);\n+    for (let i = 2; i < process.argv.length; ++i) {\n+      let value = process.argv[i];\n+      Buffer.from(value).copy(view, ptr);\n+      ptr += Buffer.byteLength(process.argv[i]) + 1;\n+    }\n+  }\n+}\n+\n+function syscall_getenv(params) {\n+  let [keyPtr, keyLen, valuePtr, valueLen] = params;\n+\n+  let key = copystr(keyPtr, keyLen);\n+  let value = process.env[key];\n+\n+  if (value == null) {\n+    params[4] = 0xFFFFFFFF;\n+  } else {\n+    let view = new Uint8Array(memory.buffer);\n+    let totalLen = Buffer.byteLength(value);\n+    params[4] = totalLen;\n+    if (valueLen >= totalLen) {\n+      Buffer.from(value).copy(view, valuePtr);\n+    }\n+  }\n+}\n+\n+function syscall_time(params) {\n+  let t = Date.now();\n+  let secs = Math.floor(t / 1000);\n+  let millis = t % 1000;\n+  params[1] = Math.floor(secs / 0x100000000);\n+  params[2] = secs % 0x100000000;\n+  params[3] = Math.floor(millis * 1000000);\n+}\n+\n let imports = {};\n imports.env = {\n   // These are generated by LLVM itself for various intrinsic calls. Hopefully\n@@ -48,68 +110,25 @@ imports.env = {\n   log10: Math.log10,\n   log10f: Math.log10,\n \n-  // These are called in src/libstd/sys/wasm/stdio.rs and are used when\n-  // debugging is enabled.\n-  rust_wasm_write_stdout: function(a, b) {\n-    let s = copystr(a, b);\n-    if (s !== null) {\n-      process.stdout.write(s);\n-    }\n-  },\n-  rust_wasm_write_stderr: function(a, b) {\n-    let s = copystr(a, b);\n-    if (s !== null) {\n-      process.stderr.write(s);\n-    }\n-  },\n-\n-  // These are called in src/libstd/sys/wasm/args.rs and are used when\n-  // debugging is enabled.\n-  rust_wasm_args_count: function() {\n-    if (memory === null)\n-      return 0;\n-    return process.argv.length - 2;\n-  },\n-  rust_wasm_args_arg_size: function(i) {\n-    return Buffer.byteLength(process.argv[i + 2]);\n-  },\n-  rust_wasm_args_arg_fill: function(idx, ptr) {\n-    let arg = process.argv[idx + 2];\n-    let view = new Uint8Array(memory.buffer);\n-    Buffer.from(arg).copy(view, ptr);\n-  },\n-\n-  // These are called in src/libstd/sys/wasm/os.rs and are used when\n-  // debugging is enabled.\n-  rust_wasm_getenv_len: function(a, b) {\n-    let key = copystr(a, b);\n-    if (key === null) {\n-      return -1;\n+  rust_wasm_syscall: function(index, data) {\n+    switch (index) {\n+      case 1: syscall_write(viewstruct(data, 3)); return true;\n+      case 2: syscall_exit(viewstruct(data, 1)); return true;\n+      case 3: syscall_args(viewstruct(data, 3)); return true;\n+      case 4: syscall_getenv(viewstruct(data, 5)); return true;\n+      case 6: syscall_time(viewstruct(data, 4)); return true;\n+      default:\n+        console.log(\"Unsupported syscall: \" + index);\n+        return false;\n     }\n-    if (!(key in process.env)) {\n-      return -1;\n-    }\n-    return Buffer.byteLength(process.env[key]);\n-  },\n-  rust_wasm_getenv_data: function(a, b, ptr) {\n-    let key = copystr(a, b);\n-    let value = process.env[key];\n-    let view = new Uint8Array(memory.buffer);\n-    Buffer.from(value).copy(view, ptr);\n-  },\n-};\n-\n-let module_imports = WebAssembly.Module.imports(m);\n-\n-for (var i = 0; i < module_imports.length; i++) {\n-  let imp = module_imports[i];\n-  if (imp.module != 'env') {\n-    continue\n   }\n-  if (imp.name == 'memory' && imp.kind == 'memory') {\n-    memory = new WebAssembly.Memory({initial: 20});\n-    imports.env.memory = memory;\n-  }\n-}\n+};\n \n let instance = new WebAssembly.Instance(m, imports);\n+memory = instance.exports.memory;\n+try {\n+  instance.exports.main();\n+} catch (e) {\n+  console.error(e);\n+  process.exit(101);\n+}"}, {"sha": "206c73b017459b077b05dd78a719fc242113d806", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -824,9 +824,7 @@ fn binaryen_assemble(cgcx: &CodegenContext,\n     if cgcx.debuginfo != config::NoDebugInfo {\n         options.debuginfo(true);\n     }\n-    if cgcx.crate_types.contains(&config::CrateTypeExecutable) {\n-        options.start(\"main\");\n-    }\n+\n     options.stack(1024 * 1024);\n     options.import_memory(cgcx.wasm_import_memory);\n     let assembled = input.and_then(|input| {\n@@ -1452,7 +1450,7 @@ fn start_executing_work(tcx: TyCtxt,\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n         binaryen_linker: tcx.sess.linker_flavor() == LinkerFlavor::Binaryen,\n         debuginfo: tcx.sess.opts.debuginfo,\n-        wasm_import_memory: wasm_import_memory,\n+        wasm_import_memory,\n         assembler_cmd,\n     };\n "}, {"sha": "c1fe4a89d6ac0f9a750a49727cab3be1c4514321", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -48,3 +48,4 @@ jemalloc = [\"alloc_jemalloc\"]\n force_alloc_system = []\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n+wasm_syscall = []"}, {"sha": "b3c6b671e809949c9bca2b0d43bdc68999f42a5e", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -10,8 +10,8 @@\n \n use ffi::OsString;\n use marker::PhantomData;\n-use mem;\n use vec;\n+use sys::ArgsSysCall;\n \n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     // On wasm these should always be null, so there's nothing for us to do here\n@@ -21,38 +21,10 @@ pub unsafe fn cleanup() {\n }\n \n pub fn args() -> Args {\n-    // When the runtime debugging is enabled we'll link to some extra runtime\n-    // functions to actually implement this. These are for now just implemented\n-    // in a node.js script but they're off by default as they're sort of weird\n-    // in a web-wasm world.\n-    if !super::DEBUG {\n-        return Args {\n-            iter: Vec::new().into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n-    }\n-\n-    // You'll find the definitions of these in `src/etc/wasm32-shim.js`. These\n-    // are just meant for debugging and should not be relied on.\n-    extern {\n-        fn rust_wasm_args_count() -> usize;\n-        fn rust_wasm_args_arg_size(a: usize) -> usize;\n-        fn rust_wasm_args_arg_fill(a: usize, ptr: *mut u8);\n-    }\n-\n-    unsafe {\n-        let cnt = rust_wasm_args_count();\n-        let mut v = Vec::with_capacity(cnt);\n-        for i in 0..cnt {\n-            let n = rust_wasm_args_arg_size(i);\n-            let mut data = vec![0; n];\n-            rust_wasm_args_arg_fill(i, data.as_mut_ptr());\n-            v.push(mem::transmute::<Vec<u8>, OsString>(data));\n-        }\n-        Args {\n-            iter: v.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n+    let v = ArgsSysCall::perform();\n+    Args {\n+        iter: v.into_iter(),\n+        _dont_send_or_sync_me: PhantomData,\n     }\n }\n "}, {"sha": "c02e5e809c8bb33cb81553eec35607420553fbd4", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 221, "deletions": 12, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -26,17 +26,11 @@\n \n use io;\n use os::raw::c_char;\n-\n-// Right now the wasm backend doesn't even have the ability to print to the\n-// console by default. Wasm can't import anything from JS! (you have to\n-// explicitly provide it).\n-//\n-// Sometimes that's a real bummer, though, so this flag can be set to `true` to\n-// enable calling various shims defined in `src/etc/wasm32-shim.js` which should\n-// help receive debug output and see what's going on. In general this flag\n-// currently controls \"will we call out to our own defined shims in node.js\",\n-// and this flag should always be `false` for release builds.\n-const DEBUG: bool = false;\n+use ptr;\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, FromInner};\n+use ffi::{OsString, OsStr};\n+use time::Duration;\n \n pub mod args;\n #[cfg(feature = \"backtrace\")]\n@@ -92,7 +86,7 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    ::intrinsics::abort();\n+    ExitSysCall::perform(1)\n }\n \n // We don't have randomness yet, but I totally used a random number generator to\n@@ -103,3 +97,218 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     (1, 2)\n }\n+\n+// Implement a minimal set of system calls to enable basic IO\n+pub enum SysCallIndex {\n+    Read = 0,\n+    Write = 1,\n+    Exit = 2,\n+    Args = 3,\n+    GetEnv = 4,\n+    SetEnv = 5,\n+    Time = 6,\n+}\n+\n+#[repr(C)]\n+pub struct ReadSysCall {\n+    fd: usize,\n+    ptr: *mut u8,\n+    len: usize,\n+    result: usize,\n+}\n+\n+impl ReadSysCall {\n+    pub fn perform(fd: usize, buffer: &mut [u8]) -> usize {\n+        let mut call_record = ReadSysCall {\n+            fd,\n+            len: buffer.len(),\n+            ptr: buffer.as_mut_ptr(),\n+            result: 0\n+        };\n+        if unsafe { syscall(SysCallIndex::Read, &mut call_record) } {\n+            call_record.result\n+        } else {\n+            0\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct WriteSysCall {\n+    fd: usize,\n+    ptr: *const u8,\n+    len: usize,\n+}\n+\n+impl WriteSysCall {\n+    pub fn perform(fd: usize, buffer: &[u8]) {\n+        let mut call_record = WriteSysCall {\n+            fd,\n+            len: buffer.len(),\n+            ptr: buffer.as_ptr()\n+        };\n+        unsafe { syscall(SysCallIndex::Write, &mut call_record); }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct ExitSysCall {\n+    code: usize,\n+}\n+\n+impl ExitSysCall {\n+    pub fn perform(code: usize) -> ! {\n+        let mut call_record = ExitSysCall {\n+            code\n+        };\n+        unsafe {\n+            syscall(SysCallIndex::Exit, &mut call_record);\n+            ::intrinsics::abort();\n+        }\n+    }\n+}\n+\n+fn receive_buffer<E, F: FnMut(&mut [u8]) -> Result<usize, E>>(estimate: usize, mut f: F)\n+    -> Result<Vec<u8>, E>\n+{\n+    let mut buffer = vec![0; estimate];\n+    loop {\n+        let result = f(&mut buffer)?;\n+        if result <= buffer.len() {\n+            buffer.truncate(result);\n+            break;\n+        }\n+        buffer.resize(result, 0);\n+    }\n+    Ok(buffer)\n+}\n+\n+#[repr(C)]\n+pub struct ArgsSysCall {\n+    ptr: *mut u8,\n+    len: usize,\n+    result: usize\n+}\n+\n+impl ArgsSysCall {\n+    pub fn perform() -> Vec<OsString> {\n+        receive_buffer(1024, |buffer| -> Result<usize, !> {\n+            let mut call_record = ArgsSysCall {\n+                len: buffer.len(),\n+                ptr: buffer.as_mut_ptr(),\n+                result: 0\n+            };\n+            if unsafe { syscall(SysCallIndex::Args, &mut call_record) } {\n+                Ok(call_record.result)\n+            } else {\n+                Ok(0)\n+            }\n+        })\n+            .unwrap()\n+            .split(|b| *b == 0)\n+            .map(|s| FromInner::from_inner(Buf { inner: s.to_owned() }))\n+            .collect()\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct GetEnvSysCall {\n+    key_ptr: *const u8,\n+    key_len: usize,\n+    value_ptr: *mut u8,\n+    value_len: usize,\n+    result: usize\n+}\n+\n+impl GetEnvSysCall {\n+    pub fn perform(key: &OsStr) -> Option<OsString> {\n+        let key_buf = &AsInner::as_inner(key).inner;\n+        receive_buffer(64, |buffer| {\n+            let mut call_record = GetEnvSysCall {\n+                key_len: key_buf.len(),\n+                key_ptr: key_buf.as_ptr(),\n+                value_len: buffer.len(),\n+                value_ptr: buffer.as_mut_ptr(),\n+                result: !0usize\n+            };\n+            if unsafe { syscall(SysCallIndex::GetEnv, &mut call_record) } {\n+                if call_record.result == !0usize {\n+                    Err(())\n+                } else {\n+                    Ok(call_record.result)\n+                }\n+            } else {\n+                Err(())\n+            }\n+        }).ok().map(|s| {\n+            FromInner::from_inner(Buf { inner: s })\n+        })\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct SetEnvSysCall {\n+    key_ptr: *const u8,\n+    key_len: usize,\n+    value_ptr: *const u8,\n+    value_len: usize\n+}\n+\n+impl SetEnvSysCall {\n+    pub fn perform(key: &OsStr, value: Option<&OsStr>) {\n+        let key_buf = &AsInner::as_inner(key).inner;\n+        let value_buf = value.map(|v| &AsInner::as_inner(v).inner);\n+        let mut call_record = SetEnvSysCall {\n+            key_len: key_buf.len(),\n+            key_ptr: key_buf.as_ptr(),\n+            value_len: value_buf.map(|v| v.len()).unwrap_or(!0usize),\n+            value_ptr: value_buf.map(|v| v.as_ptr()).unwrap_or(ptr::null())\n+        };\n+        unsafe { syscall(SysCallIndex::SetEnv, &mut call_record); }\n+    }\n+}\n+\n+pub enum TimeClock {\n+    Monotonic = 0,\n+    System = 1,\n+}\n+\n+#[repr(C)]\n+pub struct TimeSysCall {\n+    clock: usize,\n+    secs_hi: usize,\n+    secs_lo: usize,\n+    nanos: usize\n+}\n+\n+impl TimeSysCall {\n+    pub fn perform(clock: TimeClock) -> Duration {\n+        let mut call_record = TimeSysCall {\n+            clock: clock as usize,\n+            secs_hi: 0,\n+            secs_lo: 0,\n+            nanos: 0\n+        };\n+        if unsafe { syscall(SysCallIndex::Time, &mut call_record) } {\n+            Duration::new(\n+                ((call_record.secs_hi as u64) << 32) | (call_record.secs_lo as u64),\n+                call_record.nanos as u32\n+            )\n+        } else {\n+            panic!(\"Time system call is not implemented by WebAssembly host\");\n+        }\n+    }\n+}\n+\n+unsafe fn syscall<T>(index: SysCallIndex, data: &mut T) -> bool {\n+    #[cfg(feature = \"wasm_syscall\")]\n+    extern {\n+        #[no_mangle]\n+        fn rust_wasm_syscall(index: usize, data: *mut Void) -> usize;\n+    }\n+\n+    #[cfg(not(feature = \"wasm_syscall\"))]\n+    unsafe fn rust_wasm_syscall(_index: usize, _data: *mut Void) -> usize { 0 }\n+\n+    rust_wasm_syscall(index as usize, data as *mut T as *mut Void) != 0\n+}"}, {"sha": "23ca1754719be9905fcdb27e102710ca83277ccd", "filename": "src/libstd/sys/wasm/os.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::intrinsics;\n-\n use error::Error as StdError;\n use ffi::{OsString, OsStr};\n use fmt;\n use io;\n-use mem;\n use path::{self, PathBuf};\n use str;\n-use sys::{unsupported, Void};\n+use sys::{unsupported, Void, ExitSysCall, GetEnvSysCall, SetEnvSysCall};\n \n pub fn errno() -> i32 {\n     0\n@@ -87,36 +84,15 @@ pub fn env() -> Env {\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    // If we're debugging the runtime then we actually probe node.js to ask for\n-    // the value of environment variables to help provide inputs to programs.\n-    // The `extern` shims here are defined in `src/etc/wasm32-shim.js` and are\n-    // intended for debugging only, you should not rely on them.\n-    if !super::DEBUG {\n-        return Ok(None)\n-    }\n-\n-    extern {\n-        fn rust_wasm_getenv_len(k: *const u8, kl: usize) -> isize;\n-        fn rust_wasm_getenv_data(k: *const u8, kl: usize, v: *mut u8);\n-    }\n-    unsafe {\n-        let k: &[u8] = mem::transmute(k);\n-        let n = rust_wasm_getenv_len(k.as_ptr(), k.len());\n-        if n == -1 {\n-            return Ok(None)\n-        }\n-        let mut data = vec![0; n as usize];\n-        rust_wasm_getenv_data(k.as_ptr(), k.len(), data.as_mut_ptr());\n-        Ok(Some(mem::transmute(data)))\n-    }\n+    Ok(GetEnvSysCall::perform(k))\n }\n \n-pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {\n-    unsupported()\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    Ok(SetEnvSysCall::perform(k, Some(v)))\n }\n \n-pub fn unsetenv(_n: &OsStr) -> io::Result<()> {\n-    unsupported()\n+pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n+    Ok(SetEnvSysCall::perform(k, None))\n }\n \n pub fn temp_dir() -> PathBuf {\n@@ -128,7 +104,7 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(_code: i32) -> ! {\n-    unsafe { intrinsics::abort() }\n+    ExitSysCall::perform(_code as isize as usize)\n }\n \n pub fn getpid() -> u32 {"}, {"sha": "beb19c0ed2c1f62bd17b1611db911eb9a04eb7af", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n use io;\n-use sys::{Void, unsupported};\n+use sys::{ReadSysCall, WriteSysCall};\n \n-pub struct Stdin(Void);\n+pub struct Stdin;\n pub struct Stdout;\n pub struct Stderr;\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        unsupported()\n+        Ok(Stdin)\n     }\n \n-    pub fn read(&self, _data: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        Ok(ReadSysCall::perform(0, data))\n     }\n }\n \n@@ -31,19 +31,7 @@ impl Stdout {\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        // If runtime debugging is enabled at compile time we'll invoke some\n-        // runtime functions that are defined in our src/etc/wasm32-shim.js\n-        // debugging script. Note that this ffi function call is intended\n-        // *purely* for debugging only and should not be relied upon.\n-        if !super::DEBUG {\n-            return unsupported()\n-        }\n-        extern {\n-            fn rust_wasm_write_stdout(data: *const u8, len: usize);\n-        }\n-        unsafe {\n-            rust_wasm_write_stdout(data.as_ptr(), data.len())\n-        }\n+        WriteSysCall::perform(1, data);\n         Ok(data.len())\n     }\n \n@@ -58,16 +46,7 @@ impl Stderr {\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        // See comments in stdout for what's going on here.\n-        if !super::DEBUG {\n-            return unsupported()\n-        }\n-        extern {\n-            fn rust_wasm_write_stderr(data: *const u8, len: usize);\n-        }\n-        unsafe {\n-            rust_wasm_write_stderr(data.as_ptr(), data.len())\n-        }\n+        WriteSysCall::perform(2, data);\n         Ok(data.len())\n     }\n "}, {"sha": "e52435e63398f226e6cb735a431012f7eb0b3350", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36695a37c52a0e6cc582247a506ab0b3c764b48f/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=36695a37c52a0e6cc582247a506ab0b3c764b48f", "patch": "@@ -8,56 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fmt;\n use time::Duration;\n+use sys::{TimeSysCall, TimeClock};\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n-pub struct Instant;\n+pub struct Instant(Duration);\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct SystemTime;\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct SystemTime(Duration);\n \n-pub const UNIX_EPOCH: SystemTime = SystemTime;\n+pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n impl Instant {\n     pub fn now() -> Instant {\n-        panic!(\"not supported on web assembly\");\n+        Instant(TimeSysCall::perform(TimeClock::Monotonic))\n     }\n \n-    pub fn sub_instant(&self, _other: &Instant) -> Duration {\n-        panic!(\"can't sub yet\");\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        self.0 - other.0\n     }\n \n-    pub fn add_duration(&self, _other: &Duration) -> Instant {\n-        panic!(\"can't add yet\");\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant(self.0 + *other)\n     }\n \n-    pub fn sub_duration(&self, _other: &Duration) -> Instant {\n-        panic!(\"can't sub yet\");\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant(self.0 - *other)\n     }\n }\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        panic!(\"not supported on web assembly\");\n+        SystemTime(TimeSysCall::perform(TimeClock::System))\n     }\n \n-    pub fn sub_time(&self, _other: &SystemTime)\n+    pub fn sub_time(&self, other: &SystemTime)\n                     -> Result<Duration, Duration> {\n-        panic!()\n-    }\n-\n-    pub fn add_duration(&self, _other: &Duration) -> SystemTime {\n-        panic!()\n+        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n     }\n \n-    pub fn sub_duration(&self, _other: &Duration) -> SystemTime {\n-        panic!()\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime(self.0 + *other)\n     }\n-}\n \n-impl fmt::Debug for SystemTime {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        panic!()\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime(self.0 - *other)\n     }\n }"}]}