{"sha": "6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMTlhOGM3MWQ5Y2M0YzU4OWRmNDBjYzJhNTE0ZTlhYzg2N2Y2MjM=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-05-30T07:39:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-30T07:39:15Z"}, "message": "Merge pull request #3586 from topecongiro/issue-3584\n\nFormat trait aliases with where clauses", "tree": {"sha": "d2e151bf1efa29ca84dda6177ef6f9842322cd91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2e151bf1efa29ca84dda6177ef6f9842322cd91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc74ijCRBK7hj4Ov3rIwAAdHIIAJEX8G6W1Y9tYNsmnLSb5D76\nQatCTIsjp0YCNKYwTXCV7TjrEqpAubGwCgxCt4hkLky1ueVCKhFlLMfbhQHp2gnu\n5Nbtpte9BL/JVyo9bJCf9eWrfZtzNFPoIaptS+aN0IfcQD2cSNclrxFJDcN4q4wC\nVoNAb7e6Ul/EaMC3zqINxCy62TCF4O8uuYtm3qoRZMuWUtxZUsB6x6YaPlpcpdSf\nYOTtJ9OO6AyyMp7IzChWKYMSaEi6rdzY9dwJCcK8yALiiP/9pHLI6xoGGJpdbGaW\nzvd+jRN8I6xYooz/WZhykuHBIz/V25y2Yk6UuAlU3XgVkNHyTv3ZHXbtq2g8MXM=\n=Fj2p\n-----END PGP SIGNATURE-----\n", "payload": "tree d2e151bf1efa29ca84dda6177ef6f9842322cd91\nparent fbd9f335f9fa53f50da89d63571117b5bfe8e65d\nparent c1373b267ba8be93eee9626ea1ac876fa36dac67\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1559201955 +0200\ncommitter GitHub <noreply@github.com> 1559201955 +0200\n\nMerge pull request #3586 from topecongiro/issue-3584\n\nFormat trait aliases with where clauses"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "html_url": "https://github.com/rust-lang/rust/commit/6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd9f335f9fa53f50da89d63571117b5bfe8e65d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd9f335f9fa53f50da89d63571117b5bfe8e65d", "html_url": "https://github.com/rust-lang/rust/commit/fbd9f335f9fa53f50da89d63571117b5bfe8e65d"}, {"sha": "c1373b267ba8be93eee9626ea1ac876fa36dac67", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1373b267ba8be93eee9626ea1ac876fa36dac67", "html_url": "https://github.com/rust-lang/rust/commit/c1373b267ba8be93eee9626ea1ac876fa36dac67"}], "stats": {"total": 353, "additions": 283, "deletions": 70}, "files": [{"sha": "7640fa32d22ebc4440844bca42c2ca0e0d0ccf96", "filename": "src/items.rs", "status": "modified", "additions": 180, "deletions": 70, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "patch": "@@ -693,7 +693,7 @@ pub(crate) fn format_impl(\n         {\n             option.suppress_comma();\n             option.snuggle();\n-            option.compress_where();\n+            option.allow_single_line();\n         }\n \n         let misssing_span = mk_sp(self_ty.span.hi(), item.span.hi());\n@@ -708,7 +708,6 @@ pub(crate) fn format_impl(\n             where_span_end,\n             self_ty.span.hi(),\n             option,\n-            false,\n         )?;\n \n         // If there is no where-clause, we may have missing comments between the trait name and\n@@ -1068,7 +1067,6 @@ pub(crate) fn format_trait(\n                 None,\n                 pos_before_where,\n                 option,\n-                false,\n             )?;\n             // If the where-clause cannot fit on the same line,\n             // put the where-clause on a new line\n@@ -1156,6 +1154,45 @@ pub(crate) fn format_trait(\n     }\n }\n \n+pub(crate) struct TraitAliasBounds<'a> {\n+    generic_bounds: &'a ast::GenericBounds,\n+    generics: &'a ast::Generics,\n+}\n+\n+impl<'a> Rewrite for TraitAliasBounds<'a> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        let generic_bounds_str = self.generic_bounds.rewrite(context, shape)?;\n+\n+        let mut option = WhereClauseOption::new(true, WhereClauseSpace::None);\n+        option.allow_single_line();\n+\n+        let where_str = rewrite_where_clause(\n+            context,\n+            &self.generics.where_clause,\n+            context.config.brace_style(),\n+            shape,\n+            Density::Compressed,\n+            \";\",\n+            None,\n+            self.generics.where_clause.span.lo(),\n+            option,\n+        )?;\n+\n+        let fits_single_line = !generic_bounds_str.contains('\\n')\n+            && !where_str.contains('\\n')\n+            && generic_bounds_str.len() + where_str.len() + 1 <= shape.width;\n+        let space = if generic_bounds_str.is_empty() || where_str.is_empty() {\n+            Cow::from(\"\")\n+        } else if fits_single_line {\n+            Cow::from(\" \")\n+        } else {\n+            shape.indent.to_string_with_newline(&context.config)\n+        };\n+\n+        Some(format!(\"{}{}{}\", generic_bounds_str, space, where_str))\n+    }\n+}\n+\n pub(crate) fn format_trait_alias(\n     context: &RewriteContext<'_>,\n     ident: ast::Ident,\n@@ -1171,7 +1208,11 @@ pub(crate) fn format_trait_alias(\n     let vis_str = format_visibility(context, vis);\n     let lhs = format!(\"{}trait {} =\", vis_str, generics_str);\n     // 1 = \";\"\n-    rewrite_assign_rhs(context, lhs, generic_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n+    let trait_alias_bounds = TraitAliasBounds {\n+        generics,\n+        generic_bounds,\n+    };\n+    rewrite_assign_rhs(context, lhs, &trait_alias_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n }\n \n fn format_unit_struct(\n@@ -1376,7 +1417,7 @@ fn format_tuple_struct(\n             result.push_str(&generics_str);\n \n             let where_budget = context.budget(last_line_width(&result));\n-            let option = WhereClauseOption::new(true, false);\n+            let option = WhereClauseOption::new(true, WhereClauseSpace::Newline);\n             rewrite_where_clause(\n                 context,\n                 &generics.where_clause,\n@@ -1387,7 +1428,6 @@ fn format_tuple_struct(\n                 None,\n                 body_hi,\n                 option,\n-                false,\n             )?\n         }\n         None => \"\".to_owned(),\n@@ -1464,7 +1504,6 @@ fn rewrite_type_prefix(\n         None,\n         generics.span.hi(),\n         option,\n-        false,\n     )?;\n     result.push_str(&where_clause_str);\n \n@@ -2205,7 +2244,15 @@ fn rewrite_fn_base(\n \n     let is_args_multi_lined = arg_str.contains('\\n');\n \n-    let option = WhereClauseOption::new(!has_body, put_args_in_block && ret_str.is_empty());\n+    let space = if put_args_in_block && ret_str.is_empty() {\n+        WhereClauseSpace::Space\n+    } else {\n+        WhereClauseSpace::Newline\n+    };\n+    let mut option = WhereClauseOption::new(!has_body, space);\n+    if is_args_multi_lined {\n+        option.veto_single_line();\n+    }\n     let where_clause_str = rewrite_where_clause(\n         context,\n         where_clause,\n@@ -2216,7 +2263,6 @@ fn rewrite_fn_base(\n         Some(span.hi()),\n         pos_before_where,\n         option,\n-        is_args_multi_lined,\n     )?;\n     // If there are neither where-clause nor return type, we may be missing comments between\n     // args and `{`.\n@@ -2244,40 +2290,62 @@ fn rewrite_fn_base(\n     Some((result, force_new_line_for_brace))\n }\n \n+/// Kind of spaces to put before `where`.\n+#[derive(Copy, Clone)]\n+enum WhereClauseSpace {\n+    /// A single space.\n+    Space,\n+    /// A new line.\n+    Newline,\n+    /// Nothing.\n+    None,\n+}\n+\n #[derive(Copy, Clone)]\n struct WhereClauseOption {\n     suppress_comma: bool, // Force no trailing comma\n-    snuggle: bool,        // Do not insert newline before `where`\n-    compress_where: bool, // Try single line where-clause instead of vertical layout\n+    snuggle: WhereClauseSpace,\n+    allow_single_line: bool, // Try single line where-clause instead of vertical layout\n+    veto_single_line: bool,  // Disallow a single-line where-clause.\n }\n \n impl WhereClauseOption {\n-    fn new(suppress_comma: bool, snuggle: bool) -> WhereClauseOption {\n+    fn new(suppress_comma: bool, snuggle: WhereClauseSpace) -> WhereClauseOption {\n         WhereClauseOption {\n             suppress_comma,\n             snuggle,\n-            compress_where: false,\n+            allow_single_line: false,\n+            veto_single_line: false,\n         }\n     }\n \n     fn snuggled(current: &str) -> WhereClauseOption {\n         WhereClauseOption {\n             suppress_comma: false,\n-            snuggle: last_line_width(current) == 1,\n-            compress_where: false,\n+            snuggle: if last_line_width(current) == 1 {\n+                WhereClauseSpace::Space\n+            } else {\n+                WhereClauseSpace::Newline\n+            },\n+            allow_single_line: false,\n+            veto_single_line: false,\n         }\n     }\n \n     fn suppress_comma(&mut self) {\n         self.suppress_comma = true\n     }\n \n-    fn compress_where(&mut self) {\n-        self.compress_where = true\n+    fn allow_single_line(&mut self) {\n+        self.allow_single_line = true\n     }\n \n     fn snuggle(&mut self) {\n-        self.snuggle = true\n+        self.snuggle = WhereClauseSpace::Space\n+    }\n+\n+    fn veto_single_line(&mut self) {\n+        self.veto_single_line = true;\n     }\n }\n \n@@ -2467,25 +2535,104 @@ fn rewrite_where_clause_rfc_style(\n     span_end: Option<BytePos>,\n     span_end_before_where: BytePos,\n     where_clause_option: WhereClauseOption,\n-    is_args_multi_line: bool,\n ) -> Option<String> {\n+    let (where_keyword, allow_single_line) = rewrite_where_keyword(\n+        context,\n+        where_clause,\n+        shape,\n+        span_end_before_where,\n+        where_clause_option,\n+    )?;\n+\n+    // 1 = `,`\n+    let clause_shape = shape\n+        .block()\n+        .with_max_width(context.config)\n+        .block_left(context.config.tab_spaces())?\n+        .sub_width(1)?;\n+    let force_single_line = context.config.where_single_line()\n+        && where_clause.predicates.len() == 1\n+        && !where_clause_option.veto_single_line;\n+\n+    let preds_str = rewrite_bounds_on_where_clause(\n+        context,\n+        where_clause,\n+        clause_shape,\n+        terminator,\n+        span_end,\n+        where_clause_option,\n+        force_single_line,\n+    )?;\n+\n+    // 6 = `where `\n+    let clause_sep =\n+        if allow_single_line && !preds_str.contains('\\n') && 6 + preds_str.len() <= shape.width\n+            || force_single_line\n+        {\n+            Cow::from(\" \")\n+        } else {\n+            clause_shape.indent.to_string_with_newline(context.config)\n+        };\n+\n+    Some(format!(\"{}{}{}\", where_keyword, clause_sep, preds_str))\n+}\n+\n+/// Rewrite `where` and comment around it.\n+fn rewrite_where_keyword(\n+    context: &RewriteContext<'_>,\n+    where_clause: &ast::WhereClause,\n+    shape: Shape,\n+    span_end_before_where: BytePos,\n+    where_clause_option: WhereClauseOption,\n+) -> Option<(String, bool)> {\n     let block_shape = shape.block().with_max_width(context.config);\n+    // 1 = `,`\n+    let clause_shape = block_shape\n+        .block_left(context.config.tab_spaces())?\n+        .sub_width(1)?;\n+\n+    let comment_separator = |comment: &str, shape: Shape| {\n+        if comment.is_empty() {\n+            Cow::from(\"\")\n+        } else {\n+            shape.indent.to_string_with_newline(context.config)\n+        }\n+    };\n \n     let (span_before, span_after) =\n         missing_span_before_after_where(span_end_before_where, where_clause);\n     let (comment_before, comment_after) =\n         rewrite_comments_before_after_where(context, span_before, span_after, shape)?;\n \n-    let starting_newline = if where_clause_option.snuggle && comment_before.is_empty() {\n-        Cow::from(\" \")\n-    } else {\n-        block_shape.indent.to_string_with_newline(context.config)\n+    let starting_newline = match where_clause_option.snuggle {\n+        WhereClauseSpace::Space if comment_before.is_empty() => Cow::from(\" \"),\n+        WhereClauseSpace::None => Cow::from(\"\"),\n+        _ => block_shape.indent.to_string_with_newline(context.config),\n     };\n \n-    let clause_shape = block_shape.block_left(context.config.tab_spaces())?;\n-    // 1 = `,`\n-    let clause_shape = clause_shape.sub_width(1)?;\n-    // each clause on one line, trailing comma (except if suppress_comma)\n+    let newline_before_where = comment_separator(&comment_before, shape);\n+    let newline_after_where = comment_separator(&comment_after, clause_shape);\n+    let result = format!(\n+        \"{}{}{}where{}{}\",\n+        starting_newline, comment_before, newline_before_where, newline_after_where, comment_after\n+    );\n+    let allow_single_line = where_clause_option.allow_single_line\n+        && comment_before.is_empty()\n+        && comment_after.is_empty();\n+\n+    Some((result, allow_single_line))\n+}\n+\n+/// Rewrite bounds on a where clause.\n+fn rewrite_bounds_on_where_clause(\n+    context: &RewriteContext<'_>,\n+    where_clause: &ast::WhereClause,\n+    shape: Shape,\n+    terminator: &str,\n+    span_end: Option<BytePos>,\n+    where_clause_option: WhereClauseOption,\n+    force_single_line: bool,\n+) -> Option<String> {\n     let span_start = where_clause.predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n@@ -2499,64 +2646,30 @@ fn rewrite_where_clause_rfc_style(\n         \",\",\n         |pred| pred.span().lo(),\n         |pred| pred.span().hi(),\n-        |pred| pred.rewrite(context, clause_shape),\n+        |pred| pred.rewrite(context, shape),\n         span_start,\n         span_end,\n         false,\n     );\n-    let where_single_line = context.config.where_single_line() && len == 1 && !is_args_multi_line;\n-    let comma_tactic = if where_clause_option.suppress_comma || where_single_line {\n+    let comma_tactic = if where_clause_option.suppress_comma || force_single_line {\n         SeparatorTactic::Never\n     } else {\n         context.config.trailing_comma()\n     };\n \n-    // shape should be vertical only and only if we have `where_single_line` option enabled\n+    // shape should be vertical only and only if we have `force_single_line` option enabled\n     // and the number of items of the where-clause is equal to 1\n-    let shape_tactic = if where_single_line {\n+    let shape_tactic = if force_single_line {\n         DefinitiveListTactic::Horizontal\n     } else {\n         DefinitiveListTactic::Vertical\n     };\n \n-    let fmt = ListFormatting::new(clause_shape, context.config)\n+    let fmt = ListFormatting::new(shape, context.config)\n         .tactic(shape_tactic)\n         .trailing_separator(comma_tactic)\n         .preserve_newline(true);\n-    let preds_str = write_list(&items.collect::<Vec<_>>(), &fmt)?;\n-\n-    let comment_separator = |comment: &str, shape: Shape| {\n-        if comment.is_empty() {\n-            Cow::from(\"\")\n-        } else {\n-            shape.indent.to_string_with_newline(context.config)\n-        }\n-    };\n-    let newline_before_where = comment_separator(&comment_before, shape);\n-    let newline_after_where = comment_separator(&comment_after, clause_shape);\n-\n-    // 6 = `where `\n-    let clause_sep = if where_clause_option.compress_where\n-        && comment_before.is_empty()\n-        && comment_after.is_empty()\n-        && !preds_str.contains('\\n')\n-        && 6 + preds_str.len() <= shape.width\n-        || where_single_line\n-    {\n-        Cow::from(\" \")\n-    } else {\n-        clause_shape.indent.to_string_with_newline(context.config)\n-    };\n-    Some(format!(\n-        \"{}{}{}where{}{}{}{}\",\n-        starting_newline,\n-        comment_before,\n-        newline_before_where,\n-        newline_after_where,\n-        comment_after,\n-        clause_sep,\n-        preds_str\n-    ))\n+    write_list(&items.collect::<Vec<_>>(), &fmt)\n }\n \n fn rewrite_where_clause(\n@@ -2569,7 +2682,6 @@ fn rewrite_where_clause(\n     span_end: Option<BytePos>,\n     span_end_before_where: BytePos,\n     where_clause_option: WhereClauseOption,\n-    is_args_multi_line: bool,\n ) -> Option<String> {\n     if where_clause.predicates.is_empty() {\n         return Some(String::new());\n@@ -2584,7 +2696,6 @@ fn rewrite_where_clause(\n             span_end,\n             span_end_before_where,\n             where_clause_option,\n-            is_args_multi_line,\n         );\n     }\n \n@@ -2742,7 +2853,6 @@ fn format_generics(\n             Some(span.hi()),\n             span_end_before_where,\n             option,\n-            false,\n         )?;\n         result.push_str(&where_clause_str);\n         ("}, {"sha": "80ee0188a6baac4ac8cea857a5b789127f97d3e3", "filename": "tests/source/trait.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/tests%2Fsource%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/tests%2Fsource%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftrait.rs?ref=6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "patch": "@@ -122,3 +122,55 @@ pub mod test {\n {\n }\n }\n+\n+// Trait aliases with where clauses.\n+trait A = where for<'b> &'b Self: Send;\n+\n+trait B = where for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCC;\n+trait B = where for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCC;\n+trait B = where\n+    for<'b> &'b Self:\n+Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCCCCCCCCCCCCCC;\n+trait B = where\n+    for<'b> &'b Self:\n+Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC;\n+\n+trait B = where\n+    for<'b> &'b Self:\n+Send\n+    + Clone\n+    + Copy\n+    + SomeTrait\n+    + AAAAAAAA\n+    + BBBBBBB\n+    + CCCCCCCCC\n+    + DDDDDDD\n+    + DDDDDDDD\n+    + DDDDDDDDD\n+    + EEEEEEE;\n+\n+trait A<'a, 'b, 'c> = Debug<T> + Foo where for<'b> &'b Self: Send;\n+\n+trait B<'a, 'b, 'c> = Debug<T> +Foo\n+where for<'b> &'b Self:\n+Send\n+    + Clone\n+    + Copy\n+    + SomeTrait\n+    + AAAAAAAA\n+    + BBBBBBB\n+    + CCCCCCCCC\n+    + DDDDDDD;\n+\n+trait B<'a, 'b, 'c,T> = Debug<'a, T> where for<'b> &'b Self:\n+Send\n+    + Clone\n+    + Copy\n+    + SomeTrait\n+    + AAAAAAAA\n+    + BBBBBBB\n+    + CCCCCCCCC\n+    + DDDDDDD\n+    + DDDDDDDD\n+    + DDDDDDDDD\n+    + EEEEEEE;"}, {"sha": "620046a71b29bea84f343141ff15836c40dfddaa", "filename": "tests/target/trait.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/tests%2Ftarget%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d19a8c71d9cc4c589df40cc2a514e9ac867f623/tests%2Ftarget%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftrait.rs?ref=6d19a8c71d9cc4c589df40cc2a514e9ac867f623", "patch": "@@ -160,3 +160,54 @@ pub mod test {\n     {\n     }\n }\n+\n+// Trait aliases with where clauses.\n+trait A = where for<'b> &'b Self: Send;\n+\n+trait B = where for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCC;\n+trait B =\n+    where for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCC;\n+trait B = where\n+    for<'b> &'b Self:\n+        Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCCCCCCCCCCCCCC;\n+trait B = where\n+    for<'b> &'b Self: Send\n+        + Clone\n+        + Copy\n+        + SomeTrait\n+        + AAAAAAAA\n+        + BBBBBBB\n+        + CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC;\n+\n+trait B = where\n+    for<'b> &'b Self: Send\n+        + Clone\n+        + Copy\n+        + SomeTrait\n+        + AAAAAAAA\n+        + BBBBBBB\n+        + CCCCCCCCC\n+        + DDDDDDD\n+        + DDDDDDDD\n+        + DDDDDDDDD\n+        + EEEEEEE;\n+\n+trait A<'a, 'b, 'c> = Debug<T> + Foo where for<'b> &'b Self: Send;\n+\n+trait B<'a, 'b, 'c> = Debug<T> + Foo\n+where\n+    for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCC + DDDDDDD;\n+\n+trait B<'a, 'b, 'c, T> = Debug<'a, T>\n+where\n+    for<'b> &'b Self: Send\n+        + Clone\n+        + Copy\n+        + SomeTrait\n+        + AAAAAAAA\n+        + BBBBBBB\n+        + CCCCCCCCC\n+        + DDDDDDD\n+        + DDDDDDDD\n+        + DDDDDDDDD\n+        + EEEEEEE;"}]}