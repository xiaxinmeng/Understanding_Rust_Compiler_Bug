{"sha": "dbd10f81758381339f98994b8d31814cf5e98707", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZDEwZjgxNzU4MzgxMzM5Zjk4OTk0YjhkMzE4MTRjZjVlOTg3MDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-17T14:10:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-17T14:10:11Z"}, "message": "Auto merge of #50615 - irinagpopa:rename-trans, r=nikomatsakis\n\nRename trans to codegen everywhere.\n\nPart of #45274.", "tree": {"sha": "314792e2f467d17181d29d4988550058197ac029", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314792e2f467d17181d29d4988550058197ac029"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbd10f81758381339f98994b8d31814cf5e98707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd10f81758381339f98994b8d31814cf5e98707", "html_url": "https://github.com/rust-lang/rust/commit/dbd10f81758381339f98994b8d31814cf5e98707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbd10f81758381339f98994b8d31814cf5e98707/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3150564f889a3bad01795d9fcb31d4f14d58a99", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3150564f889a3bad01795d9fcb31d4f14d58a99", "html_url": "https://github.com/rust-lang/rust/commit/e3150564f889a3bad01795d9fcb31d4f14d58a99"}, {"sha": "b63d7e2b1c4019e40051036bcb1fd5f254a8f6e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b63d7e2b1c4019e40051036bcb1fd5f254a8f6e2", "html_url": "https://github.com/rust-lang/rust/commit/b63d7e2b1c4019e40051036bcb1fd5f254a8f6e2"}], "stats": {"total": 3095, "additions": 1547, "deletions": 1548}, "files": [{"sha": "00cc530e6324abddd5ae5a1ec7b596e246a283d3", "filename": "src/Cargo.lock", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1896,6 +1896,52 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_codegen_llvm\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n+ \"rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_allocator 0.0.0\",\n+ \"rustc_apfloat 0.0.0\",\n+ \"rustc_codegen_utils 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"rustc_target 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+ \"tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc_codegen_utils\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"ar 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_target 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_cratesio_shim\"\n version = \"0.0.0\"\n@@ -1932,6 +1978,7 @@ dependencies = [\n  \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n+ \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n@@ -1945,7 +1992,6 @@ dependencies = [\n  \"rustc_save_analysis 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"rustc_traits 0.0.0\",\n- \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n@@ -2155,52 +2201,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_trans\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cc 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jobserver 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_allocator 0.0.0\",\n- \"rustc_apfloat 0.0.0\",\n- \"rustc_data_structures 0.0.0\",\n- \"rustc_errors 0.0.0\",\n- \"rustc_incremental 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n- \"rustc_mir 0.0.0\",\n- \"rustc_platform_intrinsics 0.0.0\",\n- \"rustc_target 0.0.0\",\n- \"rustc_trans_utils 0.0.0\",\n- \"serialize 0.0.0\",\n- \"syntax 0.0.0\",\n- \"syntax_pos 0.0.0\",\n- \"tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"rustc_trans_utils\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"ar 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc 0.0.0\",\n- \"rustc_data_structures 0.0.0\",\n- \"rustc_incremental 0.0.0\",\n- \"rustc_mir 0.0.0\",\n- \"rustc_target 0.0.0\",\n- \"syntax 0.0.0\",\n- \"syntax_pos 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_tsan\"\n version = \"0.0.0\""}, {"sha": "1518e8d910fc2161c349aec1188ca7e1e5156e91", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -4,7 +4,7 @@ members = [\n   \"rustc\",\n   \"libstd\",\n   \"libtest\",\n-  \"librustc_trans\",\n+  \"librustc_codegen_llvm\",\n   \"tools/cargotest\",\n   \"tools/clippy\",\n   \"tools/compiletest\","}, {"sha": "cc1e66332a3f38acaca8f26f35de85958fbc508c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -844,7 +844,7 @@ impl<'a> Builder<'a> {\n         // default via `-ldylib=winapi_foo`. That is, they're linked with the\n         // `dylib` type with a `winapi_` prefix (so the winapi ones don't\n         // conflict with the system MinGW ones). This consequently means that\n-        // the binaries we ship of things like rustc_trans (aka the rustc_trans\n+        // the binaries we ship of things like rustc_codegen_llvm (aka the rustc_codegen_llvm\n         // DLL) when linked against *again*, for example with procedural macros\n         // or plugins, will trigger the propagation logic of `-ldylib`, passing\n         // `-lwinapi_foo` to the linker again. This isn't actually available in"}, {"sha": "a516af58b1eabc8d310122db212e83d07f9348bd", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -118,7 +118,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.all_krates(\"rustc_trans\")\n+        run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -139,12 +139,12 @@ impl Step for CodegenBackend {\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n         let features = builder.rustc_features().to_string();\n-        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n+        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         // We won't build LLVM if it's not available, as it shouldn't affect `check`.\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         run_cargo(builder,\n                   cargo.arg(\"--features\").arg(features),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n@@ -259,14 +259,14 @@ pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<St\n     builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n }\n \n-/// Cargo's output path for librustc_trans in a given stage, compiled by a particular\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n fn codegen_backend_stamp(builder: &Builder,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Librustc, target)\n-         .join(format!(\".librustc_trans-{}-check.stamp\", backend))\n+         .join(format!(\".librustc_codegen_llvm-{}-check.stamp\", backend))\n }\n \n /// Cargo's output path for rustdoc in a given stage, compiled by a particular"}, {"sha": "8e0227f8fe143737a4ed6f47366183a6e153ea54", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -603,7 +603,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.all_krates(\"rustc_trans\")\n+        run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -637,15 +637,15 @@ impl Step for CodegenBackend {\n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         let mut features = builder.rustc_features().to_string();\n         cargo.arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         features += &build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n \n         let tmp_stamp = builder.cargo_out(compiler, Mode::Librustc, target)\n             .join(\".tmp.stamp\");\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         let files = run_cargo(builder,\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n@@ -656,7 +656,7 @@ impl Step for CodegenBackend {\n         let mut files = files.into_iter()\n             .filter(|f| {\n                 let filename = f.file_name().unwrap().to_str().unwrap();\n-                is_dylib(filename) && filename.contains(\"rustc_trans-\")\n+                is_dylib(filename) && filename.contains(\"rustc_codegen_llvm-\")\n             });\n         let codegen_backend = match files.next() {\n             Some(f) => f,\n@@ -697,7 +697,7 @@ pub fn build_codegen_backend(builder: &Builder,\n                      compiler.stage, &compiler.host, target, backend));\n \n             // Pass down configuration from the LLVM build into the build of\n-            // librustc_llvm and librustc_trans.\n+            // librustc_llvm and librustc_codegen_llvm.\n             if builder.is_rust_llvm(target) {\n                 cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n             }\n@@ -762,7 +762,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n         t!(t!(File::open(&stamp)).read_to_string(&mut dylib));\n         let file = Path::new(&dylib);\n         let filename = file.file_name().unwrap().to_str().unwrap();\n-        // change `librustc_trans-xxxxxx.so` to `librustc_trans-llvm.so`\n+        // change `librustc_codegen_llvm-xxxxxx.so` to `librustc_codegen_llvm-llvm.so`\n         let target_filename = {\n             let dash = filename.find(\"-\").unwrap();\n             let dot = filename.find(\".\").unwrap();\n@@ -808,14 +808,14 @@ pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<St\n     builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n-/// Cargo's output path for librustc_trans in a given stage, compiled by a particular\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n fn codegen_backend_stamp(builder: &Builder,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Librustc, target)\n-        .join(format!(\".librustc_trans-{}.stamp\", backend))\n+        .join(format!(\".librustc_codegen_llvm-{}.stamp\", backend))\n }\n \n pub fn compiler_file(builder: &Builder,"}, {"sha": "93e94e5586302629d12e7299d87fa076b69e5a88", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -69,7 +69,7 @@ for details on how to format and write long error codes.\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/diagnostics.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/diagnostics.rs),\n-  [librustc_trans](https://github.com/rust-lang/rust/blob/master/src/librustc_trans/diagnostics.rs),\n+  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/diagnostics.rs),\n   [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/diagnostics.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/diagnostics.rs).\n * Explanations have full markdown support. Use it, especially to highlight"}, {"sha": "09d16b265208372b1124c42a69882e5cc7551cc3", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -134,7 +134,7 @@ unsafe impl Alloc for Global {\n }\n \n /// The allocator for unique pointers.\n-// This function must not unwind. If it does, MIR trans will fail.\n+// This function must not unwind. If it does, MIR codegen will fail.\n #[cfg(not(test))]\n #[lang = \"exchange_malloc\"]\n #[inline]"}, {"sha": "5ec6cb6c710541c3aa61a499adc13a8ac9024150", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n //! rustc compiler intrinsics.\n //!\n-//! The corresponding definitions are in librustc_trans/intrinsic.rs.\n+//! The corresponding definitions are in librustc_codegen_llvm/intrinsic.rs.\n //!\n //! # Volatiles\n //!"}, {"sha": "8f9a8bd5c015f24b10560c530d17d54fa3f7acb2", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -35,21 +35,21 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n # rlib/dylib pair but all crates.io crates tend to just be rlibs. This means\n # we've got a problem for dependency graphs that look like:\n #\n-#           foo - rustc_trans\n+#           foo - rustc_codegen_llvm\n #         /                  \\\n #   rustc                     ---- rustc_driver\n #         \\                     /\n #           foo - rustc_metadata\n #\n-# Here the crate `foo` is linked into the `rustc_trans` and the\n+# Here the crate `foo` is linked into the `rustc_codegen_llvm` and the\n # `rustc_metadata` dylibs, meaning we've got duplicate copies! When we then\n # go to link `rustc_driver` the compiler notices this and gives us a compiler\n # error.\n #\n # To work around this problem we just add these crates.io dependencies to the\n # `rustc` crate which is a shared dependency above. That way the crate `foo`\n # shows up in the dylib for the `rustc` crate, deduplicating it and allowing\n-# crates like `rustc_trans` to use `foo` *through* the `rustc` crate.\n+# crates like `rustc_codegen_llvm` to use `foo` *through* the `rustc` crate.\n #\n # tl;dr; this is not needed to get `rustc` to compile, but if you remove it then\n #        later crate stop compiling. If you can remove this and everything"}, {"sha": "20e4b1343c1b8d247bb1af226725774a9d8c51b0", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -452,13 +452,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         // The CFG for match expression is quite complex, so no ASCII\n         // art for it (yet).\n         //\n-        // The CFG generated below matches roughly what trans puts\n-        // out. Each pattern and guard is visited in parallel, with\n+        // The CFG generated below matches roughly what MIR contains.\n+        // Each pattern and guard is visited in parallel, with\n         // arms containing multiple patterns generating multiple nodes\n         // for the same guard expression. The guard expressions chain\n         // into each other from top to bottom, with a specific\n         // exception to allow some additional valid programs\n-        // (explained below). Trans differs slightly in that the\n+        // (explained below). MIR differs slightly in that the\n         // pattern matching may continue after a guard but the visible\n         // behaviour should be the same.\n         //"}, {"sha": "9cd9d44874b80a1d5f9f3af384717aef428f86f6", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -565,7 +565,7 @@ define_dep_nodes!( <'tcx>\n     [] IsUnreachableLocalDefinition(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n-    [] TransFnAttrs(DefId),\n+    [] CodegenFnAttrs(DefId),\n     [] FnArgNames(DefId),\n     [] RenderedConst(DefId),\n     [] DylibDepFormats(CrateNum),\n@@ -637,8 +637,8 @@ define_dep_nodes!( <'tcx>\n     [eval_always] AllTraits,\n     [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),\n-    [eval_always] CollectAndPartitionTranslationItems,\n-    [] IsTranslatedItem(DefId),\n+    [eval_always] CollectAndPartitionMonoItems,\n+    [] IsCodegenedItem(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,"}, {"sha": "26470ddc82af5c322ae46da1bd211bb88bec31be", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -856,10 +856,10 @@ impl DepGraph {\n /// each partition. In the first run, we create partitions based on\n /// the symbols that need to be compiled. For each partition P, we\n /// hash the symbols in P and create a `WorkProduct` record associated\n-/// with `DepNode::TransPartition(P)`; the hash is the set of symbols\n+/// with `DepNode::CodegenUnit(P)`; the hash is the set of symbols\n /// in P.\n ///\n-/// The next time we compile, if the `DepNode::TransPartition(P)` is\n+/// The next time we compile, if the `DepNode::CodegenUnit(P)` is\n /// judged to be clean (which means none of the things we read to\n /// generate the partition were found to be dirty), it will be loaded\n /// into previous work products. We will then regenerate the set of"}, {"sha": "591cb9d5ad6c2c33bb73984ea34992aa583b88f3", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn {\n-            self.tcx.trans_fn_attrs(self.tcx.hir.local_def_id(item.id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir.local_def_id(item.id));\n         } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")"}, {"sha": "edd5e668d5e679676b1462741e41975aca87a848", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -2244,8 +2244,8 @@ pub fn provide(providers: &mut Providers) {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n-pub struct TransFnAttrs {\n-    pub flags: TransFnAttrFlags,\n+pub struct CodegenFnAttrs {\n+    pub flags: CodegenFnAttrFlags,\n     pub inline: InlineAttr,\n     pub export_name: Option<Symbol>,\n     pub target_features: Vec<Symbol>,\n@@ -2254,7 +2254,7 @@ pub struct TransFnAttrs {\n \n bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n-    pub struct TransFnAttrFlags: u8 {\n+    pub struct CodegenFnAttrFlags: u8 {\n         const COLD                      = 0b0000_0001;\n         const ALLOCATOR                 = 0b0000_0010;\n         const UNWIND                    = 0b0000_0100;\n@@ -2266,10 +2266,10 @@ bitflags! {\n     }\n }\n \n-impl TransFnAttrs {\n-    pub fn new() -> TransFnAttrs {\n-        TransFnAttrs {\n-            flags: TransFnAttrFlags::empty(),\n+impl CodegenFnAttrs {\n+    pub fn new() -> CodegenFnAttrs {\n+        CodegenFnAttrs {\n+            flags: CodegenFnAttrFlags::empty(),\n             inline: InlineAttr::None,\n             export_name: None,\n             target_features: vec![],\n@@ -2287,7 +2287,6 @@ impl TransFnAttrs {\n \n     /// True if `#[no_mangle]` or `#[export_name(...)]` is present.\n     pub fn contains_extern_indicator(&self) -> bool {\n-        self.flags.contains(TransFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n+        self.flags.contains(CodegenFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n     }\n }\n-"}, {"sha": "30f725a6b50af45f48231bd499d869bda71fd53d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1155,12 +1155,12 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     }\n }\n \n-impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrs\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'hir>,\n                                           hasher: &mut StableHasher<W>) {\n-        let hir::TransFnAttrs {\n+        let hir::CodegenFnAttrs {\n             flags,\n             inline,\n             export_name,\n@@ -1176,7 +1176,7 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n     }\n }\n \n-impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrFlags\n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrFlags\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'hir>,"}, {"sha": "d58eb64c366e7aa056faab5958017ddb7b5be838", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -30,7 +30,7 @@ pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n-pub const ATTR_PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+pub const ATTR_PARTITION_CODEGENED: &'static str = \"rustc_partition_codegened\";\n \n \n pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n@@ -39,7 +39,7 @@ pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n     ATTR_PARTITION_REUSED,\n-    ATTR_PARTITION_TRANSLATED,\n+    ATTR_PARTITION_CODEGENED,\n ];\n \n pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n@@ -49,5 +49,5 @@ pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n     ATTR_PARTITION_REUSED,\n-    ATTR_PARTITION_TRANSLATED,\n+    ATTR_PARTITION_CODEGENED,\n ];"}, {"sha": "4cc5e885b8a800272a6c6e00feabd760565a58c6", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -614,7 +614,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n                 // compiler; those regions are ignored for the\n                 // outlives relation, and hence don't affect trait\n                 // selection or auto traits, and they are erased\n-                // during trans.\n+                // during codegen.\n \n                 let generics = self.tcx.generics_of(def_id);\n                 let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map("}, {"sha": "381bb161e4205c5c77a9e8f82e54529f954da3ca", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,15 +10,15 @@\n \n //! Implementation of lint checking.\n //!\n-//! The lint checking is mostly consolidated into one pass which runs just\n-//! before translation to LLVM bytecode. Throughout compilation, lint warnings\n+//! The lint checking is mostly consolidated into one pass which runs\n+//! after all other analyses. Throughout compilation, lint warnings\n //! can be added via the `add_lint` method on the Session structure. This\n //! requires a span and an id of the node that the lint is being added to. The\n //! lint isn't actually emitted at that time because it is unknown what the\n //! actual lint level at that location is.\n //!\n-//! To actually emit lint warnings/errors, a separate pass is used just before\n-//! translation. A context keeps track of the current state of all lint levels.\n+//! To actually emit lint warnings/errors, a separate pass is used.\n+//! A context keeps track of the current state of all lint levels.\n //! Upon entering a node of the ast which can modify the lint settings, the\n //! previous lint state is pushed onto a stack and the ast is then recursed\n //! upon.  As the ast is traversed, this keeps track of the current lint level"}, {"sha": "7645d3486c2f871bdf800af0047a9ad4ff8f206b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -16,15 +16,15 @@\n //! other phases of the compiler, which are generally required to hold in order\n //! to compile the program at all.\n //!\n-//! Most lints can be written as `LintPass` instances. These run just before\n-//! translation to LLVM bytecode. The `LintPass`es built into rustc are defined\n+//! Most lints can be written as `LintPass` instances. These run after\n+//! all other analyses. The `LintPass`es built into rustc are defined\n //! within `builtin.rs`, which has further comments on how to add such a lint.\n //! rustc can also load user-defined lint plugins via the plugin mechanism.\n //!\n //! Some of rustc's lints are defined elsewhere in the compiler and work by\n //! calling `add_lint()` on the overall `Session` object. This works when\n //! it happens before the main lint pass, which emits the lints stored by\n-//! `add_lint()`. To emit lints after the main lint pass (from trans, for\n+//! `add_lint()`. To emit lints after the main lint pass (from codegen, for\n //! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n //! in `context.rs`.\n "}, {"sha": "4c99b46ddff6e5443cd3f9af9ffc84c3c91612df", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -109,7 +109,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let sess = &tcx.sess;\n \n-    if !sess.opts.output_types.should_trans() {\n+    if !sess.opts.output_types.should_codegen() {\n         return Vec::new();\n     }\n "}, {"sha": "e9d27c182a2c944f55aa60bf0dee1300db5fb6a4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -46,9 +46,9 @@\n //!\n //! ## By-reference upvars\n //!\n-//! One part of the translation which may be non-obvious is that we translate\n+//! One part of the codegen which may be non-obvious is that we translate\n //! closure upvars into the dereference of a borrowed pointer; this more closely\n-//! resembles the runtime translation. So, for example, if we had:\n+//! resembles the runtime codegen. So, for example, if we had:\n //!\n //!     let mut x = 3;\n //!     let y = 5;"}, {"sha": "249651ef65da0eadd645695d0a5366b8d11c041e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -15,7 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use hir::TransFnAttrs;\n+use hir::CodegenFnAttrs;\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n@@ -44,7 +44,7 @@ fn generics_require_inlining(generics: &hir::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &hir::Item, attrs: TransFnAttrs) -> bool {\n+fn item_might_be_inlined(item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n@@ -61,15 +61,15 @@ fn item_might_be_inlined(item: &hir::Item, attrs: TransFnAttrs) -> bool {\n fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n-    let trans_fn_attrs = tcx.trans_fn_attrs(impl_item.hir_id.owner_def_id());\n-    if trans_fn_attrs.requests_inline() ||\n+    let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n+    if codegen_fn_attrs.requests_inline() ||\n         generics_require_inlining(&impl_item.generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n             Some(hir_map::NodeItem(item)) =>\n-                item_might_be_inlined(&item, trans_fn_attrs),\n+                item_might_be_inlined(&item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n                     hir::ItemFn(..) =>\n-                        item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)),\n+                        item_might_be_inlined(&item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n@@ -179,7 +179,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n-                        let attrs = self.tcx.trans_fn_attrs(def_id);\n+                        let attrs = self.tcx.codegen_fn_attrs(def_id);\n                         if generics_require_inlining(&impl_item.generics) ||\n                                 attrs.requests_inline() {\n                             true\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     false\n                 };\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n-                let is_extern = self.tcx.trans_fn_attrs(def_id).contains_extern_indicator();\n+                let is_extern = self.tcx.codegen_fn_attrs(def_id).contains_extern_indicator();\n                 if reachable || is_extern {\n                     self.reachable_symbols.insert(search_item);\n                 }\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n-                        if item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)) {\n+                        if item_might_be_inlined(&item, self.tcx.codegen_fn_attrs(def_id)) {\n                             self.visit_nested_body(body);\n                         }\n                     }"}, {"sha": "71d7abed6c95a8e1359787a8ce350afd030aefda", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1279,7 +1279,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         loop {\n             // Note: give all the expressions matching `ET` with the\n             // extended temporary lifetime, not just the innermost rvalue,\n-            // because in trans if we must compile e.g. `*rvalue()`\n+            // because in codegen if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);"}, {"sha": "31885c1e0205ed553ed3ee2ffbaa72211b1a857b", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -249,7 +249,7 @@ pub struct Allocation {\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n-    /// Whether the allocation (of a static) should be put into mutable memory when translating\n+    /// Whether the allocation (of a static) should be put into mutable memory when codegenning\n     ///\n     /// Only happens for `static mut` or `static` with interior mutability\n     pub runtime_mutability: Mutability,"}, {"sha": "7bd84a607e714d96bd6c6ab6842f09be8d9b9100", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -75,7 +75,7 @@ impl<'tcx> ConstValue<'tcx> {\n ///\n /// For optimization of a few very common cases, there is also a representation for a pair of\n /// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's trans.\n+/// operations and fat pointers. This idea was taken from rustc's codegen.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n     ByRef(Pointer, Align),"}, {"sha": "40e9b687f0ccc404c479a2cf4c5866c84a0d4775", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -696,7 +696,7 @@ pub struct BasicBlockData<'tcx> {\n     pub terminator: Option<Terminator<'tcx>>,\n \n     /// If true, this block lies on an unwind path. This is used\n-    /// during trans where distinct kinds of basic blocks may be\n+    /// during codegen where distinct kinds of basic blocks may be\n     /// generated (particularly for MSVC cleanup). Unwind blocks must\n     /// only branch to other unwind blocks.\n     pub is_cleanup: bool,\n@@ -1614,7 +1614,7 @@ pub enum CastKind {\n     UnsafeFnPointer,\n \n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n-    /// trans must figure out the details once full monomorphization\n+    /// codegen must figure out the details once full monomorphization\n     /// is known. For example, this could be used to cast from a\n     /// `&[i32;N]` to a `&[i32]`, or a `Box<T>` to a `Box<Trait>`\n     /// (presuming `T: Trait`)."}, {"sha": "9de9347d0ce047644a81dd5842b72b3347fbdd4c", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -184,11 +184,11 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n \n         name.hash_stable(hcx, hasher);\n \n-        let mut items: Vec<(Fingerprint, _)> = items.iter().map(|(trans_item, &attrs)| {\n+        let mut items: Vec<(Fingerprint, _)> = items.iter().map(|(mono_item, &attrs)| {\n             let mut hasher = StableHasher::new();\n-            trans_item.hash_stable(hcx, &mut hasher);\n-            let trans_item_fingerprint = hasher.finish();\n-            (trans_item_fingerprint, attrs)\n+            mono_item.hash_stable(hcx, &mut hasher);\n+            let mono_item_fingerprint = hasher.finish();\n+            (mono_item_fingerprint, attrs)\n         }).collect();\n \n         items.sort_unstable_by_key(|i| i.0);\n@@ -238,4 +238,3 @@ impl Stats {\n         self.fn_stats.extend(stats.fn_stats);\n     }\n }\n-"}, {"sha": "2344cd11f66d3d38e65daa64893e8ab0efed8717", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -270,7 +270,7 @@ impl OutputTypes {\n     }\n \n     // True if any of the output types require codegen or linking.\n-    pub fn should_trans(&self) -> bool {\n+    pub fn should_codegen(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n             | OutputType::Assembly\n@@ -1135,14 +1135,14 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"count where LLVM instrs originate\"),\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n         \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n-         re-translated modules when used with incremental compilation\" )],\n+         re-codegened modules when used with incremental compilation\" )],\n         \"measure time of each LLVM pass\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),\n-    trans_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n-        \"The output of `-Z trans-stats` might not be accurate when incremental \\\n+    codegen_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"The output of `-Z codegen-stats` might not be accurate when incremental \\\n          compilation is enabled\")],\n-        \"gather trans statistics\"),\n+        \"gather codegen statistics\"),\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior)\"),\n     no_verify: bool = (false, parse_bool, [TRACKED],\n@@ -1183,8 +1183,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           Use with RUST_REGION_GRAPH=help for more info\"),\n     parse_only: bool = (false, parse_bool, [UNTRACKED],\n           \"parse only; do not compile, assemble, or link\"),\n-    no_trans: bool = (false, parse_bool, [TRACKED],\n-          \"run all passes except translation; no output\"),\n+    no_codegen: bool = (false, parse_bool, [TRACKED],\n+          \"run all passes except codegen; no output\"),\n     treat_err_as_bug: bool = (false, parse_bool, [TRACKED],\n           \"treat all errors that occur as bugs\"),\n     external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n@@ -1235,16 +1235,16 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n     print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n           \"print layout information for each type encountered\"),\n-    print_trans_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-          \"print the result of the translation item collection pass\"),\n+    print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+          \"print the result of the monomorphization collection pass\"),\n     mir_opt_level: usize = (1, parse_uint, [TRACKED],\n           \"set the MIR optimization level (0-3, default: 1)\"),\n     mutable_noalias: bool = (false, parse_bool, [TRACKED],\n           \"emit noalias metadata for mutable references\"),\n     arg_align_attributes: bool = (false, parse_bool, [TRACKED],\n           \"emit align metadata for reference arguments\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-          \"dump MIR state at various points in translation\"),\n+          \"dump MIR state at various points in transforms\"),\n     dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n     dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n@@ -1296,8 +1296,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n                        \"dump facts from NLL analysis into side files\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n-    trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"generate a graphical HTML report of time spent in trans and LLVM\"),\n+    codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1309,7 +1309,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          the max/min integer respectively, and NaN is mapped to 0\"),\n     lower_128bit_ops: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"rewrite operators on i128 and u128 into lang item calls (typically provided \\\n-         by compiler-builtins) so translation doesn't need to support them,\n+         by compiler-builtins) so codegen doesn't need to support them,\n          overriding the default for the current target\"),\n     human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],\n         \"generate human-readable, predictable names for codegen units\"),\n@@ -3047,7 +3047,7 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.input_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.trans_stats = true;\n+        opts.debugging_opts.codegen_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.borrowck_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n@@ -3093,7 +3093,7 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.keep_ast = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_trans_items = Some(String::from(\"abc\"));\n+        opts.debugging_opts.print_mono_items = Some(String::from(\"abc\"));\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n@@ -3120,7 +3120,7 @@ mod tests {\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();\n-        opts.debugging_opts.no_trans = true;\n+        opts.debugging_opts.no_codegen = true;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "6c8d4f5669e8ec262717b10114f72a98c9747896", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -98,7 +98,7 @@ pub struct Session {\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n-    /// trans::back::symbol_names module for more information.\n+    /// rustc_codegen_llvm::back::symbol_names module for more information.\n     pub crate_disambiguator: Once<CrateDisambiguator>,\n \n     features: Once<feature_gate::Features>,\n@@ -504,8 +504,8 @@ impl Session {\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.time_llvm_passes\n     }\n-    pub fn trans_stats(&self) -> bool {\n-        self.opts.debugging_opts.trans_stats\n+    pub fn codegen_stats(&self) -> bool {\n+        self.opts.debugging_opts.codegen_stats\n     }\n     pub fn meta_stats(&self) -> bool {\n         self.opts.debugging_opts.meta_stats\n@@ -894,11 +894,11 @@ impl Session {\n         // Why is 16 codegen units the default all the time?\n         //\n         // The main reason for enabling multiple codegen units by default is to\n-        // leverage the ability for the trans backend to do translation and\n-        // codegen in parallel. This allows us, especially for large crates, to\n+        // leverage the ability for the codegen backend to do codegen and\n+        // optimization in parallel. This allows us, especially for large crates, to\n         // make good use of all available resources on the machine once we've\n         // hit that stage of compilation. Large crates especially then often\n-        // take a long time in trans/codegen and this helps us amortize that\n+        // take a long time in codegen/optimization and this helps us amortize that\n         // cost.\n         //\n         // Note that a high number here doesn't mean that we'll be spawning a"}, {"sha": "cf404202ac120830ff9da5309a4b4280136a3700", "filename": "src/librustc/traits/codegen/mod.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file contains various trait resolution methods used by trans.\n+// This file contains various trait resolution methods used by codegen.\n // They all assume regions can be erased and monomorphic types.  It\n // seems likely that they should eventually be merged into more\n // general routines.\n@@ -30,15 +30,15 @@ use ty::fold::TypeFoldable;\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to.\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n-pub fn trans_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n                                           (param_env, trait_ref):\n                                           (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n                                           -> Vtable<'tcx, ()>\n {\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = ty.erase_regions(&trait_ref);\n \n-    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+    debug!(\"codegen_fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n             (param_env, trait_ref), trait_ref.def_id());\n \n     // Do the initial selection for the obligation. This yields the\n@@ -60,12 +60,12 @@ pub fn trans_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n                 // leading to an ambiguous result. So report this as an\n                 // overflow bug, since I believe this is the only case\n                 // where ambiguity can result.\n-                bug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                bug!(\"Encountered ambiguity selecting `{:?}` during codegen, \\\n                         presuming due to overflow\",\n                         trait_ref)\n             }\n             Err(e) => {\n-                bug!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\",\n                             e, trait_ref)\n             }\n         };", "previous_filename": "src/librustc/traits/trans/mod.rs"}, {"sha": "b5115eab7dc34dbdaa3f16a6e0d6663b9cc6fc4f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -64,7 +64,7 @@ mod on_unimplemented;\n mod select;\n mod specialize;\n mod structural_impls;\n-pub mod trans;\n+pub mod codegen;\n mod util;\n \n pub mod query;\n@@ -473,8 +473,8 @@ pub enum Vtable<'tcx, N> {\n ///\n /// The type parameter `N` indicates the type used for \"nested\n /// obligations\" that are required by the impl. During type check, this\n-/// is `Obligation`, as one might expect. During trans, however, this\n-/// is `()`, because trans only requires a shallow resolution of an\n+/// is `Obligation`, as one might expect. During codegen, however, this\n+/// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableImplData<'tcx, N> {\n@@ -856,7 +856,7 @@ fn vtable_methods<'a, 'tcx>(\n                 // It's possible that the method relies on where clauses that\n                 // do not hold for this particular set of type parameters.\n                 // Note that this method could then never be called, so we\n-                // do not want to try and trans it, in that case (see #23435).\n+                // do not want to try and codegen it, in that case (see #23435).\n                 let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n                 if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                     debug!(\"vtable_methods: predicates do not hold\");\n@@ -992,7 +992,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n-        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n+        codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n         vtable_methods,\n         substitute_normalize_and_test_predicates,\n         ..*providers"}, {"sha": "270e06a872bcb0b15e025e060fbf328dd4b6e726", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -65,7 +65,7 @@ pub enum Reveal {\n     /// }\n     UserFacing,\n \n-    /// At trans time, all monomorphic projections will succeed.\n+    /// At codegen time, all monomorphic projections will succeed.\n     /// Also, `impl Trait` is normalized to the concrete type,\n     /// which has to be already collected by type-checking.\n     ///\n@@ -346,7 +346,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n-                // Only normalize `impl Trait` after type-checking, usually in trans.\n+                // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n \n@@ -1054,7 +1054,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n             super::VtableImpl(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n-                // trans (i.e., projection mode is not \"any\"), and the\n+                // codegen (i.e., projection mode is not \"any\"), and the\n                 // impl's type is declared as default, then we disable\n                 // projection (even if the trait ref is fully\n                 // monomorphic). In the case where trait ref is not"}, {"sha": "1e9e9c056c944ee57fcc0666314f70e2bd3525c5", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -104,7 +104,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n         match ty.sty {\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => {\n                 // (*)\n-                // Only normalize `impl Trait` after type-checking, usually in trans.\n+                // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n "}, {"sha": "1cb96a3e33f43aa9a3f3494d9b0f61dbd19565b8", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -57,7 +57,7 @@ impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     ///\n     /// NB. Currently, higher-ranked type bounds inhibit\n     /// normalization. Therefore, each time we erase them in\n-    /// translation, we need to normalize the contents.\n+    /// codegen, we need to normalize the contents.\n     pub fn normalize_erasing_late_bound_regions<T>(\n         self,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "2e2f7a2ad312329233df665b417e040bdd78c40f", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     }\n }\n \n-// For trans only.\n+// For codegen only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {"}, {"sha": "3263da8fda365756298c026f23db0a546b383825", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -91,8 +91,8 @@ pub enum Adjust<'tcx> {\n     /// pointers.  We don't store the details of how the transform is\n     /// done (in fact, we don't know that, because it might depend on\n     /// the precise type parameters). We just store the target\n-    /// type. Trans figures out what has to be done at monomorphization\n-    /// time based on the precise source/target type at hand.\n+    /// type. Codegen backends and miri figure out what has to be done\n+    /// based on the precise source/target type at hand.\n     Unsize,\n }\n "}, {"sha": "7593d4ed24e768f71872dad84892d6c79edb1e98", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Helpers for handling cast expressions, used in both\n-// typeck and trans.\n+// typeck and codegen.\n \n use ty::{self, Ty};\n "}, {"sha": "ee55b8dd7672f1fe629bc5ed4f0a68378cbd2b5e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -401,7 +401,7 @@ pub struct TypeckTables<'tcx> {\n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n     /// (including late-bound regions) are replaced with free\n-    /// equivalents. This table is not used in trans (since regions\n+    /// equivalents. This table is not used in codegen (since regions\n     /// are erased there) and hence is not serialized to metadata.\n     liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n \n@@ -921,7 +921,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// A general purpose channel to throw data out the back towards LLVM worker\n     /// threads.\n     ///\n-    /// This is intended to only get used during the trans phase of the compiler\n+    /// This is intended to only get used during the codegen phase of the compiler\n     /// when satisfying the query for a particular codegen unit. Internally in\n     /// the query it'll send data along this channel to get processed later.\n     pub tx_to_llvm_workers: Lock<mpsc::Sender<Box<dyn Any + Send>>>,"}, {"sha": "f483b4c174ac3881ce1705d6c09fadba04d4122a", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -68,12 +68,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'a, 'gcx, 't\n         //\n         // Note that we *CAN* replace early-bound regions -- the\n         // type system never \"sees\" those, they get substituted\n-        // away. In trans, they will always be erased to 'erased\n+        // away. In codegen, they will always be erased to 'erased\n         // whenever a substitution occurs.\n         match *r {\n             ty::ReLateBound(..) => r,\n             _ => self.tcx.types.re_erased\n         }\n     }\n }\n-"}, {"sha": "8aca7177d55663a215246187ed4aaf787220ccc9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         collector.regions\n     }\n \n-    /// Replace any late-bound regions bound in `value` with `'erased`. Useful in trans but also\n+    /// Replace any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>"}, {"sha": "e97f782fccff82d19e0e84a18773053a363b9aba", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -104,13 +104,13 @@ impl<'tcx> InstanceDef<'tcx> {\n             return true\n         }\n         if let ty::InstanceDef::DropGlue(..) = *self {\n-            // Drop glue wants to be instantiated at every translation\n+            // Drop glue wants to be instantiated at every codegen\n             // unit, but without an #[inline] hint. We should make this\n             // available to normal end-users.\n             return true\n         }\n-        let trans_fn_attrs = tcx.trans_fn_attrs(self.def_id());\n-        trans_fn_attrs.requests_inline() || tcx.is_const_fn(self.def_id())\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(self.def_id());\n+        codegen_fn_attrs.requests_inline() || tcx.is_const_fn(self.def_id())\n     }\n }\n \n@@ -145,7 +145,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n         assert!(!substs.has_escaping_regions(),\n-                \"substs of instance {:?} not normalized for trans: {:?}\",\n+                \"substs of instance {:?} not normalized for codegen: {:?}\",\n                 def_id, substs);\n         Instance { def: InstanceDef::Item(def_id), substs: substs }\n     }\n@@ -175,7 +175,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     /// `RevealMode` in the parameter environment.)\n     ///\n     /// Presuming that coherence and type-check have succeeded, if this method is invoked\n-    /// in a monomorphic context (i.e., like during trans), then it is guaranteed to return\n+    /// in a monomorphic context (i.e., like during codegen), then it is guaranteed to return\n     /// `Some`.\n     pub fn resolve(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: ty::ParamEnv<'tcx>,\n@@ -259,7 +259,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n+    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -321,7 +321,7 @@ fn needs_fn_once_adapter_shim<'a, 'tcx>(actual_closure_kind: ty::ClosureKind,\n             }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n             // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // `fn(&mut self, ...)`. In fact, at codegen time, these are\n             // basically the same thing, so we can just return llfn.\n             Ok(false)\n         }\n@@ -334,7 +334,7 @@ fn needs_fn_once_adapter_shim<'a, 'tcx>(actual_closure_kind: ty::ClosureKind,\n                 //     fn call_once(self, ...) { call_mut(&self, ...) }\n                 //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n                 //\n-                // These are both the same at trans time.\n+                // These are both the same at codegen time.\n                 Ok(true)\n         }\n         (ty::ClosureKind::FnMut, _) |"}, {"sha": "dbc32f4dbddced6ba557b44fc23b62ebee91ab35", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -949,14 +949,14 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     // because this discriminant will be loaded, and then stored into variable of\n                     // type calculated by typeck. Consider such case (a bug): typeck decided on\n                     // byte-sized discriminant, but layout thinks we need a 16-bit to store all\n-                    // discriminant values. That would be a bug, because then, in trans, in order\n+                    // discriminant values. That would be a bug, because then, in codegen, in order\n                     // to store this 16-bit discriminant into 8-bit sized temporary some of the\n                     // space necessary to represent would have to be discarded (or layout is wrong\n                     // on thinking it needs 16 bits)\n                     bug!(\"layout decided on a larger discriminant type ({:?}) than typeck ({:?})\",\n                          min_ity, typeck_ity);\n                     // However, it is fine to make discr type however large (as an optimisation)\n-                    // after this point \u2013 we\u2019ll just truncate the value we load in trans.\n+                    // after this point \u2013 we\u2019ll just truncate the value we load in codegen.\n                 }\n \n                 // Check to see if we should use a different type for the\n@@ -1121,7 +1121,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n-        // to see the stuff resulting from the final trans session.\n+        // to see the stuff resulting from the final codegen session.\n         if\n             !self.tcx.sess.opts.debugging_opts.print_type_sizes ||\n             layout.ty.has_param_types() ||"}, {"sha": "19c97a918bb917a981478a0757ad1eae5e361b9a", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -349,7 +349,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::trans_fulfill_obligation<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt, key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n         format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n     }\n@@ -637,9 +637,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::exported_symbols<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_translation_items<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_mono_items<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"collect_and_partition_translation_items\")\n+        format!(\"collect_and_partition_mono_items\")\n     }\n }\n \n@@ -795,5 +795,5 @@ impl_disk_cacheable_query!(def_symbol_name, |_| true);\n impl_disk_cacheable_query!(type_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(predicates_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(used_trait_imports, |def_id| def_id.is_local());\n-impl_disk_cacheable_query!(trans_fn_attrs, |_| true);\n+impl_disk_cacheable_query!(codegen_fn_attrs, |_| true);\n impl_disk_cacheable_query!(specialization_graph_of, |_| true);"}, {"sha": "6556e47720c6239404371850cb7dd3b483f6f050", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n use dep_graph::{DepConstructor, DepNode};\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n-use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n+use hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n use hir::svh::Svh;\n use infer::canonical::{self, Canonical};\n use lint;\n@@ -181,7 +181,7 @@ define_maps! { <'tcx>\n     [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n-    /// for trans. This is also the only query that can fetch non-local MIR, at present.\n+    /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n     [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n \n     /// The result of unsafety-checking this def-id.\n@@ -255,7 +255,7 @@ define_maps! { <'tcx>\n     [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n     [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n     [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n-    [] fn trans_fn_attrs: trans_fn_attrs(DefId) -> TransFnAttrs,\n+    [] fn codegen_fn_attrs: codegen_fn_attrs(DefId) -> CodegenFnAttrs,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     /// Gets the rendered value of the specified constant or associated constant.\n     /// Used by rustdoc.\n@@ -268,7 +268,7 @@ define_maps! { <'tcx>\n     [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n                           -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n \n-    [] fn trans_fulfill_obligation: fulfill_obligation_dep_node(\n+    [] fn codegen_fulfill_obligation: fulfill_obligation_dep_node(\n         (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n     [] fn trait_impls_of: TraitImpls(DefId) -> Lrc<ty::trait_def::TraitImpls>,\n     [] fn specialization_graph_of: SpecializationGraph(DefId) -> Lrc<specialization_graph::Graph>,\n@@ -402,10 +402,10 @@ define_maps! { <'tcx>\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n         -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n-    [] fn collect_and_partition_translation_items:\n-        collect_and_partition_translation_items_node(CrateNum)\n+    [] fn collect_and_partition_mono_items:\n+        collect_and_partition_mono_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-    [] fn is_translated_item: IsTranslatedItem(DefId) -> bool,\n+    [] fn is_codegened_item: IsCodegenedItem(DefId) -> bool,\n     [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n     [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n     [] fn output_filenames: output_filenames_node(CrateNum)\n@@ -475,8 +475,8 @@ fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Features\n }\n \n-fn trans_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n-    DepConstructor::TransFnAttrs { 0: id }\n+fn codegen_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n+    DepConstructor::CodegenFnAttrs { 0: id }\n }\n \n fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n@@ -609,8 +609,8 @@ fn all_traits_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::AllTraits\n }\n \n-fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CollectAndPartitionTranslationItems\n+fn collect_and_partition_mono_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::CollectAndPartitionMonoItems\n }\n \n fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {"}, {"sha": "9ca90a06c4e5052e86dc53340664029cffb78b50", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -224,7 +224,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<predicates_of, _>(tcx, enc, qri)?;\n                 encode_query_results::<used_trait_imports, _>(tcx, enc, qri)?;\n                 encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n-                encode_query_results::<trans_fulfill_obligation, _>(tcx, enc, qri)?;\n+                encode_query_results::<codegen_fulfill_obligation, _>(tcx, enc, qri)?;\n                 encode_query_results::<optimized_mir, _>(tcx, enc, qri)?;\n                 encode_query_results::<unsafety_check_result, _>(tcx, enc, qri)?;\n                 encode_query_results::<borrowck, _>(tcx, enc, qri)?;\n@@ -234,7 +234,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n                 encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match, _>(tcx, enc, qri)?;\n-                encode_query_results::<trans_fn_attrs, _>(tcx, enc, qri)?;\n+                encode_query_results::<codegen_fn_attrs, _>(tcx, enc, qri)?;\n                 encode_query_results::<specialization_graph_of, _>(tcx, enc, qri)?;\n \n                 // const eval is special, it only encodes successfully evaluated constants"}, {"sha": "065b7939ac3628d820267bb1d40ad85d9048dbfa", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -871,7 +871,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n     // Since we cannot reconstruct the query key of a DepNode::CodegenUnit, we\n     // would always end up having to evaluate the first caller of the\n     // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-translating the whole CGU just\n+    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n     // to re-trigger calling the `codegen_unit` query with the right key. At\n     // that point we would already have re-done all the work we are trying to\n     // avoid doing in the first place.\n@@ -1046,7 +1046,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         }\n         DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n-        DepKind::TransFnAttrs => { force!(trans_fn_attrs, def_id!()); }\n+        DepKind::CodegenFnAttrs => { force!(codegen_fn_attrs, def_id!()); }\n         DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n         DepKind::RenderedConst => { force!(rendered_const, def_id!()); }\n         DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n@@ -1121,10 +1121,10 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::AllTraits => { force!(all_traits, LOCAL_CRATE); }\n         DepKind::AllCrateNums => { force!(all_crate_nums, LOCAL_CRATE); }\n         DepKind::ExportedSymbols => { force!(exported_symbols, krate!()); }\n-        DepKind::CollectAndPartitionTranslationItems => {\n-            force!(collect_and_partition_translation_items, LOCAL_CRATE);\n+        DepKind::CollectAndPartitionMonoItems => {\n+            force!(collect_and_partition_mono_items, LOCAL_CRATE);\n         }\n-        DepKind::IsTranslatedItem => { force!(is_translated_item, def_id!()); }\n+        DepKind::IsCodegenedItem => { force!(is_codegened_item, def_id!()); }\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n@@ -1207,6 +1207,6 @@ impl_load_from_cache!(\n     GenericsOfItem => generics_of,\n     PredicatesOfItem => predicates_of,\n     UsedTraitImports => used_trait_imports,\n-    TransFnAttrs => trans_fn_attrs,\n+    CodegenFnAttrs => codegen_fn_attrs,\n     SpecializationGraph => specialization_graph_of,\n );"}, {"sha": "ce7feae0719d06213a0cbf965903e99b683c1873", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -118,7 +118,7 @@ mod sty;\n // Data types\n \n /// The complete set of all analyses described in this module. This is\n-/// produced by the driver and fed to trans and later passes.\n+/// produced by the driver and fed to codegen and later passes.\n ///\n /// NB: These contents are being migrated into queries using the\n /// *on-demand* infrastructure.\n@@ -1426,7 +1426,7 @@ pub struct ParamEnv<'tcx> {\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: &'tcx Slice<ty::Predicate<'tcx>>,\n \n-    /// Typically, this is `Reveal::UserFacing`, but during trans we\n+    /// Typically, this is `Reveal::UserFacing`, but during codegen we\n     /// want `Reveal::All` -- note that this is always paired with an\n     /// empty environment. To get that, use `ParamEnv::reveal()`.\n     pub reveal: traits::Reveal,\n@@ -1444,7 +1444,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Construct a trait environment with no where clauses in scope\n     /// where the values of all `impl Trait` and other hidden types\n     /// are revealed. This is suitable for monomorphized, post-typeck\n-    /// environments like trans or doing optimizations.\n+    /// environments like codegen or doing optimizations.\n     ///\n     /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n@@ -1462,7 +1462,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Returns a new parameter environment with the same clauses, but\n     /// which \"reveals\" the true results of projections in all cases\n     /// (even for associated types that are specializable).  This is\n-    /// the desired behavior during trans and certain other special\n+    /// the desired behavior during codegen and certain other special\n     /// contexts; normally though we want to use `Reveal::UserFacing`,\n     /// which is the default.\n     pub fn with_reveal_all(self) -> Self {"}, {"sha": "4493c668593148614a0ec3f1f9dfca0f7896dacd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -243,7 +243,7 @@ pub enum TypeVariants<'tcx> {\n /// out later.\n ///\n /// All right, you say, but why include the type parameters from the\n-/// original function then? The answer is that trans may need them\n+/// original function then? The answer is that codegen may need them\n /// when monomorphizing, and they may not appear in the upvars.  A\n /// closure could capture no variables but still make use of some\n /// in-scope type parameter with a bound (e.g., if our example above\n@@ -273,7 +273,7 @@ pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with the types of the upvars.\n     ///\n-    /// These are separated out because trans wants to pass them around\n+    /// These are separated out because codegen wants to pass them around\n     /// when monomorphizing.\n     pub substs: &'tcx Substs<'tcx>,\n }\n@@ -1093,7 +1093,7 @@ pub enum RegionKind {\n     /// variable with no constraints.\n     ReEmpty,\n \n-    /// Erased region, used by trait selection, in MIR and during trans.\n+    /// Erased region, used by trait selection, in MIR and during codegen.\n     ReErased,\n \n     /// These are regions bound in the \"defining type\" for a"}, {"sha": "c66dd79cbf5e4bc70d7ca281147f207bef432804", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1135,7 +1135,7 @@ define_print! {\n                         })?\n                     } else {\n                         // cross-crate closure types should only be\n-                        // visible in trans bug reports, I imagine.\n+                        // visible in codegen bug reports, I imagine.\n                         write!(f, \"@{:?}\", did)?;\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n@@ -1175,7 +1175,7 @@ define_print! {\n                         })?\n                     } else {\n                         // cross-crate closure types should only be\n-                        // visible in trans bug reports, I imagine.\n+                        // visible in codegen bug reports, I imagine.\n                         write!(f, \"@{:?}\", did)?;\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {"}, {"sha": "6fc0ed47b807b9de89d03f3197ab6bafc39074f2", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1126,7 +1126,7 @@ fn foo(a: [D; 10], b: [D; 10], i: i32, t: bool) -> D {\n }\n ```\n \n-There are a number of ways that the trans backend could choose to\n+There are a number of ways that the codegen backend could choose to\n compile this (e.g. a `[bool; 10]` array for each such moved array;\n or an `Option<usize>` for each moved array).  From the viewpoint of the\n borrow-checker, the important thing is to record what kind of fragment"}, {"sha": "7cf0a1c1becaa53c69ac26fa6f0c62826c755837", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1,10 +1,10 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_trans\"\n+name = \"rustc_codegen_llvm\"\n version = \"0.0.0\"\n \n [lib]\n-name = \"rustc_trans\"\n+name = \"rustc_codegen_llvm\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n test = false\n@@ -27,7 +27,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n-rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n+rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_mir = { path = \"../librustc_mir\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n@@ -43,7 +43,7 @@ env_logger = { version = \"0.5\", default-features = false }\n # `rustc` driver script communicate this.\n jemalloc = [\"rustc_target/jemalloc\"]\n \n-# This is used to convince Cargo to separately cache builds of `rustc_trans`\n+# This is used to convince Cargo to separately cache builds of `rustc_codegen_llvm`\n # when this option is enabled or not. That way we can build two, cache two\n # artifacts, and have nice speedy rebuilds.\n emscripten = [\"rustc_llvm/emscripten\"]", "previous_filename": "src/librustc_trans/Cargo.toml"}, {"sha": "8d1c9a52b24289479478c4810e751eb9c1e3857e", "filename": "src/librustc_codegen_llvm/README.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FREADME.md?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -0,0 +1,7 @@\n+The `codegen` crate contains the code to convert from MIR into LLVM IR,\n+and then from LLVM IR into machine code. In general it contains code\n+that runs towards the end of the compilation process.\n+\n+For more information about how codegen works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/codegen.html"}, {"sha": "25c598c532c4897c66d4136c154fa77823ef43bc", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/abi.rs"}, {"sha": "eeb02e948f1ccbd7ec4471091e537e3ab5a607d7", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -20,7 +20,7 @@ use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n use ModuleLlvm;\n use llvm::{self, False, True};\n \n-pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n     let llcx = mods.llcx;\n     let llmod = mods.llmod;\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {", "previous_filename": "src/librustc_trans/allocator.rs"}, {"sha": "82f068106ff71839265c47f28a41a48272f05832", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # Translation of inline assembly.\n-\n use llvm::{self, ValueRef};\n use common::*;\n use type_::Type;\n@@ -26,7 +24,7 @@ use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'a, 'tcx>(\n+pub fn codegen_inline_asm<'a, 'tcx>(\n     bx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n     outputs: Vec<PlaceRef<'tcx>>,\n@@ -120,7 +118,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     }\n }\n \n-pub fn trans_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+pub fn codegen_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   ga: &hir::GlobalAsm) {\n     let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n     unsafe {", "previous_filename": "src/librustc_trans/asm.rs"}, {"sha": "b64e102ba788252a20e0e8f89ba93e5d01d1b33b", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n \n use std::ffi::{CStr, CString};\n \n-use rustc::hir::{self, TransFnAttrFlags};\n+use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::session::Session;\n@@ -118,34 +118,34 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n-    let trans_fn_attrs = cx.tcx.trans_fn_attrs(id);\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(id);\n \n-    inline(llfn, trans_fn_attrs.inline);\n+    inline(llfn, codegen_fn_attrs.inline);\n \n     set_frame_pointer_elimination(cx, llfn);\n     set_probestack(cx, llfn);\n \n-    if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n         Attribute::Cold.apply_llfn(Function, llfn);\n     }\n-    if trans_fn_attrs.flags.contains(TransFnAttrFlags::NAKED) {\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n         naked(llfn, true);\n     }\n-    if trans_fn_attrs.flags.contains(TransFnAttrFlags::ALLOCATOR) {\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::ALLOCATOR) {\n         Attribute::NoAlias.apply_llfn(\n             llvm::AttributePlace::ReturnValue, llfn);\n     }\n-    if trans_fn_attrs.flags.contains(TransFnAttrFlags::UNWIND) {\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n         unwind(llfn, true);\n     }\n-    if trans_fn_attrs.flags.contains(TransFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n         unwind(llfn, false);\n     }\n \n     let features = llvm_target_features(cx.tcx.sess)\n         .map(|s| s.to_string())\n         .chain(\n-            trans_fn_attrs.target_features\n+            codegen_fn_attrs.target_features\n                 .iter()\n                 .map(|f| {\n                     let feature = &*f.as_str();", "previous_filename": "src/librustc_trans/attributes.rs"}, {"sha": "609629bffb9dad4f48318015f89bcfdeea605850", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/back/archive.rs"}, {"sha": "212d1aaf055d183840548cb8c75c94921ef3801f", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/back/bytecode.rs"}, {"sha": "9ebbdd7c3c936eefdde8466292c4cb34f5337458", "filename": "src/librustc_codegen_llvm/back/command.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fcommand.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/back/command.rs"}, {"sha": "dbfd430a3e2e7815efdc48c9bb1675ac9ce2b34c", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "renamed", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -24,7 +24,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n use rustc::middle::cstore::{NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n-use {CrateTranslation, CrateInfo};\n+use {CodegenResults, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::hir::def_id::CrateNum;\n@@ -52,7 +52,7 @@ pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n // same as for metadata above, but for allocator shim\n pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n \n-pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n+pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n                                   check_file_is_writeable};\n \n@@ -141,14 +141,14 @@ pub fn remove(sess: &Session, path: &Path) {\n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n pub(crate) fn link_binary(sess: &Session,\n-                          trans: &CrateTranslation,\n+                          codegen_results: &CodegenResults,\n                           outputs: &OutputFilenames,\n                           crate_name: &str) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n-        // Ignore executable crates if we have -Z no-trans, as they will error.\n+        // Ignore executable crates if we have -Z no-codegen, as they will error.\n         let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n-        if (sess.opts.debugging_opts.no_trans || !sess.opts.output_types.should_trans()) &&\n+        if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n            !output_metadata &&\n            crate_type == config::CrateTypeExecutable {\n             continue;\n@@ -159,7 +159,7 @@ pub(crate) fn link_binary(sess: &Session,\n                 crate_type, sess.opts.target_triple);\n         }\n         let mut out_files = link_binary_output(sess,\n-                                               trans,\n+                                               codegen_results,\n                                                crate_type,\n                                                outputs,\n                                                crate_name);\n@@ -168,20 +168,20 @@ pub(crate) fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_trans() &&\n+        if sess.opts.output_types.should_codegen() &&\n             !preserve_objects_for_their_debuginfo(sess)\n         {\n-            for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+            for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n                 remove(sess, obj);\n             }\n         }\n-        for obj in trans.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+        for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n             remove(sess, obj);\n         }\n-        if let Some(ref obj) = trans.metadata_module.object {\n+        if let Some(ref obj) = codegen_results.metadata_module.object {\n             remove(sess, obj);\n         }\n-        if let Some(ref allocator) = trans.allocator_module {\n+        if let Some(ref allocator) = codegen_results.allocator_module {\n             if let Some(ref obj) = allocator.object {\n                 remove(sess, obj);\n             }\n@@ -304,11 +304,11 @@ pub(crate) fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum)\n }\n \n fn link_binary_output(sess: &Session,\n-                      trans: &CrateTranslation,\n+                      codegen_results: &CodegenResults,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> Vec<PathBuf> {\n-    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         check_file_is_writeable(obj, sess);\n     }\n \n@@ -325,7 +325,7 @@ fn link_binary_output(sess: &Session,\n             Ok(tmpdir) => tmpdir,\n             Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n         };\n-        let metadata = emit_metadata(sess, trans, &metadata_tmpdir);\n+        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n         if let Err(e) = fs::rename(metadata, &out_filename) {\n             sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }\n@@ -337,21 +337,21 @@ fn link_binary_output(sess: &Session,\n         Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n     };\n \n-    if outputs.outputs.should_trans() {\n+    if outputs.outputs.should_codegen() {\n         let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n         match crate_type {\n             config::CrateTypeRlib => {\n                 link_rlib(sess,\n-                          trans,\n+                          codegen_results,\n                           RlibFlavor::Normal,\n                           &out_filename,\n                           &tmpdir).build();\n             }\n             config::CrateTypeStaticlib => {\n-                link_staticlib(sess, trans, &out_filename, &tmpdir);\n+                link_staticlib(sess, codegen_results, &out_filename, &tmpdir);\n             }\n             _ => {\n-                link_natively(sess, crate_type, &out_filename, trans, tmpdir.path());\n+                link_natively(sess, crate_type, &out_filename, codegen_results, tmpdir.path());\n             }\n         }\n         out_filenames.push(out_filename);\n@@ -388,10 +388,10 @@ fn archive_config<'a>(sess: &'a Session,\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, tmpdir: &TempDir)\n+fn emit_metadata<'a>(sess: &'a Session, codegen_results: &CodegenResults, tmpdir: &TempDir)\n                      -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &trans.metadata.raw_data);\n+    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n@@ -412,14 +412,14 @@ enum RlibFlavor {\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n fn link_rlib<'a>(sess: &'a Session,\n-                 trans: &CrateTranslation,\n+                 codegen_results: &CodegenResults,\n                  flavor: RlibFlavor,\n                  out_filename: &Path,\n                  tmpdir: &TempDir) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n \n-    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         ab.add_file(obj);\n     }\n \n@@ -439,7 +439,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     // feature then we'll need to figure out how to record what objects were\n     // loaded from the libraries found here and then encode that into the\n     // metadata of the rlib we're generating somehow.\n-    for lib in trans.crate_info.used_libraries.iter() {\n+    for lib in codegen_results.crate_info.used_libraries.iter() {\n         match lib.kind {\n             NativeLibraryKind::NativeStatic => {}\n             NativeLibraryKind::NativeStaticNobundle |\n@@ -478,11 +478,15 @@ fn link_rlib<'a>(sess: &'a Session,\n         RlibFlavor::Normal => {\n             // Instead of putting the metadata in an object file section, rlibs\n             // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, trans, tmpdir));\n+            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.\n-            for bytecode in trans.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+            for bytecode in codegen_results\n+                .modules\n+                .iter()\n+                .filter_map(|m| m.bytecode_compressed.as_ref())\n+            {\n                 ab.add_file(bytecode);\n             }\n \n@@ -495,7 +499,7 @@ fn link_rlib<'a>(sess: &'a Session,\n         }\n \n         RlibFlavor::StaticlibBase => {\n-            let obj = trans.allocator_module\n+            let obj = codegen_results.allocator_module\n                 .as_ref()\n                 .and_then(|m| m.object.as_ref());\n             if let Some(obj) = obj {\n@@ -520,19 +524,19 @@ fn link_rlib<'a>(sess: &'a Session,\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n fn link_staticlib(sess: &Session,\n-                  trans: &CrateTranslation,\n+                  codegen_results: &CodegenResults,\n                   out_filename: &Path,\n                   tempdir: &TempDir) {\n     let mut ab = link_rlib(sess,\n-                           trans,\n+                           codegen_results,\n                            RlibFlavor::StaticlibBase,\n                            out_filename,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &trans.crate_info, &mut |cnum, path| {\n-        let name = &trans.crate_info.crate_name[&cnum];\n-        let native_libs = &trans.crate_info.native_libraries[&cnum];\n+    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n+        let name = &codegen_results.crate_info.crate_name[&cnum];\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n \n         // Here when we include the rlib into our staticlib we need to make a\n         // decision whether to include the extra object files along the way.\n@@ -554,10 +558,10 @@ fn link_staticlib(sess: &Session,\n         ab.add_rlib(path,\n                     &name.as_str(),\n                     is_full_lto_enabled(sess) &&\n-                        !ignored_for_lto(sess, &trans.crate_info, cnum),\n+                        !ignored_for_lto(sess, &codegen_results.crate_info, cnum),\n                     skip_object_files).unwrap();\n \n-        all_native_libs.extend(trans.crate_info.native_libraries[&cnum].iter().cloned());\n+        all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n     });\n     if let Err(e) = res {\n         sess.fatal(&e);\n@@ -609,7 +613,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n fn link_natively(sess: &Session,\n                  crate_type: config::CrateType,\n                  out_filename: &Path,\n-                 trans: &CrateTranslation,\n+                 codegen_results: &CodegenResults,\n                  tmpdir: &Path) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let flavor = sess.linker_flavor();\n@@ -662,9 +666,9 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = trans.linker_info.to_linker(cmd, &sess);\n+        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  out_filename, trans);\n+                  out_filename, codegen_results);\n         cmd = linker.finalize();\n     }\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n@@ -842,9 +846,9 @@ fn link_natively(sess: &Session,\n     }\n \n     if sess.opts.target_triple == TargetTriple::from_triple(\"wasm32-unknown-unknown\") {\n-        wasm::rewrite_imports(&out_filename, &trans.crate_info.wasm_imports);\n+        wasm::rewrite_imports(&out_filename, &codegen_results.crate_info.wasm_imports);\n         wasm::add_custom_sections(&out_filename,\n-                                  &trans.crate_info.wasm_custom_sections);\n+                                  &codegen_results.crate_info.wasm_custom_sections);\n     }\n }\n \n@@ -995,7 +999,7 @@ fn link_args(cmd: &mut Linker,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n              out_filename: &Path,\n-             trans: &CrateTranslation) {\n+             codegen_results: &CodegenResults) {\n \n     // Linker plugins should be specified early in the list of arguments\n     cmd.cross_lang_lto();\n@@ -1008,14 +1012,14 @@ fn link_args(cmd: &mut Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         cmd.add_object(obj);\n     }\n     cmd.output_filename(out_filename);\n \n     if crate_type == config::CrateTypeExecutable &&\n        sess.target.target.options.is_like_windows {\n-        if let Some(ref s) = trans.windows_subsystem {\n+        if let Some(ref s) = codegen_results.windows_subsystem {\n             cmd.subsystem(s);\n         }\n     }\n@@ -1032,12 +1036,12 @@ fn link_args(cmd: &mut Linker,\n     // object file, so we link that in here.\n     if crate_type == config::CrateTypeDylib ||\n        crate_type == config::CrateTypeProcMacro {\n-        if let Some(obj) = trans.metadata_module.object.as_ref() {\n+        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n             cmd.add_object(obj);\n         }\n     }\n \n-    let obj = trans.allocator_module\n+    let obj = codegen_results.allocator_module\n         .as_ref()\n         .and_then(|m| m.object.as_ref());\n     if let Some(obj) = obj {\n@@ -1051,7 +1055,7 @@ fn link_args(cmd: &mut Linker,\n         cmd.gc_sections(keep_metadata);\n     }\n \n-    let used_link_args = &trans.crate_info.link_args;\n+    let used_link_args = &codegen_results.crate_info.link_args;\n \n     if crate_type == config::CrateTypeExecutable {\n         let mut position_independent_executable = false;\n@@ -1140,9 +1144,9 @@ fn link_args(cmd: &mut Linker,\n     // link line. And finally upstream native libraries can't depend on anything\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n     // on other dylibs (e.g. other native deps).\n-    add_local_native_libraries(cmd, sess, trans);\n-    add_upstream_rust_crates(cmd, sess, trans, crate_type, tmpdir);\n-    add_upstream_native_libraries(cmd, sess, trans, crate_type);\n+    add_local_native_libraries(cmd, sess, codegen_results);\n+    add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n \n     // Tell the linker what we're doing.\n     if crate_type != config::CrateTypeExecutable {\n@@ -1171,7 +1175,7 @@ fn link_args(cmd: &mut Linker,\n             path\n         };\n         let mut rpath_config = RPathConfig {\n-            used_crates: &trans.crate_info.used_crates_dynamic,\n+            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n@@ -1203,15 +1207,15 @@ fn link_args(cmd: &mut Linker,\n // may have their native library pulled in above.\n fn add_local_native_libraries(cmd: &mut Linker,\n                               sess: &Session,\n-                              trans: &CrateTranslation) {\n+                              codegen_results: &CodegenResults) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n             PathKind::Framework => { cmd.framework_path(path); }\n             _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n     });\n \n-    let relevant_libs = trans.crate_info.used_libraries.iter().filter(|l| {\n+    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n         relevant_lib(sess, l)\n     });\n \n@@ -1234,7 +1238,7 @@ fn add_local_native_libraries(cmd: &mut Linker,\n // the intermediate rlib version)\n fn add_upstream_rust_crates(cmd: &mut Linker,\n                             sess: &Session,\n-                            trans: &CrateTranslation,\n+                            codegen_results: &CodegenResults,\n                             crate_type: config::CrateType,\n                             tmpdir: &Path) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1250,7 +1254,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n-    let deps = &trans.crate_info.used_crates_dynamic;\n+    let deps = &codegen_results.crate_info.used_crates_dynamic;\n \n     // There's a few internal crates in the standard library (aka libcore and\n     // libstd) which actually have a circular dependence upon one another. This\n@@ -1273,7 +1277,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     let mut group_end = None;\n     let mut group_start = None;\n     let mut end_with = FxHashSet();\n-    let info = &trans.crate_info;\n+    let info = &codegen_results.crate_info;\n     for &(cnum, _) in deps.iter().rev() {\n         if let Some(missing) = info.missing_lang_items.get(&cnum) {\n             end_with.extend(missing.iter().cloned());\n@@ -1305,24 +1309,24 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n-            _ if trans.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n+            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n+                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n             }\n-            _ if trans.crate_info.sanitizer_runtime == Some(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, trans, tmpdir, cnum);\n+            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n+                link_sanitizer_runtime(cmd, sess, codegen_results, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n-            _ if trans.crate_info.compiler_builtins == Some(cnum) => {\n+            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n                 assert!(compiler_builtins.is_none());\n                 compiler_builtins = Some(cnum);\n             }\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n+                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n             }\n             Linkage::Dynamic => {\n                 add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n@@ -1340,7 +1344,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // was already \"included\" in a dylib (e.g. `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n+        add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -1358,10 +1362,10 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // linking it.\n     fn link_sanitizer_runtime(cmd: &mut Linker,\n                               sess: &Session,\n-                              trans: &CrateTranslation,\n+                              codegen_results: &CodegenResults,\n                               tmpdir: &Path,\n                               cnum: CrateNum) {\n-        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         if sess.target.target.options.is_like_osx {\n@@ -1427,23 +1431,23 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // we're at the end of the dependency chain.\n     fn add_static_crate(cmd: &mut Linker,\n                         sess: &Session,\n-                        trans: &CrateTranslation,\n+                        codegen_results: &CodegenResults,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n                         cnum: CrateNum) {\n-        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         // See the comment above in `link_staticlib` and `link_rlib` for why if\n         // there's a static library that's not relevant we skip all object\n         // files.\n-        let native_libs = &trans.crate_info.native_libraries[&cnum];\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n         let skip_native = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n         if (!is_full_lto_enabled(sess) ||\n-            ignored_for_lto(sess, &trans.crate_info, cnum)) &&\n+            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n            crate_type != config::CrateTypeDylib &&\n            !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1499,7 +1503,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 let skip_because_lto = is_full_lto_enabled(sess) &&\n                     is_rust_object &&\n                     (sess.target.target.options.no_builtins ||\n-                     !trans.crate_info.is_no_builtins.contains(&cnum));\n+                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n                     archive.remove_file(&f);\n@@ -1521,7 +1525,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             // compiler-builtins crate (e.g. compiler-rt) because it'll get\n             // repeatedly linked anyway.\n             if crate_type == config::CrateTypeDylib &&\n-                trans.crate_info.compiler_builtins != Some(cnum) {\n+                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n                 cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n             } else {\n                 cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n@@ -1567,7 +1571,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n // also be resolved in the target crate.\n fn add_upstream_native_libraries(cmd: &mut Linker,\n                                  sess: &Session,\n-                                 trans: &CrateTranslation,\n+                                 codegen_results: &CodegenResults,\n                                  crate_type: config::CrateType) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n@@ -1581,9 +1585,9 @@ fn add_upstream_native_libraries(cmd: &mut Linker,\n     let formats = sess.dependency_formats.borrow();\n     let data = formats.get(&crate_type).unwrap();\n \n-    let crates = &trans.crate_info.used_crates_static;\n+    let crates = &codegen_results.crate_info.used_crates_static;\n     for &(cnum, _) in crates {\n-        for lib in trans.crate_info.native_libraries[&cnum].iter() {\n+        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n             if !relevant_lib(sess, &lib) {\n                 continue\n             }", "previous_filename": "src/librustc_trans/back/link.rs"}, {"sha": "dd1983bdc1723d57bc67343b2f49dcd43ff447cc", "filename": "src/librustc_codegen_llvm/back/linker.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -641,7 +641,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n     //\n     // The linker will read this `*.def` file and export all the symbols from\n     // the dynamic library. Note that this is not as simple as just exporting\n-    // all the symbols in the current crate (as specified by `trans.reachable`)\n+    // all the symbols in the current crate (as specified by `codegen.reachable`)\n     // but rather we also need to possibly export the symbols of upstream\n     // crates. Upstream rlibs may be linked statically to this dynamic library,\n     // in which case they may continue to transitively be used and hence need", "previous_filename": "src/librustc_trans/back/linker.rs"}, {"sha": "96eda50d7883573340eb1aff7e2628df307ddbbd", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "renamed", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -21,7 +21,7 @@ use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n use time_graph::Timeline;\n-use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n+use {ModuleCodegen, ModuleLlvm, ModuleKind, ModuleSource};\n \n use libc;\n \n@@ -42,45 +42,45 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-pub(crate) enum LtoModuleTranslation {\n+pub(crate) enum LtoModuleCodegen {\n     Fat {\n-        module: Option<ModuleTranslation>,\n+        module: Option<ModuleCodegen>,\n         _serialized_bitcode: Vec<SerializedModule>,\n     },\n \n     Thin(ThinModule),\n }\n \n-impl LtoModuleTranslation {\n+impl LtoModuleCodegen {\n     pub fn name(&self) -> &str {\n         match *self {\n-            LtoModuleTranslation::Fat { .. } => \"everything\",\n-            LtoModuleTranslation::Thin(ref m) => m.name(),\n+            LtoModuleCodegen::Fat { .. } => \"everything\",\n+            LtoModuleCodegen::Thin(ref m) => m.name(),\n         }\n     }\n \n     /// Optimize this module within the given codegen context.\n     ///\n-    /// This function is unsafe as it'll return a `ModuleTranslation` still\n-    /// points to LLVM data structures owned by this `LtoModuleTranslation`.\n+    /// This function is unsafe as it'll return a `ModuleCodegen` still\n+    /// points to LLVM data structures owned by this `LtoModuleCodegen`.\n     /// It's intended that the module returned is immediately code generated and\n     /// dropped, and then this LTO module is dropped.\n     pub(crate) unsafe fn optimize(&mut self,\n                                   cgcx: &CodegenContext,\n                                   timeline: &mut Timeline)\n-        -> Result<ModuleTranslation, FatalError>\n+        -> Result<ModuleCodegen, FatalError>\n     {\n         match *self {\n-            LtoModuleTranslation::Fat { ref mut module, .. } => {\n-                let trans = module.take().unwrap();\n-                let config = cgcx.config(trans.kind);\n-                let llmod = trans.llvm().unwrap().llmod;\n-                let tm = trans.llvm().unwrap().tm;\n+            LtoModuleCodegen::Fat { ref mut module, .. } => {\n+                let module = module.take().unwrap();\n+                let config = cgcx.config(module.kind);\n+                let llmod = module.llvm().unwrap().llmod;\n+                let tm = module.llvm().unwrap().tm;\n                 run_pass_manager(cgcx, tm, llmod, config, false);\n                 timeline.record(\"fat-done\");\n-                Ok(trans)\n+                Ok(module)\n             }\n-            LtoModuleTranslation::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n+            LtoModuleCodegen::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n         }\n     }\n \n@@ -89,16 +89,16 @@ impl LtoModuleTranslation {\n     pub fn cost(&self) -> u64 {\n         match *self {\n             // Only one module with fat LTO, so the cost doesn't matter.\n-            LtoModuleTranslation::Fat { .. } => 0,\n-            LtoModuleTranslation::Thin(ref m) => m.cost(),\n+            LtoModuleCodegen::Fat { .. } => 0,\n+            LtoModuleCodegen::Thin(ref m) => m.cost(),\n         }\n     }\n }\n \n pub(crate) fn run(cgcx: &CodegenContext,\n-                  modules: Vec<ModuleTranslation>,\n+                  modules: Vec<ModuleCodegen>,\n                   timeline: &mut Timeline)\n-    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+    -> Result<Vec<LtoModuleCodegen>, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n     let export_threshold = match cgcx.lto {\n@@ -201,11 +201,11 @@ pub(crate) fn run(cgcx: &CodegenContext,\n \n fn fat_lto(cgcx: &CodegenContext,\n            diag_handler: &Handler,\n-           mut modules: Vec<ModuleTranslation>,\n+           mut modules: Vec<ModuleCodegen>,\n            mut serialized_modules: Vec<(SerializedModule, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n-    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+    -> Result<Vec<LtoModuleCodegen>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n@@ -228,18 +228,18 @@ fn fat_lto(cgcx: &CodegenContext,\n             (cost, i)\n         })\n         .max()\n-        .expect(\"must be trans'ing at least one module\");\n+        .expect(\"must be codegen'ing at least one module\");\n     let module = modules.remove(costliest_module);\n-    let llmod = module.llvm().expect(\"can't lto pre-translated modules\").llmod;\n+    let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod;\n     info!(\"using {:?} as a base module\", module.llmod_id);\n \n-    // For all other modules we translated we'll need to link them into our own\n-    // bitcode. All modules were translated in their own LLVM context, however,\n+    // For all other modules we codegened we'll need to link them into our own\n+    // bitcode. All modules were codegened in their own LLVM context, however,\n     // and we want to move everything to the same LLVM context. Currently the\n     // way we know of to do that is to serialize them to a string and them parse\n     // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n     for module in modules {\n-        let llvm = module.llvm().expect(\"can't lto pre-translated modules\");\n+        let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n         let buffer = ModuleBuffer::new(llvm.llmod);\n         let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n         serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n@@ -284,7 +284,7 @@ fn fat_lto(cgcx: &CodegenContext,\n     }\n     timeline.record(\"passes\");\n \n-    Ok(vec![LtoModuleTranslation::Fat {\n+    Ok(vec![LtoModuleCodegen::Fat {\n         module: Some(module),\n         _serialized_bitcode: serialized_bitcode,\n     }])\n@@ -344,14 +344,14 @@ impl Drop for Linker {\n ///\n /// With all that in mind, the function here is designed at specifically just\n /// calculating the *index* for ThinLTO. This index will then be shared amongst\n-/// all of the `LtoModuleTranslation` units returned below and destroyed once\n+/// all of the `LtoModuleCodegen` units returned below and destroyed once\n /// they all go out of scope.\n fn thin_lto(diag_handler: &Handler,\n-            modules: Vec<ModuleTranslation>,\n+            modules: Vec<ModuleCodegen>,\n             serialized_modules: Vec<(SerializedModule, CString)>,\n             symbol_white_list: &[*const libc::c_char],\n             timeline: &mut Timeline)\n-    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+    -> Result<Vec<LtoModuleCodegen>, FatalError>\n {\n     unsafe {\n         info!(\"going for that thin, thin LTO\");\n@@ -369,7 +369,7 @@ fn thin_lto(diag_handler: &Handler,\n         //        analysis!\n         for (i, module) in modules.iter().enumerate() {\n             info!(\"local module: {} - {}\", i, module.llmod_id);\n-            let llvm = module.llvm().expect(\"can't lto pretranslated module\");\n+            let llvm = module.llvm().expect(\"can't lto precodegened module\");\n             let name = CString::new(module.llmod_id.clone()).unwrap();\n             let buffer = ThinBuffer::new(llvm.llmod);\n             thin_modules.push(llvm::ThinLTOModule {\n@@ -431,15 +431,15 @@ fn thin_lto(diag_handler: &Handler,\n         // Throw our data in an `Arc` as we'll be sharing it across threads. We\n         // also put all memory referenced by the C++ data (buffers, ids, etc)\n         // into the arc as well. After this we'll create a thin module\n-        // translation per module in this data.\n+        // codegen per module in this data.\n         let shared = Arc::new(ThinShared {\n             data,\n             thin_buffers,\n             serialized_modules: serialized,\n             module_names,\n         });\n         Ok((0..shared.module_names.len()).map(|i| {\n-            LtoModuleTranslation::Thin(ThinModule {\n+            LtoModuleCodegen::Thin(ThinModule {\n                 shared: shared.clone(),\n                 idx: i,\n             })\n@@ -622,7 +622,7 @@ impl ThinModule {\n     }\n \n     unsafe fn optimize(&mut self, cgcx: &CodegenContext, timeline: &mut Timeline)\n-        -> Result<ModuleTranslation, FatalError>\n+        -> Result<ModuleCodegen, FatalError>\n     {\n         let diag_handler = cgcx.create_diag_handler();\n         let tm = (cgcx.tm_factory)().map_err(|e| {\n@@ -632,7 +632,7 @@ impl ThinModule {\n         // Right now the implementation we've got only works over serialized\n         // modules, so we create a fresh new LLVM context and parse the module\n         // into that context. One day, however, we may do this for upstream\n-        // crates but for locally translated modules we may be able to reuse\n+        // crates but for locally codegened modules we may be able to reuse\n         // that LLVM Context and Module.\n         let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n         let llmod = llvm::LLVMRustParseBitcodeForThinLTO(\n@@ -645,8 +645,8 @@ impl ThinModule {\n             let msg = format!(\"failed to parse bitcode for thin LTO module\");\n             return Err(write::llvm_err(&diag_handler, msg));\n         }\n-        let mtrans = ModuleTranslation {\n-            source: ModuleSource::Translated(ModuleLlvm {\n+        let module = ModuleCodegen {\n+            source: ModuleSource::Codegened(ModuleLlvm {\n                 llmod,\n                 llcx,\n                 tm,\n@@ -655,7 +655,7 @@ impl ThinModule {\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,\n         };\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-input\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-input\");\n \n         // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n         // using below. If we find more than one though then rustc has changed\n@@ -673,7 +673,7 @@ impl ThinModule {\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-            cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-nounwind\");\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-nounwind\");\n             timeline.record(\"nounwind\");\n         }\n \n@@ -689,25 +689,25 @@ impl ThinModule {\n             let msg = format!(\"failed to prepare thin LTO module\");\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-rename\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n         timeline.record(\"rename\");\n         if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n             let msg = format!(\"failed to prepare thin LTO module\");\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-resolve\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n         timeline.record(\"resolve\");\n         if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n             let msg = format!(\"failed to prepare thin LTO module\");\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-internalize\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n         timeline.record(\"internalize\");\n         if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n             let msg = format!(\"failed to prepare thin LTO module\");\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-import\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n         timeline.record(\"import\");\n \n         // Ok now this is a bit unfortunate. This is also something you won't\n@@ -740,18 +740,18 @@ impl ThinModule {\n         // so it appears). Hopefully we can remove this once upstream bugs are\n         // fixed in LLVM.\n         llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-patch\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-patch\");\n         timeline.record(\"patch\");\n \n         // Alright now that we've done everything related to the ThinLTO\n         // analysis it's time to run some optimizations! Here we use the same\n         // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n         // populate a thin-specific pass manager, which presumably LLVM treats a\n         // little differently.\n-        info!(\"running thin lto passes over {}\", mtrans.name);\n-        let config = cgcx.config(mtrans.kind);\n+        info!(\"running thin lto passes over {}\", module.name);\n+        let config = cgcx.config(module.kind);\n         run_pass_manager(cgcx, tm, llmod, config, true);\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-pm\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n         timeline.record(\"thin-done\");\n \n         // FIXME: this is a hack around a bug in LLVM right now. Discovered in\n@@ -765,9 +765,9 @@ impl ThinModule {\n         // shouldn't be necessary eventually and we can safetly delete these few\n         // lines.\n         llvm::LLVMRustThinLTORemoveAvailableExternally(llmod);\n-        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-rm-ae\");\n+        cgcx.save_temp_bitcode(&module, \"thin-lto-after-rm-ae\");\n         timeline.record(\"no-ae\");\n \n-        Ok(mtrans)\n+        Ok(module)\n     }\n }", "previous_filename": "src/librustc_trans/back/lto.rs"}, {"sha": "8e5e7d376488b7df5b69af8b100b736f6fe15a8d", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/back/rpath.rs"}, {"sha": "81ac684aee245b222dd89e7b21abc7f6bea65c45", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -13,7 +13,7 @@ use std::sync::Arc;\n \n use monomorphize::Instance;\n use rustc::hir;\n-use rustc::hir::TransFnAttrFlags;\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::ich::Fingerprint;\n use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol, metadata_symbol_name};\n@@ -63,7 +63,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    if !tcx.sess.opts.output_types.should_trans() {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n         return Lrc::new(DefIdMap())\n     }\n \n@@ -118,7 +118,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let def_id = tcx.hir.local_def_id(node_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx) &&\n-                        // Functions marked with #[inline] are only ever translated\n+                        // Functions marked with #[inline] are only ever codegened\n                         // with \"internal\" linkage and are never exported.\n                         !Instance::mono(tcx, def_id).def.requires_local(tcx) {\n                         Some(def_id)\n@@ -195,7 +195,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    if !tcx.sess.opts.output_types.should_trans() {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n         return Arc::new(vec![])\n     }\n \n@@ -255,7 +255,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let need_visibility = tcx.sess.target.target.options.dynamic_linking &&\n                               !tcx.sess.target.target.options.only_cdylib;\n \n-        let (_, cgus) = tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n+        let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n \n         for (mono_item, &(linkage, visibility)) in cgus.iter()\n                                                        .flat_map(|cgu| cgu.items().iter()) {\n@@ -383,9 +383,10 @@ fn symbol_export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n     // special symbols in the standard library for various plumbing between\n     // core/std/allocators/etc. For example symbols used to hook up allocation\n     // are not considered for export\n-    let trans_fn_attrs = tcx.trans_fn_attrs(sym_def_id);\n-    let is_extern = trans_fn_attrs.contains_extern_indicator();\n-    let std_internal = trans_fn_attrs.flags.contains(TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n+    let codegen_fn_attrs = tcx.codegen_fn_attrs(sym_def_id);\n+    let is_extern = codegen_fn_attrs.contains_extern_indicator();\n+    let std_internal =\n+        codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n \n     if is_extern && !std_internal {\n         SymbolExportLevel::C", "previous_filename": "src/librustc_trans/back/symbol_export.rs"}, {"sha": "d6d386c9fbe77d74cd3468c1aed99fdf985c1704", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/back/wasm.rs"}, {"sha": "1151e0131313dee3db9b2e3bb5847e6f3efcb77e", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "renamed", "additions": 105, "deletions": 107, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -28,7 +28,7 @@ use time_graph::{self, TimeGraph, Timeline};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::{SMDiagnosticRef, ContextRef};\n-use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n+use {CodegenResults, ModuleSource, ModuleCodegen, CompiledModule, ModuleKind};\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n@@ -383,16 +383,16 @@ impl CodegenContext {\n         }\n     }\n \n-    pub(crate) fn save_temp_bitcode(&self, trans: &ModuleTranslation, name: &str) {\n+    pub(crate) fn save_temp_bitcode(&self, module: &ModuleCodegen, name: &str) {\n         if !self.save_temps {\n             return\n         }\n         unsafe {\n             let ext = format!(\"{}.bc\", name);\n-            let cgu = Some(&trans.name[..]);\n+            let cgu = Some(&module.name[..]);\n             let path = self.output_filenames.temp_path_ext(&ext, cgu);\n             let cstr = path2cstr(&path);\n-            let llmod = trans.llvm().unwrap().llmod;\n+            let llmod = module.llvm().unwrap().llmod;\n             llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n         }\n     }\n@@ -491,21 +491,21 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n // Unsafe due to LLVM calls.\n unsafe fn optimize(cgcx: &CodegenContext,\n                    diag_handler: &Handler,\n-                   mtrans: &ModuleTranslation,\n+                   module: &ModuleCodegen,\n                    config: &ModuleConfig,\n                    timeline: &mut Timeline)\n     -> Result<(), FatalError>\n {\n-    let (llmod, llcx, tm) = match mtrans.source {\n-        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n+    let (llmod, llcx, tm) = match module.source {\n+        ModuleSource::Codegened(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n         ModuleSource::Preexisting(_) => {\n             bug!(\"optimize_and_codegen: called with ModuleSource::Preexisting\")\n         }\n     };\n \n     let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n-    let module_name = mtrans.name.clone();\n+    let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n \n     if config.emit_no_opt_bc {\n@@ -594,12 +594,12 @@ unsafe fn optimize(cgcx: &CodegenContext,\n }\n \n fn generate_lto_work(cgcx: &CodegenContext,\n-                     modules: Vec<ModuleTranslation>)\n+                     modules: Vec<ModuleCodegen>)\n     -> Vec<(WorkItem, u64)>\n {\n     let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n-        tg.start(TRANS_WORKER_TIMELINE,\n-                 TRANS_WORK_PACKAGE_KIND,\n+        tg.start(CODEGEN_WORKER_TIMELINE,\n+                 CODEGEN_WORK_PACKAGE_KIND,\n                  \"generate lto\")\n     }).unwrap_or(Timeline::noop());\n     let lto_modules = lto::run(cgcx, modules, &mut timeline)\n@@ -613,19 +613,19 @@ fn generate_lto_work(cgcx: &CodegenContext,\n \n unsafe fn codegen(cgcx: &CodegenContext,\n                   diag_handler: &Handler,\n-                  mtrans: ModuleTranslation,\n+                  module: ModuleCodegen,\n                   config: &ModuleConfig,\n                   timeline: &mut Timeline)\n     -> Result<CompiledModule, FatalError>\n {\n     timeline.record(\"codegen\");\n-    let (llmod, llcx, tm) = match mtrans.source {\n-        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n+    let (llmod, llcx, tm) = match module.source {\n+        ModuleSource::Codegened(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n         ModuleSource::Preexisting(_) => {\n             bug!(\"codegen: called with ModuleSource::Preexisting\")\n         }\n     };\n-    let module_name = mtrans.name.clone();\n+    let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n     let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n@@ -696,7 +696,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n \n         if config.emit_bc_compressed {\n             let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-            let data = bytecode::encode(&mtrans.llmod_id, data);\n+            let data = bytecode::encode(&module.llmod_id, data);\n             if let Err(e) = fs::write(&dst, data) {\n                 diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n             }\n@@ -805,7 +805,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     }\n \n     drop(handlers);\n-    Ok(mtrans.into_compiled_module(config.emit_obj,\n+    Ok(module.into_compiled_module(config.emit_obj,\n                                    config.emit_bc,\n                                    config.emit_bc_compressed,\n                                    &cgcx.output_filenames))\n@@ -880,13 +880,13 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n-pub fn start_async_translation(tcx: TyCtxt,\n+pub fn start_async_codegen(tcx: TyCtxt,\n                                time_graph: Option<TimeGraph>,\n                                link: LinkMeta,\n                                metadata: EncodedMetadata,\n                                coordinator_receive: Receiver<Box<Any + Send>>,\n                                total_cgus: usize)\n-                               -> OngoingCrateTranslation {\n+                               -> OngoingCodegen {\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n@@ -991,12 +991,12 @@ pub fn start_async_translation(tcx: TyCtxt,\n     allocator_config.time_passes = false;\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n-    let (trans_worker_send, trans_worker_receive) = channel();\n+    let (codegen_worker_send, codegen_worker_receive) = channel();\n \n     let coordinator_thread = start_executing_work(tcx,\n                                                   &crate_info,\n                                                   shared_emitter,\n-                                                  trans_worker_send,\n+                                                  codegen_worker_send,\n                                                   coordinator_receive,\n                                                   total_cgus,\n                                                   sess.jobserver.clone(),\n@@ -1005,7 +1005,7 @@ pub fn start_async_translation(tcx: TyCtxt,\n                                                   Arc::new(metadata_config),\n                                                   Arc::new(allocator_config));\n \n-    OngoingCrateTranslation {\n+    OngoingCodegen {\n         crate_name,\n         link,\n         metadata,\n@@ -1015,7 +1015,7 @@ pub fn start_async_translation(tcx: TyCtxt,\n \n         time_graph,\n         coordinator_send: tcx.tx_to_llvm_workers.lock().clone(),\n-        trans_worker_receive,\n+        codegen_worker_receive,\n         shared_emitter_main,\n         future: coordinator_thread,\n         output_filenames: tcx.output_filenames(LOCAL_CRATE),\n@@ -1204,15 +1204,15 @@ fn produce_final_output_artifacts(sess: &Session,\n     // These are used in linking steps and will be cleaned up afterward.\n }\n \n-pub(crate) fn dump_incremental_data(trans: &CrateTranslation) {\n+pub(crate) fn dump_incremental_data(codegen_results: &CodegenResults) {\n     println!(\"[incremental] Re-using {} out of {} modules\",\n-              trans.modules.iter().filter(|m| m.pre_existing).count(),\n-              trans.modules.len());\n+              codegen_results.modules.iter().filter(|m| m.pre_existing).count(),\n+              codegen_results.modules.len());\n }\n \n enum WorkItem {\n-    Optimize(ModuleTranslation),\n-    LTO(lto::LtoModuleTranslation),\n+    Optimize(ModuleCodegen),\n+    LTO(lto::LtoModuleCodegen),\n }\n \n impl WorkItem {\n@@ -1233,7 +1233,7 @@ impl WorkItem {\n \n enum WorkItemResult {\n     Compiled(CompiledModule),\n-    NeedsLTO(ModuleTranslation),\n+    NeedsLTO(ModuleCodegen),\n }\n \n fn execute_work_item(cgcx: &CodegenContext,\n@@ -1243,8 +1243,8 @@ fn execute_work_item(cgcx: &CodegenContext,\n {\n     let diag_handler = cgcx.create_diag_handler();\n     let config = cgcx.config(work_item.kind());\n-    let mtrans = match work_item {\n-        WorkItem::Optimize(mtrans) => mtrans,\n+    let module = match work_item {\n+        WorkItem::Optimize(module) => module,\n         WorkItem::LTO(mut lto) => {\n             unsafe {\n                 let module = lto.optimize(cgcx, timeline)?;\n@@ -1253,18 +1253,18 @@ fn execute_work_item(cgcx: &CodegenContext,\n             }\n         }\n     };\n-    let module_name = mtrans.name.clone();\n+    let module_name = module.name.clone();\n \n-    let pre_existing = match mtrans.source {\n-        ModuleSource::Translated(_) => None,\n+    let pre_existing = match module.source {\n+        ModuleSource::Codegened(_) => None,\n         ModuleSource::Preexisting(ref wp) => Some(wp.clone()),\n     };\n \n     if let Some(wp) = pre_existing {\n         let incr_comp_session_dir = cgcx.incr_comp_session_dir\n                                         .as_ref()\n                                         .unwrap();\n-        let name = &mtrans.name;\n+        let name = &module.name;\n         let mut object = None;\n         let mut bytecode = None;\n         let mut bytecode_compressed = None;\n@@ -1290,7 +1290,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n             let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n                                                &saved_file);\n             debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n-                   mtrans.name,\n+                   module.name,\n                    source_file,\n                    obj_out.display());\n             match link_or_copy(&source_file, &obj_out) {\n@@ -1308,7 +1308,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n         assert_eq!(bytecode_compressed.is_some(), config.emit_bc_compressed);\n \n         Ok(WorkItemResult::Compiled(CompiledModule {\n-            llmod_id: mtrans.llmod_id.clone(),\n+            llmod_id: module.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,\n@@ -1320,15 +1320,15 @@ fn execute_work_item(cgcx: &CodegenContext,\n         debug!(\"llvm-optimizing {:?}\", module_name);\n \n         unsafe {\n-            optimize(cgcx, &diag_handler, &mtrans, config, timeline)?;\n+            optimize(cgcx, &diag_handler, &module, config, timeline)?;\n \n             // After we've done the initial round of optimizations we need to\n             // decide whether to synchronously codegen this module or ship it\n             // back to the coordinator thread for further LTO processing (which\n             // has to wait for all the initial modules to be optimized).\n             //\n             // Here we dispatch based on the `cgcx.lto` and kind of module we're\n-            // translating...\n+            // codegenning...\n             let needs_lto = match cgcx.lto {\n                 Lto::No => false,\n \n@@ -1353,24 +1353,24 @@ fn execute_work_item(cgcx: &CodegenContext,\n                 // Additionally here's where we also factor in the current LLVM\n                 // version. If it doesn't support ThinLTO we skip this.\n                 Lto::ThinLocal => {\n-                    mtrans.kind != ModuleKind::Allocator &&\n+                    module.kind != ModuleKind::Allocator &&\n                         llvm::LLVMRustThinLTOAvailable()\n                 }\n             };\n \n             // Metadata modules never participate in LTO regardless of the lto\n             // settings.\n-            let needs_lto = needs_lto && mtrans.kind != ModuleKind::Metadata;\n+            let needs_lto = needs_lto && module.kind != ModuleKind::Metadata;\n \n             // Don't run LTO passes when cross-lang LTO is enabled. The linker\n             // will do that for us in this case.\n             let needs_lto = needs_lto &&\n                 !cgcx.opts.debugging_opts.cross_lang_lto.embed_bitcode();\n \n             if needs_lto {\n-                Ok(WorkItemResult::NeedsLTO(mtrans))\n+                Ok(WorkItemResult::NeedsLTO(module))\n             } else {\n-                let module = codegen(cgcx, &diag_handler, mtrans, config, timeline)?;\n+                let module = codegen(cgcx, &diag_handler, module, config, timeline)?;\n                 Ok(WorkItemResult::Compiled(module))\n             }\n         }\n@@ -1380,19 +1380,19 @@ fn execute_work_item(cgcx: &CodegenContext,\n enum Message {\n     Token(io::Result<Acquired>),\n     NeedsLTO {\n-        result: ModuleTranslation,\n+        result: ModuleCodegen,\n         worker_id: usize,\n     },\n     Done {\n         result: Result<CompiledModule, ()>,\n         worker_id: usize,\n     },\n-    TranslationDone {\n+    CodegenDone {\n         llvm_work_item: WorkItem,\n         cost: u64,\n     },\n-    TranslationComplete,\n-    TranslateItem,\n+    CodegenComplete,\n+    CodegenItem,\n }\n \n struct Diagnostic {\n@@ -1404,14 +1404,14 @@ struct Diagnostic {\n #[derive(PartialEq, Clone, Copy, Debug)]\n enum MainThreadWorkerState {\n     Idle,\n-    Translating,\n+    Codegenning,\n     LLVMing,\n }\n \n fn start_executing_work(tcx: TyCtxt,\n                         crate_info: &CrateInfo,\n                         shared_emitter: SharedEmitter,\n-                        trans_worker_send: Sender<Message>,\n+                        codegen_worker_send: Sender<Message>,\n                         coordinator_receive: Receiver<Box<Any + Send>>,\n                         total_cgus: usize,\n                         jobserver: Client,\n@@ -1520,7 +1520,7 @@ fn start_executing_work(tcx: TyCtxt,\n     // - Error reporting only can happen on the main thread because that's the\n     //   only place where we have access to the compiler `Session`.\n     // - LLVM work can be done on any thread.\n-    // - Translation can only happen on the main thread.\n+    // - Codegen can only happen on the main thread.\n     // - Each thread doing substantial work most be in possession of a `Token`\n     //   from the `Jobserver`.\n     // - The compiler process always holds one `Token`. Any additional `Tokens`\n@@ -1536,7 +1536,7 @@ fn start_executing_work(tcx: TyCtxt,\n     // any error messages it has received. It might even abort compilation if\n     // has received a fatal error. In this case we rely on all other threads\n     // being torn down automatically with the main thread.\n-    // Since the main thread will often be busy doing translation work, error\n+    // Since the main thread will often be busy doing codegen work, error\n     // reporting will be somewhat delayed, since the message queue can only be\n     // checked in between to work packages.\n     //\n@@ -1552,10 +1552,10 @@ fn start_executing_work(tcx: TyCtxt,\n     // thread about what work to do when, and it will spawn off LLVM worker\n     // threads as open LLVM WorkItems become available.\n     //\n-    // The job of the main thread is to translate CGUs into LLVM work package\n+    // The job of the main thread is to codegen CGUs into LLVM work package\n     // (since the main thread is the only thread that can do this). The main\n     // thread will block until it receives a message from the coordinator, upon\n-    // which it will translate one CGU, send it to the coordinator and block\n+    // which it will codegen one CGU, send it to the coordinator and block\n     // again. This way the coordinator can control what the main thread is\n     // doing.\n     //\n@@ -1573,7 +1573,7 @@ fn start_executing_work(tcx: TyCtxt,\n     // if possible. These two goals are at odds with each other: If memory\n     // consumption were not an issue, we could just let the main thread produce\n     // LLVM WorkItems at full speed, assuring maximal utilization of\n-    // Tokens/LLVM worker threads. However, since translation usual is faster\n+    // Tokens/LLVM worker threads. However, since codegen usual is faster\n     // than LLVM processing, the queue of LLVM WorkItems would fill up and each\n     // WorkItem potentially holds on to a substantial amount of memory.\n     //\n@@ -1637,7 +1637,7 @@ fn start_executing_work(tcx: TyCtxt,\n     // The final job the coordinator thread is responsible for is managing LTO\n     // and how that works. When LTO is requested what we'll to is collect all\n     // optimized LLVM modules into a local vector on the coordinator. Once all\n-    // modules have been translated and optimized we hand this to the `lto`\n+    // modules have been codegened and optimized we hand this to the `lto`\n     // module for further optimization. The `lto` module will return back a list\n     // of more modules to work on, which the coordinator will continue to spawn\n     // work for.\n@@ -1663,15 +1663,15 @@ fn start_executing_work(tcx: TyCtxt,\n         };\n \n         // This is where we collect codegen units that have gone all the way\n-        // through translation and LLVM.\n+        // through codegen and LLVM.\n         let mut compiled_modules = vec![];\n         let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n         let mut needs_lto = Vec::new();\n         let mut started_lto = false;\n \n-        // This flag tracks whether all items have gone through translations\n-        let mut translation_done = false;\n+        // This flag tracks whether all items have gone through codegens\n+        let mut codegen_done = false;\n \n         // This is the queue of LLVM work items that still need processing.\n         let mut work_items = Vec::<(WorkItem, u64)>::new();\n@@ -1687,23 +1687,23 @@ fn start_executing_work(tcx: TyCtxt,\n \n         // Run the message loop while there's still anything that needs message\n         // processing:\n-        while !translation_done ||\n+        while !codegen_done ||\n               work_items.len() > 0 ||\n               running > 0 ||\n               needs_lto.len() > 0 ||\n               main_thread_worker_state != MainThreadWorkerState::Idle {\n \n-            // While there are still CGUs to be translated, the coordinator has\n+            // While there are still CGUs to be codegened, the coordinator has\n             // to decide how to utilize the compiler processes implicit Token:\n-            // For translating more CGU or for running them through LLVM.\n-            if !translation_done {\n+            // For codegenning more CGU or for running them through LLVM.\n+            if !codegen_done {\n                 if main_thread_worker_state == MainThreadWorkerState::Idle {\n                     if !queue_full_enough(work_items.len(), running, max_workers) {\n-                        // The queue is not full enough, translate more items:\n-                        if let Err(_) = trans_worker_send.send(Message::TranslateItem) {\n-                            panic!(\"Could not send Message::TranslateItem to main thread\")\n+                        // The queue is not full enough, codegen more items:\n+                        if let Err(_) = codegen_worker_send.send(Message::CodegenItem) {\n+                            panic!(\"Could not send Message::CodegenItem to main thread\")\n                         }\n-                        main_thread_worker_state = MainThreadWorkerState::Translating;\n+                        main_thread_worker_state = MainThreadWorkerState::Codegenning;\n                     } else {\n                         // The queue is full enough to not let the worker\n                         // threads starve. Use the implicit Token to do some\n@@ -1721,7 +1721,7 @@ fn start_executing_work(tcx: TyCtxt,\n                     }\n                 }\n             } else {\n-                // If we've finished everything related to normal translation\n+                // If we've finished everything related to normal codegen\n                 // then it must be the case that we've got some LTO work to do.\n                 // Perform the serial work here of figuring out what we're\n                 // going to LTO and then push a bunch of work items onto our\n@@ -1742,7 +1742,7 @@ fn start_executing_work(tcx: TyCtxt,\n                     }\n                 }\n \n-                // In this branch, we know that everything has been translated,\n+                // In this branch, we know that everything has been codegened,\n                 // so it's just a matter of determining whether the implicit\n                 // Token is free to use for LLVM work.\n                 match main_thread_worker_state {\n@@ -1768,9 +1768,9 @@ fn start_executing_work(tcx: TyCtxt,\n                             main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                         }\n                     }\n-                    MainThreadWorkerState::Translating => {\n-                        bug!(\"trans worker should not be translating after \\\n-                              translation was already completed\")\n+                    MainThreadWorkerState::Codegenning => {\n+                        bug!(\"codegen worker should not be codegenning after \\\n+                              codegen was already completed\")\n                     }\n                     MainThreadWorkerState::LLVMing => {\n                         // Already making good use of that token\n@@ -1812,7 +1812,7 @@ fn start_executing_work(tcx: TyCtxt,\n                                 // If the main thread token is used for LLVM work\n                                 // at the moment, we turn that thread into a regular\n                                 // LLVM worker thread, so the main thread is free\n-                                // to react to translation demand.\n+                                // to react to codegen demand.\n                                 main_thread_worker_state = MainThreadWorkerState::Idle;\n                                 running += 1;\n                             }\n@@ -1826,7 +1826,7 @@ fn start_executing_work(tcx: TyCtxt,\n                     }\n                 }\n \n-                Message::TranslationDone { llvm_work_item, cost } => {\n+                Message::CodegenDone { llvm_work_item, cost } => {\n                     // We keep the queue sorted by estimated processing cost,\n                     // so that more expensive items are processed earlier. This\n                     // is good for throughput as it gives the main thread more\n@@ -1844,14 +1844,14 @@ fn start_executing_work(tcx: TyCtxt,\n \n                     helper.request_token();\n                     assert_eq!(main_thread_worker_state,\n-                               MainThreadWorkerState::Translating);\n+                               MainThreadWorkerState::Codegenning);\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n \n-                Message::TranslationComplete => {\n-                    translation_done = true;\n+                Message::CodegenComplete => {\n+                    codegen_done = true;\n                     assert_eq!(main_thread_worker_state,\n-                               MainThreadWorkerState::Translating);\n+                               MainThreadWorkerState::Codegenning);\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n \n@@ -1902,8 +1902,8 @@ fn start_executing_work(tcx: TyCtxt,\n                     // Exit the coordinator thread\n                     return Err(())\n                 }\n-                Message::TranslateItem => {\n-                    bug!(\"the coordinator should not receive translation requests\")\n+                Message::CodegenItem => {\n+                    bug!(\"the coordinator should not receive codegen requests\")\n                 }\n             }\n         }\n@@ -1934,7 +1934,7 @@ fn start_executing_work(tcx: TyCtxt,\n     });\n \n     // A heuristic that determines if we have enough LLVM WorkItems in the\n-    // queue so that the main thread can do LLVM work instead of translation\n+    // queue so that the main thread can do LLVM work instead of codegen\n     fn queue_full_enough(items_in_queue: usize,\n                          workers_running: usize,\n                          max_workers: usize) -> bool {\n@@ -1955,10 +1955,10 @@ fn start_executing_work(tcx: TyCtxt,\n     }\n }\n \n-pub const TRANS_WORKER_ID: usize = ::std::usize::MAX;\n-pub const TRANS_WORKER_TIMELINE: time_graph::TimelineId =\n-    time_graph::TimelineId(TRANS_WORKER_ID);\n-pub const TRANS_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n+pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n+    time_graph::TimelineId(CODEGEN_WORKER_ID);\n+pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n     time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n     time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n@@ -2231,7 +2231,7 @@ impl SharedEmitterMain {\n     }\n }\n \n-pub struct OngoingCrateTranslation {\n+pub struct OngoingCodegen {\n     crate_name: Symbol,\n     link: LinkMeta,\n     metadata: EncodedMetadata,\n@@ -2240,17 +2240,17 @@ pub struct OngoingCrateTranslation {\n     crate_info: CrateInfo,\n     time_graph: Option<TimeGraph>,\n     coordinator_send: Sender<Box<Any + Send>>,\n-    trans_worker_receive: Receiver<Message>,\n+    codegen_worker_receive: Receiver<Message>,\n     shared_emitter_main: SharedEmitterMain,\n     future: thread::JoinHandle<Result<CompiledModules, ()>>,\n     output_filenames: Arc<OutputFilenames>,\n }\n \n-impl OngoingCrateTranslation {\n+impl OngoingCodegen {\n     pub(crate) fn join(\n         self,\n         sess: &Session\n-    ) -> (CrateTranslation, FxHashMap<WorkProductId, WorkProduct>) {\n+    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n         self.shared_emitter_main.check(sess, true);\n         let compiled_modules = match self.future.join() {\n             Ok(Ok(compiled_modules)) => compiled_modules,\n@@ -2259,7 +2259,7 @@ impl OngoingCrateTranslation {\n                 panic!(\"expected abort due to worker thread errors\")\n             },\n             Err(_) => {\n-                sess.fatal(\"Error during translation/LLVM phase.\");\n+                sess.fatal(\"Error during codegen/LLVM phase.\");\n             }\n         };\n \n@@ -2282,7 +2282,7 @@ impl OngoingCrateTranslation {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n         }\n \n-        let trans = CrateTranslation {\n+        (CodegenResults {\n             crate_name: self.crate_name,\n             link: self.link,\n             metadata: self.metadata,\n@@ -2293,35 +2293,33 @@ impl OngoingCrateTranslation {\n             modules: compiled_modules.modules,\n             allocator_module: compiled_modules.allocator_module,\n             metadata_module: compiled_modules.metadata_module,\n-        };\n-\n-        (trans, work_products)\n+        }, work_products)\n     }\n \n-    pub(crate) fn submit_pre_translated_module_to_llvm(&self,\n+    pub(crate) fn submit_pre_codegened_module_to_llvm(&self,\n                                                        tcx: TyCtxt,\n-                                                       mtrans: ModuleTranslation) {\n-        self.wait_for_signal_to_translate_item();\n+                                                       module: ModuleCodegen) {\n+        self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n \n         // These are generally cheap and won't through off scheduling.\n         let cost = 0;\n-        submit_translated_module_to_llvm(tcx, mtrans, cost);\n+        submit_codegened_module_to_llvm(tcx, module, cost);\n     }\n \n-    pub fn translation_finished(&self, tcx: TyCtxt) {\n-        self.wait_for_signal_to_translate_item();\n+    pub fn codegen_finished(&self, tcx: TyCtxt) {\n+        self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n-        drop(self.coordinator_send.send(Box::new(Message::TranslationComplete)));\n+        drop(self.coordinator_send.send(Box::new(Message::CodegenComplete)));\n     }\n \n     pub fn check_for_errors(&self, sess: &Session) {\n         self.shared_emitter_main.check(sess, false);\n     }\n \n-    pub fn wait_for_signal_to_translate_item(&self) {\n-        match self.trans_worker_receive.recv() {\n-            Ok(Message::TranslateItem) => {\n+    pub fn wait_for_signal_to_codegen_item(&self) {\n+        match self.codegen_worker_receive.recv() {\n+            Ok(Message::CodegenItem) => {\n                 // Nothing to do\n             }\n             Ok(_) => panic!(\"unexpected message\"),\n@@ -2333,11 +2331,11 @@ impl OngoingCrateTranslation {\n     }\n }\n \n-pub(crate) fn submit_translated_module_to_llvm(tcx: TyCtxt,\n-                                               mtrans: ModuleTranslation,\n+pub(crate) fn submit_codegened_module_to_llvm(tcx: TyCtxt,\n+                                               module: ModuleCodegen,\n                                                cost: u64) {\n-    let llvm_work_item = WorkItem::Optimize(mtrans);\n-    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::TranslationDone {\n+    let llvm_work_item = WorkItem::Optimize(module);\n+    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone {\n         llvm_work_item,\n         cost,\n     })));", "previous_filename": "src/librustc_trans/back/write.rs"}, {"sha": "d04cb72d52d6ae4a38ab0b6530d7061e95e6ad2c", "filename": "src/librustc_codegen_llvm/base.rs", "status": "renamed", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Translate the completed AST to the LLVM IR.\n+//! Codegen the completed AST to the LLVM IR.\n //!\n-//! Some functions here, such as trans_block and trans_expr, return a value --\n-//! the result of the translation to LLVM -- while others, such as trans_fn\n-//! and trans_item, are called only for the side effect of adding a\n+//! Some functions here, such as codegen_block and codegen_expr, return a value --\n+//! the result of the codegen to LLVM -- while others, such as codegen_fn\n+//! and mono_item, are called only for the side effect of adding a\n //! particular definition to the LLVM IR output we're producing.\n //!\n-//! Hopefully useful general knowledge about trans:\n+//! Hopefully useful general knowledge about codegen:\n //!\n //!   * There's no way to find out the Ty type of a ValueRef.  Doing so\n //!     would be \"trying to get the eggs out of an omelette\" (credit:\n@@ -25,12 +25,12 @@\n \n use super::ModuleLlvm;\n use super::ModuleSource;\n-use super::ModuleTranslation;\n+use super::ModuleCodegen;\n use super::ModuleKind;\n \n use abi;\n use back::link;\n-use back::write::{self, OngoingCrateTranslation, create_target_machine};\n+use back::write::{self, OngoingCodegen, create_target_machine};\n use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n@@ -66,9 +66,9 @@ use meth;\n use mir;\n use monomorphize::Instance;\n use monomorphize::partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n-use rustc_trans_utils::symbol_names_test;\n+use rustc_codegen_utils::symbol_names_test;\n use time_graph;\n-use trans_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n+use mono_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n@@ -93,7 +93,7 @@ use syntax::ast;\n \n use mir::operand::OperandValue;\n \n-pub use rustc_trans_utils::check_for_rustc_errors_attr;\n+pub use rustc_codegen_utils::check_for_rustc_errors_attr;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n     cx: &'a CodegenCx<'a, 'tcx>,\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n \n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n-        if self.cx.sess().trans_stats() {\n+        if self.cx.sess().codegen_stats() {\n             let mut stats = self.cx.stats.borrow_mut();\n             let iend = stats.n_llvm_insns;\n             stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n@@ -458,8 +458,8 @@ pub fn call_memset<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn trans_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = if cx.sess().trans_stats() {\n+pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let _s = if cx.sess().codegen_stats() {\n         let mut instance_name = String::new();\n         DefPathBasedNames::new(cx.tcx, true, true)\n             .push_def_path(instance.def_id(), &mut instance_name);\n@@ -471,7 +471,7 @@ pub fn trans_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tc\n     // this is an info! to allow collecting monomorphization statistics\n     // and to allow finding the last function before LLVM aborts from\n     // release builds.\n-    info!(\"trans_instance({})\", instance);\n+    info!(\"codegen_instance({})\", instance);\n \n     let fn_ty = instance.ty(cx.tcx);\n     let sig = common::ty_fn_sig(cx, fn_ty);\n@@ -506,7 +506,7 @@ pub fn trans_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tc\n     }\n \n     let mir = cx.tcx.instance_mir(instance.def);\n-    mir::trans_mir(cx, lldecl, &mir, instance, sig);\n+    mir::codegen_mir(cx, lldecl, &mir, instance, sig);\n }\n \n pub fn set_link_section(cx: &CodegenCx,\n@@ -712,9 +712,9 @@ pub fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     }\n }\n \n-pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              rx: mpsc::Receiver<Box<Any + Send>>)\n-                             -> OngoingCrateTranslation {\n+                             -> OngoingCodegen {\n \n     check_for_rustc_errors_attr(tcx);\n \n@@ -734,55 +734,55 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let link_meta = link::build_link_meta(crate_hash);\n \n-    // Translate the metadata.\n+    // Codegen the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess, \"write metadata\", || {\n             write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n-    let metadata_module = ModuleTranslation {\n+    let metadata_module = ModuleCodegen {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         llmod_id: llmod_id.to_string(),\n-        source: ModuleSource::Translated(ModuleLlvm {\n+        source: ModuleSource::Codegened(ModuleLlvm {\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n             tm: create_target_machine(tcx.sess, false),\n         }),\n         kind: ModuleKind::Metadata,\n     };\n \n-    let time_graph = if tcx.sess.opts.debugging_opts.trans_time_graph {\n+    let time_graph = if tcx.sess.opts.debugging_opts.codegen_time_graph {\n         Some(time_graph::TimeGraph::new())\n     } else {\n         None\n     };\n \n-    // Skip crate items and just output metadata in -Z no-trans mode.\n-    if tcx.sess.opts.debugging_opts.no_trans ||\n-       !tcx.sess.opts.output_types.should_trans() {\n-        let ongoing_translation = write::start_async_translation(\n+    // Skip crate items and just output metadata in -Z no-codegen mode.\n+    if tcx.sess.opts.debugging_opts.no_codegen ||\n+       !tcx.sess.opts.output_types.should_codegen() {\n+        let ongoing_codegen = write::start_async_codegen(\n             tcx,\n             time_graph.clone(),\n             link_meta,\n             metadata,\n             rx,\n             1);\n \n-        ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n-        ongoing_translation.translation_finished(tcx);\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n+        ongoing_codegen.codegen_finished(tcx);\n \n         assert_and_save_dep_graph(tcx);\n \n-        ongoing_translation.check_for_errors(tcx.sess);\n+        ongoing_codegen.check_for_errors(tcx.sess);\n \n-        return ongoing_translation;\n+        return ongoing_codegen;\n     }\n \n-    // Run the translation item collector and partition the collected items into\n+    // Run the monomorphization collector and partition the collected items into\n     // codegen units.\n     let codegen_units =\n-        tcx.collect_and_partition_translation_items(LOCAL_CRATE).1;\n+        tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n     let codegen_units = (*codegen_units).clone();\n \n     // Force all codegen_unit queries so they are already either red or green\n@@ -796,15 +796,15 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let ongoing_translation = write::start_async_translation(\n+    let ongoing_codegen = write::start_async_codegen(\n         tcx,\n         time_graph.clone(),\n         link_meta,\n         metadata,\n         rx,\n         codegen_units.len());\n \n-    // Translate an allocator shim, if any\n+    // Codegen an allocator shim, if any\n     let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         unsafe {\n             let llmod_id = \"allocator\";\n@@ -816,13 +816,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tm: create_target_machine(tcx.sess, false),\n             };\n             time(tcx.sess, \"write allocator module\", || {\n-                allocator::trans(tcx, &modules, kind)\n+                allocator::codegen(tcx, &modules, kind)\n             });\n \n-            Some(ModuleTranslation {\n+            Some(ModuleCodegen {\n                 name: link::ALLOCATOR_MODULE_NAME.to_string(),\n                 llmod_id: llmod_id.to_string(),\n-                source: ModuleSource::Translated(modules),\n+                source: ModuleSource::Codegened(modules),\n                 kind: ModuleKind::Allocator,\n             })\n         }\n@@ -831,10 +831,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     if let Some(allocator_module) = allocator_module {\n-        ongoing_translation.submit_pre_translated_module_to_llvm(tcx, allocator_module);\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n     }\n \n-    ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n+    ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n \n     // We sort the codegen units by size. This way we can schedule work for LLVM\n     // a bit more efficiently.\n@@ -844,12 +844,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         codegen_units\n     };\n \n-    let mut total_trans_time = Duration::new(0, 0);\n+    let mut total_codegen_time = Duration::new(0, 0);\n     let mut all_stats = Stats::default();\n \n     for cgu in codegen_units.into_iter() {\n-        ongoing_translation.wait_for_signal_to_translate_item();\n-        ongoing_translation.check_for_errors(tcx.sess);\n+        ongoing_codegen.wait_for_signal_to_codegen_item();\n+        ongoing_codegen.check_for_errors(tcx.sess);\n \n         // First, if incremental compilation is enabled, we try to re-use the\n         // codegen unit from the cache.\n@@ -878,14 +878,14 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n                     let llmod_id = format!(\"{}.rs\", cgu.name());\n \n-                    let module = ModuleTranslation {\n+                    let module = ModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: ModuleSource::Preexisting(buf),\n                         kind: ModuleKind::Regular,\n                         llmod_id,\n                     };\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n-                    write::submit_translated_module_to_llvm(tcx, module, 0);\n+                    write::submit_codegened_module_to_llvm(tcx, module, 0);\n                     // Continue to next cgu, this one is done.\n                     continue\n                 }\n@@ -896,32 +896,32 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         let _timing_guard = time_graph.as_ref().map(|time_graph| {\n-            time_graph.start(write::TRANS_WORKER_TIMELINE,\n-                             write::TRANS_WORK_PACKAGE_KIND,\n+            time_graph.start(write::CODEGEN_WORKER_TIMELINE,\n+                             write::CODEGEN_WORK_PACKAGE_KIND,\n                              &format!(\"codegen {}\", cgu.name()))\n         });\n         let start_time = Instant::now();\n         all_stats.extend(tcx.compile_codegen_unit(*cgu.name()));\n-        total_trans_time += start_time.elapsed();\n-        ongoing_translation.check_for_errors(tcx.sess);\n+        total_codegen_time += start_time.elapsed();\n+        ongoing_codegen.check_for_errors(tcx.sess);\n     }\n \n-    ongoing_translation.translation_finished(tcx);\n+    ongoing_codegen.codegen_finished(tcx);\n \n-    // Since the main thread is sometimes blocked during trans, we keep track\n+    // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n     print_time_passes_entry(tcx.sess.time_passes(),\n-                            \"translate to LLVM IR\",\n-                            total_trans_time);\n+                            \"codegen to LLVM IR\",\n+                            total_codegen_time);\n \n     if tcx.sess.opts.incremental.is_some() {\n         ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n     }\n \n     symbol_names_test::report_symbol_names(tcx);\n \n-    if tcx.sess.trans_stats() {\n-        println!(\"--- trans stats ---\");\n+    if tcx.sess.codegen_stats() {\n+        println!(\"--- codegen stats ---\");\n         println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n         println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n         println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n@@ -942,10 +942,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    ongoing_translation.check_for_errors(tcx.sess);\n+    ongoing_codegen.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx);\n-    ongoing_translation\n+    ongoing_codegen\n }\n \n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -958,14 +958,14 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n          || rustc_incremental::save_dep_graph(tcx));\n }\n \n-fn collect_and_partition_translation_items<'a, 'tcx>(\n+fn collect_and_partition_mono_items<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cnum: CrateNum,\n ) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let collection_mode = match tcx.sess.opts.debugging_opts.print_trans_items {\n+    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n         Some(ref s) => {\n             let mode_string = s.to_lowercase();\n             let mode_string = mode_string.trim();\n@@ -992,7 +992,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     };\n \n     let (items, inlining_map) =\n-        time(tcx.sess, \"translation item collection\", || {\n+        time(tcx.sess, \"monomorphization collection\", || {\n             collector::collect_crate_mono_items(tcx, collection_mode)\n     });\n \n@@ -1016,20 +1016,20 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n             .collect::<Vec<_>>()\n     });\n \n-    let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n-        match *trans_item {\n+    let mono_items: DefIdSet = items.iter().filter_map(|mono_item| {\n+        match *mono_item {\n             MonoItem::Fn(ref instance) => Some(instance.def_id()),\n             MonoItem::Static(def_id) => Some(def_id),\n             _ => None,\n         }\n     }).collect();\n \n-    if tcx.sess.opts.debugging_opts.print_trans_items.is_some() {\n+    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n         let mut item_to_cgus = FxHashMap();\n \n         for cgu in &codegen_units {\n-            for (&trans_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(trans_item)\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item)\n                             .or_insert(Vec::new())\n                             .push((cgu.name().clone(), linkage));\n             }\n@@ -1073,11 +1073,11 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n         item_keys.sort();\n \n         for item in item_keys {\n-            println!(\"TRANS_ITEM {}\", item);\n+            println!(\"MONO_ITEM {}\", item);\n         }\n     }\n \n-    (Arc::new(translation_items), Arc::new(codegen_units))\n+    (Arc::new(mono_items), Arc::new(codegen_units))\n }\n \n impl CrateInfo {\n@@ -1174,34 +1174,34 @@ impl CrateInfo {\n     }\n }\n \n-fn is_translated_item(tcx: TyCtxt, id: DefId) -> bool {\n-    let (all_trans_items, _) =\n-        tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n-    all_trans_items.contains(&id)\n+fn is_codegened_item(tcx: TyCtxt, id: DefId) -> bool {\n+    let (all_mono_items, _) =\n+        tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+    all_mono_items.contains(&id)\n }\n \n fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   cgu: InternedString) -> Stats {\n     let cgu = tcx.codegen_unit(cgu);\n \n     let start_time = Instant::now();\n-    let (stats, module) = module_translation(tcx, cgu);\n-    let time_to_translate = start_time.elapsed();\n+    let (stats, module) = module_codegen(tcx, cgu);\n+    let time_to_codegen = start_time.elapsed();\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n-    // the time we needed for translating it.\n-    let cost = time_to_translate.as_secs() * 1_000_000_000 +\n-               time_to_translate.subsec_nanos() as u64;\n+    // the time we needed for codegenning it.\n+    let cost = time_to_codegen.as_secs() * 1_000_000_000 +\n+               time_to_codegen.subsec_nanos() as u64;\n \n-    write::submit_translated_module_to_llvm(tcx,\n+    write::submit_codegened_module_to_llvm(tcx,\n                                             module,\n                                             cost);\n     return stats;\n \n-    fn module_translation<'a, 'tcx>(\n+    fn module_codegen<'a, 'tcx>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu: Arc<CodegenUnit<'tcx>>)\n-        -> (Stats, ModuleTranslation)\n+        -> (Stats, ModuleCodegen)\n     {\n         let cgu_name = cgu.name().to_string();\n \n@@ -1218,18 +1218,18 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                tcx.crate_disambiguator(LOCAL_CRATE)\n                                    .to_fingerprint().to_hex());\n \n-        // Instantiate translation items without filling out definitions yet...\n+        // Instantiate monomorphizations without filling out definitions yet...\n         let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n         let module = {\n-            let trans_items = cx.codegen_unit\n+            let mono_items = cx.codegen_unit\n                                  .items_in_deterministic_order(cx.tcx);\n-            for &(trans_item, (linkage, visibility)) in &trans_items {\n-                trans_item.predefine(&cx, linkage, visibility);\n+            for &(mono_item, (linkage, visibility)) in &mono_items {\n+                mono_item.predefine(&cx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n-            for &(trans_item, _) in &trans_items {\n-                trans_item.define(&cx);\n+            for &(mono_item, _) in &mono_items {\n+                mono_item.define(&cx);\n             }\n \n             // If this codegen unit contains the main function, also create the\n@@ -1273,9 +1273,9 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tm: create_target_machine(cx.sess(), false),\n             };\n \n-            ModuleTranslation {\n+            ModuleCodegen {\n                 name: cgu_name,\n-                source: ModuleSource::Translated(llvm_module),\n+                source: ModuleSource::Codegened(llvm_module),\n                 kind: ModuleKind::Regular,\n                 llmod_id,\n             }\n@@ -1286,13 +1286,13 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_translation_items =\n-        collect_and_partition_translation_items;\n+    providers.collect_and_partition_mono_items =\n+        collect_and_partition_mono_items;\n \n-    providers.is_translated_item = is_translated_item;\n+    providers.is_codegened_item = is_codegened_item;\n \n     providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n+        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n         all.iter()\n             .find(|cgu| *cgu.name() == name)\n             .cloned()\n@@ -1369,9 +1369,9 @@ pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n mod temp_stable_hash_impls {\n     use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n                                                HashStable};\n-    use ModuleTranslation;\n+    use ModuleCodegen;\n \n-    impl<HCX> HashStable<HCX> for ModuleTranslation {\n+    impl<HCX> HashStable<HCX> for ModuleCodegen {\n         fn hash_stable<W: StableHasherResult>(&self,\n                                               _: &mut HCX,\n                                               _: &mut StableHasher<W>) {", "previous_filename": "src/librustc_trans/base.rs"}, {"sha": "97accbb4b8fe631b6ef2a07643bff9e1962bedb4", "filename": "src/librustc_codegen_llvm/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuild.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/build.rs"}, {"sha": "7b4998e85881efa9a03ad31810021ce8b0a0d18d", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     fn count_insn(&self, category: &str) {\n-        if self.cx.sess().trans_stats() {\n+        if self.cx.sess().codegen_stats() {\n             self.cx.stats.borrow_mut().n_llvm_insns += 1;\n         }\n         if self.cx.sess().count_llvm_insns() {", "previous_filename": "src/librustc_trans/builder.rs"}, {"sha": "a3dbc450ce72f4de6e6038bd062844dfb3da370d", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Handles translation of callees as well as other call-related\n+//! Handles codegen of callees as well as other call-related\n //! things.  Callees are a superset of normal rust values and sometimes\n //! have different representations.  In particular, top-level fn items\n //! and methods are represented as just a fn ptr and not a full\n@@ -28,7 +28,7 @@ use rustc::ty::layout::LayoutOf;\n use rustc::ty::subst::Substs;\n use rustc_target::spec::PanicStrategy;\n \n-/// Translates a reference to a fn/method item, monomorphizing and\n+/// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n ///\n /// # Parameters\n@@ -116,9 +116,9 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         // just declared.\n         //\n         // This is sort of subtle. Inside our codegen unit we started off\n-        // compilation by predefining all our own `TransItem` instances. That\n-        // is, everything we're translating ourselves is already defined. That\n-        // means that anything we're actually translating in this codegen unit\n+        // compilation by predefining all our own `MonoItem` instances. That\n+        // is, everything we're codegenning ourselves is already defined. That\n+        // means that anything we're actually codegenning in this codegen unit\n         // will have hit the above branch in `get_declared_value`. As a result,\n         // we're guaranteed here that we're declaring a symbol that won't get\n         // defined, or in other words we're referencing a value from another\n@@ -181,7 +181,7 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 }\n             } else {\n                 // This is a non-generic function\n-                if cx.tcx.is_translated_item(instance_def_id) {\n+                if cx.tcx.is_codegened_item(instance_def_id) {\n                     // This is a function that is instantiated in the local crate\n \n                     if instance_def_id.is_local() {", "previous_filename": "src/librustc_trans/callee.rs"}, {"sha": "10ca8e43ce6556908e3dd2108b9110d6791df469", "filename": "src/librustc_codegen_llvm/common.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_camel_case_types, non_snake_case)]\n \n-//! Code that is useful in various trans modules.\n+//! Code that is useful in various codegen modules.\n \n use llvm;\n use llvm::{ValueRef, ContextRef, TypeKind};\n@@ -446,4 +446,3 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n     }\n }\n-", "previous_filename": "src/librustc_trans/common.rs"}, {"sha": "afa81465ea2d1b78c362c09a55eb4a81203c74e3", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -128,7 +128,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n-                    span_bug!(span, \"trans: Conflicting symbol names for static?\");\n+                    span_bug!(span, \"Conflicting symbol names for static?\");\n                 }\n \n                 let g = declare::define_global(cx, &sym[..], llty).unwrap();\n@@ -145,7 +145,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let g = if let Some(linkage) = cx.tcx.trans_fn_attrs(def_id).linkage {\n+                let g = if let Some(linkage) = cx.tcx.codegen_fn_attrs(def_id).linkage {\n                     // If this is a static with a linkage specified, then we need to handle\n                     // it a little specially. The typesystem prevents things like &T and\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n@@ -221,8 +221,8 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             // However, in some scenarios we defer emission of statics to downstream\n             // crates, so there are cases where a static with an upstream DefId\n             // is actually present in the current crate. We can find out via the\n-            // is_translated_item query.\n-            if !cx.tcx.is_translated_item(def_id) {\n+            // is_codegened_item query.\n+            if !cx.tcx.is_codegened_item(def_id) {\n                 unsafe {\n                     llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n                 }\n@@ -243,14 +243,14 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     g\n }\n \n-pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+pub fn codegen_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               def_id: DefId,\n                               is_mutable: bool,\n                               attrs: &[ast::Attribute]) {\n     unsafe {\n         let g = get_static(cx, def_id);\n \n-        let v = match ::mir::trans_static_initializer(cx, def_id) {\n+        let v = match ::mir::codegen_static_initializer(cx, def_id) {\n             Ok(v) => v,\n             // Error has already been reported\n             Err(_) => return,\n@@ -290,7 +290,7 @@ pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n-            // with the new global later. (See base::trans_crate.)\n+            // with the new global later. (See base::codegen_backend.)\n             cx.statics_to_rauw.borrow_mut().push((g, new_g));\n             new_g\n         };", "previous_filename": "src/librustc_trans/consts.rs"}, {"sha": "9b1de3d44ea865463a0076a5fc01302214243a1f", "filename": "src/librustc_codegen_llvm/context.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -69,7 +69,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// Val is a ValueRef holding a *[T].\n     ///\n     /// Needed because LLVM loses pointer->pointee association\n-    /// when we ptrcast, and we have to ptrcast during translation\n+    /// when we ptrcast, and we have to ptrcast during codegen\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n     pub const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n@@ -81,7 +81,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n     /// List of globals for static variables which need to be passed to the\n-    /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n+    /// LLVM function ReplaceAllUsesWith (RAUW) when codegen is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n     /// to constants.)\n     pub statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n@@ -351,7 +351,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         // The exception handling personality function.\n         //\n         // If our compilation unit has the `eh_personality` lang item somewhere\n-        // within it, then we just need to translate that. Otherwise, we're\n+        // within it, then we just need to codegen that. Otherwise, we're\n         // building an rlib which will depend on some upstream implementation of\n         // this function, so we just codegen a generic reference to it. We don't\n         // specify any of the types for the function, we just make it a symbol", "previous_filename": "src/librustc_trans/context.rs"}, {"sha": "bddb3d909402e323905f3f944cd872df672f7f48", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/debuginfo/create_scope_map.rs"}, {"sha": "ce0476b07eb433d20342bca5809b9ec3561ce1a4", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -131,9 +131,9 @@\n //! when generating prologue instructions we have to make sure that we don't\n //! emit source location information until the 'real' function body begins. For\n //! this reason, source location emission is disabled by default for any new\n-//! function being translated and is only activated after a call to the third\n+//! function being codegened and is only activated after a call to the third\n //! function from the list above, `start_emitting_source_locations()`. This\n-//! function should be called right before regularly starting to translate the\n+//! function should be called right before regularly starting to codegen the\n //! top-level block of the given function.\n //!\n //! There is one exception to the above rule: `llvm.dbg.declare` instruction", "previous_filename": "src/librustc_trans/debuginfo/doc.rs"}, {"sha": "0b4858c7ab051085350c48fa95fa01d0e05fd5c3", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/debuginfo/gdb.rs"}, {"sha": "ee60711c11d444ca2afac1fe67d2903471b8a038", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -23,7 +23,7 @@ use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n-use rustc::hir::TransFnAttrFlags;\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n@@ -1645,13 +1645,13 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n     }\n \n     let tcx = cx.tcx;\n-    let attrs = tcx.trans_fn_attrs(def_id);\n+    let attrs = tcx.codegen_fn_attrs(def_id);\n \n-    if attrs.flags.contains(TransFnAttrFlags::NO_DEBUG) {\n+    if attrs.flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n         return;\n     }\n \n-    let no_mangle = attrs.flags.contains(TransFnAttrFlags::NO_MANGLE);\n+    let no_mangle = attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE);\n     // We may want to remove the namespace scope if we're in an extern block, see:\n     // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952\n     let var_scope = get_namespace_for_item(cx, def_id);", "previous_filename": "src/librustc_trans/debuginfo/metadata.rs"}, {"sha": "294d8cbbd932ddc579af765447493e456e261fd6", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -23,7 +23,7 @@ use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};\n-use rustc::hir::TransFnAttrFlags;\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::{Substs, UnpackedKind};\n \n@@ -212,7 +212,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n \n     if let InstanceDef::Item(def_id) = instance.def {\n-        if cx.tcx.trans_fn_attrs(def_id).flags.contains(TransFnAttrFlags::NO_DEBUG) {\n+        if cx.tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n     }", "previous_filename": "src/librustc_trans/debuginfo/mod.rs"}, {"sha": "51c45de9dc22a7633f1e8a6bdcaa35d5638acd28", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/debuginfo/namespace.rs"}, {"sha": "eb37e7f931cc3023228377f9208a549bf0ad5fa2", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -50,9 +50,9 @@ pub fn set_source_location(\n /// Enables emitting source locations for the given functions.\n ///\n /// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to translate a new function. This functions\n+/// they are disabled when beginning to codegen a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is translated.\n+/// first real statement/expression of the function is codegened.\n pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext) {\n     match *dbg_context {\n         FunctionDebugContext::RegularContext(ref data) => {", "previous_filename": "src/librustc_trans/debuginfo/source_loc.rs"}, {"sha": "05a74db3a6ca9842470d51991fc589dc5998c88a", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/debuginfo/type_names.rs"}, {"sha": "9d37f99cb2a591f016538eb0b6bca3d91454f952", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -31,7 +31,7 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n     // externally visible or by being inlined into something externally\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n-    // available in the translation pass.\n+    // available in the codegen pass.\n     !cx.tcx.is_reachable_non_generic(def_id)\n }\n ", "previous_filename": "src/librustc_trans/debuginfo/utils.rs"}, {"sha": "fdc84f914f50256dcc9fc03d558c694791b5b759", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n //!\n //! Prefer using functions and methods from this module rather than calling LLVM\n //! functions directly. These functions do some additional work to ensure we do\n-//! the right thing given the preconceptions of trans.\n+//! the right thing given the preconceptions of codegen.\n //!\n //! Some useful guidelines:\n //!", "previous_filename": "src/librustc_trans/declare.rs"}, {"sha": "57cc33d09bbea94e1f36f7fa1c82fe58ae831ce5", "filename": "src/librustc_codegen_llvm/diagnostics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/diagnostics.rs"}, {"sha": "c7275d094018567f7221192ea2cec1c20ecaf7a7", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/glue.rs"}, {"sha": "ba04cc7fad5e96806056ec17a4f402f31207f4c0", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -84,8 +84,8 @@ fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n \n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n-/// add them to librustc_trans/trans/context.rs\n-pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n+/// add them to librustc_codegen_llvm/context.rs\n+pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType<'tcx, Ty<'tcx>>,\n                                       args: &[OperandRef<'tcx>],\n@@ -386,7 +386,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         },\n \n         \"discriminant_value\" => {\n-            args[0].deref(bx.cx).trans_get_discr(bx, ret_ty)\n+            args[0].deref(bx.cx).codegen_get_discr(bx, ret_ty)\n         }\n \n         \"align_offset\" => {\n@@ -743,9 +743,9 @@ fn try_intrinsic<'a, 'tcx>(\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         bx.store(C_null(Type::i8p(&bx.cx)), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n-        trans_msvc_try(bx, cx, func, data, local_ptr, dest);\n+        codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bx, cx, func, data, local_ptr, dest);\n+        codegen_gnu_try(bx, cx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -756,7 +756,7 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn trans_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n+fn codegen_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                             cx: &CodegenCx,\n                             func: ValueRef,\n                             data: ValueRef,\n@@ -857,14 +857,14 @@ fn trans_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n // of exceptions (e.g. the normal semantics of LLVM's landingpad and invoke\n // instructions).\n //\n-// This translation is a little surprising because we always call a shim\n+// This codegen is a little surprising because we always call a shim\n // function instead of inlining the call to `invoke` manually here. This is done\n // because in LLVM we're only allowed to have one personality per function\n // definition. The call to the `try` intrinsic is being inlined into the\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn trans_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n+fn codegen_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                            cx: &CodegenCx,\n                            func: ValueRef,\n                            data: ValueRef,\n@@ -873,7 +873,7 @@ fn trans_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n \n-        // Translates the shims described above:\n+        // Codegens the shims described above:\n         //\n         //   bx:\n         //      invoke %func(%args...) normal %normal unwind %catch\n@@ -922,13 +922,13 @@ fn trans_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     bx.store(ret, dest, i32_align);\n }\n \n-// Helper function to give a Block to a closure to translate a shim function.\n+// Helper function to give a Block to a closure to codegen a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n-                    trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n+                    codegen: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n     let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder::bind(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n@@ -939,7 +939,7 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     )));\n     let llfn = declare::define_internal_fn(cx, name, rust_fn_ty);\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n-    trans(bx);\n+    codegen(bx);\n     llfn\n }\n \n@@ -948,7 +948,7 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n //\n // This function is only generated once and is then cached.\n fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n+                             codegen: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n@@ -965,7 +965,7 @@ fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         Abi::Rust\n     )));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n     return rust_try\n }\n@@ -1069,7 +1069,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n             Ok(n) => n,\n             Err(_) => span_bug!(span,\n-                                \"bad `simd_shuffle` instruction only caught in trans?\")\n+                                \"bad `simd_shuffle` instruction only caught in codegen?\")\n         };\n \n         require_simd!(ret_ty, \"return\");", "previous_filename": "src/librustc_trans/intrinsic.rs"}, {"sha": "bd053da4bd3034ddade089159bc57511c6d8d794", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "renamed", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -49,7 +49,7 @@ extern crate rustc_demangle;\n extern crate rustc_incremental;\n extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n-extern crate rustc_trans_utils;\n+extern crate rustc_codegen_utils;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -79,12 +79,12 @@ use rustc::session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc_mir::monomorphize;\n-use rustc_trans_utils::trans_crate::TransCrate;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n mod diagnostics;\n \n mod back {\n-    pub use rustc_trans_utils::symbol_names;\n+    pub use rustc_codegen_utils::symbol_names;\n     mod archive;\n     pub mod bytecode;\n     mod command;\n@@ -116,23 +116,23 @@ mod metadata;\n mod meth;\n mod mir;\n mod time_graph;\n-mod trans_item;\n+mod mono_item;\n mod type_;\n mod type_of;\n mod value;\n \n-pub struct LlvmTransCrate(());\n+pub struct LlvmCodegenBackend(());\n \n-impl !Send for LlvmTransCrate {} // Llvm is on a per-thread basis\n-impl !Sync for LlvmTransCrate {}\n+impl !Send for LlvmCodegenBackend {} // Llvm is on a per-thread basis\n+impl !Sync for LlvmCodegenBackend {}\n \n-impl LlvmTransCrate {\n-    pub fn new() -> Box<TransCrate> {\n-        box LlvmTransCrate(())\n+impl LlvmCodegenBackend {\n+    pub fn new() -> Box<CodegenBackend> {\n+        box LlvmCodegenBackend(())\n     }\n }\n \n-impl TransCrate for LlvmTransCrate {\n+impl CodegenBackend for LlvmCodegenBackend {\n     fn init(&self, sess: &Session) {\n         llvm_util::init(sess); // Make sure llvm is inited\n     }\n@@ -197,27 +197,28 @@ impl TransCrate for LlvmTransCrate {\n         attributes::provide_extern(providers);\n     }\n \n-    fn trans_crate<'a, 'tcx>(\n+    fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx: mpsc::Receiver<Box<Any + Send>>\n     ) -> Box<Any> {\n-        box base::trans_crate(tcx, rx)\n+        box base::codegen_crate(tcx, rx)\n     }\n \n-    fn join_trans_and_link(\n+    fn join_codegen_and_link(\n         &self,\n-        trans: Box<Any>,\n+        ongoing_codegen: Box<Any>,\n         sess: &Session,\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete>{\n         use rustc::util::common::time;\n-        let (trans, work_products) = trans.downcast::<::back::write::OngoingCrateTranslation>()\n-            .expect(\"Expected LlvmTransCrate's OngoingCrateTranslation, found Box<Any>\")\n-            .join(sess);\n+        let (ongoing_codegen, work_products) =\n+            ongoing_codegen.downcast::<::back::write::OngoingCodegen>()\n+                .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n+                .join(sess);\n         if sess.opts.debugging_opts.incremental_info {\n-            back::write::dump_incremental_data(&trans);\n+            back::write::dump_incremental_data(&ongoing_codegen);\n         }\n \n         time(sess,\n@@ -234,24 +235,25 @@ impl TransCrate for LlvmTransCrate {\n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n         time(sess, \"linking\", || {\n-            back::link::link_binary(sess, &trans, outputs, &trans.crate_name.as_str());\n+            back::link::link_binary(sess, &ongoing_codegen,\n+                                    outputs, &ongoing_codegen.crate_name.as_str());\n         });\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+        rustc_incremental::finalize_session_directory(sess, ongoing_codegen.link.crate_hash);\n \n         Ok(())\n     }\n }\n \n-/// This is the entrypoint for a hot plugged rustc_trans\n+/// This is the entrypoint for a hot plugged rustc_codegen_llvm\n #[no_mangle]\n-pub fn __rustc_codegen_backend() -> Box<TransCrate> {\n-    LlvmTransCrate::new()\n+pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n+    LlvmCodegenBackend::new()\n }\n \n-struct ModuleTranslation {\n+struct ModuleCodegen {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be\n     /// unique amongst **all** crates.  Therefore, it should contain\n@@ -270,10 +272,10 @@ enum ModuleKind {\n     Allocator,\n }\n \n-impl ModuleTranslation {\n+impl ModuleCodegen {\n     fn llvm(&self) -> Option<&ModuleLlvm> {\n         match self.source {\n-            ModuleSource::Translated(ref llvm) => Some(llvm),\n+            ModuleSource::Codegened(ref llvm) => Some(llvm),\n             ModuleSource::Preexisting(_) => None,\n         }\n     }\n@@ -285,7 +287,7 @@ impl ModuleTranslation {\n                                 outputs: &OutputFilenames) -> CompiledModule {\n         let pre_existing = match self.source {\n             ModuleSource::Preexisting(_) => true,\n-            ModuleSource::Translated(_) => false,\n+            ModuleSource::Codegened(_) => false,\n         };\n         let object = if emit_obj {\n             Some(outputs.temp_path(OutputType::Object, Some(&self.name)))\n@@ -332,7 +334,7 @@ enum ModuleSource {\n     Preexisting(WorkProduct),\n \n     /// Rebuild from this LLVM module.\n-    Translated(ModuleLlvm),\n+    Codegened(ModuleLlvm),\n }\n \n #[derive(Debug)]\n@@ -355,7 +357,7 @@ impl Drop for ModuleLlvm {\n     }\n }\n \n-struct CrateTranslation {\n+struct CodegenResults {\n     crate_name: Symbol,\n     modules: Vec<CompiledModule>,\n     allocator_module: Option<CompiledModule>,\n@@ -387,4 +389,4 @@ struct CrateInfo {\n     missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n }\n \n-__build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n+__build_diagnostic_array! { librustc_codegen_llvm, DIAGNOSTICS }", "previous_filename": "src/librustc_trans/lib.rs"}, {"sha": "357b639e78890593c7c3767bf4d5721f51eb5fa2", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -249,7 +249,7 @@ pub(crate) fn print(req: PrintRequest, sess: &Session) {\n         match req {\n             PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),\n             PrintRequest::TargetFeatures => llvm::LLVMRustPrintTargetFeatures(tm),\n-            _ => bug!(\"rustc_trans can't handle print request: {:?}\", req),\n+            _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n         }\n     }\n }", "previous_filename": "src/librustc_trans/llvm_util.rs"}, {"sha": "144baa65c1bfa32a6b19b29391799d5811de5f5d", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/metadata.rs"}, {"sha": "21bbdf31dcb5200d8fa04068ad3e94fa83fec9f1", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/meth.rs"}, {"sha": "9e5298eb736a33e18c7d97710f1739fa3b925ebc", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/mir/analyze.rs"}, {"sha": "556baeba39e0ad2b79c3e81b43876bd466da3c6a", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "renamed", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -34,25 +34,25 @@ use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n+    pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n         let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];\n \n-        debug!(\"trans_block({:?}={:?})\", bb, data);\n+        debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n         for statement in &data.statements {\n-            bx = self.trans_statement(bx, statement);\n+            bx = self.codegen_statement(bx, statement);\n         }\n \n-        self.trans_terminator(bx, bb, data.terminator());\n+        self.codegen_terminator(bx, bb, data.terminator());\n     }\n \n-    fn trans_terminator(&mut self,\n+    fn codegen_terminator(&mut self,\n                         mut bx: Builder<'a, 'tcx>,\n                         bb: mir::BasicBlock,\n                         terminator: &mir::Terminator<'tcx>)\n     {\n-        debug!(\"trans_terminator: {:?}\", terminator);\n+        debug!(\"codegen_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n         let tcx = bx.tcx();\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                let discr = self.trans_operand(&bx, discr);\n+                let discr = self.codegen_operand(&bx, discr);\n                 if switch_ty == bx.tcx().types.bool {\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     }\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n-                        let op = self.trans_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n+                        let op = self.codegen_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n                             bx.load(llval, align)\n                         } else {\n@@ -233,10 +233,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         let op = match self.locals[mir::RETURN_PLACE] {\n                             LocalRef::Operand(Some(op)) => op,\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n-                            LocalRef::Place(tr_place) => {\n+                            LocalRef::Place(cg_place) => {\n                                 OperandRef {\n-                                    val: Ref(tr_place.llval, tr_place.align),\n-                                    layout: tr_place.layout\n+                                    val: Ref(cg_place.llval, cg_place.align),\n+                                    layout: cg_place.layout\n                                 }\n                             }\n                         };\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     return\n                 }\n \n-                let place = self.trans_place(&bx, location);\n+                let place = self.codegen_place(&bx, location);\n                 let mut args: &[_] = &[place.llval, place.llextra];\n                 args = &args[..1 + place.has_extra() as usize];\n                 let (drop_fn, fn_ty) = match ty.sty {\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let cond = self.trans_operand(&bx, cond).immediate();\n+                let cond = self.codegen_operand(&bx, cond).immediate();\n                 let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     }\n                 }\n \n-                // Don't translate the panic block if success if known.\n+                // Don't codegen the panic block if success if known.\n                 if const_cond == Some(expected) {\n                     funclet_br(self, bx, target);\n                     return;\n@@ -353,8 +353,8 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args) = match *msg {\n                     EvalErrorKind::BoundsCheck { ref len, ref index } => {\n-                        let len = self.trans_operand(&mut bx, len).immediate();\n-                        let index = self.trans_operand(&mut bx, index).immediate();\n+                        let len = self.codegen_operand(&mut bx, len).immediate();\n+                        let index = self.codegen_operand(&mut bx, index).immediate();\n \n                         let file_line_col = C_struct(bx.cx, &[filename, line, col], false);\n                         let file_line_col = consts::addr_of(bx.cx,\n@@ -386,17 +386,17 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 let fn_ty = FnType::of_instance(bx.cx, &instance);\n                 let llfn = callee::get_fn(bx.cx, instance);\n \n-                // Translate the actual panic invoke/call.\n+                // Codegen the actual panic invoke/call.\n                 do_call(self, bx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n-                bug!(\"undesugared DropAndReplace in trans: {:?}\", terminator);\n+                bug!(\"undesugared DropAndReplace in codegen: {:?}\", terminator);\n             }\n \n             mir::TerminatorKind::Call { ref func, ref args, ref destination, cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-                let callee = self.trans_operand(&bx, func);\n+                let callee = self.codegen_operand(&bx, func);\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n@@ -419,7 +419,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 );\n                 let abi = sig.abi;\n \n-                // Handle intrinsics old trans wants Expr's for, ourselves.\n+                // Handle intrinsics old codegen wants Expr's for, ourselves.\n                 let intrinsic = match def {\n                     Some(ty::InstanceDef::Intrinsic(def_id))\n                         => Some(bx.tcx().item_name(def_id).as_str()),\n@@ -429,7 +429,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n-                    self.trans_transmute(&bx, &args[0], dest);\n+                    self.codegen_transmute(&bx, &args[0], dest);\n                     funclet_br(self, bx, target);\n                     return;\n                 }\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 };\n \n                 if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n-                    use intrinsic::trans_intrinsic_call;\n+                    use intrinsic::codegen_intrinsic_call;\n \n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n@@ -504,12 +504,12 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             }\n                         }\n \n-                        self.trans_operand(&bx, arg)\n+                        self.codegen_operand(&bx, arg)\n                     }).collect();\n \n \n                     let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n-                    trans_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n+                    codegen_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -534,7 +534,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 };\n \n                 for (i, arg) in first_args.iter().enumerate() {\n-                    let mut op = self.trans_operand(&bx, arg);\n+                    let mut op = self.codegen_operand(&bx, arg);\n                     if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n                         if let Pair(data_ptr, meta) = op.val {\n                             llfn = Some(meth::VirtualIndex::from_index(idx)\n@@ -556,10 +556,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         _ => {}\n                     }\n \n-                    self.trans_argument(&bx, op, &mut llargs, &fn_ty.args[i]);\n+                    self.codegen_argument(&bx, op, &mut llargs, &fn_ty.args[i]);\n                 }\n                 if let Some(tup) = untuple {\n-                    self.trans_arguments_untupled(&bx, tup, &mut llargs,\n+                    self.codegen_arguments_untupled(&bx, tup, &mut llargs,\n                         &fn_ty.args[first_args.len()..])\n                 }\n \n@@ -574,13 +574,13 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         cleanup);\n             }\n             mir::TerminatorKind::GeneratorDrop |\n-            mir::TerminatorKind::Yield { .. } => bug!(\"generator ops in trans\"),\n+            mir::TerminatorKind::Yield { .. } => bug!(\"generator ops in codegen\"),\n             mir::TerminatorKind::FalseEdges { .. } |\n-            mir::TerminatorKind::FalseUnwind { .. } => bug!(\"borrowck false edges in trans\"),\n+            mir::TerminatorKind::FalseUnwind { .. } => bug!(\"borrowck false edges in codegen\"),\n         }\n     }\n \n-    fn trans_argument(&mut self,\n+    fn codegen_argument(&mut self,\n                       bx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     llargs.push(b);\n                     return;\n                 }\n-                _ => bug!(\"trans_argument: {:?} invalid for pair arugment\", op)\n+                _ => bug!(\"codegen_argument: {:?} invalid for pair arugment\", op)\n             }\n         }\n \n@@ -659,25 +659,25 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         llargs.push(llval);\n     }\n \n-    fn trans_arguments_untupled(&mut self,\n+    fn codegen_arguments_untupled(&mut self,\n                                 bx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 args: &[ArgType<'tcx, Ty<'tcx>>]) {\n-        let tuple = self.trans_operand(bx, operand);\n+        let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n         if let Ref(llval, align) = tuple.val {\n             let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n-                self.trans_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n+                self.codegen_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n             }\n         } else {\n             // If the tuple is immediate, the elements are as well.\n             for i in 0..tuple.layout.fields.count() {\n                 let op = tuple.extract_field(bx, i);\n-                self.trans_argument(bx, op, llargs, &args[i]);\n+                self.codegen_argument(bx, op, llargs, &args[i]);\n             }\n         }\n     }\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            self.trans_place(bx, dest)\n+            self.codegen_place(bx, dest)\n         };\n         if fn_ret.is_indirect() {\n             if dest.align.abi() < dest.layout.align.abi() {\n@@ -811,18 +811,18 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn trans_transmute(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn codegen_transmute(&mut self, bx: &Builder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>,\n                        dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n-                LocalRef::Place(place) => self.trans_transmute_into(bx, src, place),\n+                LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.cx.layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n                     place.storage_live(bx);\n-                    self.trans_transmute_into(bx, src, place);\n+                    self.codegen_transmute_into(bx, src, place);\n                     let op = place.load(bx);\n                     place.storage_dead(bx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n@@ -833,15 +833,15 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            let dst = self.trans_place(bx, dst);\n-            self.trans_transmute_into(bx, src, dst);\n+            let dst = self.codegen_place(bx, dst);\n+            self.codegen_transmute_into(bx, src, dst);\n         }\n     }\n \n-    fn trans_transmute_into(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n                             dst: PlaceRef<'tcx>) {\n-        let src = self.trans_operand(bx, src);\n+        let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);", "previous_filename": "src/librustc_trans/mir/block.rs"}, {"sha": "c2638d2d410704b0a7662386b6c24402ea4e3180", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -158,7 +158,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     C_struct(cx, &llvals, true)\n }\n \n-pub fn trans_static_initializer<'a, 'tcx>(\n+pub fn codegen_static_initializer<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>", "previous_filename": "src/librustc_trans/mir/constant.rs"}, {"sha": "47b153203110c2be78dc8b79b87567b74a7d11ac", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -33,15 +33,15 @@ use std::iter;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n-pub use self::constant::trans_static_initializer;\n+pub use self::constant::codegen_static_initializer;\n \n use self::analyze::CleanupKind;\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n-/// Master context for translating MIR.\n+/// Master context for codegenning from MIR.\n pub struct FunctionCx<'a, 'tcx:'a> {\n     instance: Instance<'tcx>,\n \n@@ -197,7 +197,7 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'a, 'tcx: 'a>(\n+pub fn codegen_mir<'a, 'tcx: 'a>(\n     cx: &'a CodegenCx<'a, 'tcx>,\n     llfn: ValueRef,\n     mir: &'a Mir<'tcx>,\n@@ -321,18 +321,18 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n-    // Translate the body of each block using reverse postorder\n+    // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        fx.trans_block(bb);\n+        fx.codegen_block(bb);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n     for bb in mir.basic_blocks().indices() {\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n-            debug!(\"trans_mir: block {:?} was not visited\", bb);\n+            debug!(\"codegen_mir: block {:?} was not visited\", bb);\n             unsafe {\n                 llvm::LLVMDeleteBasicBlock(fx.blocks[bb]);\n             }", "previous_filename": "src/librustc_trans/mir/mod.rs"}, {"sha": "62ef58f825504765243bb0d8c59789e628efabb2", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -315,12 +315,12 @@ impl<'a, 'tcx> OperandValue {\n }\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    fn maybe_trans_consume_direct(&mut self,\n+    fn maybe_codegen_consume_direct(&mut self,\n                                   bx: &Builder<'a, 'tcx>,\n                                   place: &mir::Place<'tcx>)\n                                    -> Option<OperandRef<'tcx>>\n     {\n-        debug!(\"maybe_trans_consume_direct(place={:?})\", place);\n+        debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n         // watch out for locals that do not have an\n         // alloca; they are handled somewhat differently\n@@ -340,7 +340,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n         // Moves out of scalar and scalar pair fields are trivial.\n         if let &mir::Place::Projection(ref proj) = place {\n-            if let Some(o) = self.maybe_trans_consume_direct(bx, &proj.base) {\n+            if let Some(o) = self.maybe_codegen_consume_direct(bx, &proj.base) {\n                 match proj.elem {\n                     mir::ProjectionElem::Field(ref f, _) => {\n                         return Some(o.extract_field(bx, f.index()));\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     mir::ProjectionElem::ConstantIndex { .. } => {\n                         // ZSTs don't require any actual memory access.\n                         // FIXME(eddyb) deduplicate this with the identical\n-                        // checks in `trans_consume` and `extract_field`.\n+                        // checks in `codegen_consume` and `extract_field`.\n                         let elem = o.layout.field(bx.cx, 0);\n                         if elem.is_zst() {\n                             return Some(OperandRef::new_zst(bx.cx, elem));\n@@ -363,12 +363,12 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         None\n     }\n \n-    pub fn trans_consume(&mut self,\n+    pub fn codegen_consume(&mut self,\n                          bx: &Builder<'a, 'tcx>,\n                          place: &mir::Place<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n-        debug!(\"trans_consume(place={:?})\", place);\n+        debug!(\"codegen_consume(place={:?})\", place);\n \n         let ty = self.monomorphized_place_ty(place);\n         let layout = bx.cx.layout_of(ty);\n@@ -378,26 +378,26 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             return OperandRef::new_zst(bx.cx, layout);\n         }\n \n-        if let Some(o) = self.maybe_trans_consume_direct(bx, place) {\n+        if let Some(o) = self.maybe_codegen_consume_direct(bx, place) {\n             return o;\n         }\n \n         // for most places, to consume them we just load them\n         // out from their home\n-        self.trans_place(bx, place).load(bx)\n+        self.codegen_place(bx, place).load(bx)\n     }\n \n-    pub fn trans_operand(&mut self,\n+    pub fn codegen_operand(&mut self,\n                          bx: &Builder<'a, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n-        debug!(\"trans_operand(operand={:?})\", operand);\n+        debug!(\"codegen_operand(operand={:?})\", operand);\n \n         match *operand {\n             mir::Operand::Copy(ref place) |\n             mir::Operand::Move(ref place) => {\n-                self.trans_consume(bx, place)\n+                self.codegen_consume(bx, place)\n             }\n \n             mir::Operand::Constant(ref constant) => {", "previous_filename": "src/librustc_trans/mir/operand.rs"}, {"sha": "bda8c758750515ab8e66213b94ff820707852b73", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "renamed", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn trans_get_discr(self, bx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+    pub fn codegen_get_discr(self, bx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         if self.layout.abi == layout::Abi::Uninhabited {\n             return C_undef(cast_to);\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n-    pub fn trans_set_discr(&self, bx: &Builder<'a, 'tcx>, variant_index: usize) {\n+    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'tcx>, variant_index: usize) {\n         if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n@@ -399,11 +399,11 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n }\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    pub fn trans_place(&mut self,\n+    pub fn codegen_place(&mut self,\n                         bx: &Builder<'a, 'tcx>,\n                         place: &mir::Place<'tcx>)\n                         -> PlaceRef<'tcx> {\n-        debug!(\"trans_place(place={:?})\", place);\n+        debug!(\"codegen_place(place={:?})\", place);\n \n         let cx = bx.cx;\n         let tcx = cx.tcx;\n@@ -430,46 +430,46 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                self.trans_consume(bx, base).deref(bx.cx)\n+                self.codegen_consume(bx, base).deref(bx.cx)\n             }\n             mir::Place::Projection(ref projection) => {\n-                let tr_base = self.trans_place(bx, &projection.base);\n+                let cg_base = self.codegen_place(bx, &projection.base);\n \n                 match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        tr_base.project_field(bx, field.index())\n+                        cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Copy(mir::Place::Local(index));\n-                        let index = self.trans_operand(bx, index);\n+                        let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n-                        tr_base.project_index(bx, llindex)\n+                        cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_usize(bx.cx, offset as u64);\n-                        tr_base.project_index(bx, lloffset)\n+                        cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_usize(bx.cx, offset as u64);\n-                        let lllen = tr_base.len(bx.cx);\n+                        let lllen = cg_base.len(bx.cx);\n                         let llindex = bx.sub(lllen, lloffset);\n-                        tr_base.project_index(bx, llindex)\n+                        cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let mut subslice = tr_base.project_index(bx,\n+                        let mut subslice = cg_base.project_index(bx,\n                             C_usize(bx.cx, from as u64));\n-                        let projected_ty = PlaceTy::Ty { ty: tr_base.layout.ty }\n+                        let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem).to_ty(bx.tcx());\n                         subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n-                            assert!(tr_base.has_extra());\n-                            subslice.llextra = bx.sub(tr_base.llextra,\n+                            assert!(cg_base.has_extra());\n+                            subslice.llextra = bx.sub(cg_base.llextra,\n                                 C_usize(bx.cx, (from as u64) + (to as u64)));\n                         }\n \n@@ -481,12 +481,12 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         subslice\n                     }\n                     mir::ProjectionElem::Downcast(_, v) => {\n-                        tr_base.project_downcast(bx, v)\n+                        cg_base.project_downcast(bx, v)\n                     }\n                 }\n             }\n         };\n-        debug!(\"trans_place(place={:?}) => {:?}\", place, result);\n+        debug!(\"codegen_place(place={:?}) => {:?}\", place, result);\n         result\n     }\n \n@@ -496,4 +496,3 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         self.monomorphize(&place_ty.to_ty(tcx))\n     }\n }\n-", "previous_filename": "src/librustc_trans/mir/place.rs"}, {"sha": "d1b949d4f7351ecaca55e0ca14195fa73a742ca2", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "renamed", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -33,21 +33,21 @@ use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    pub fn trans_rvalue(&mut self,\n+    pub fn codegen_rvalue(&mut self,\n                         bx: Builder<'a, 'tcx>,\n                         dest: PlaceRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Builder<'a, 'tcx>\n     {\n-        debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n+        debug!(\"codegen_rvalue(dest.llval={:?}, rvalue={:?})\",\n                Value(dest.llval), rvalue);\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n-               let tr_operand = self.trans_operand(&bx, operand);\n-               // FIXME: consider not copying constants through stack. (fixable by translating\n+               let cg_operand = self.codegen_operand(&bx, operand);\n+               // FIXME: consider not copying constants through stack. (fixable by codegenning\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               tr_operand.val.store(&bx, dest);\n+               cg_operand.val.store(&bx, dest);\n                bx\n            }\n \n@@ -57,16 +57,16 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 if dest.layout.is_llvm_scalar_pair() {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n-                    let (bx, temp) = self.trans_rvalue_operand(bx, rvalue);\n+                    let (bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n                     temp.val.store(&bx, dest);\n                     return bx;\n                 }\n \n                 // Unsize of a nontrivial struct. I would prefer for\n-                // this to be eliminated by MIR translation, but\n+                // this to be eliminated by MIR building, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.trans_operand(&bx, source);\n+                let operand = self.codegen_operand(&bx, source);\n                 match operand.val {\n                     OperandValue::Pair(..) |\n                     OperandValue::Immediate(_) => {\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         // `coerce_unsized_into` use extractvalue to\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n-                        debug!(\"trans_rvalue: creating ugly alloca\");\n+                        debug!(\"codegen_rvalue: creating ugly alloca\");\n                         let scratch = PlaceRef::alloca(&bx, operand.layout, \"__unsize_temp\");\n                         scratch.storage_live(&bx);\n                         operand.val.store(&bx, scratch);\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let tr_elem = self.trans_operand(&bx, elem);\n+                let cg_elem = self.codegen_operand(&bx, elem);\n \n                 // Do not generate the loop for zero-sized elements or empty arrays.\n                 if dest.layout.is_zst() {\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n                 let start = dest.project_index(&bx, C_usize(bx.cx, 0)).llval;\n \n-                if let OperandValue::Immediate(v) = tr_elem.val {\n+                if let OperandValue::Immediate(v) = cg_elem.val {\n                     let align = C_i32(bx.cx, dest.align.abi() as i32);\n                     let size = C_usize(bx.cx, dest.layout.size.bytes());\n \n@@ -133,8 +133,8 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 let keep_going = header_bx.icmp(llvm::IntNE, current, end);\n                 header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n \n-                tr_elem.val.store(&body_bx,\n-                    PlaceRef::new_sized(current, tr_elem.layout, dest.align));\n+                cg_elem.val.store(&body_bx,\n+                    PlaceRef::new_sized(current, cg_elem.layout, dest.align));\n \n                 let next = body_bx.inbounds_gep(current, &[C_usize(bx.cx, 1)]);\n                 body_bx.br(header_bx.llbb());\n@@ -146,7 +146,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n-                        dest.trans_set_discr(&bx, variant_index);\n+                        dest.codegen_set_discr(&bx, variant_index);\n                         if adt_def.is_enum() {\n                             (dest.project_downcast(&bx, variant_index), active_field_index)\n                         } else {\n@@ -156,7 +156,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     _ => (dest, None)\n                 };\n                 for (i, operand) in operands.iter().enumerate() {\n-                    let op = self.trans_operand(&bx, operand);\n+                    let op = self.codegen_operand(&bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n@@ -168,23 +168,23 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue));\n-                let (bx, temp) = self.trans_rvalue_operand(bx, rvalue);\n+                let (bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n                 temp.val.store(&bx, dest);\n                 bx\n             }\n         }\n     }\n \n-    pub fn trans_rvalue_operand(&mut self,\n+    pub fn codegen_rvalue_operand(&mut self,\n                                 bx: Builder<'a, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n                                 -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n-        assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+        assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n-                let operand = self.trans_operand(&bx, source);\n+                let operand = self.codegen_operand(&bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n                 let cast = bx.cx.layout_of(self.monomorphize(&mir_cast_ty));\n \n@@ -242,7 +242,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Ref(..) => {\n-                                bug!(\"by-ref operand {:?} in trans_rvalue_operand\",\n+                                bug!(\"by-ref operand {:?} in codegen_rvalue_operand\",\n                                      operand);\n                             }\n                         }\n@@ -358,16 +358,16 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Ref(_, bk, ref place) => {\n-                let tr_place = self.trans_place(&bx, place);\n+                let cg_place = self.codegen_place(&bx, place);\n \n-                let ty = tr_place.layout.ty;\n+                let ty = cg_place.layout.ty;\n \n                 // Note: places are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n                 let val = if !bx.cx.type_has_metadata(ty) {\n-                    OperandValue::Immediate(tr_place.llval)\n+                    OperandValue::Immediate(cg_place.llval)\n                 } else {\n-                    OperandValue::Pair(tr_place.llval, tr_place.llextra)\n+                    OperandValue::Pair(cg_place.llval, cg_place.llextra)\n                 };\n                 (bx, OperandRef {\n                     val,\n@@ -388,20 +388,20 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.trans_operand(&bx, lhs);\n-                let rhs = self.trans_operand(&bx, rhs);\n+                let lhs = self.codegen_operand(&bx, lhs);\n+                let rhs = self.codegen_operand(&bx, rhs);\n                 let llresult = match (lhs.val, rhs.val) {\n                     (OperandValue::Pair(lhs_addr, lhs_extra),\n                      OperandValue::Pair(rhs_addr, rhs_extra)) => {\n-                        self.trans_fat_ptr_binop(&bx, op,\n+                        self.codegen_fat_ptr_binop(&bx, op,\n                                                  lhs_addr, lhs_extra,\n                                                  rhs_addr, rhs_extra,\n                                                  lhs.layout.ty)\n                     }\n \n                     (OperandValue::Immediate(lhs_val),\n                      OperandValue::Immediate(rhs_val)) => {\n-                        self.trans_scalar_binop(&bx, op, lhs_val, rhs_val, lhs.layout.ty)\n+                        self.codegen_scalar_binop(&bx, op, lhs_val, rhs_val, lhs.layout.ty)\n                     }\n \n                     _ => bug!()\n@@ -414,9 +414,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 (bx, operand)\n             }\n             mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.trans_operand(&bx, lhs);\n-                let rhs = self.trans_operand(&bx, rhs);\n-                let result = self.trans_scalar_checked_binop(&bx, op,\n+                let lhs = self.codegen_operand(&bx, lhs);\n+                let rhs = self.codegen_operand(&bx, rhs);\n+                let result = self.codegen_scalar_checked_binop(&bx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.layout.ty);\n                 let val_ty = op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty);\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.trans_operand(&bx, operand);\n+                let operand = self.codegen_operand(&bx, operand);\n                 let lloperand = operand.immediate();\n                 let is_float = operand.layout.ty.is_fp();\n                 let llval = match op {\n@@ -449,8 +449,8 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n             mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n-                let discr =  self.trans_place(&bx, place)\n-                    .trans_get_discr(&bx, discr_ty);\n+                let discr =  self.codegen_place(&bx, place)\n+                    .codegen_get_discr(&bx, discr_ty);\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n                     layout: self.cx.layout_of(discr_ty)\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 (bx, operand)\n             }\n             mir::Rvalue::Use(ref operand) => {\n-                let operand = self.trans_operand(&bx, operand);\n+                let operand = self.codegen_operand(&bx, operand);\n                 (bx, operand)\n             }\n             mir::Rvalue::Repeat(..) |\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                           place: &mir::Place<'tcx>) -> ValueRef\n     {\n         // ZST are passed as operands and require special handling\n-        // because trans_place() panics if Local is operand.\n+        // because codegen_place() panics if Local is operand.\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n@@ -522,11 +522,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let tr_value = self.trans_place(&bx, place);\n-        return tr_value.len(bx.cx);\n+        let cg_value = self.codegen_place(&bx, place);\n+        return cg_value.len(bx.cx);\n     }\n \n-    pub fn trans_scalar_binop(&mut self,\n+    pub fn codegen_scalar_binop(&mut self,\n                               bx: &Builder<'a, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn trans_fat_ptr_binop(&mut self,\n+    pub fn codegen_fat_ptr_binop(&mut self,\n                                bx: &Builder<'a, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn trans_scalar_checked_binop(&mut self,\n+    pub fn codegen_scalar_checked_binop(&mut self,\n                                       bx: &Builder<'a, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n@@ -650,7 +650,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n         if !bx.cx.check_overflow {\n-            let val = self.trans_scalar_binop(bx, op, lhs, rhs, input_ty);\n+            let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n             return OperandValue::Pair(val, C_bool(bx.cx, false));\n         }\n \n@@ -676,7 +676,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 let outer_bits = bx.and(rhs, invert_mask);\n \n                 let of = bx.icmp(llvm::IntNE, outer_bits, C_null(rhs_llty));\n-                let val = self.trans_scalar_binop(bx, op, lhs, rhs, input_ty);\n+                let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n \n                 (val, of)\n             }", "previous_filename": "src/librustc_trans/mir/rvalue.rs"}, {"sha": "578481df157e8b231b1e863eb696430ff4a1949c", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -17,22 +17,22 @@ use super::FunctionCx;\n use super::LocalRef;\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    pub fn trans_statement(&mut self,\n+    pub fn codegen_statement(&mut self,\n                            bx: Builder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n                            -> Builder<'a, 'tcx> {\n-        debug!(\"trans_statement(statement={:?})\", statement);\n+        debug!(\"codegen_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(ref place, ref rvalue) => {\n                 if let mir::Place::Local(index) = *place {\n                     match self.locals[index] {\n-                        LocalRef::Place(tr_dest) => {\n-                            self.trans_rvalue(bx, tr_dest, rvalue)\n+                        LocalRef::Place(cg_dest) => {\n+                            self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (bx, operand) = self.trans_rvalue_operand(bx, rvalue);\n+                            let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }\n@@ -44,42 +44,42 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             }\n \n                             // If the type is zero-sized, it's already been set here,\n-                            // but we still need to make sure we translate the operand\n-                            self.trans_rvalue_operand(bx, rvalue).0\n+                            // but we still need to make sure we codegen the operand\n+                            self.codegen_rvalue_operand(bx, rvalue).0\n                         }\n                     }\n                 } else {\n-                    let tr_dest = self.trans_place(&bx, place);\n-                    self.trans_rvalue(bx, tr_dest, rvalue)\n+                    let cg_dest = self.codegen_place(&bx, place);\n+                    self.codegen_rvalue(bx, cg_dest, rvalue)\n                 }\n             }\n             mir::StatementKind::SetDiscriminant{ref place, variant_index} => {\n-                self.trans_place(&bx, place)\n-                    .trans_set_discr(&bx, variant_index);\n+                self.codegen_place(&bx, place)\n+                    .codegen_set_discr(&bx, variant_index);\n                 bx\n             }\n             mir::StatementKind::StorageLive(local) => {\n-                if let LocalRef::Place(tr_place) = self.locals[local] {\n-                    tr_place.storage_live(&bx);\n+                if let LocalRef::Place(cg_place) = self.locals[local] {\n+                    cg_place.storage_live(&bx);\n                 }\n                 bx\n             }\n             mir::StatementKind::StorageDead(local) => {\n-                if let LocalRef::Place(tr_place) = self.locals[local] {\n-                    tr_place.storage_dead(&bx);\n+                if let LocalRef::Place(cg_place) = self.locals[local] {\n+                    cg_place.storage_dead(&bx);\n                 }\n                 bx\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n-                    self.trans_place(&bx, output)\n+                    self.codegen_place(&bx, output)\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {\n-                    self.trans_operand(&bx, input).immediate()\n+                    self.codegen_operand(&bx, input).immediate()\n                 }).collect();\n \n-                asm::trans_inline_asm(&bx, asm, outputs, input_vals);\n+                asm::codegen_inline_asm(&bx, asm, outputs, input_vals);\n                 bx\n             }\n             mir::StatementKind::EndRegion(_) |", "previous_filename": "src/librustc_trans/mir/statement.rs"}, {"sha": "6ba3582f0143bf3af42e40c77f3e2791e8adbef2", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -58,18 +58,18 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 };\n                 let attrs = tcx.get_attrs(def_id);\n \n-                consts::trans_static(&cx, def_id, is_mutable, &attrs);\n+                consts::codegen_static(&cx, def_id, is_mutable, &attrs);\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);\n                 if let hir::ItemGlobalAsm(ref ga) = item.node {\n-                    asm::trans_global_asm(cx, ga);\n+                    asm::codegen_global_asm(cx, ga);\n                 } else {\n-                    span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n+                    span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n                 }\n             }\n             MonoItem::Fn(instance) => {\n-                base::trans_instance(&cx, instance);\n+                base::codegen_instance(&cx, instance);\n             }\n         }\n ", "previous_filename": "src/librustc_trans/trans_item.rs"}, {"sha": "a8502682a806b718f93c6e5b7c9943d86cba759a", "filename": "src/librustc_codegen_llvm/time_graph.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftime_graph.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/time_graph.rs"}, {"sha": "a77acc4f1756f016de71784f726a9a9c64412302", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/type_.rs"}, {"sha": "5f186e7514ecc54bcba90b11f008705121f123b8", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -14,7 +14,7 @@ use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::spec::PanicStrategy;\n-use trans_item::DefPathBasedNames;\n+use mono_item::DefPathBasedNames;\n use type_::Type;\n \n use std::fmt::Write;", "previous_filename": "src/librustc_trans/type_of.rs"}, {"sha": "287ad87caacf94e6398c9e6bc8e1ebd9abb063e7", "filename": "src/librustc_codegen_llvm/value.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans/value.rs"}, {"sha": "690fb260390e52b90dcb0be4cd7c8a4c2e137946", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1,10 +1,10 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_trans_utils\"\n+name = \"rustc_codegen_utils\"\n version = \"0.0.0\"\n \n [lib]\n-name = \"rustc_trans_utils\"\n+name = \"rustc_codegen_utils\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n test = false", "previous_filename": "src/librustc_trans_utils/Cargo.toml"}, {"sha": "15aab680289eb87163eb3c24676bc1e0aa1bdd1a", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "renamed", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -50,7 +50,7 @@ use link::{build_link_meta, out_filename};\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n-pub trait TransCrate {\n+pub trait CodegenBackend {\n     fn init(&self, _sess: &Session) {}\n     fn print(&self, _req: PrintRequest, _sess: &Session) {}\n     fn target_features(&self, _sess: &Session) -> Vec<Symbol> { vec![] }\n@@ -61,57 +61,57 @@ pub trait TransCrate {\n     fn metadata_loader(&self) -> Box<MetadataLoader + Sync>;\n     fn provide(&self, _providers: &mut Providers);\n     fn provide_extern(&self, _providers: &mut Providers);\n-    fn trans_crate<'a, 'tcx>(\n+    fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx: mpsc::Receiver<Box<Any + Send>>\n     ) -> Box<Any>;\n \n-    /// This is called on the returned `Box<Any>` from `trans_crate`\n+    /// This is called on the returned `Box<Any>` from `codegen_backend`\n     ///\n     /// # Panics\n     ///\n-    /// Panics when the passed `Box<Any>` was not returned by `trans_crate`.\n-    fn join_trans_and_link(\n+    /// Panics when the passed `Box<Any>` was not returned by `codegen_backend`.\n+    fn join_codegen_and_link(\n         &self,\n-        trans: Box<Any>,\n+        ongoing_codegen: Box<Any>,\n         sess: &Session,\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete>;\n }\n \n-pub struct DummyTransCrate;\n+pub struct DummyCodegenBackend;\n \n-impl TransCrate for DummyTransCrate {\n+impl CodegenBackend for DummyCodegenBackend {\n     fn metadata_loader(&self) -> Box<MetadataLoader + Sync> {\n         box DummyMetadataLoader(())\n     }\n \n     fn provide(&self, _providers: &mut Providers) {\n-        bug!(\"DummyTransCrate::provide\");\n+        bug!(\"DummyCodegenBackend::provide\");\n     }\n \n     fn provide_extern(&self, _providers: &mut Providers) {\n-        bug!(\"DummyTransCrate::provide_extern\");\n+        bug!(\"DummyCodegenBackend::provide_extern\");\n     }\n \n-    fn trans_crate<'a, 'tcx>(\n+    fn codegen_crate<'a, 'tcx>(\n         &self,\n         _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n     ) -> Box<Any> {\n-        bug!(\"DummyTransCrate::trans_crate\");\n+        bug!(\"DummyCodegenBackend::codegen_backend\");\n     }\n \n-    fn join_trans_and_link(\n+    fn join_codegen_and_link(\n         &self,\n-        _trans: Box<Any>,\n+        _ongoing_codegen: Box<Any>,\n         _sess: &Session,\n         _dep_graph: &DepGraph,\n         _outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete> {\n-        bug!(\"DummyTransCrate::join_trans_and_link\");\n+        bug!(\"DummyCodegenBackend::join_codegen_and_link\");\n     }\n }\n \n@@ -167,20 +167,20 @@ impl MetadataLoader for NoLlvmMetadataLoader {\n     }\n }\n \n-pub struct MetadataOnlyTransCrate(());\n-pub struct OngoingCrateTranslation {\n+pub struct MetadataOnlyCodegenBackend(());\n+pub struct OngoingCodegen {\n     metadata: EncodedMetadata,\n     metadata_version: Vec<u8>,\n     crate_name: Symbol,\n }\n \n-impl MetadataOnlyTransCrate {\n-    pub fn new() -> Box<TransCrate> {\n-        box MetadataOnlyTransCrate(())\n+impl MetadataOnlyCodegenBackend {\n+    pub fn new() -> Box<CodegenBackend> {\n+        box MetadataOnlyCodegenBackend(())\n     }\n }\n \n-impl TransCrate for MetadataOnlyTransCrate {\n+impl CodegenBackend for MetadataOnlyCodegenBackend {\n     fn init(&self, sess: &Session) {\n         for cty in sess.opts.crate_types.iter() {\n             match *cty {\n@@ -208,7 +208,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n     }\n     fn provide_extern(&self, _providers: &mut Providers) {}\n \n-    fn trans_crate<'a, 'tcx>(\n+    fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n@@ -228,17 +228,17 @@ impl TransCrate for MetadataOnlyTransCrate {\n         ::rustc::middle::dependency_format::calculate(tcx);\n         let _ = tcx.link_args(LOCAL_CRATE);\n         let _ = tcx.native_libraries(LOCAL_CRATE);\n-        for trans_item in\n+        for mono_item in\n             collector::collect_crate_mono_items(\n                 tcx,\n                 collector::MonoItemCollectionMode::Eager\n             ).0 {\n-            match trans_item {\n+            match mono_item {\n                 MonoItem::Fn(inst) => {\n                     let def_id = inst.def_id();\n                     if def_id.is_local()  {\n                         let _ = inst.def.is_inline(tcx);\n-                        let _ = tcx.trans_fn_attrs(def_id);\n+                        let _ = tcx.codegen_fn_attrs(def_id);\n                     }\n                 }\n                 _ => {}\n@@ -249,36 +249,36 @@ impl TransCrate for MetadataOnlyTransCrate {\n         let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n         let metadata = tcx.encode_metadata(&link_meta);\n \n-        box OngoingCrateTranslation {\n+        box OngoingCodegen {\n             metadata: metadata,\n             metadata_version: tcx.metadata_encoding_version().to_vec(),\n             crate_name: tcx.crate_name(LOCAL_CRATE),\n         }\n     }\n \n-    fn join_trans_and_link(\n+    fn join_codegen_and_link(\n         &self,\n-        trans: Box<Any>,\n+        ongoing_codegen: Box<Any>,\n         sess: &Session,\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete> {\n-        let trans = trans.downcast::<OngoingCrateTranslation>()\n-            .expect(\"Expected MetadataOnlyTransCrate's OngoingCrateTranslation, found Box<Any>\");\n+        let ongoing_codegen = ongoing_codegen.downcast::<OngoingCodegen>()\n+            .expect(\"Expected MetadataOnlyCodegenBackend's OngoingCodegen, found Box<Any>\");\n         for &crate_type in sess.opts.crate_types.iter() {\n             if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n                 continue;\n             }\n             let output_name =\n-                out_filename(sess, crate_type, &outputs, &trans.crate_name.as_str());\n-            let mut compressed = trans.metadata_version.clone();\n+                out_filename(sess, crate_type, &outputs, &ongoing_codegen.crate_name.as_str());\n+            let mut compressed = ongoing_codegen.metadata_version.clone();\n             let metadata = if crate_type == CrateType::CrateTypeDylib {\n                 DeflateEncoder::new(&mut compressed, Compression::fast())\n-                    .write_all(&trans.metadata.raw_data)\n+                    .write_all(&ongoing_codegen.metadata.raw_data)\n                     .unwrap();\n                 &compressed\n             } else {\n-                &trans.metadata.raw_data\n+                &ongoing_codegen.metadata.raw_data\n             };\n             let mut builder = Builder::new(File::create(&output_name).unwrap());\n             let header = Header::new(\"rust.metadata.bin\".to_string(), metadata.len() as u64);", "previous_filename": "src/librustc_trans_utils/trans_crate.rs"}, {"sha": "0c18571f4ffe884e0b6b9ac7a563697756486743", "filename": "src/librustc_codegen_utils/lib.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -42,12 +42,12 @@ pub extern crate rustc as __rustc;\n use rustc::ty::TyCtxt;\n \n pub mod link;\n-pub mod trans_crate;\n+pub mod codegen_backend;\n pub mod symbol_names;\n pub mod symbol_names_test;\n \n /// check for the #[rustc_error] annotation, which forces an\n-/// error in trans. This is used to write compile-fail tests\n+/// error in codegen. This is used to write compile-fail tests\n /// that actually test that compilation succeeds without\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n@@ -60,4 +60,4 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n     }\n }\n \n-__build_diagnostic_array! { librustc_trans_utils, DIAGNOSTICS }\n+__build_diagnostic_array! { librustc_codegen_utils, DIAGNOSTICS }", "previous_filename": "src/librustc_trans_utils/lib.rs"}, {"sha": "aabe931d79c579af326fa6a93ef1263fa72a898f", "filename": "src/librustc_codegen_utils/link.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans_utils/link.rs"}, {"sha": "1a62f39ae3d8b1ac29f3c22bba148d8910349a3e", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -277,7 +277,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n         return tcx.item_name(def_id).to_string();\n     }\n \n-    if let Some(name) = tcx.trans_fn_attrs(def_id).export_name {\n+    if let Some(name) = tcx.codegen_fn_attrs(def_id).export_name {\n         // Use provided name\n         return name.to_string();\n     }", "previous_filename": "src/librustc_trans_utils/symbol_names.rs"}, {"sha": "47bbd67fb5c70840cc5fdf85e8cfca77338df991", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/librustc_trans_utils/symbol_names_test.rs"}, {"sha": "24bf07d793f3d280a40011c991bc31797fd1fdd9", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -31,7 +31,7 @@ rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_traits = { path = \"../librustc_traits\" }\n-rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n+rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "ed28b05c12551a5e28174eb7e7d99f7080f87b22", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -32,7 +32,7 @@ use rustc_resolve::{MakeGlobMap, Resolver, ResolverArenas};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n use rustc_traits;\n-use rustc_trans_utils::trans_crate::TransCrate;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n@@ -110,7 +110,7 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n }\n \n pub fn compile_input(\n-    trans: Box<TransCrate>,\n+    codegen_backend: Box<CodegenBackend>,\n     sess: &Session,\n     cstore: &CStore,\n     input_path: &Option<PathBuf>,\n@@ -143,7 +143,7 @@ pub fn compile_input(\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, ongoing_trans, dep_graph) = {\n+    let (outputs, ongoing_codegen, dep_graph) = {\n         let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -162,7 +162,7 @@ pub fn compile_input(\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n         let crate_name =\n-            ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n+            ::rustc_codegen_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         install_panic_hook();\n \n         let ExpansionResult {\n@@ -274,7 +274,7 @@ pub fn compile_input(\n         };\n \n         phase_3_run_analysis_passes(\n-            &*trans,\n+            &*codegen_backend,\n             control,\n             sess,\n             cstore,\n@@ -310,14 +310,14 @@ pub fn compile_input(\n                 result?;\n \n                 if log_enabled!(::log::Level::Info) {\n-                    println!(\"Pre-trans\");\n+                    println!(\"Pre-codegen\");\n                     tcx.print_debug_stats();\n                 }\n \n-                let ongoing_trans = phase_4_translate_to_llvm(&*trans, tcx, rx);\n+                let ongoing_codegen = phase_4_codegen(&*codegen_backend, tcx, rx);\n \n                 if log_enabled!(::log::Level::Info) {\n-                    println!(\"Post-trans\");\n+                    println!(\"Post-codegen\");\n                     tcx.print_debug_stats();\n                 }\n \n@@ -328,7 +328,7 @@ pub fn compile_input(\n                     }\n                 }\n \n-                Ok((outputs.clone(), ongoing_trans, tcx.dep_graph.clone()))\n+                Ok((outputs.clone(), ongoing_codegen, tcx.dep_graph.clone()))\n             },\n         )??\n     };\n@@ -337,7 +337,7 @@ pub fn compile_input(\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    trans.join_trans_and_link(ongoing_trans, sess, &dep_graph, &outputs)?;\n+    codegen_backend.join_codegen_and_link(ongoing_codegen, sess, &dep_graph, &outputs)?;\n \n     if sess.opts.debugging_opts.perf_stats {\n         sess.print_perf_stats();\n@@ -1089,7 +1089,7 @@ pub fn default_provide_extern(providers: &mut ty::maps::Providers) {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(\n-    trans: &TransCrate,\n+    codegen_backend: &CodegenBackend,\n     control: &CompileController,\n     sess: &'tcx Session,\n     cstore: &'tcx CrateStoreDyn,\n@@ -1128,12 +1128,12 @@ where\n \n     let mut local_providers = ty::maps::Providers::default();\n     default_provide(&mut local_providers);\n-    trans.provide(&mut local_providers);\n+    codegen_backend.provide(&mut local_providers);\n     (control.provide)(&mut local_providers);\n \n     let mut extern_providers = local_providers;\n     default_provide_extern(&mut extern_providers);\n-    trans.provide_extern(&mut extern_providers);\n+    codegen_backend.provide_extern(&mut extern_providers);\n     (control.provide_extern)(&mut extern_providers);\n \n     let (tx, rx) = mpsc::channel();\n@@ -1233,23 +1233,23 @@ where\n     )\n }\n \n-/// Run the translation phase to LLVM, after which the AST and analysis can\n+/// Run the codegen backend, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'a, 'tcx>(\n-    trans: &TransCrate,\n+pub fn phase_4_codegen<'a, 'tcx>(\n+    codegen_backend: &CodegenBackend,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     rx: mpsc::Receiver<Box<Any + Send>>,\n ) -> Box<Any> {\n     time(tcx.sess, \"resolving dependency formats\", || {\n         ::rustc::middle::dependency_format::calculate(tcx)\n     });\n \n-    let translation = time(tcx.sess, \"translation\", move || trans.trans_crate(tcx, rx));\n+    let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n     if tcx.sess.profile_queries() {\n         profile::dump(&tcx.sess, \"profile_queries\".to_string())\n     }\n \n-    translation\n+    codegen\n }\n \n fn escape_dep_filename(filename: &FileName) -> String {\n@@ -1272,7 +1272,7 @@ fn generated_output_paths(\n             // If the filename has been overridden using `-o`, it will not be modified\n             // by appending `.rlib`, `.exe`, etc., so we can skip this transformation.\n             OutputType::Exe if !exact_name => for crate_type in sess.crate_types.borrow().iter() {\n-                let p = ::rustc_trans_utils::link::filename_for_input(\n+                let p = ::rustc_codegen_utils::link::filename_for_input(\n                     sess,\n                     *crate_type,\n                     crate_name,\n@@ -1424,7 +1424,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     if base.is_empty() {\n         base.extend(attr_types);\n         if base.is_empty() {\n-            base.push(::rustc_trans_utils::link::default_output_for_target(\n+            base.push(::rustc_codegen_utils::link::default_output_for_target(\n                 session,\n             ));\n         }\n@@ -1434,7 +1434,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n \n     base.into_iter()\n         .filter(|crate_type| {\n-            let res = !::rustc_trans_utils::link::invalid_output_for_target(session, *crate_type);\n+            let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n \n             if !res {\n                 session.warn(&format!("}, {"sha": "0b4b090f1f0b3e7c705d6fad1efee44816015754", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -52,7 +52,7 @@ extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n extern crate rustc_traits;\n-extern crate rustc_trans_utils;\n+extern crate rustc_codegen_utils;\n extern crate rustc_typeck;\n extern crate scoped_tls;\n extern crate serialize;\n@@ -83,7 +83,7 @@ use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc::util::common::{time, ErrorReported};\n-use rustc_trans_utils::trans_crate::TransCrate;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n use serialize::json::ToJson;\n \n@@ -122,17 +122,19 @@ pub mod target_features {\n     use syntax::ast;\n     use syntax::symbol::Symbol;\n     use rustc::session::Session;\n-    use rustc_trans_utils::trans_crate::TransCrate;\n+    use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n     /// Add `target_feature = \"...\"` cfgs for a variety of platform\n     /// specific features (SSE, NEON etc.).\n     ///\n     /// This is performed by checking whether a whitelisted set of\n     /// features is available on the target machine, by querying LLVM.\n-    pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session, trans: &TransCrate) {\n+    pub fn add_configuration(cfg: &mut ast::CrateConfig,\n+                             sess: &Session,\n+                             codegen_backend: &CodegenBackend) {\n         let tf = Symbol::intern(\"target_feature\");\n \n-        for feat in trans.target_features(sess) {\n+        for feat in codegen_backend.target_features(sess) {\n             cfg.insert((tf, Some(feat)));\n         }\n \n@@ -200,7 +202,7 @@ pub fn run<F>(run_compiler: F) -> isize\n     0\n }\n \n-fn load_backend_from_dylib(path: &Path) -> fn() -> Box<TransCrate> {\n+fn load_backend_from_dylib(path: &Path) -> fn() -> Box<CodegenBackend> {\n     // Note that we're specifically using `open_global_now` here rather than\n     // `open`, namely we want the behavior on Unix of RTLD_GLOBAL and RTLD_NOW,\n     // where NOW means \"bind everything right now\" because we don't want\n@@ -233,24 +235,24 @@ fn load_backend_from_dylib(path: &Path) -> fn() -> Box<TransCrate> {\n     }\n }\n \n-pub fn get_trans(sess: &Session) -> Box<TransCrate> {\n+pub fn get_codegen_backend(sess: &Session) -> Box<CodegenBackend> {\n     static INIT: Once = ONCE_INIT;\n \n     #[allow(deprecated)]\n     #[no_debug]\n-    static mut LOAD: fn() -> Box<TransCrate> = || unreachable!();\n+    static mut LOAD: fn() -> Box<CodegenBackend> = || unreachable!();\n \n     INIT.call_once(|| {\n-        let trans_name = sess.opts.debugging_opts.codegen_backend.as_ref()\n+        let codegen_name = sess.opts.debugging_opts.codegen_backend.as_ref()\n             .unwrap_or(&sess.target.target.options.codegen_backend);\n-        let backend = match &trans_name[..] {\n+        let backend = match &codegen_name[..] {\n             \"metadata_only\" => {\n-                rustc_trans_utils::trans_crate::MetadataOnlyTransCrate::new\n+                rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::new\n             }\n             filename if filename.contains(\".\") => {\n                 load_backend_from_dylib(filename.as_ref())\n             }\n-            trans_name => get_trans_sysroot(trans_name),\n+            codegen_name => get_codegen_sysroot(codegen_name),\n         };\n \n         unsafe {\n@@ -262,23 +264,23 @@ pub fn get_trans(sess: &Session) -> Box<TransCrate> {\n     backend\n }\n \n-fn get_trans_sysroot(backend_name: &str) -> fn() -> Box<TransCrate> {\n+fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<CodegenBackend> {\n     // For now we only allow this function to be called once as it'll dlopen a\n     // few things, which seems to work best if we only do that once. In\n-    // general this assertion never trips due to the once guard in `get_trans`,\n+    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n     // but there's a few manual calls to this function in this file we protect\n     // against.\n     static LOADED: AtomicBool = ATOMIC_BOOL_INIT;\n     assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n-            \"cannot load the default trans backend twice\");\n+            \"cannot load the default codegen backend twice\");\n \n     // When we're compiling this library with `--test` it'll run as a binary but\n     // not actually exercise much functionality. As a result most of the logic\n     // here is defunkt (it assumes we're a dynamic library in a sysroot) so\n     // let's just return a dummy creation function which won't be used in\n     // general anyway.\n     if cfg!(test) {\n-        return rustc_trans_utils::trans_crate::MetadataOnlyTransCrate::new\n+        return rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::new\n     }\n \n     let target = session::config::host_triple();\n@@ -346,7 +348,7 @@ fn get_trans_sysroot(backend_name: &str) -> fn() -> Box<TransCrate> {\n \n     let mut file: Option<PathBuf> = None;\n \n-    let expected_name = format!(\"rustc_trans-{}\", backend_name);\n+    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n     for entry in d.filter_map(|e| e.ok()) {\n         let path = entry.path();\n         let filename = match path.file_name().and_then(|s| s.to_str()) {\n@@ -520,20 +522,20 @@ fn run_compiler_with_pool<'a>(\n         return (Err(CompileIncomplete::Stopped), Some(sess));\n     }\n \n-    let trans = get_trans(&sess);\n+    let codegen_backend = get_codegen_backend(&sess);\n \n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n+    target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;\n \n     let result = {\n         let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n \n-        let cstore = CStore::new(trans.metadata_loader());\n+        let cstore = CStore::new(codegen_backend.metadata_loader());\n \n-        do_or_return!(callbacks.late_callback(&*trans,\n+        do_or_return!(callbacks.late_callback(&*codegen_backend,\n                                               &matches,\n                                               &sess,\n                                               &cstore,\n@@ -545,7 +547,7 @@ fn run_compiler_with_pool<'a>(\n \n         let control = callbacks.build_controller(&sess, &matches);\n \n-        driver::compile_input(trans,\n+        driver::compile_input(codegen_backend,\n                               &sess,\n                               &cstore,\n                               &input_file_path,\n@@ -659,7 +661,7 @@ pub trait CompilerCalls<'a> {\n     // be called just before actual compilation starts (and before build_controller\n     // is called), after all arguments etc. have been completely handled.\n     fn late_callback(&mut self,\n-                     _: &TransCrate,\n+                     _: &CodegenBackend,\n                      _: &getopts::Matches,\n                      _: &Session,\n                      _: &CrateStore,\n@@ -841,11 +843,11 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 }\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n-                let trans = get_trans(&sess);\n-                target_features::add_configuration(&mut cfg, &sess, &*trans);\n+                let codegen_backend = get_codegen_backend(&sess);\n+                target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n                 sess.parse_sess.config = cfg;\n                 let should_stop = RustcDefaultCalls::print_crate_info(\n-                    &*trans,\n+                    &*codegen_backend,\n                     &sess,\n                     None,\n                     odir,\n@@ -863,15 +865,15 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     }\n \n     fn late_callback(&mut self,\n-                     trans: &TransCrate,\n+                     codegen_backend: &CodegenBackend,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n                      cstore: &CrateStore,\n                      input: &Input,\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n-        RustcDefaultCalls::print_crate_info(trans, sess, Some(input), odir, ofile)\n+        RustcDefaultCalls::print_crate_info(codegen_backend, sess, Some(input), odir, ofile)\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, cstore, matches, input))\n     }\n \n@@ -1000,7 +1002,7 @@ impl RustcDefaultCalls {\n     }\n \n \n-    fn print_crate_info(trans: &TransCrate,\n+    fn print_crate_info(codegen_backend: &CodegenBackend,\n                         sess: &Session,\n                         input: Option<&Input>,\n                         odir: &Option<PathBuf>,\n@@ -1042,14 +1044,14 @@ impl RustcDefaultCalls {\n                     };\n                     let attrs = attrs.as_ref().unwrap();\n                     let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n-                    let id = rustc_trans_utils::link::find_crate_name(Some(sess), attrs, input);\n+                    let id = rustc_codegen_utils::link::find_crate_name(Some(sess), attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n                         continue;\n                     }\n                     let crate_types = driver::collect_crate_types(sess, attrs);\n                     for &style in &crate_types {\n-                        let fname = rustc_trans_utils::link::filename_for_input(\n+                        let fname = rustc_codegen_utils::link::filename_for_input(\n                             sess,\n                             style,\n                             &id,\n@@ -1102,7 +1104,7 @@ impl RustcDefaultCalls {\n                     }\n                 }\n                 RelocationModels | CodeModels | TlsModels | TargetCPUs | TargetFeatures => {\n-                    trans.print(*req, sess);\n+                    codegen_backend.print(*req, sess);\n                 }\n                 // Any output here interferes with Cargo's parsing of other printed output\n                 PrintRequest::NativeStaticLibs => {}\n@@ -1143,7 +1145,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n-        get_trans_sysroot(\"llvm\")().print_version();\n+        get_codegen_sysroot(\"llvm\")().print_version();\n     }\n }\n \n@@ -1451,7 +1453,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        get_trans_sysroot(\"llvm\")().print_passes();\n+        get_codegen_sysroot(\"llvm\")().print_passes();\n         return None;\n     }\n \n@@ -1663,8 +1665,8 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     // FIXME: need to figure out a way to get these back in here\n-    // all_errors.extend_from_slice(get_trans(sess).diagnostics());\n-    all_errors.extend_from_slice(&rustc_trans_utils::DIAGNOSTICS);\n+    // all_errors.extend_from_slice(get_codegen_backend(sess).diagnostics());\n+    all_errors.extend_from_slice(&rustc_codegen_utils::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);"}, {"sha": "f1ad14237eec27dfeb7ee1ce1cf424a46db56895", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -228,8 +228,8 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let control = &driver::CompileController::basic();\n-                let trans = ::get_trans(sess);\n-                abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n+                let codegen_backend = ::get_codegen_backend(sess);\n+                abort_on_err(driver::phase_3_run_analysis_passes(&*codegen_backend,\n                                                                  control,\n                                                                  sess,\n                                                                  cstore,\n@@ -1089,8 +1089,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     let control = &driver::CompileController::basic();\n-    let trans = ::get_trans(sess);\n-    abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n+    let codegen_backend = ::get_codegen_backend(sess);\n+    abort_on_err(driver::phase_3_run_analysis_passes(&*codegen_backend,\n                                                      control,\n                                                      sess,\n                                                      cstore,"}, {"sha": "46f552ed28da8320cb0838a5b0e72c5ccdca670b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -122,7 +122,7 @@ fn test_env_with_pool<F>(\n                                        None,\n                                        diagnostic_handler,\n                                        Lrc::new(CodeMap::new(FilePathMapping::empty())));\n-    let cstore = CStore::new(::get_trans(&sess).metadata_loader());\n+    let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::Anon,"}, {"sha": "c317d31b95ab9d4cf3ae199831679201346ed5de", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -13,7 +13,7 @@\n //! will dump graphs in graphviz form to disk, and it searches for\n //! `#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n //! annotations. These annotations can be used to test whether paths\n-//! exist in the graph. These checks run after trans, so they view the\n+//! exist in the graph. These checks run after codegen, so they view the\n //! the final state of the dependency graph. Note that there are\n //! similar assertions found in `persist::dirty_clean` which check the\n //! **initial** state of the dependency graph, just after it has been\n@@ -36,10 +36,10 @@\n //! #[rustc_if_this_changed(Hir)]\n //! fn foo() { }\n //!\n-//! #[rustc_then_this_would_need(trans)] //~ ERROR no path from `foo`\n+//! #[rustc_then_this_would_need(codegen)] //~ ERROR no path from `foo`\n //! fn bar() { }\n //!\n-//! #[rustc_then_this_would_need(trans)] //~ ERROR OK\n+//! #[rustc_then_this_would_need(codegen)] //~ ERROR OK\n //! fn baz() { foo(); }\n //! ```\n "}, {"sha": "df8e0f056afc9141651b63ea8fd0601aaded3d6c", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -16,7 +16,7 @@\n //!\n //! ```\n //! #![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n-//! #![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+//! #![rustc_partition_codegened(module=\"spike-x\", cfg=\"rpass2\")]\n //! ```\n //!\n //! The first indicates (in the cfg `rpass2`) that `spike.o` will be\n@@ -32,13 +32,13 @@ use rustc::mir::mono::CodegenUnit;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n use syntax_pos::symbol::Symbol;\n-use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_TRANSLATED};\n+use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED};\n \n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n \n #[derive(Debug, PartialEq, Clone, Copy)]\n-enum Disposition { Reused, Translated }\n+enum Disposition { Reused, Codegened }\n \n pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n@@ -61,8 +61,8 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n         let disposition = if attr.check_name(ATTR_PARTITION_REUSED) {\n             Disposition::Reused\n-        } else if attr.check_name(ATTR_PARTITION_TRANSLATED) {\n-            Disposition::Translated\n+        } else if attr.check_name(ATTR_PARTITION_CODEGENED) {\n+            Disposition::Codegened\n         } else {\n             return;\n         };\n@@ -84,17 +84,17 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n                 (Disposition::Reused, false) => {\n                     self.tcx.sess.span_err(\n                         attr.span,\n-                        &format!(\"expected module named `{}` to be Reused but is Translated\",\n+                        &format!(\"expected module named `{}` to be Reused but is Codegened\",\n                                  mname));\n                 }\n-                (Disposition::Translated, true) => {\n+                (Disposition::Codegened, true) => {\n                     self.tcx.sess.span_err(\n                         attr.span,\n-                        &format!(\"expected module named `{}` to be Translated but is Reused\",\n+                        &format!(\"expected module named `{}` to be Codegened but is Reused\",\n                                  mname));\n                 }\n                 (Disposition::Reused, true) |\n-                (Disposition::Translated, false) => {\n+                (Disposition::Codegened, false) => {\n                     // These are what we would expect.\n                 }\n             }"}, {"sha": "8f406161831bf18219f8ea9a5887a9e7a83a5898", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -239,8 +239,8 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         intravisit::walk_crate(&mut all_attrs, krate);\n \n         // Note that we cannot use the existing \"unused attribute\"-infrastructure\n-        // here, since that is running before trans. This is also the reason why\n-        // all trans-specific attributes are `Whitelisted` in syntax::feature_gate.\n+        // here, since that is running before codegen. This is also the reason why\n+        // all codegen-specific attributes are `Whitelisted` in syntax::feature_gate.\n         all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n     })\n }"}, {"sha": "2abe361233fd0f3fe77189a7f2fa6449f188d948", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -432,7 +432,7 @@ enum FfiResult<'tcx> {\n /// \"nullable pointer optimization\". Currently restricted\n /// to function pointers and references, but could be\n /// expanded to cover NonZero raw pointers and newtypes.\n-/// FIXME: This duplicates code in trans.\n+/// FIXME: This duplicates code in codegen.\n fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def: &'tcx ty::AdtDef,\n                                   substs: &Substs<'tcx>)"}, {"sha": "0497de940ca159b67b3e3467d826cf7c7f9fab32", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -515,7 +515,7 @@ pub enum ModuleBuffer {}\n // dllimport/dllexport are applied and need to be correct for everything to\n // link successfully. The #[link] annotation here says \"these symbols are\n // included statically\" which means that they're all exported with dllexport\n-// and from the rustc_llvm dynamic library. Otherwise the rustc_trans dynamic\n+// and from the rustc_llvm dynamic library. Otherwise the rustc_codegen_llvm dynamic\n // library would not be able to access these symbols.\n #[link(name = \"rustllvm\", kind = \"static\")]\n extern \"C\" {"}, {"sha": "07830d54d0c9e1bc83555caa297fbf178bfe3d51", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -138,7 +138,7 @@ pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n     }\n }\n \n-// Externally visible symbols that might appear in multiple translation units need to appear in\n+// Externally visible symbols that might appear in multiple codegen units need to appear in\n // their own comdat section so that the duplicates can be discarded at link time. This can for\n // example happen for generics when using multiple codegen units. This function simply uses the\n // value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the"}, {"sha": "b38c12355737b27308f1516d076204246a401eea", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -14,7 +14,7 @@ register_long_diagnostics! {\n E0454: r##\"\n A link name was given with an empty name. Erroneous code example:\n \n-```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n #[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n ```\n \n@@ -51,7 +51,7 @@ https://doc.rust-lang.org/book/first-edition/conditional-compilation.html\n E0458: r##\"\n An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n \n-```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n #[link(kind = \"wonderful_unicorn\")] extern {}\n // error: unknown kind: `wonderful_unicorn`\n ```\n@@ -67,7 +67,7 @@ Please specify a valid \"kind\" value, from one of the following:\n E0459: r##\"\n A link was used without a name parameter. Erroneous code example:\n \n-```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n #[link(kind = \"dylib\")] extern {}\n // error: #[link(...)] specified without `name = \"foo\"`\n ```"}, {"sha": "bbc4120f0600d3d2f26f34563f17da6ec8c042bc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -868,7 +868,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn metadata_output_only(&self) -> bool {\n         // MIR optimisation can be skipped when we're just interested in the metadata.\n-        !self.tcx.sess.opts.output_types.should_trans()\n+        !self.tcx.sess.opts.output_types.should_codegen()\n     }\n \n     fn const_qualif(&self, mir: u8, body_id: hir::BodyId) -> ConstQualif {\n@@ -930,7 +930,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ImplItemKind::Method(ref sig, _) => {\n                     let generics = self.tcx.generics_of(def_id);\n                     let needs_inline = (generics.requires_monomorphization(self.tcx) ||\n-                                        tcx.trans_fn_attrs(def_id).requests_inline()) &&\n+                                        tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                                         !self.metadata_output_only();\n                     let is_const_fn = sig.constness == hir::Constness::Const;\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n@@ -1224,8 +1224,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let has_tps = generics.ty_params().next().is_some();\n-                    let needs_inline = (has_tps || tcx.trans_fn_attrs(def_id).requests_inline()) &&\n-                        !self.metadata_output_only();\n+                    let needs_inline =\n+                        (has_tps || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                            !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n                         self.encode_optimized_mir(def_id)"}, {"sha": "4115dbe6274930681f7242deb644d9ec507d2438", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Rvalue::Cast(CastKind::Unsize, source, expr.ty))\n             }\n             ExprKind::Array { fields } => {\n-                // (*) We would (maybe) be closer to trans if we\n+                // (*) We would (maybe) be closer to codegen if we\n                 // handled this and other aggregate cases via\n                 // `into()`, not `as_rvalue` -- in that case, instead\n                 // of generating"}, {"sha": "0fd4b8e7e23022276886f588b8ef56116e9d9909", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Translates expressions into MIR. As a caller into this module, you\n+//! Builds MIR from expressions. As a caller into this module, you\n //! have many options, but the first thing you have to decide is\n //! whether you are evaluating this expression for its *value*, its\n //! *location*, or as a *constant*.\n@@ -41,7 +41,7 @@\n //! ### Implementation notes\n //!\n //! For any given kind of expression, there is generally one way that\n-//! can be translated most naturally. This is specified by the\n+//! can be lowered most naturally. This is specified by the\n //! `Category::of` function in the `category` module. For example, a\n //! struct expression (or other expression that creates a new value)\n //! is typically easiest to write in terms of `as_rvalue` or `into`,"}, {"sha": "f3953d0877c357d47fd473001024e002bbdcd4f4", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -896,7 +896,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n                         .collect(),\n                 };\n-                debug!(\"Entering guard translation context: {:?}\", guard_frame);\n+                debug!(\"Entering guard building context: {:?}\", guard_frame);\n                 self.guard_context.push(guard_frame);\n             } else {\n                 self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n@@ -909,7 +909,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {\n                 let guard_frame = self.guard_context.pop().unwrap();\n-                debug!(\"Exiting guard translation context with locals: {:?}\", guard_frame);\n+                debug!(\"Exiting guard building context with locals: {:?}\", guard_frame);\n             }\n \n             let false_edge_block = self.cfg.start_new_block();"}, {"sha": "3bbf73ec8b5e2dcac4820119b5fc610b1736ff7c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -775,7 +775,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n // Builder methods are broken up into modules, depending on what kind\n-// of thing is being translated. Note that they use the `unpack` macro\n+// of thing is being lowered. Note that they use the `unpack` macro\n // above extensively.\n \n mod block;"}, {"sha": "5dc59ac9f41197972469634891f5275bffb56032", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n /*!\n Managing the scope stack. The scopes are tied to lexical scopes, so as\n-we descend the HAIR, we push a scope on the stack, translate ite\n+we descend the HAIR, we push a scope on the stack, build its\n contents, and then pop it off. Every scope is named by a\n `region::Scope`.\n \n@@ -30,15 +30,15 @@ them. Eventually, when we shift to non-lexical lifetimes, there should\n be no need to remember this mapping.\n \n There is one additional wrinkle, actually, that I wanted to hide from\n-you but duty compels me to mention. In the course of translating\n+you but duty compels me to mention. In the course of building\n matches, it sometimes happen that certain code (namely guards) gets\n executed multiple times. This means that the scope lexical scope may\n in fact correspond to multiple, disjoint SEME regions. So in fact our\n mapping is from one scope to a vector of SEME regions.\n \n ### Drops\n \n-The primary purpose for scopes is to insert drops: while translating\n+The primary purpose for scopes is to insert drops: while building\n the contents, we also accumulate places that need to be dropped upon\n exit from each scope. This is done by calling `schedule_drop`. Once a\n drop is scheduled, whenever we branch out we will insert drops of all"}, {"sha": "5ef1eef133d9d45413a1448e2c7743c4de904bb5", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -20,7 +20,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n-        // We have to eagerly translate the \"spine\" of the statements\n+        // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n         let opt_destruction_scope ="}, {"sha": "b01b3542136c4f230102a6ef130c17a2d8829a36", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n-        // the settings for the crate they are translated in.\n+        // the settings for the crate they are codegened in.\n         let mut check_overflow = attr::contains_name(attrs, \"rustc_inherit_overflow_checks\");\n \n         // Respect -C overflow-checks."}, {"sha": "ab9acdc49507c385437bba50f9dd3b5e72a12db9", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The MIR is translated from some high-level abstract IR\n+//! The MIR is built from some high-level abstract IR\n //! (HAIR). This section defines the HAIR along with a trait for\n //! accessing it. The intention is to allow MIR construction to be\n //! unit-tested and separated from the Rust source and compiler data\n@@ -107,12 +107,12 @@ pub enum StmtKind<'tcx> {\n     },\n }\n \n-/// The Hair trait implementor translates their expressions (`&'tcx H::Expr`)\n-/// into instances of this `Expr` enum. This translation can be done\n+/// The Hair trait implementor lowers their expressions (`&'tcx H::Expr`)\n+/// into instances of this `Expr` enum. This lowering can be done\n /// basically as lazily or as eagerly as desired: every recursive\n /// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n-/// untranslated `&'tcx H::Expr`. Note that instances of `Expr` are very\n+/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n /// shortlived. They are created by `Hair::to_expr`, analyzed and\n /// converted into MIR, and then discarded.\n ///"}, {"sha": "c62eb1cf1855fa6e62587f0588b60a8d8e408c8e", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -188,7 +188,7 @@\n //! this is not implemented however: a mono item will be produced\n //! regardless of whether it is actually needed or not.\n \n-use rustc::hir::{self, TransFnAttrFlags};\n+use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n@@ -343,9 +343,9 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         visitor.push_extra_entry_roots();\n     }\n \n-    // We can only translate items that are instantiable - items all of\n+    // We can only codegen items that are instantiable - items all of\n     // whose predicates hold. Luckily, items that aren't instantiable\n-    // can't actually be used, so we can just skip translating them.\n+    // can't actually be used, so we can just skip codegenning them.\n     roots.retain(|root| root.is_instantiable(tcx));\n \n     roots\n@@ -717,7 +717,7 @@ fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-// Returns true if we should translate an instance in the local crate.\n+// Returns true if we should codegen an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n // need a mono item.\n fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n@@ -734,7 +734,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n \n     return match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => {\n-            false // foreign items are linked against, not translated.\n+            false // foreign items are linked against, not codegened.\n         }\n         Some(_) => true,\n         None => {\n@@ -1015,8 +1015,8 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n             MonoItemCollectionMode::Lazy => {\n                 self.entry_fn == Some(def_id) ||\n                 self.tcx.is_reachable_non_generic(def_id) ||\n-                self.tcx.trans_fn_attrs(def_id).flags.contains(\n-                    TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n+                self.tcx.codegen_fn_attrs(def_id).flags.contains(\n+                    CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n             }\n         }\n     }"}, {"sha": "27f8254bf8a784a7394101615bb9c09acd5e6e9e", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -29,15 +29,15 @@ use syntax_pos::symbol::Symbol;\n use syntax::codemap::Span;\n pub use rustc::mir::mono::MonoItem;\n \n-/// Describes how a translation item will be instantiated in object files.\n+/// Describes how a monomorphization will be instantiated in object files.\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum InstantiationMode {\n     /// There will be exactly one instance of the given MonoItem. It will have\n     /// external linkage so that it can be linked to from other codegen units.\n     GloballyShared {\n         /// In some compilation scenarios we may decide to take functions that\n         /// are typically `LocalCopy` and instead move them to `GloballyShared`\n-        /// to avoid translating them a bunch of times. In this situation,\n+        /// to avoid codegenning them a bunch of times. In this situation,\n         /// however, our local copy may conflict with other crates also\n         /// inlining the same function.\n         ///\n@@ -114,7 +114,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n                 // creating one copy of this `#[inline]` function which may\n                 // conflict with upstream crates as it could be an exported\n                 // symbol.\n-                match tcx.trans_fn_attrs(instance.def_id()).inline {\n+                match tcx.codegen_fn_attrs(instance.def_id()).inline {\n                     InlineAttr::Always => InstantiationMode::LocalCopy,\n                     _ => {\n                         InstantiationMode::GloballyShared  { may_conflict: true }\n@@ -137,19 +137,19 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(..) => return None,\n         };\n \n-        let trans_fn_attrs = tcx.trans_fn_attrs(def_id);\n-        trans_fn_attrs.linkage\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(def_id);\n+        codegen_fn_attrs.linkage\n     }\n \n     /// Returns whether this instance is instantiable - whether it has no unsatisfied\n     /// predicates.\n     ///\n-    /// In order to translate an item, all of its predicates must hold, because\n+    /// In order to codegen an item, all of its predicates must hold, because\n     /// otherwise the item does not make sense. Type-checking ensures that\n     /// the predicates of every item that is *used by* a valid item *do*\n     /// hold, so we can rely on that.\n     ///\n-    /// However, we translate collector roots (reachable items) and functions\n+    /// However, we codegen collector roots (reachable items) and functions\n     /// in vtables when they are seen, even if they are not used, and so they\n     /// might not be instantiable. For example, a programmer can define this\n     /// public function:\n@@ -158,7 +158,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     ///         <&mut () as Clone>::clone(&s);\n     ///     }\n     ///\n-    /// That function can't be translated, because the method `<&mut () as Clone>::clone`\n+    /// That function can't be codegened, because the method `<&mut () as Clone>::clone`\n     /// does not exist. Luckily for us, that function can't ever be used,\n     /// because that would require for `&'a mut (): Clone` to hold, so we\n     /// can just not emit any code, or even a linker reference for it.\n@@ -229,7 +229,7 @@ impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n // MonoItem String Keys\n //=-----------------------------------------------------------------------------\n \n-// The code below allows for producing a unique string key for a trans item.\n+// The code below allows for producing a unique string key for a mono item.\n // These keys are used by the handwritten auto-tests, so they need to be\n // predictable and human-readable.\n //"}, {"sha": "517933055133819effb09b99ff3e7b173982fe20", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -23,11 +23,11 @@ pub mod item;\n pub mod partitioning;\n \n #[inline(never)] // give this a place in the profiler\n-pub fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n+pub fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mono_items: I)\n     where I: Iterator<Item=&'a MonoItem<'tcx>>\n {\n-    let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-        (trans_item, trans_item.symbol_name(tcx))\n+    let mut symbols: Vec<_> = mono_items.map(|mono_item| {\n+        (mono_item, mono_item.symbol_name(tcx))\n     }).collect();\n \n     (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n@@ -39,11 +39,11 @@ pub fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tra\n         let sym2 = &pair[1].1;\n \n         if *sym1 == *sym2 {\n-            let trans_item1 = pair[0].0;\n-            let trans_item2 = pair[1].0;\n+            let mono_item1 = pair[0].0;\n+            let mono_item2 = pair[1].0;\n \n-            let span1 = trans_item1.local_span(tcx);\n-            let span2 = trans_item2.local_span(tcx);\n+            let span1 = mono_item1.local_span(tcx);\n+            let span2 = mono_item2.local_span(tcx);\n \n             // Deterministically select one of the spans for error reporting\n             let span = match (span1, span2) {\n@@ -111,7 +111,7 @@ fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n             // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // `fn(&mut self, ...)`. In fact, at codegen time, these are\n             // basically the same thing, so we can just return llfn.\n             Ok(false)\n         }\n@@ -124,7 +124,7 @@ fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n             //     fn call_once(self, ...) { call_mut(&self, ...) }\n             //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n             //\n-            // These are both the same at trans time.\n+            // These are both the same at codegen time.\n             Ok(true)\n         }\n         _ => Err(()),\n@@ -167,7 +167,7 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match tcx.trans_fulfill_obligation( (ty::ParamEnv::reveal_all(), trait_ref)) {\n+    match tcx.codegen_fulfill_obligation( (ty::ParamEnv::reveal_all(), trait_ref)) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }"}, {"sha": "9607a84124af5f7ac4ef45b25cd91a7a8e0e4802", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,16 +11,16 @@\n //! Partitioning Codegen Units for Incremental Compilation\n //! ======================================================\n //!\n-//! The task of this module is to take the complete set of translation items of\n+//! The task of this module is to take the complete set of monomorphizations of\n //! a crate and produce a set of codegen units from it, where a codegen unit\n-//! is a named set of (translation-item, linkage) pairs. That is, this module\n-//! decides which translation item appears in which codegen units with which\n+//! is a named set of (mono-item, linkage) pairs. That is, this module\n+//! decides which monomorphization appears in which codegen units with which\n //! linkage. The following paragraphs describe some of the background on the\n //! partitioning scheme.\n //!\n //! The most important opportunity for saving on compilation time with\n-//! incremental compilation is to avoid re-translating and re-optimizing code.\n-//! Since the unit of translation and optimization for LLVM is \"modules\" or, how\n+//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n+//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n //! we call them \"codegen units\", the particulars of how much time can be saved\n //! by incremental compilation are tightly linked to how the output program is\n //! partitioned into these codegen units prior to passing it to LLVM --\n@@ -214,17 +214,17 @@ fn fallback_cgu_name(tcx: TyCtxt) -> InternedString {\n \n \n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              trans_items: I,\n+                              mono_items: I,\n                               strategy: PartitioningStrategy,\n                               inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = MonoItem<'tcx>>\n {\n-    // In the first step, we place all regular translation items into their\n-    // respective 'home' codegen unit. Regular translation items are all\n+    // In the first step, we place all regular monomorphizations into their\n+    // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = place_root_translation_items(tcx,\n-                                                                trans_items);\n+    let mut initial_partitioning = place_root_mono_items(tcx,\n+                                                                mono_items);\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n \n@@ -239,10 +239,10 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n-    // translation items have to go into each codegen unit. These additional\n-    // translation items can be drop-glue, functions from external crates, and\n+    // monomorphizations have to go into each codegen unit. These additional\n+    // monomorphizations can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n-    let mut post_inlining = place_inlined_translation_items(initial_partitioning,\n+    let mut post_inlining = place_inlined_mono_items(initial_partitioning,\n                                                             inlining_map);\n \n     post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n@@ -258,7 +258,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Finally, sort by codegen unit name, so that we get deterministic results\n     let PostInliningPartitioning {\n         codegen_units: mut result,\n-        trans_item_placements: _,\n+        mono_item_placements: _,\n         internalization_candidates: _,\n     } = post_inlining;\n \n@@ -275,23 +275,23 @@ struct PreInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-/// For symbol internalization, we need to know whether a symbol/trans-item is\n+/// For symbol internalization, we need to know whether a symbol/mono-item is\n /// accessed from outside the codegen unit it is defined in. This type is used\n /// to keep track of that.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-enum TransItemPlacement {\n+enum MonoItemPlacement {\n     SingleCgu { cgu_name: InternedString },\n     MultipleCgus,\n }\n \n struct PostInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    trans_item_placements: FxHashMap<MonoItem<'tcx>, TransItemPlacement>,\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             trans_items: I)\n+fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             mono_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = MonoItem<'tcx>>\n {\n@@ -307,15 +307,15 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let export_generics = tcx.share_generics() &&\n                           tcx.local_crate_exports_generics();\n \n-    for trans_item in trans_items {\n-        match trans_item.instantiation_mode(tcx) {\n+    for mono_item in mono_items {\n+        match mono_item.instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n             InstantiationMode::LocalCopy => continue,\n         }\n \n-        let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n+        let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n         let is_volatile = is_incremental_build &&\n-                          trans_item.is_generic_fn();\n+                          mono_item.is_generic_fn();\n \n         let codegen_unit_name = match characteristic_def_id {\n             Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n@@ -353,10 +353,10 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Visibility::Hidden\n             }\n         };\n-        let (linkage, mut visibility) = match trans_item.explicit_linkage(tcx) {\n+        let (linkage, mut visibility) = match mono_item.explicit_linkage(tcx) {\n             Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n             None => {\n-                match trans_item {\n+                match mono_item {\n                     MonoItem::Fn(ref instance) => {\n                         let visibility = match instance.def {\n                             InstanceDef::Item(def_id) => {\n@@ -463,11 +463,11 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n         if visibility == Visibility::Hidden && can_be_internalized {\n-            internalization_candidates.insert(trans_item);\n+            internalization_candidates.insert(mono_item);\n         }\n \n-        codegen_unit.items_mut().insert(trans_item, (linkage, visibility));\n-        roots.insert(trans_item);\n+        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+        roots.insert(mono_item);\n     }\n \n     // always ensure we have at least one CGU; otherwise, if we have a\n@@ -522,11 +522,11 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     }\n }\n \n-fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n+fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n                                          inlining_map: &InliningMap<'tcx>)\n                                          -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n-    let mut trans_item_placements = FxHashMap();\n+    let mut mono_item_placements = FxHashMap();\n \n     let PreInliningPartitioning {\n         codegen_units: initial_cgus,\n@@ -545,40 +545,40 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name().clone());\n \n-        // Add all translation items that are not already there\n-        for trans_item in reachable {\n-            if let Some(linkage) = old_codegen_unit.items().get(&trans_item) {\n+        // Add all monomorphizations that are not already there\n+        for mono_item in reachable {\n+            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n                 // This is a root, just copy it over\n-                new_codegen_unit.items_mut().insert(trans_item, *linkage);\n+                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n             } else {\n-                if roots.contains(&trans_item) {\n-                    bug!(\"GloballyShared trans-item inlined into other CGU: \\\n-                          {:?}\", trans_item);\n+                if roots.contains(&mono_item) {\n+                    bug!(\"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\", mono_item);\n                 }\n \n                 // This is a cgu-private copy\n                 new_codegen_unit.items_mut().insert(\n-                    trans_item,\n+                    mono_item,\n                     (Linkage::Internal, Visibility::Default),\n                 );\n             }\n \n             if !single_codegen_unit {\n                 // If there is more than one codegen unit, we need to keep track\n-                // in which codegen units each translation item is placed:\n-                match trans_item_placements.entry(trans_item) {\n+                // in which codegen units each monomorphization is placed:\n+                match mono_item_placements.entry(mono_item) {\n                     Entry::Occupied(e) => {\n                         let placement = e.into_mut();\n                         debug_assert!(match *placement {\n-                            TransItemPlacement::SingleCgu { ref cgu_name } => {\n+                            MonoItemPlacement::SingleCgu { ref cgu_name } => {\n                                 *cgu_name != *new_codegen_unit.name()\n                             }\n-                            TransItemPlacement::MultipleCgus => true,\n+                            MonoItemPlacement::MultipleCgus => true,\n                         });\n-                        *placement = TransItemPlacement::MultipleCgus;\n+                        *placement = MonoItemPlacement::MultipleCgus;\n                     }\n                     Entry::Vacant(e) => {\n-                        e.insert(TransItemPlacement::SingleCgu {\n+                        e.insert(MonoItemPlacement::SingleCgu {\n                             cgu_name: new_codegen_unit.name().clone()\n                         });\n                     }\n@@ -591,18 +591,18 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n     return PostInliningPartitioning {\n         codegen_units: new_partitioning,\n-        trans_item_placements,\n+        mono_item_placements,\n         internalization_candidates,\n     };\n \n-    fn follow_inlining<'tcx>(trans_item: MonoItem<'tcx>,\n+    fn follow_inlining<'tcx>(mono_item: MonoItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n                              visited: &mut FxHashSet<MonoItem<'tcx>>) {\n-        if !visited.insert(trans_item) {\n+        if !visited.insert(mono_item) {\n             return;\n         }\n \n-        inlining_map.with_inlining_candidates(trans_item, |target| {\n+        inlining_map.with_inlining_candidates(mono_item, |target| {\n             follow_inlining(target, inlining_map, visited);\n         });\n     }\n@@ -625,7 +625,7 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    // Build a map from every translation item to all the translation items that\n+    // Build a map from every monomorphization to all the monomorphizations that\n     // reference it.\n     let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = FxHashMap();\n     inlining_map.iter_accesses(|accessor, accessees| {\n@@ -636,12 +636,12 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     });\n \n-    let trans_item_placements = &partitioning.trans_item_placements;\n+    let mono_item_placements = &partitioning.mono_item_placements;\n \n     // For each internalization candidates in each codegen unit, check if it is\n     // accessed from outside its defining codegen unit.\n     for cgu in &mut partitioning.codegen_units {\n-        let home_cgu = TransItemPlacement::SingleCgu {\n+        let home_cgu = MonoItemPlacement::SingleCgu {\n             cgu_name: cgu.name().clone()\n         };\n \n@@ -650,14 +650,14 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // This item is no candidate for internalizing, so skip it.\n                 continue\n             }\n-            debug_assert_eq!(trans_item_placements[accessee], home_cgu);\n+            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n \n             if let Some(accessors) = accessor_map.get(accessee) {\n                 if accessors.iter()\n                             .filter_map(|accessor| {\n                                 // Some accessors might not have been\n                                 // instantiated. We can safely ignore those.\n-                                trans_item_placements.get(accessor)\n+                                mono_item_placements.get(accessor)\n                             })\n                             .any(|placement| *placement != home_cgu) {\n                     // Found an accessor from another CGU, so skip to the next\n@@ -667,16 +667,16 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             // If we got here, we did not find any accesses from other CGUs,\n-            // so it's fine to make this translation item internal.\n+            // so it's fine to make this monomorphization internal.\n             *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n         }\n     }\n }\n \n-fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 trans_item: MonoItem<'tcx>)\n+fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 mono_item: MonoItem<'tcx>)\n                                                  -> Option<DefId> {\n-    match trans_item {\n+    match mono_item {\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n                 ty::InstanceDef::Item(def_id) => def_id,\n@@ -771,14 +771,14 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         for cgu in cgus {\n             debug!(\"CodegenUnit {}:\", cgu.name());\n \n-            for (trans_item, linkage) in cgu.items() {\n-                let symbol_name = trans_item.symbol_name(tcx).name.as_str();\n+            for (mono_item, linkage) in cgu.items() {\n+                let symbol_name = mono_item.symbol_name(tcx).name.as_str();\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");\n \n                 debug!(\" - {} [{:?}] [{}]\",\n-                       trans_item.to_string(tcx),\n+                       mono_item.to_string(tcx),\n                        linkage,\n                        symbol_hash);\n             }"}, {"sha": "2d2663bc7c3fca1336dbbe85452907193df5c5a2", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -69,8 +69,8 @@ fn make_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             )\n         }\n         ty::InstanceDef::Virtual(def_id, _) => {\n-            // We are translating a call back to our def-id, which\n-            // trans::mir knows to turn to an actual virtual call.\n+            // We are generating a call back to our def-id, which the\n+            // codegen backend knows to turn to an actual virtual call.\n             build_call_shim(\n                 tcx,\n                 def_id,"}, {"sha": "2692790444000c5f9209390c02c80f292530e9ec", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -30,7 +30,7 @@ pub use self::AddCallGuards::*;\n  * do at the end of the predecessor block, or at the start of the\n  * successor block. Critical edges have to be broken in order to prevent\n  * \"edge actions\" from affecting other edges. We need this for calls that are\n- * translated to LLVM invoke instructions, because invoke is a block terminator\n+ * codegened to LLVM invoke instructions, because invoke is a block terminator\n  * in LLVM so we can't insert any code to handle the call's result into the\n  * block that performs the call.\n  *"}, {"sha": "15b0c4a8bf7510cea181a090555fa11605caef4a", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -442,7 +442,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     /// Elaborate a MIR `replace` terminator. This instruction\n-    /// is not directly handled by translation, and therefore\n+    /// is not directly handled by codegen, and therefore\n     /// must be desugared.\n     ///\n     /// The desugaring drops the location if needed, and then writes"}, {"sha": "c697391d86776aa5b0bbe064a82e46f57b85b791", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! This pass erases all early-bound regions from the types occurring in the MIR.\n-//! We want to do this once just before trans, so trans does not have to take\n+//! We want to do this once just before codegen, so codegen does not have to take\n //! care erasing regions all over the place.\n //! NOTE:  We do NOT erase regions of statements that are relevant for\n //! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion."}, {"sha": "5fb9148d49a278251a51126336529b7ff3d6cc9c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n //! Inlining pass for MIR functions\n \n use rustc::hir;\n-use rustc::hir::TransFnAttrFlags;\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::DefId;\n \n use rustc_data_structures::bitvec::BitVector;\n@@ -211,16 +211,16 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n-        // Do not inline {u,i}128 lang items, trans const eval depends\n+        // Do not inline {u,i}128 lang items, codegen const eval depends\n         // on detecting calls to these lang items and intercepting them\n         if tcx.is_binop_lang_item(callsite.callee).is_some() {\n             debug!(\"    not inlining 128bit integer lang item\");\n             return false;\n         }\n \n-        let trans_fn_attrs = tcx.trans_fn_attrs(callsite.callee);\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee);\n \n-        let hinted = match trans_fn_attrs.inline {\n+        let hinted = match codegen_fn_attrs.inline {\n             // Just treat inline(always) as a hint for now,\n             // there are cases that prevent inlining that we\n             // need to check for first.\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         };\n \n         // Significantly lower the threshold for inlining cold functions\n-        if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n+        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n             threshold /= 5;\n         }\n \n@@ -355,7 +355,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n         }\n \n-        if let attr::InlineAttr::Always = trans_fn_attrs.inline {\n+        if let attr::InlineAttr::Always = codegen_fn_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n             true\n         } else {\n@@ -515,8 +515,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         //     Fn::call(closure_ref, tuple_tmp)\n         //\n         // meanwhile the closure body expects the arguments (here, `a`, `b`, and `c`)\n-        // as distinct arguments. (This is the \"rust-call\" ABI hack.) Normally, trans has\n-        // the job of unpacking this tuple. But here, we are trans. =) So we want to create\n+        // as distinct arguments. (This is the \"rust-call\" ABI hack.) Normally, codegen has\n+        // the job of unpacking this tuple. But here, we are codegen. =) So we want to create\n         // a vector like\n         //\n         //     [closure_ref, tuple_tmp.0, tuple_tmp.1, tuple_tmp.2]"}, {"sha": "e2f2312dbd204a79a346ad1dd01d2dec85b528f4", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -277,7 +277,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         simplify::SimplifyLocals,\n \n         add_call_guards::CriticalCallEdges,\n-        dump_mir::Marker(\"PreTrans\"),\n+        dump_mir::Marker(\"PreCodegen\"),\n     ];\n     tcx.alloc_mir(mir)\n }"}, {"sha": "7e23a5cb1a89509262c0a7ba27f0908c3907842b", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -15,7 +15,7 @@\n //!\n //! The `SimplifyLocals` pass is kinda expensive and therefore not very suitable to be run often.\n //! Most of the passes should not care or be impacted in meaningful ways due to extra locals\n-//! either, so running the pass once, right before translation, should suffice.\n+//! either, so running the pass once, right before codegen, should suffice.\n //!\n //! On the other side of the spectrum, the `SimplifyCfg` pass is considerably cheap to run, thus\n //! one should run it after every pass which may modify CFG in significant ways. This pass must"}, {"sha": "d1868ba2abb1722760356eb4812c20173ebe063b", "filename": "src/librustc_trans/README.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -1,7 +0,0 @@\n-The `trans` crate contains the code to convert from MIR into LLVM IR,\n-and then from LLVM IR into machine code. In general it contains code\n-that runs towards the end of the compilation process.\n-\n-For more information about how trans works, see the [rustc guide].\n-\n-[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trans.html"}, {"sha": "feb26e76162573dab1cad4d7f546057e721d72cd", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -72,7 +72,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n \n-/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n+/// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {"}, {"sha": "2dd22058d76959289f89dc523e9769a1504ca9f5", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -665,7 +665,7 @@ enum Op {\n ///    `PartialEq` is not applicable.\n ///\n /// Reason #2 is the killer. I tried for a while to always use\n-/// overloaded logic and just check the types in constants/trans after\n+/// overloaded logic and just check the types in constants/codegen after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n fn is_builtin_binop(lhs: Ty, rhs: Ty, op: hir::BinOp) -> bool {\n     match BinOpCategory::from(op) {"}, {"sha": "735ebbfcb3d38557e8bf87d0459edf68f57c44b2", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Check properties that are required by built-in traits and set\n-//! up data structures required by type-checking/translation.\n+//! up data structures required by type-checking/codegen.\n \n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;"}, {"sha": "157f3ab76ca0c17f2720c3f6adff6694d2b113cd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -48,7 +48,7 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::feature_gate;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::{self, map as hir_map, TransFnAttrs, TransFnAttrFlags, Unsafety};\n+use rustc::hir::{self, map as hir_map, CodegenFnAttrs, CodegenFnAttrFlags, Unsafety};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n@@ -75,7 +75,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n-        trans_fn_attrs,\n+        codegen_fn_attrs,\n         ..*providers\n     };\n }\n@@ -1800,33 +1800,33 @@ fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &\n     }\n }\n \n-fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAttrs {\n+fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> CodegenFnAttrs {\n     let attrs = tcx.get_attrs(id);\n \n-    let mut trans_fn_attrs = TransFnAttrs::new();\n+    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n \n     let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n \n     let mut inline_span = None;\n     for attr in attrs.iter() {\n         if attr.check_name(\"cold\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::COLD;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n         } else if attr.check_name(\"allocator\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::ALLOCATOR;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n         } else if attr.check_name(\"unwind\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::UNWIND;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n         } else if attr.check_name(\"rustc_allocator_nounwind\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n         } else if attr.check_name(\"naked\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::NAKED;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n         } else if attr.check_name(\"no_mangle\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::NO_MANGLE;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n         } else if attr.check_name(\"rustc_std_internal_symbol\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n         } else if attr.check_name(\"no_debug\") {\n-            trans_fn_attrs.flags |= TransFnAttrFlags::NO_DEBUG;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_DEBUG;\n         } else if attr.check_name(\"inline\") {\n-            trans_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+            codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n                 if attr.path != \"inline\" {\n                     return ia;\n                 }\n@@ -1862,7 +1862,7 @@ fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAt\n             });\n         } else if attr.check_name(\"export_name\") {\n             if let s @ Some(_) = attr.value_str() {\n-                trans_fn_attrs.export_name = s;\n+                codegen_fn_attrs.export_name = s;\n             } else {\n                 struct_span_err!(tcx.sess, attr.span, E0558,\n                                     \"export_name attribute has invalid format\")\n@@ -1875,10 +1875,10 @@ fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAt\n                            `unsafe` function\";\n                 tcx.sess.span_err(attr.span, msg);\n             }\n-            from_target_feature(tcx, id, attr, &whitelist, &mut trans_fn_attrs.target_features);\n+            from_target_feature(tcx, id, attr, &whitelist, &mut codegen_fn_attrs.target_features);\n         } else if attr.check_name(\"linkage\") {\n             if let Some(val) = attr.value_str() {\n-                trans_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n+                codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n         }\n     }\n@@ -1887,14 +1887,14 @@ fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAt\n     // purpose functions as they wouldn't have the right target features\n     // enabled. For that reason we also forbid #[inline(always)] as it can't be\n     // respected.\n-    if trans_fn_attrs.target_features.len() > 0 {\n-        if trans_fn_attrs.inline == InlineAttr::Always {\n+    if codegen_fn_attrs.target_features.len() > 0 {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let Some(span) = inline_span {\n                 tcx.sess.span_err(span, \"cannot use #[inline(always)] with \\\n                                          #[target_feature]\");\n             }\n         }\n     }\n \n-    trans_fn_attrs\n+    codegen_fn_attrs\n }"}, {"sha": "99744d5b4b680112556a501cc39f5956f1661eca", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1179,7 +1179,7 @@ extern \"rust-intrinsic\" {\n ```\n \n Please check you didn't make a mistake in the function's name. All intrinsic\n-functions are defined in librustc_trans/trans/intrinsic.rs and in\n+functions are defined in librustc_codegen_llvm/intrinsic.rs and in\n libcore/intrinsics.rs in the Rust source code. Example:\n \n ```\n@@ -1209,7 +1209,7 @@ fn main() {\n ```\n \n Please check you didn't make a mistake in the function's name. All intrinsic\n-functions are defined in librustc_trans/trans/intrinsic.rs and in\n+functions are defined in librustc_codegen_llvm/intrinsic.rs and in\n libcore/intrinsics.rs in the Rust source code. Example:\n \n ```"}, {"sha": "90889890e0bc2ae8c120b6d0fff2faffd94f6365", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -219,19 +219,19 @@ pub fn run_core(search_paths: SearchPaths,\n         let mut sess = session::build_session_(\n             sessopts, cpath, diagnostic_handler, codemap,\n         );\n-        let trans = rustc_driver::get_trans(&sess);\n-        let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n+        let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+        let cstore = Rc::new(CStore::new(codegen_backend.metadata_loader()));\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n-        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n         let control = &driver::CompileController::basic();\n \n         let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n \n-        let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n+        let name = ::rustc_codegen_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n \n         let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n \n@@ -279,7 +279,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n         let resolver = RefCell::new(resolver);\n \n-        abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n+        abort_on_err(driver::phase_3_run_analysis_passes(&*codegen_backend,\n                                                         control,\n                                                         &sess,\n                                                         &*cstore,"}, {"sha": "3ce95c78a9000bba69587e3e96e0523a5040fa26", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -33,7 +33,7 @@ extern crate getopts;\n extern crate env_logger;\n extern crate rustc;\n extern crate rustc_data_structures;\n-extern crate rustc_trans_utils;\n+extern crate rustc_codegen_utils;\n extern crate rustc_driver;\n extern crate rustc_resolve;\n extern crate rustc_lint;"}, {"sha": "f507d0dc09dab39aa92e4c45d13cf409bd20a432", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -95,12 +95,12 @@ pub fn run(input_path: &Path,\n         let mut sess = session::build_session_(\n             sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n         );\n-        let trans = rustc_driver::get_trans(&sess);\n-        let cstore = CStore::new(trans.metadata_loader());\n+        let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+        let cstore = CStore::new(codegen_backend.metadata_loader());\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n         let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n@@ -120,7 +120,7 @@ pub fn run(input_path: &Path,\n         };\n \n         let crate_name = crate_name.unwrap_or_else(|| {\n-            ::rustc_trans_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n+            ::rustc_codegen_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n         });\n         let mut opts = scrape_test_config(hir_forest.krate());\n         opts.display_warnings |= display_warnings;\n@@ -273,16 +273,16 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         let mut sess = session::build_session_(\n             sessopts, None, diagnostic_handler, codemap,\n         );\n-        let trans = rustc_driver::get_trans(&sess);\n-        let cstore = CStore::new(trans.metadata_loader());\n+        let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+        let cstore = CStore::new(codegen_backend.metadata_loader());\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n         let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n         let mut control = driver::CompileController::basic();\n \n         let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n         let out = Some(outdir.lock().unwrap().path().to_path_buf());\n@@ -293,7 +293,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n \n         let res = panic::catch_unwind(AssertUnwindSafe(|| {\n             driver::compile_input(\n-                trans,\n+                codegen_backend,\n                 &sess,\n                 &cstore,\n                 &None,"}, {"sha": "d247b5402efbc7913cc3425715f00d037b80d6b1", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -839,7 +839,7 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                    is just used for rustc unit tests \\\n                                                    and will never be stable\",\n                                                   cfg_fn!(rustc_attrs))),\n-    (\"rustc_partition_translated\", Whitelisted, Gated(Stability::Unstable,\n+    (\"rustc_partition_codegened\", Whitelisted, Gated(Stability::Unstable,\n                                                       \"rustc_attrs\",\n                                                       \"this attribute \\\n                                                        is just used for rustc unit tests \\\n@@ -938,7 +938,7 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted, Ungated),\n \n-    // FIXME: #14406 these are processed in trans, which happens after the\n+    // FIXME: #14406 these are processed in codegen, which happens after the\n     // lint pass\n     (\"cold\", Whitelisted, Ungated),\n     (\"naked\", Whitelisted, Gated(Stability::Unstable,"}, {"sha": "f29cc75664da81fb92bc774225a856f7f0c145c4", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -79,7 +79,7 @@ struct Context<'a, 'b: 'a> {\n     /// final generated static argument array. We record the starting indices\n     /// corresponding to each positional argument, and number of references\n     /// consumed so far for each argument, to facilitate correct `Position`\n-    /// mapping in `trans_piece`. In effect this can be seen as a \"flattened\"\n+    /// mapping in `build_piece`. In effect this can be seen as a \"flattened\"\n     /// version of `arg_unique_types`.\n     ///\n     /// Again with the example described above in docstring for `args`:\n@@ -108,7 +108,7 @@ struct Context<'a, 'b: 'a> {\n \n     /// Current position of the implicit positional arg pointer, as if it\n     /// still existed in this phase of processing.\n-    /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n+    /// Used only for `all_pieces_simple` tracking in `build_piece`.\n     curarg: usize,\n     /// Keep track of invalid references to positional arguments\n     invalid_refs: Vec<usize>,\n@@ -373,7 +373,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.std_path(&[\"fmt\", \"rt\", \"v1\", s])\n     }\n \n-    fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n+    fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -401,17 +401,17 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// Translate the accumulated string literals to a literal expression\n-    fn trans_literal_string(&mut self) -> P<ast::Expr> {\n+    /// Build a literal expression from the accumulated string literals\n+    fn build_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n         let s = Symbol::intern(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n \n-    /// Translate a `parse::Piece` to a static `rt::Argument` or append\n+    /// Build a static `rt::Argument` from a `parse::Piece` or append\n     /// to the `literal` string.\n-    fn trans_piece(&mut self,\n+    fn build_piece(&mut self,\n                    piece: &parse::Piece,\n                    arg_index_consumed: &mut Vec<usize>)\n                    -> Option<P<ast::Expr>> {\n@@ -422,7 +422,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None\n             }\n             parse::NextArgument(ref arg) => {\n-                // Translate the position\n+                // Build the position\n                 let pos = {\n                     let pos = |c, arg| {\n                         let mut path = Context::rtpath(self.ecx, \"Position\");\n@@ -486,7 +486,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.all_pieces_simple = false;\n                 }\n \n-                // Translate the format\n+                // Build the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n                     let mut p = Context::rtpath(self.ecx, \"Alignment\");\n@@ -501,8 +501,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_u32(sp, arg.format.flags);\n-                let prec = self.trans_count(arg.format.precision);\n-                let width = self.trans_count(arg.format.width);\n+                let prec = self.build_count(arg.format.precision);\n+                let width = self.build_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt =\n                     self.ecx.expr_struct(sp,\n@@ -759,8 +759,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n \n     let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n     for piece in pieces {\n-        if let Some(piece) = cx.trans_piece(&piece, &mut arg_index_consumed) {\n-            let s = cx.trans_literal_string();\n+        if let Some(piece) = cx.build_piece(&piece, &mut arg_index_consumed) {\n+            let s = cx.build_literal_string();\n             cx.str_pieces.push(s);\n             cx.pieces.push(piece);\n         }\n@@ -776,7 +776,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {\n-        let s = cx.trans_literal_string();\n+        let s = cx.build_literal_string();\n         cx.str_pieces.push(s);\n     }\n "}, {"sha": "0dd8f0c55d8d496b668c25704ed99a84f231f8cc", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -697,7 +697,7 @@ pub mod printf {\n \n         /// Check that the translations are what we expect.\n         #[test]\n-        fn test_trans() {\n+        fn test_translation() {\n             assert_eq_pnsat!(\"%c\", Some(\"{}\"));\n             assert_eq_pnsat!(\"%d\", Some(\"{}\"));\n             assert_eq_pnsat!(\"%u\", Some(\"{}\"));\n@@ -900,7 +900,7 @@ pub mod shell {\n         }\n \n         #[test]\n-        fn test_trans() {\n+        fn test_translation() {\n             assert_eq_pnsat!(\"$0\", Some(\"{0}\"));\n             assert_eq_pnsat!(\"$9\", Some(\"{9}\"));\n             assert_eq_pnsat!(\"$1\", Some(\"{1}\"));"}, {"sha": "642aa0e5b125da1ea99803eb361f3e516266ab8e", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -14,7 +14,7 @@\n /// \"file-scoped\", or \"module-level\" assembly. These synonyms\n /// all correspond to LLVM's module-level inline assembly instruction.\n ///\n-/// For example, `global_asm!(\"some assembly here\")` translates to\n+/// For example, `global_asm!(\"some assembly here\")` codegens to\n /// LLVM's `module asm \"some assembly here\"`. All of LLVM's caveats\n /// therefore apply.\n "}, {"sha": "d5410feb254a033549da30663caf91b8eea51c9d", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -388,7 +388,7 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.FunctionSections = FunctionSections;\n \n   if (TrapUnreachable) {\n-    // Tell LLVM to translate `unreachable` into an explicit trap instruction.\n+    // Tell LLVM to codegen `unreachable` into an explicit trap instruction.\n     // This limits the extent of possible undefined behavior in some cases, as\n     // it prevents control flow from \"falling through\" into whatever code\n     // happens to be laid out next in memory."}, {"sha": "a26604d3ce969d77572cf34e7662810bf9857f63", "filename": "src/test/codegen-units/item-collection/cross-crate-closures.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,29 +9,29 @@\n // except according to those terms.\n \n // In the current version of the collector that still has to support\n-// legacy-trans, closures do not generate their own TransItems, so we are\n-// ignoring this test until MIR trans has taken over completely\n+// legacy-codegen, closures do not generate their own MonoItems, so we are\n+// ignoring this test until MIR codegen has taken over completely\n // ignore-test\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n \n // aux-build:cgu_extern_closures.rs\n extern crate cgu_extern_closures;\n \n-//~ TRANS_ITEM fn cross_crate_closures::start[0]\n+//~ MONO_ITEM fn cross_crate_closures::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n \n-    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn[0]\n-    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn[0]::{{closure}}[0]\n+    //~ MONO_ITEM fn cgu_extern_closures::inlined_fn[0]\n+    //~ MONO_ITEM fn cgu_extern_closures::inlined_fn[0]::{{closure}}[0]\n     let _ = cgu_extern_closures::inlined_fn(1, 2);\n \n-    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn_generic[0]<i32>\n-    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn_generic[0]::{{closure}}[0]<i32>\n+    //~ MONO_ITEM fn cgu_extern_closures::inlined_fn_generic[0]<i32>\n+    //~ MONO_ITEM fn cgu_extern_closures::inlined_fn_generic[0]::{{closure}}[0]<i32>\n     let _ = cgu_extern_closures::inlined_fn_generic(3, 4, 5i32);\n \n     // Nothing should be generated for this call, we just link to the instance\n@@ -41,4 +41,4 @@ fn start(_: isize, _: *const *const u8) -> isize {\n     0\n }\n \n-//~ TRANS_ITEM drop-glue i8\n+//~ MONO_ITEM drop-glue i8"}, {"sha": "aa33c25da9a248c9b9c9f6fb7408defcc7bf6b0e", "filename": "src/test/codegen-units/item-collection/cross-crate-generic-functions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n \n // aux-build:cgu_generic_function.rs\n extern crate cgu_generic_function;\n \n-//~ TRANS_ITEM fn cross_crate_generic_functions::start[0]\n+//~ MONO_ITEM fn cross_crate_generic_functions::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn cgu_generic_function::bar[0]<u32>\n-    //~ TRANS_ITEM fn cgu_generic_function::foo[0]<u32>\n+    //~ MONO_ITEM fn cgu_generic_function::bar[0]<u32>\n+    //~ MONO_ITEM fn cgu_generic_function::foo[0]<u32>\n     let _ = cgu_generic_function::foo(1u32);\n \n-    //~ TRANS_ITEM fn cgu_generic_function::bar[0]<u64>\n-    //~ TRANS_ITEM fn cgu_generic_function::foo[0]<u64>\n+    //~ MONO_ITEM fn cgu_generic_function::bar[0]<u64>\n+    //~ MONO_ITEM fn cgu_generic_function::foo[0]<u64>\n     let _ = cgu_generic_function::foo(2u64);\n \n     // This should not introduce a codegen item"}, {"sha": "7a16b22a023c44e3728e80503f3f74ae7308f467", "filename": "src/test/codegen-units/item-collection/cross-crate-trait-method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-trait-method.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -19,7 +19,7 @@ extern crate cgu_export_trait_method;\n \n use cgu_export_trait_method::Trait;\n \n-//~ TRANS_ITEM fn cross_crate_trait_method::start[0]\n+//~ MONO_ITEM fn cross_crate_trait_method::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     // The object code of these methods is contained in the external crate, so\n@@ -30,31 +30,31 @@ fn start(_: isize, _: *const *const u8) -> isize {\n     // Currently, no object code is generated for trait methods with default\n     // implemenations, unless they are actually called from somewhere. Therefore\n     // we cannot import the implementations and have to create our own inline.\n-    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl[0]<u32>\n+    //~ MONO_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl[0]<u32>\n     let _ = Trait::with_default_impl(0u32);\n-    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl[0]<char>\n+    //~ MONO_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl[0]<char>\n     let _ = Trait::with_default_impl('c');\n \n \n \n-    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<u32, &str>\n+    //~ MONO_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<u32, &str>\n     let _ = Trait::with_default_impl_generic(0u32, \"abc\");\n-    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<u32, bool>\n+    //~ MONO_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<u32, bool>\n     let _ = Trait::with_default_impl_generic(0u32, false);\n \n-    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<char, i16>\n+    //~ MONO_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<char, i16>\n     let _ = Trait::with_default_impl_generic('x', 1i16);\n-    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<char, i32>\n+    //~ MONO_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<char, i32>\n     let _ = Trait::with_default_impl_generic('y', 0i32);\n \n-    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[1]::without_default_impl_generic[0]<char>\n+    //~ MONO_ITEM fn cgu_export_trait_method::{{impl}}[1]::without_default_impl_generic[0]<char>\n     let _: (u32, char) = Trait::without_default_impl_generic('c');\n-    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[1]::without_default_impl_generic[0]<bool>\n+    //~ MONO_ITEM fn cgu_export_trait_method::{{impl}}[1]::without_default_impl_generic[0]<bool>\n     let _: (u32, bool) = Trait::without_default_impl_generic(false);\n \n-    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<char>\n+    //~ MONO_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<char>\n     let _: (char, char) = Trait::without_default_impl_generic('c');\n-    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<bool>\n+    //~ MONO_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<bool>\n     let _: (char, bool) = Trait::without_default_impl_generic(false);\n \n     0"}, {"sha": "49e4b8d43c19c9131c4560e63710f9dbcf9266a6", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,38 +9,38 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![feature(start)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic0[Internal]\n struct StructWithDtor(u32);\n \n impl Drop for StructWithDtor {\n-    //~ TRANS_ITEM fn drop_in_place_intrinsic::{{impl}}[0]::drop[0]\n+    //~ MONO_ITEM fn drop_in_place_intrinsic::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM fn drop_in_place_intrinsic::start[0]\n+//~ MONO_ITEM fn drop_in_place_intrinsic::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic0[Internal]\n     let x = [StructWithDtor(0), StructWithDtor(1)];\n \n     drop_slice_in_place(&x);\n \n     0\n }\n \n-//~ TRANS_ITEM fn drop_in_place_intrinsic::drop_slice_in_place[0]\n+//~ MONO_ITEM fn drop_in_place_intrinsic::drop_slice_in_place[0]\n fn drop_slice_in_place(x: &[StructWithDtor]) {\n     unsafe {\n         // This is the interesting thing in this test case: Normally we would\n         // not have drop-glue for the unsized [StructWithDtor]. This has to be\n         // generated though when the drop_in_place() intrinsic is used.\n-        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic0[Internal]\n+        //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic0[Internal]\n         ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n     }\n }"}, {"sha": "9a88336d1e57ea3a252cb9dc5a3215651fbe5e3c", "filename": "src/test/codegen-units/item-collection/function-as-argument.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -24,26 +24,26 @@ fn take_fn_pointer<T1, T2>(f: fn(T1, T2), x: T1, y: T2) {\n     (f)(x, y)\n }\n \n-//~ TRANS_ITEM fn function_as_argument::start[0]\n+//~ MONO_ITEM fn function_as_argument::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n \n-    //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<u32, &str, fn(u32, &str)>\n-    //~ TRANS_ITEM fn function_as_argument::function[0]<u32, &str>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(u32, &str), (u32, &str)>\n+    //~ MONO_ITEM fn function_as_argument::take_fn_once[0]<u32, &str, fn(u32, &str)>\n+    //~ MONO_ITEM fn function_as_argument::function[0]<u32, &str>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(u32, &str), (u32, &str)>\n     take_fn_once(function, 0u32, \"abc\");\n \n-    //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<char, f64, fn(char, f64)>\n-    //~ TRANS_ITEM fn function_as_argument::function[0]<char, f64>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(char, f64), (char, f64)>\n+    //~ MONO_ITEM fn function_as_argument::take_fn_once[0]<char, f64, fn(char, f64)>\n+    //~ MONO_ITEM fn function_as_argument::function[0]<char, f64>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(char, f64), (char, f64)>\n     take_fn_once(function, 'c', 0f64);\n \n-    //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<i32, ()>\n-    //~ TRANS_ITEM fn function_as_argument::function[0]<i32, ()>\n+    //~ MONO_ITEM fn function_as_argument::take_fn_pointer[0]<i32, ()>\n+    //~ MONO_ITEM fn function_as_argument::function[0]<i32, ()>\n     take_fn_pointer(function, 0i32, ());\n \n-    //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<f32, i64>\n-    //~ TRANS_ITEM fn function_as_argument::function[0]<f32, i64>\n+    //~ MONO_ITEM fn function_as_argument::take_fn_pointer[0]<f32, i64>\n+    //~ MONO_ITEM fn function_as_argument::function[0]<f32, i64>\n     take_fn_pointer(function, 0f32, 0i64);\n \n     0"}, {"sha": "aad32d1eb7c0646493e6513d5042aaad6d2bb87a", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n@@ -47,41 +47,41 @@ enum EnumNoDrop<T1, T2> {\n struct NonGenericNoDrop(i32);\n \n struct NonGenericWithDrop(i32);\n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue0[Internal]\n \n impl Drop for NonGenericWithDrop {\n-    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n+    //~ MONO_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM fn generic_drop_glue::start[0]\n+//~ MONO_ITEM fn generic_drop_glue::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue0[Internal]\n+    //~ MONO_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue0[Internal]\n+    //~ MONO_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n     // Should produce no drop glue\n     let _ = StructNoDrop { x: 'a', y: 0u32 }.x;\n \n     // This is supposed to generate drop-glue because it contains a field that\n     // needs to be dropped.\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue0[Internal]\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue0[Internal]\n+    //~ MONO_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n-    //~TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n+    //~MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue0[Internal]\n+    //~ MONO_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as f64"}, {"sha": "402d19f9996ce27be90f9d657f874d1d45cc261a", "filename": "src/test/codegen-units/item-collection/generic-functions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-functions.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -27,39 +27,39 @@ fn foo3<T1, T2, T3>(a: T1, b: T2, c: T3) -> (T1, T2, T3) {\n }\n \n // This function should be instantiated even if no used\n-//~ TRANS_ITEM fn generic_functions::lifetime_only[0]\n+//~ MONO_ITEM fn generic_functions::lifetime_only[0]\n pub fn lifetime_only<'a>(a: &'a u32) -> &'a u32 {\n     a\n }\n \n-//~ TRANS_ITEM fn generic_functions::start[0]\n+//~ MONO_ITEM fn generic_functions::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn generic_functions::foo1[0]<i32>\n+    //~ MONO_ITEM fn generic_functions::foo1[0]<i32>\n     let _ = foo1(2i32);\n-    //~ TRANS_ITEM fn generic_functions::foo1[0]<i64>\n+    //~ MONO_ITEM fn generic_functions::foo1[0]<i64>\n     let _ = foo1(2i64);\n-    //~ TRANS_ITEM fn generic_functions::foo1[0]<&str>\n+    //~ MONO_ITEM fn generic_functions::foo1[0]<&str>\n     let _ = foo1(\"abc\");\n-    //~ TRANS_ITEM fn generic_functions::foo1[0]<char>\n+    //~ MONO_ITEM fn generic_functions::foo1[0]<char>\n     let _ = foo1('v');\n \n-    //~ TRANS_ITEM fn generic_functions::foo2[0]<i32, i32>\n+    //~ MONO_ITEM fn generic_functions::foo2[0]<i32, i32>\n     let _ = foo2(2i32, 2i32);\n-    //~ TRANS_ITEM fn generic_functions::foo2[0]<i64, &str>\n+    //~ MONO_ITEM fn generic_functions::foo2[0]<i64, &str>\n     let _ = foo2(2i64, \"abc\");\n-    //~ TRANS_ITEM fn generic_functions::foo2[0]<&str, usize>\n+    //~ MONO_ITEM fn generic_functions::foo2[0]<&str, usize>\n     let _ = foo2(\"a\", 2usize);\n-    //~ TRANS_ITEM fn generic_functions::foo2[0]<char, ()>\n+    //~ MONO_ITEM fn generic_functions::foo2[0]<char, ()>\n     let _ = foo2('v', ());\n \n-    //~ TRANS_ITEM fn generic_functions::foo3[0]<i32, i32, i32>\n+    //~ MONO_ITEM fn generic_functions::foo3[0]<i32, i32, i32>\n     let _ = foo3(2i32, 2i32, 2i32);\n-    //~ TRANS_ITEM fn generic_functions::foo3[0]<i64, &str, char>\n+    //~ MONO_ITEM fn generic_functions::foo3[0]<i64, &str, char>\n     let _ = foo3(2i64, \"abc\", 'c');\n-    //~ TRANS_ITEM fn generic_functions::foo3[0]<i16, &str, usize>\n+    //~ MONO_ITEM fn generic_functions::foo3[0]<i16, &str, usize>\n     let _ = foo3(0i16, \"a\", 2usize);\n-    //~ TRANS_ITEM fn generic_functions::foo3[0]<char, (), ()>\n+    //~ MONO_ITEM fn generic_functions::foo3[0]<char, (), ()>\n     let _ = foo3('v', (), ());\n \n     0"}, {"sha": "07e51a1e9472216496076570bd526ed7831fe4f6", "filename": "src/test/codegen-units/item-collection/generic-impl.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-impl.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -41,41 +41,41 @@ pub struct LifeTimeOnly<'a> {\n \n impl<'a> LifeTimeOnly<'a> {\n \n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[1]::foo[0]\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[1]::foo[0]\n     pub fn foo(&self) {}\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[1]::bar[0]\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[1]::bar[0]\n     pub fn bar(&'a self) {}\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[1]::baz[0]\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[1]::baz[0]\n     pub fn baz<'b>(&'b self) {}\n \n     pub fn non_instantiated<T>(&self) {}\n }\n \n-//~ TRANS_ITEM fn generic_impl::start[0]\n+//~ MONO_ITEM fn generic_impl::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<i32>\n-    //~ TRANS_ITEM fn generic_impl::id[0]<i32>\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<i32, i16>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::new[0]<i32>\n+    //~ MONO_ITEM fn generic_impl::id[0]<i32>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::get[0]<i32, i16>\n     let _ = Struct::new(0i32).get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<i64>\n-    //~ TRANS_ITEM fn generic_impl::id[0]<i64>\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<i64, i16>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::new[0]<i64>\n+    //~ MONO_ITEM fn generic_impl::id[0]<i64>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::get[0]<i64, i16>\n     let _ = Struct::new(0i64).get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<char>\n-    //~ TRANS_ITEM fn generic_impl::id[0]<char>\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<char, i16>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::new[0]<char>\n+    //~ MONO_ITEM fn generic_impl::id[0]<char>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::get[0]<char, i16>\n     let _ = Struct::new('c').get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<&str>\n-    //~ TRANS_ITEM fn generic_impl::id[0]<&str>\n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<generic_impl::Struct[0]<&str>, i16>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::new[0]<&str>\n+    //~ MONO_ITEM fn generic_impl::id[0]<&str>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::get[0]<generic_impl::Struct[0]<&str>, i16>\n     let _ = Struct::new(Struct::new(\"str\")).get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<generic_impl::Struct[0]<&str>>\n-    //~ TRANS_ITEM fn generic_impl::id[0]<generic_impl::Struct[0]<&str>>\n+    //~ MONO_ITEM fn generic_impl::{{impl}}[0]::new[0]<generic_impl::Struct[0]<&str>>\n+    //~ MONO_ITEM fn generic_impl::id[0]<generic_impl::Struct[0]<&str>>\n     let _ = (Struct::new(Struct::new(\"str\")).f)(Struct::new(\"str\"));\n \n     0"}, {"sha": "6d65c0d3aa8b41fa8181e6803a252363d3208c34", "filename": "src/test/codegen-units/item-collection/impl-in-non-instantiated-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fimpl-in-non-instantiated-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fimpl-in-non-instantiated-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fimpl-in-non-instantiated-generic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -22,14 +22,14 @@ trait SomeTrait {\n // discovered.\n pub fn generic_function<T>(x: T) -> (T, i32) {\n     impl SomeTrait for i64 {\n-        //~ TRANS_ITEM fn impl_in_non_instantiated_generic::generic_function[0]::{{impl}}[0]::foo[0]\n+        //~ MONO_ITEM fn impl_in_non_instantiated_generic::generic_function[0]::{{impl}}[0]::foo[0]\n         fn foo(&self) {}\n     }\n \n     (x, 0)\n }\n \n-//~ TRANS_ITEM fn impl_in_non_instantiated_generic::start[0]\n+//~ MONO_ITEM fn impl_in_non_instantiated_generic::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     0i64.foo();"}, {"sha": "5c6201da252bee22bc49265a4787b26c1dfa355d", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n@@ -29,20 +29,20 @@ impl<T> Trait for Struct<T> {\n     fn bar(&self) {}\n }\n \n-//~ TRANS_ITEM fn instantiation_through_vtable::start[0]\n+//~ MONO_ITEM fn instantiation_through_vtable::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     let s1 = Struct { _a: 0u32 };\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable0[Internal]\n-    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n-    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable0[Internal]\n+    //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n+    //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;\n \n     let s1 = Struct { _a: 0u64 };\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable0[Internal]\n-    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n-    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable0[Internal]\n+    //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n+    //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n     let _ = &s1 as &Trait;\n \n     0"}, {"sha": "f9813063831f9e6a7358abed7c097dcab8f4deab", "filename": "src/test/codegen-units/item-collection/items-within-generic-items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n \n fn generic_fn<T>(a: T) -> (T, i32) {\n-    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]::nested_fn[0]\n+    //~ MONO_ITEM fn items_within_generic_items::generic_fn[0]::nested_fn[0]\n     fn nested_fn(a: i32) -> i32 {\n         a + 1\n     }\n \n     let x = {\n-        //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]::nested_fn[1]\n+        //~ MONO_ITEM fn items_within_generic_items::generic_fn[0]::nested_fn[1]\n         fn nested_fn(a: i32) -> i32 {\n             a + 2\n         }\n@@ -32,14 +32,14 @@ fn generic_fn<T>(a: T) -> (T, i32) {\n     return (a, x + nested_fn(0));\n }\n \n-//~ TRANS_ITEM fn items_within_generic_items::start[0]\n+//~ MONO_ITEM fn items_within_generic_items::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<i64>\n+    //~ MONO_ITEM fn items_within_generic_items::generic_fn[0]<i64>\n     let _ = generic_fn(0i64);\n-    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<u16>\n+    //~ MONO_ITEM fn items_within_generic_items::generic_fn[0]<u16>\n     let _ = generic_fn(0u16);\n-    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<i8>\n+    //~ MONO_ITEM fn items_within_generic_items::generic_fn[0]<i8>\n     let _ = generic_fn(0i8);\n \n     0"}, {"sha": "77ada23de714cdfd7ca4679a2ca788fc63489236", "filename": "src/test/codegen-units/item-collection/non-generic-closures.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,51 +9,51 @@\n // except according to those terms.\n \n // In the current version of the collector that still has to support\n-// legacy-trans, closures do not generate their own TransItems, so we are\n-// ignoring this test until MIR trans has taken over completely\n+// legacy-codegen, closures do not generate their own MonoItems, so we are\n+// ignoring this test until MIR codegen has taken over completely\n // ignore-test\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ TRANS_ITEM fn non_generic_closures::temporary[0]\n+//~ MONO_ITEM fn non_generic_closures::temporary[0]\n fn temporary() {\n-    //~ TRANS_ITEM fn non_generic_closures::temporary[0]::{{closure}}[0]\n+    //~ MONO_ITEM fn non_generic_closures::temporary[0]::{{closure}}[0]\n     (|a: u32| {\n         let _ = a;\n     })(4);\n }\n \n-//~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_but_not_executed[0]\n+//~ MONO_ITEM fn non_generic_closures::assigned_to_variable_but_not_executed[0]\n fn assigned_to_variable_but_not_executed() {\n-    //~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_but_not_executed[0]::{{closure}}[0]\n+    //~ MONO_ITEM fn non_generic_closures::assigned_to_variable_but_not_executed[0]::{{closure}}[0]\n     let _x = |a: i16| {\n         let _ = a + 1;\n     };\n }\n \n-//~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_directly[0]\n+//~ MONO_ITEM fn non_generic_closures::assigned_to_variable_executed_directly[0]\n fn assigned_to_variable_executed_indirectly() {\n-    //~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_directly[0]::{{closure}}[0]\n+    //~ MONO_ITEM fn non_generic_closures::assigned_to_variable_executed_directly[0]::{{closure}}[0]\n     let f = |a: i32| {\n         let _ = a + 2;\n     };\n     run_closure(&f);\n }\n \n-//~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_indirectly[0]\n+//~ MONO_ITEM fn non_generic_closures::assigned_to_variable_executed_indirectly[0]\n fn assigned_to_variable_executed_directly() {\n-    //~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_indirectly[0]::{{closure}}[0]\n+    //~ MONO_ITEM fn non_generic_closures::assigned_to_variable_executed_indirectly[0]::{{closure}}[0]\n     let f = |a: i64| {\n         let _ = a + 3;\n     };\n     f(4);\n }\n \n-//~ TRANS_ITEM fn non_generic_closures::start[0]\n+//~ MONO_ITEM fn non_generic_closures::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     temporary();\n@@ -64,7 +64,7 @@ fn start(_: isize, _: *const *const u8) -> isize {\n     0\n }\n \n-//~ TRANS_ITEM fn non_generic_closures::run_closure[0]\n+//~ MONO_ITEM fn non_generic_closures::run_closure[0]\n fn run_closure(f: &Fn(i32)) {\n     f(3);\n }"}, {"sha": "6ca24aa5b4b89da9fd84b79b49582373b128ed13", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,41 +9,41 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n struct StructWithDrop {\n     x: i32\n }\n \n impl Drop for StructWithDrop {\n-    //~ TRANS_ITEM fn non_generic_drop_glue::{{impl}}[0]::drop[0]\n+    //~ MONO_ITEM fn non_generic_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n struct StructNoDrop {\n     x: i32\n }\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n enum EnumWithDrop {\n     A(i32)\n }\n \n impl Drop for EnumWithDrop {\n-    //~ TRANS_ITEM fn non_generic_drop_glue::{{impl}}[1]::drop[0]\n+    //~ MONO_ITEM fn non_generic_drop_glue::{{impl}}[1]::drop[0]\n     fn drop(&mut self) {}\n }\n \n enum EnumNoDrop {\n     A(i32)\n }\n \n-//~ TRANS_ITEM fn non_generic_drop_glue::start[0]\n+//~ MONO_ITEM fn non_generic_drop_glue::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     let _ = StructWithDrop { x: 0 }.x;"}, {"sha": "38d08c8a6ed2a127efa313698d30039caa98ab6a", "filename": "src/test/codegen-units/item-collection/non-generic-functions.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,68 +9,68 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ TRANS_ITEM fn non_generic_functions::foo[0]\n+//~ MONO_ITEM fn non_generic_functions::foo[0]\n fn foo() {\n     {\n-        //~ TRANS_ITEM fn non_generic_functions::foo[0]::foo[0]\n+        //~ MONO_ITEM fn non_generic_functions::foo[0]::foo[0]\n         fn foo() {}\n         foo();\n     }\n \n     {\n-        //~ TRANS_ITEM fn non_generic_functions::foo[0]::foo[1]\n+        //~ MONO_ITEM fn non_generic_functions::foo[0]::foo[1]\n         fn foo() {}\n         foo();\n     }\n }\n \n-//~ TRANS_ITEM fn non_generic_functions::bar[0]\n+//~ MONO_ITEM fn non_generic_functions::bar[0]\n fn bar() {\n-    //~ TRANS_ITEM fn non_generic_functions::bar[0]::baz[0]\n+    //~ MONO_ITEM fn non_generic_functions::bar[0]::baz[0]\n     fn baz() {}\n     baz();\n }\n \n struct Struct { _x: i32 }\n \n impl Struct {\n-    //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]\n+    //~ MONO_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]\n     fn foo() {\n         {\n-            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]::foo[0]\n+            //~ MONO_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]::foo[0]\n             fn foo() {}\n             foo();\n         }\n \n         {\n-            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]::foo[1]\n+            //~ MONO_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]::foo[1]\n             fn foo() {}\n             foo();\n         }\n     }\n \n-    //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]\n+    //~ MONO_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]\n     fn bar(&self) {\n         {\n-            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]::foo[0]\n+            //~ MONO_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]::foo[0]\n             fn foo() {}\n             foo();\n         }\n \n         {\n-            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]::foo[1]\n+            //~ MONO_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]::foo[1]\n             fn foo() {}\n             foo();\n         }\n     }\n }\n \n-//~ TRANS_ITEM fn non_generic_functions::start[0]\n+//~ MONO_ITEM fn non_generic_functions::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     foo();"}, {"sha": "dae6ef8355126e8f3eb305ad4b5189c76a1e2c41", "filename": "src/test/codegen-units/item-collection/overloaded-operators.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![crate_type=\"lib\"]\n@@ -23,7 +23,7 @@ pub struct Indexable {\n impl Index<usize> for Indexable {\n     type Output = u8;\n \n-    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[0]::index[0]\n+    //~ MONO_ITEM fn overloaded_operators::{{impl}}[0]::index[0]\n     fn index(&self, index: usize) -> &Self::Output {\n         if index >= 3 {\n             &self.data[0]\n@@ -34,7 +34,7 @@ impl Index<usize> for Indexable {\n }\n \n impl IndexMut<usize> for Indexable {\n-    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[1]::index_mut[0]\n+    //~ MONO_ITEM fn overloaded_operators::{{impl}}[1]::index_mut[0]\n     fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n         if index >= 3 {\n             &mut self.data[0]\n@@ -45,16 +45,16 @@ impl IndexMut<usize> for Indexable {\n }\n \n \n-//~ TRANS_ITEM fn overloaded_operators::{{impl}}[4]::eq[0]\n-//~ TRANS_ITEM fn overloaded_operators::{{impl}}[4]::ne[0]\n+//~ MONO_ITEM fn overloaded_operators::{{impl}}[4]::eq[0]\n+//~ MONO_ITEM fn overloaded_operators::{{impl}}[4]::ne[0]\n #[derive(PartialEq)]\n pub struct Equatable(u32);\n \n \n impl Add<u32> for Equatable {\n     type Output = u32;\n \n-    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[2]::add[0]\n+    //~ MONO_ITEM fn overloaded_operators::{{impl}}[2]::add[0]\n     fn add(self, rhs: u32) -> u32 {\n         self.0 + rhs\n     }\n@@ -63,7 +63,7 @@ impl Add<u32> for Equatable {\n impl Deref for Equatable {\n     type Target = u32;\n \n-    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[3]::deref[0]\n+    //~ MONO_ITEM fn overloaded_operators::{{impl}}[3]::deref[0]\n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }"}, {"sha": "f36c4903458eeb6421a08f9a7a254128da8cd4bc", "filename": "src/test/codegen-units/item-collection/static-init.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // ignore-tidy-linelength\n \n #![feature(start)]\n@@ -17,12 +17,11 @@ pub static FN : fn() = foo::<i32>;\n \n pub fn foo<T>() { }\n \n-//~ TRANS_ITEM fn static_init::foo[0]<i32>\n-//~ TRANS_ITEM static static_init::FN[0]\n+//~ MONO_ITEM fn static_init::foo[0]<i32>\n+//~ MONO_ITEM static static_init::FN[0]\n \n-//~ TRANS_ITEM fn static_init::start[0]\n+//~ MONO_ITEM fn static_init::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     0\n }\n-"}, {"sha": "883809ff059661b0eaf79a767c60f7ea6799541d", "filename": "src/test/codegen-units/item-collection/statics-and-consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -48,7 +48,7 @@ fn foo() {\n     };\n }\n \n-//~ TRANS_ITEM fn statics_and_consts::start[0]\n+//~ MONO_ITEM fn statics_and_consts::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     foo();\n@@ -57,9 +57,9 @@ fn start(_: isize, _: *const *const u8) -> isize {\n     0\n }\n \n-//~ TRANS_ITEM static statics_and_consts::STATIC1[0]\n+//~ MONO_ITEM static statics_and_consts::STATIC1[0]\n \n-//~ TRANS_ITEM fn statics_and_consts::foo[0]\n-//~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[0]\n-//~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[1]\n-//~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[2]\n+//~ MONO_ITEM fn statics_and_consts::foo[0]\n+//~ MONO_ITEM static statics_and_consts::foo[0]::STATIC2[0]\n+//~ MONO_ITEM static statics_and_consts::foo[0]::STATIC2[1]\n+//~ MONO_ITEM static statics_and_consts::foo[0]::STATIC2[2]"}, {"sha": "f85486b5d347824f3c59707667e16a29247d7358", "filename": "src/test/codegen-units/item-collection/trait-implementations.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -21,15 +21,15 @@ pub trait SomeTrait {\n \n impl SomeTrait for i64 {\n \n-    //~ TRANS_ITEM fn trait_implementations::{{impl}}[0]::foo[0]\n+    //~ MONO_ITEM fn trait_implementations::{{impl}}[0]::foo[0]\n     fn foo(&self) {}\n \n     fn bar<T>(&self, _: T) {}\n }\n \n impl SomeTrait for i32 {\n \n-    //~ TRANS_ITEM fn trait_implementations::{{impl}}[1]::foo[0]\n+    //~ MONO_ITEM fn trait_implementations::{{impl}}[1]::foo[0]\n     fn foo(&self) {}\n \n     fn bar<T>(&self, _: T) {}\n@@ -43,7 +43,7 @@ pub trait SomeGenericTrait<T> {\n // Concrete impl of generic trait\n impl SomeGenericTrait<u32> for f64 {\n \n-    //~ TRANS_ITEM fn trait_implementations::{{impl}}[2]::foo[0]\n+    //~ MONO_ITEM fn trait_implementations::{{impl}}[2]::foo[0]\n     fn foo(&self, _: u32) {}\n \n     fn bar<T2>(&self, _: u32, _: T2) {}\n@@ -56,28 +56,28 @@ impl<T> SomeGenericTrait<T> for f32 {\n     fn bar<T2>(&self, _: T, _: T2) {}\n }\n \n-//~ TRANS_ITEM fn trait_implementations::start[0]\n+//~ MONO_ITEM fn trait_implementations::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[1]::bar[0]<char>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[1]::bar[0]<char>\n    0i32.bar('x');\n \n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[2]::bar[0]<&str>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[2]::bar[0]<&str>\n    0f64.bar(0u32, \"&str\");\n \n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[2]::bar[0]<()>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[2]::bar[0]<()>\n    0f64.bar(0u32, ());\n \n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::foo[0]<char>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[3]::foo[0]<char>\n    0f32.foo('x');\n \n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::foo[0]<i64>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[3]::foo[0]<i64>\n    0f32.foo(-1i64);\n \n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<u32, ()>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<u32, ()>\n    0f32.bar(0u32, ());\n \n-   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<&str, &str>\n+   //~ MONO_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<&str, &str>\n    0f32.bar(\"&str\", \"&str\");\n \n    0"}, {"sha": "1f08f0f80601438f8901ad10dbf52d5f877edc04", "filename": "src/test/codegen-units/item-collection/trait-method-as-argument.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -37,33 +37,33 @@ fn take_foo_mut<T, F: FnMut(T) -> T>(mut f: F, arg: T) -> T {\n     (f)(arg)\n }\n \n-//~ TRANS_ITEM fn trait_method_as_argument::start[0]\n+//~ MONO_ITEM fn trait_method_as_argument::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n-    //~ TRANS_ITEM fn trait_method_as_argument::{{impl}}[0]::foo[0]\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(u32) -> u32, (u32)>\n+    //~ MONO_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n+    //~ MONO_ITEM fn trait_method_as_argument::{{impl}}[0]::foo[0]\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(u32) -> u32, (u32)>\n     take_foo_once(Trait::foo, 0u32);\n \n-    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>\n-    //~ TRANS_ITEM fn trait_method_as_argument::Trait[0]::foo[0]<char>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(char) -> char, (char)>\n+    //~ MONO_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>\n+    //~ MONO_ITEM fn trait_method_as_argument::Trait[0]::foo[0]<char>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(char) -> char, (char)>\n     take_foo_once(Trait::foo, 'c');\n \n-    //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<u32, fn(u32) -> u32>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::Fn[0]::call[0]<fn(u32) -> u32, (u32)>\n+    //~ MONO_ITEM fn trait_method_as_argument::take_foo[0]<u32, fn(u32) -> u32>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::Fn[0]::call[0]<fn(u32) -> u32, (u32)>\n     take_foo(Trait::foo, 0u32);\n \n-    //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<char, fn(char) -> char>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::Fn[0]::call[0]<fn(char) -> char, (char)>\n+    //~ MONO_ITEM fn trait_method_as_argument::take_foo[0]<char, fn(char) -> char>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::Fn[0]::call[0]<fn(char) -> char, (char)>\n     take_foo(Trait::foo, 'c');\n \n-    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<u32, fn(u32) -> u32>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnMut[0]::call_mut[0]<fn(char) -> char, (char)>\n+    //~ MONO_ITEM fn trait_method_as_argument::take_foo_mut[0]<u32, fn(u32) -> u32>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::FnMut[0]::call_mut[0]<fn(char) -> char, (char)>\n     take_foo_mut(Trait::foo, 0u32);\n \n-    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<char, fn(char) -> char>\n-    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n+    //~ MONO_ITEM fn trait_method_as_argument::take_foo_mut[0]<char, fn(char) -> char>\n+    //~ MONO_ITEM fn core::ops[0]::function[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n     take_foo_mut(Trait::foo, 'c');\n \n     0"}, {"sha": "b130747972e38d90439532b2107434e753e999a2", "filename": "src/test/codegen-units/item-collection/trait-method-default-impl.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![deny(dead_code)]\n #![feature(start)]\n@@ -24,7 +24,7 @@ impl SomeTrait for i8 {\n \n     // For the non-generic foo(), we should generate a codegen-item even if it\n     // is not called anywhere\n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::foo[0]<i8>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeTrait[0]::foo[0]<i8>\n }\n \n trait SomeGenericTrait<T1> {\n@@ -38,7 +38,7 @@ impl SomeGenericTrait<u64> for i32 {\n \n     // For the non-generic foo(), we should generate a codegen-item even if it\n     // is not called anywhere\n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::foo[0]<i32, u64>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::foo[0]<i32, u64>\n }\n \n // Non-generic impl of generic trait\n@@ -47,25 +47,25 @@ impl<T1> SomeGenericTrait<T1> for u32 {\n     // since nothing is monomorphic here, nothing should be generated unless used somewhere.\n }\n \n-//~ TRANS_ITEM fn trait_method_default_impl::start[0]\n+//~ MONO_ITEM fn trait_method_default_impl::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, char>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, char>\n     let _ = 1i8.bar('c');\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, &str>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, &str>\n     let _ = 2i8.bar(\"&str\");\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i32, u64, char>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i32, u64, char>\n     0i32.bar(0u64, 'c');\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i32, u64, &str>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i32, u64, &str>\n     0i32.bar(0u64, \"&str\");\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i8, &[char; 1]>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i8, &[char; 1]>\n     0u32.bar(0i8, &['c']);\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i16, ()>\n+    //~ MONO_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i16, ()>\n     0u32.bar(0i16, ());\n \n     0"}, {"sha": "d20213c109bdb3d18664fef978b95b6fcc52d32e", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,21 +9,21 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue0[Internal]\n struct Root(Intermediate);\n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue0[Internal]\n struct Intermediate(Leaf);\n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue0[Internal]\n struct Leaf;\n \n impl Drop for Leaf {\n-    //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[0]::drop[0]\n+    //~ MONO_ITEM fn transitive_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n@@ -35,21 +35,21 @@ impl<T> Drop for LeafGen<T> {\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM fn transitive_drop_glue::start[0]\n+//~ MONO_ITEM fn transitive_drop_glue::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     let _ = Root(Intermediate(Leaf));\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n \n     0"}, {"sha": "9e4cc6ea6f08ebd51b72a3fd9494b3b9307929bc", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,28 +9,28 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue0[Internal]\n struct Dropped;\n \n impl Drop for Dropped {\n-    //~ TRANS_ITEM fn tuple_drop_glue::{{impl}}[0]::drop[0]\n+    //~ MONO_ITEM fn tuple_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM fn tuple_drop_glue::start[0]\n+//~ MONO_ITEM fn tuple_drop_glue::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue0[Internal]\n     let x = (0u32, Dropped);\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue0[Internal]\n     let x = (0i16, (Dropped, true));\n \n     0"}, {"sha": "c2ff846721c5f87584197f6bd1f8b99f88cea85c", "filename": "src/test/codegen-units/item-collection/unreferenced-const-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-const-fn.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-mono-items=lazy\n \n-// NB: We do not expect *any* translation item to be generated here.\n+// NB: We do not expect *any* monomorphization to be generated here.\n \n #![feature(const_fn)]\n #![deny(dead_code)]"}, {"sha": "829b4fbf3c92b70b96280e0580974fed1ecc6690", "filename": "src/test/codegen-units/item-collection/unreferenced-inline-function.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-inline-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-inline-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-inline-function.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-mono-items=lazy\n \n-// NB: We do not expect *any* translation item to be generated here.\n+// NB: We do not expect *any* monomorphization to be generated here.\n \n #![deny(dead_code)]\n #![crate_type = \"rlib\"]\n@@ -20,4 +20,3 @@\n pub fn foo() -> bool {\n     [1, 2] == [3, 4]\n }\n-"}, {"sha": "adc0eb6c709152f206b64fe3709ac5fba7b74360", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n // compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n@@ -54,19 +54,19 @@ struct Wrapper<T: ?Sized>(*const T);\n \n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n \n-//~ TRANS_ITEM fn unsizing::start[0]\n+//~ MONO_ITEM fn unsizing::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     // simple case\n     let bool_sized = &true;\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing0[Internal]\n-    //~ TRANS_ITEM fn unsizing::{{impl}}[0]::foo[0]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing0[Internal]\n+    //~ MONO_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n \n     let char_sized = &'a';\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing0[Internal]\n-    //~ TRANS_ITEM fn unsizing::{{impl}}[1]::foo[0]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing0[Internal]\n+    //~ MONO_ITEM fn unsizing::{{impl}}[1]::foo[0]\n     let _char_unsized = char_sized as &Trait;\n \n     // struct field\n@@ -75,14 +75,14 @@ fn start(_: isize, _: *const *const u8) -> isize {\n         _b: 2,\n         _c: 3.0f64\n     };\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing0[Internal]\n-    //~ TRANS_ITEM fn unsizing::{{impl}}[2]::foo[0]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing0[Internal]\n+    //~ MONO_ITEM fn unsizing::{{impl}}[2]::foo[0]\n     let _struct_unsized = struct_sized as &Struct<Trait>;\n \n     // custom coercion\n     let wrapper_sized = Wrapper(&0u32);\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing0[Internal]\n-    //~ TRANS_ITEM fn unsizing::{{impl}}[3]::foo[0]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing0[Internal]\n+    //~ MONO_ITEM fn unsizing::{{impl}}[3]::foo[0]\n     let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n \n     0"}, {"sha": "2edc7b211a1ba7e6338c1d061bb05418a0357cf8", "filename": "src/test/codegen-units/item-collection/unused-traits-and-generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-mono-items=eager\n \n #![crate_type=\"lib\"]\n #![deny(dead_code)]\n@@ -85,4 +85,4 @@ impl NonGeneric {\n }\n \n // Only the non-generic methods should be instantiated:\n-//~ TRANS_ITEM fn unused_traits_and_generics::{{impl}}[3]::foo[0]\n+//~ MONO_ITEM fn unused_traits_and_generics::{{impl}}[3]::foo[0]"}, {"sha": "cbad3a638840c4af1ca546de8fe6c57a15a3c4e6", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -12,7 +12,7 @@\n \n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/extern-drop-glue\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/extern-drop-glue\n // compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n@@ -21,14 +21,14 @@\n // aux-build:cgu_extern_drop_glue.rs\n extern crate cgu_extern_drop_glue;\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<cgu_extern_drop_glue::Struct[0]> @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<cgu_extern_drop_glue::Struct[0]> @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n \n struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n-//~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[External]\n+//~ MONO_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[External]\n pub fn user()\n {\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::LocalStruct[0]> @@ extern_drop_glue[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::LocalStruct[0]> @@ extern_drop_glue[Internal]\n     let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n }\n \n@@ -37,10 +37,10 @@ pub mod mod1 {\n \n     struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n-    //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[External]\n+    //~ MONO_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[External]\n     pub fn user()\n     {\n-        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::mod1[0]::LocalStruct[0]> @@ extern_drop_glue-mod1[Internal]\n+        //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::mod1[0]::LocalStruct[0]> @@ extern_drop_glue-mod1[Internal]\n         let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n     }\n }"}, {"sha": "a774376690a9742eda6058fd556e756f987c1b53", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,31 +11,31 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp/partitioning-tests/extern-generic -Zshare-generics=y\n+// compile-flags:-Zprint-mono-items=eager -Zincremental=tmp/partitioning-tests/extern-generic -Zshare-generics=y\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n // aux-build:cgu_generic_function.rs\n extern crate cgu_generic_function;\n \n-//~ TRANS_ITEM fn extern_generic::user[0] @@ extern_generic[Internal]\n+//~ MONO_ITEM fn extern_generic::user[0] @@ extern_generic[Internal]\n fn user() {\n     let _ = cgu_generic_function::foo(\"abc\");\n }\n \n mod mod1 {\n     use cgu_generic_function;\n \n-    //~ TRANS_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[Internal]\n+    //~ MONO_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[Internal]\n     fn user() {\n         let _ = cgu_generic_function::foo(\"abc\");\n     }\n \n     mod mod1 {\n         use cgu_generic_function;\n \n-        //~ TRANS_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[Internal]\n+        //~ MONO_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[Internal]\n         fn user() {\n             let _ = cgu_generic_function::foo(\"abc\");\n         }\n@@ -45,18 +45,18 @@ mod mod1 {\n mod mod2 {\n     use cgu_generic_function;\n \n-    //~ TRANS_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[Internal]\n+    //~ MONO_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[Internal]\n     fn user() {\n         let _ = cgu_generic_function::foo(\"abc\");\n     }\n }\n \n mod mod3 {\n-    //~ TRANS_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[Internal]\n+    //~ MONO_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[Internal]\n     fn non_user() {}\n }\n \n // Make sure the two generic functions from the extern crate get instantiated\n // once for the current crate\n-//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n-//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]\n+//~ MONO_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n+//~ MONO_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]"}, {"sha": "4136557d800449348588164add2329a2ab5a5779", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/inlining-from-extern-crate\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/inlining-from-extern-crate\n // compile-flags:-Zinline-in-all-cgus\n \n #![crate_type=\"lib\"]\n@@ -22,41 +22,41 @@ extern crate cgu_explicit_inlining;\n // This test makes sure that items inlined from external crates are privately\n // instantiated in every codegen unit they are used in.\n \n-//~ TRANS_ITEM fn cgu_explicit_inlining::inlined[0] @@ inlining_from_extern_crate[Internal] inlining_from_extern_crate-mod1[Internal]\n-//~ TRANS_ITEM fn cgu_explicit_inlining::always_inlined[0] @@ inlining_from_extern_crate[Internal] inlining_from_extern_crate-mod2[Internal]\n+//~ MONO_ITEM fn cgu_explicit_inlining::inlined[0] @@ inlining_from_extern_crate[Internal] inlining_from_extern_crate-mod1[Internal]\n+//~ MONO_ITEM fn cgu_explicit_inlining::always_inlined[0] @@ inlining_from_extern_crate[Internal] inlining_from_extern_crate-mod2[Internal]\n \n-//~ TRANS_ITEM fn inlining_from_extern_crate::user[0] @@ inlining_from_extern_crate[External]\n+//~ MONO_ITEM fn inlining_from_extern_crate::user[0] @@ inlining_from_extern_crate[External]\n pub fn user()\n {\n     cgu_explicit_inlining::inlined();\n     cgu_explicit_inlining::always_inlined();\n \n-    // does not generate a translation item in this crate\n+    // does not generate a monomorphization in this crate\n     cgu_explicit_inlining::never_inlined();\n }\n \n pub mod mod1 {\n     use cgu_explicit_inlining;\n \n-    //~ TRANS_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[External]\n+    //~ MONO_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[External]\n     pub fn user()\n     {\n         cgu_explicit_inlining::inlined();\n \n-        // does not generate a translation item in this crate\n+        // does not generate a monomorphization in this crate\n         cgu_explicit_inlining::never_inlined();\n     }\n }\n \n pub mod mod2 {\n     use cgu_explicit_inlining;\n \n-    //~ TRANS_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[External]\n+    //~ MONO_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[External]\n     pub fn user()\n     {\n         cgu_explicit_inlining::always_inlined();\n \n-        // does not generate a translation item in this crate\n+        // does not generate a monomorphization in this crate\n         cgu_explicit_inlining::never_inlined();\n     }\n }"}, {"sha": "98729d99ea95091d9743d69afb3bc35735b0605c", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,28 +11,28 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-drop-glue\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/local-drop-glue\n // compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n #![crate_type=\"rlib\"]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Struct[0]> @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Struct[0]> @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n struct Struct {\n     _a: u32\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[External]\n+    //~ MONO_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[External]\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Outer[0]> @@ local_drop_glue[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Outer[0]> @@ local_drop_glue[Internal]\n struct Outer {\n     _a: Struct\n }\n \n-//~ TRANS_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[External]\n+//~ MONO_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[External]\n pub fn user()\n {\n     let _ = Outer {\n@@ -46,14 +46,14 @@ pub mod mod1\n {\n     use super::Struct;\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::mod1[0]::Struct2[0]> @@ local_drop_glue-mod1[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::mod1[0]::Struct2[0]> @@ local_drop_glue-mod1[Internal]\n     struct Struct2 {\n         _a: Struct,\n-        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, local_drop_glue::Struct[0])> @@ local_drop_glue-mod1[Internal]\n+        //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, local_drop_glue::Struct[0])> @@ local_drop_glue-mod1[Internal]\n         _b: (u32, Struct),\n     }\n \n-    //~ TRANS_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[External]\n+    //~ MONO_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[External]\n     pub fn user()\n     {\n         let _ = Struct2 {"}, {"sha": "7c8ca20e1e3c082825a862ccf9186a59569f66c5", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,34 +11,34 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp/partitioning-tests/local-generic\n+// compile-flags:-Zprint-mono-items=eager -Zincremental=tmp/partitioning-tests/local-generic\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[External]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[External]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[External]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[External]\n+//~ MONO_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[External]\n+//~ MONO_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[External]\n+//~ MONO_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[External]\n+//~ MONO_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[External]\n pub fn generic<T>(x: T) -> T { x }\n \n-//~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[Internal]\n+//~ MONO_ITEM fn local_generic::user[0] @@ local_generic[Internal]\n fn user() {\n     let _ = generic(0u32);\n }\n \n mod mod1 {\n     pub use super::generic;\n \n-    //~ TRANS_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[Internal]\n+    //~ MONO_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[Internal]\n     fn user() {\n         let _ = generic(0u64);\n     }\n \n     mod mod1 {\n         use super::generic;\n \n-        //~ TRANS_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[Internal]\n+        //~ MONO_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[Internal]\n         fn user() {\n             let _ = generic('c');\n         }\n@@ -48,7 +48,7 @@ mod mod1 {\n mod mod2 {\n     use super::generic;\n \n-    //~ TRANS_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[Internal]\n+    //~ MONO_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[Internal]\n     fn user() {\n         let _ = generic(\"abc\");\n     }"}, {"sha": "747f768c11ff213ef128ce1f67df9230e1b30201", "filename": "src/test/codegen-units/partitioning/local-inlining-but-not-all.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining-but-not-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining-but-not-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining-but-not-all.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,15 +11,15 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-inlining-but-not-all\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/local-inlining-but-not-all\n // compile-flags:-Zinline-in-all-cgus=no\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n mod inline {\n \n-    //~ TRANS_ITEM fn local_inlining_but_not_all::inline[0]::inlined_function[0] @@ local_inlining_but_not_all-inline[External]\n+    //~ MONO_ITEM fn local_inlining_but_not_all::inline[0]::inlined_function[0] @@ local_inlining_but_not_all-inline[External]\n     #[inline]\n     pub fn inlined_function()\n     {\n@@ -30,7 +30,7 @@ mod inline {\n pub mod user1 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining_but_not_all::user1[0]::foo[0] @@ local_inlining_but_not_all-user1[External]\n+    //~ MONO_ITEM fn local_inlining_but_not_all::user1[0]::foo[0] @@ local_inlining_but_not_all-user1[External]\n     pub fn foo() {\n         inline::inlined_function();\n     }\n@@ -39,15 +39,15 @@ pub mod user1 {\n pub mod user2 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining_but_not_all::user2[0]::bar[0] @@ local_inlining_but_not_all-user2[External]\n+    //~ MONO_ITEM fn local_inlining_but_not_all::user2[0]::bar[0] @@ local_inlining_but_not_all-user2[External]\n     pub fn bar() {\n         inline::inlined_function();\n     }\n }\n \n pub mod non_user {\n \n-    //~ TRANS_ITEM fn local_inlining_but_not_all::non_user[0]::baz[0] @@ local_inlining_but_not_all-non_user[External]\n+    //~ MONO_ITEM fn local_inlining_but_not_all::non_user[0]::baz[0] @@ local_inlining_but_not_all-non_user[External]\n     pub fn baz() {\n \n     }"}, {"sha": "f144f0d992bf086bd3c24966545d065282261e95", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-inlining\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/local-inlining\n // compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n@@ -20,7 +20,7 @@\n mod inline {\n \n     // Important: This function should show up in all codegen units where it is inlined\n-    //~ TRANS_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-user1[Internal] local_inlining-user2[Internal]\n+    //~ MONO_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-user1[Internal] local_inlining-user2[Internal]\n     #[inline(always)]\n     pub fn inlined_function()\n     {\n@@ -31,7 +31,7 @@ mod inline {\n pub mod user1 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[External]\n+    //~ MONO_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[External]\n     pub fn foo() {\n         inline::inlined_function();\n     }\n@@ -40,15 +40,15 @@ pub mod user1 {\n pub mod user2 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[External]\n+    //~ MONO_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[External]\n     pub fn bar() {\n         inline::inlined_function();\n     }\n }\n \n pub mod non_user {\n \n-    //~ TRANS_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[External]\n+    //~ MONO_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[External]\n     pub fn baz() {\n \n     }"}, {"sha": "8637844a83d08a96f04b4ab1cfa12bee2390dafd", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,15 +11,15 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-transitive-inlining\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/local-transitive-inlining\n // compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n #![crate_type=\"rlib\"]\n \n mod inline {\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-indirect_user[Internal]\n+    //~ MONO_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-indirect_user[Internal]\n     #[inline(always)]\n     pub fn inlined_function()\n     {\n@@ -30,7 +30,7 @@ mod inline {\n mod direct_user {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-indirect_user[Internal]\n+    //~ MONO_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-indirect_user[Internal]\n     #[inline(always)]\n     pub fn foo() {\n         inline::inlined_function();\n@@ -40,15 +40,15 @@ mod direct_user {\n pub mod indirect_user {\n     use super::direct_user;\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[External]\n+    //~ MONO_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[External]\n     pub fn bar() {\n         direct_user::foo();\n     }\n }\n \n pub mod non_user {\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[External]\n+    //~ MONO_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[External]\n     pub fn baz() {\n \n     }"}, {"sha": "ff25a7194e0728e6f347ffea19cfb6a72e72b8f8", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -16,7 +16,7 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/methods-are-with-self-type\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/methods-are-with-self-type\n \n #![allow(dead_code)]\n #![feature(start)]\n@@ -31,10 +31,10 @@ mod mod1 {\n     // Even though the impl is in `mod1`, the methods should end up in the\n     // parent module, since that is where their self-type is.\n     impl SomeType {\n-        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::method[0] @@ methods_are_with_self_type[External]\n+        //~ MONO_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::method[0] @@ methods_are_with_self_type[External]\n         fn method(&self) {}\n \n-        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::associated_fn[0] @@ methods_are_with_self_type[External]\n+        //~ MONO_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::associated_fn[0] @@ methods_are_with_self_type[External]\n         fn associated_fn() {}\n     }\n \n@@ -64,25 +64,25 @@ mod type2 {\n     pub struct Struct;\n }\n \n-//~ TRANS_ITEM fn methods_are_with_self_type::start[0]\n+//~ MONO_ITEM fn methods_are_with_self_type::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n+    //~ MONO_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType(0u32, 0u64).method();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n+    //~ MONO_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType::associated_fn('c', \"&str\");\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    //~ MONO_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.foo();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    //~ MONO_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.foo();\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    //~ MONO_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.default();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    //~ MONO_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.default();\n \n     0\n }\n \n-//~ TRANS_ITEM drop-glue i8\n+//~ MONO_ITEM drop-glue i8"}, {"sha": "e1ec6f51b30b6648007b000f436330b836dbfa30", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,72 +11,72 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp/partitioning-tests/regular-modules\n+// compile-flags:-Zprint-mono-items=eager -Zincremental=tmp/partitioning-tests/regular-modules\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM fn regular_modules::foo[0] @@ regular_modules[Internal]\n+//~ MONO_ITEM fn regular_modules::foo[0] @@ regular_modules[Internal]\n fn foo() {}\n \n-//~ TRANS_ITEM fn regular_modules::bar[0] @@ regular_modules[Internal]\n+//~ MONO_ITEM fn regular_modules::bar[0] @@ regular_modules[Internal]\n fn bar() {}\n \n-//~ TRANS_ITEM static regular_modules::BAZ[0] @@ regular_modules[Internal]\n+//~ MONO_ITEM static regular_modules::BAZ[0] @@ regular_modules[Internal]\n static BAZ: u64 = 0;\n \n mod mod1 {\n \n-    //~ TRANS_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[Internal]\n+    //~ MONO_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[Internal]\n     fn foo() {}\n-    //~ TRANS_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[Internal]\n+    //~ MONO_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[Internal]\n     fn bar() {}\n-    //~ TRANS_ITEM static regular_modules::mod1[0]::BAZ[0] @@ regular_modules-mod1[Internal]\n+    //~ MONO_ITEM static regular_modules::mod1[0]::BAZ[0] @@ regular_modules-mod1[Internal]\n     static BAZ: u64 = 0;\n \n     mod mod1 {\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod1[0]::mod1[0]::BAZ[0] @@ regular_modules-mod1-mod1[Internal]\n+        //~ MONO_ITEM static regular_modules::mod1[0]::mod1[0]::BAZ[0] @@ regular_modules-mod1-mod1[Internal]\n         static BAZ: u64 = 0;\n     }\n \n     mod mod2 {\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod1[0]::mod2[0]::BAZ[0] @@ regular_modules-mod1-mod2[Internal]\n+        //~ MONO_ITEM static regular_modules::mod1[0]::mod2[0]::BAZ[0] @@ regular_modules-mod1-mod2[Internal]\n         static BAZ: u64 = 0;\n     }\n }\n \n mod mod2 {\n \n-    //~ TRANS_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[Internal]\n+    //~ MONO_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[Internal]\n     fn foo() {}\n-    //~ TRANS_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[Internal]\n+    //~ MONO_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[Internal]\n     fn bar() {}\n-    //~ TRANS_ITEM static regular_modules::mod2[0]::BAZ[0] @@ regular_modules-mod2[Internal]\n+    //~ MONO_ITEM static regular_modules::mod2[0]::BAZ[0] @@ regular_modules-mod2[Internal]\n     static BAZ: u64 = 0;\n \n     mod mod1 {\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod2[0]::mod1[0]::BAZ[0] @@ regular_modules-mod2-mod1[Internal]\n+        //~ MONO_ITEM static regular_modules::mod2[0]::mod1[0]::BAZ[0] @@ regular_modules-mod2-mod1[Internal]\n         static BAZ: u64 = 0;\n     }\n \n     mod mod2 {\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[Internal]\n+        //~ MONO_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod2[0]::mod2[0]::BAZ[0] @@ regular_modules-mod2-mod2[Internal]\n+        //~ MONO_ITEM static regular_modules::mod2[0]::mod2[0]::BAZ[0] @@ regular_modules-mod2-mod2[Internal]\n         static BAZ: u64 = 0;\n     }\n }"}, {"sha": "880361fac2ee03399270ffc5a46f1b260870daf8", "filename": "src/test/codegen-units/partitioning/shared-generics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,22 +9,22 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe\n+// compile-flags:-Zprint-mono-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe\n \n #![crate_type=\"rlib\"]\n \n // aux-build:shared_generics_aux.rs\n extern crate shared_generics_aux;\n \n-//~ TRANS_ITEM fn shared_generics::foo[0]\n+//~ MONO_ITEM fn shared_generics::foo[0]\n pub fn foo() {\n \n-    //~ TRANS_ITEM fn shared_generics_aux::generic_fn[0]<u16> @@ shared_generics_aux.volatile[External]\n+    //~ MONO_ITEM fn shared_generics_aux::generic_fn[0]<u16> @@ shared_generics_aux.volatile[External]\n     let _ = shared_generics_aux::generic_fn(0u16, 1u16);\n \n     // This should not generate a monomorphization because it's already\n     // available in `shared_generics_aux`.\n     let _ = shared_generics_aux::generic_fn(0.0f32, 3.0f32);\n }\n \n-// TRANS_ITEM drop-glue i8\n+// MONO_ITEM drop-glue i8"}, {"sha": "b6c1e5210daccfac7159958adfd39b2bf3980583", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,38 +11,38 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/statics\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/statics\n \n #![crate_type=\"rlib\"]\n \n-//~ TRANS_ITEM static statics::FOO[0] @@ statics[Internal]\n+//~ MONO_ITEM static statics::FOO[0] @@ statics[Internal]\n static FOO: u32 = 0;\n \n-//~ TRANS_ITEM static statics::BAR[0] @@ statics[Internal]\n+//~ MONO_ITEM static statics::BAR[0] @@ statics[Internal]\n static BAR: u32 = 0;\n \n-//~ TRANS_ITEM fn statics::function[0] @@ statics[External]\n+//~ MONO_ITEM fn statics::function[0] @@ statics[External]\n pub fn function() {\n-    //~ TRANS_ITEM static statics::function[0]::FOO[0] @@ statics[Internal]\n+    //~ MONO_ITEM static statics::function[0]::FOO[0] @@ statics[Internal]\n     static FOO: u32 = 0;\n \n-    //~ TRANS_ITEM static statics::function[0]::BAR[0] @@ statics[Internal]\n+    //~ MONO_ITEM static statics::function[0]::BAR[0] @@ statics[Internal]\n     static BAR: u32 = 0;\n }\n \n pub mod mod1 {\n-    //~ TRANS_ITEM static statics::mod1[0]::FOO[0] @@ statics-mod1[Internal]\n+    //~ MONO_ITEM static statics::mod1[0]::FOO[0] @@ statics-mod1[Internal]\n     static FOO: u32 = 0;\n \n-    //~ TRANS_ITEM static statics::mod1[0]::BAR[0] @@ statics-mod1[Internal]\n+    //~ MONO_ITEM static statics::mod1[0]::BAR[0] @@ statics-mod1[Internal]\n     static BAR: u32 = 0;\n \n-    //~ TRANS_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[External]\n+    //~ MONO_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[External]\n     pub fn function() {\n-        //~ TRANS_ITEM static statics::mod1[0]::function[0]::FOO[0] @@ statics-mod1[Internal]\n+        //~ MONO_ITEM static statics::mod1[0]::function[0]::FOO[0] @@ statics-mod1[Internal]\n         static FOO: u32 = 0;\n \n-        //~ TRANS_ITEM static statics::mod1[0]::function[0]::BAR[0] @@ statics-mod1[Internal]\n+        //~ MONO_ITEM static statics::mod1[0]::function[0]::BAR[0] @@ statics-mod1[Internal]\n         static BAR: u32 = 0;\n     }\n }"}, {"sha": "74533c1015b6062d1b20f523aca839b30966ff87", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -12,7 +12,7 @@\n \n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/vtable-through-const\n+// compile-flags:-Zprint-mono-items=lazy -Zincremental=tmp/partitioning-tests/vtable-through-const\n // compile-flags:-Zinline-in-all-cgus\n \n // This test case makes sure, that references made through constants are\n@@ -40,7 +40,7 @@ mod mod1 {\n \n     fn id<T>(x: T) -> T { x }\n \n-    // These are referenced, so they produce trans-items (see start())\n+    // These are referenced, so they produce mono-items (see start())\n     pub const TRAIT1_REF: &'static Trait1 = &0u32 as &Trait1;\n     pub const TRAIT1_GEN_REF: &'static Trait1Gen<u8> = &0u32 as &Trait1Gen<u8>;\n     pub const ID_CHAR: fn(char) -> char = id::<char>;\n@@ -64,34 +64,34 @@ mod mod1 {\n         fn do_something_else(&self, x: T) -> T { x }\n     }\n \n-    // These are not referenced, so they do not produce trans-items\n+    // These are not referenced, so they do not produce mono-items\n     pub const TRAIT2_REF: &'static Trait2 = &0u32 as &Trait2;\n     pub const TRAIT2_GEN_REF: &'static Trait2Gen<u8> = &0u32 as &Trait2Gen<u8>;\n     pub const ID_I64: fn(i64) -> i64 = id::<i64>;\n }\n \n-//~ TRANS_ITEM fn vtable_through_const::start[0]\n+//~ MONO_ITEM fn vtable_through_const::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ vtable_through_const[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ vtable_through_const[Internal]\n \n     // Since Trait1::do_something() is instantiated via its default implementation,\n     // it is considered a generic and is instantiated here only because it is\n     // referenced in this module.\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n+    //~ MONO_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n \n     // Although it is never used, Trait1::do_something_else() has to be\n     // instantiated locally here too, otherwise the <&u32 as &Trait1> vtable\n     // could not be fully constructed.\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n+    //~ MONO_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n     mod1::TRAIT1_REF.do_something();\n \n     // Same as above\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n+    //~ MONO_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n+    //~ MONO_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n     mod1::TRAIT1_GEN_REF.do_something(0u8);\n \n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const-mod1.volatile[External]\n+    //~ MONO_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const-mod1.volatile[External]\n     mod1::ID_CHAR('x');\n \n     0"}, {"sha": "f6a64bcba21c3a6b15f0ce0eeafa3dacc49350d0", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Zforce-overflow-checks=on\n \n-// these errors are not actually \"const_err\", they occur in trans/consts\n+// these errors are not actually \"const_err\", they occur in codegen/consts\n // and are unconditional warnings that can't be denied or allowed\n \n #![allow(exceeding_bitshifts)]"}, {"sha": "7b5db7a4f6db07923a9b71b0ee23114a20a6f0d9", "filename": "src/test/compile-fail/const-eval-overflow2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_imports)]\n \n // Note: the relevant lint pass here runs before some of the constant\n-// evaluation below (e.g. that performed by trans and llvm), so if you\n+// evaluation below (e.g. that performed by codegen and llvm), so if you\n // change this warn to a deny, then the compiler will exit before\n // those errors are detected.\n "}, {"sha": "ce4dc72555dc0172afcbe78078a113f23f90f17e", "filename": "src/test/compile-fail/const-eval-overflow2b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_imports)]\n \n // Note: the relevant lint pass here runs before some of the constant\n-// evaluation below (e.g. that performed by trans and llvm), so if you\n+// evaluation below (e.g. that performed by codegen and llvm), so if you\n // change this warn to a deny, then the compiler will exit before\n // those errors are detected.\n "}, {"sha": "88eb14a133019a33659cd2d699396ce7f8c376e7", "filename": "src/test/compile-fail/const-eval-overflow2c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_imports)]\n \n // Note: the relevant lint pass here runs before some of the constant\n-// evaluation below (e.g. that performed by trans and llvm), so if you\n+// evaluation below (e.g. that performed by codegen and llvm), so if you\n // change this warn to a deny, then the compiler will exit before\n // those errors are detected.\n "}, {"sha": "c20cfbc7e232cf614f79693e906475c5dc57a333", "filename": "src/test/compile-fail/dep-graph-assoc-type-codegen.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-codegen.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -39,7 +39,7 @@ mod y {\n     pub fn use_char_assoc() {\n         // Careful here: in the representation, <char as Foo>::T gets\n         // normalized away, so at a certain point we had no edge to\n-        // trans.  (But now trans just depends on typeck.)\n+        // codegen.  (But now codegen just depends on typeck.)\n         let x: <char as Foo>::T = 'a';\n     }\n ", "previous_filename": "src/test/compile-fail/dep-graph-assoc-type-trans.rs"}, {"sha": "ab935a07d650fc3164fa47edd1673b35d8b4e3ea", "filename": "src/test/debuginfo/struct-with-destructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -91,7 +91,7 @@ struct NestedOuter {\n \n \n // The compiler adds a 'destructed' boolean field to structs implementing Drop. This field is used\n-// at runtime to prevent drop() to be executed more than once (see middle::trans::adt).\n+// at runtime to prevent drop() to be executed more than once.\n // This field must be incorporated by the debug info generation. Otherwise the debugger assumes a\n // wrong size/layout for the struct.\n fn main() {"}, {"sha": "9aeb3bc91336a67b17f9b6f4eb8a790c254fa034", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -72,7 +72,7 @@ fn main() {\n     let constant2 = 6_usize;\n \n     // The `self` argument of the following closure should be passed by value\n-    // to FnOnce::call_once(self, args), which gets translated a bit differently\n+    // to FnOnce::call_once(self, args), which gets codegened a bit differently\n     // than the regular case. Let's make sure this is supported too.\n     let immedate_env = move || {\n         zzz(); // #break"}, {"sha": "02ee06b4cf445c4a6122d791d6e40b924ca8fc31", "filename": "src/test/incremental/cache_file_headers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcache_file_headers.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -13,7 +13,7 @@\n // different compiler version. This is tested by artificially forcing the\n // emission of a different compiler version in the header of rpass1 artifacts,\n // and then making sure that the only object file of the test program gets\n-// re-translated although the program stays unchanged.\n+// re-codegened although the program stays unchanged.\n \n // The `l33t haxx0r` Rust compiler is known to produce incr. comp. artifacts\n // that are outrageously incompatible with just about anything, even itself:\n@@ -23,7 +23,7 @@\n // compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n-#![rustc_partition_translated(module=\"cache_file_headers\", cfg=\"rpass2\")]\n+#![rustc_partition_codegened(module=\"cache_file_headers\", cfg=\"rpass2\")]\n \n fn main() {\n     // empty"}, {"sha": "37d1a397303b6f9aa88ba1f657e2940cc0c8f869", "filename": "src/test/incremental/change_add_field/struct_point.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -22,14 +22,14 @@\n #![allow(dead_code)]\n #![crate_type = \"rlib\"]\n \n-// These are expected to require translation.\n-#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_with_type_in_sig\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-call_fn_with_type_in_sig\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_with_type_in_body\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_read_field\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_write_field\", cfg=\"cfail2\")]\n+// These are expected to require codegen.\n+#![rustc_partition_codegened(module=\"struct_point-point\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-fn_with_type_in_sig\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-call_fn_with_type_in_sig\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-fn_with_type_in_body\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-fn_make_struct\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-fn_read_field\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-fn_write_field\", cfg=\"cfail2\")]\n \n #![rustc_partition_reused(module=\"struct_point-call_fn_with_type_in_body\", cfg=\"cfail2\")]\n "}, {"sha": "d1b8399dbdae537a0efa67ee64a2ea952e186e4a", "filename": "src/test/incremental/change_private_fn/struct_point.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -20,7 +20,7 @@\n #![allow(dead_code)]\n #![crate_type = \"rlib\"]\n \n-#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-point\", cfg=\"cfail2\")]\n \n #![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"cfail2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"cfail2\")]"}, {"sha": "cf6eefd61d70a8b2423ff5a24c67882e6afeb9cd", "filename": "src/test/incremental/change_private_impl_method/struct_point.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -20,7 +20,7 @@\n #![allow(dead_code)]\n #![crate_type = \"rlib\"]\n \n-#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-point\", cfg=\"cfail2\")]\n \n #![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"cfail2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"cfail2\")]"}, {"sha": "a204fe27da6bb97adca900eed769f53dbce2f315", "filename": "src/test/incremental/change_pub_inherent_method_body/struct_point.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -19,7 +19,7 @@\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]\n \n-#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-point\", cfg=\"cfail2\")]\n \n #![rustc_partition_reused(module=\"struct_point-fn_calls_changed_method\", cfg=\"cfail2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_calls_another_method\", cfg=\"cfail2\")]"}, {"sha": "76c9dfce93d227431d19888e8f08bae0fa296e02", "filename": "src/test/incremental/change_pub_inherent_method_sig/struct_point.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -19,9 +19,9 @@\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]\n \n-// These are expected to require translation.\n-#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_changed_method\", cfg=\"cfail2\")]\n+// These are expected to require codegen.\n+#![rustc_partition_codegened(module=\"struct_point-point\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"struct_point-fn_calls_changed_method\", cfg=\"cfail2\")]\n \n #![rustc_partition_reused(module=\"struct_point-fn_calls_another_method\", cfg=\"cfail2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"cfail2\")]"}, {"sha": "feb8026f501a871c113cd32b46038b2be9df8550", "filename": "src/test/incremental/change_symbol_export_status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -14,7 +14,7 @@\n #![feature(rustc_attrs)]\n #![allow(private_no_mangle_fns)]\n \n-#![rustc_partition_translated(module=\"change_symbol_export_status-mod1\", cfg=\"rpass2\")]\n+#![rustc_partition_codegened(module=\"change_symbol_export_status-mod1\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"change_symbol_export_status-mod2\", cfg=\"rpass2\")]\n \n // This test case makes sure that a change in symbol visibility is detected by"}, {"sha": "bb2f385e9c5f733048b7215c996d27155e4bc8ff", "filename": "src/test/incremental/commandline-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcommandline-args.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -16,7 +16,7 @@\n \n #![feature(rustc_attrs)]\n \n-#![rustc_partition_translated(module=\"commandline_args\", cfg=\"rpass2\")]\n+#![rustc_partition_codegened(module=\"commandline_args\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"commandline_args\", cfg=\"rpass3\")]\n \n // Between revisions 1 and 2, we are changing the debuginfo-level, which should"}, {"sha": "baf4ae739325de79c2be25b6d9ed14c06a9e0d82", "filename": "src/test/incremental/inlined_hir_34991/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n // Regression test for #34991: an ICE occurred here because we inline\n // some of the vector routines and give them a local def-id `X`. This\n-// got hashed after trans (`Hir(X)`). When we load back up, we get an\n+// got hashed after codegen (`Hir(X)`). When we load back up, we get an\n // error because the `X` is remapped to the original def-id (in\n // libstd), and we can't hash a HIR node from std.\n "}, {"sha": "a19de6ef6360489f10010fae1eafc309cc5293fa", "filename": "src/test/incremental/issue-38222.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fissue-38222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fissue-38222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-38222.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -20,7 +20,7 @@\n \n #![rustc_partition_reused(module=\"issue_38222-mod1\", cfg=\"rpass2\")]\n \n-// If trans had added a dependency edge to the Krate dep-node, nothing would\n+// If codegen had added a dependency edge to the Krate dep-node, nothing would\n // be re-used, so checking that this module was re-used is sufficient.\n #![rustc_partition_reused(module=\"issue_38222\", cfg=\"rpass2\")]\n "}, {"sha": "dfa92d425f4362b4e7234ebc9c44b80c4890d101", "filename": "src/test/incremental/issue-49595/issue_49595.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -15,8 +15,8 @@\n #![feature(rustc_attrs)]\n #![crate_type = \"rlib\"]\n \n-#![rustc_partition_translated(module=\"issue_49595-tests\", cfg=\"cfail2\")]\n-#![rustc_partition_translated(module=\"issue_49595-lit_test\", cfg=\"cfail3\")]\n+#![rustc_partition_codegened(module=\"issue_49595-tests\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"issue_49595-lit_test\", cfg=\"cfail3\")]\n \n mod tests {\n     #[cfg_attr(not(cfail1), ignore)]"}, {"sha": "cd66310dafeff07e7d036b1202ea938c8208eb97", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -20,7 +20,7 @@\n #![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"main-some_mod\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"main\", cfg=\"rpass3\")]\n-#![rustc_partition_translated(module=\"main-some_mod\", cfg=\"rpass3\")]\n+#![rustc_partition_codegened(module=\"main-some_mod\", cfg=\"rpass3\")]\n \n extern crate extern_crate;\n "}, {"sha": "d4701b9a66eb43f297315ad0f719a4b80d419866", "filename": "src/test/incremental/spike-neg1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fspike-neg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fspike-neg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike-neg1.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // A variant of the first \"spike\" test that serves to test the\n-// `rustc_partition_reused` and `rustc_partition_translated` tests.\n+// `rustc_partition_reused` and `rustc_partition_codegened` tests.\n // Here we change and say that the `x` module will be reused (when in\n // fact it will not), and then indicate that the test itself\n // should-fail (because an error will be reported, and hence the"}, {"sha": "da79237b1a6494347a1a171f403a980d9c89cc5c", "filename": "src/test/incremental/spike-neg2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fspike-neg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fspike-neg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike-neg2.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // A variant of the first \"spike\" test that serves to test the\n-// `rustc_partition_reused` and `rustc_partition_translated` tests.\n-// Here we change and say that the `y` module will be translated (when\n+// `rustc_partition_reused` and `rustc_partition_codegened` tests.\n+// Here we change and say that the `y` module will be codegened (when\n // in fact it will not), and then indicate that the test itself\n // should-fail (because an error will be reported, and hence the\n // revision rpass2 will not compile, despite being named rpass).\n@@ -21,8 +21,8 @@\n #![feature(rustc_attrs)]\n \n #![rustc_partition_reused(module=\"spike_neg2\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"spike_neg2-x\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"spike_neg2-y\", cfg=\"rpass2\")] // this is wrong!\n+#![rustc_partition_codegened(module=\"spike_neg2-x\", cfg=\"rpass2\")]\n+#![rustc_partition_codegened(module=\"spike_neg2-y\", cfg=\"rpass2\")] // this is wrong!\n \n mod x {\n     pub struct X {"}, {"sha": "1756511dd370647716d5d723a9b3b2361aa8017f", "filename": "src/test/incremental/spike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fspike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Fincremental%2Fspike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -18,7 +18,7 @@\n #![feature(rustc_attrs)]\n \n #![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+#![rustc_partition_codegened(module=\"spike-x\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"spike-y\", cfg=\"rpass2\")]\n \n mod x {"}, {"sha": "9c851eb7346bb295bedfc10fc41fb88980d52cfd", "filename": "src/test/run-fail/mir_codegen_calls_converging_drops.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_converging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_converging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_converging_drops.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-fail/mir_trans_calls_converging_drops.rs"}, {"sha": "6f10521155648a8e83fe5f34caa721d34e9191ed", "filename": "src/test/run-fail/mir_codegen_calls_converging_drops_2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_converging_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_converging_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_converging_drops_2.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-fail/mir_trans_calls_converging_drops_2.rs"}, {"sha": "9dbf7de0d2d4988d6a9dc0e5c01641107a3b66e2", "filename": "src/test/run-fail/mir_codegen_calls_diverging.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_diverging.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-fail/mir_trans_calls_diverging.rs"}, {"sha": "f8fbe8f79cc622bd8068a4c00d2e056354019898", "filename": "src/test/run-fail/mir_codegen_calls_diverging_drops.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_diverging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_diverging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_codegen_calls_diverging_drops.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-fail/mir_trans_calls_diverging_drops.rs"}, {"sha": "aded2739b10d1edcec569f91d35ce6a762d7df74", "filename": "src/test/run-fail/mir_codegen_no_landing_pads.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_no_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_no_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_codegen_no_landing_pads.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-fail/mir_trans_no_landing_pads.rs"}, {"sha": "d3a8613bbc4bf033e4fe5f995a0561fe486289f6", "filename": "src/test/run-fail/mir_codegen_no_landing_pads_diverging.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_no_landing_pads_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Fmir_codegen_no_landing_pads_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_codegen_no_landing_pads_diverging.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-fail/mir_trans_no_landing_pads_diverging.rs"}, {"sha": "572b56d02ae994bf60aa91790b48ac631e7600d9", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that trans treats the rhs of pth's decl\n+// Tests that codegen treats the rhs of pth's decl\n // as a _|_-typed thing, not a str-typed thing\n // error-pattern:bye\n "}, {"sha": "251fb78a98588160459802a01f4704329a72481b", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -12,7 +12,7 @@\n \n extern crate syntax;\n extern crate rustc;\n-extern crate rustc_trans_utils;\n+extern crate rustc_codegen_utils;\n \n use std::any::Any;\n use std::sync::mpsc;\n@@ -23,11 +23,11 @@ use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n-use rustc_trans_utils::trans_crate::{TransCrate, MetadataOnlyTransCrate};\n+use rustc_codegen_utils::codegen_backend::{CodegenBackend, MetadataOnlyCodegenBackend};\n \n-struct TheBackend(Box<TransCrate>);\n+struct TheBackend(Box<CodegenBackend>);\n \n-impl TransCrate for TheBackend {\n+impl CodegenBackend for TheBackend {\n     fn metadata_loader(&self) -> Box<MetadataLoader + Sync> {\n         self.0.metadata_loader()\n     }\n@@ -40,7 +40,7 @@ impl TransCrate for TheBackend {\n         self.0.provide_extern(providers);\n     }\n \n-    fn trans_crate<'a, 'tcx>(\n+    fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n@@ -50,18 +50,18 @@ impl TransCrate for TheBackend {\n         Box::new(tcx.crate_name(LOCAL_CRATE) as Symbol)\n     }\n \n-    fn join_trans_and_link(\n+    fn join_codegen_and_link(\n         &self,\n-        trans: Box<Any>,\n+        ongoing_codegen: Box<Any>,\n         sess: &Session,\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete> {\n         use std::io::Write;\n         use rustc::session::config::CrateType;\n-        use rustc_trans_utils::link::out_filename;\n-        let crate_name = trans.downcast::<Symbol>()\n-            .expect(\"in join_trans_and_link: trans is not a Symbol\");\n+        use rustc_codegen_utils::link::out_filename;\n+        let crate_name = ongoing_codegen.downcast::<Symbol>()\n+            .expect(\"in join_codegen_and_link: ongoing_codegen is not a Symbol\");\n         for &crate_type in sess.opts.crate_types.iter() {\n             if crate_type != CrateType::CrateTypeExecutable {\n                 sess.fatal(&format!(\"Crate type is {:?}\", crate_type));\n@@ -75,8 +75,8 @@ impl TransCrate for TheBackend {\n     }\n }\n \n-/// This is the entrypoint for a hot plugged rustc_trans\n+/// This is the entrypoint for a hot plugged rustc_codegen_llvm\n #[no_mangle]\n-pub fn __rustc_codegen_backend() -> Box<TransCrate> {\n-    Box::new(TheBackend(MetadataOnlyTransCrate::new()))\n+pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n+    Box::new(TheBackend(MetadataOnlyCodegenBackend::new()))\n }"}, {"sha": "403f4f79843e8c93020e5bad461a50d21712b55e", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -15,7 +15,7 @@ extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n-extern crate rustc_trans_utils;\n+extern crate rustc_codegen_utils;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n@@ -25,7 +25,7 @@ use rustc_driver::driver::{compile_input, CompileController};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n use syntax::codemap::FileName;\n-use rustc_trans_utils::trans_crate::TransCrate;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -52,7 +52,7 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<TransCrate>) {\n+fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<CodegenBackend>) {\n     let mut opts = basic_options();\n     opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n     opts.maybe_sysroot = Some(sysroot);\n@@ -62,19 +62,19 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<TransCrate>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n+    let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+    let cstore = Rc::new(CStore::new(codegen_backend.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    (sess, cstore, trans)\n+    (sess, cstore, codegen_backend)\n }\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     syntax::with_globals(|| {\n-        let (sess, cstore, trans) = basic_sess(sysroot);\n+        let (sess, cstore, codegen_backend) = basic_sess(sysroot);\n         let control = CompileController::basic();\n         let input = Input::Str { name: FileName::Anon, input: code };\n         let _ = compile_input(\n-            trans,\n+            codegen_backend,\n             &sess,\n             &cstore,\n             &None,"}, {"sha": "9658b99e3b0c32ecc8743807f40ffabcb2bdf73a", "filename": "src/test/run-make-fulldeps/issue-7349/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-make-fulldeps%2Fissue-7349%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-make-fulldeps%2Fissue-7349%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-7349%2FMakefile?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n # Test to make sure that inner functions within a polymorphic outer function\n-# don't get re-translated when the outer function is monomorphized.  The test\n+# don't get re-codegened when the outer function is monomorphized.  The test\n # code monomorphizes the outer functions several times, but the magic constants\n # used in the inner functions should each appear only once in the generated IR.\n "}, {"sha": "9aa4f42c8ac86b2d71048801d723b990de5ed811", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -18,15 +18,15 @@\n extern crate getopts;\n extern crate rustc;\n extern crate rustc_driver;\n-extern crate rustc_trans_utils;\n+extern crate rustc_codegen_utils;\n extern crate syntax;\n extern crate rustc_errors as errors;\n \n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n-use rustc_trans_utils::trans_crate::TransCrate;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use syntax::ast;\n \n use std::path::PathBuf;\n@@ -48,7 +48,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     }\n \n     fn late_callback(&mut self,\n-                     _: &TransCrate,\n+                     _: &CodegenBackend,\n                      _: &getopts::Matches,\n                      _: &Session,\n                      _: &CrateStore,"}, {"sha": "40f352e2e1f71fd5be21aebb3a9c764652addb03", "filename": "src/test/run-pass/associated-types-region-erasure-issue-20582.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fassociated-types-region-erasure-issue-20582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fassociated-types-region-erasure-issue-20582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-region-erasure-issue-20582.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Regression test for #20582. This test caused an ICE related to\n-// inconsistent region erasure in trans.\n+// inconsistent region erasure in codegen.\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "2f33eb9ca40932fb32c244c18fa95dbf0903fd1c", "filename": "src/test/run-pass/atomic-compare_exchange.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -15,7 +15,7 @@ use std::sync::atomic::Ordering::*;\n static ATOMIC: AtomicIsize = ATOMIC_ISIZE_INIT;\n \n fn main() {\n-    // Make sure trans can emit all the intrinsics correctly\n+    // Make sure codegen can emit all the intrinsics correctly\n     ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n     ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n     ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();"}, {"sha": "5fbfef05e10d4f321b14f8f891c31d58e15faa24", "filename": "src/test/run-pass/codegen-object-shim.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fcodegen-object-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fcodegen-object-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcodegen-object-shim.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/trans-object-shim.rs"}, {"sha": "ba01d51dc6a5d8b0e14e62693ba5986afc6df5fe", "filename": "src/test/run-pass/codegen-tag-static-padding.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fcodegen-tag-static-padding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fcodegen-tag-static-padding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcodegen-tag-static-padding.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/trans-tag-static-padding.rs"}, {"sha": "d318b8fa44bc62ab2fa4ec488b7a0e864e14b37a", "filename": "src/test/run-pass/compiletest-skip-codegen.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fcompiletest-skip-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fcompiletest-skip-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompiletest-skip-codegen.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that with the `skip-trans` option the test isn't executed.\n+// Test that with the `skip-codegen` option the test isn't executed.\n \n-// skip-trans\n+// skip-codegen\n \n fn main() {\n     unreachable!();", "previous_filename": "src/test/run-pass/compiletest-skip-trans.rs"}, {"sha": "01bdcfeaefb45c6b5aacf4c152380c365fb8e4e0", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -22,7 +22,7 @@ mod rustrt {\n     #[cfg(bogus)]\n     extern {\n         // This symbol doesn't exist and would be a link error if this\n-        // module was translated\n+        // module was codegened\n         pub fn bogus();\n     }\n "}, {"sha": "797b3197182170cb1915db4ec239e398aa3c57cd", "filename": "src/test/run-pass/issue-18425.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18425.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that trans doesn't ICE when translating an array repeat\n+// Check that codegen doesn't ICE when codegenning an array repeat\n // expression with a count of 1 and a non-Copy element type.\n \n // pretty-expanded FIXME #23616"}, {"sha": "f8bebb4a40beb79bcf449e049ce0ae4165305786", "filename": "src/test/run-pass/issue-18514.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18514.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we don't ICE when translating a generic impl method from\n+// Test that we don't ICE when codegenning a generic impl method from\n // an extern crate that contains a match expression on a local\n // variable place where one of the match case bodies contains an\n // expression that autoderefs through an overloaded generic deref"}, {"sha": "1eddc34f5b17fdf8712e9cf2dd060a0edc5beea8", "filename": "src/test/run-pass/issue-18652.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18652.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18652.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18652.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Tests multiple free variables being passed by value into an unboxed\n-// once closure as an optimization by trans.  This used to hit an\n+// once closure as an optimization by codegen.  This used to hit an\n // incorrect assert.\n \n fn main() {"}, {"sha": "4287f449c6fd09be8ca7adb746ed0946d94c9fca", "filename": "src/test/run-pass/issue-18661.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18661.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-18661.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18661.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Test that param substitutions from the correct environment are\n-// used when translating unboxed closure calls.\n+// used when codegenning unboxed closure calls.\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "65a67d0b41a722956a7d64e0c0264de05fc8108b", "filename": "src/test/run-pass/issue-20644.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20644.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // A reduced version of the rustbook ice. The problem this encountered\n-// had to do with trans ignoring binders.\n+// had to do with codegen ignoring binders.\n \n // pretty-expanded FIXME #23616\n // ignore-cloudabi no std::fs"}, {"sha": "b15ec2986c236f057fb1d885bf2048322b207fab", "filename": "src/test/run-pass/issue-24085.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-24085.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-24085.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24085.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n // Regression test for #24085. Errors were occurring in region\n // inference due to the requirement that `'a:b'`, which was getting\n-// incorrectly translated in connection with the closure below.\n+// incorrectly codegened in connection with the closure below.\n \n #[derive(Copy,Clone)]\n struct Path<'a:'b, 'b> {"}, {"sha": "5c7c5a2b3b96fbe163e953fca3e45e3e4edd68bc", "filename": "src/test/run-pass/issue-34569.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-34569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-34569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34569.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -12,7 +12,7 @@\n \n // In this test we just want to make sure that the code below does not lead to\n // a debuginfo verification assertion during compilation. This was caused by the\n-// closure in the guard being translated twice due to how match expressions are\n+// closure in the guard being codegened twice due to how match expressions are\n // handled.\n //\n // See https://github.com/rust-lang/rust/issues/34569 for details."}, {"sha": "2694c98dd9163b6984589aa46ee7fa4bbcb7d54f", "filename": "src/test/run-pass/issue-36381.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-36381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-36381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36381.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Regression test for #36381. The trans collector was asserting that\n+// Regression test for #36381. The monomorphization collector was asserting that\n // there are no projection types, but the `<&str as\n // StreamOnce>::Position` projection contained a late-bound region,\n // and we don't currently normalize in that case until the function is"}, {"sha": "4eb381b9eac27a6dcc7dfdcfbf15632eb5f670aa", "filename": "src/test/run-pass/issue-38002.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-38002.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-38002.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38002.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that constant ADTs are translated OK, part k of N.\n+// Check that constant ADTs are codegened OK, part k of N.\n \n enum Bar {\n     C"}, {"sha": "9bd13c4d3a0f4317e792d2f3cbc3664aa5d5bc7a", "filename": "src/test/run-pass/issue-5243.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-5243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue-5243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5243.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Check that merely having lifetime parameters is not\n-// enough for trans to consider this as non-monomorphic,\n+// enough for codegen to consider this as non-monomorphic,\n // which led to various assertions and failures in turn.\n \n // pretty-expanded FIXME #23616"}, {"sha": "abec252c74e5d3a74423883816be087143991f85", "filename": "src/test/run-pass/issue24687-embed-debuginfo/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue24687-embed-debuginfo%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fissue24687-embed-debuginfo%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue24687-embed-debuginfo%2Fmain.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -14,7 +14,7 @@\n extern crate issue24687_lib as d;\n \n fn main() {\n-    // Create a d, which has a destructor whose body will be trans'ed\n+    // Create a d, which has a destructor whose body will be codegen'ed\n     // into the generated code here, and thus the local debuginfo will\n     // need references into the original source locations from\n     // `importer` above."}, {"sha": "82d747b6c27a1e6ae9485a2a978cc9794cefab04", "filename": "src/test/run-pass/method-two-trait-defer-resolution-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -16,7 +16,7 @@\n // whether `_1: MyCopy` or `_1 == Box<i32>`.  However (and this is the\n // point of the test), we don't have to pick between the two impls --\n // it is enough to know that `foo` comes from the `Foo` trait. We can\n-// translate the call as `Foo::foo(&x)` and let the specific impl get\n+// codegen the call as `Foo::foo(&x)` and let the specific impl get\n // chosen later.\n \n "}, {"sha": "b7f247012ce129da0bb7f694698a792d31ff0bd5", "filename": "src/test/run-pass/mir_codegen_array.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_array.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_array.rs"}, {"sha": "c7133fb0c0e4923b5447bc4732fb3b8b72579dd2", "filename": "src/test/run-pass/mir_codegen_array_2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_array_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_array_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_array_2.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_array_2.rs"}, {"sha": "7d420bb86c6077968714deba37f25d3cede35739", "filename": "src/test/run-pass/mir_codegen_call_converging.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_call_converging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_call_converging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_call_converging.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_call_converging.rs"}, {"sha": "d02e3287bc38a0e123dbda9c9703e0e1c871cb03", "filename": "src/test/run-pass/mir_codegen_calls.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_calls.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_calls.rs"}, {"sha": "7845c9426e23b2d45d86ddd401d7dd8c070ea3a8", "filename": "src/test/run-pass/mir_codegen_calls_variadic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_calls_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_calls_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_calls_variadic.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_calls_variadic.rs"}, {"sha": "c742e71633fc5cf6190e8a1a608d1c99fc1c0f87", "filename": "src/test/run-pass/mir_codegen_critical_edge.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_critical_edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_critical_edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_critical_edge.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -44,7 +44,7 @@ where A: Iterator, B: Iterator<Item=A::Item>\n     }\n }\n \n-// Make sure we actually translate a version of the function\n+// Make sure we actually codegen a version of the function\n pub fn do_stuff(mut f: Foo<Box<Iterator<Item=u32>>, Box<Iterator<Item=u32>>>) {\n     let _x = f.next();\n }", "previous_filename": "src/test/run-pass/mir_trans_critical_edge.rs"}, {"sha": "27e1583af34ac0ad763cbeadf5f67cf2ed750cac", "filename": "src/test/run-pass/mir_codegen_spike1.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_spike1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_spike1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_spike1.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// A simple spike test for MIR version of trans.\n+// A simple spike test for MIR version of codegen.\n \n fn sum(x: i32, y: i32) -> i32 {\n     x + y", "previous_filename": "src/test/run-pass/mir_trans_spike1.rs"}, {"sha": "b097bf46ad3708210eebf151ad60077439553971", "filename": "src/test/run-pass/mir_codegen_switch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_switch.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_switch.rs"}, {"sha": "537734596a5214f42de7ba2b8b94cd5e8b486a2b", "filename": "src/test/run-pass/mir_codegen_switchint.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_switchint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_codegen_switchint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_codegen_switchint.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/mir_trans_switchint.rs"}, {"sha": "a2cfca01dacb37304ed48e337cde880b1d70f6dd", "filename": "src/test/run-pass/mir_overflow_off.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_overflow_off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fmir_overflow_off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_overflow_off.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z force-overflow-checks=off\n \n-// Test that with MIR trans, overflow checks can be\n+// Test that with MIR codegen, overflow checks can be\n // turned off, even when they're from core::ops::*.\n \n use std::ops::*;"}, {"sha": "778f355b24b895d3c1e0ca0573821e1f52513702", "filename": "src/test/run-pass/pattern-bound-var-in-for-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that trans_path checks whether a\n-// pattern-bound var is an upvar (when translating\n+// Tests that codegen_path checks whether a\n+// pattern-bound var is an upvar (when codegenning\n // the for-each body)\n \n "}, {"sha": "60a7f70931d48baf6bd17232fee5c4003d2f80aa", "filename": "src/test/run-pass/regions-mock-codegen.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/regions-mock-trans.rs"}, {"sha": "4fea07028b6148b4cc0a7d4c6ba8bb81ec51c2cc", "filename": "src/test/run-pass/sepcomp-fns-backwards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fsepcomp-fns-backwards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fsepcomp-fns-backwards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-fns-backwards.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -11,7 +11,7 @@\n // ignore-bitrig\n // compile-flags: -C codegen-units=3\n \n-// Test references to items that haven't been translated yet.\n+// Test references to items that haven't been codegened yet.\n \n // Generate some code in the first compilation unit before declaring any\n // modules.  This ensures that the first module doesn't go into the same"}, {"sha": "d2283da8bdd8a2c64a71454275840a99468eaf5b", "filename": "src/test/run-pass/small-enum-range-edge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -13,7 +13,7 @@\n #![feature(core)]\n \n /*!\n- * Tests the range assertion wraparound case in trans::middle::adt::load_discr.\n+ * Tests the range assertion wraparound case when reading discriminants.\n  */\n \n #[repr(u8)]"}, {"sha": "77270364bb5e969ff480721a7409dd6ec0915c4d", "filename": "src/test/run-pass/union/union-const-codegen.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Funion%2Funion-const-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Funion%2Funion-const-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-const-codegen.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "previous_filename": "src/test/run-pass/union/union-const-trans.rs"}, {"sha": "9625d6a88ac3c96463b7a8a3a863991b22800942", "filename": "src/test/run-pass/zero-sized-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fzero-sized-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftest%2Frun-pass%2Fzero-sized-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero-sized-tuple-struct.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(unused_assignments)]\n \n-// Make sure that the constructor args are translated for zero-sized tuple structs\n+// Make sure that the constructor args are codegened for zero-sized tuple structs\n \n struct Foo(());\n "}, {"sha": "f66f5c5b70e7ed38c213989043b456ceb19f397a", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -224,7 +224,7 @@ pub struct TestProps {\n     // The test must be compiled and run successfully. Only used in UI tests for now.\n     pub run_pass: bool,\n     // Skip any codegen step and running the executable. Only for run-pass.\n-    pub skip_trans: bool,\n+    pub skip_codegen: bool,\n     // Do not pass `-Z ui-testing` to UI tests\n     pub disable_ui_testing_normalization: bool,\n     // customized normalization rules\n@@ -258,7 +258,7 @@ impl TestProps {\n             compile_pass: false,\n             check_test_line_numbers_match: false,\n             run_pass: false,\n-            skip_trans: false,\n+            skip_codegen: false,\n             disable_ui_testing_normalization: false,\n             normalize_stdout: vec![],\n             normalize_stderr: vec![],\n@@ -371,8 +371,8 @@ impl TestProps {\n                 self.compile_pass = config.parse_compile_pass(ln) || self.run_pass;\n             }\n \n-                        if !self.skip_trans {\n-                            self.skip_trans = config.parse_skip_trans(ln);\n+                        if !self.skip_codegen {\n+                            self.skip_codegen = config.parse_skip_codegen(ln);\n                         }\n \n             if !self.disable_ui_testing_normalization {\n@@ -532,8 +532,8 @@ impl Config {\n         self.parse_name_directive(line, \"run-pass\")\n     }\n \n-    fn parse_skip_trans(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"skip-trans\")\n+    fn parse_skip_codegen(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"skip-codegen\")\n     }\n \n     fn parse_env(&self, line: &str, name: &str) -> Option<(String, String)> {"}, {"sha": "780c8122734e61f8cebf8b78a9e8fd0e37114851", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -357,7 +357,7 @@ impl<'test> TestCx<'test> {\n             \"run-pass tests with expected warnings should be moved to ui/\"\n         );\n \n-        if !self.props.skip_trans {\n+        if !self.props.skip_codegen {\n             let proc_res = self.exec_compiled_test();\n             if !proc_res.status.success() {\n                 self.fatal_proc_rec(\"test run failed!\", &proc_res);\n@@ -555,7 +555,7 @@ impl<'test> TestCx<'test> {\n \n         rustc\n             .arg(\"-\")\n-            .arg(\"-Zno-trans\")\n+            .arg(\"-Zno-codegen\")\n             .arg(\"--out-dir\")\n             .arg(&out_dir)\n             .arg(&format!(\"--target={}\", target))\n@@ -1703,7 +1703,7 @@ impl<'test> TestCx<'test> {\n             }\n         }\n \n-        if self.props.skip_trans {\n+        if self.props.skip_codegen {\n             assert!(!self.props.compile_flags.iter().any(|s| s.starts_with(\"--emit\")));\n             rustc.args(&[\"--emit\", \"metadata\"]);\n         }\n@@ -2181,19 +2181,19 @@ impl<'test> TestCx<'test> {\n \n         self.check_no_compiler_crash(&proc_res);\n \n-        const PREFIX: &'static str = \"TRANS_ITEM \";\n+        const PREFIX: &'static str = \"MONO_ITEM \";\n         const CGU_MARKER: &'static str = \"@@\";\n \n-        let actual: Vec<TransItem> = proc_res\n+        let actual: Vec<MonoItem> = proc_res\n             .stdout\n             .lines()\n             .filter(|line| line.starts_with(PREFIX))\n-            .map(str_to_trans_item)\n+            .map(str_to_mono_item)\n             .collect();\n \n-        let expected: Vec<TransItem> = errors::load_errors(&self.testpaths.file, None)\n+        let expected: Vec<MonoItem> = errors::load_errors(&self.testpaths.file, None)\n             .iter()\n-            .map(|e| str_to_trans_item(&e.msg[..]))\n+            .map(|e| str_to_mono_item(&e.msg[..]))\n             .collect();\n \n         let mut missing = Vec::new();\n@@ -2271,14 +2271,14 @@ impl<'test> TestCx<'test> {\n         }\n \n         #[derive(Clone, Eq, PartialEq)]\n-        struct TransItem {\n+        struct MonoItem {\n             name: String,\n             codegen_units: HashSet<String>,\n             string: String,\n         }\n \n-        // [TRANS_ITEM] name [@@ (cgu)+]\n-        fn str_to_trans_item(s: &str) -> TransItem {\n+        // [MONO_ITEM] name [@@ (cgu)+]\n+        fn str_to_mono_item(s: &str) -> MonoItem {\n             let s = if s.starts_with(PREFIX) {\n                 (&s[PREFIX.len()..]).trim()\n             } else {\n@@ -2307,7 +2307,7 @@ impl<'test> TestCx<'test> {\n                 HashSet::new()\n             };\n \n-            TransItem {\n+            MonoItem {\n                 name: name.to_owned(),\n                 codegen_units: cgus,\n                 string: full_string,"}, {"sha": "5739ec5f325135669c35959a8b81e2446e622679", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd10f81758381339f98994b8d31814cf5e98707/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=dbd10f81758381339f98994b8d31814cf5e98707", "patch": "@@ -52,7 +52,7 @@ static EXCEPTIONS: &'static [&'static str] = &[\n /// Which crates to check against the whitelist?\n static WHITELIST_CRATES: &'static [CrateVersion] = &[\n     CrateVersion(\"rustc\", \"0.0.0\"),\n-    CrateVersion(\"rustc_trans\", \"0.0.0\"),\n+    CrateVersion(\"rustc_codegen_llvm\", \"0.0.0\"),\n ];\n \n /// Whitelist of crates rustc is allowed to depend on. Avoid adding to the list if possible."}]}