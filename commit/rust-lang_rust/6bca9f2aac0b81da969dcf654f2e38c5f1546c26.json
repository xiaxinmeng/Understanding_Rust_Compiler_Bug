{"sha": "6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "node_id": "C_kwDOAAsO6NoAKDZiY2E5ZjJhYWMwYjgxZGE5NjlkY2Y2NTRmMmUzOGM1ZjE1NDZjMjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T15:48:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T15:48:22Z"}, "message": "Auto merge of #14859 - lunacookies:qos, r=lunacookies\n\nSpecify thread types using Quality of Service API\n\n<details>\n<summary>Some background (in case you haven\u2019t heard of QoS before)</summary>\n\nHeterogenous multi-core CPUs are increasingly found in laptops and desktops (e.g. Alder Lake, Snapdragon 8cx Gen 3, M1). To maximize efficiency on this kind of hardware, it is important to provide the operating system with more information so threads can be scheduled on different core types appropriately.\n\nThe approach that XNU (the kernel of macOS, iOS, etc) and Windows have taken is to provide a high-level semantic API \u2013 quality of service, or QoS \u2013 which informs the OS of the program\u2019s intent. For instance, you might specify that a thread is running a render loop for a game. This makes the OS provide this thread with as large a share of the system\u2019s resources as possible. Specifying a thread is running an unimportant background task, on the other hand, is cause for it to be scheduled exclusively on high-efficiency cores instead of high-performance cores.\n\nQoS APIs allows for easy configuration of many different parameters at once; for instance, setting QoS on XNU affects scheduling, timer latency, I/O priorities, and of course what core type the thread in question should run on. I don\u2019t know any details on how QoS works on Windows, but I would guess it\u2019s similar.\n\nHypothetically, taking advantage of these APIs would improve power consumption, thermals, battery life if applicable, etc.\n\n</details>\n\n# Relevance to rust-analyzer\n\nFrom what I can tell the philosophy behind both the XNU and Windows QoS APIs is that _user interfaces should never stutter under any circumstances._ You can see this in the array of QoS classes which are available: the highest QoS class in both APIs is one intended explicitly for UI render loops.\n\nImagine rust-analyzer is performing CPU-intensive background work \u2013 maybe you just invoked Find Usages on `usize` or opened a large project \u2013 in this scenario the editor\u2019s render loop should absolutely get higher priority than rust-analyzer, no matter what. You could view it in terms of \u201crealtime-ness\u201d: flight control software is hard realtime, audio software is soft realtime, GUIs are softer realtime, and rust-analyzer is not realtime at all. Of course, maximizing responsiveness is important, but respecting the rest of the system is more important.\n\n# Implementation\n\nI\u2019ve tried my best to unify thread creation in `stdx`, where the new API I\u2019ve introduced _requires_ specifying a QoS class. Different points along the performance/efficiency curve can make a great difference; the M1\u2019s e-cores use around three times less power than the p-cores, so putting in this effort is worthwhile IMO.\n\nIt\u2019s worth mentioning that Linux does not [yet](https://youtu.be/RfgPWpTwTQo) have a QoS API. Maybe translating QoS into regular thread priorities would be acceptable? From what I can tell the only scheduling-related code in rust-analyzer is Windows-specific, so ignoring QoS entirely on Linux shouldn\u2019t cause any new issues. Also, I haven\u2019t implemented support for the Windows QoS APIs because I don\u2019t have a Windows machine to test on, and because I\u2019m completely unfamiliar with Windows APIs :)\n\nI noticed that rust-analyzer handles some requests on the main thread (using `.on_sync()`) and others on a threadpool (using `.on()`). I think it would make sense to run the main thread at the User Initiated QoS and the threadpool at Utility, but only if all requests that are caused by typing use `.on_sync()` and all that don\u2019t use `.on()`. I don\u2019t understand how the `.on_sync()`/`.on()` split that\u2019s currently present was chosen, so I\u2019ve let this code be for the moment. Let me know if changing this to what I proposed makes any sense.\n\nTo avoid having to change everything back in case I\u2019ve misunderstood something, I\u2019ve left all threads at the Utility QoS for now. Of course, this isn\u2019t what I hope the code will look like in the end, but I figured I have to start somewhere :P\n\n# References\n\n<ul>\n\n<li><a href=\"https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html\">Apple documentation related to QoS</a></li>\n<li><a href=\"https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/include/pthread/qos.h\">pthread API for setting QoS on XNU</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/procthread/quality-of-service\">Windows\u2019s QoS classes</a></li>\n<li>\n<details>\n<summary>Full documentation of XNU QoS classes. This documentation is only available as a huge not-very-readable comment in a header file, so I\u2019ve reformatted it and put it here for reference.</summary>\n<ul>\n<li><p><strong><code>QOS_CLASS_USER_INTERACTIVE</code>: A QOS class which indicates work performed by this thread is interactive with the user.</strong></p><p>Such work is requested to run at high priority relative to other work on the system. Specifying this QOS class is a request to run with nearly all available system CPU and I/O bandwidth even under contention. This is not an energy-efficient QOS class to use for large tasks. The use of this QOS class should be limited to critical interaction with the user such as handling events on the main event loop, view drawing, animation, etc.</p></li>\n<li><p><strong><code>QOS_CLASS_USER_INITIATED</code>: A QOS class which indicates work performed by this thread was initiated by the user and that the user is likely waiting for the results.</strong></p><p>Such work is requested to run at a priority below critical user-interactive work, but relatively higher than other work on the system. This is not an energy-efficient QOS class to use for large tasks. Its use should be limited to operations of short enough duration that the user is unlikely to switch tasks while waiting for the results. Typical user-initiated work will have progress indicated by the display of placeholder content or modal user interface.</p></li>\n<li><p><strong><code>QOS_CLASS_DEFAULT</code>: A default QOS class used by the system in cases where more specific QOS class information is not available.</strong></p><p>Such work is requested to run at a priority below critical user-interactive and user-initiated work, but relatively higher than utility and background tasks. Threads created by <code>pthread_create()</code> without an attribute specifying a QOS class will default to <code>QOS_CLASS_DEFAULT</code>. This QOS class value is not intended to be used as a work classification, it should only be set when propagating or restoring QOS class values provided by the system.</p></li>\n<li><p><strong><code>QOS_CLASS_UTILITY</code>: A QOS class which indicates work performed by this thread may or may not be initiated by the user and that the user is unlikely to be immediately waiting for the results.</strong></p><p>Such work is requested to run at a priority below critical user-interactive and user-initiated work, but relatively higher than low-level system maintenance tasks. The use of this QOS class indicates the work should be run in an energy and thermally-efficient manner. The progress of utility work may or may not be indicated to the user, but the effect of such work is user-visible.</p></li>\n<li><p><strong><code>QOS_CLASS_BACKGROUND</code>: A QOS class which indicates work performed by this thread was not initiated by the user and that the user may be unaware of the results.</strong></p><p>Such work is requested to run at a priority below other work. The use of this QOS class indicates the work should be run in the most energy and thermally-efficient manner.</p></li>\n<li><p><strong><code>QOS_CLASS_UNSPECIFIED</code>: A QOS class value which indicates the absence or removal of QOS class information.</strong></p><p>As an API return value, may indicate that threads or pthread attributes were configured with legacy API incompatible or in conflict with the QOS class system.</p></li>\n</ul>\n</details>\n</li>\n\n</ul>", "tree": {"sha": "4cae2273f9c6c1cb30798062651d74e8cbef1d80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cae2273f9c6c1cb30798062651d74e8cbef1d80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "html_url": "https://github.com/rust-lang/rust/commit/6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3713c4b949a9c1e0f517aa64ec9cb61ed5ee725f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3713c4b949a9c1e0f517aa64ec9cb61ed5ee725f", "html_url": "https://github.com/rust-lang/rust/commit/3713c4b949a9c1e0f517aa64ec9cb61ed5ee725f"}, {"sha": "430bdd3509d9e188ec4904e2b5cd23e9f3e63e61", "url": "https://api.github.com/repos/rust-lang/rust/commits/430bdd3509d9e188ec4904e2b5cd23e9f3e63e61", "html_url": "https://github.com/rust-lang/rust/commit/430bdd3509d9e188ec4904e2b5cd23e9f3e63e61"}], "stats": {"total": 417, "additions": 393, "deletions": 24}, "files": [{"sha": "e7ae42a2d9b8afee440763d2f6c195b89c06c646", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -408,7 +408,6 @@ dependencies = [\n  \"cargo_metadata\",\n  \"command-group\",\n  \"crossbeam-channel\",\n- \"jod-thread\",\n  \"paths\",\n  \"rustc-hash\",\n  \"serde\",\n@@ -1278,6 +1277,7 @@ dependencies = [\n  \"paths\",\n  \"proc-macro-api\",\n  \"proc-macro-test\",\n+ \"stdx\",\n  \"tt\",\n ]\n \n@@ -1493,7 +1493,6 @@ dependencies = [\n  \"ide-db\",\n  \"ide-ssr\",\n  \"itertools\",\n- \"jod-thread\",\n  \"lsp-server\",\n  \"lsp-types\",\n  \"mbe\",\n@@ -1712,6 +1711,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"always-assert\",\n  \"backtrace\",\n+ \"jod-thread\",\n  \"libc\",\n  \"miow\",\n  \"winapi\",\n@@ -2123,9 +2123,9 @@ name = \"vfs-notify\"\n version = \"0.0.0\"\n dependencies = [\n  \"crossbeam-channel\",\n- \"jod-thread\",\n  \"notify\",\n  \"paths\",\n+ \"stdx\",\n  \"tracing\",\n  \"vfs\",\n  \"walkdir\","}, {"sha": "3f6671b1c43dd96f40c000fb244f247299c68bb6", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -18,7 +18,6 @@ cargo_metadata = \"0.15.0\"\n rustc-hash = \"1.1.0\"\n serde_json.workspace = true\n serde.workspace = true\n-jod-thread = \"0.1.2\"\n command-group = \"2.0.1\"\n \n # local deps"}, {"sha": "e40257c58f8a56fb5ef5ac2ea3566ec0f8152c82", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -77,7 +77,7 @@ impl fmt::Display for FlycheckConfig {\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n     sender: Sender<StateChange>,\n-    _thread: jod_thread::JoinHandle,\n+    _thread: stdx::thread::JoinHandle,\n     id: usize,\n }\n \n@@ -90,7 +90,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<StateChange>();\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n@@ -395,7 +395,7 @@ struct CargoHandle {\n     /// The handle to the actual cargo process. As we cannot cancel directly from with\n     /// a read syscall dropping and therefore terminating the process is our best option.\n     child: JodGroupChild,\n-    thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n+    thread: stdx::thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n@@ -409,7 +409,7 @@ impl CargoHandle {\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"CargoHandle\".to_owned())\n             .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");"}, {"sha": "f049a225f077ead3e27bfe70de277790035f8fb6", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -80,7 +80,11 @@ pub(crate) fn parallel_prime_caches(\n         for _ in 0..num_worker_threads {\n             let worker = prime_caches_worker.clone();\n             let db = db.snapshot();\n-            std::thread::spawn(move || Cancelled::catch(|| worker(db)));\n+\n+            stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+                .allow_leak(true)\n+                .spawn(move || Cancelled::catch(|| worker(db)))\n+                .expect(\"failed to spawn thread\");\n         }\n \n         (work_sender, progress_receiver)"}, {"sha": "d5eb157bfef97b8695da47271b05b4ccf45b45db", "filename": "crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2FCargo.toml?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -22,6 +22,7 @@ object = { version = \"0.30.2\", default-features = false, features = [\n libloading = \"0.7.3\"\n memmap2 = \"0.5.4\"\n \n+stdx.workspace = true\n tt.workspace = true\n mbe.workspace = true\n paths.workspace = true"}, {"sha": "3f795340b2f6b8e2feba9302d50d86fb999a89b5", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -86,7 +86,6 @@ jemallocator = { version = \"0.5.0\", package = \"tikv-jemallocator\", optional = tr\n \n [dev-dependencies]\n expect-test = \"1.4.0\"\n-jod-thread = \"0.1.2\"\n xshell = \"0.2.2\"\n \n test-utils.workspace = true"}, {"sha": "3224aeae5645b51cbae0b714d4f4d85811dee028", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -78,7 +78,14 @@ fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n                 println!(\"rust-analyzer {}\", rust_analyzer::version());\n                 return Ok(());\n             }\n-            with_extra_thread(\"LspServer\", run_server)?;\n+\n+            // rust-analyzer\u2019s \u201cmain thread\u201d is actually a secondary thread\n+            // with an increased stack size at the User Initiated QoS class.\n+            // We use this QoS class because any delay in the main loop\n+            // will make actions like hitting enter in the editor slow.\n+            // rust-analyzer does not block the editor\u2019s render loop,\n+            // so we don\u2019t use User Interactive.\n+            with_extra_thread(\"LspServer\", stdx::thread::QoSClass::UserInitiated, run_server)?;\n         }\n         flags::RustAnalyzerCmd::Parse(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Symbols(cmd) => cmd.run()?,\n@@ -136,14 +143,17 @@ const STACK_SIZE: usize = 1024 * 1024 * 8;\n /// space.\n fn with_extra_thread(\n     thread_name: impl Into<String>,\n+    qos_class: stdx::thread::QoSClass,\n     f: impl FnOnce() -> Result<()> + Send + 'static,\n ) -> Result<()> {\n-    let handle =\n-        std::thread::Builder::new().name(thread_name.into()).stack_size(STACK_SIZE).spawn(f)?;\n-    match handle.join() {\n-        Ok(res) => res,\n-        Err(panic) => std::panic::resume_unwind(panic),\n-    }\n+    let handle = stdx::thread::Builder::new(qos_class)\n+        .name(thread_name.into())\n+        .stack_size(STACK_SIZE)\n+        .spawn(f)?;\n+\n+    handle.join()?;\n+\n+    Ok(())\n }\n \n fn run_server() -> Result<()> {"}, {"sha": "a28edde2f4907a451871b8e49785f67e6757641d", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -665,14 +665,20 @@ impl GlobalState {\n         use crate::handlers::request as handlers;\n \n         dispatcher\n+            // Request handlers that must run on the main thread\n+            // because they mutate GlobalState:\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(handlers::handle_workspace_reload)\n             .on_sync_mut::<lsp_ext::RebuildProcMacros>(handlers::handle_proc_macros_rebuild)\n             .on_sync_mut::<lsp_ext::MemoryUsage>(handlers::handle_memory_usage)\n             .on_sync_mut::<lsp_ext::ShuffleCrateGraph>(handlers::handle_shuffle_crate_graph)\n+            // Request handlers which are related to the user typing\n+            // are run on the main thread to reduce latency:\n             .on_sync::<lsp_ext::JoinLines>(handlers::handle_join_lines)\n             .on_sync::<lsp_ext::OnEnter>(handlers::handle_on_enter)\n             .on_sync::<lsp_types::request::SelectionRangeRequest>(handlers::handle_selection_range)\n             .on_sync::<lsp_ext::MatchingBrace>(handlers::handle_matching_brace)\n+            .on_sync::<lsp_ext::OnTypeFormatting>(handlers::handle_on_type_formatting)\n+            // All other request handlers:\n             .on::<lsp_ext::FetchDependencyList>(handlers::fetch_dependency_list)\n             .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n@@ -693,7 +699,6 @@ impl GlobalState {\n             .on::<lsp_ext::OpenCargoToml>(handlers::handle_open_cargo_toml)\n             .on::<lsp_ext::MoveItem>(handlers::handle_move_item)\n             .on::<lsp_ext::WorkspaceSymbol>(handlers::handle_workspace_symbol)\n-            .on::<lsp_ext::OnTypeFormatting>(handlers::handle_on_type_formatting)\n             .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)\n             .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)\n             .on::<lsp_types::request::GotoDeclaration>(handlers::handle_goto_declaration)"}, {"sha": "0c5a4f30553479976690236c77478672dbbb2e17", "filename": "crates/rust-analyzer/src/task_pool.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -1,5 +1,7 @@\n //! A thin wrapper around `ThreadPool` to make sure that we join all things\n //! properly.\n+use std::sync::{Arc, Barrier};\n+\n use crossbeam_channel::Sender;\n \n pub(crate) struct TaskPool<T> {\n@@ -16,6 +18,18 @@ impl<T> TaskPool<T> {\n             .thread_stack_size(STACK_SIZE)\n             .num_threads(threads)\n             .build();\n+\n+        // Set QoS of all threads in threadpool.\n+        let barrier = Arc::new(Barrier::new(threads + 1));\n+        for _ in 0..threads {\n+            let barrier = barrier.clone();\n+            inner.execute(move || {\n+                stdx::thread::set_current_thread_qos_class(stdx::thread::QoSClass::Utility);\n+                barrier.wait();\n+            });\n+        }\n+        barrier.wait();\n+\n         TaskPool { sender, inner }\n     }\n \n@@ -26,7 +40,16 @@ impl<T> TaskPool<T> {\n     {\n         self.inner.execute({\n             let sender = self.sender.clone();\n-            move || sender.send(task()).unwrap()\n+            move || {\n+                if stdx::thread::IS_QOS_AVAILABLE {\n+                    debug_assert_eq!(\n+                        stdx::thread::get_current_thread_qos_class(),\n+                        Some(stdx::thread::QoSClass::Utility)\n+                    );\n+                }\n+\n+                sender.send(task()).unwrap()\n+            }\n         })\n     }\n "}, {"sha": "33d7f6576c3cd96552af96bf557e4ceae11c3c15", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -155,7 +155,7 @@ pub(crate) fn project(fixture: &str) -> Server {\n pub(crate) struct Server {\n     req_id: Cell<i32>,\n     messages: RefCell<Vec<Message>>,\n-    _thread: jod_thread::JoinHandle<()>,\n+    _thread: stdx::thread::JoinHandle,\n     client: Connection,\n     /// XXX: remove the tempdir last\n     dir: TestDir,\n@@ -165,7 +165,7 @@ impl Server {\n     fn new(dir: TestDir, config: Config) -> Server {\n         let (connection, client) = Connection::memory();\n \n-        let _thread = jod_thread::Builder::new()\n+        let _thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"test server\".to_string())\n             .spawn(move || main_loop(config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");"}, {"sha": "986e3fcdcfc394f89f67ffb179bf1f7b8d388326", "filename": "crates/stdx/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2FCargo.toml?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -15,6 +15,7 @@ doctest = false\n libc = \"0.2.135\"\n backtrace = { version = \"0.3.65\", optional = true }\n always-assert = { version = \"0.1.2\", features = [\"log\"] }\n+jod-thread = \"0.1.2\"\n # Think twice before adding anything here\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "24990d6a0e71431ba3a538fa14011390a5a8dba5", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -11,6 +11,7 @@ pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;\n pub mod rand;\n+pub mod thread;\n \n pub use always_assert::{always, never};\n "}, {"sha": "5042f001435e8115df5109800cca08078312bac1", "filename": "crates/stdx/src/thread.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fstdx%2Fsrc%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fstdx%2Fsrc%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -0,0 +1,326 @@\n+//! A utility module for working with threads that automatically joins threads upon drop\n+//! and provides functionality for interfacing with operating system quality of service (QoS) APIs.\n+//!\n+//! As a system, rust-analyzer should have the property that\n+//! old manual scheduling APIs are replaced entirely by QoS.\n+//! To maintain this invariant, we panic when it is clear that\n+//! old scheduling APIs have been used.\n+//!\n+//! Moreover, we also want to ensure that every thread has a QoS set explicitly\n+//! to force a decision about its importance to the system.\n+//! Thus, [`QoSClass`] has no default value\n+//! and every entry point to creating a thread requires a [`QoSClass`] upfront.\n+\n+use std::fmt;\n+\n+pub fn spawn<F, T>(qos_class: QoSClass, f: F) -> JoinHandle<T>\n+where\n+    F: FnOnce() -> T,\n+    F: Send + 'static,\n+    T: Send + 'static,\n+{\n+    Builder::new(qos_class).spawn(f).expect(\"failed to spawn thread\")\n+}\n+\n+pub struct Builder {\n+    qos_class: QoSClass,\n+    inner: jod_thread::Builder,\n+    allow_leak: bool,\n+}\n+\n+impl Builder {\n+    pub fn new(qos_class: QoSClass) -> Builder {\n+        Builder { qos_class, inner: jod_thread::Builder::new(), allow_leak: false }\n+    }\n+\n+    pub fn name(self, name: String) -> Builder {\n+        Builder { inner: self.inner.name(name), ..self }\n+    }\n+\n+    pub fn stack_size(self, size: usize) -> Builder {\n+        Builder { inner: self.inner.stack_size(size), ..self }\n+    }\n+\n+    pub fn allow_leak(self, b: bool) -> Builder {\n+        Builder { allow_leak: b, ..self }\n+    }\n+\n+    pub fn spawn<F, T>(self, f: F) -> std::io::Result<JoinHandle<T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'static,\n+        T: Send + 'static,\n+    {\n+        let inner_handle = self.inner.spawn(move || {\n+            set_current_thread_qos_class(self.qos_class);\n+            f()\n+        })?;\n+\n+        Ok(JoinHandle { inner: Some(inner_handle), allow_leak: self.allow_leak })\n+    }\n+}\n+\n+pub struct JoinHandle<T = ()> {\n+    // `inner` is an `Option` so that we can\n+    // take ownership of the contained `JoinHandle`.\n+    inner: Option<jod_thread::JoinHandle<T>>,\n+    allow_leak: bool,\n+}\n+\n+impl<T> JoinHandle<T> {\n+    pub fn join(mut self) -> T {\n+        self.inner.take().unwrap().join()\n+    }\n+}\n+\n+impl<T> Drop for JoinHandle<T> {\n+    fn drop(&mut self) {\n+        if !self.allow_leak {\n+            return;\n+        }\n+\n+        if let Some(join_handle) = self.inner.take() {\n+            join_handle.detach();\n+        }\n+    }\n+}\n+\n+impl<T> fmt::Debug for JoinHandle<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"JoinHandle { .. }\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+// Please maintain order from least to most priority for the derived `Ord` impl.\n+pub enum QoSClass {\n+    // Documentation adapted from https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/include/sys/qos.h#L55\n+    //\n+    /// TLDR: invisible maintenance tasks\n+    ///\n+    /// Contract:\n+    ///\n+    /// * **You do not care about how long it takes for work to finish.**\n+    /// * **You do not care about work being deferred temporarily.**\n+    ///   (e.g. if the device\u2019s battery is in a critical state)\n+    ///\n+    /// Examples:\n+    ///\n+    /// * in a video editor:\n+    ///   creating periodic backups of project files\n+    /// * in a browser:\n+    ///   cleaning up cached sites which have not been accessed in a long time\n+    /// * in a collaborative word processor:\n+    ///   creating a searchable index of all documents\n+    ///\n+    /// Use this QoS class for background tasks\n+    /// which the user did not initiate themselves\n+    /// and which are invisible to the user.\n+    /// It is expected that this work will take significant time to complete:\n+    /// minutes or even hours.\n+    ///\n+    /// This QoS class provides the most energy and thermally-efficient execution possible.\n+    /// All other work is prioritized over background tasks.\n+    Background,\n+\n+    /// TLDR: tasks that don\u2019t block using your app\n+    ///\n+    /// Contract:\n+    ///\n+    /// * **Your app remains useful even as the task is executing.**\n+    ///\n+    /// Examples:\n+    ///\n+    /// * in a video editor:\n+    ///   exporting a video to disk \u2013\n+    ///   the user can still work on the timeline\n+    /// * in a browser:\n+    ///   automatically extracting a downloaded zip file \u2013\n+    ///   the user can still switch tabs\n+    /// * in a collaborative word processor:\n+    ///   downloading images embedded in a document \u2013\n+    ///   the user can still make edits\n+    ///\n+    /// Use this QoS class for tasks which\n+    /// may or may not be initiated by the user,\n+    /// but whose result is visible.\n+    /// It is expected that this work will take a few seconds to a few minutes.\n+    /// Typically your app will include a progress bar\n+    /// for tasks using this class.\n+    ///\n+    /// This QoS class provides a balance between\n+    /// performance, responsiveness and efficiency.\n+    Utility,\n+\n+    /// TLDR: tasks that block using your app\n+    ///\n+    /// Contract:\n+    ///\n+    /// * **You need this work to complete\n+    ///   before the user can keep interacting with your app.**\n+    /// * **Your work will not take more than a few seconds to complete.**\n+    ///\n+    /// Examples:\n+    ///\n+    /// * in a video editor:\n+    ///   opening a saved project\n+    /// * in a browser:\n+    ///   loading a list of the user\u2019s bookmarks and top sites\n+    ///   when a new tab is created\n+    /// * in a collaborative word processor:\n+    ///   running a search on the document\u2019s content\n+    ///\n+    /// Use this QoS class for tasks which were initiated by the user\n+    /// and block the usage of your app while they are in progress.\n+    /// It is expected that this work will take a few seconds or less to complete;\n+    /// not long enough to cause the user to switch to something else.\n+    /// Your app will likely indicate progress on these tasks\n+    /// through the display of placeholder content or modals.\n+    ///\n+    /// This QoS class is not energy-efficient.\n+    /// Rather, it provides responsiveness\n+    /// by prioritizing work above other tasks on the system\n+    /// except for critical user-interactive work.\n+    UserInitiated,\n+\n+    /// TLDR: render loops and nothing else\n+    ///\n+    /// Contract:\n+    ///\n+    /// * **You absolutely need this work to complete immediately\n+    ///   or your app will appear to freeze.**\n+    /// * **Your work will always complete virtually instantaneously.**\n+    ///\n+    /// Examples:\n+    ///\n+    /// * the main thread in a GUI application\n+    /// * the update & render loop in a game\n+    /// * a secondary thread which progresses an animation\n+    ///\n+    /// Use this QoS class for any work which, if delayed,\n+    /// will make your user interface unresponsive.\n+    /// It is expected that this work will be virtually instantaneous.\n+    ///\n+    /// This QoS class is not energy-efficient.\n+    /// Specifying this class is a request to run with\n+    /// nearly all available system CPU and I/O bandwidth even under contention.\n+    UserInteractive,\n+}\n+\n+pub const IS_QOS_AVAILABLE: bool = imp::IS_QOS_AVAILABLE;\n+\n+pub fn set_current_thread_qos_class(class: QoSClass) {\n+    imp::set_current_thread_qos_class(class)\n+}\n+\n+pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n+    imp::get_current_thread_qos_class()\n+}\n+\n+// All Apple platforms use XNU as their kernel\n+// and thus have the concept of QoS.\n+#[cfg(target_vendor = \"apple\")]\n+mod imp {\n+    use super::QoSClass;\n+\n+    pub(super) const IS_QOS_AVAILABLE: bool = true;\n+\n+    pub(super) fn set_current_thread_qos_class(class: QoSClass) {\n+        let c = match class {\n+            QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n+            QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n+            QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n+            QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n+        };\n+\n+        let code = unsafe { libc::pthread_set_qos_class_self_np(c, 0) };\n+\n+        if code == 0 {\n+            return;\n+        }\n+\n+        let errno = unsafe { *libc::__error() };\n+\n+        match errno {\n+            libc::EPERM => {\n+                // This thread has been excluded from the QoS system\n+                // due to a previous call to a function such as `pthread_setschedparam`\n+                // which is incompatible with QoS.\n+                //\n+                // Panic instead of returning an error\n+                // to maintain the invariant that we only use QoS APIs.\n+                panic!(\"tried to set QoS of thread which has opted out of QoS (os error {errno})\")\n+            }\n+\n+            libc::EINVAL => {\n+                // This is returned if we pass something other than a qos_class_t\n+                // to `pthread_set_qos_class_self_np`.\n+                //\n+                // This is impossible, so again panic.\n+                unreachable!(\n+                    \"invalid qos_class_t value was passed to pthread_set_qos_class_self_np\"\n+                )\n+            }\n+\n+            _ => {\n+                // `pthread_set_qos_class_self_np`\u2019s documentation\n+                // does not mention any other errors.\n+                unreachable!(\"`pthread_set_qos_class_self_np` returned unexpected error {errno}\")\n+            }\n+        }\n+    }\n+\n+    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n+        let current_thread = unsafe { libc::pthread_self() };\n+        let mut qos_class_raw = libc::qos_class_t::QOS_CLASS_UNSPECIFIED;\n+        let code = unsafe {\n+            libc::pthread_get_qos_class_np(current_thread, &mut qos_class_raw, std::ptr::null_mut())\n+        };\n+\n+        if code != 0 {\n+            // `pthread_get_qos_class_np`\u2019s documentation states that\n+            // an error value is placed into errno if the return code is not zero.\n+            // However, it never states what errors are possible.\n+            // Inspecting the source[0] shows that, as of this writing, it always returns zero.\n+            //\n+            // Whatever errors the function could report in future are likely to be\n+            // ones which we cannot handle anyway\n+            //\n+            // 0: https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/src/qos.c#L171-L177\n+            let errno = unsafe { *libc::__error() };\n+            unreachable!(\"`pthread_get_qos_class_np` failed unexpectedly (os error {errno})\");\n+        }\n+\n+        match qos_class_raw {\n+            libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE => Some(QoSClass::UserInteractive),\n+            libc::qos_class_t::QOS_CLASS_USER_INITIATED => Some(QoSClass::UserInitiated),\n+            libc::qos_class_t::QOS_CLASS_DEFAULT => None, // QoS has never been set\n+            libc::qos_class_t::QOS_CLASS_UTILITY => Some(QoSClass::Utility),\n+            libc::qos_class_t::QOS_CLASS_BACKGROUND => Some(QoSClass::Background),\n+\n+            libc::qos_class_t::QOS_CLASS_UNSPECIFIED => {\n+                // Using manual scheduling APIs causes threads to \u201copt out\u201d of QoS.\n+                // At this point they become incompatible with QoS,\n+                // and as such have the \u201cunspecified\u201d QoS class.\n+                //\n+                // Panic instead of returning an error\n+                // to maintain the invariant that we only use QoS APIs.\n+                panic!(\"tried to get QoS of thread which has opted out of QoS\")\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME: Windows has QoS APIs, we should use them!\n+#[cfg(not(target_vendor = \"apple\"))]\n+mod imp {\n+    use super::QoSClass;\n+\n+    pub(super) const IS_QOS_AVAILABLE: bool = false;\n+\n+    pub(super) fn set_current_thread_qos_class(_: QoSClass) {}\n+\n+    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n+        None\n+    }\n+}"}, {"sha": "5d61a227284ed173a57f436774f9ca46eb9d1689", "filename": "crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2FCargo.toml?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -13,10 +13,10 @@ doctest = false\n \n [dependencies]\n tracing = \"0.1.35\"\n-jod-thread = \"0.1.2\"\n walkdir = \"2.3.2\"\n crossbeam-channel = \"0.5.5\"\n notify = \"5.0\"\n \n+stdx.workspace = true\n vfs.workspace = true\n paths.workspace = true"}, {"sha": "26f7a9fc423593a0cfe493788200c8228d92fb6e", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bca9f2aac0b81da969dcf654f2e38c5f1546c26/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=6bca9f2aac0b81da969dcf654f2e38c5f1546c26", "patch": "@@ -21,7 +21,7 @@ use walkdir::WalkDir;\n pub struct NotifyHandle {\n     // Relative order of fields below is significant.\n     sender: Sender<Message>,\n-    _thread: jod_thread::JoinHandle,\n+    _thread: stdx::thread::JoinHandle,\n }\n \n #[derive(Debug)]\n@@ -34,7 +34,7 @@ impl loader::Handle for NotifyHandle {\n     fn spawn(sender: loader::Sender) -> NotifyHandle {\n         let actor = NotifyActor::new(sender);\n         let (sender, receiver) = unbounded::<Message>();\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"VfsLoader\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");"}]}