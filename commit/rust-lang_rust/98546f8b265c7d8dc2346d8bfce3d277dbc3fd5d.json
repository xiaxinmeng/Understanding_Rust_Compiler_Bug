{"sha": "98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NTQ2ZjhiMjY1YzdkOGRjMjM0NmQ4YmZjZTNkMjc3ZGJjM2ZkNWQ=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2018-04-25T02:45:49Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2018-04-25T03:12:07Z"}, "message": "Make Binder's field private and clean up its usage", "tree": {"sha": "f0445622107e91f8190aef47d83b8c6e33651ea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0445622107e91f8190aef47d83b8c6e33651ea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "html_url": "https://github.com/rust-lang/rust/commit/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "190a6c41cf2afdb11e81545846f2639ee96998e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/190a6c41cf2afdb11e81545846f2639ee96998e8", "html_url": "https://github.com/rust-lang/rust/commit/190a6c41cf2afdb11e81545846f2639ee96998e8"}], "stats": {"total": 496, "additions": 262, "deletions": 234}, "files": [{"sha": "5ab8d6eb7b3e011de9fe1fb65518dac861827b44", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -262,8 +262,7 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let ty::Binder(ref inner) = *self;\n-        inner.hash_stable(hcx, hasher);\n+        self.skip_binder().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "4bb191a878fdbeb6d1137a08e0f61509b2ef192a", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -388,14 +388,16 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     Obligation::new(\n                         cause.clone(),\n                         param_env,\n-                        ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n+                        ty::Predicate::RegionOutlives(\n+                            ty::Binder::dummy(ty::OutlivesPredicate(r1, r2))),\n                     ),\n \n                 UnpackedKind::Type(t1) =>\n                     Obligation::new(\n                         cause.clone(),\n                         param_env,\n-                        ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t1, r2))),\n+                        ty::Predicate::TypeOutlives(\n+                            ty::Binder::dummy(ty::OutlivesPredicate(t1, r2))),\n                     ),\n             }\n         })) as Box<dyn Iterator<Item = _>>"}, {"sha": "096aed85f55e05ac0de46b23f33566ad3041d022", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -302,7 +302,7 @@ struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n /// Result from a generalization operation. This includes\n /// not only the generalized type, but also a bool flag\n-/// indicating whether further WF checks are needed.q\n+/// indicating whether further WF checks are needed.\n struct Generalization<'tcx> {\n     ty: Ty<'tcx>,\n \n@@ -351,7 +351,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn relate_item_substs(&mut self,"}, {"sha": "588f75f809c153f21a4efb19fb5bfbfb6ae074b8", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -916,7 +916,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         };\n \n                         if let (Some(def_id), Some(ret_ty)) = (def_id, ret_ty) {\n-                            if exp_is_struct && exp_found.expected == ret_ty.0 {\n+                            if exp_is_struct && &exp_found.expected == ret_ty.skip_binder() {\n                                 let message = format!(\n                                     \"did you mean `{}(/* fields */)`?\",\n                                     self.tcx.item_path_str(def_id)"}, {"sha": "c23836071ffa8ff727343e421955071005b5d0b4", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n-            Ok(ty::Binder(result))\n+            Ok(ty::Binder::bind(result))\n         });\n     }\n \n@@ -239,7 +239,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                    b,\n                    result1);\n \n-            Ok(ty::Binder(result1))\n+            Ok(ty::Binder::bind(result1))\n         });\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n@@ -335,7 +335,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                    b,\n                    result1);\n \n-            Ok(ty::Binder(result1))\n+            Ok(ty::Binder::bind(result1))\n         });\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "58eae5e6a5b9409d00f28928ab588a6580ab5e56", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -98,7 +98,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                         self.fields.trace.cause.clone(),\n                         self.fields.param_env,\n                         ty::Predicate::Subtype(\n-                            ty::Binder(ty::SubtypePredicate {\n+                            ty::Binder::dummy(ty::SubtypePredicate {\n                                 a_is_expected: self.a_is_expected,\n                                 a,\n                                 b,"}, {"sha": "a7669b942e3b0d2814ccb2398e947a6e7766eaa8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -537,7 +537,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     &data.parent_trait_ref);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n-                    None => Some(format!(\"{}\", parent_trait_ref.0.self_ty())),\n+                    None => Some(format!(\"{}\", parent_trait_ref.skip_binder().self_ty())),\n                 }\n             }\n             _ => None,\n@@ -862,7 +862,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 obligation: &PredicateObligation<'tcx>,\n                                 err: &mut DiagnosticBuilder<'tcx>,\n                                 trait_ref: &ty::Binder<ty::TraitRef<'tcx>>) {\n-        let ty::Binder(trait_ref) = trait_ref;\n+        let trait_ref = trait_ref.skip_binder();\n         let span = obligation.cause.span;\n \n         if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n@@ -1102,7 +1102,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ::syntax::abi::Abi::Rust\n                 )\n             };\n-            format!(\"{}\", ty::Binder(sig))\n+            format!(\"{}\", ty::Binder::bind(sig))\n         }\n \n         let argument_is_closure = expected_ref.skip_binder().substs.type_at(0).is_closure();\n@@ -1436,7 +1436,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n                 let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-                let ty = parent_trait_ref.0.self_ty();\n+                let ty = parent_trait_ref.skip_binder().self_ty();\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n \n@@ -1453,7 +1453,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\n                     &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                              parent_trait_ref,\n-                             parent_trait_ref.0.self_ty()));\n+                             parent_trait_ref.skip_binder().self_ty()));\n                 let parent_predicate = parent_trait_ref.to_predicate();\n                 self.note_obligation_cause_code(err,\n                                             &parent_predicate,\n@@ -1484,7 +1484,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n             let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             for obligated_type in obligated_types {\n-                if obligated_type == &parent_trait_ref.0.self_ty() {\n+                if obligated_type == &parent_trait_ref.skip_binder().self_ty() {\n                     return true;\n                 }\n             }"}, {"sha": "9e636db3a764bc52c0fd9e62c65d2fdbc288dbc5", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -864,7 +864,7 @@ fn vtable_methods<'a, 'tcx>(\n                 // at some particular call site\n                 let substs = tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n-                    &ty::Binder(substs),\n+                    &ty::Binder::bind(substs),\n                 );\n \n                 // It's possible that the method relies on where clauses that\n@@ -997,7 +997,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n \n impl<'tcx> TraitObligation<'tcx> {\n     fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        ty::Binder(self.predicate.skip_binder().self_ty())\n+        self.predicate.map_bound(|p| p.self_ty())\n     }\n }\n "}, {"sha": "c0d5a337cee3a1ca018026856bb058633e67e128", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         supertraits_only: bool) -> bool\n     {\n-        let trait_ref = ty::Binder(ty::TraitRef {\n+        let trait_ref = ty::Binder::dummy(ty::TraitRef {\n             def_id: trait_def_id,\n             substs: Substs::identity_for_item(self, trait_def_id)\n         });\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             .any(|predicate| {\n                 match predicate {\n                     ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                        trait_pred.0.self_ty().is_self()\n+                        trait_pred.skip_binder().self_ty().is_self()\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n@@ -352,7 +352,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                     // Compute supertraits of current trait lazily.\n                     if supertraits.is_none() {\n-                        let trait_ref = ty::Binder(ty::TraitRef {\n+                        let trait_ref = ty::Binder::bind(ty::TraitRef {\n                             def_id: trait_def_id,\n                             substs: Substs::identity_for_item(self, trait_def_id)\n                         });\n@@ -367,7 +367,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     // direct equality here because all of these types\n                     // are part of the formal parameter listing, and\n                     // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder(data.trait_ref(self));\n+                    let projection_trait_ref = ty::Binder::bind(data.trait_ref(self));\n                     let is_supertrait_of_current_trait =\n                         supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n "}, {"sha": "1c7942139e97bd8e554003f681d279c3d47066ac", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -478,7 +478,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n-            let projection = ty::Binder(ty::ProjectionPredicate {\n+            let projection = ty::Binder::dummy(ty::ProjectionPredicate {\n                 projection_ty,\n                 ty: ty_var\n             });\n@@ -982,8 +982,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                predicate);\n         match predicate {\n             ty::Predicate::Projection(data) => {\n-                let same_def_id =\n-                    data.0.projection_ty.item_def_id == obligation.predicate.item_def_id;\n+                let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n                 let is_match = same_def_id && infcx.probe(|_| {\n                     let data_poly_trait_ref =\n@@ -1241,7 +1240,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n         // item with the correct name\n         let env_predicates = env_predicates.filter_map(|p| match p {\n             ty::Predicate::Projection(data) =>\n-                if data.0.projection_ty.item_def_id == obligation.predicate.item_def_id {\n+                if data.projection_def_id() == obligation.predicate.item_def_id {\n                     Some(data)\n                 } else {\n                     None\n@@ -1302,28 +1301,28 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n \n     let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n \n-    // Note: we unwrap the binder here but re-create it below (1)\n-    let ty::Binder((trait_ref, yield_ty, return_ty)) =\n+    let predicate =\n         tcx.generator_trait_ref_and_outputs(gen_def_id,\n                                             obligation.predicate.self_ty(),\n-                                            gen_sig);\n-\n-    let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n-    let ty = if name == Symbol::intern(\"Return\") {\n-        return_ty\n-    } else if name == Symbol::intern(\"Yield\") {\n-        yield_ty\n-    } else {\n-        bug!()\n-    };\n+                                            gen_sig)\n+        .map_bound(|(trait_ref, yield_ty, return_ty)| {\n+            let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n+            let ty = if name == Symbol::intern(\"Return\") {\n+                return_ty\n+            } else if name == Symbol::intern(\"Yield\") {\n+                yield_ty\n+            } else {\n+                bug!()\n+            };\n \n-    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n-        projection_ty: ty::ProjectionTy {\n-            substs: trait_ref.substs,\n-            item_def_id: obligation.predicate.item_def_id,\n-        },\n-        ty: ty\n-    });\n+            ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy {\n+                    substs: trait_ref.substs,\n+                    item_def_id: obligation.predicate.item_def_id,\n+                },\n+                ty: ty\n+            }\n+        });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n         .with_addl_obligations(vtable.nested)\n@@ -1400,21 +1399,21 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     // the `Output` associated type is declared on `FnOnce`\n     let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n \n-    // Note: we unwrap the binder here but re-create it below (1)\n-    let ty::Binder((trait_ref, ret_type)) =\n+    let predicate =\n         tcx.closure_trait_ref_and_return_type(fn_once_def_id,\n                                               obligation.predicate.self_ty(),\n                                               fn_sig,\n-                                              flag);\n-\n-    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n-        projection_ty: ty::ProjectionTy::from_ref_and_name(\n-            tcx,\n-            trait_ref,\n-            Symbol::intern(FN_OUTPUT_NAME),\n-        ),\n-        ty: ret_type\n-    });\n+                                              flag)\n+        .map_bound(|(trait_ref, ret_type)| {\n+            ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy::from_ref_and_name(\n+                    tcx,\n+                    trait_ref,\n+                    Symbol::intern(FN_OUTPUT_NAME),\n+                ),\n+                ty: ret_type\n+            }\n+        });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n }"}, {"sha": "b61407ffdb65a0733917e78bce39febdff4e5907", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -1274,7 +1274,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n         let tcx = self.tcx();\n-        let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n+        let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n             let cache = tcx.selection_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n@@ -1294,7 +1294,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n         let tcx = self.tcx();\n-        let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n+        let trait_ref = cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n             let mut cache = tcx.selection_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n@@ -1357,7 +1357,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let lang_items = self.tcx().lang_items();\n         if lang_items.copy_trait() == Some(def_id) {\n             debug!(\"obligation self ty is {:?}\",\n-                   obligation.predicate.0.self_ty());\n+                   obligation.predicate.skip_binder().self_ty());\n \n             // User-defined copy impls are permitted, but only for\n             // structs and enums.\n@@ -1409,7 +1409,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n-        match obligation.predicate.0.trait_ref.self_ty().sty {\n+        match obligation.predicate.skip_binder().trait_ref.self_ty().sty {\n             ty::TyProjection(_) | ty::TyAnon(..) => {}\n             ty::TyInfer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n@@ -1507,7 +1507,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n         if let Err(_) = self.infcx.at(&obligation.cause, obligation.param_env)\n-                                  .sup(ty::Binder(skol_trait_ref), trait_bound) {\n+                                  .sup(ty::Binder::dummy(skol_trait_ref), trait_bound) {\n             return false;\n         }\n \n@@ -1605,7 +1605,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -1661,12 +1661,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // provide an impl, but only for suitable `fn` pointers\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                if let ty::Binder(ty::FnSig {\n+                if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n                     variadic: false,\n                     ..\n-                }) = self_ty.fn_sig(self.tcx()) {\n+                } = self_ty.fn_sig(self.tcx()).skip_binder() {\n                     candidates.vec.push(FnPointerCandidate);\n                 }\n             }\n@@ -1687,7 +1687,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         self.tcx().for_each_relevant_impl(\n             obligation.predicate.def_id(),\n-            obligation.predicate.0.trait_ref.self_ty(),\n+            obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n                 self.probe(|this, snapshot| { /* [1] */\n                     match this.match_impl(impl_def_id, obligation, snapshot) {\n@@ -2046,19 +2046,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyGeneratorWitness(..) | ty::TyArray(..) | ty::TyClosure(..) |\n             ty::TyNever | ty::TyError => {\n                 // safe for everything\n-                Where(ty::Binder(Vec::new()))\n+                Where(ty::Binder::dummy(Vec::new()))\n             }\n \n             ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) => Never,\n \n             ty::TyTuple(tys) => {\n-                Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n+                Where(ty::Binder::bind(tys.last().into_iter().cloned().collect()))\n             }\n \n             ty::TyAdt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(ty::Binder(\n+                Where(ty::Binder::bind(\n                     sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n                 ))\n             }\n@@ -2088,7 +2088,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyError => {\n-                Where(ty::Binder(Vec::new()))\n+                Where(ty::Binder::dummy(Vec::new()))\n             }\n \n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n@@ -2106,20 +2106,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyArray(element_ty, _) => {\n                 // (*) binder moved here\n-                Where(ty::Binder(vec![element_ty]))\n+                Where(ty::Binder::bind(vec![element_ty]))\n             }\n \n             ty::TyTuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder(tys.to_vec()))\n+                Where(ty::Binder::bind(tys.to_vec()))\n             }\n \n             ty::TyClosure(def_id, substs) => {\n                 let trait_id = obligation.predicate.def_id();\n                 let is_copy_trait = Some(trait_id) == self.tcx().lang_items().copy_trait();\n                 let is_clone_trait = Some(trait_id) == self.tcx().lang_items().clone_trait();\n                 if is_copy_trait || is_clone_trait {\n-                    Where(ty::Binder(substs.upvar_tys(def_id, self.tcx()).collect()))\n+                    Where(ty::Binder::bind(substs.upvar_tys(def_id, self.tcx()).collect()))\n                 } else {\n                     Never\n                 }\n@@ -2260,7 +2260,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n \n         types.skip_binder().into_iter().flat_map(|ty| { // binder moved -\\\n-            let ty: ty::Binder<Ty<'tcx>> = ty::Binder(ty); // <----------/\n+            let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n             self.in_snapshot(|this, snapshot| {\n                 let (skol_ty, skol_map) =\n@@ -2450,18 +2450,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds\n     /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n     fn confirm_auto_impl_candidate(&mut self,\n-                                      obligation: &TraitObligation<'tcx>,\n-                                      trait_def_id: DefId)\n-                                      -> VtableAutoImplData<PredicateObligation<'tcx>>\n+                                   obligation: &TraitObligation<'tcx>,\n+                                   trait_def_id: DefId)\n+                                   -> VtableAutoImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_auto_impl_candidate({:?}, {:?})\",\n                obligation,\n                trait_def_id);\n \n-        // binder is moved below\n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n-        let types = self.constituent_types_for_ty(self_ty);\n-        self.vtable_auto_impl(obligation, trait_def_id, ty::Binder(types))\n+        let types = obligation.predicate.map_bound(|inner| {\n+            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n+            self.constituent_types_for_ty(self_ty)\n+        });\n+        self.vtable_auto_impl(obligation, trait_def_id, types)\n     }\n \n     /// See `confirm_auto_impl_candidate`\n@@ -2726,7 +2727,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"confirm_closure_candidate({:?})\", obligation);\n \n-        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => bug!(\"closure candidate for non-fn trait {:?}\", obligation)\n         };\n@@ -2835,14 +2836,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::TyDynamic(ref data_a, r_a), &ty::TyDynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n-                // Binders reintroduced below in call to mk_existential_predicates.\n-                let principal = data_a.skip_binder().principal();\n-                let iter = principal.into_iter().map(ty::ExistentialPredicate::Trait)\n-                    .chain(data_a.skip_binder().projection_bounds()\n-                           .map(|x| ty::ExistentialPredicate::Projection(x)))\n-                    .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n-                let new_trait = tcx.mk_dynamic(\n-                    ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n+                let existential_predicates = data_a.map_bound(|data_a| {\n+                    let principal = data_a.principal();\n+                    let iter = principal.into_iter().map(ty::ExistentialPredicate::Trait)\n+                        .chain(data_a.projection_bounds()\n+                            .map(|x| ty::ExistentialPredicate::Projection(x)))\n+                        .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n+                    tcx.mk_existential_predicates(iter)\n+                });\n+                let new_trait = tcx.mk_dynamic(existential_predicates, r_b);\n                 let InferOk { obligations, .. } =\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_trait)\n@@ -2857,7 +2859,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n                                                    obligation.param_env,\n-                                                   ty::Binder(outlives).to_predicate()));\n+                                                   ty::Binder::bind(outlives).to_predicate()));\n             }\n \n             // T -> Trait.\n@@ -2900,7 +2902,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n                 let outlives = ty::OutlivesPredicate(source, r);\n-                push(ty::Binder(outlives).to_predicate());\n+                push(ty::Binder::dummy(outlives).to_predicate());\n             }\n \n             // [T; n] -> [T].\n@@ -3201,18 +3203,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n         let closure_type = self.infcx.closure_sig(closure_def_id, substs);\n-        let ty::Binder((trait_ref, _)) =\n-            self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n-                                                         obligation.predicate.0.self_ty(), // (1)\n-                                                         closure_type,\n-                                                         util::TupleArgumentsFlag::No);\n+\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is\n         // in fact unparameterized (or at least does not reference any\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n \n-        ty::Binder(trait_ref)\n+        self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n+                                                     obligation.predicate\n+                                                         .skip_binder().self_ty(), // (1)\n+                                                     closure_type,\n+                                                     util::TupleArgumentsFlag::No)\n+            .map_bound(|(trait_ref, _)| trait_ref)\n     }\n \n     fn generator_trait_ref_unnormalized(&mut self,\n@@ -3222,17 +3225,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n         let gen_sig = substs.generator_poly_sig(closure_def_id, self.tcx());\n-        let ty::Binder((trait_ref, ..)) =\n-            self.tcx().generator_trait_ref_and_outputs(obligation.predicate.def_id(),\n-                                                       obligation.predicate.0.self_ty(), // (1)\n-                                                       gen_sig);\n+\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an generator type and hence is\n         // in fact unparameterized (or at least does not reference any\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n \n-        ty::Binder(trait_ref)\n+        self.tcx().generator_trait_ref_and_outputs(obligation.predicate.def_id(),\n+                                                   obligation.predicate\n+                                                       .skip_binder().self_ty(), // (1)\n+                                                   gen_sig)\n+            .map_bound(|(trait_ref, ..)| trait_ref)\n     }\n \n     /// Returns the obligations that are implied by instantiating an"}, {"sha": "3c62f04afc56eefcbf9944c161665c1caa8ecd77", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -209,13 +209,13 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                                None\n                            } else {\n                                Some(ty::Predicate::RegionOutlives(\n-                                   ty::Binder(ty::OutlivesPredicate(r, r_min))))\n+                                   ty::Binder::dummy(ty::OutlivesPredicate(r, r_min))))\n                            },\n \n                            Component::Param(p) => {\n                                let ty = tcx.mk_param(p.idx, p.name);\n                                Some(ty::Predicate::TypeOutlives(\n-                                   ty::Binder(ty::OutlivesPredicate(ty, r_min))))\n+                                   ty::Binder::dummy(ty::OutlivesPredicate(ty, r_min))))\n                            },\n \n                            Component::UnresolvedInferenceVariable(_) => {\n@@ -514,7 +514,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             def_id: fn_trait_def_id,\n             substs: self.mk_substs_trait(self_ty, &[arguments_tuple]),\n         };\n-        ty::Binder((trait_ref, sig.skip_binder().output()))\n+        ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n     }\n \n     pub fn generator_trait_ref_and_outputs(self,\n@@ -527,7 +527,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             def_id: fn_trait_def_id,\n             substs: self.mk_substs_trait(self_ty, &[]),\n         };\n-        ty::Binder((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n+        ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n     }\n \n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {"}, {"sha": "047bfcc8c6f59e80f06eefdd57c1b77541113b4b", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -92,6 +92,6 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n }"}, {"sha": "eb06852c65d43d29c20af658e01674d179ddaa18", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -394,7 +394,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         });\n-        Binder(value)\n+        Binder::bind(value)\n     }\n \n     /// Returns a set of all late-bound regions that are constrained\n@@ -446,7 +446,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         where T : TypeFoldable<'tcx>,\n     {\n         let mut counter = 0;\n-        Binder(self.replace_late_bound_regions(sig, |_| {\n+        Binder::bind(self.replace_late_bound_regions(sig, |_| {\n             counter += 1;\n             self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter)))\n         }).0)"}, {"sha": "02a03bc542a3acd820461890019f5c65fcca4813", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -259,7 +259,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation((param_env, ty::Binder(trait_ref)));\n+    let vtbl = tcx.trans_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:"}, {"sha": "d8aba0245022da5b982b03c7371ebe6142d9c060", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -1048,18 +1048,18 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n \n-        let substs = &trait_ref.0.substs;\n+        let substs = &trait_ref.skip_binder().substs;\n         match *self {\n-            Predicate::Trait(ty::Binder(ref data)) =>\n-                Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n-            Predicate::Subtype(ty::Binder(ref data)) =>\n-                Predicate::Subtype(ty::Binder(data.subst(tcx, substs))),\n-            Predicate::RegionOutlives(ty::Binder(ref data)) =>\n-                Predicate::RegionOutlives(ty::Binder(data.subst(tcx, substs))),\n-            Predicate::TypeOutlives(ty::Binder(ref data)) =>\n-                Predicate::TypeOutlives(ty::Binder(data.subst(tcx, substs))),\n-            Predicate::Projection(ty::Binder(ref data)) =>\n-                Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Trait(ref binder) =>\n+                Predicate::Trait(binder.map_bound(|data| data.subst(tcx, substs))),\n+            Predicate::Subtype(ref binder) =>\n+                Predicate::Subtype(binder.map_bound(|data| data.subst(tcx, substs))),\n+            Predicate::RegionOutlives(ref binder) =>\n+                Predicate::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs))),\n+            Predicate::TypeOutlives(ref binder) =>\n+                Predicate::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs))),\n+            Predicate::Projection(ref binder) =>\n+                Predicate::Projection(binder.map_bound(|data| data.subst(tcx, substs))),\n             Predicate::WellFormed(data) =>\n                 Predicate::WellFormed(data.subst(tcx, substs)),\n             Predicate::ObjectSafe(trait_def_id) =>\n@@ -1095,7 +1095,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn def_id(&self) -> DefId {\n         // ok to skip binder since trait def-id does not care about regions\n-        self.0.def_id()\n+        self.skip_binder().def_id()\n     }\n }\n \n@@ -1149,11 +1149,20 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         // This is because here `self` has a `Binder` and so does our\n         // return value, so we are preserving the number of binding\n         // levels.\n-        ty::Binder(self.0.projection_ty.trait_ref(tcx))\n+        self.map_bound(|predicate| predicate.projection_ty.trait_ref(tcx))\n     }\n \n     pub fn ty(&self) -> Binder<Ty<'tcx>> {\n-        Binder(self.skip_binder().ty) // preserves binding levels\n+        self.map_bound(|predicate| predicate.ty)\n+    }\n+\n+    /// The DefId of the TraitItem for the associated type.\n+    ///\n+    /// Note that this is not the DefId of the TraitRef containing this\n+    /// associated type, which is in tcx.associated_item(projection_def_id()).container.\n+    pub fn projection_def_id(&self) -> DefId {\n+        // ok to skip binder since trait def-id does not care about regions\n+        self.skip_binder().projection_ty.item_def_id\n     }\n }\n \n@@ -1163,8 +1172,7 @@ pub trait ToPolyTraitRef<'tcx> {\n \n impl<'tcx> ToPolyTraitRef<'tcx> for TraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n-        assert!(!self.has_escaping_regions());\n-        ty::Binder(self.clone())\n+        ty::Binder::dummy(self.clone())\n     }\n }\n \n@@ -1180,12 +1188,7 @@ pub trait ToPredicate<'tcx> {\n \n impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        // we're about to add a binder, so let's check that we don't\n-        // accidentally capture anything, or else that might be some\n-        // weird debruijn accounting.\n-        assert!(!self.has_escaping_regions());\n-\n-        ty::Predicate::Trait(ty::Binder(ty::TraitPredicate {\n+        ty::Predicate::Trait(ty::Binder::dummy(ty::TraitPredicate {\n             trait_ref: self.clone()\n         }))\n     }\n@@ -1224,17 +1227,19 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 data.skip_binder().input_types().collect()\n             }\n-            ty::Predicate::Subtype(ty::Binder(SubtypePredicate { a, b, a_is_expected: _ })) => {\n+            ty::Predicate::Subtype(binder) => {\n+                let SubtypePredicate { a, b, a_is_expected: _ } = binder.skip_binder();\n                 vec![a, b]\n             }\n-            ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n-                vec![data.0]\n+            ty::Predicate::TypeOutlives(binder) => {\n+                vec![binder.skip_binder().0]\n             }\n             ty::Predicate::RegionOutlives(..) => {\n                 vec![]\n             }\n             ty::Predicate::Projection(ref data) => {\n-                data.0.projection_ty.substs.types().chain(Some(data.0.ty)).collect()\n+                let inner = data.skip_binder();\n+                inner.projection_ty.substs.types().chain(Some(inner.ty)).collect()\n             }\n             ty::Predicate::WellFormed(data) => {\n                 vec![data]\n@@ -2090,7 +2095,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     Some(x) => x,\n                     _ => return vec![ty]\n                 };\n-                let sized_predicate = Binder(TraitRef {\n+                let sized_predicate = Binder::dummy(TraitRef {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();"}, {"sha": "348cf03dd8783e0bf5e130618f030b3d92f3488e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -431,10 +431,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         {\n             // Wrap our types with a temporary GeneratorWitness struct\n             // inside the binder so we can related them\n-            let a_types = ty::Binder(GeneratorWitness(*a_types.skip_binder()));\n-            let b_types = ty::Binder(GeneratorWitness(*b_types.skip_binder()));\n+            let a_types = a_types.map_bound(GeneratorWitness);\n+            let b_types = b_types.map_bound(GeneratorWitness);\n             // Then remove the GeneratorWitness for the result\n-            let types = ty::Binder(relation.relate(&a_types, &b_types)?.skip_binder().0);\n+            let types = relation.relate(&a_types, &b_types)?.map_bound(|witness| witness.0);\n             Ok(tcx.mk_generator_witness(types))\n         }\n "}, {"sha": "199a46678c83cfb158bbfbf08c15908d1c27dc30", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.0).map(|x| ty::Binder(x))\n+        tcx.lift(self.skip_binder()).map(ty::Binder::bind)\n     }\n }\n \n@@ -720,15 +720,15 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n \n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::Binder(self.0.fold_with(folder))\n+        self.map_bound_ref(|ty| ty.fold_with(folder))\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_binder(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor)\n+        self.skip_binder().visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {"}, {"sha": "d5b63939dd6e8f43b90db3fdf37e241ca6c6b560", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -345,7 +345,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// binder, but it never contains bound regions. Probably this\n     /// function should be removed.\n     pub fn generator_poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> PolyGenSig<'tcx> {\n-        ty::Binder(self.generator_sig(def_id, tcx))\n+        ty::Binder::dummy(self.generator_sig(def_id, tcx))\n     }\n \n     /// Return the \"generator signature\", which consists of its yield\n@@ -504,13 +504,13 @@ impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n \n impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n-        self.skip_binder().principal().map(Binder)\n+        self.skip_binder().principal().map(Binder::bind)\n     }\n \n     #[inline]\n     pub fn projection_bounds<'a>(&'a self) ->\n         impl Iterator<Item=PolyExistentialProjection<'tcx>> + 'a {\n-        self.skip_binder().projection_bounds().map(Binder)\n+        self.skip_binder().projection_bounds().map(Binder::bind)\n     }\n \n     #[inline]\n@@ -520,7 +520,7 @@ impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n \n     pub fn iter<'a>(&'a self)\n         -> impl DoubleEndedIterator<Item=Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n-        self.skip_binder().iter().cloned().map(Binder)\n+        self.skip_binder().iter().cloned().map(Binder::bind)\n     }\n }\n \n@@ -567,26 +567,26 @@ pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.0.self_ty()\n+        self.skip_binder().self_ty()\n     }\n \n     pub fn def_id(&self) -> DefId {\n-        self.0.def_id\n+        self.skip_binder().def_id\n     }\n \n     pub fn substs(&self) -> &'tcx Substs<'tcx> {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n-        self.0.substs\n+        self.skip_binder().substs\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n-        self.0.input_types()\n+        self.skip_binder().input_types()\n     }\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n         // Note that we preserve binding levels\n-        Binder(ty::TraitPredicate { trait_ref: self.0.clone() })\n+        Binder(ty::TraitPredicate { trait_ref: self.skip_binder().clone() })\n     }\n }\n \n@@ -633,12 +633,12 @@ pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n \n impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     pub fn def_id(&self) -> DefId {\n-        self.0.def_id\n+        self.skip_binder().def_id\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n-        self.0.input_types()\n+        self.skip_binder().input_types()\n     }\n }\n \n@@ -650,7 +650,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Binder<T>(pub T);\n+pub struct Binder<T>(T);\n \n impl<T> Binder<T> {\n     /// Wraps `value` in a binder, asserting that `value` does not\n@@ -664,6 +664,12 @@ impl<T> Binder<T> {\n         Binder(value)\n     }\n \n+    /// Wraps `value` in a binder, binding late-bound regions (if any).\n+    pub fn bind<'tcx>(value: T) -> Binder<T>\n+    {\n+        Binder(value)\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// debruijn indices and the like. It is usually better to\n@@ -685,7 +691,7 @@ impl<T> Binder<T> {\n     }\n \n     pub fn as_ref(&self) -> Binder<&T> {\n-        ty::Binder(&self.0)\n+        Binder(&self.0)\n     }\n \n     pub fn map_bound_ref<F, U>(&self, f: F) -> Binder<U>\n@@ -697,7 +703,7 @@ impl<T> Binder<T> {\n     pub fn map_bound<F, U>(self, f: F) -> Binder<U>\n         where F: FnOnce(T) -> U\n     {\n-        ty::Binder(f(self.0))\n+        Binder(f(self.0))\n     }\n \n     /// Unwraps and returns the value within, but only if it contains\n@@ -730,7 +736,7 @@ impl<T> Binder<T> {\n     pub fn fuse<U,F,R>(self, u: Binder<U>, f: F) -> Binder<R>\n         where F: FnOnce(T, U) -> R\n     {\n-        ty::Binder(f(self.0, u.0))\n+        Binder(f(self.0, u.0))\n     }\n \n     /// Split the contents into two things that share the same binder\n@@ -743,7 +749,7 @@ impl<T> Binder<T> {\n         where F: FnOnce(T) -> (U, V)\n     {\n         let (u, v) = f(self.0);\n-        (ty::Binder(u), ty::Binder(v))\n+        (Binder(u), Binder(v))\n     }\n }\n \n@@ -839,7 +845,7 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n     pub fn inputs(&self) -> Binder<&'tcx [Ty<'tcx>]> {\n-        Binder(self.skip_binder().inputs())\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs())\n     }\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n@@ -1152,6 +1158,10 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n         -> ty::PolyProjectionPredicate<'tcx> {\n         self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n+\n+    pub fn item_def_id(&self) -> DefId {\n+        return self.skip_binder().item_def_id;\n+    }\n }\n \n impl DebruijnIndex {"}, {"sha": "b23e9124ddc91914aa3cd73b17e71dc194c8ee57", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::ConstEvaluatable(..) => {\n                         None\n                     }\n-                    ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n+                    ty::Predicate::TypeOutlives(predicate) => {\n                         // Search for a bound of the form `erased_self_ty\n                         // : 'a`, but be wary of something like `for<'a>\n                         // erased_self_ty : 'a` (we interpret a\n@@ -390,8 +390,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         // it's kind of a moot point since you could never\n                         // construct such an object, but this seems\n                         // correct even if that code changes).\n-                        if t == erased_self_ty && !r.has_escaping_regions() {\n-                            Some(r)\n+                        let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n+                        if t == &erased_self_ty && !r.has_escaping_regions() {\n+                            Some(*r)\n                         } else {\n                             None\n                         }\n@@ -561,7 +562,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnOnce => closure_ty,\n         };\n-        Some(ty::Binder(env_ty))\n+        Some(ty::Binder::bind(env_ty))\n     }\n \n     /// Given the def-id of some item that has no type parameters, make"}, {"sha": "aea84791fe86b66aa082919fa13886ef510040c2", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -307,7 +307,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                                 cause,\n                                 param_env,\n                                 ty::Predicate::TypeOutlives(\n-                                    ty::Binder(\n+                                    ty::Binder::dummy(\n                                         ty::OutlivesPredicate(mt.ty, r)))));\n                     }\n                 }\n@@ -492,7 +492,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n-                let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n+                let outlives = ty::Binder::dummy(\n+                    ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::new(cause,\n                                                       self.param_env,\n                                                       outlives.to_predicate()));"}, {"sha": "efe83252d0fac8cf96291eeb8aa38c2bbc0b2fda", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -473,7 +473,7 @@ impl PrintContext {\n         let value = if let Some(v) = lifted {\n             v\n         } else {\n-            return original.0.print_display(f, self);\n+            return original.skip_binder().print_display(f, self);\n         };\n \n         if self.binder_depth == 0 {\n@@ -679,9 +679,9 @@ define_print! {\n             ty::tls::with(|tcx| {\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n \n-                let trait_ref = tcx.lift(&ty::Binder(*self))\n+                let trait_ref = *tcx.lift(&ty::Binder::bind(*self))\n                                    .expect(\"could not lift TraitRef for printing\")\n-                                   .with_self_ty(tcx, dummy_self).0;\n+                                   .with_self_ty(tcx, dummy_self).skip_binder();\n                 cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n             })\n         }"}, {"sha": "83501f45ec037796d7c59fc24018f1b33b7cb2fd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_fn_ptr(ty::Binder(self.infcx.tcx.mk_fn_sig(\n+        self.infcx.tcx.mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n             input_tys.iter().cloned(),\n             output_ty,\n             false,"}, {"sha": "141d491327aa4544af0c4419df8f8a0bd677a340", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -960,7 +960,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                 // Attempt to select a concrete impl before checking.\n                 ty::TraitContainer(trait_def_id) => {\n                     let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n-                    let trait_ref = ty::Binder(trait_ref);\n+                    let trait_ref = ty::Binder::bind(trait_ref);\n                     let span = tcx.hir.span(expr_id);\n                     let obligation =\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),"}, {"sha": "020dce62c38049977318f3f8a730998178b6c35e", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -163,7 +163,7 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            -> CustomCoerceUnsized {\n     let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let trait_ref = ty::Binder(ty::TraitRef {\n+    let trait_ref = ty::Binder::bind(ty::TraitRef {\n         def_id: def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });"}, {"sha": "e4cb118a4f7f8b8bd0e381506ebd1967852a8b51", "filename": "src/librustc_traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -86,14 +86,14 @@ where\n                 }\n                 Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r1.into(), r2),\n             })\n-            .map(ty::Binder) // no bound regions in the code above\n+            .map(ty::Binder::dummy) // no bound regions in the code above\n             .collect();\n \n         outlives.extend(\n             region_obligations\n                 .into_iter()\n                 .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n-                .map(ty::Binder) // no bound regions in the code above\n+                .map(ty::Binder::dummy) // no bound regions in the code above\n         );\n \n         outlives"}, {"sha": "4d781d7280d376c158a0f7292408237f3ed2c978", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -406,7 +406,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n             return llfn;\n         }\n \n-        let ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+        let ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n             iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n             tcx.types.never,\n             false,"}, {"sha": "ecdc2d20d2142fa9a84a6a9ec71a4e831f845b29", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -958,7 +958,7 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder(cx.tcx.mk_fn_sig(\n+    let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder::bind(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n         false,\n@@ -985,7 +985,7 @@ fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+    let fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n         iter::once(i8p),\n         tcx.mk_nil(),\n         false,"}, {"sha": "d657db0b1252c68cbd97054379020c83277df722", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -363,7 +363,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_ref.path.segments.last().unwrap());\n-        let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n+        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n         poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n             // specify type to assert that error was already reported in Err case:\n@@ -485,7 +485,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n             let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n             let late_bound_in_ty =\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder(binding.ty));\n+                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(binding.ty));\n             debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n             debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n             for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n@@ -639,7 +639,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         for projection_bound in &projection_bounds {\n-            associated_types.remove(&projection_bound.0.projection_ty.item_def_id);\n+            associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n         for item_def_id in associated_types {\n@@ -654,14 +654,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         .emit();\n         }\n \n+        // skip_binder is okay, because the predicates are re-bound.\n         let mut v =\n             iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n             .chain(existential_projections\n                    .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n             .collect::<AccumulateVec<[_; 8]>>();\n         v.sort_by(|a, b| a.cmp(tcx, b));\n-        let existential_predicates = ty::Binder(tcx.mk_existential_predicates(v.into_iter()));\n+        let existential_predicates = ty::Binder::bind(tcx.mk_existential_predicates(v.into_iter()));\n \n \n         // Explicitly specified region bound. Use that.\n@@ -825,7 +826,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n \n                 let candidates =\n-                    traits::supertraits(tcx, ty::Binder(trait_ref))\n+                    traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n                                                                          assoc_name));\n \n@@ -853,7 +854,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        let trait_did = bound.0.def_id;\n+        let trait_did = bound.def_id();\n         let (assoc_ident, def_scope) = tcx.adjust(assoc_name, trait_did, ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n@@ -1184,7 +1185,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        let bare_fn_ty = ty::Binder(tcx.mk_fn_sig(\n+        let bare_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n             input_tys.into_iter(),\n             output_ty,\n             decl.variadic,\n@@ -1396,7 +1397,8 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n             // account for the binder being introduced below; no need to shift `param_ty`\n             // because, at present at least, it can only refer to early-bound regions\n             let region_bound = tcx.mk_region(ty::fold::shift_region(*region_bound, 1));\n-            vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate());\n+            vec.push(\n+                ty::Binder::dummy(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate());\n         }\n \n         for bound_trait_ref in &self.trait_bounds {"}, {"sha": "0c95f5eeb4311c8a314d136a20f1b5a9adfda695", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings.\n-                (ty::Binder(self.tcx.mk_fn_sig(\n+                (ty::Binder::bind(self.tcx.mk_fn_sig(\n                     self.err_args(arg_exprs.len()).into_iter(),\n                     self.tcx.types.err,\n                     false,"}, {"sha": "0deda993d4f4aeeec3c50e73e97f802cfeba2e32", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let ret_param_ty = projection.0.ty;\n+        let ret_param_ty = projection.skip_binder().ty;\n         let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n         debug!(\n             \"deduce_sig_from_projection: ret_param_ty {:?}\",\n@@ -458,7 +458,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n         assert!(!expected_sig.sig.has_regions_escaping_depth(1));\n-        let bound_sig = ty::Binder(self.tcx.mk_fn_sig(\n+        let bound_sig = ty::Binder::bind(self.tcx.mk_fn_sig(\n             expected_sig.sig.inputs().iter().cloned(),\n             expected_sig.sig.output(),\n             decl.variadic,\n@@ -562,7 +562,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let (supplied_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n-                    &ty::Binder(supplied_ty),\n+                    &ty::Binder::bind(supplied_ty),\n                 ); // recreated from (*) above\n \n                 // Check that E' = S'.\n@@ -607,7 +607,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::DefaultReturn(_) => astconv.ty_infer(decl.output.span()),\n         };\n \n-        let result = ty::Binder(self.tcx.mk_fn_sig(\n+        let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n             supplied_arguments,\n             supplied_return,\n             decl.variadic,\n@@ -639,7 +639,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::DefaultReturn(_) => {}\n         }\n \n-        let result = ty::Binder(self.tcx.mk_fn_sig(\n+        let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n             supplied_arguments,\n             self.tcx.types.err,\n             decl.variadic,"}, {"sha": "8c69608a2617060ae292029ec5ec4acbdb7ce45d", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -558,7 +558,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             let trait_ref = match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     if unsize_did == tr.def_id() {\n-                        if let ty::TyTuple(..) = tr.0.input_types().nth(1).unwrap().sty {\n+                        let sty = &tr.skip_binder().input_types().nth(1).unwrap().sty;\n+                        if let ty::TyTuple(..) = sty {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }"}, {"sha": "c9e53fa7674d413945aa577f45685b27dfbe5d42", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -234,9 +234,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n         let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_skol_substs);\n-        let (impl_m_own_bounds, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                       infer::HigherRankedType,\n-                                                       &ty::Binder(impl_m_own_bounds.predicates));\n+        let (impl_m_own_bounds, _) = infcx.replace_late_bound_regions_with_fresh_var(\n+            impl_m_span,\n+            infer::HigherRankedType,\n+            &ty::Binder::bind(impl_m_own_bounds.predicates)\n+        );\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, param_env, normalize_cause.clone(), &predicate);\n@@ -270,7 +272,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               impl_m_node_id,\n                                               param_env,\n                                               &impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n+        let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(\n@@ -283,7 +285,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               impl_m_node_id,\n                                               param_env,\n                                               &trait_sig);\n-        let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n+        let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n@@ -505,7 +507,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.infer_ctxt().enter(|infcx| {\n             let self_arg_ty = tcx.liberate_late_bound_regions(\n                 method.def_id,\n-                &ty::Binder(self_arg_ty)\n+                &ty::Binder::bind(self_arg_ty)\n             );\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {"}, {"sha": "7bae5fe4fd1af13c9e3e7fe3f51f87bbc0030d5f", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -129,7 +129,7 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                                         ty::BrAnon(counter)))\n     });\n \n-    let witness = fcx.tcx.mk_generator_witness(ty::Binder(type_list));\n+    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n \n     debug!(\"Types in generator after region replacement {:?}, span = {:?}\",\n             witness, body.value.span);"}, {"sha": "64b0e7d0a7d6e3f40ad0468b3c0b98ed39e6f72f", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -61,7 +61,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    let fty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+    let fty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n         false,\n@@ -304,7 +304,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = ty::Binder(tcx.mk_fn_sig(\n+                let fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n                     tcx.mk_nil(),\n                     false,"}, {"sha": "09feaaffc5b9df3e6209644b83363381ecdae0be", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // We won't add these if we encountered an illegal sized bound, so that we can use\n         // a custom error in that case.\n         if !illegal_sized_bound {\n-            let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n+            let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig));\n             self.add_obligations(method_ty, all_substs, &method_predicates);\n         }\n \n@@ -587,7 +587,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 }\n             })\n             .any(|trait_pred| {\n-                match trait_pred.0.self_ty().sty {\n+                match trait_pred.skip_binder().self_ty().sty {\n                     ty::TyDynamic(..) => true,\n                     _ => false,\n                 }"}, {"sha": "5f55ee6163b53bb5ceac7891140ff1a1bbf2b732", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            &bounds));\n \n         // Also add an obligation for the method type being well-formed.\n-        let method_ty = tcx.mk_fn_ptr(ty::Binder(fn_sig));\n+        let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig));\n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n                method_ty,\n                obligation);"}, {"sha": "5c1ca44f9f5849d8f80ddf9e52df9b2c6afe739e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -650,7 +650,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             .filter_map(|predicate| {\n                 match *predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n-                        match trait_predicate.0.trait_ref.self_ty().sty {\n+                        match trait_predicate.skip_binder().trait_ref.self_ty().sty {\n                             ty::TyParam(ref p) if *p == param_ty => {\n                                 Some(trait_predicate.to_poly_trait_ref())\n                             }\n@@ -1204,7 +1204,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if !selcx.evaluate_obligation(&o) {\n                     result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n-                        possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n+                        possibly_unsatisfied_predicates.push(pred.skip_binder().trait_ref);\n                     }\n                 }\n             }"}, {"sha": "4083d4a21ef4e8414c697d787012f14ae044bb23", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -1727,7 +1727,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n             predicates: self.param_env.caller_bounds.iter().filter(|predicate| {\n                 match **predicate {\n                     ty::Predicate::Trait(ref data) => {\n-                        data.0.self_ty().is_param(index)\n+                        data.skip_binder().self_ty().is_param(index)\n                     }\n                     _ => false\n                 }"}, {"sha": "9c4807bec2f08e3985574a030e1303c1d392c3ac", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -508,7 +508,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n     let self_ty = fcx.tcx.liberate_late_bound_regions(\n         method.def_id,\n-        &ty::Binder(self_ty)\n+        &ty::Binder::bind(self_ty)\n     );\n \n     let self_arg_ty = sig.inputs()[0];\n@@ -517,7 +517,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n     let self_arg_ty = fcx.tcx.liberate_late_bound_regions(\n         method.def_id,\n-        &ty::Binder(self_arg_ty)\n+        &ty::Binder::bind(self_arg_ty)\n     );\n \n     let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();"}, {"sha": "fb8c6ba6401d76f8eebd2b22f65c8e69907d9a21", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -1171,7 +1171,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let inputs = fields.iter().map(|f| {\n                 tcx.type_of(tcx.hir.local_def_id(f.id))\n             });\n-            ty::Binder(tcx.mk_fn_sig(\n+            ty::Binder::bind(tcx.mk_fn_sig(\n                 inputs,\n                 ty,\n                 false,\n@@ -1434,7 +1434,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         for bound in &param.bounds {\n             let bound_region = AstConv::ast_region_to_region(&icx, bound, None);\n-            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n+            let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound_region));\n             predicates.push(outlives.to_predicate());\n         }\n     }\n@@ -1482,7 +1482,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             let region = AstConv::ast_region_to_region(&icx,\n                                                                        lifetime,\n                                                                        None);\n-                            let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n+                            let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n                             predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n                     }\n@@ -1493,7 +1493,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let r1 = AstConv::ast_region_to_region(&icx, &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n                     let r2 = AstConv::ast_region_to_region(&icx, bound, None);\n-                    let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n+                    let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n@@ -1627,7 +1627,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n         }\n         hir::RegionTyParamBound(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n+            let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n             vec![ty::Predicate::TypeOutlives(pred)]\n         }\n         hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {"}, {"sha": "d29ee3d9b3ab118f1cda700f77fb13561abde199", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -212,7 +212,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.mk_nil()\n             };\n \n-            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(\n                 tcx.mk_fn_sig(\n                     iter::empty(),\n                     expected_return_type,\n@@ -261,7 +261,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => ()\n             }\n \n-            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(\n                 tcx.mk_fn_sig(\n                     [\n                         tcx.types.isize,"}, {"sha": "65c78d3593f63488665c71a89f307f8b7435c060", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -258,7 +258,7 @@ fn check_explicit_predicates<'tcx>(\n                 // where OutlivesPredicate<type1, region1> is the predicate\n                 // we want to add.\n                 ty::Predicate::TypeOutlives(poly) => {\n-                    let predicate = poly.0.subst(tcx, substs);\n+                    let predicate = poly.skip_binder().subst(tcx, substs);\n                     insert_outlives_predicate(\n                         tcx,\n                         predicate.0.into(),\n@@ -271,7 +271,7 @@ fn check_explicit_predicates<'tcx>(\n                 // where OutlivesPredicate<region1, region2> is the predicate\n                 // we want to add.\n                 ty::Predicate::RegionOutlives(poly) => {\n-                    let predicate = poly.0.subst(tcx, substs);\n+                    let predicate = poly.skip_binder().subst(tcx, substs);\n                     insert_outlives_predicate(\n                         tcx,\n                         predicate.0.into(),"}, {"sha": "e5af4c606912bf7289066464695a6875e4086bf2", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -89,11 +89,11 @@ fn inferred_outlives_crate<'tcx>(\n             let vec: Vec<ty::Predicate<'tcx>> = set.iter()\n                 .map(\n                     |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n-                        UnpackedKind::Type(ty1) => ty::Predicate::TypeOutlives(ty::Binder(\n+                        UnpackedKind::Type(ty1) => ty::Predicate::TypeOutlives(ty::Binder::bind(\n                             ty::OutlivesPredicate(ty1, region2),\n                         )),\n                         UnpackedKind::Lifetime(region1) => ty::Predicate::RegionOutlives(\n-                            ty::Binder(ty::OutlivesPredicate(region1, region2)),\n+                            ty::Binder::bind(ty::OutlivesPredicate(region1, region2)),\n                         ),\n                     },\n                 )"}, {"sha": "b5e7effa61e8d3bfffba7c0bb86fb1566b9ad556", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -313,11 +313,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 if let Some(p) = data.principal() {\n                     let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(current, poly_trait_ref.0, variance);\n+                    self.add_constraints_from_trait_ref(\n+                        current, *poly_trait_ref.skip_binder(), variance);\n                 }\n \n                 for projection in data.projection_bounds() {\n-                    self.add_constraints_from_ty(current, projection.0.ty, self.invariant);\n+                    self.add_constraints_from_ty(\n+                        current, projection.skip_binder().ty, self.invariant);\n                 }\n             }\n \n@@ -399,10 +401,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                 sig: ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n-        for &input in sig.0.inputs() {\n+        for &input in sig.skip_binder().inputs() {\n             self.add_constraints_from_ty(current, input, contra);\n         }\n-        self.add_constraints_from_ty(current, sig.0.output(), variance);\n+        self.add_constraints_from_ty(current, sig.skip_binder().output(), variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a"}, {"sha": "477b576ad217e47acedd38ecfd1ddc3cf5cc3547", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             substs: tcx.mk_substs_trait(ty, &[]),\n         };\n \n-        let trait_pred = ty::Binder(trait_ref);\n+        let trait_pred = ty::Binder::bind(trait_ref);\n \n         let bail_out = tcx.infer_ctxt().enter(|infcx| {\n             let mut selcx = SelectionContext::with_negative(&infcx, true);\n@@ -622,7 +622,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n         let mut already_visited = FxHashSet();\n         let mut predicates = VecDeque::new();\n-        predicates.push_back(ty::Binder(ty::TraitPredicate {\n+        predicates.push_back(ty::Binder::bind(ty::TraitPredicate {\n             trait_ref: ty::TraitRef {\n                 def_id: trait_did,\n                 substs: infcx.tcx.mk_substs_trait(ty, &[]),"}, {"sha": "e37b3a7fcc4d8757de2b534d04d166d25ae39d81", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -120,7 +120,7 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n \n impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n     fn clean(&self, cx: &DocContext) -> U {\n-        self.0.clean(cx)\n+        self.skip_binder().clean(cx)\n     }\n }\n \n@@ -2846,15 +2846,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     }\n \n                     let mut bindings = vec![];\n-                    for ty::Binder(ref pb) in obj.projection_bounds() {\n+                    for pb in obj.projection_bounds() {\n                         bindings.push(TypeBinding {\n-                            name: cx.tcx.associated_item(pb.item_def_id).name.clean(cx),\n-                            ty: pb.ty.clean(cx)\n+                            name: cx.tcx.associated_item(pb.item_def_id()).name.clean(cx),\n+                            ty: pb.skip_binder().ty.clean(cx)\n                         });\n                     }\n \n                     let path = external_path(cx, &cx.tcx.item_name(did), Some(did),\n-                        false, bindings, principal.0.substs);\n+                        false, bindings, principal.skip_binder().substs);\n                     ResolvedPath {\n                         path,\n                         typarams: Some(typarams),"}, {"sha": "b7767606a6aa48861602c9b81f7e2c10d19088db", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=98546f8b265c7d8dc2346d8bfce3d277dbc3fd5d", "patch": "@@ -154,7 +154,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     let predicates = cx.tcx.super_predicates_of(child).predicates;\n     predicates.iter().filter_map(|pred| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n-            if pred.0.trait_ref.self_ty().is_self() {\n+            if pred.skip_binder().trait_ref.self_ty().is_self() {\n                 Some(pred.def_id())\n             } else {\n                 None"}]}