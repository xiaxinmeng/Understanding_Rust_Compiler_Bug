{"sha": "0825b357d894d1486deecd9294a15da1a32a3441", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MjViMzU3ZDg5NGQxNDg2ZGVlY2Q5Mjk0YTE1ZGExYTMyYTM0NDE=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-11-03T08:39:39Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-11-03T08:39:39Z"}, "message": "librustc_lexer: Add methods \"first\" and \"second\" to the \"Cursor\"", "tree": {"sha": "8a4d816e4c2521d8fd06804165574d99b1b8c018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a4d816e4c2521d8fd06804165574d99b1b8c018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0825b357d894d1486deecd9294a15da1a32a3441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0825b357d894d1486deecd9294a15da1a32a3441", "html_url": "https://github.com/rust-lang/rust/commit/0825b357d894d1486deecd9294a15da1a32a3441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0825b357d894d1486deecd9294a15da1a32a3441/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3d28a49209a21628fda0245b631e5fc3465be1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d28a49209a21628fda0245b631e5fc3465be1a", "html_url": "https://github.com/rust-lang/rust/commit/d3d28a49209a21628fda0245b631e5fc3465be1a"}], "stats": {"total": 50, "additions": 30, "deletions": 20}, "files": [{"sha": "13d0b07d98baeeb345e2f3404aac4bca316872ee", "filename": "src/librustc_lexer/src/cursor.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0825b357d894d1486deecd9294a15da1a32a3441/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0825b357d894d1486deecd9294a15da1a32a3441/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs?ref=0825b357d894d1486deecd9294a15da1a32a3441", "patch": "@@ -45,6 +45,16 @@ impl<'a> Cursor<'a> {\n         self.chars().nth(n).unwrap_or(EOF_CHAR)\n     }\n \n+    /// Peeks the next symbol from the input stream without consuming it.\n+    pub(crate) fn first(&self) -> char {\n+        self.nth_char(0)\n+    }\n+\n+    /// Peeks the second symbol from the input stream without consuming it.\n+    pub(crate) fn second(&self) -> char {\n+        self.nth_char(1)\n+    }\n+\n     /// Checks if there is nothing more to consume.\n     pub(crate) fn is_eof(&self) -> bool {\n         self.chars.as_str().is_empty()"}, {"sha": "6e2e0c44e0a422b39c440669da7fe0c58d8566b6", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0825b357d894d1486deecd9294a15da1a32a3441/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0825b357d894d1486deecd9294a15da1a32a3441/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=0825b357d894d1486deecd9294a15da1a32a3441", "patch": "@@ -248,7 +248,7 @@ impl Cursor<'_> {\n         let first_char = self.bump().unwrap();\n         let token_kind = match first_char {\n             // Slash, comment or block comment.\n-            '/' => match self.nth_char(0) {\n+            '/' => match self.first() {\n                 '/' => self.line_comment(),\n                 '*' => self.block_comment(),\n                 _ => Slash,\n@@ -257,8 +257,8 @@ impl Cursor<'_> {\n             // Whitespace sequence.\n             c if is_whitespace(c) => self.whitespace(),\n \n-            // Raw string literal or identifier.\n-            'r' => match (self.nth_char(0), self.nth_char(1)) {\n+            // Raw identifier, raw string literal or identifier.\n+            'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n                     let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n@@ -273,7 +273,7 @@ impl Cursor<'_> {\n             },\n \n             // Byte literal, byte string literal, raw byte string literal or identifier.\n-            'b' => match (self.nth_char(0), self.nth_char(1)) {\n+            'b' => match (self.first(), self.second()) {\n                 ('\\'', _) => {\n                     self.bump();\n                     let terminated = self.single_quoted_string();\n@@ -366,7 +366,7 @@ impl Cursor<'_> {\n     }\n \n     fn line_comment(&mut self) -> TokenKind {\n-        debug_assert!(self.prev() == '/' && self.nth_char(0) == '/');\n+        debug_assert!(self.prev() == '/' && self.first() == '/');\n         self.bump();\n         loop {\n             match self.nth_char(0) {\n@@ -381,16 +381,16 @@ impl Cursor<'_> {\n     }\n \n     fn block_comment(&mut self) -> TokenKind {\n-        debug_assert!(self.prev() == '/' && self.nth_char(0) == '*');\n+        debug_assert!(self.prev() == '/' && self.first() == '*');\n         self.bump();\n         let mut depth = 1usize;\n         while let Some(c) = self.bump() {\n             match c {\n-                '/' if self.nth_char(0) == '*' => {\n+                '/' if self.first() == '*' => {\n                     self.bump();\n                     depth += 1;\n                 }\n-                '*' if self.nth_char(0) == '/' => {\n+                '*' if self.first() == '/' => {\n                     self.bump();\n                     depth -= 1;\n                     if depth == 0 {\n@@ -418,8 +418,8 @@ impl Cursor<'_> {\n     fn raw_ident(&mut self) -> TokenKind {\n         debug_assert!(\n             self.prev() == 'r'\n-                && self.nth_char(0) == '#'\n-                && is_id_start(self.nth_char(1))\n+                && self.first() == '#'\n+                && is_id_start(self.second())\n         );\n         self.bump();\n         self.bump();\n@@ -442,7 +442,7 @@ impl Cursor<'_> {\n         let mut base = Base::Decimal;\n         if first_digit == '0' {\n             // Attempt to parse encoding base.\n-            let has_digits = match self.nth_char(0) {\n+            let has_digits = match self.first() {\n                 'b' => {\n                     base = Base::Binary;\n                     self.bump();\n@@ -476,20 +476,20 @@ impl Cursor<'_> {\n             self.eat_decimal_digits();\n         };\n \n-        match self.nth_char(0) {\n+        match self.first() {\n             // Don't be greedy if this is actually an\n             // integer literal followed by field/method access or a range pattern\n             // (`0..2` and `12.foo()`)\n-            '.' if self.nth_char(1) != '.'\n-                && !is_id_start(self.nth_char(1)) =>\n+            '.' if self.second() != '.'\n+                && !is_id_start(self.second()) =>\n             {\n                 // might have stuff after the ., and if it does, it needs to start\n                 // with a number\n                 self.bump();\n                 let mut empty_exponent = false;\n-                if self.nth_char(0).is_digit(10) {\n+                if self.first().is_digit(10) {\n                     self.eat_decimal_digits();\n-                    match self.nth_char(0) {\n+                    match self.first() {\n                         'e' | 'E' => {\n                             self.bump();\n                             empty_exponent = self.float_exponent().is_err()\n@@ -556,7 +556,7 @@ impl Cursor<'_> {\n         // Parse until either quotes are terminated or error is detected.\n         let mut first = true;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 // Probably beginning of the comment, which we don't want to include\n                 // to the error report.\n                 '/' if !first => break,\n@@ -643,7 +643,7 @@ impl Cursor<'_> {\n     fn eat_decimal_digits(&mut self) -> bool {\n         let mut has_digits = false;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 '_' => {\n                     self.bump();\n                 }\n@@ -660,7 +660,7 @@ impl Cursor<'_> {\n     fn eat_hexadecimal_digits(&mut self) -> bool {\n         let mut has_digits = false;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 '_' => {\n                     self.bump();\n                 }\n@@ -676,7 +676,7 @@ impl Cursor<'_> {\n \n     fn float_exponent(&mut self) -> Result<(), ()> {\n         debug_assert!(self.prev() == 'e' || self.prev() == 'E');\n-        if self.nth_char(0) == '-' || self.nth_char(0) == '+' {\n+        if self.first() == '-' || self.first() == '+' {\n             self.bump();\n         }\n         if self.eat_decimal_digits() { Ok(()) } else { Err(()) }"}]}