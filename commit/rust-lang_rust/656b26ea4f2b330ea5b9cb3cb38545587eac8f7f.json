{"sha": "656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NmIyNmVhNGYyYjMzMGVhNWI5Y2IzY2IzODU0NTU4N2VhYzhmN2Y=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-28T06:39:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-28T06:39:54Z"}, "message": "Merge pull request #2832 from kennytm/non-copy-const\n\nLint against const items which are interior mutable.", "tree": {"sha": "b8b792dd8131a523a60bda6e425b2ca2105b0f50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8b792dd8131a523a60bda6e425b2ca2105b0f50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbNIK6CRBK7hj4Ov3rIwAAdHIIACJMNMPDhuSFPkrLuLaurJlN\ndTV11SYG9NrbLa3RKOmB6whScvKVjp6CpuJg3RvF273rE2AETvQwg2zYz2St9r3m\n6vGevo9VaTpBOq2exmihp+n8yc3d7HwJ4l5DFx+e57rA+mILstWcT8cLCdtcWwPy\nyfv6ddrbReMWOc9d32fXwZRIrB1n5s/lupCZrCn2bPBM6lSnXVw+TifnZjtMsGQZ\nn+DmLEYjrrV5N1HFpW4MmvUiK6v4PQ8rR/5iaVSdI1lXypDQ/sHrAvty9YqzsCgS\nW8AE1Z1RcVUtCrqWXc/h0udBGqGgCoA2YplkX+v4ymh/NMTPfFYD7Xe51wkxNMY=\n=o0Cs\n-----END PGP SIGNATURE-----\n", "payload": "tree b8b792dd8131a523a60bda6e425b2ca2105b0f50\nparent 296b15e908eb88089b1af09ad5b510f3825c57a3\nparent 88b7603b167dd7cbd03522e37ad9f7dec18cae23\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1530167994 +0200\ncommitter GitHub <noreply@github.com> 1530167994 +0200\n\nMerge pull request #2832 from kennytm/non-copy-const\n\nLint against const items which are interior mutable."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "html_url": "https://github.com/rust-lang/rust/commit/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "296b15e908eb88089b1af09ad5b510f3825c57a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/296b15e908eb88089b1af09ad5b510f3825c57a3", "html_url": "https://github.com/rust-lang/rust/commit/296b15e908eb88089b1af09ad5b510f3825c57a3"}, {"sha": "88b7603b167dd7cbd03522e37ad9f7dec18cae23", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b7603b167dd7cbd03522e37ad9f7dec18cae23", "html_url": "https://github.com/rust-lang/rust/commit/88b7603b167dd7cbd03522e37ad9f7dec18cae23"}], "stats": {"total": 696, "additions": 696, "deletions": 0}, "files": [{"sha": "9fc020b6819f665c14b9c8ba654f3d617117da7d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "patch": "@@ -148,6 +148,7 @@ pub mod neg_cmp_op_on_partial_ord;\n pub mod neg_multiply;\n pub mod new_without_default;\n pub mod no_effect;\n+pub mod non_copy_const;\n pub mod non_expressive_names;\n pub mod ok_if_let;\n pub mod open_options;\n@@ -405,6 +406,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box duration_subsec::DurationSubsec);\n     reg.register_late_lint_pass(box default_trait_access::DefaultTraitAccess);\n     reg.register_late_lint_pass(box indexing_slicing::IndexingSlicing);\n+    reg.register_late_lint_pass(box non_copy_const::NonCopyConst);\n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -613,6 +615,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         new_without_default::NEW_WITHOUT_DEFAULT_DERIVE,\n         no_effect::NO_EFFECT,\n         no_effect::UNNECESSARY_OPERATION,\n+        non_copy_const::BORROW_INTERIOR_MUTABLE_CONST,\n+        non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST,\n         non_expressive_names::JUST_UNDERSCORES_AND_DIGITS,\n         non_expressive_names::MANY_SINGLE_CHAR_NAMES,\n         ok_if_let::IF_LET_SOME_RESULT,\n@@ -868,6 +872,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         misc::CMP_NAN,\n         misc::FLOAT_CMP,\n         misc::MODULO_ONE,\n+        non_copy_const::BORROW_INTERIOR_MUTABLE_CONST,\n+        non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n         ptr::MUT_FROM_REF,\n         ranges::ITERATOR_STEP_BY_ZERO,"}, {"sha": "5fcf54bc015262bb2c385c472c7404da985a1b13", "filename": "clippy_lints/src/non_copy_const.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "patch": "@@ -0,0 +1,268 @@\n+//! Checks for uses of const which the type is not Freeze (Cell-free).\n+//!\n+//! This lint is **deny** by default.\n+\n+use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n+use rustc::hir::*;\n+use rustc::hir::def::Def;\n+use rustc::ty::{self, TyRef, TypeFlags};\n+use rustc::ty::adjustment::Adjust;\n+use rustc_errors::Applicability;\n+use rustc_typeck::hir_ty_to_ty;\n+use syntax_pos::{DUMMY_SP, Span};\n+use std::ptr;\n+use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n+\n+/// **What it does:** Checks for declaration of `const` items which is interior\n+/// mutable (e.g. contains a `Cell`, `Mutex`, `AtomicXxxx` etc).\n+///\n+/// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n+/// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+/// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+/// these types in the first place.\n+///\n+/// The `const` should better be replaced by a `static` item if a global\n+/// variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n+///\n+/// **Known problems:** A \"non-constant\" const item is a legacy way to supply an\n+/// initialized value to downstream `static` items (e.g. the\n+/// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n+/// and this lint should be suppressed.\n+///\n+/// **Example:**\n+/// ```rust\n+/// use std::sync::atomic::{Ordering::SeqCst, AtomicUsize};\n+///\n+/// // Bad.\n+/// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+/// CONST_ATOM.store(6, SeqCst);             // the content of the atomic is unchanged\n+/// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+///\n+/// // Good.\n+/// static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n+/// STATIC_ATOM.store(9, SeqCst);\n+/// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+/// ```\n+declare_clippy_lint! {\n+    pub DECLARE_INTERIOR_MUTABLE_CONST,\n+    correctness,\n+    \"declaring const with interior mutability\"\n+}\n+\n+/// **What it does:** Checks if `const` items which is interior mutable (e.g.\n+/// contains a `Cell`, `Mutex`, `AtomicXxxx` etc) has been borrowed directly.\n+///\n+/// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n+/// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+/// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+/// these types in the first place.\n+///\n+/// The `const` value should be stored inside a `static` item.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// use std::sync::atomic::{Ordering::SeqCst, AtomicUsize};\n+/// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+///\n+/// // Bad.\n+/// CONST_ATOM.store(6, SeqCst);             // the content of the atomic is unchanged\n+/// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+///\n+/// // Good.\n+/// static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n+/// STATIC_ATOM.store(9, SeqCst);\n+/// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+/// ```\n+declare_clippy_lint! {\n+    pub BORROW_INTERIOR_MUTABLE_CONST,\n+    correctness,\n+    \"referencing const with interior mutability\"\n+}\n+\n+#[derive(Copy, Clone)]\n+enum Source {\n+    Item {\n+        item: Span,\n+    },\n+    Assoc {\n+        item: Span,\n+        ty: Span,\n+    },\n+    Expr {\n+        expr: Span,\n+    },\n+}\n+\n+impl Source {\n+    fn lint(&self) -> (&'static Lint, &'static str, Span) {\n+        match self {\n+            Source::Item { item } | Source::Assoc { item, .. } => (\n+                DECLARE_INTERIOR_MUTABLE_CONST,\n+                \"a const item should never be interior mutable\",\n+                *item,\n+            ),\n+            Source::Expr { expr } => (\n+                BORROW_INTERIOR_MUTABLE_CONST,\n+                \"a const item with interior mutability should not be borrowed\",\n+                *expr,\n+            ),\n+        }\n+    }\n+}\n+\n+fn verify_ty_bound<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    source: Source,\n+) {\n+    if ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP) || is_copy(cx, ty) {\n+        // an UnsafeCell is !Copy, and an UnsafeCell is also the only type which\n+        // is !Freeze, thus if our type is Copy we can be sure it must be Freeze\n+        // as well.\n+        return;\n+    }\n+\n+    let (lint, msg, span) = source.lint();\n+    span_lint_and_then(cx, lint, span, msg, |db| {\n+        if in_macro(span) {\n+            return; // Don't give suggestions into macros.\n+        }\n+        match source {\n+            Source::Item { .. } => {\n+                let const_kw_span = span.from_inner_byte_pos(0, 5);\n+                db.span_suggestion_with_applicability(\n+                    const_kw_span,\n+                    \"make this a static item\",\n+                    \"static\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Source::Assoc { ty: ty_span, .. } => {\n+                if ty.flags.contains(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n+                    db.span_help(ty_span, &format!(\"consider requiring `{}` to be `Copy`\", ty));\n+                }\n+            }\n+            Source::Expr { .. } => {\n+                db.help(\n+                    \"assign this const to a local or static variable, and use the variable here\",\n+                );\n+            }\n+        }\n+    });\n+}\n+\n+\n+pub struct NonCopyConst;\n+\n+impl LintPass for NonCopyConst {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DECLARE_INTERIOR_MUTABLE_CONST, BORROW_INTERIOR_MUTABLE_CONST)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx Item) {\n+        if let ItemConst(hir_ty, ..) = &it.node {\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            verify_ty_bound(cx, ty, Source::Item { item: it.span });\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx TraitItem) {\n+        if let TraitItemKind::Const(hir_ty, ..) = &trait_item.node {\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            verify_ty_bound(cx, ty, Source::Assoc { ty: hir_ty.span, item: trait_item.span });\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem) {\n+        if let ImplItemKind::Const(hir_ty, ..) = &impl_item.node {\n+            let item_node_id = cx.tcx.hir.get_parent_node(impl_item.id);\n+            let item = cx.tcx.hir.expect_item(item_node_id);\n+            // ensure the impl is an inherent impl.\n+            if let ItemImpl(_, _, _, _, None, _, _) = item.node {\n+                let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                verify_ty_bound(cx, ty, Source::Assoc { ty: hir_ty.span, item: impl_item.span });\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if let ExprPath(qpath) = &expr.node {\n+            // Only lint if we use the const item inside a function.\n+            if in_constant(cx, expr.id) {\n+                return;\n+            }\n+\n+            // make sure it is a const item.\n+            match cx.tables.qpath_def(qpath, expr.hir_id) {\n+                Def::Const(_) | Def::AssociatedConst(_) => {},\n+                _ => return,\n+            };\n+\n+            // climb up to resolve any field access and explicit referencing.\n+            let mut cur_expr = expr;\n+            let mut dereferenced_expr = expr;\n+            let mut needs_check_adjustment = true;\n+            loop {\n+                let parent_id = cx.tcx.hir.get_parent_node(cur_expr.id);\n+                if parent_id == cur_expr.id {\n+                    break;\n+                }\n+                if let Some(map::NodeExpr(parent_expr)) = cx.tcx.hir.find(parent_id) {\n+                    match &parent_expr.node {\n+                        ExprAddrOf(..) => {\n+                            // `&e` => `e` must be referenced\n+                            needs_check_adjustment = false;\n+                        }\n+                        ExprField(..) => {\n+                            dereferenced_expr = parent_expr;\n+                            needs_check_adjustment = true;\n+                        }\n+                        ExprIndex(e, _) if ptr::eq(&**e, cur_expr) => {\n+                            // `e[i]` => desugared to `*Index::index(&e, i)`,\n+                            // meaning `e` must be referenced.\n+                            // no need to go further up since a method call is involved now.\n+                            needs_check_adjustment = false;\n+                            break;\n+                        }\n+                        ExprUnary(UnDeref, _) => {\n+                            // `*e` => desugared to `*Deref::deref(&e)`,\n+                            // meaning `e` must be referenced.\n+                            // no need to go further up since a method call is involved now.\n+                            needs_check_adjustment = false;\n+                            break;\n+                        }\n+                        _ => break,\n+                    }\n+                    cur_expr = parent_expr;\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            let ty = if !needs_check_adjustment {\n+                cx.tables.expr_ty(dereferenced_expr)\n+            } else {\n+                let adjustments = cx.tables.expr_adjustments(dereferenced_expr);\n+                if let Some(i) = adjustments.iter().position(|adj| match adj.kind {\n+                    Adjust::Borrow(_) | Adjust::Deref(_) => true,\n+                    _ => false,\n+                }) {\n+                    if i == 0 {\n+                        cx.tables.expr_ty(dereferenced_expr)\n+                    } else {\n+                        adjustments[i - 1].target\n+                    }\n+                } else {\n+                    // No borrow adjustments = the entire const is moved.\n+                    return;\n+                }\n+            };\n+\n+            verify_ty_bound(cx, ty, Source::Expr { expr: expr.span });\n+        }\n+    }\n+}"}, {"sha": "d7391577d23ae04583519bef649c651c2733e307", "filename": "tests/ui/non_copy_const.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/tests%2Fui%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/tests%2Fui%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_copy_const.rs?ref=656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "patch": "@@ -0,0 +1,147 @@\n+#![feature(const_string_new, const_vec_new)]\n+#![allow(ref_in_deref, dead_code)]\n+\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize, Ordering};\n+use std::cell::Cell;\n+use std::sync::Once;\n+use std::borrow::Cow;\n+use std::fmt::Display;\n+\n+const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n+const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n+const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n+//~^ ERROR interior mutable\n+\n+macro_rules! declare_const {\n+    ($name:ident: $ty:ty = $e:expr) => { const $name: $ty = $e; };\n+}\n+declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n+\n+// const ATOMIC_REF: &AtomicUsize = &AtomicUsize::new(7); // This will simply trigger E0492.\n+\n+const INTEGER: u8 = 8;\n+const STRING: String = String::new();\n+const STR: &str = \"012345\";\n+const COW: Cow<str> = Cow::Borrowed(\"abcdef\");\n+//^ note: a const item of Cow is used in the `postgres` package.\n+\n+const NO_ANN: &Display = &70;\n+\n+static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n+//^ there should be no lints on this line\n+\n+#[allow(declare_interior_mutable_const)]\n+const ONCE_INIT: Once = Once::new();\n+\n+trait Trait<T>: Copy {\n+    type NonCopyType;\n+\n+    const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n+    const INTEGER: u64;\n+    const STRING: String;\n+    const SELF: Self; // (no error)\n+    const INPUT: T;\n+    //~^ ERROR interior mutable\n+    //~| HELP consider requiring `T` to be `Copy`\n+    const ASSOC: Self::NonCopyType;\n+    //~^ ERROR interior mutable\n+    //~| HELP consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+\n+    const AN_INPUT: T = Self::INPUT;\n+    //~^ ERROR interior mutable\n+    //~| ERROR consider requiring `T` to be `Copy`\n+    declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n+}\n+\n+trait Trait2 {\n+    type CopyType: Copy;\n+\n+    const SELF_2: Self;\n+    //~^ ERROR interior mutable\n+    //~| HELP consider requiring `Self` to be `Copy`\n+    const ASSOC_2: Self::CopyType; // (no error)\n+}\n+\n+// we don't lint impl of traits, because an impl has no power to change the interface.\n+impl Trait<u32> for u64 {\n+    type NonCopyType = u16;\n+\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const INTEGER: u64 = 10;\n+    const STRING: String = String::new();\n+    const SELF: Self = 11;\n+    const INPUT: u32 = 12;\n+    const ASSOC: Self::NonCopyType = 13;\n+}\n+\n+struct Local<T, U>(T, U);\n+\n+impl<T: Trait2 + Trait<u32>, U: Trait2> Local<T, U> {\n+    const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n+    const COW: Cow<'static, str> = Cow::Borrowed(\"tuvwxy\");\n+    const T_SELF: T = T::SELF_2;\n+    const U_SELF: U = U::SELF_2;\n+    //~^ ERROR interior mutable\n+    //~| HELP consider requiring `U` to be `Copy`\n+    const T_ASSOC: T::NonCopyType = T::ASSOC;\n+    //~^ ERROR interior mutable\n+    //~| HELP consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n+    const U_ASSOC: U::CopyType = U::ASSOC_2;\n+}\n+\n+fn main() {\n+    ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n+    assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n+\n+    ATOMIC_USIZE_INIT.store(2, Ordering::SeqCst); //~ ERROR interior mutability\n+    assert_eq!(ATOMIC_USIZE_INIT.load(Ordering::SeqCst), 0); //~ ERROR interior mutability\n+\n+    let _once = ONCE_INIT;\n+    let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n+    let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n+    let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n+    let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n+    let _atomic_into_inner = ATOMIC.into_inner();\n+    // these should be all fine.\n+    let _twice = (ONCE_INIT, ONCE_INIT);\n+    let _ref_twice = &(ONCE_INIT, ONCE_INIT);\n+    let _ref_once = &(ONCE_INIT, ONCE_INIT).0;\n+    let _array_twice = [ONCE_INIT, ONCE_INIT];\n+    let _ref_array_twice = &[ONCE_INIT, ONCE_INIT];\n+    let _ref_array_once = &[ONCE_INIT, ONCE_INIT][0];\n+\n+    // referencing projection is still bad.\n+    let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n+    let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n+    let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n+    let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n+    let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n+    let _ = &*ATOMIC_TUPLE.1; //~ ERROR interior mutability\n+    let _ = &ATOMIC_TUPLE.2;\n+    let _ = (&&&&ATOMIC_TUPLE).0;\n+    let _ = (&&&&ATOMIC_TUPLE).2;\n+    let _ = ATOMIC_TUPLE.0;\n+    let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n+    let _ = ATOMIC_TUPLE.1.into_iter();\n+    let _ = ATOMIC_TUPLE.2;\n+    let _ = &{ATOMIC_TUPLE};\n+\n+    CELL.set(2); //~ ERROR interior mutability\n+    assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n+\n+    assert_eq!(INTEGER, 8);\n+    assert!(STRING.is_empty());\n+\n+    let a = ATOMIC;\n+    a.store(4, Ordering::SeqCst);\n+    assert_eq!(a.load(Ordering::SeqCst), 4);\n+\n+    STATIC_TUPLE.0.store(3, Ordering::SeqCst);\n+    assert_eq!(STATIC_TUPLE.0.load(Ordering::SeqCst), 3);\n+    assert!(STATIC_TUPLE.1.is_empty());\n+\n+    u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n+    assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n+\n+    assert_eq!(NO_ANN.to_string(), \"70\"); // should never lint this.\n+}"}, {"sha": "388c7fabab0e286e308dc8de86876d8f897d8ec9", "filename": "tests/ui/non_copy_const.stderr", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/tests%2Fui%2Fnon_copy_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f/tests%2Fui%2Fnon_copy_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_copy_const.stderr?ref=656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "patch": "@@ -0,0 +1,275 @@\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:10:1\n+   |\n+10 | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | help: make this a static item: `static`\n+   |\n+   = note: #[deny(declare_interior_mutable_const)] on by default\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:11:1\n+   |\n+11 | const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | help: make this a static item: `static`\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:12:1\n+   |\n+12 | const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | help: make this a static item: `static`\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:16:42\n+   |\n+16 |     ($name:ident: $ty:ty = $e:expr) => { const $name: $ty = $e; };\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^\n+17 | }\n+18 | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n+   | ------------------------------------------ in this macro invocation\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:39:5\n+   |\n+39 |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:43:5\n+   |\n+43 |     const INPUT: T;\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+help: consider requiring `T` to be `Copy`\n+  --> $DIR/non_copy_const.rs:43:18\n+   |\n+43 |     const INPUT: T;\n+   |                  ^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:46:5\n+   |\n+46 |     const ASSOC: Self::NonCopyType;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+  --> $DIR/non_copy_const.rs:46:18\n+   |\n+46 |     const ASSOC: Self::NonCopyType;\n+   |                  ^^^^^^^^^^^^^^^^^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:50:5\n+   |\n+50 |     const AN_INPUT: T = Self::INPUT;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider requiring `T` to be `Copy`\n+  --> $DIR/non_copy_const.rs:50:21\n+   |\n+50 |     const AN_INPUT: T = Self::INPUT;\n+   |                     ^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:16:42\n+   |\n+16 |     ($name:ident: $ty:ty = $e:expr) => { const $name: $ty = $e; };\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+53 |     declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n+   |     ----------------------------------------------- in this macro invocation\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:59:5\n+   |\n+59 |     const SELF_2: Self;\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider requiring `Self` to be `Copy`\n+  --> $DIR/non_copy_const.rs:59:19\n+   |\n+59 |     const SELF_2: Self;\n+   |                   ^^^^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:80:5\n+   |\n+80 |     const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:83:5\n+   |\n+83 |     const U_SELF: U = U::SELF_2;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider requiring `U` to be `Copy`\n+  --> $DIR/non_copy_const.rs:83:19\n+   |\n+83 |     const U_SELF: U = U::SELF_2;\n+   |                   ^\n+\n+error: a const item should never be interior mutable\n+  --> $DIR/non_copy_const.rs:86:5\n+   |\n+86 |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n+  --> $DIR/non_copy_const.rs:86:20\n+   |\n+86 |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n+   |                    ^^^^^^^^^^^^^^\n+\n+error: a const item with interior mutability should not be borrowed\n+  --> $DIR/non_copy_const.rs:93:5\n+   |\n+93 |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n+   |     ^^^^^^\n+   |\n+   = note: #[deny(borrow_interior_mutable_const)] on by default\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+  --> $DIR/non_copy_const.rs:94:16\n+   |\n+94 |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n+   |                ^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+  --> $DIR/non_copy_const.rs:96:5\n+   |\n+96 |     ATOMIC_USIZE_INIT.store(2, Ordering::SeqCst); //~ ERROR interior mutability\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+  --> $DIR/non_copy_const.rs:97:16\n+   |\n+97 |     assert_eq!(ATOMIC_USIZE_INIT.load(Ordering::SeqCst), 0); //~ ERROR interior mutability\n+   |                ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:100:22\n+    |\n+100 |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n+    |                      ^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:101:25\n+    |\n+101 |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n+    |                         ^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:102:27\n+    |\n+102 |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n+    |                           ^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:103:26\n+    |\n+103 |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n+    |                          ^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:114:14\n+    |\n+114 |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n+    |              ^^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:115:14\n+    |\n+115 |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n+    |              ^^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:116:19\n+    |\n+116 |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n+    |                   ^^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:117:14\n+    |\n+117 |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n+    |              ^^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:118:13\n+    |\n+118 |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n+    |             ^^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:124:13\n+    |\n+124 |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n+    |             ^^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:129:5\n+    |\n+129 |     CELL.set(2); //~ ERROR interior mutability\n+    |     ^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:130:16\n+    |\n+130 |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n+    |                ^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:143:5\n+    |\n+143 |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n+    |     ^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a const item with interior mutability should not be borrowed\n+   --> $DIR/non_copy_const.rs:144:16\n+    |\n+144 |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n+    |                ^^^^^^^^^^^\n+    |\n+    = help: assign this const to a local or static variable, and use the variable here\n+\n+error: aborting due to 31 previous errors\n+"}]}