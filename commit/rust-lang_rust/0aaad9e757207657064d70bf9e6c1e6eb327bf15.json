{"sha": "0aaad9e757207657064d70bf9e6c1e6eb327bf15", "node_id": "C_kwDOAAsO6NoAKDBhYWFkOWU3NTcyMDc2NTcwNjRkNzBiZjllNmMxZTZlYjMyN2JmMTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-09T10:24:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-09T10:24:27Z"}, "message": "Auto merge of #102565 - jyn514:refactor-build-manifest, r=Mark-Simulacrum\n\nRefactor build-manifest to minimize the number of changes needed to add a new component\n\n- Add all components to `PkgType`\n- Automate functionality wherever possible, so functions often don't have to be manually edited\n- Where that's not possible, use exhaustive matches on `PkgType` instead of adding individual strings.\n- Add documentation for how to add a component. Improve the existing documentation for how to test changes.\n\nI tested locally that this generates an identical manifest before and after my change, as follows:\n```sh\ngit checkout d44e14225ab00e164aa9ea9e8d9e1bee40f96b3e\ncargo +nightly run --manifest-path src/tools/build-manifest/Cargo.toml build/dist build/manifest-before 1970-01-01 http://example.com nightly\ngit checkout refactor-build-manifest\ncargo +nightly run --manifest-path src/tools/build-manifest/Cargo.toml build/dist build/manifest-before 1970-01-01 http://example.com nightly\nsort -u build/manifest-before/channel-rust-nightly.toml | diff - <(sort -u build/manifest-after/channel-rust-nightly.toml)\n```\nI then verified by hand that the differences before sorting are inconsequential (mostly targets being slightly reordered).\n\nThe only change in behavior is that `llvm-tools` is now properly renamed to `llvm-tools-preview`:\n```\n; sort -u build/manifest-before/channel-rust-nightly.toml | diff - <(sort -u build/manifest-after/channel-rust-nightly.toml)\n784a785\n> [renames.llvm-tools]\n894a896\n> to = \"llvm-tools-preview\"\n```\n\nThis is based on https://github.com/rust-lang/rust/pull/102241 and should not be merged before.", "tree": {"sha": "e2616562465ccbb4666b4ac5ec8f92f53d4e8dcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2616562465ccbb4666b4ac5ec8f92f53d4e8dcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aaad9e757207657064d70bf9e6c1e6eb327bf15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aaad9e757207657064d70bf9e6c1e6eb327bf15", "html_url": "https://github.com/rust-lang/rust/commit/0aaad9e757207657064d70bf9e6c1e6eb327bf15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aaad9e757207657064d70bf9e6c1e6eb327bf15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d22c43389da86abba64fbed8b4a7e2ba8a1a7c10", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22c43389da86abba64fbed8b4a7e2ba8a1a7c10", "html_url": "https://github.com/rust-lang/rust/commit/d22c43389da86abba64fbed8b4a7e2ba8a1a7c10"}, {"sha": "8810174a16a72d6fa4bf1322adb54acda0f40b27", "url": "https://api.github.com/repos/rust-lang/rust/commits/8810174a16a72d6fa4bf1322adb54acda0f40b27", "html_url": "https://github.com/rust-lang/rust/commit/8810174a16a72d6fa4bf1322adb54acda0f40b27"}], "stats": {"total": 389, "additions": 208, "deletions": 181}, "files": [{"sha": "9d30c554186be1f6bd109170f1adbc07f8846502", "filename": "src/tools/build-manifest/README.md", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FREADME.md?ref=0aaad9e757207657064d70bf9e6c1e6eb327bf15", "patch": "@@ -1,27 +1,33 @@\n # build-manifest\n \n-This tool generates the manifests uploaded to static.rust-lang.org and used by\n-rustup. The tool is invoked by the bootstrap tool.\n+This tool generates the manifests uploaded to static.rust-lang.org and used by rustup.\n+You can see a full list of all manifests at <https://static.rust-lang.org/manifests.txt>.\n+This listing is updated by <https://github.com/rust-lang/generate-manifest-list> every 7 days.\n+\n+This gets called by `promote-release` <https://github.com/rust-lang/promote-release> via `x.py dist hash-and-sign`.\n+\n+## Adding a new component\n+\n+1. Add a new `Step` to `dist.rs`. This should usually be named after the filename of the uploaded tarball. See https://github.com/rust-lang/rust/pull/101799/files#diff-2c56335faa24486df09ba392d8900c57e2fac4633e1f7038469bcf9ed3feb871 for an example.\n+    a. If appropriate, call `tarball.is_preview(true)` for the component.\n+2. Add a new `PkgType` to build-manifest. Fix all the compile errors as appropriate.\n \n ## Testing changes locally\n \n In order to test the changes locally you need to have a valid dist directory\n available locally. If you don't want to build all the compiler, you can easily\n create one from the nightly artifacts with:\n \n-```\n-#!/bin/bash\n-for cmpn in rust rustc rust-std rust-docs cargo; do\n-    wget https://static.rust-lang.org/dist/${cmpn}-nightly-x86_64-unknown-linux-gnu.tar.gz\n+```sh\n+for component in rust rustc rust-std rust-docs cargo; do\n+    wget -P build/dist https://static.rust-lang.org/dist/${component}-nightly-x86_64-unknown-linux-gnu.tar.gz\n done\n ```\n \n-Then, you can generate the manifest and all the packages from `path/to/dist` to\n-`path/to/output` with:\n+Then, you can generate the manifest and all the packages from `build/dist` to\n+`build/manifest` with:\n \n+```sh\n+mkdir -p build/manifest\n+cargo +nightly run --release -p build-manifest build/dist build/manifest 1970-01-01 http://example.com nightly\n ```\n-$ cargo +nightly run path/to/dist path/to/output 1970-01-01 http://example.com CHANNEL\n-```\n-\n-Remember to replace `CHANNEL` with the channel you produced dist artifacts of\n-and `VERSION` with the current Rust version."}, {"sha": "371e60f969e5891174d8dce79a08aa101329faad", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 92, "deletions": 120, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=0aaad9e757207657064d70bf9e6c1e6eb327bf15", "patch": "@@ -1,8 +1,4 @@\n-//! Build a dist manifest, hash and sign everything.\n-//! This gets called by `promote-release`\n-//! (https://github.com/rust-lang/rust-central-station/tree/master/promote-release)\n-//! via `x.py dist hash-and-sign`; the cmdline arguments are set up\n-//! by rustbuild (in `src/bootstrap/dist.rs`).\n+#![doc = include_str!(\"../README.md\")]\n \n mod checksum;\n mod manifest;\n@@ -184,7 +180,7 @@ static PKG_INSTALLERS: &[&str] = &[\"x86_64-apple-darwin\", \"aarch64-apple-darwin\"\n \n static MINGW: &[&str] = &[\"i686-pc-windows-gnu\", \"x86_64-pc-windows-gnu\"];\n \n-static NIGHTLY_ONLY_COMPONENTS: &[&str] = &[\"miri-preview\", \"rust-docs-json-preview\"];\n+static NIGHTLY_ONLY_COMPONENTS: &[PkgType] = &[PkgType::Miri, PkgType::JsonDocs];\n \n macro_rules! t {\n     ($e:expr) => {\n@@ -287,28 +283,9 @@ impl Builder {\n     }\n \n     fn add_packages_to(&mut self, manifest: &mut Manifest) {\n-        macro_rules! package {\n-            ($name:expr, $targets:expr) => {\n-                self.package($name, &mut manifest.pkg, $targets, &[])\n-            };\n+        for pkg in PkgType::all() {\n+            self.package(pkg, &mut manifest.pkg);\n         }\n-        package!(\"rustc\", HOSTS);\n-        package!(\"rustc-dev\", HOSTS);\n-        package!(\"reproducible-artifacts\", HOSTS);\n-        package!(\"rustc-docs\", HOSTS);\n-        package!(\"cargo\", HOSTS);\n-        package!(\"rust-mingw\", MINGW);\n-        package!(\"rust-std\", TARGETS);\n-        self.package(\"rust-docs\", &mut manifest.pkg, HOSTS, DOCS_FALLBACK);\n-        self.package(\"rust-docs-json-preview\", &mut manifest.pkg, HOSTS, DOCS_FALLBACK);\n-        package!(\"rust-src\", &[\"*\"]);\n-        package!(\"rls-preview\", HOSTS);\n-        package!(\"rust-analyzer-preview\", HOSTS);\n-        package!(\"clippy-preview\", HOSTS);\n-        package!(\"miri-preview\", HOSTS);\n-        package!(\"rustfmt-preview\", HOSTS);\n-        package!(\"rust-analysis\", TARGETS);\n-        package!(\"llvm-tools-preview\", TARGETS);\n     }\n \n     fn add_artifacts_to(&mut self, manifest: &mut Manifest) {\n@@ -333,44 +310,28 @@ impl Builder {\n     }\n \n     fn add_profiles_to(&mut self, manifest: &mut Manifest) {\n-        let mut profile = |name, pkgs| self.profile(name, &mut manifest.profiles, pkgs);\n-        profile(\"minimal\", &[\"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\"]);\n-        profile(\n-            \"default\",\n-            &[\n-                \"rustc\",\n-                \"cargo\",\n-                \"rust-std\",\n-                \"rust-mingw\",\n-                \"rust-docs\",\n-                \"rustfmt-preview\",\n-                \"clippy-preview\",\n-            ],\n-        );\n-        profile(\n-            \"complete\",\n-            &[\n-                \"rustc\",\n-                \"cargo\",\n-                \"rust-std\",\n-                \"rust-mingw\",\n-                \"rust-docs\",\n-                \"rustfmt-preview\",\n-                \"clippy-preview\",\n-                \"rls-preview\",\n-                \"rust-analyzer-preview\",\n-                \"rust-src\",\n-                \"llvm-tools-preview\",\n-                \"rust-analysis\",\n-                \"miri-preview\",\n-            ],\n-        );\n+        use PkgType::*;\n+\n+        let mut profile = |name, pkgs: &_| self.profile(name, &mut manifest.profiles, pkgs);\n+\n+        // Use a Vec here to make sure we don't exclude any components in an earlier profile.\n+        let minimal = vec![Rustc, Cargo, RustStd, RustMingw];\n+        profile(\"minimal\", &minimal);\n+\n+        let mut default = minimal;\n+        default.extend([HtmlDocs, Rustfmt, Clippy]);\n+        profile(\"default\", &default);\n+\n+        // NOTE: this profile is effectively deprecated; do not add new components to it.\n+        let mut complete = default;\n+        complete.extend([Rls, RustAnalyzer, RustSrc, LlvmTools, RustAnalysis, Miri]);\n+        profile(\"complete\", &complete);\n \n         // The compiler libraries are not stable for end users, and they're also huge, so we only\n         // `rustc-dev` for nightly users, and only in the \"complete\" profile. It's still possible\n         // for users to install the additional component manually, if needed.\n         if self.versions.channel() == \"nightly\" {\n-            self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-dev\"]);\n+            self.extend_profile(\"complete\", &mut manifest.profiles, &[RustcDev]);\n             // Do not include the rustc-docs component for now, as it causes\n             // conflicts with the rust-docs component when installed. See\n             // #75833.\n@@ -382,12 +343,11 @@ impl Builder {\n         let mut rename = |from: &str, to: &str| {\n             manifest.renames.insert(from.to_owned(), Rename { to: to.to_owned() })\n         };\n-        rename(\"rls\", \"rls-preview\");\n-        rename(\"rustfmt\", \"rustfmt-preview\");\n-        rename(\"clippy\", \"clippy-preview\");\n-        rename(\"miri\", \"miri-preview\");\n-        rename(\"rust-docs-json\", \"rust-docs-json-preview\");\n-        rename(\"rust-analyzer\", \"rust-analyzer-preview\");\n+        for pkg in PkgType::all() {\n+            if pkg.is_preview() {\n+                rename(pkg.tarball_component_name(), &pkg.manifest_component_name());\n+            }\n+        }\n     }\n \n     fn rust_package(&mut self, manifest: &Manifest) -> Package {\n@@ -419,42 +379,52 @@ impl Builder {\n         let mut components = Vec::new();\n         let mut extensions = Vec::new();\n \n-        let host_component = |pkg| Component::from_str(pkg, host);\n-\n-        // rustc/rust-std/cargo/docs are all required,\n-        // and so is rust-mingw if it's available for the target.\n-        components.extend(vec![\n-            host_component(\"rustc\"),\n-            host_component(\"rust-std\"),\n-            host_component(\"cargo\"),\n-            host_component(\"rust-docs\"),\n-        ]);\n-        if host.contains(\"pc-windows-gnu\") {\n-            components.push(host_component(\"rust-mingw\"));\n-        }\n+        let host_component = |pkg: &_| Component::from_pkg(pkg, host);\n \n-        // Tools are always present in the manifest,\n-        // but might be marked as unavailable if they weren't built.\n-        extensions.extend(vec![\n-            host_component(\"clippy-preview\"),\n-            host_component(\"miri-preview\"),\n-            host_component(\"rls-preview\"),\n-            host_component(\"rust-analyzer-preview\"),\n-            host_component(\"rustfmt-preview\"),\n-            host_component(\"llvm-tools-preview\"),\n-            host_component(\"rust-analysis\"),\n-            host_component(\"rust-docs-json-preview\"),\n-        ]);\n-\n-        extensions.extend(\n-            TARGETS\n-                .iter()\n-                .filter(|&&target| target != host)\n-                .map(|target| Component::from_str(\"rust-std\", target)),\n-        );\n-        extensions.extend(HOSTS.iter().map(|target| Component::from_str(\"rustc-dev\", target)));\n-        extensions.extend(HOSTS.iter().map(|target| Component::from_str(\"rustc-docs\", target)));\n-        extensions.push(Component::from_str(\"rust-src\", \"*\"));\n+        for pkg in PkgType::all() {\n+            match pkg {\n+                // rustc/rust-std/cargo/docs are all required\n+                PkgType::Rustc | PkgType::Cargo | PkgType::HtmlDocs => {\n+                    components.push(host_component(pkg));\n+                }\n+                PkgType::RustStd => {\n+                    components.push(host_component(pkg));\n+                    extensions.extend(\n+                        TARGETS\n+                            .iter()\n+                            .filter(|&&target| target != host)\n+                            .map(|target| Component::from_pkg(pkg, target)),\n+                    );\n+                }\n+                // so is rust-mingw if it's available for the target\n+                PkgType::RustMingw => {\n+                    if host.contains(\"pc-windows-gnu\") {\n+                        components.push(host_component(pkg));\n+                    }\n+                }\n+                // Tools are always present in the manifest,\n+                // but might be marked as unavailable if they weren't built.\n+                PkgType::Clippy\n+                | PkgType::Miri\n+                | PkgType::Rls\n+                | PkgType::RustAnalyzer\n+                | PkgType::Rustfmt\n+                | PkgType::LlvmTools\n+                | PkgType::RustAnalysis\n+                | PkgType::JsonDocs => {\n+                    extensions.push(host_component(pkg));\n+                }\n+                PkgType::RustcDev | PkgType::RustcDocs => {\n+                    extensions.extend(HOSTS.iter().map(|target| Component::from_pkg(pkg, target)));\n+                }\n+                PkgType::RustSrc => {\n+                    extensions.push(Component::from_pkg(pkg, \"*\"));\n+                }\n+                PkgType::Rust => {}\n+                // NOTE: this is intentional, these artifacts aren't intended to be used with rustup\n+                PkgType::ReproducibleArtifacts => {}\n+            }\n+        }\n \n         // If the components/extensions don't actually exist for this\n         // particular host/target combination then nix it entirely from our\n@@ -481,43 +451,44 @@ impl Builder {\n         &mut self,\n         profile_name: &str,\n         dst: &mut BTreeMap<String, Vec<String>>,\n-        pkgs: &[&str],\n+        pkgs: &[PkgType],\n     ) {\n-        dst.insert(profile_name.to_owned(), pkgs.iter().map(|s| (*s).to_owned()).collect());\n+        dst.insert(\n+            profile_name.to_owned(),\n+            pkgs.iter().map(|s| s.manifest_component_name()).collect(),\n+        );\n     }\n \n     fn extend_profile(\n         &mut self,\n         profile_name: &str,\n         dst: &mut BTreeMap<String, Vec<String>>,\n-        pkgs: &[&str],\n+        pkgs: &[PkgType],\n     ) {\n         dst.get_mut(profile_name)\n             .expect(\"existing profile\")\n-            .extend(pkgs.iter().map(|s| (*s).to_owned()));\n+            .extend(pkgs.iter().map(|s| s.manifest_component_name()));\n     }\n \n-    fn package(\n-        &mut self,\n-        pkgname: &str,\n-        dst: &mut BTreeMap<String, Package>,\n-        targets: &[&str],\n-        fallback: &[(&str, &str)],\n-    ) {\n-        let version_info = self\n-            .versions\n-            .version(&PkgType::from_component(pkgname))\n-            .expect(\"failed to load package version\");\n+    fn package(&mut self, pkg: &PkgType, dst: &mut BTreeMap<String, Package>) {\n+        if *pkg == PkgType::Rust {\n+            // This is handled specially by `rust_package` later.\n+            // Order is important, so don't call `rust_package` here.\n+            return;\n+        }\n+\n+        let fallback = if pkg.use_docs_fallback() { DOCS_FALLBACK } else { &[] };\n+        let version_info = self.versions.version(&pkg).expect(\"failed to load package version\");\n         let mut is_present = version_info.present;\n \n         // Never ship nightly-only components for other trains.\n-        if self.versions.channel() != \"nightly\" && NIGHTLY_ONLY_COMPONENTS.contains(&pkgname) {\n+        if self.versions.channel() != \"nightly\" && NIGHTLY_ONLY_COMPONENTS.contains(&pkg) {\n             is_present = false; // Pretend the component is entirely missing.\n         }\n \n         macro_rules! tarball_name {\n             ($target_name:expr) => {\n-                self.versions.tarball_name(&PkgType::from_component(pkgname), $target_name).unwrap()\n+                self.versions.tarball_name(pkg, $target_name).unwrap()\n             };\n         }\n         let mut target_from_compressed_tar = |target_name| {\n@@ -546,7 +517,8 @@ impl Builder {\n             Target::unavailable()\n         };\n \n-        let targets = targets\n+        let targets = pkg\n+            .targets()\n             .iter()\n             .map(|name| {\n                 let target = if is_present {\n@@ -561,7 +533,7 @@ impl Builder {\n             .collect();\n \n         dst.insert(\n-            pkgname.to_string(),\n+            pkg.manifest_component_name(),\n             Package {\n                 version: version_info.version.unwrap_or_default(),\n                 git_commit_hash: version_info.git_commit,"}, {"sha": "a9f19d8e5653f35157f736c3e128f16be290a256", "filename": "src/tools/build-manifest/src/manifest.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmanifest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmanifest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmanifest.rs?ref=0aaad9e757207657064d70bf9e6c1e6eb327bf15", "patch": "@@ -1,3 +1,4 @@\n+use crate::versions::PkgType;\n use crate::Builder;\n use serde::{Serialize, Serializer};\n use std::collections::BTreeMap;\n@@ -116,8 +117,8 @@ pub(crate) struct Component {\n }\n \n impl Component {\n-    pub(crate) fn from_str(pkg: &str, target: &str) -> Self {\n-        Self { pkg: pkg.to_string(), target: target.to_string() }\n+    pub(crate) fn from_pkg(pkg: &PkgType, target: &str) -> Self {\n+        Self { pkg: pkg.manifest_component_name(), target: target.to_string() }\n     }\n }\n "}, {"sha": "dde9745afb78564b9319c62894459ea0d40ec0fe", "filename": "src/tools/build-manifest/src/versions.rs", "status": "modified", "additions": 94, "deletions": 46, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaad9e757207657064d70bf9e6c1e6eb327bf15/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fversions.rs?ref=0aaad9e757207657064d70bf9e6c1e6eb327bf15", "patch": "@@ -8,55 +8,63 @@ use tar::Archive;\n \n const DEFAULT_TARGET: &str = \"x86_64-unknown-linux-gnu\";\n \n-#[derive(Debug, Hash, Eq, PartialEq, Clone)]\n-pub(crate) enum PkgType {\n-    Rust,\n-    RustSrc,\n-    Rustc,\n-    Cargo,\n-    Rls,\n-    RustAnalyzer,\n-    Clippy,\n-    Rustfmt,\n-    LlvmTools,\n-    Miri,\n-    JsonDocs,\n-    Other(String),\n-}\n+macro_rules! pkg_type {\n+    ( $($variant:ident = $component:literal $(; preview = true $(@$is_preview:tt)? )? ),+ $(,)? ) => {\n+        #[derive(Debug, Hash, Eq, PartialEq, Clone)]\n+        pub(crate) enum PkgType {\n+            $($variant,)+\n+        }\n \n-impl PkgType {\n-    pub(crate) fn from_component(component: &str) -> Self {\n-        match component {\n-            \"rust\" => PkgType::Rust,\n-            \"rust-src\" => PkgType::RustSrc,\n-            \"rustc\" => PkgType::Rustc,\n-            \"cargo\" => PkgType::Cargo,\n-            \"rls\" | \"rls-preview\" => PkgType::Rls,\n-            \"rust-analyzer\" | \"rust-analyzer-preview\" => PkgType::RustAnalyzer,\n-            \"clippy\" | \"clippy-preview\" => PkgType::Clippy,\n-            \"rustfmt\" | \"rustfmt-preview\" => PkgType::Rustfmt,\n-            \"llvm-tools\" | \"llvm-tools-preview\" => PkgType::LlvmTools,\n-            \"miri\" | \"miri-preview\" => PkgType::Miri,\n-            \"rust-docs-json\" | \"rust-docs-json-preview\" => PkgType::JsonDocs,\n-            other => PkgType::Other(other.into()),\n+        impl PkgType {\n+            pub(crate) fn is_preview(&self) -> bool {\n+                match self {\n+                    $( $( $($is_preview)? PkgType::$variant => true, )? )+\n+                    _ => false,\n+                }\n+            }\n+\n+            /// First part of the tarball name.\n+            pub(crate) fn tarball_component_name(&self) -> &str {\n+                match self {\n+                    $( PkgType::$variant => $component,)+\n+                }\n+            }\n+\n+            pub(crate) fn all() -> &'static [PkgType] {\n+                &[ $(PkgType::$variant),+ ]\n+            }\n         }\n     }\n+}\n \n-    /// First part of the tarball name.\n-    fn tarball_component_name(&self) -> &str {\n-        match self {\n-            PkgType::Rust => \"rust\",\n-            PkgType::RustSrc => \"rust-src\",\n-            PkgType::Rustc => \"rustc\",\n-            PkgType::Cargo => \"cargo\",\n-            PkgType::Rls => \"rls\",\n-            PkgType::RustAnalyzer => \"rust-analyzer\",\n-            PkgType::Clippy => \"clippy\",\n-            PkgType::Rustfmt => \"rustfmt\",\n-            PkgType::LlvmTools => \"llvm-tools\",\n-            PkgType::Miri => \"miri\",\n-            PkgType::JsonDocs => \"rust-docs-json\",\n-            PkgType::Other(component) => component,\n+pkg_type! {\n+    Rust = \"rust\",\n+    RustSrc = \"rust-src\",\n+    Rustc = \"rustc\",\n+    RustcDev = \"rustc-dev\",\n+    RustcDocs = \"rustc-docs\",\n+    ReproducibleArtifacts = \"reproducible-artifacts\",\n+    RustMingw = \"rust-mingw\",\n+    RustStd = \"rust-std\",\n+    Cargo = \"cargo\",\n+    HtmlDocs = \"rust-docs\",\n+    RustAnalysis = \"rust-analysis\",\n+    Rls = \"rls\"; preview = true,\n+    RustAnalyzer = \"rust-analyzer\"; preview = true,\n+    Clippy = \"clippy\"; preview = true,\n+    Rustfmt = \"rustfmt\"; preview = true,\n+    LlvmTools = \"llvm-tools\"; preview = true,\n+    Miri = \"miri\"; preview = true,\n+    JsonDocs = \"rust-docs-json\"; preview = true,\n+}\n+\n+impl PkgType {\n+    /// Component name in the manifest. In particular, this includes the `-preview` suffix where appropriate.\n+    pub(crate) fn manifest_component_name(&self) -> String {\n+        if self.is_preview() {\n+            format!(\"{}-preview\", self.tarball_component_name())\n+        } else {\n+            self.tarball_component_name().to_string()\n         }\n     }\n \n@@ -73,17 +81,57 @@ impl PkgType {\n             PkgType::Miri => false,\n \n             PkgType::Rust => true,\n+            PkgType::RustStd => true,\n             PkgType::RustSrc => true,\n             PkgType::Rustc => true,\n             PkgType::JsonDocs => true,\n-            PkgType::Other(_) => true,\n+            PkgType::HtmlDocs => true,\n+            PkgType::RustcDev => true,\n+            PkgType::RustcDocs => true,\n+            PkgType::ReproducibleArtifacts => true,\n+            PkgType::RustMingw => true,\n+            PkgType::RustAnalysis => true,\n+        }\n+    }\n+\n+    pub(crate) fn targets(&self) -> &[&str] {\n+        use crate::{HOSTS, MINGW, TARGETS};\n+        use PkgType::*;\n+\n+        match self {\n+            Rust => HOSTS, // doesn't matter in practice, but return something to avoid panicking\n+            Rustc => HOSTS,\n+            RustcDev => HOSTS,\n+            ReproducibleArtifacts => HOSTS,\n+            RustcDocs => HOSTS,\n+            Cargo => HOSTS,\n+            RustMingw => MINGW,\n+            RustStd => TARGETS,\n+            HtmlDocs => HOSTS,\n+            JsonDocs => HOSTS,\n+            RustSrc => &[\"*\"],\n+            Rls => HOSTS,\n+            RustAnalyzer => HOSTS,\n+            Clippy => HOSTS,\n+            Miri => HOSTS,\n+            Rustfmt => HOSTS,\n+            RustAnalysis => TARGETS,\n+            LlvmTools => TARGETS,\n         }\n     }\n \n     /// Whether this package is target-independent or not.\n     fn target_independent(&self) -> bool {\n         *self == PkgType::RustSrc\n     }\n+\n+    /// Whether to package these target-specific docs for another similar target.\n+    pub(crate) fn use_docs_fallback(&self) -> bool {\n+        match self {\n+            PkgType::JsonDocs | PkgType::HtmlDocs => true,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(Debug, Default, Clone)]"}]}