{"sha": "cb45103358c0fef99d7659e0949b3c65b3eabdd6", "node_id": "C_kwDOAAsO6NoAKGNiNDUxMDMzNThjMGZlZjk5ZDc2NTllMDk0OWIzYzY1YjNlYWJkZDY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-26T17:13:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-26T17:13:57Z"}, "message": "Merge from rustc", "tree": {"sha": "e430c91fb4e29070945f79df7a47639e5cf4f9b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e430c91fb4e29070945f79df7a47639e5cf4f9b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb45103358c0fef99d7659e0949b3c65b3eabdd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb45103358c0fef99d7659e0949b3c65b3eabdd6", "html_url": "https://github.com/rust-lang/rust/commit/cb45103358c0fef99d7659e0949b3c65b3eabdd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb45103358c0fef99d7659e0949b3c65b3eabdd6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fb185210eaa9d2de7e8ab1161897edf2eaae758", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb185210eaa9d2de7e8ab1161897edf2eaae758", "html_url": "https://github.com/rust-lang/rust/commit/9fb185210eaa9d2de7e8ab1161897edf2eaae758"}, {"sha": "c4e0cd966062ca67daed20775f4e8a60c28e57df", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4e0cd966062ca67daed20775f4e8a60c28e57df", "html_url": "https://github.com/rust-lang/rust/commit/c4e0cd966062ca67daed20775f4e8a60c28e57df"}], "stats": {"total": 20341, "additions": 12022, "deletions": 8319}, "files": [{"sha": "353bfcb6ac1aef3c1519f2a340bdd2fcb54f8552", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,3 +1,5 @@\n+# Use `git config blame.ignorerevsfile .git-blame-ignore-revs` to make `git blame` ignore the following commits.\n+\n # format the world\n a06baa56b95674fc626b3c3fd680d6a65357fe60\n # format libcore"}, {"sha": "9e5deedb66fff860078878c56e9641789fb45d1d", "filename": "Cargo.lock", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -88,15 +88,6 @@ dependencies = [\n  \"yansi-term\",\n ]\n \n-[[package]]\n-name = \"ansi_term\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"ansi_term\"\n version = \"0.12.1\"\n@@ -390,7 +381,6 @@ dependencies = [\n  \"os_info\",\n  \"pasetors\",\n  \"pathdiff\",\n- \"percent-encoding\",\n  \"pretty_env_logger\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n@@ -891,11 +881,11 @@ dependencies = [\n  \"diff\",\n  \"getopts\",\n  \"glob\",\n- \"lazy_static\",\n  \"lazycell\",\n  \"libc\",\n- \"miow 0.3.7\",\n+ \"miow 0.5.0\",\n  \"miropt-test-tools\",\n+ \"once_cell\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n@@ -1216,12 +1206,6 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8\"\n \n-[[package]]\n-name = \"difference\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n-\n [[package]]\n name = \"digest\"\n version = \"0.10.6\"\n@@ -1378,6 +1362,15 @@ dependencies = [\n  \"zeroize\",\n ]\n \n+[[package]]\n+name = \"elsa\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f74077c3c3aedb99a2683919698285596662518ea13e5eedcf8bdd43b0d0453b\"\n+dependencies = [\n+ \"stable_deref_trait\",\n+]\n+\n [[package]]\n name = \"ena\"\n version = \"0.14.0\"\n@@ -1452,6 +1445,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"mdbook\",\n+ \"rustc_error_codes\",\n ]\n \n [[package]]\n@@ -1934,8 +1928,16 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n- \"compiler_builtins\",\n  \"libc\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"856b5cb0902c2b6d65d5fd97dfa30f9b70c7538e770b98eab5ed52d8db923e01\"\n+dependencies = [\n+ \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n@@ -3184,14 +3186,14 @@ checksum = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \n [[package]]\n name = \"pretty_assertions\"\n-version = \"0.6.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f81e1644e1b54f5a68959a29aa86cde704219254669da328ecfdf6a1f09d427\"\n+checksum = \"a25e9bcb20aa780fd0bb16b72403a9064d6b3f22f026946029acb941a50af755\"\n dependencies = [\n- \"ansi_term 0.11.0\",\n  \"ctor\",\n- \"difference\",\n+ \"diff\",\n  \"output_vt100\",\n+ \"yansi\",\n ]\n \n [[package]]\n@@ -3689,6 +3691,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -3698,6 +3701,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n  \"rustc_span\",\n+ \"thin-vec\",\n ]\n \n [[package]]\n@@ -3882,6 +3886,7 @@ dependencies = [\n  \"arrayvec 0.7.0\",\n  \"bitflags\",\n  \"cfg-if\",\n+ \"elsa\",\n  \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n@@ -3918,26 +3923,47 @@ version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n  \"rustc_ast\",\n+ \"rustc_ast_lowering\",\n+ \"rustc_ast_passes\",\n  \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n+ \"rustc_borrowck\",\n+ \"rustc_builtin_macros\",\n  \"rustc_codegen_ssa\",\n+ \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n+ \"rustc_error_messages\",\n  \"rustc_errors\",\n+ \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_hir_analysis\",\n  \"rustc_hir_pretty\",\n+ \"rustc_hir_typeck\",\n+ \"rustc_incremental\",\n+ \"rustc_infer\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_log\",\n  \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n+ \"rustc_mir_build\",\n+ \"rustc_mir_dataflow\",\n+ \"rustc_monomorphize\",\n  \"rustc_parse\",\n+ \"rustc_passes\",\n  \"rustc_plugin_impl\",\n+ \"rustc_privacy\",\n+ \"rustc_query_system\",\n+ \"rustc_resolve\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n+ \"rustc_ty_utils\",\n  \"serde_json\",\n  \"tracing\",\n  \"winapi\",\n@@ -4071,6 +4097,7 @@ dependencies = [\n  \"rustc_trait_selection\",\n  \"rustc_type_ir\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4127,6 +4154,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4826,7 +4854,6 @@ dependencies = [\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n- \"thin-vec\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -5276,7 +5303,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown 0.12.3\",\n- \"hermit-abi 0.2.6\",\n+ \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object 0.29.0\",\n@@ -5471,10 +5498,8 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n  \"core\",\n  \"getopts\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"proc_macro\",\n@@ -5502,9 +5527,9 @@ checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n [[package]]\n name = \"thin-vec\"\n-version = \"0.2.9\"\n+version = \"0.2.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ceb05e71730d396f960f8f3901cdb41be2d339b303e9d7d3a07c5ff0536e671b\"\n+checksum = \"aac81b6fd6beb5884b0cf3321b8117e6e5d47ecb6fc89f414cfdcca8b2fe2dd8\"\n \n [[package]]\n name = \"thiserror\"\n@@ -5749,7 +5774,7 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"245da694cc7fc4729f3f418b304cb57789f1bed2a78c575407ab8a23f53cb4d3\"\n dependencies = [\n- \"ansi_term 0.12.1\",\n+ \"ansi_term\",\n  \"lazy_static\",\n  \"matchers\",\n  \"parking_lot 0.11.2\",\n@@ -5768,7 +5793,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ce989c9962c7f61fe084dd4a230eec784649dfc2392467c790007c3a6e134e7\"\n dependencies = [\n- \"ansi_term 0.12.1\",\n+ \"ansi_term\",\n  \"atty\",\n  \"tracing-core\",\n  \"tracing-log\","}, {"sha": "f0632ac92e96f3698dc9806a5fa70f46b1f5ae49", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -15,5 +15,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "03c375c46668ab6a12b3c19e6fd48a0e0db3569a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -209,7 +209,7 @@ pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n     /// The comma separated parts in the `<...>`.\n-    pub args: Vec<AngleBracketedArg>,\n+    pub args: ThinVec<AngleBracketedArg>,\n }\n \n /// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n@@ -253,7 +253,7 @@ pub struct ParenthesizedArgs {\n     pub span: Span,\n \n     /// `(A, B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: ThinVec<P<Ty>>,\n \n     /// ```text\n     /// Foo(A, B) -> C\n@@ -384,15 +384,15 @@ impl GenericParam {\n /// a function, enum, trait, etc.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Generics {\n-    pub params: Vec<GenericParam>,\n+    pub params: ThinVec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() -> Generics {\n-        Generics { params: Vec::new(), where_clause: Default::default(), span: DUMMY_SP }\n+        Generics { params: ThinVec::new(), where_clause: Default::default(), span: DUMMY_SP }\n     }\n }\n \n@@ -403,13 +403,13 @@ pub struct WhereClause {\n     /// if we parsed no predicates (e.g. `struct Foo where {}`).\n     /// This allows us to pretty-print accurately.\n     pub has_where_token: bool,\n-    pub predicates: Vec<WherePredicate>,\n+    pub predicates: ThinVec<WherePredicate>,\n     pub span: Span,\n }\n \n impl Default for WhereClause {\n     fn default() -> WhereClause {\n-        WhereClause { has_where_token: false, predicates: Vec::new(), span: DUMMY_SP }\n+        WhereClause { has_where_token: false, predicates: ThinVec::new(), span: DUMMY_SP }\n     }\n }\n \n@@ -441,7 +441,7 @@ impl WherePredicate {\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n-    pub bound_generic_params: Vec<GenericParam>,\n+    pub bound_generic_params: ThinVec<GenericParam>,\n     /// The type being bounded.\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone + Send + 'static`).\n@@ -471,7 +471,7 @@ pub struct WhereEqPredicate {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n     pub attrs: AttrVec,\n-    pub items: Vec<P<Item>>,\n+    pub items: ThinVec<P<Item>>,\n     pub spans: ModSpans,\n     /// Must be equal to `CRATE_NODE_ID` after the crate root is expanded, but may hold\n     /// expansion placeholders or an unassigned value (`DUMMY_NODE_ID`) before that.\n@@ -503,7 +503,7 @@ pub enum MetaItemKind {\n     /// List meta item.\n     ///\n     /// E.g., `#[derive(..)]`, where the field represents the `..`.\n-    List(Vec<NestedMetaItem>),\n+    List(ThinVec<NestedMetaItem>),\n \n     /// Name value meta item.\n     ///\n@@ -531,7 +531,7 @@ pub enum NestedMetaItem {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Block {\n     /// The statements in the block.\n-    pub stmts: Vec<Stmt>,\n+    pub stmts: ThinVec<Stmt>,\n     pub id: NodeId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n@@ -581,7 +581,7 @@ impl Pat {\n             // A tuple pattern `(P0, .., Pn)` can be reparsed as `(T0, .., Tn)`\n             // assuming `T0` to `Tn` are all syntactically valid as types.\n             PatKind::Tuple(pats) => {\n-                let mut tys = Vec::with_capacity(pats.len());\n+                let mut tys = ThinVec::with_capacity(pats.len());\n                 // FIXME(#48994) - could just be collected into an Option<Vec>\n                 for pat in pats {\n                     tys.push(pat.to_ty()?);\n@@ -722,14 +722,14 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Option<P<QSelf>>, Path, Vec<PatField>, /* recovered */ bool),\n+    Struct(Option<P<QSelf>>, Path, ThinVec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    TupleStruct(Option<P<QSelf>>, Path, Vec<P<Pat>>),\n+    TupleStruct(Option<P<QSelf>>, Path, ThinVec<P<Pat>>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n-    Or(Vec<P<Pat>>),\n+    Or(ThinVec<P<Pat>>),\n \n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n@@ -738,7 +738,7 @@ pub enum PatKind {\n     Path(Option<P<QSelf>>, Path),\n \n     /// A tuple pattern (`(a, b)`).\n-    Tuple(Vec<P<Pat>>),\n+    Tuple(ThinVec<P<Pat>>),\n \n     /// A `box` pattern.\n     Box(P<Pat>),\n@@ -753,7 +753,7 @@ pub enum PatKind {\n     Range(Option<P<Expr>>, Option<P<Expr>>, Spanned<RangeEnd>),\n \n     /// A slice pattern `[a, b, c]`.\n-    Slice(Vec<P<Pat>>),\n+    Slice(ThinVec<P<Pat>>),\n \n     /// A rest pattern `..`.\n     ///\n@@ -1169,7 +1169,7 @@ impl Expr {\n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n-                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n+                PolyTraitRef::new(ThinVec::new(), path.clone(), self.span),\n                 TraitBoundModifier::None,\n             )),\n             _ => None,\n@@ -1204,7 +1204,7 @@ impl Expr {\n             ExprKind::Array(exprs) if exprs.len() == 1 => exprs[0].to_ty().map(TyKind::Slice)?,\n \n             ExprKind::Tup(exprs) => {\n-                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<Vec<_>>>()?;\n+                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<ThinVec<_>>>()?;\n                 TyKind::Tup(tys)\n             }\n \n@@ -1337,7 +1337,7 @@ pub struct MethodCall {\n     /// The receiver, e.g. `x`.\n     pub receiver: P<Expr>,\n     /// The arguments, e.g. `a, b, c`.\n-    pub args: Vec<P<Expr>>,\n+    pub args: ThinVec<P<Expr>>,\n     /// The span of the function, without the dot and receiver e.g. `foo::<Bar,\n     /// Baz>(a, b, c)`.\n     pub span: Span,\n@@ -1357,7 +1357,7 @@ pub enum StructRest {\n pub struct StructExpr {\n     pub qself: Option<P<QSelf>>,\n     pub path: Path,\n-    pub fields: Vec<ExprField>,\n+    pub fields: ThinVec<ExprField>,\n     pub rest: StructRest,\n }\n \n@@ -1366,7 +1366,7 @@ pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    Array(Vec<P<Expr>>),\n+    Array(ThinVec<P<Expr>>),\n     /// Allow anonymous constants from an inline `const` block\n     ConstBlock(AnonConst),\n     /// A function call\n@@ -1375,11 +1375,11 @@ pub enum ExprKind {\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    Call(P<Expr>, Vec<P<Expr>>),\n+    Call(P<Expr>, ThinVec<P<Expr>>),\n     /// A method call (e.g. `x.foo::<Bar, Baz>(a, b, c)`).\n     MethodCall(Box<MethodCall>),\n     /// A tuple (e.g., `(a, b, c, d)`).\n-    Tup(Vec<P<Expr>>),\n+    Tup(ThinVec<P<Expr>>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (e.g., `!x`, `*x`).\n@@ -1414,7 +1414,7 @@ pub enum ExprKind {\n     /// `'label: loop { block }`\n     Loop(P<Block>, Option<Label>, Span),\n     /// A `match` block.\n-    Match(P<Expr>, Vec<Arm>),\n+    Match(P<Expr>, ThinVec<Arm>),\n     /// A closure (e.g., `move |a, b, c| a + b + c`).\n     Closure(Box<Closure>),\n     /// A block (`'label: { ... }`).\n@@ -1574,7 +1574,7 @@ pub enum ClosureBinder {\n         /// for<'a, 'b> |_: &'a (), _: &'b ()| { ... }\n         ///     ^^^^^^ -- this\n         /// ```\n-        generic_params: P<[GenericParam]>,\n+        generic_params: ThinVec<GenericParam>,\n     },\n }\n \n@@ -2056,7 +2056,7 @@ impl Ty {\n pub struct BareFnTy {\n     pub unsafety: Unsafe,\n     pub ext: Extern,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: ThinVec<GenericParam>,\n     pub decl: P<FnDecl>,\n     /// Span of the `fn(...) -> ...` part.\n     pub decl_span: Span,\n@@ -2078,7 +2078,7 @@ pub enum TyKind {\n     /// The never type (`!`).\n     Never,\n     /// A tuple (`(A, B, C, D,...)`).\n-    Tup(Vec<P<Ty>>),\n+    Tup(ThinVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g., `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n@@ -2363,7 +2363,7 @@ impl Param {\n /// which contains metadata about function safety, asyncness, constness and ABI.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Param>,\n+    pub inputs: ThinVec<Param>,\n     pub output: FnRetTy,\n }\n \n@@ -2475,7 +2475,7 @@ pub enum ModKind {\n     /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n     /// The inner span is from the first token past `{` to the last token until `}`,\n     /// or from the first to the last token in the loaded file.\n-    Loaded(Vec<P<Item>>, Inline, ModSpans),\n+    Loaded(ThinVec<P<Item>>, Inline, ModSpans),\n     /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n     Unloaded,\n }\n@@ -2497,12 +2497,12 @@ pub struct ForeignMod {\n     /// semantically by Rust.\n     pub unsafety: Unsafe,\n     pub abi: Option<StrLit>,\n-    pub items: Vec<P<ForeignItem>>,\n+    pub items: ThinVec<P<ForeignItem>>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<Variant>,\n+    pub variants: ThinVec<Variant>,\n }\n /// Enum variant.\n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2532,7 +2532,7 @@ pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     Simple(Option<Ident>),\n     /// `use prefix::{...}`\n-    Nested(Vec<(UseTree, NodeId)>),\n+    Nested(ThinVec<(UseTree, NodeId)>),\n     /// `use prefix::*`\n     Glob,\n }\n@@ -2636,7 +2636,7 @@ pub struct TraitRef {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n-    pub bound_generic_params: Vec<GenericParam>,\n+    pub bound_generic_params: ThinVec<GenericParam>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n@@ -2645,7 +2645,7 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n+    pub fn new(generic_params: ThinVec<GenericParam>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n             trait_ref: TraitRef { path, ref_id: DUMMY_NODE_ID },\n@@ -2695,11 +2695,11 @@ pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<FieldDef>, bool),\n+    Struct(ThinVec<FieldDef>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n-    Tuple(Vec<FieldDef>, NodeId),\n+    Tuple(ThinVec<FieldDef>, NodeId),\n     /// Unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n@@ -2826,7 +2826,7 @@ pub struct Trait {\n     pub is_auto: IsAuto,\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n-    pub items: Vec<P<AssocItem>>,\n+    pub items: ThinVec<P<AssocItem>>,\n }\n \n /// The location of a where clause on a `TyAlias` (`Span`) and whether there was\n@@ -2874,7 +2874,7 @@ pub struct Impl {\n     /// The trait being implemented, if any.\n     pub of_trait: Option<TraitRef>,\n     pub self_ty: P<Ty>,\n-    pub items: Vec<P<AssocItem>>,\n+    pub items: ThinVec<P<AssocItem>>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -3112,26 +3112,26 @@ mod size_asserts {\n     static_assert_size!(AssocItem, 104);\n     static_assert_size!(AssocItemKind, 32);\n     static_assert_size!(Attribute, 32);\n-    static_assert_size!(Block, 48);\n+    static_assert_size!(Block, 32);\n     static_assert_size!(Expr, 72);\n     static_assert_size!(ExprKind, 40);\n-    static_assert_size!(Fn, 184);\n+    static_assert_size!(Fn, 152);\n     static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n     static_assert_size!(GenericArg, 24);\n-    static_assert_size!(GenericBound, 72);\n-    static_assert_size!(Generics, 72);\n-    static_assert_size!(Impl, 184);\n-    static_assert_size!(Item, 184);\n-    static_assert_size!(ItemKind, 112);\n+    static_assert_size!(GenericBound, 56);\n+    static_assert_size!(Generics, 40);\n+    static_assert_size!(Impl, 136);\n+    static_assert_size!(Item, 136);\n+    static_assert_size!(ItemKind, 64);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n     static_assert_size!(MetaItemLit, 40);\n     static_assert_size!(Param, 40);\n-    static_assert_size!(Pat, 88);\n+    static_assert_size!(Pat, 72);\n     static_assert_size!(Path, 24);\n     static_assert_size!(PathSegment, 24);\n-    static_assert_size!(PatKind, 64);\n+    static_assert_size!(PatKind, 48);\n     static_assert_size!(Stmt, 32);\n     static_assert_size!(StmtKind, 16);\n     static_assert_size!(Ty, 64);"}, {"sha": "2e83b3e623f075c4f3ace79abb5f2c591e9eb8aa", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -20,7 +20,7 @@ use std::iter;\n use std::ops::BitXor;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicU32, Ordering};\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n@@ -135,7 +135,7 @@ impl Attribute {\n         }\n     }\n \n-    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    pub fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.kind {\n             AttrKind::Normal(normal) => normal.item.meta_item_list(),\n             AttrKind::DocComment(..) => None,\n@@ -216,7 +216,7 @@ impl AttrItem {\n         self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n     }\n \n-    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.args {\n             AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n                 MetaItemKind::list_from_tokens(args.tokens.clone())\n@@ -375,9 +375,9 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn list_from_tokens(tokens: TokenStream) -> Option<Vec<NestedMetaItem>> {\n+    fn list_from_tokens(tokens: TokenStream) -> Option<ThinVec<NestedMetaItem>> {\n         let mut tokens = tokens.into_trees().peekable();\n-        let mut result = Vec::new();\n+        let mut result = ThinVec::new();\n         while tokens.peek().is_some() {\n             let item = NestedMetaItem::from_tokens(&mut tokens)?;\n             result.push(item);"}, {"sha": "7dcb03b4c786cd98bf297b5e148135f7ad9e2ae6", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -17,10 +17,10 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n-\n use smallvec::{smallvec, Array, SmallVec};\n use std::ops::DerefMut;\n use std::{panic, ptr};\n+use thin_vec::ThinVec;\n \n pub trait ExpectOne<A: Array> {\n     fn expect_one(self, err: &'static str) -> A::Item;\n@@ -335,6 +335,17 @@ where\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+#[inline]\n+pub fn visit_thin_vec<T, F>(elems: &mut ThinVec<T>, mut visit_elem: F)\n+where\n+    F: FnMut(&mut T),\n+{\n+    for elem in elems {\n+        visit_elem(elem);\n+    }\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n #[inline]\n pub fn visit_opt<T, F>(opt: &mut Option<T>, mut visit_elem: F)\n@@ -358,6 +369,11 @@ pub fn visit_exprs<T: MutVisitor>(exprs: &mut Vec<P<Expr>>, vis: &mut T) {\n     exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_thin_exprs<T: MutVisitor>(exprs: &mut ThinVec<P<Expr>>, vis: &mut T) {\n+    exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_bounds<T: MutVisitor>(bounds: &mut GenericBounds, vis: &mut T) {\n     visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n@@ -474,7 +490,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             vis.visit_fn_decl(decl);\n             vis.visit_span(decl_span);\n         }\n-        TyKind::Tup(tys) => visit_vec(tys, |ty| vis.visit_ty(ty)),\n+        TyKind::Tup(tys) => visit_thin_vec(tys, |ty| vis.visit_ty(ty)),\n         TyKind::Paren(ty) => vis.visit_ty(ty),\n         TyKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -561,7 +577,7 @@ pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let AngleBracketedArgs { args, span } = data;\n-    visit_vec(args, |arg| match arg {\n+    visit_thin_vec(args, |arg| match arg {\n         AngleBracketedArg::Arg(arg) => vis.visit_generic_arg(arg),\n         AngleBracketedArg::Constraint(constraint) => vis.visit_constraint(constraint),\n     });\n@@ -573,7 +589,7 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let ParenthesizedArgs { inputs, output, span, .. } = args;\n-    visit_vec(inputs, |input| vis.visit_ty(input));\n+    visit_thin_vec(inputs, |input| vis.visit_ty(input));\n     noop_visit_fn_ret_ty(output, vis);\n     vis.visit_span(span);\n }\n@@ -636,7 +652,7 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     let MetaItem { path: _, kind, span } = mi;\n     match kind {\n         MetaItemKind::Word => {}\n-        MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n+        MetaItemKind::List(mis) => visit_thin_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n         MetaItemKind::NameValue(_s) => {}\n     }\n     vis.visit_span(span);\n@@ -839,9 +855,7 @@ pub fn noop_visit_closure_binder<T: MutVisitor>(binder: &mut ClosureBinder, vis:\n     match binder {\n         ClosureBinder::NotPresent => {}\n         ClosureBinder::For { span: _, generic_params } => {\n-            let mut vec = std::mem::take(generic_params).into_vec();\n-            vec.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n-            *generic_params = P::from_vec(vec);\n+            generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n         }\n     }\n }\n@@ -919,7 +933,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n     let WhereClause { has_where_token: _, predicates, span } = wc;\n-    visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n+    visit_thin_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }\n \n@@ -1227,7 +1241,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::TupleStruct(qself, path, elems) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);\n-            visit_vec(elems, |elem| vis.visit_pat(elem));\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -1246,7 +1260,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             vis.visit_span(span);\n         }\n         PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n-            visit_vec(elems, |elem| vis.visit_pat(elem))\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem))\n         }\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::MacCall(mac) => vis.visit_mac_call(mac),\n@@ -1303,18 +1317,18 @@ pub fn noop_visit_expr<T: MutVisitor>(\n ) {\n     match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n-        ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Array(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::ConstBlock(anon_const) => {\n             vis.visit_anon_const(anon_const);\n         }\n         ExprKind::Repeat(expr, count) => {\n             vis.visit_expr(expr);\n             vis.visit_anon_const(count);\n         }\n-        ExprKind::Tup(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Tup(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::Call(f, args) => {\n             vis.visit_expr(f);\n-            visit_exprs(args, vis);\n+            visit_thin_exprs(args, vis);\n         }\n         ExprKind::MethodCall(box MethodCall {\n             seg: PathSegment { ident, id, args: seg_args },\n@@ -1326,7 +1340,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_id(id);\n             visit_opt(seg_args, |args| vis.visit_generic_args(args));\n             vis.visit_method_receiver_expr(receiver);\n-            visit_exprs(call_args, vis);\n+            visit_thin_exprs(call_args, vis);\n             vis.visit_span(span);\n         }\n         ExprKind::Binary(_binop, lhs, rhs) => {"}, {"sha": "eb2e82d7988c955dca73cac97523f14e89df1776", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -19,5 +19,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "a2837deafdec4f38a16b61392228b709684edacd", "filename": "compiler/rustc_ast_lowering/locales/en-US.ftl", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -19,6 +19,9 @@ ast_lowering_remove_parentheses = remove these parentheses\n ast_lowering_misplaced_impl_trait =\n     `impl Trait` only allowed in function and inherent method return types, not in {$position}\n \n+ast_lowering_misplaced_assoc_ty_binding =\n+    associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n+\n ast_lowering_rustc_box_attribute_error =\n     #[rustc_box] requires precisely one argument and no other attributes are allowed\n ", "previous_filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl"}, {"sha": "def74c2adeee944c36975b02f6b699202044f170", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -79,6 +79,14 @@ pub struct MisplacedImplTrait<'a> {\n     pub position: DiagnosticArgFromDisplay<'a>,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(ast_lowering_misplaced_assoc_ty_binding)]\n+pub struct MisplacedAssocTyBinding<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub position: DiagnosticArgFromDisplay<'a>,\n+}\n+\n #[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering_rustc_box_attribute_error)]\n pub struct RustcBoxAttributeError {\n@@ -339,7 +347,7 @@ pub struct InclusiveRangeWithNoEnd {\n #[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering_trait_fn_async, code = \"E0706\")]\n #[note]\n-#[note(note2)]\n+#[note(ast_lowering_note2)]\n pub struct TraitFnAsync {\n     #[primary_span]\n     pub fn_span: Span,"}, {"sha": "d4fafe38638a42139f6e41b9c674da24d1f1da97", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -18,7 +18,7 @@ use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -88,8 +88,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n-                            hir::ExprKind::Err\n+                            let guar = self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n+                            hir::ExprKind::Err(guar)\n                         }\n                     } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n                         self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n@@ -266,8 +266,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n-                    hir::ExprKind::Err\n+                    let guar = self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n+                    hir::ExprKind::Err(guar)\n                 }\n                 ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n@@ -299,8 +299,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n-                            Some(&*self.arena.alloc(self.expr_err(*sp)))\n+                            let guar =\n+                                self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n+                            Some(&*self.arena.alloc(self.expr_err(*sp, guar)))\n                         }\n                         StructRest::None => None,\n                     };\n@@ -318,7 +319,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     )\n                 }\n                 ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n-                ExprKind::Err => hir::ExprKind::Err,\n+                ExprKind::Err => hir::ExprKind::Err(\n+                    self.tcx.sess.delay_span_bug(e.span, \"lowered ExprKind::Err\"),\n+                ),\n                 ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n \n                 ExprKind::Paren(_) | ExprKind::ForLoop(..) => unreachable!(\"already handled\"),\n@@ -367,7 +370,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_legacy_const_generics(\n         &mut self,\n         mut f: Expr,\n-        args: Vec<AstP<Expr>>,\n+        args: ThinVec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n         let ExprKind::Path(None, path) = &mut f.kind else {\n@@ -376,7 +379,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // Split the arguments into const generics and normal arguments\n         let mut real_args = vec![];\n-        let mut generic_args = vec![];\n+        let mut generic_args = ThinVec::new();\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n                 let parent_def_id = self.current_hir_id_owner;\n@@ -761,7 +764,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.expr_ident_mut(span, task_context_ident, task_context_hid)\n             } else {\n                 // Use of `await` outside of an async context, we cannot use `task_context` here.\n-                self.expr_err(span)\n+                self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no task_context hir id\"))\n             };\n             let new_unchecked = self.expr_call_lang_item_fn_mut(\n                 span,"}, {"sha": "4095e225a8019ea846a88b67e70cc470863c1f5c", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -102,7 +102,12 @@ fn make_count<'hir>(\n                 let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n                 ctx.expr_call_mut(sp, count_param, value)\n             } else {\n-                ctx.expr(sp, hir::ExprKind::Err)\n+                ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Err(\n+                        ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\"),\n+                    ),\n+                )\n             }\n         }\n         None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n@@ -135,7 +140,10 @@ fn make_format_spec<'hir>(\n                 argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n             ctx.expr_usize(sp, i)\n         }\n-        Err(_) => ctx.expr(sp, hir::ExprKind::Err),\n+        Err(_) => ctx.expr(\n+            sp,\n+            hir::ExprKind::Err(ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\")),\n+        ),\n     };\n     let &FormatOptions {\n         ref width,\n@@ -294,7 +302,12 @@ fn expand_format_args<'hir>(\n                 ));\n                 make_argument(ctx, sp, arg, ty)\n             } else {\n-                ctx.expr(macsp, hir::ExprKind::Err)\n+                ctx.expr(\n+                    macsp,\n+                    hir::ExprKind::Err(\n+                        ctx.tcx.sess.delay_span_bug(macsp, format!(\"no arg at {arg_index}\")),\n+                    ),\n+                )\n             }\n         }));\n         let elements: Vec<_> = arguments"}, {"sha": "7325bce6055923cf73af599e43a6eb7ba651136d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -284,7 +285,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n             ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n-            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: Some(ty), .. }) => {\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -299,18 +300,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &generics,\n                     id,\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n-                );\n-                hir::ItemKind::TyAlias(ty, generics)\n-            }\n-            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: None, .. }) => {\n-                let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n-                let (generics, ty) = self.lower_generics(\n-                    &generics,\n-                    id,\n-                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n+                    |this| match ty {\n+                        None => {\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                span,\n+                                \"expected to lower type alias type, but it was missing\",\n+                            );\n+                            this.arena.alloc(this.ty(span, hir::TyKind::Err(guar)))\n+                        }\n+                        Some(ty) => this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n+                    },\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n@@ -798,8 +797,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Err)\n+    pub(crate) fn expr_err(&mut self, span: Span, guar: ErrorGuaranteed) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Err(guar))\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n@@ -847,7 +846,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| match ty {\n                         None => {\n-                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                i.span,\n+                                \"expected to lower associated type, but it was missing\",\n+                            );\n+                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err(guar)));\n                             hir::ImplItemKind::Type(ty)\n                         }\n                         Some(ty) => {\n@@ -973,7 +976,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n         match block {\n             Some(block) => self.lower_block_expr(block),\n-            None => self.expr_err(span),\n+            None => self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no block\")),\n         }\n     }\n \n@@ -983,7 +986,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 &[],\n                 match expr {\n                     Some(expr) => this.lower_expr_mut(expr),\n-                    None => this.expr_err(span),\n+                    None => this.expr_err(span, this.tcx.sess.delay_span_bug(span, \"no block\")),\n                 },\n             )\n         })"}, {"sha": "5d78d914b6d7f7c67ab46bfa7d3ad832a9b494cb", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 96, "deletions": 74, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -52,23 +52,28 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{DiagnosticArgFromDisplay, Handler, StashKey};\n+use rustc_errors::{\n+    DiagnosticArgFromDisplay, DiagnosticMessage, Handler, StashKey, SubdiagnosticMessage,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::span_bug;\n-use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n+use rustc_macros::fluent_messages;\n+use rustc_middle::{\n+    span_bug,\n+    ty::{ResolverAstLowering, TyCtxt},\n+};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-\n use smallvec::SmallVec;\n use std::collections::hash_map::Entry;\n+use thin_vec::ThinVec;\n \n macro_rules! arena_vec {\n     ($this:expr; $($x:expr),*) => (\n@@ -87,6 +92,8 @@ mod lifetime_collector;\n mod pat;\n mod path;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n struct LoweringContext<'a, 'hir> {\n     tcx: TyCtxt<'hir>,\n     resolver: &'a mut ResolverAstLowering,\n@@ -281,31 +288,31 @@ enum ImplTraitPosition {\n impl std::fmt::Display for ImplTraitPosition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let name = match self {\n-            ImplTraitPosition::Path => \"path\",\n-            ImplTraitPosition::Variable => \"variable binding\",\n-            ImplTraitPosition::Trait => \"trait\",\n-            ImplTraitPosition::AsyncBlock => \"async block\",\n-            ImplTraitPosition::Bound => \"bound\",\n-            ImplTraitPosition::Generic => \"generic\",\n-            ImplTraitPosition::ExternFnParam => \"`extern fn` param\",\n-            ImplTraitPosition::ClosureParam => \"closure param\",\n-            ImplTraitPosition::PointerParam => \"`fn` pointer param\",\n-            ImplTraitPosition::FnTraitParam => \"`Fn` trait param\",\n-            ImplTraitPosition::TraitParam => \"trait method param\",\n-            ImplTraitPosition::ImplParam => \"`impl` method param\",\n-            ImplTraitPosition::ExternFnReturn => \"`extern fn` return\",\n-            ImplTraitPosition::ClosureReturn => \"closure return\",\n-            ImplTraitPosition::PointerReturn => \"`fn` pointer return\",\n-            ImplTraitPosition::FnTraitReturn => \"`Fn` trait return\",\n-            ImplTraitPosition::TraitReturn => \"trait method return\",\n-            ImplTraitPosition::ImplReturn => \"`impl` method return\",\n-            ImplTraitPosition::GenericDefault => \"generic parameter default\",\n-            ImplTraitPosition::ConstTy => \"const type\",\n-            ImplTraitPosition::StaticTy => \"static type\",\n-            ImplTraitPosition::AssocTy => \"associated type\",\n-            ImplTraitPosition::FieldTy => \"field type\",\n-            ImplTraitPosition::Cast => \"cast type\",\n-            ImplTraitPosition::ImplSelf => \"impl header\",\n+            ImplTraitPosition::Path => \"paths\",\n+            ImplTraitPosition::Variable => \"variable bindings\",\n+            ImplTraitPosition::Trait => \"traits\",\n+            ImplTraitPosition::AsyncBlock => \"async blocks\",\n+            ImplTraitPosition::Bound => \"bounds\",\n+            ImplTraitPosition::Generic => \"generics\",\n+            ImplTraitPosition::ExternFnParam => \"`extern fn` params\",\n+            ImplTraitPosition::ClosureParam => \"closure params\",\n+            ImplTraitPosition::PointerParam => \"`fn` pointer params\",\n+            ImplTraitPosition::FnTraitParam => \"`Fn` trait params\",\n+            ImplTraitPosition::TraitParam => \"trait method params\",\n+            ImplTraitPosition::ImplParam => \"`impl` method params\",\n+            ImplTraitPosition::ExternFnReturn => \"`extern fn` return types\",\n+            ImplTraitPosition::ClosureReturn => \"closure return types\",\n+            ImplTraitPosition::PointerReturn => \"`fn` pointer return types\",\n+            ImplTraitPosition::FnTraitReturn => \"`Fn` trait return types\",\n+            ImplTraitPosition::TraitReturn => \"trait method return types\",\n+            ImplTraitPosition::ImplReturn => \"`impl` method return types\",\n+            ImplTraitPosition::GenericDefault => \"generic parameter defaults\",\n+            ImplTraitPosition::ConstTy => \"const types\",\n+            ImplTraitPosition::StaticTy => \"static types\",\n+            ImplTraitPosition::AssocTy => \"associated types\",\n+            ImplTraitPosition::FieldTy => \"field types\",\n+            ImplTraitPosition::Cast => \"cast types\",\n+            ImplTraitPosition::ImplSelf => \"impl headers\",\n         };\n \n         write!(f, \"{name}\")\n@@ -995,8 +1002,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         } else {\n             self.arena.alloc(hir::GenericArgs::none())\n         };\n-        let itctx_tait = &ImplTraitContext::TypeAliasesOpaqueTy;\n-\n         let kind = match &constraint.kind {\n             AssocConstraintKind::Equality { term } => {\n                 let term = match term {\n@@ -1006,8 +1011,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TypeBindingKind::Equality { term }\n             }\n             AssocConstraintKind::Bound { bounds } => {\n+                enum DesugarKind<'a> {\n+                    ImplTrait,\n+                    Error(&'a ImplTraitPosition),\n+                    Bound,\n+                }\n+\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n-                let (desugar_to_impl_trait, itctx) = match itctx {\n+                let desugar_kind = match itctx {\n                     // We are in the return position:\n                     //\n                     //     fn foo() -> impl Iterator<Item: Debug>\n@@ -1016,7 +1027,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n                     ImplTraitContext::ReturnPositionOpaqueTy { .. }\n-                    | ImplTraitContext::TypeAliasesOpaqueTy { .. } => (true, itctx),\n+                    | ImplTraitContext::TypeAliasesOpaqueTy { .. } => DesugarKind::ImplTrait,\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1025,15 +1036,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal if self.is_in_dyn_type => (true, itctx),\n+                    ImplTraitContext::Universal if self.is_in_dyn_type => DesugarKind::ImplTrait,\n \n-                    // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n-                    // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n-                    // \"impl trait context\" to permit `impl Debug` in this position (it desugars\n-                    // then to an opaque type).\n-                    //\n-                    // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n-                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => (true, itctx_tait),\n+                    ImplTraitContext::Disallowed(position) if self.is_in_dyn_type => {\n+                        DesugarKind::Error(position)\n+                    }\n \n                     // We are in the parameter position, but not within a dyn type:\n                     //\n@@ -1042,35 +1049,47 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so we leave it as is and this gets expanded in astconv to a bound like\n                     // `<T as Iterator>::Item: Debug` where `T` is the type parameter for the\n                     // `impl Iterator`.\n-                    _ => (false, itctx),\n+                    _ => DesugarKind::Bound,\n                 };\n \n-                if desugar_to_impl_trait {\n-                    // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n-                    // constructing the HIR for `impl bounds...` and then lowering that.\n-\n-                    let impl_trait_node_id = self.next_node_id();\n-\n-                    self.with_dyn_type_scope(false, |this| {\n-                        let node_id = this.next_node_id();\n-                        let ty = this.lower_ty(\n-                            &Ty {\n-                                id: node_id,\n-                                kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n-                                span: this.lower_span(constraint.span),\n-                                tokens: None,\n-                            },\n-                            itctx,\n-                        );\n+                match desugar_kind {\n+                    DesugarKind::ImplTrait => {\n+                        // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n+                        // constructing the HIR for `impl bounds...` and then lowering that.\n \n-                        hir::TypeBindingKind::Equality { term: ty.into() }\n-                    })\n-                } else {\n-                    // Desugar `AssocTy: Bounds` into a type binding where the\n-                    // later desugars into a trait predicate.\n-                    let bounds = self.lower_param_bounds(bounds, itctx);\n+                        let impl_trait_node_id = self.next_node_id();\n \n-                    hir::TypeBindingKind::Constraint { bounds }\n+                        self.with_dyn_type_scope(false, |this| {\n+                            let node_id = this.next_node_id();\n+                            let ty = this.lower_ty(\n+                                &Ty {\n+                                    id: node_id,\n+                                    kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n+                                    span: this.lower_span(constraint.span),\n+                                    tokens: None,\n+                                },\n+                                itctx,\n+                            );\n+\n+                            hir::TypeBindingKind::Equality { term: ty.into() }\n+                        })\n+                    }\n+                    DesugarKind::Bound => {\n+                        // Desugar `AssocTy: Bounds` into a type binding where the\n+                        // later desugars into a trait predicate.\n+                        let bounds = self.lower_param_bounds(bounds, itctx);\n+\n+                        hir::TypeBindingKind::Constraint { bounds }\n+                    }\n+                    DesugarKind::Error(position) => {\n+                        let guar = self.tcx.sess.emit_err(errors::MisplacedAssocTyBinding {\n+                            span: constraint.span,\n+                            position: DiagnosticArgFromDisplay(position),\n+                        });\n+                        let err_ty =\n+                            &*self.arena.alloc(self.ty(constraint.span, hir::TyKind::Err(guar)));\n+                        hir::TypeBindingKind::Equality { term: err_ty.into() }\n+                    }\n                 }\n             }\n         };\n@@ -1207,7 +1226,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                 let bound = this.lower_poly_trait_ref(\n                     &PolyTraitRef {\n-                        bound_generic_params: vec![],\n+                        bound_generic_params: ThinVec::new(),\n                         trait_ref: TraitRef { path: path.clone(), ref_id: t.id },\n                         span: t.span\n                     },\n@@ -1237,7 +1256,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n         let kind = match &t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n-            TyKind::Err => hir::TyKind::Err,\n+            TyKind::Err => {\n+                hir::TyKind::Err(self.tcx.sess.delay_span_bug(t.span, \"TyKind::Err lowered\"))\n+            }\n             TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Ref(region, mt) => {\n@@ -1363,7 +1384,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         path\n                     }\n                     ImplTraitContext::FeatureGated(position, feature) => {\n-                        self.tcx\n+                        let guar = self\n+                            .tcx\n                             .sess\n                             .create_feature_err(\n                                 MisplacedImplTrait {\n@@ -1373,24 +1395,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 *feature,\n                             )\n                             .emit();\n-                        hir::TyKind::Err\n+                        hir::TyKind::Err(guar)\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n-                        self.tcx.sess.emit_err(MisplacedImplTrait {\n+                        let guar = self.tcx.sess.emit_err(MisplacedImplTrait {\n                             span: t.span,\n                             position: DiagnosticArgFromDisplay(position),\n                         });\n-                        hir::TyKind::Err\n+                        hir::TyKind::Err(guar)\n                     }\n                 }\n             }\n             TyKind::MacCall(_) => panic!(\"`TyKind::MacCall` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n-                self.tcx.sess.delay_span_bug(\n+                let guar = self.tcx.sess.delay_span_bug(\n                     t.span,\n                     \"`TyKind::CVarArgs` should have been handled elsewhere\",\n                 );\n-                hir::TyKind::Err\n+                hir::TyKind::Err(guar)\n             }\n         };\n "}, {"sha": "2509b70563956758860d1f855675d71d5e2c68f7", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -330,8 +330,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n-                self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n-                return self.arena.alloc(self.expr_err(expr.span));\n+                let guar = self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n+                return self.arena.alloc(self.expr_err(expr.span, guar));\n             }\n         }\n         self.lower_expr(expr)"}, {"sha": "8bd212073a65a8ada361244ff56b47a1624eb053", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n itertools = \"0.10.1\"\n-tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n@@ -16,4 +16,5 @@ rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "747bd52b22c7d6b14fe9ffdb88d5a4bdd4877113", "filename": "compiler/rustc_ast_passes/locales/en-US.ftl", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -0,0 +1,236 @@\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_forbidden_let_stable =\n+    expected expression, found statement (`let`)\n+    .note = variable declaration using `let` is a statement\n+\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_invalid_visibility =\n+    unnecessary visibility qualifier\n+    .implied = `pub` not permitted here because it's implied\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n+\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n+\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n+\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n+\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n+\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n+\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n+\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n+\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n+\n+ast_passes_assoc_const_without_body =\n+    associated constant in `impl` without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_assoc_fn_without_body =\n+    associated function in `impl` without body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_assoc_type_without_body =\n+    associated type in `impl` without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_const_without_body =\n+    free constant item without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n+\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n+\n+ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+\n+ast_passes_extern_types_cannot = `type`s inside `extern` blocks cannot have {$descr}\n+    .suggestion = remove the {$remove_descr}\n+    .label = `extern` block begins here\n+\n+ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n+    .cannot_have = cannot have a body\n+    .invalid = the invalid body\n+    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+\n+ast_passes_fn_body_extern = incorrect function inside `extern` block\n+    .cannot_have = cannot have a body\n+    .suggestion = remove the invalid body\n+    .help = you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+    .label = `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+\n+ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n+    .label = in this `extern` block\n+    .suggestion = remove the qualifiers\n+\n+ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n+    .label = in this `extern` block\n+    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+\n+ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+\n+ast_passes_item_underscore = `{$kind}` items in this context need a name\n+    .label = `_` is not a valid name for this `{$kind}` item\n+\n+ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n+\n+ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n+    .help = consider using the `#[path]` attribute to specify filesystem path\n+\n+ast_passes_auto_generic = auto traits cannot have generic parameters\n+    .label = auto trait cannot have generic parameters\n+    .suggestion = remove the parameters\n+\n+ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n+    .label = {ast_passes_auto_super_lifetime}\n+    .suggestion = remove the super traits or lifetime bounds\n+\n+ast_passes_auto_items = auto traits cannot have associated items\n+    .label = {ast_passes_auto_items}\n+    .suggestion = remove these associated items\n+\n+ast_passes_generic_before_constraints = generic arguments must come before the first constraint\n+    .constraints = {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    }\n+    .args = generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+    .empty_string = {\"\"},\n+    .suggestion = move the {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    } after the generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n+\n+ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n+\n+ast_passes_impl_trait_path = `impl Trait` is not allowed in path parameters\n+\n+ast_passes_nested_impl_trait = nested `impl Trait` is not allowed\n+    .outer = outer `impl Trait`\n+    .inner = nested `impl Trait` here\n+\n+ast_passes_at_least_one_trait = at least one trait must be specified\n+\n+ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n+\n+ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n+    .suggestion = reorder the parameters: lifetimes, then consts and types\n+\n+ast_passes_obsolete_auto = `impl Trait for .. {\"{}\"}` is an obsolete syntax\n+    .help = use `auto trait Trait {\"{}\"}` instead\n+\n+ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n+    .negative = negative because of this\n+    .unsafe = unsafe because of this\n+\n+ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n+    .because = {$annotation} because of this\n+    .type = inherent impl for this type\n+    .only_trait = only trait implementations may be annotated with {$annotation}\n+\n+ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n+\n+ast_passes_fieldless_union = unions cannot have zero fields\n+\n+ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n+    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n+\n+ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n+\n+ast_passes_nested_lifetimes = nested quantification of lifetimes\n+\n+ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n+    .note = traits are `?{$path_str}` by default\n+\n+ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n+\n+ast_passes_tilde_const_disallowed = `~const` is not allowed here\n+    .trait = trait objects cannot have `~const` trait bounds\n+    .closure = closures cannot have `~const` trait bounds\n+    .function = this function is not `const`, so it cannot have `~const` trait bounds\n+\n+ast_passes_optional_const_exclusive = `~const` and `?` are mutually exclusive\n+\n+ast_passes_const_and_async = functions cannot be both `const` and `async`\n+    .const = `const` because of this\n+    .async = `async` because of this\n+    .label = {\"\"}\n+\n+ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n+    .label = pattern not allowed in foreign function\n+\n+ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n+    .label = pattern not allowed in function without body\n+\n+ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n+    .label = not supported\n+    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n+    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n+    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+\n+ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+\n+ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n+    .suggestion = remove the attribute\n+    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+\n+ast_passes_incompatbile_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+    .help = remove one of these features\n+\n+ast_passes_show_span = {$msg}"}, {"sha": "1c561375626cf2d3325c3370ddf57a6727605f28", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 182, "deletions": 417, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -13,7 +13,6 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, fluent, pluralize, struct_span_err, Applicability};\n use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n@@ -27,11 +26,10 @@ use rustc_span::Span;\n use rustc_target::spec::abi;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n+use thin_vec::thin_vec;\n \n-use crate::errors::*;\n-\n-const MORE_EXTERN: &str =\n-    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n+use crate::errors;\n+use crate::fluent_generated as fluent;\n \n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n enum SelfSemantic {\n@@ -69,10 +67,6 @@ struct AstValidator<'a> {\n     /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n \n-    /// Used to ban associated type bounds (i.e., `Type<AssocType: Bounds>`) in\n-    /// certain positions.\n-    is_assoc_ty_bound_banned: bool,\n-\n     /// See [ForbiddenLetReason]\n     forbidden_let_reason: Option<ForbiddenLetReason>,\n \n@@ -136,9 +130,9 @@ impl<'a> AstValidator<'a> {\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n         let sess = &self.session;\n         if sess.opts.unstable_features.is_nightly_build() {\n-            sess.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n+            sess.emit_err(errors::ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n         } else {\n-            sess.emit_err(ForbiddenLetStable { span: expr.span });\n+            sess.emit_err(errors::ForbiddenLetStable { span: expr.span });\n         }\n     }\n \n@@ -178,30 +172,12 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn with_banned_assoc_ty_bound(&mut self, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.is_assoc_ty_bound_banned, true);\n-        f(self);\n-        self.is_assoc_ty_bound_banned = old;\n-    }\n-\n     fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         f(self);\n         self.outer_impl_trait = old;\n     }\n \n-    fn visit_assoc_constraint_from_generic_args(&mut self, constraint: &'a AssocConstraint) {\n-        match constraint.kind {\n-            AssocConstraintKind::Equality { .. } => {}\n-            AssocConstraintKind::Bound { .. } => {\n-                if self.is_assoc_ty_bound_banned {\n-                    self.session.emit_err(ForbiddenAssocConstraint { span: constraint.span });\n-                }\n-            }\n-        }\n-        self.visit_assoc_constraint(constraint);\n-    }\n-\n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n         match &t.kind {\n@@ -254,22 +230,22 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(KeywordLifetime { span: ident.span });\n+            self.session.emit_err(errors::KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n+            self.session.emit_err(errors::InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<errors::InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        self.session.emit_err(InvalidVisibility {\n+        self.session.emit_err(errors::InvalidVisibility {\n             span: vis.span,\n             implied: vis.kind.is_pub().then_some(vis.span),\n             note,\n@@ -290,7 +266,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            self.session.emit_err(TraitFnConst { span });\n+            self.session.emit_err(errors::TraitFnConst { span });\n         }\n     }\n \n@@ -307,21 +283,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n+            self.session.emit_fatal(errors::FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n+                    self.session.emit_err(errors::FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n+                        self.session.emit_err(errors::FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -348,25 +324,25 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.session.emit_err(FnParamDocComment { span: attr.span });\n+                    self.session.emit_err(errors::FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n+                    self.session.emit_err(errors::FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n+                self.session.emit_err(errors::FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.session.emit_err(ForbiddenDefault { span, def_span });\n+            self.session.emit_err(errors::ForbiddenDefault { span, def_span });\n         }\n     }\n \n@@ -389,27 +365,17 @@ impl<'a> AstValidator<'a> {\n             [b0] => b0.span(),\n             [b0, .., bl] => b0.span().to(bl.span()),\n         };\n-        self.err_handler()\n-            .struct_span_err(span, &format!(\"bounds on `type`s in {} have no effect\", ctx))\n-            .emit();\n+        self.err_handler().emit_err(errors::BoundInContext { span, ctx });\n     }\n \n     fn check_foreign_ty_genericless(&self, generics: &Generics, where_span: Span) {\n         let cannot_have = |span, descr, remove_descr| {\n-            self.err_handler()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"`type`s inside `extern` blocks cannot have {}\", descr),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove the {}\", remove_descr),\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .span_label(self.current_extern_span(), \"`extern` block begins here\")\n-                .note(MORE_EXTERN)\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternTypesCannotHave {\n+                span,\n+                descr,\n+                remove_descr,\n+                block_span: self.current_extern_span(),\n+            });\n         };\n \n         if !generics.params.is_empty() {\n@@ -425,47 +391,24 @@ impl<'a> AstValidator<'a> {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_label(body, \"the invalid body\")\n-            .span_label(\n-                self.current_extern_span(),\n-                format!(\n-                    \"`extern` blocks define existing foreign {0}s and {0}s \\\n-                    inside of them cannot have a body\",\n-                    kind\n-                ),\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::BodyInExtern {\n+            span: ident.span,\n+            body,\n+            block: self.current_extern_span(),\n+            kind,\n+        });\n     }\n \n     /// An `fn` in `extern { ... }` cannot have a body `{ ... }`.\n     fn check_foreign_fn_bodyless(&self, ident: Ident, body: Option<&Block>) {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, \"incorrect function inside `extern` block\")\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_suggestion(\n-                body.span,\n-                \"remove the invalid body\",\n-                \";\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .help(\n-                \"you might have meant to write a function accessible through FFI, \\\n-                which can be done by writing `extern fn` outside of the `extern` block\",\n-            )\n-            .span_label(\n-                self.current_extern_span(),\n-                \"`extern` blocks define existing foreign functions and functions \\\n-                inside of them cannot have a body\",\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::FnBodyInExtern {\n+            span: ident.span,\n+            body: body.span,\n+            block: self.current_extern_span(),\n+        });\n     }\n \n     fn current_extern_span(&self) -> Span {\n@@ -475,34 +418,21 @@ impl<'a> AstValidator<'a> {\n     /// An `fn` in `extern { ... }` cannot have qualifiers, e.g. `async fn`.\n     fn check_foreign_fn_headerless(&self, ident: Ident, span: Span, header: FnHeader) {\n         if header.has_qualifiers() {\n-            self.err_handler()\n-                .struct_span_err(ident.span, \"functions in `extern` blocks cannot have qualifiers\")\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .span_suggestion_verbose(\n-                    span.until(ident.span.shrink_to_lo()),\n-                    \"remove the qualifiers\",\n-                    \"fn \",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.err_handler().emit_err(errors::FnQualifierInExtern {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+                sugg_span: span.until(ident.span.shrink_to_lo()),\n+            });\n         }\n     }\n \n     /// An item in `extern { ... }` cannot use non-ascii identifier.\n     fn check_foreign_item_ascii_only(&self, ident: Ident) {\n         if !ident.as_str().is_ascii() {\n-            let n = 83942;\n-            self.err_handler()\n-                .struct_span_err(\n-                    ident.span,\n-                    \"items in `extern` blocks cannot use non-ascii identifiers\",\n-                )\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .note(&format!(\n-                    \"this limitation may be lifted in the future; see issue #{} <https://github.com/rust-lang/rust/issues/{}> for more information\",\n-                    n, n,\n-                ))\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternItemAscii {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+            });\n         }\n     }\n \n@@ -525,12 +455,7 @@ impl<'a> AstValidator<'a> {\n \n         for Param { ty, span, .. } in &fk.decl().inputs {\n             if let TyKind::CVarArgs = ty.kind {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        *span,\n-                        \"only foreign or `unsafe extern \\\"C\\\"` functions may be C-variadic\",\n-                    )\n-                    .emit();\n+                self.err_handler().emit_err(errors::BadCVariadic { span: *span });\n             }\n         }\n     }\n@@ -539,75 +464,32 @@ impl<'a> AstValidator<'a> {\n         if ident.name != kw::Underscore {\n             return;\n         }\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"`{}` items in this context need a name\", kind))\n-            .span_label(ident.span, format!(\"`_` is not a valid name for this `{}` item\", kind))\n-            .emit();\n+        self.err_handler().emit_err(errors::ItemUnderscore { span: ident.span, kind });\n     }\n \n     fn check_nomangle_item_asciionly(&self, ident: Ident, item_span: Span) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        let head_span = self.session.source_map().guess_head_span(item_span);\n-        struct_span_err!(\n-            self.session,\n-            head_span,\n-            E0754,\n-            \"`#[no_mangle]` requires ASCII identifier\"\n-        )\n-        .emit();\n+        let span = self.session.source_map().guess_head_span(item_span);\n+        self.session.emit_err(errors::NoMangleAscii { span });\n     }\n \n     fn check_mod_file_item_asciionly(&self, ident: Ident) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0754,\n-            \"trying to load file for module `{}` with non-ascii identifier name\",\n-            ident.name\n-        )\n-        .help(\"consider using `#[path]` attribute to specify filesystem path\")\n-        .emit();\n+        self.session.emit_err(errors::ModuleNonAscii { span: ident.span, name: ident.name });\n     }\n \n-    fn deny_generic_params(&self, generics: &Generics, ident_span: Span) {\n+    fn deny_generic_params(&self, generics: &Generics, ident: Span) {\n         if !generics.params.is_empty() {\n-            struct_span_err!(\n-                self.session,\n-                generics.span,\n-                E0567,\n-                \"auto traits cannot have generic parameters\"\n-            )\n-            .span_label(ident_span, \"auto trait cannot have generic parameters\")\n-            .span_suggestion(\n-                generics.span,\n-                \"remove the parameters\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.session.emit_err(errors::AutoTraitGeneric { span: generics.span, ident });\n         }\n     }\n \n-    fn emit_e0568(&self, span: Span, ident_span: Span) {\n-        struct_span_err!(\n-            self.session,\n-            span,\n-            E0568,\n-            \"auto traits cannot have super traits or lifetime bounds\"\n-        )\n-        .span_label(ident_span, \"auto trait cannot have super traits or lifetime bounds\")\n-        .span_suggestion(\n-            span,\n-            \"remove the super traits or lifetime bounds\",\n-            \"\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+    fn emit_e0568(&self, span: Span, ident: Span) {\n+        self.session.emit_err(errors::AutoTraitBounds { span, ident });\n     }\n \n     fn deny_super_traits(&self, bounds: &GenericBounds, ident_span: Span) {\n@@ -623,24 +505,11 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn deny_items(&self, trait_items: &[P<AssocItem>], ident_span: Span) {\n+    fn deny_items(&self, trait_items: &[P<AssocItem>], ident: Span) {\n         if !trait_items.is_empty() {\n             let spans: Vec<_> = trait_items.iter().map(|i| i.ident.span).collect();\n-            let total_span = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n-            struct_span_err!(\n-                self.session,\n-                spans,\n-                E0380,\n-                \"auto traits cannot have associated items\"\n-            )\n-            .span_suggestion(\n-                total_span,\n-                \"remove these associated items\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .span_label(ident_span, \"auto trait cannot have associated items\")\n-            .emit();\n+            let total = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n+            self.session.emit_err(errors::AutoTraitItems { spans, total, ident });\n         }\n     }\n \n@@ -686,43 +555,25 @@ impl<'a> AstValidator<'a> {\n         let args_len = arg_spans.len();\n         let constraint_len = constraint_spans.len();\n         // ...and then error:\n-        self.err_handler()\n-            .struct_span_err(\n-                arg_spans.clone(),\n-                \"generic arguments must come before the first constraint\",\n-            )\n-            .span_label(constraint_spans[0], &format!(\"constraint{}\", pluralize!(constraint_len)))\n-            .span_label(\n-                *arg_spans.iter().last().unwrap(),\n-                &format!(\"generic argument{}\", pluralize!(args_len)),\n-            )\n-            .span_labels(constraint_spans, \"\")\n-            .span_labels(arg_spans, \"\")\n-            .span_suggestion_verbose(\n-                data.span,\n-                &format!(\n-                    \"move the constraint{} after the generic argument{}\",\n-                    pluralize!(constraint_len),\n-                    pluralize!(args_len)\n-                ),\n-                self.correct_generic_order_suggestion(&data),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.err_handler().emit_err(errors::ArgsBeforeConstraint {\n+            arg_spans: arg_spans.clone(),\n+            constraints: constraint_spans[0],\n+            args: *arg_spans.iter().last().unwrap(),\n+            data: data.span,\n+            constraint_spans: errors::EmptyLabelManySpans(constraint_spans),\n+            arg_spans2: errors::EmptyLabelManySpans(arg_spans),\n+            suggestion: self.correct_generic_order_suggestion(&data),\n+            constraint_len,\n+            args_len,\n+        });\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n         match &ty.kind {\n             TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::PatternFnPointer { span });\n                 });\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n@@ -734,13 +585,8 @@ impl<'a> AstValidator<'a> {\n                 for bound in bounds {\n                     if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n+                            self.session\n+                                .emit_err(errors::TraitObjectBound { span: lifetime.ident.span });\n                             break;\n                         }\n                         any_lifetime_bounds = true;\n@@ -749,29 +595,19 @@ impl<'a> AstValidator<'a> {\n             }\n             TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::ImplTraitPath { span: ty.span });\n                 }\n \n                 if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n+                    self.session.emit_err(errors::NestedImplTrait {\n+                        span: ty.span,\n+                        outer: outer_impl_trait_sp,\n+                        inner: ty.span,\n+                    });\n                 }\n \n                 if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                    self.err_handler().emit_err(errors::AtLeastOneTrait { span: ty.span });\n                 }\n             }\n             _ => {}\n@@ -792,7 +628,7 @@ impl<'a> AstValidator<'a> {\n                 MISSING_ABI,\n                 id,\n                 span,\n-                \"extern declarations without an explicit ABI are deprecated\",\n+                fluent::ast_passes_extern_without_abi,\n                 BuiltinLintDiagnostics::MissingAbi(span, abi::Abi::FALLBACK),\n             )\n         }\n@@ -865,20 +701,13 @@ fn validate_generic_param_order(\n         ordered_params += \">\";\n \n         for (param_ord, (max_param, spans)) in &out_of_order {\n-            let mut err = handler.struct_span_err(\n-                spans.clone(),\n-                &format!(\n-                    \"{} parameters must be declared prior to {} parameters\",\n-                    param_ord, max_param,\n-                ),\n-            );\n-            err.span_suggestion(\n-                span,\n-                \"reorder the parameters: lifetimes, then consts and types\",\n-                &ordered_params,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            handler.emit_err(errors::OutOfOrderParams {\n+                spans: spans.clone(),\n+                sugg_span: span,\n+                param_ord,\n+                max_param,\n+                ordered_params: &ordered_params,\n+            });\n         }\n     }\n }\n@@ -992,25 +821,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n-                        this.err_handler()\n-                            .struct_span_err(\n-                                item.span,\n-                                \"`impl Trait for .. {}` is an obsolete syntax\",\n-                            )\n-                            .help(\"use `auto trait Trait {}` instead\")\n-                            .emit();\n+                        this.err_handler().emit_err(errors::ObsoleteAuto { span: item.span });\n                     }\n                     if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n                     {\n-                        struct_span_err!(\n-                            this.session,\n-                            sp.to(t.path.span),\n-                            E0198,\n-                            \"negative impls cannot be unsafe\"\n-                        )\n-                        .span_label(sp, \"negative because of this\")\n-                        .span_label(span, \"unsafe because of this\")\n-                        .emit();\n+                        this.session.emit_err(errors::UnsafeNegativeImpl {\n+                            span: sp.to(t.path.span),\n+                            negative: sp,\n+                            r#unsafe: span,\n+                        });\n                     }\n \n                     this.visit_vis(&item.vis);\n@@ -1038,52 +857,54 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self_ty,\n                 items: _,\n             }) => {\n-                let error = |annotation_span, annotation| {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        self_ty.span,\n-                        &format!(\"inherent impls cannot be {}\", annotation),\n-                    );\n-                    err.span_label(annotation_span, &format!(\"{} because of this\", annotation));\n-                    err.span_label(self_ty.span, \"inherent impl for this type\");\n-                    err\n-                };\n+                let error =\n+                    |annotation_span, annotation, only_trait: bool| errors::InherentImplCannot {\n+                        span: self_ty.span,\n+                        annotation_span,\n+                        annotation,\n+                        self_ty: self_ty.span,\n+                        only_trait: only_trait.then_some(()),\n+                    };\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualImplItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    error(span, \"unsafe\").code(error_code!(E0197)).emit();\n+                    self.err_handler().emit_err(errors::InherentImplCannotUnsafe {\n+                        span: self_ty.span,\n+                        annotation_span: span,\n+                        annotation: \"unsafe\",\n+                        self_ty: self_ty.span,\n+                    });\n                 }\n                 if let &ImplPolarity::Negative(span) = polarity {\n-                    error(span, \"negative\").emit();\n+                    self.err_handler().emit_err(error(span, \"negative\", false));\n                 }\n                 if let &Defaultness::Default(def_span) = defaultness {\n-                    error(def_span, \"`default`\")\n-                        .note(\"only trait implementations may be annotated with `default`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(def_span, \"`default`\", true));\n                 }\n                 if let &Const::Yes(span) = constness {\n-                    error(span, \"`const`\")\n-                        .note(\"only trait implementations may be annotated with `const`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(span, \"`const`\", true));\n                 }\n             }\n             ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n                 self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n-                    self.session.emit_err(FnWithoutBody {\n+                    self.session.emit_err(errors::FnWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                         extern_block_suggestion: match sig.header.ext {\n                             Extern::None => None,\n-                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion::Implicit {\n-                                start_span,\n-                                end_span: item.span.shrink_to_hi(),\n-                            }),\n+                            Extern::Implicit(start_span) => {\n+                                Some(errors::ExternBlockSuggestion::Implicit {\n+                                    start_span,\n+                                    end_span: item.span.shrink_to_hi(),\n+                                })\n+                            }\n                             Extern::Explicit(abi, start_span) => {\n-                                Some(ExternBlockSuggestion::Explicit {\n+                                Some(errors::ExternBlockSuggestion::Explicit {\n                                     start_span,\n                                     end_span: item.span.shrink_to_hi(),\n                                     abi: abi.symbol_unescaped,\n@@ -1105,10 +926,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualForeignItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"extern block\" });\n                 }\n                 if abi.is_none() {\n                     self.maybe_lint_missing_abi(item.span, item.id);\n@@ -1148,7 +969,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(unsafety, mod_kind) => {\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"module\" });\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n@@ -1159,40 +980,34 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n-                    self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n+                    self.err_handler().emit_err(errors::FieldlessUnion { span: item.span });\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, *def);\n-                self.session.emit_err(ConstWithoutBody {\n+                self.session.emit_err(errors::ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::Static(.., None) => {\n-                self.session.emit_err(StaticWithoutBody {\n+                self.session.emit_err(errors::StaticWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n                 self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n-                    self.session.emit_err(TyAliasWithoutBody {\n+                    self.session.emit_err(errors::TyAliasWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                     });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        where_clauses.1.1,\n-                        \"where clauses are not allowed after the type for type aliases\",\n-                    );\n-                    err.note(\n-                        \"see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\",\n-                    );\n-                    err.emit();\n+                    self.err_handler()\n+                        .emit_err(errors::WhereAfterTypeAlias { span: where_clauses.1.1 });\n                 }\n             }\n             _ => {}\n@@ -1246,7 +1061,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         // are allowed to contain nested `impl Trait`.\n                         AngleBracketedArg::Constraint(constraint) => {\n                             self.with_impl_trait(None, |this| {\n-                                this.visit_assoc_constraint_from_generic_args(constraint);\n+                                this.visit_assoc_constraint(constraint);\n                             });\n                         }\n                     }\n@@ -1274,11 +1089,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                     if let Some(span) = prev_param_default {\n-                        let mut err = self.err_handler().struct_span_err(\n-                            span,\n-                            \"generic parameters with a default must be trailing\",\n-                        );\n-                        err.emit();\n+                        self.err_handler().emit_err(errors::GenericDefaultTrailing { span });\n                         break;\n                     }\n                 }\n@@ -1306,13 +1117,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             match bound {\n                                 GenericBound::Trait(t, _) => {\n                                     if !t.bound_generic_params.is_empty() {\n-                                        struct_span_err!(\n-                                            self.err_handler(),\n-                                            t.span,\n-                                            E0316,\n-                                            \"nested quantification of lifetimes\"\n-                                        )\n-                                        .emit();\n+                                        self.err_handler()\n+                                            .emit_err(errors::NestedLifetimes { span: t.span });\n                                     }\n                                 }\n                                 GenericBound::Outlives(_) => {}\n@@ -1337,32 +1143,27 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n-                    let mut err = self\n-                        .err_handler()\n-                        .struct_span_err(poly.span, \"`?Trait` is not permitted in supertraits\");\n-                    let path_str = pprust::path_to_string(&poly.trait_ref.path);\n-                    err.note(&format!(\"traits are `?{}` by default\", path_str));\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitSupertrait {\n+                        span: poly.span,\n+                        path_str: pprust::path_to_string(&poly.trait_ref.path)\n+                    });\n                 }\n                 (BoundKind::TraitObject, TraitBoundModifier::Maybe) => {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        poly.span,\n-                        \"`?Trait` is not permitted in trait object types\",\n-                    );\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitObject {span: poly.span});\n                 }\n                 (_, TraitBoundModifier::MaybeConst) if let Some(reason) = &self.disallow_tilde_const => {\n-                    let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n-                    match reason {\n-                        DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n+                    let reason = match reason {\n+                        DisallowTildeConstContext::TraitObject => errors::TildeConstReason::TraitObject,\n+                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => errors::TildeConstReason::Closure,\n+                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => errors::TildeConstReason::Function { ident: ident.span },\n                     };\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::TildeConstDisallowed {\n+                        span: bound.span(),\n+                        reason\n+                    });\n                 }\n                 (_, TraitBoundModifier::MaybeConstMaybe) => {\n-                    self.err_handler()\n-                        .span_err(bound.span(), \"`~const` and `?` are mutually exclusive\");\n+                    self.err_handler().emit_err(errors::OptionalConstExclusive {span: bound.span()});\n                 }\n                 _ => {}\n             }\n@@ -1371,14 +1172,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_param_bound(self, bound)\n     }\n \n-    fn visit_variant_data(&mut self, s: &'a VariantData) {\n-        self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n-    }\n-\n-    fn visit_enum_def(&mut self, enum_definition: &'a EnumDef) {\n-        self.with_banned_assoc_ty_bound(|this| visit::walk_enum_def(this, enum_definition))\n-    }\n-\n     fn visit_fn(&mut self, fk: FnKind<'a>, span: Span, id: NodeId) {\n         // Only associated `fn`s can have `self` parameters.\n         let self_semantic = match fk.ctxt() {\n@@ -1390,21 +1183,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.check_c_variadic_type(fk);\n \n         // Functions cannot both be `const async`\n-        if let Some(FnHeader {\n+        if let Some(&FnHeader {\n             constness: Const::Yes(cspan),\n             asyncness: Async::Yes { span: aspan, .. },\n             ..\n         }) = fk.header()\n         {\n-            self.err_handler()\n-                .struct_span_err(\n-                    vec![*cspan, *aspan],\n-                    \"functions cannot be both `const` and `async`\",\n-                )\n-                .span_label(*cspan, \"`const` because of this\")\n-                .span_label(*aspan, \"`async` because of this\")\n-                .span_label(span, \"\") // Point at the fn header.\n-                .emit();\n+            self.err_handler().emit_err(errors::ConstAndAsync {\n+                spans: vec![cspan, aspan],\n+                cspan,\n+                aspan,\n+                span,\n+            });\n         }\n \n         if let FnKind::Fn(\n@@ -1422,20 +1212,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         // Functions without bodies cannot have patterns.\n         if let FnKind::Fn(ctxt, _, sig, _, _, None) = fk {\n             Self::check_decl_no_pat(&sig.decl, |span, ident, mut_ident| {\n-                let (code, msg, label) = match ctxt {\n-                    FnCtxt::Foreign => (\n-                        error_code!(E0130),\n-                        \"patterns aren't allowed in foreign function declarations\",\n-                        \"pattern not allowed in foreign function\",\n-                    ),\n-                    _ => (\n-                        error_code!(E0642),\n-                        \"patterns aren't allowed in functions without bodies\",\n-                        \"pattern not allowed in function without body\",\n-                    ),\n-                };\n                 if mut_ident && matches!(ctxt, FnCtxt::Assoc(_)) {\n                     if let Some(ident) = ident {\n+                        let msg = match ctxt {\n+                            FnCtxt::Foreign => fluent::ast_passes_pattern_in_foreign,\n+                            _ => fluent::ast_passes_pattern_in_bodiless,\n+                        };\n                         let diag = BuiltinLintDiagnostics::PatternsInFnsWithoutBody(span, ident);\n                         self.lint_buffer.buffer_lint_with_diagnostic(\n                             PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -1446,11 +1228,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         )\n                     }\n                 } else {\n-                    self.err_handler()\n-                        .struct_span_err(span, msg)\n-                        .span_label(span, label)\n-                        .code(code)\n-                        .emit();\n+                    match ctxt {\n+                        FnCtxt::Foreign => {\n+                            self.err_handler().emit_err(errors::PatternInForeign { span })\n+                        }\n+                        _ => self.err_handler().emit_err(errors::PatternInBodiless { span }),\n+                    };\n                 }\n             });\n         }\n@@ -1477,15 +1260,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocConstWithoutBody {\n+                        self.session.emit_err(errors::AssocConstWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n                     }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocFnWithoutBody {\n+                        self.session.emit_err(errors::AssocFnWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1500,7 +1283,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ..\n                 }) => {\n                     if ty.is_none() {\n-                        self.session.emit_err(AssocTypeWithoutBody {\n+                        self.session.emit_err(errors::AssocTypeWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1572,11 +1355,7 @@ fn deny_equality_constraints(\n     predicate: &WhereEqPredicate,\n     generics: &Generics,\n ) {\n-    let mut err = this.err_handler().struct_span_err(\n-        predicate.span,\n-        \"equality constraints are not yet supported in `where` clauses\",\n-    );\n-    err.span_label(predicate.span, \"not supported\");\n+    let mut err = errors::EqualityInWhere { span: predicate.span, assoc: None, assoc2: None };\n \n     // Given `<A as Foo>::Bar = RhsTy`, suggest `A: Foo<Bar = RhsTy>`.\n     if let TyKind::Path(Some(qself), full_path) = &predicate.lhs_ty.kind {\n@@ -1615,25 +1394,17 @@ fn deny_equality_constraints(\n                                         empty_args => {\n                                             *empty_args = AngleBracketedArgs {\n                                                 span: ident.span,\n-                                                args: vec![arg],\n+                                                args: thin_vec![arg],\n                                             }\n                                             .into();\n                                         }\n                                     }\n-                                    err.span_suggestion_verbose(\n-                                        predicate.span,\n-                                        &format!(\n-                                            \"if `{}` is an associated type you're trying to set, \\\n-                                            use the associated type binding syntax\",\n-                                            ident\n-                                        ),\n-                                        format!(\n-                                            \"{}: {}\",\n-                                            param,\n-                                            pprust::path_to_string(&assoc_path)\n-                                        ),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n+                                    err.assoc = Some(errors::AssociatedSuggestion {\n+                                        span: predicate.span,\n+                                        ident: *ident,\n+                                        param: *param,\n+                                        path: pprust::path_to_string(&assoc_path),\n+                                    })\n                                 }\n                                 _ => {}\n                             };\n@@ -1675,26 +1446,21 @@ fn deny_equality_constraints(\n                                         trait_segment.span().shrink_to_hi(),\n                                     ),\n                                 };\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"if `{}::{}` is an associated type you're trying to set, \\\n-                                        use the associated type binding syntax\",\n-                                        trait_segment.ident, potential_assoc.ident,\n-                                    ),\n-                                    vec![(span, args), (predicate.span, String::new())],\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                                err.assoc2 = Some(errors::AssociatedSuggestion2 {\n+                                    span,\n+                                    args,\n+                                    predicate: predicate.span,\n+                                    trait_segment: trait_segment.ident,\n+                                    potential_assoc: potential_assoc.ident,\n+                                });\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-    err.note(\n-        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\",\n-    );\n-    err.emit();\n+    this.err_handler().emit_err(err);\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {\n@@ -1707,7 +1473,6 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         outer_impl_trait: None,\n         disallow_tilde_const: None,\n         is_impl_trait_banned: false,\n-        is_assoc_ty_bound_banned: false,\n         forbidden_let_reason: Some(ForbiddenLetReason::GenericForbidden),\n         lint_buffer: lints,\n     };\n@@ -1722,12 +1487,12 @@ pub(crate) enum ForbiddenLetReason {\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n     /// A let chain with the `||` operator\n-    #[note(not_supported_or)]\n+    #[note(ast_passes_not_supported_or)]\n     NotSupportedOr(#[primary_span] Span),\n     /// A let chain with invalid parentheses\n     ///\n     /// For example, `let 1 = 1 && (expr && expr)` is allowed\n     /// but `(let 1 = 1 && (let 1 = 1 && (let 1 = 1))) && let a = 1` is not\n-    #[note(not_supported_parentheses)]\n+    #[note(ast_passes_not_supported_parentheses)]\n     NotSupportedParentheses(#[primary_span] Span),\n }"}, {"sha": "d007097d91818b6c705b7ad3d34ddbf60139be52", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 478, "deletions": 11, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,9 +1,12 @@\n //! Errors emitted by ast_passes.\n \n+use rustc_ast::ParamKindOrd;\n+use rustc_errors::AddToDiagnostic;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n \n use crate::ast_validation::ForbiddenLetReason;\n+use crate::fluent_generated as fluent;\n \n #[derive(Diagnostic)]\n #[diag(ast_passes_forbidden_let)]\n@@ -23,13 +26,6 @@ pub struct ForbiddenLetStable {\n     pub span: Span,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(ast_passes_forbidden_assoc_constraint)]\n-pub struct ForbiddenAssocConstraint {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(ast_passes_keyword_lifetime)]\n pub struct KeywordLifetime {\n@@ -50,17 +46,17 @@ pub struct InvalidLabel {\n pub struct InvalidVisibility {\n     #[primary_span]\n     pub span: Span,\n-    #[label(implied)]\n+    #[label(ast_passes_implied)]\n     pub implied: Option<Span>,\n     #[subdiagnostic]\n     pub note: Option<InvalidVisibilityNote>,\n }\n \n #[derive(Subdiagnostic)]\n pub enum InvalidVisibilityNote {\n-    #[note(individual_impl_items)]\n+    #[note(ast_passes_individual_impl_items)]\n     IndividualImplItems,\n-    #[note(individual_foreign_items)]\n+    #[note(ast_passes_individual_foreign_items)]\n     IndividualForeignItems,\n }\n \n@@ -224,3 +220,474 @@ pub enum ExternBlockSuggestion {\n         abi: Symbol,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bound_in_context)]\n+pub struct BoundInContext<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_types_cannot)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct ExternTypesCannotHave<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub descr: &'a str,\n+    pub remove_descr: &'a str,\n+    #[label]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_body_in_extern)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct BodyInExtern<'a> {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[label(ast_passes_invalid)]\n+    pub body: Span,\n+    #[label(ast_passes_existing)]\n+    pub block: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fn_body_extern)]\n+#[help]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct FnBodyInExtern {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[suggestion(code = \";\", applicability = \"maybe-incorrect\")]\n+    pub body: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_fn_qualifiers)]\n+pub struct FnQualifierInExtern {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+    #[suggestion(code = \"fn \", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub sugg_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_item_ascii)]\n+#[note]\n+pub struct ExternItemAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bad_c_variadic)]\n+pub struct BadCVariadic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_item_underscore)]\n+pub struct ItemUnderscore<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nomangle_ascii, code = \"E0754\")]\n+pub struct NoMangleAscii {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_module_nonascii, code = \"E0754\")]\n+#[help]\n+pub struct ModuleNonAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_generic, code = \"E0567\")]\n+pub struct AutoTraitGeneric {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_super_lifetime, code = \"E0568\")]\n+pub struct AutoTraitBounds {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_items, code = \"E0380\")]\n+pub struct AutoTraitItems {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub total: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_before_constraints)]\n+pub struct ArgsBeforeConstraint {\n+    #[primary_span]\n+    pub arg_spans: Vec<Span>,\n+    #[label(ast_passes_constraints)]\n+    pub constraints: Span,\n+    #[label(ast_passes_args)]\n+    pub args: Span,\n+    #[suggestion(code = \"{suggestion}\", applicability = \"machine-applicable\", style = \"verbose\")]\n+    pub data: Span,\n+    pub suggestion: String,\n+    pub constraint_len: usize,\n+    pub args_len: usize,\n+    #[subdiagnostic]\n+    pub constraint_spans: EmptyLabelManySpans,\n+    #[subdiagnostic]\n+    pub arg_spans2: EmptyLabelManySpans,\n+}\n+\n+pub struct EmptyLabelManySpans(pub Vec<Span>);\n+\n+// The derive for `Vec<Span>` does multiple calls to `span_label`, adding commas between each\n+impl AddToDiagnostic for EmptyLabelManySpans {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.span_labels(self.0, \"\");\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_fn_pointer, code = \"E0561\")]\n+pub struct PatternFnPointer {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_trait_object_single_bound, code = \"E0226\")]\n+pub struct TraitObjectBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_impl_trait_path, code = \"E0667\")]\n+pub struct ImplTraitPath {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_impl_trait, code = \"E0666\")]\n+pub struct NestedImplTrait {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_outer)]\n+    pub outer: Span,\n+    #[label(ast_passes_inner)]\n+    pub inner: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_at_least_one_trait)]\n+pub struct AtLeastOneTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_out_of_order_params)]\n+pub struct OutOfOrderParams<'a> {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"{ordered_params}\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Span,\n+    pub param_ord: &'a ParamKindOrd,\n+    pub max_param: &'a ParamKindOrd,\n+    pub ordered_params: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_obsolete_auto)]\n+#[help]\n+pub struct ObsoleteAuto {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_negative_impl, code = \"E0198\")]\n+pub struct UnsafeNegativeImpl {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_negative)]\n+    pub negative: Span,\n+    #[label(ast_passes_unsafe)]\n+    pub r#unsafe: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be)]\n+pub struct InherentImplCannot<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+    #[note(ast_passes_only_trait)]\n+    pub only_trait: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be, code = \"E0197\")]\n+pub struct InherentImplCannotUnsafe<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_item)]\n+pub struct UnsafeItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fieldless_union)]\n+pub struct FieldlessUnion {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_where_after_type_alias)]\n+#[note]\n+pub struct WhereAfterTypeAlias {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_default_trailing)]\n+pub struct GenericDefaultTrailing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_lifetimes, code = \"E0316\")]\n+pub struct NestedLifetimes {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_supertrait)]\n+#[note]\n+pub struct OptionalTraitSupertrait {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_object)]\n+pub struct OptionalTraitObject {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_tilde_const_disallowed)]\n+pub struct TildeConstDisallowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: TildeConstReason,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TildeConstReason {\n+    #[note(ast_passes_trait)]\n+    TraitObject,\n+    #[note(ast_passes_closure)]\n+    Closure,\n+    #[note(ast_passes_function)]\n+    Function {\n+        #[primary_span]\n+        ident: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_const_exclusive)]\n+pub struct OptionalConstExclusive {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_const_and_async)]\n+pub struct ConstAndAsync {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label(ast_passes_const)]\n+    pub cspan: Span,\n+    #[label(ast_passes_async)]\n+    pub aspan: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_foreign, code = \"E0130\")]\n+pub struct PatternInForeign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_bodiless, code = \"E0642\")]\n+pub struct PatternInBodiless {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_equality_in_where)]\n+#[note]\n+pub struct EqualityInWhere {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub assoc: Option<AssociatedSuggestion>,\n+    #[subdiagnostic]\n+    pub assoc2: Option<AssociatedSuggestion2>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_passes_suggestion,\n+    code = \"{param}: {path}\",\n+    style = \"verbose\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct AssociatedSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub param: Ident,\n+    pub path: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(ast_passes_suggestion_path, applicability = \"maybe-incorrect\")]\n+pub struct AssociatedSuggestion2 {\n+    #[suggestion_part(code = \"{args}\")]\n+    pub span: Span,\n+    pub args: String,\n+    #[suggestion_part(code = \"\")]\n+    pub predicate: Span,\n+    pub trait_segment: Ident,\n+    pub potential_assoc: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_stability_outside_std, code = \"E0734\")]\n+pub struct StabilityOutsideStd {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_feature_on_non_nightly, code = \"E0554\")]\n+pub struct FeatureOnNonNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub channel: &'static str,\n+    #[subdiagnostic]\n+    pub stable_features: Vec<StableFeature>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub sugg: Option<Span>,\n+}\n+\n+pub struct StableFeature {\n+    pub name: Symbol,\n+    pub since: Symbol,\n+}\n+\n+impl AddToDiagnostic for StableFeature {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"name\", self.name);\n+        diag.set_arg(\"since\", self.since);\n+        diag.help(fluent::ast_passes_stable_since);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_incompatbile_features)]\n+#[help]\n+pub struct IncompatibleFeatures {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub f1: Symbol,\n+    pub f2: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_show_span)]\n+pub struct ShowSpan {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: &'static str,\n+}"}, {"sha": "926b0da2ec610a70a0c5896abc32b3195048485f", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,16 +2,18 @@ use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n-use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n-use crate::errors::ForbiddenLifetimeBound;\n+use crate::errors;\n \n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n@@ -155,14 +157,14 @@ impl<'a> PostExpansionVisitor<'a> {\n                 &self.sess.parse_sess,\n                 sym::non_lifetime_binders,\n                 non_lt_param_spans,\n-                rustc_errors::fluent::ast_passes_forbidden_non_lifetime_param,\n+                crate::fluent_generated::ast_passes_forbidden_non_lifetime_param,\n             )\n             .emit();\n         }\n         for param in params {\n             if !param.bounds.is_empty() {\n                 let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+                self.sess.emit_err(errors::ForbiddenLifetimeBound { spans });\n             }\n         }\n     }\n@@ -216,13 +218,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 || attr.has_name(sym::rustc_const_stable)\n                 || attr.has_name(sym::rustc_default_body_unstable)\n             {\n-                struct_span_err!(\n-                    self.sess,\n-                    attr.span,\n-                    E0734,\n-                    \"stability attributes may not be used outside of the standard library\",\n-                )\n-                .emit();\n+                self.sess.emit_err(errors::StabilityOutsideStd { span: attr.span });\n             }\n         }\n     }\n@@ -250,7 +246,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n             ast::ItemKind::Struct(..) => {\n                 for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n-                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+                    for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n                                 &self,\n@@ -633,13 +629,13 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n             return;\n         }\n         for attr in krate.attrs.iter().filter(|attr| attr.has_name(sym::feature)) {\n-            let mut err = struct_span_err!(\n-                sess.parse_sess.span_diagnostic,\n-                attr.span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n-            );\n+            let mut err = errors::FeatureOnNonNightly {\n+                span: attr.span,\n+                channel: option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\"),\n+                stable_features: vec![],\n+                sugg: None,\n+            };\n+\n             let mut all_stable = true;\n             for ident in\n                 attr.meta_item_list().into_iter().flatten().flat_map(|nested| nested.ident())\n@@ -650,24 +646,15 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n                     .flat_map(|&(feature, _, since)| if feature == name { since } else { None })\n                     .next();\n                 if let Some(since) = stable_since {\n-                    err.help(&format!(\n-                        \"the feature `{}` has been stable since {} and no longer requires \\\n-                                  an attribute to enable\",\n-                        name, since\n-                    ));\n+                    err.stable_features.push(errors::StableFeature { name, since });\n                 } else {\n                     all_stable = false;\n                 }\n             }\n             if all_stable {\n-                err.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                err.sugg = Some(attr.span);\n             }\n-            err.emit();\n+            sess.parse_sess.span_diagnostic.emit_err(err);\n         }\n     }\n }\n@@ -690,16 +677,7 @@ fn check_incompatible_features(sess: &Session) {\n             if let Some((f2_name, f2_span)) = declared_features.clone().find(|(name, _)| name == f2)\n             {\n                 let spans = vec![f1_span, f2_span];\n-                sess.struct_span_err(\n-                    spans,\n-                    &format!(\n-                        \"features `{}` and `{}` are incompatible, using them at the same time \\\n-                        is not allowed\",\n-                        f1_name, f2_name\n-                    ),\n-                )\n-                .help(\"remove one of these features\")\n-                .emit();\n+                sess.emit_err(errors::IncompatibleFeatures { spans, f1: f1_name, f2: f2_name });\n             }\n         }\n     }"}, {"sha": "b9dcaee2373d2f049035383ecde336230b96157f", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -10,12 +10,16 @@\n #![feature(iter_is_partitioned)]\n #![feature(let_chains)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n-#[macro_use]\n-extern crate tracing;\n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n \n pub mod ast_validation;\n mod errors;\n pub mod feature_gate;\n pub mod node_count;\n pub mod show_span;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "280cf3284c38ccd4940902c8c6346a7059ba7603", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,6 +9,8 @@ use rustc_ast as ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n \n+use crate::errors;\n+\n enum Mode {\n     Expression,\n     Pattern,\n@@ -36,21 +38,21 @@ struct ShowSpanVisitor<'a> {\n impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         if let Mode::Expression = self.mode {\n-            self.span_diagnostic.span_warn(e.span, \"expression\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: e.span, msg: \"expression\" });\n         }\n         visit::walk_expr(self, e);\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         if let Mode::Pattern = self.mode {\n-            self.span_diagnostic.span_warn(p.span, \"pattern\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: p.span, msg: \"pattern\" });\n         }\n         visit::walk_pat(self, p);\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n         if let Mode::Type = self.mode {\n-            self.span_diagnostic.span_warn(t.span, \"type\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: t.span, msg: \"type\" });\n         }\n         visit::walk_ty(self, t);\n     }"}, {"sha": "980a8fa93a97d531c1647b902d36e21857f1bd39", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -8,3 +8,4 @@ edition = \"2021\"\n [dependencies]\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n+thin-vec = \"0.2.12\""}, {"sha": "694d688bf1fe0190f557f367c1bd2fd58d7c4065", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -4,7 +4,7 @@ mod item;\n \n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n-\n+use rustc_ast::attr::AttrIdGenerator;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, BinOpToken, CommentKind, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -20,9 +20,8 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n-\n-use rustc_ast::attr::AttrIdGenerator;\n use std::borrow::Cow;\n+use thin_vec::ThinVec;\n \n pub use self::delimited::IterDelimited;\n \n@@ -1722,10 +1721,10 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.print_formal_generic_params(generic_params);\n         let generics = ast::Generics {\n-            params: Vec::new(),\n+            params: ThinVec::new(),\n             where_clause: ast::WhereClause {\n                 has_where_token: false,\n-                predicates: Vec::new(),\n+                predicates: ThinVec::new(),\n                 span: DUMMY_SP,\n             },\n             span: DUMMY_SP,"}, {"sha": "3b2b60a86f06e8d5728a6b0539290f6c9fd3c414", "filename": "compiler/rustc_ast_pretty/src/pprust/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,6 +3,7 @@ use super::*;\n use rustc_ast as ast;\n use rustc_span::create_default_session_globals_then;\n use rustc_span::symbol::Ident;\n+use thin_vec::ThinVec;\n \n fn fun_to_string(\n     decl: &ast::FnDecl,\n@@ -27,8 +28,10 @@ fn test_fun_to_string() {\n     create_default_session_globals_then(|| {\n         let abba_ident = Ident::from_str(\"abba\");\n \n-        let decl =\n-            ast::FnDecl { inputs: Vec::new(), output: ast::FnRetTy::Default(rustc_span::DUMMY_SP) };\n+        let decl = ast::FnDecl {\n+            inputs: ThinVec::new(),\n+            output: ast::FnRetTy::Default(rustc_span::DUMMY_SP),\n+        };\n         let generics = ast::Generics::default();\n         assert_eq!(\n             fun_to_string(&decl, ast::FnHeader::default(), abba_ident, &generics),"}, {"sha": "a7f8c993d4225316129e515ef4e2a84bbe872137", "filename": "compiler/rustc_attr/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_attr%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_attr%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/attr.ftl"}, {"sha": "5fede0a58ac1f0fdf0bd97e62a587a78a91de21f", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -11,6 +11,9 @@\n #[macro_use]\n extern crate rustc_macros;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n+\n mod builtin;\n mod session_diagnostics;\n \n@@ -22,3 +25,5 @@ pub use StabilityLevel::*;\n pub use rustc_ast::attr::*;\n \n pub(crate) use rustc_ast::HashStableContext;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "ee79545e304aea65772b3fc521f4575753063304", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,11 +2,12 @@ use std::num::IntErrorKind;\n \n use rustc_ast as ast;\n use rustc_errors::{\n-    error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n };\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n \n+use crate::fluent_generated as fluent;\n use crate::UnsupportedLiteralReason;\n \n #[derive(Diagnostic)]\n@@ -59,7 +60,7 @@ impl<'a> IntoDiagnostic<'a> for UnknownMetaItem<'_> {\n         );\n         diag.set_arg(\"item\", self.item);\n         diag.set_arg(\"expected\", expected.join(\", \"));\n-        diag.span_label(self.span, fluent::label);\n+        diag.span_label(self.span, fluent::attr_label);\n         diag\n     }\n }\n@@ -99,31 +100,31 @@ pub(crate) struct InvalidIssueString {\n // translatable.\n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidIssueStringCause {\n-    #[label(must_not_be_zero)]\n+    #[label(attr_must_not_be_zero)]\n     MustNotBeZero {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(empty)]\n+    #[label(attr_empty)]\n     Empty {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(invalid_digit)]\n+    #[label(attr_invalid_digit)]\n     InvalidDigit {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(pos_overflow)]\n+    #[label(attr_pos_overflow)]\n     PosOverflow {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(neg_overflow)]\n+    #[label(attr_neg_overflow)]\n     NegOverflow {\n         #[primary_span]\n         span: Span,\n@@ -275,7 +276,7 @@ pub(crate) struct IncorrectReprFormatGeneric<'a> {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n-    #[suggestion(suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n+    #[suggestion(attr_suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n     Int {\n         #[primary_span]\n         span: Span,\n@@ -287,7 +288,7 @@ pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n         int: u128,\n     },\n \n-    #[suggestion(suggestion, code = \"{name}({symbol})\", applicability = \"machine-applicable\")]\n+    #[suggestion(attr_suggestion, code = \"{name}({symbol})\", applicability = \"machine-applicable\")]\n     Symbol {\n         #[primary_span]\n         span: Span,"}, {"sha": "a3b6b5e8138b68ed2e84b37abad09be4ef2577ac", "filename": "compiler/rustc_borrowck/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl"}, {"sha": "1427f5cb31d9c8c14b5a983782e7bbb808f8d6c6", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, RegionVid, Ty};\n+use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n \n use crate::{\n     borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, nll::ToRegionVid,\n@@ -165,7 +165,7 @@ impl<'cx, 'tcx> ConstraintGeneration<'cx, 'tcx> {\n     /// `location`.\n     fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n     where\n-        T: TypeVisitable<'tcx>,\n+        T: TypeVisitable<TyCtxt<'tcx>>,\n     {\n         debug!(\"add_regular_live_constraint(live_ty={:?}, location={:?})\", live_ty, location);\n "}, {"sha": "f370c02161b115590e2333b39f4d1c6866e653e2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -17,7 +17,7 @@ pub(crate) mod graph;\n /// constraints of the form `R1: R2`. Each constraint is identified by\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Debug, Default)]\n pub(crate) struct OutlivesConstraintSet<'tcx> {\n     outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }"}, {"sha": "68205fa45587bb4579060e88285f0459cc15dcbc", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> ToUniverseInfo<'tcx>\n     }\n }\n \n-impl<'tcx, T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx> ToUniverseInfo<'tcx>\n+impl<'tcx, T: Copy + fmt::Display + TypeFoldable<TyCtxt<'tcx>> + 'tcx> ToUniverseInfo<'tcx>\n     for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>\n {\n     fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n@@ -258,7 +258,7 @@ struct NormalizeQuery<'tcx, T> {\n \n impl<'tcx, T> TypeOpInfo<'tcx> for NormalizeQuery<'tcx, T>\n where\n-    T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx,\n+    T: Copy + fmt::Display + TypeFoldable<TyCtxt<'tcx>> + 'tcx,\n {\n     fn fallback_error(\n         &self,"}, {"sha": "7a1066f6b5878b9781cc24cd76d77fd7c593c159", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1494,7 +1494,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assert!(root_place.projection.is_empty());\n         let proper_span = self.body.local_decls[root_place.local].source_info.span;\n \n-        let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n+        let root_place_projection = self.infcx.tcx.mk_place_elems(root_place.projection);\n \n         if self.access_place_error_reported.contains(&(\n             Place { local: root_place.local, projection: root_place_projection },\n@@ -2135,7 +2135,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         let tcx = self.infcx.tcx;\n \n-        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id().to_def_id());\n+        let escapes_from = tcx.def_descr(self.mir_def_id().to_def_id());\n \n         let mut err =\n             borrowck_errors::borrowed_data_escapes_closure(tcx, escape_span, escapes_from);"}, {"sha": "4baf1b6aa8701286d67aa01eb45bb69ad5c7ef4b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -660,10 +660,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             errci.outlived_fr,\n         );\n \n-        let (_, escapes_from) = self\n-            .infcx\n-            .tcx\n-            .article_and_description(self.regioncx.universal_regions().defining_ty.def_id());\n+        let escapes_from =\n+            self.infcx.tcx.def_descr(self.regioncx.universal_regions().defining_ty.def_id());\n \n         // Revert to the normal error in these cases.\n         // Assignments aren't \"escapes\" in function items.\n@@ -757,8 +755,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             ..\n         } = errci;\n \n-        let (_, mir_def_name) =\n-            self.infcx.tcx.article_and_description(self.mir_def_id().to_def_id());\n+        let mir_def_name = self.infcx.tcx.def_descr(self.mir_def_id().to_def_id());\n \n         let err = LifetimeOutliveErr { span: *span };\n         let mut diag = self.infcx.tcx.sess.create_err(err);"}, {"sha": "18d7bde60d789236afa45cee8b3c12a158a722f5", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 94, "deletions": 10, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,7 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n #![allow(rustc::potential_query_instability)]\n+#![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n@@ -20,12 +21,15 @@ extern crate tracing;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{\n+    DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n+};\n+use rustc_macros::fluent_messages;\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n     Place, PlaceElem, PlaceRef, VarDebugInfoContents,\n@@ -43,6 +47,7 @@ use smallvec::SmallVec;\n use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+use std::ops::Deref;\n use std::rc::Rc;\n \n use rustc_mir_dataflow::impls::{\n@@ -94,6 +99,9 @@ use nll::{PoloniusOutput, ToRegionVid};\n use place_ext::PlaceExt;\n use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n+use renumber::RegionCtxt;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n@@ -167,10 +175,10 @@ fn do_mir_borrowck<'tcx>(\n     return_body_with_facts: bool,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.with_opt_param().as_local().unwrap();\n-\n     debug!(?def);\n \n     let tcx = infcx.tcx;\n+    let infcx = BorrowckInferCtxt::new(infcx);\n     let param_env = tcx.param_env(def.did);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n@@ -218,7 +226,7 @@ fn do_mir_borrowck<'tcx>(\n     let mut body_owned = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, param_env, &mut body_owned, &mut promoted);\n+        nll::replace_regions_in_mir(&infcx, param_env, &mut body_owned, &mut promoted);\n     let body = &body_owned; // no further changes\n \n     let location_table_owned = LocationTable::new(body);\n@@ -256,7 +264,7 @@ fn do_mir_borrowck<'tcx>(\n         opt_closure_req,\n         nll_errors,\n     } = nll::compute_regions(\n-        infcx,\n+        &infcx,\n         free_regions,\n         body,\n         &promoted,\n@@ -271,12 +279,12 @@ fn do_mir_borrowck<'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(infcx, &body, &regioncx, &opt_closure_req);\n+    nll::dump_mir_results(&infcx, &body, &regioncx, &opt_closure_req);\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n     nll::dump_annotation(\n-        infcx,\n+        &infcx,\n         &body,\n         &regioncx,\n         &opt_closure_req,\n@@ -320,7 +328,7 @@ fn do_mir_borrowck<'tcx>(\n \n         if let Err((move_data, move_errors)) = move_data_results {\n             let mut promoted_mbcx = MirBorrowckCtxt {\n-                infcx,\n+                infcx: &infcx,\n                 param_env,\n                 body: promoted_body,\n                 move_data: &move_data,\n@@ -349,7 +357,7 @@ fn do_mir_borrowck<'tcx>(\n     }\n \n     let mut mbcx = MirBorrowckCtxt {\n-        infcx,\n+        infcx: &infcx,\n         param_env,\n         body,\n         move_data: &mdpe.move_data,\n@@ -481,8 +489,84 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n     pub location_table: LocationTable,\n }\n \n+pub struct BorrowckInferCtxt<'cx, 'tcx> {\n+    pub(crate) infcx: &'cx InferCtxt<'tcx>,\n+    pub(crate) reg_var_to_origin: RefCell<FxHashMap<ty::RegionVid, RegionCtxt>>,\n+}\n+\n+impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n+    pub(crate) fn new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n+        BorrowckInferCtxt { infcx, reg_var_to_origin: RefCell::new(Default::default()) }\n+    }\n+\n+    pub(crate) fn next_region_var<F>(\n+        &self,\n+        origin: RegionVariableOrigin,\n+        get_ctxt_fn: F,\n+    ) -> ty::Region<'tcx>\n+    where\n+        F: Fn() -> RegionCtxt,\n+    {\n+        let next_region = self.infcx.next_region_var(origin);\n+        let vid = next_region\n+            .as_var()\n+            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+\n+        if cfg!(debug_assertions) {\n+            debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n+            let ctxt = get_ctxt_fn();\n+            let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n+            let prev = var_to_origin.insert(vid, ctxt);\n+\n+            // This only makes sense if not called in a canonicalization context. If this\n+            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+            // or modify how we track nll region vars for that map.\n+            assert!(matches!(prev, None));\n+        }\n+\n+        next_region\n+    }\n+\n+    #[instrument(skip(self, get_ctxt_fn), level = \"debug\")]\n+    pub(crate) fn next_nll_region_var<F>(\n+        &self,\n+        origin: NllRegionVariableOrigin,\n+        get_ctxt_fn: F,\n+    ) -> ty::Region<'tcx>\n+    where\n+        F: Fn() -> RegionCtxt,\n+    {\n+        let next_region = self.infcx.next_nll_region_var(origin.clone());\n+        let vid = next_region\n+            .as_var()\n+            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+\n+        if cfg!(debug_assertions) {\n+            debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n+            let ctxt = get_ctxt_fn();\n+            let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n+            let prev = var_to_origin.insert(vid, ctxt);\n+\n+            // This only makes sense if not called in a canonicalization context. If this\n+            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+            // or modify how we track nll region vars for that map.\n+            assert!(matches!(prev, None));\n+        }\n+\n+        next_region\n+    }\n+}\n+\n+impl<'cx, 'tcx> Deref for BorrowckInferCtxt<'cx, 'tcx> {\n+    type Target = InferCtxt<'tcx>;\n+\n+    fn deref(&self) -> &'cx Self::Target {\n+        self.infcx\n+    }\n+}\n+\n struct MirBorrowckCtxt<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "e5dbb83dd0728e6951daa40bef2a62e1bde61d1f", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,7 +5,6 @@\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n@@ -37,7 +36,7 @@ use crate::{\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n-    Upvar,\n+    BorrowckInferCtxt, Upvar,\n };\n \n pub type PoloniusOutput = Output<RustcFacts>;\n@@ -58,7 +57,7 @@ pub(crate) struct NllOutput<'tcx> {\n /// `compute_regions`.\n #[instrument(skip(infcx, param_env, body, promoted), level = \"debug\")]\n pub(crate) fn replace_regions_in_mir<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n@@ -157,7 +156,7 @@ fn populate_polonius_move_facts(\n ///\n /// This may result in errors being reported.\n pub(crate) fn compute_regions<'cx, 'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -259,6 +258,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     );\n \n     let mut regioncx = RegionInferenceContext::new(\n+        infcx,\n         var_origins,\n         universal_regions,\n         placeholder_indices,\n@@ -322,7 +322,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n }\n \n pub(super) fn dump_mir_results<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n@@ -372,7 +372,7 @@ pub(super) fn dump_mir_results<'tcx>(\n #[allow(rustc::diagnostic_outside_of_impl)]\n #[allow(rustc::untranslatable_diagnostic)]\n pub(super) fn dump_annotation<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,"}, {"sha": "941da2dd3b5fcabe51421c926e1d56eabb1258bc", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n use rustc_span::Span;\n \n use crate::{\n@@ -34,6 +34,7 @@ use crate::{\n     },\n     type_check::{free_region_relations::UniversalRegionRelations, Locations},\n     universal_regions::UniversalRegions,\n+    BorrowckInferCtxt,\n };\n \n mod dump_mir;\n@@ -243,6 +244,70 @@ pub enum ExtraConstraintInfo {\n     PlaceholderFromPredicate(Span),\n }\n \n+#[instrument(skip(infcx, sccs), level = \"debug\")]\n+fn sccs_info<'cx, 'tcx>(\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n+    sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+) {\n+    use crate::renumber::RegionCtxt;\n+\n+    let var_to_origin = infcx.reg_var_to_origin.borrow();\n+\n+    let mut var_to_origin_sorted = var_to_origin.clone().into_iter().collect::<Vec<_>>();\n+    var_to_origin_sorted.sort_by(|a, b| a.0.cmp(&b.0));\n+    let mut debug_str = \"region variables to origins:\\n\".to_string();\n+    for (reg_var, origin) in var_to_origin_sorted.into_iter() {\n+        debug_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n+    }\n+    debug!(debug_str);\n+\n+    let num_components = sccs.scc_data().ranges().len();\n+    let mut components = vec![FxHashSet::default(); num_components];\n+\n+    for (reg_var_idx, scc_idx) in sccs.scc_indices().iter().enumerate() {\n+        let reg_var = ty::RegionVid::from_usize(reg_var_idx);\n+        let origin = var_to_origin.get(&reg_var).unwrap_or_else(|| &RegionCtxt::Unknown);\n+        components[scc_idx.as_usize()].insert((reg_var, *origin));\n+    }\n+\n+    let mut components_str = \"strongly connected components:\".to_string();\n+    for (scc_idx, reg_vars_origins) in components.iter().enumerate() {\n+        let regions_info = reg_vars_origins.clone().into_iter().collect::<Vec<_>>();\n+        components_str.push_str(&format!(\n+            \"{:?}: {:?})\",\n+            ConstraintSccIndex::from_usize(scc_idx),\n+            regions_info,\n+        ))\n+    }\n+    debug!(components_str);\n+\n+    // calculate the best representative for each component\n+    let components_representatives = components\n+        .into_iter()\n+        .enumerate()\n+        .map(|(scc_idx, region_ctxts)| {\n+            let repr = region_ctxts\n+                .into_iter()\n+                .map(|reg_var_origin| reg_var_origin.1)\n+                .max_by(|x, y| x.preference_value().cmp(&y.preference_value()))\n+                .unwrap();\n+\n+            (ConstraintSccIndex::from_usize(scc_idx), repr)\n+        })\n+        .collect::<FxHashMap<_, _>>();\n+\n+    let mut scc_node_to_edges = FxHashMap::default();\n+    for (scc_idx, repr) in components_representatives.iter() {\n+        let edges_range = sccs.scc_data().ranges()[*scc_idx].clone();\n+        let edges = &sccs.scc_data().all_successors()[edges_range];\n+        let edge_representatives =\n+            edges.iter().map(|scc_idx| components_representatives[scc_idx]).collect::<Vec<_>>();\n+        scc_node_to_edges.insert((scc_idx, repr), edge_representatives);\n+    }\n+\n+    debug!(\"SCC edges {:#?}\", scc_node_to_edges);\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -251,7 +316,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// The `outlives_constraints` and `type_tests` are an initial set\n     /// of constraints produced by the MIR type check.\n-    pub(crate) fn new(\n+    pub(crate) fn new<'cx>(\n+        _infcx: &BorrowckInferCtxt<'cx, 'tcx>,\n         var_infos: VarInfos,\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n@@ -263,6 +329,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n+        debug!(\"universal_regions: {:#?}\", universal_regions);\n+        debug!(\"outlives constraints: {:#?}\", outlives_constraints);\n+        debug!(\"placeholder_indices: {:#?}\", placeholder_indices);\n+        debug!(\"type tests: {:#?}\", type_tests);\n+\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .iter()\n@@ -274,6 +345,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let fr_static = universal_regions.fr_static;\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph, fr_static));\n \n+        if cfg!(debug_assertions) {\n+            sccs_info(_infcx, constraint_sccs.clone());\n+        }\n+\n         let mut scc_values =\n             RegionValues::new(elements, universal_regions.len(), &placeholder_indices);\n \n@@ -1291,7 +1366,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// we use this kind of hacky solution.\n     fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'tcx>, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         tcx.fold_regions(value, |r, _db| {\n             let vid = self.to_region_vid(r);"}, {"sha": "c550e37c63eefd06d4532a9c1d1cf34ffb557534", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,12 +1,13 @@\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -149,13 +150,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // once we convert the generic parameters to those of the opaque type.\n             if let Some(prev) = result.get_mut(&opaque_type_key.def_id) {\n                 if prev.ty != ty {\n-                    if !ty.references_error() {\n+                    let guar = ty.error_reported().err().unwrap_or_else(|| {\n                         prev.report_mismatch(\n                             &OpaqueHiddenType { ty, span: concrete_type.span },\n                             infcx.tcx,\n-                        );\n-                    }\n-                    prev.ty = infcx.tcx.ty_error();\n+                        )\n+                    });\n+                    prev.ty = infcx.tcx.ty_error(guar);\n                 }\n                 // Pick a better span if there is one.\n                 // FIXME(oli-obk): collect multiple spans for better diagnostics down the road.\n@@ -178,7 +179,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// region names in error messages.\n     pub(crate) fn name_regions<T>(&self, tcx: TyCtxt<'tcx>, ty: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         tcx.fold_regions(ty, |region, _| match *region {\n             ty::ReVar(vid) => {\n@@ -247,20 +248,20 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n         if let Some(e) = self.tainted_by_errors() {\n-            return self.tcx.ty_error_with_guaranteed(e);\n+            return self.tcx.ty_error(e);\n         }\n \n         let definition_ty = instantiated_ty\n             .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n             .ty;\n \n-        if !check_opaque_type_parameter_valid(\n+        if let Err(guar) = check_opaque_type_parameter_valid(\n             self.tcx,\n             opaque_type_key,\n             origin,\n             instantiated_ty.span,\n         ) {\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error(guar);\n         }\n \n         // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n@@ -273,7 +274,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n         let param_env = self.tcx.param_env(def_id);\n         // HACK This bubble is required for this tests to pass:\n-        // type-alias-impl-trait/issue-67844-nested-opaque.rs\n+        // nested-return-type2-tait2.rs\n+        // nested-return-type2-tait3.rs\n         let infcx =\n             self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n         let ocx = ObligationCtxt::new(&infcx);\n@@ -324,7 +326,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             definition_ty\n         } else {\n             let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-            self.tcx.ty_error_with_guaranteed(reported)\n+            self.tcx.ty_error(reported)\n         }\n     }\n }\n@@ -334,7 +336,7 @@ fn check_opaque_type_parameter_valid(\n     opaque_type_key: OpaqueTypeKey<'_>,\n     origin: OpaqueTyOrigin,\n     span: Span,\n-) -> bool {\n+) -> Result<(), ErrorGuaranteed> {\n     match origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n@@ -357,7 +359,7 @@ fn check_opaque_type_parameter_valid(\n         // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n         //\n         // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return Ok(()),\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n@@ -378,13 +380,13 @@ fn check_opaque_type_parameter_valid(\n             // Prevent `fn foo() -> Foo<u32>` from being defining.\n             let opaque_param = opaque_generics.param_at(i, tcx);\n             let kind = opaque_param.kind.descr();\n-            tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n+\n+            return Err(tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n                 ty: arg,\n                 kind,\n                 span,\n                 param_span: tcx.def_span(opaque_param.def_id),\n-            });\n-            return false;\n+            }));\n         }\n     }\n \n@@ -395,12 +397,13 @@ fn check_opaque_type_parameter_valid(\n                 .into_iter()\n                 .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n                 .collect();\n-            tcx.sess\n+            return Err(tcx\n+                .sess\n                 .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n                 .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n+                .emit());\n         }\n     }\n-    true\n+\n+    Ok(())\n }"}, {"sha": "c361357ca2134462f55a0be0b281010362b409c8", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -181,7 +181,7 @@ impl<N: Idx> LivenessValues<N> {\n /// Maps from `ty::PlaceholderRegion` values that are used in the rest of\n /// rustc to the internal `PlaceholderIndex` values that are used in\n /// NLL.\n-#[derive(Default)]\n+#[derive(Debug, Default)]\n pub(crate) struct PlaceholderIndices {\n     indices: FxIndexSet<ty::PlaceholderRegion>,\n }"}, {"sha": "016f6f78dfa1d4144cfb3c44623a992d325cb122", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,18 +1,20 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+use crate::BorrowckInferCtxt;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::Constant;\n use rustc_middle::mir::{Body, Location, Promoted};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::{Span, Symbol};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n #[instrument(skip(infcx, body, promoted), level = \"debug\")]\n pub fn renumber_mir<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n@@ -29,27 +31,68 @@ pub fn renumber_mir<'tcx>(\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n-#[instrument(skip(infcx), level = \"debug\")]\n-pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> T\n+#[instrument(skip(infcx, get_ctxt_fn), level = \"debug\")]\n+pub(crate) fn renumber_regions<'tcx, T, F>(\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n+    value: T,\n+    get_ctxt_fn: F,\n+) -> T\n where\n-    T: TypeFoldable<'tcx>,\n+    T: TypeFoldable<TyCtxt<'tcx>>,\n+    F: Fn() -> RegionCtxt,\n {\n     infcx.tcx.fold_regions(value, |_region, _depth| {\n         let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n-        infcx.next_nll_region_var(origin)\n+        infcx.next_nll_region_var(origin, || get_ctxt_fn())\n     })\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub(crate) enum BoundRegionInfo {\n+    Name(Symbol),\n+    Span(Span),\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub(crate) enum RegionCtxt {\n+    Location(Location),\n+    TyContext(TyContext),\n+    Free(Symbol),\n+    Bound(BoundRegionInfo),\n+    LateBound(BoundRegionInfo),\n+    Existential(Option<Symbol>),\n+    Placeholder(BoundRegionInfo),\n+    Unknown,\n+}\n+\n+impl RegionCtxt {\n+    /// Used to determine the representative of a component in the strongly connected\n+    /// constraint graph\n+    pub(crate) fn preference_value(self) -> usize {\n+        let _anon = Symbol::intern(\"anon\");\n+\n+        match self {\n+            RegionCtxt::Unknown => 1,\n+            RegionCtxt::Existential(None) => 2,\n+            RegionCtxt::Existential(Some(_anon)) | RegionCtxt::Free(_anon) => 2,\n+            RegionCtxt::Location(_) => 3,\n+            RegionCtxt::TyContext(_) => 4,\n+            _ => 5,\n+        }\n+    }\n+}\n+\n struct NllVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n+    infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n-    fn renumber_regions<T>(&mut self, value: T) -> T\n+    fn renumber_regions<T, F>(&mut self, value: T, region_ctxt_fn: F) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n+        F: Fn() -> RegionCtxt,\n     {\n-        renumber_regions(self.infcx, value)\n+        renumber_regions(self.infcx, value, region_ctxt_fn)\n     }\n }\n \n@@ -60,30 +103,30 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n-        *ty = self.renumber_regions(*ty);\n+        *ty = self.renumber_regions(*ty, || RegionCtxt::TyContext(ty_context));\n \n         debug!(?ty);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(*substs);\n+        *substs = self.renumber_regions(*substs, || RegionCtxt::Location(location));\n \n         debug!(?substs);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n         let old_region = *region;\n-        *region = self.renumber_regions(old_region);\n+        *region = self.renumber_regions(old_region, || RegionCtxt::Location(location));\n \n         debug!(?region);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n         let literal = constant.literal;\n-        constant.literal = self.renumber_regions(literal);\n+        constant.literal = self.renumber_regions(literal, || RegionCtxt::Location(_location));\n         debug!(\"constant: {:#?}\", constant);\n     }\n }"}, {"sha": "a3678929099d10a61b8e3925389cb6e8c5537278", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -55,7 +55,7 @@ pub(crate) struct VarNeedNotMut {\n #[derive(Diagnostic)]\n #[diag(borrowck_var_cannot_escape_closure)]\n #[note]\n-#[note(cannot_escape)]\n+#[note(borrowck_cannot_escape)]\n pub(crate) struct FnMutError {\n     #[primary_span]\n     pub span: Span,\n@@ -223,7 +223,7 @@ pub(crate) struct MoveBorrow<'a> {\n     pub borrow_place: &'a str,\n     pub value_place: &'a str,\n     #[primary_span]\n-    #[label(move_label)]\n+    #[label(borrowck_move_label)]\n     pub span: Span,\n     #[label]\n     pub borrow_span: Span,"}, {"sha": "b27d5d20532135d845a43e830a8d52c01ed3a3bf", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n \n use rustc_infer::infer::{canonical::Canonical, InferOk};\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         canonical: &Canonical<'tcx, T>,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let old_universe = self.infcx.universe();\n \n@@ -117,7 +117,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     pub(super) fn prove_predicates(\n         &mut self,\n-        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx> + std::fmt::Debug>,\n+        predicates: impl IntoIterator<Item: ToPredicate<'tcx> + std::fmt::Debug>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {"}, {"sha": "504633c6a5c3942cbbd482303ddb4b4dd15a5e26", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,8 +6,8 @@ use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_middle::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, ConstraintCategory};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{TypeFoldable, TypeVisitableExt};\n use rustc_span::{Span, DUMMY_SP};\n \n use crate::{\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     ///\n     /// FIXME: This should get removed once higher ranked region obligations\n     /// are dealt with during trait solving.\n-    fn replace_placeholders_with_nll<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n+    fn replace_placeholders_with_nll<T: TypeFoldable<TyCtxt<'tcx>>>(&mut self, value: T) -> T {\n         if value.has_placeholders() {\n             self.tcx.fold_regions(value, |r, _| match *r {\n                 ty::RePlaceholder(placeholder) => {"}, {"sha": "e2f897a89e82e1cc44259842de0e4e228dad2583", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -270,12 +270,13 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 .and(type_op::normalize::Normalize::new(ty))\n                 .fully_perform(self.infcx)\n                 .unwrap_or_else(|_| {\n-                    self.infcx\n+                    let guar = self\n+                        .infcx\n                         .tcx\n                         .sess\n                         .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n                     TypeOpOutput {\n-                        output: self.infcx.tcx.ty_error(),\n+                        output: self.infcx.tcx.ty_error(guar),\n                         constraints: None,\n                         error_info: None,\n                     }"}, {"sha": "473c0596300731ddaddc797d5e2b0e656c976732", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,7 +3,7 @@ use rustc_index::bit_set::HybridBitSet;\n use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n-use rustc_middle::ty::{Ty, TypeVisitable};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeVisitable, TypeVisitableExt};\n use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -477,7 +477,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n     /// points `live_at`.\n     fn add_use_live_facts_for(\n         &mut self,\n-        value: impl TypeVisitable<'tcx>,\n+        value: impl TypeVisitable<TyCtxt<'tcx>>,\n         live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n@@ -542,7 +542,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n     fn make_all_regions_live(\n         elements: &RegionValueElements,\n         typeck: &mut TypeChecker<'_, 'tcx>,\n-        value: impl TypeVisitable<'tcx>,\n+        value: impl TypeVisitable<TyCtxt<'tcx>>,\n         live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);"}, {"sha": "a49da3da6c01344993d9ccf5c9a3d8aa7367b7de", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{\n     self, Binder, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, Dynamic,\n     OpaqueHiddenType, OpaqueTypeKey, RegionVid, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n@@ -64,7 +64,7 @@ use crate::{\n     region_infer::TypeTest,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n-    Upvar,\n+    BorrowckInferCtxt, Upvar,\n };\n \n macro_rules! span_mirbug {\n@@ -123,7 +123,7 @@ mod relate_tys;\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n /// - `elements` -- MIR region map\n pub(crate) fn type_check<'mir, 'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -239,7 +239,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                     decl.hidden_type.span,\n                     &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n                 );\n-                hidden_type.ty = infcx.tcx.ty_error_with_guaranteed(reported);\n+                hidden_type.ty = infcx.tcx.ty_error(reported);\n             }\n \n             (opaque_type_key, (hidden_type, decl.origin))\n@@ -529,9 +529,9 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n-                if place_ty.ty.references_error() {\n+                if let Err(guar) = place_ty.ty.error_reported() {\n                     assert!(self.errors_reported);\n-                    return PlaceTy::from_ty(self.tcx().ty_error());\n+                    return PlaceTy::from_ty(self.tcx().ty_error(guar));\n                 }\n             }\n             place_ty = self.sanitize_projection(place_ty, elem, place, location, context);\n@@ -763,7 +763,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n     fn error(&mut self) -> Ty<'tcx> {\n         self.errors_reported = true;\n-        self.tcx().ty_error()\n+        self.tcx().ty_error_misc()\n     }\n \n     fn get_ambient_variance(&self, context: PlaceContext) -> ty::Variance {\n@@ -866,7 +866,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n struct TypeChecker<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n+    infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n     body: &'a Body<'tcx>,\n@@ -1019,7 +1019,7 @@ impl Locations {\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n-        infcx: &'a InferCtxt<'tcx>,\n+        infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n         body: &'a Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n@@ -1356,11 +1356,34 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 };\n                 let (sig, map) = tcx.replace_late_bound_regions(sig, |br| {\n-                    self.infcx.next_region_var(LateBoundRegion(\n-                        term.source_info.span,\n-                        br.kind,\n-                        LateBoundRegionConversionTime::FnCall,\n-                    ))\n+                    use crate::renumber::{BoundRegionInfo, RegionCtxt};\n+                    use rustc_span::Symbol;\n+\n+                    let region_ctxt_fn = || {\n+                        let reg_info = match br.kind {\n+                            ty::BoundRegionKind::BrAnon(_, Some(span)) => {\n+                                BoundRegionInfo::Span(span)\n+                            }\n+                            ty::BoundRegionKind::BrAnon(..) => {\n+                                BoundRegionInfo::Name(Symbol::intern(\"anon\"))\n+                            }\n+                            ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n+                            ty::BoundRegionKind::BrEnv => {\n+                                BoundRegionInfo::Name(Symbol::intern(\"env\"))\n+                            }\n+                        };\n+\n+                        RegionCtxt::LateBound(reg_info)\n+                    };\n+\n+                    self.infcx.next_region_var(\n+                        LateBoundRegion(\n+                            term.source_info.span,\n+                            br.kind,\n+                            LateBoundRegionConversionTime::FnCall,\n+                        ),\n+                        region_ctxt_fn,\n+                    )\n                 });\n                 debug!(?sig);\n                 // IMPORTANT: We have to prove well formed for the function signature before\n@@ -2610,7 +2633,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             DefKind::InlineConst => substs.as_inline_const().parent_substs(),\n             other => bug!(\"unexpected item {:?}\", other),\n         };\n-        let parent_substs = tcx.intern_substs(parent_substs);\n+        let parent_substs = tcx.mk_substs(parent_substs);\n \n         assert_eq!(typeck_root_substs.len(), parent_substs.len());\n         if let Err(_) = self.eq_substs("}, {"sha": "d96372fb99baab5c4c38b4228dee79ca0bb340c3", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -4,11 +4,12 @@ use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n+use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::type_check::{InstantiateOpaqueType, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -100,23 +101,65 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         universe\n     }\n \n-    fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn next_existential_region_var(\n+        &mut self,\n+        from_forall: bool,\n+        _name: Option<Symbol>,\n+    ) -> ty::Region<'tcx> {\n         let origin = NllRegionVariableOrigin::Existential { from_forall };\n-        self.type_checker.infcx.next_nll_region_var(origin)\n+\n+        let reg_var =\n+            self.type_checker.infcx.next_nll_region_var(origin, || RegionCtxt::Existential(_name));\n+\n+        reg_var\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        self.type_checker\n+        let reg = self\n+            .type_checker\n             .borrowck_context\n             .constraints\n-            .placeholder_region(self.type_checker.infcx, placeholder)\n+            .placeholder_region(self.type_checker.infcx, placeholder);\n+\n+        let reg_info = match placeholder.name {\n+            ty::BoundRegionKind::BrAnon(_, Some(span)) => BoundRegionInfo::Span(span),\n+            ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(Symbol::intern(\"anon\")),\n+            ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n+            ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(Symbol::intern(\"env\")),\n+        };\n+\n+        let reg_var =\n+            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n+        let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+        let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+        assert!(matches!(prev, None));\n+\n+        reg\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n-        self.type_checker.infcx.next_nll_region_var_in_universe(\n+        let reg = self.type_checker.infcx.next_nll_region_var_in_universe(\n             NllRegionVariableOrigin::Existential { from_forall: false },\n             universe,\n-        )\n+        );\n+\n+        let reg_var =\n+            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n+\n+        if cfg!(debug_assertions) {\n+            let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+            let prev = var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n+\n+            // It only makes sense to track region vars in non-canonicalization contexts. If this\n+            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+            // or modify how we track nll region vars for that map.\n+            assert!(matches!(prev, None));\n+        }\n+\n+        reg\n     }\n \n     fn push_outlives("}, {"sha": "e058fe0db222c920cadd0c874631416dd53b7f9e", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 99, "deletions": 26, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -20,15 +20,18 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{\n     self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n };\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n+use rustc_span::Symbol;\n use std::iter;\n \n use crate::nll::ToRegionVid;\n+use crate::renumber::{BoundRegionInfo, RegionCtxt};\n+use crate::BorrowckInferCtxt;\n \n #[derive(Debug)]\n pub struct UniversalRegions<'tcx> {\n@@ -224,7 +227,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// signature. This will also compute the relationships that are\n     /// known between those regions.\n     pub fn new(\n-        infcx: &InferCtxt<'tcx>,\n+        infcx: &BorrowckInferCtxt<'_, 'tcx>,\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n@@ -385,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n }\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -403,7 +406,10 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n \n         // Create the \"global\" region that is always free in all contexts: 'static.\n-        let fr_static = self.infcx.next_nll_region_var(FR).to_region_vid();\n+        let fr_static = self\n+            .infcx\n+            .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"static\")))\n+            .to_region_vid();\n \n         // We've now added all the global regions. The next ones we\n         // add will be external.\n@@ -435,7 +441,17 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 |r| {\n                     debug!(?r);\n                     if !indices.indices.contains_key(&r) {\n-                        let region_vid = self.infcx.next_nll_region_var(FR);\n+                        let region_vid = {\n+                            let name = match r.get_name() {\n+                                Some(name) => name,\n+                                _ => Symbol::intern(\"anon\"),\n+                            };\n+\n+                            self.infcx.next_nll_region_var(FR, || {\n+                                RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                            })\n+                        };\n+\n                         debug!(?region_vid);\n                         indices.insert_late_bound_region(r, region_vid.to_region_vid());\n                     }\n@@ -463,7 +479,17 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n-                let region_vid = self.infcx.next_nll_region_var(FR);\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.infcx.next_nll_region_var(FR, || {\n+                        RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                    })\n+                };\n+\n                 debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n@@ -480,18 +506,27 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     LangItem::VaList,\n                     Some(self.infcx.tcx.def_span(self.mir_def.did)),\n                 );\n-                let region =\n-                    self.infcx.tcx.mk_re_var(self.infcx.next_nll_region_var(FR).to_region_vid());\n+\n+                let reg_vid = self\n+                    .infcx\n+                    .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"c-variadic\")))\n+                    .to_region_vid();\n+\n+                let region = self.infcx.tcx.mk_re_var(reg_vid);\n                 let va_list_ty =\n                     self.infcx.tcx.type_of(va_list_did).subst(self.infcx.tcx, &[region.into()]);\n \n-                unnormalized_input_tys = self.infcx.tcx.mk_type_list(\n+                unnormalized_input_tys = self.infcx.tcx.mk_type_list_from_iter(\n                     unnormalized_input_tys.iter().copied().chain(iter::once(va_list_ty)),\n                 );\n             }\n         }\n \n-        let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n+        let fr_fn_body = self\n+            .infcx\n+            .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"fn_body\")))\n+            .to_region_vid();\n+\n         let num_universals = self.infcx.num_region_vars();\n \n         debug!(\"build: global regions = {}..{}\", FIRST_GLOBAL_INDEX, first_extern_index);\n@@ -621,7 +656,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n-                let bound_vars = tcx.mk_bound_variable_kinds(\n+                let bound_vars = tcx.mk_bound_variable_kinds_from_iter(\n                     inputs_and_output\n                         .bound_vars()\n                         .iter()\n@@ -645,7 +680,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 };\n \n                 ty::Binder::bind_with_vars(\n-                    tcx.mk_type_list(\n+                    tcx.mk_type_list_from_iter(\n                         iter::once(closure_ty).chain(inputs).chain(iter::once(output)),\n                     ),\n                     bound_vars,\n@@ -658,7 +693,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n                 let inputs_and_output =\n-                    self.infcx.tcx.intern_type_list(&[generator_ty, resume_ty, output]);\n+                    self.infcx.tcx.mk_type_list(&[generator_ty, resume_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)\n             }\n \n@@ -674,13 +709,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n                 let ty = indices.fold_to_region_vids(tcx, ty);\n-                ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n+                ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }\n \n             DefiningTy::InlineConst(def_id, substs) => {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let ty = substs.as_inline_const().ty();\n-                ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n+                ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }\n         }\n     }\n@@ -693,7 +728,7 @@ trait InferCtxtExt<'tcx> {\n         value: T,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>;\n+        T: TypeFoldable<TyCtxt<'tcx>>;\n \n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n@@ -703,7 +738,7 @@ trait InferCtxtExt<'tcx> {\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>;\n+        T: TypeFoldable<TyCtxt<'tcx>>;\n \n     fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n         &self,\n@@ -718,16 +753,27 @@ trait InferCtxtExt<'tcx> {\n     );\n }\n \n-impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n         value: T,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        self.tcx.fold_regions(value, |_region, _depth| self.next_nll_region_var(origin))\n+        self.infcx.tcx.fold_regions(value, |region, _depth| {\n+            let name = match region.get_name() {\n+                Some(name) => name,\n+                _ => Symbol::intern(\"anon\"),\n+            };\n+            debug!(?region, ?name);\n+\n+            let reg_var = self.next_nll_region_var(origin, || RegionCtxt::Free(name));\n+\n+            reg_var\n+        })\n     }\n \n     #[instrument(level = \"debug\", skip(self, indices))]\n@@ -739,12 +785,20 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(?br);\n             let liberated_region = self.tcx.mk_re_free(all_outlive_scope.to_def_id(), br.kind);\n-            let region_vid = self.next_nll_region_var(origin);\n+            let region_vid = {\n+                let name = match br.kind.get_name() {\n+                    Some(name) => name,\n+                    _ => Symbol::intern(\"anon\"),\n+                };\n+\n+                self.next_nll_region_var(origin, || RegionCtxt::Bound(BoundRegionInfo::Name(name)))\n+            };\n+\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n             debug!(?liberated_region, ?region_vid);\n             region_vid\n@@ -770,7 +824,17 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         for_each_late_bound_region_in_recursive_scope(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n-                let region_vid = self.next_nll_region_var(FR);\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.next_nll_region_var(FR, || {\n+                        RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                    })\n+                };\n+\n                 debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n@@ -786,8 +850,17 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         for_each_late_bound_region_in_item(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n-                let region_vid = self.next_nll_region_var(FR);\n-                debug!(?region_vid);\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.next_nll_region_var(FR, || {\n+                        RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                    })\n+                };\n+\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });\n@@ -833,7 +906,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// returned by `to_region_vid`.\n     pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'tcx>, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         tcx.fold_regions(value, |region, _| tcx.mk_re_var(self.to_region_vid(region)))\n     }"}, {"sha": "336e14ef966309103e09cbfcc142942a222b2318", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -23,5 +23,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "4d088e27b364ae36762db7512961333e7a34849f", "filename": "compiler/rustc_builtin_macros/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/builtin_macros.ftl"}, {"sha": "ac6697232cb827f8afe85f13c03aad3d97ed7dda", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -39,10 +39,10 @@ pub fn expand(\n     let span = ecx.with_def_site_ctxt(item.span);\n \n     // Generate item statements for the allocator methods.\n-    let stmts = vec![generate_handler(ecx, item.ident, span, sig_span)];\n+    let stmts = thin_vec![generate_handler(ecx, item.ident, span, sig_span)];\n \n     // Generate anonymous constant serving as container for the allocator methods.\n-    let const_ty = ecx.ty(sig_span, TyKind::Tup(Vec::new()));\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(ThinVec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n     let const_item = if is_stmt {\n@@ -67,13 +67,16 @@ fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span\n \n     let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n     let layout_new = cx.expr_path(cx.path(span, layout_new));\n-    let layout =\n-        cx.expr_call(span, layout_new, vec![cx.expr_ident(span, size), cx.expr_ident(span, align)]);\n+    let layout = cx.expr_call(\n+        span,\n+        layout_new,\n+        thin_vec![cx.expr_ident(span, size), cx.expr_ident(span, align)],\n+    );\n \n-    let call = cx.expr_call_ident(sig_span, handler, vec![layout]);\n+    let call = cx.expr_call_ident(sig_span, handler, thin_vec![layout]);\n \n     let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n-    let params = vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let params = thin_vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n     let decl = cx.fn_decl(params, never);\n     let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n     let sig = FnSig { decl, header, span: span };"}, {"sha": "3fdbc9715275fff1f343ba025eb958b55563b93a", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -152,7 +152,7 @@ pub fn parse_asm_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n         } else if p.eat_keyword(kw::Const) {\n-            let anon_const = p.parse_anon_const_expr()?;\n+            let anon_const = p.parse_expr_anon_const()?;\n             ast::InlineAsmOperand::Const { anon_const }\n         } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;"}, {"sha": "75af5e2b1fade53652b502ecfc35601f63c65c61", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -11,6 +11,7 @@ use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n use rustc_parse::parser::Parser;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use thin_vec::thin_vec;\n \n pub fn expand_assert<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n@@ -79,7 +80,7 @@ pub fn expand_assert<'cx>(\n         let then = cx.expr_call_global(\n             call_site_span,\n             cx.std_path(&[sym::panicking, sym::panic]),\n-            vec![cx.expr_str(\n+            thin_vec![cx.expr_str(\n                 DUMMY_SP,\n                 Symbol::intern(&format!(\n                     \"assertion failed: {}\","}, {"sha": "b0b4dda16aff2c38069c3f18f5ed4b3e4860b16f", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -12,7 +12,7 @@ use rustc_span::{\n     symbol::{sym, Ident, Symbol},\n     Span,\n };\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub(super) struct Context<'cx, 'a> {\n     // An optimization.\n@@ -83,12 +83,12 @@ impl<'cx, 'a> Context<'cx, 'a> {\n \n         let Self { best_case_captures, capture_decls, cx, local_bind_decls, span, .. } = self;\n \n-        let mut assert_then_stmts = Vec::with_capacity(2);\n+        let mut assert_then_stmts = ThinVec::with_capacity(2);\n         assert_then_stmts.extend(best_case_captures);\n         assert_then_stmts.push(self.cx.stmt_expr(panic));\n         let assert_then = self.cx.block(span, assert_then_stmts);\n \n-        let mut stmts = Vec::with_capacity(4);\n+        let mut stmts = ThinVec::with_capacity(4);\n         stmts.push(initial_imports);\n         stmts.extend(capture_decls.into_iter().map(|c| c.decl));\n         stmts.extend(local_bind_decls);\n@@ -120,7 +120,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                 thin_vec![self.cx.attr_nested_word(sym::allow, sym::unused_imports, self.span)],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n-                    kind: UseTreeKind::Nested(vec![\n+                    kind: UseTreeKind::Nested(thin_vec![\n                         nested_tree(self, sym::TryCaptureGeneric),\n                         nested_tree(self, sym::TryCapturePrintable),\n                     ]),\n@@ -136,7 +136,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         self.cx.expr_call(\n             self.span,\n             self.cx.expr_path(self.cx.path(self.span, unlikely_path)),\n-            vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n+            thin_vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n         )\n     }\n \n@@ -339,7 +339,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         let init = self.cx.expr_call(\n             self.span,\n             self.cx.expr_path(self.cx.path(self.span, init_std_path)),\n-            vec![],\n+            ThinVec::new(),\n         );\n         let capture = Capture { decl: self.cx.stmt_let(self.span, true, ident, init), ident };\n         self.capture_decls.push(capture);\n@@ -366,7 +366,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.expr_path(\n                 self.cx.path(self.span, self.cx.std_path(&[sym::asserting, sym::Wrapper])),\n             ),\n-            vec![self.cx.expr_path(Path::from_ident(local_bind))],\n+            thin_vec![self.cx.expr_path(Path::from_ident(local_bind))],\n         );\n         let try_capture_call = self\n             .cx\n@@ -378,7 +378,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     ident: Ident::new(sym::try_capture, self.span),\n                 },\n                 expr_paren(self.cx, self.span, self.cx.expr_addr_of(self.span, wrapper)),\n-                vec![expr_addr_of_mut(\n+                thin_vec![expr_addr_of_mut(\n                     self.cx,\n                     self.span,\n                     self.cx.expr_path(Path::from_ident(capture)),\n@@ -389,7 +389,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         let local_bind_path = self.cx.expr_path(Path::from_ident(local_bind));\n         let rslt = if self.is_consumed {\n             let ret = self.cx.stmt_expr(local_bind_path);\n-            self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]))\n+            self.cx.expr_block(self.cx.block(self.span, thin_vec![try_capture_call, ret]))\n         } else {\n             self.best_case_captures.push(try_capture_call);\n             local_bind_path\n@@ -441,7 +441,7 @@ fn expr_method_call(\n     cx: &ExtCtxt<'_>,\n     seg: PathSegment,\n     receiver: P<Expr>,\n-    args: Vec<P<Expr>>,\n+    args: ThinVec<P<Expr>>,\n     span: Span,\n ) -> P<Expr> {\n     cx.expr(span, ExprKind::MethodCall(Box::new(MethodCall { seg, receiver, args, span })))"}, {"sha": "dfee2d3ce77d7983245a835b213670fd93943078", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_clone(\n     cx: &mut ExtCtxt<'_>,\n@@ -100,7 +100,7 @@ fn cs_clone_simple(\n     substr: &Substructure<'_>,\n     is_union: bool,\n ) -> BlockOrExpr {\n-    let mut stmts = Vec::new();\n+    let mut stmts = ThinVec::new();\n     let mut seen_type_names = FxHashSet::default();\n     let mut process_variant = |variant: &VariantData| {\n         for field in variant.fields() {\n@@ -162,7 +162,7 @@ fn cs_clone(\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n     let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo| {\n-        let args = vec![field.self_expr.clone()];\n+        let args = thin_vec![field.self_expr.clone()];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n \n@@ -200,7 +200,7 @@ fn cs_clone(\n                     let call = subcall(cx, field);\n                     cx.field_imm(field.span, ident, call)\n                 })\n-                .collect::<Vec<_>>();\n+                .collect::<ThinVec<_>>();\n \n             cx.expr_struct(trait_span, ctor_path, fields)\n         }"}, {"sha": "af971958680ae486dfc935d18cda4cc83554fff3", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_eq(\n     cx: &mut ExtCtxt<'_>,\n@@ -56,7 +56,7 @@ fn cs_total_eq_assert(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n ) -> BlockOrExpr {\n-    let mut stmts = Vec::new();\n+    let mut stmts = ThinVec::new();\n     let mut seen_type_names = FxHashSet::default();\n     let mut process_variant = |variant: &ast::VariantData| {\n         for field in variant.fields() {"}, {"sha": "cfd36f030a19310c5c239ae789be61c64f29855b", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -64,14 +64,14 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![field.self_expr.clone(), other_expr.clone()];\n+                let args = thin_vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, expr1, expr2) => {\n                 let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), expr1);\n                 let neq_arm =\n                     cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                cx.expr_match(span, expr2, thin_vec![eq_arm, neq_arm])\n             }\n             CsFold::Fieldless => cx.expr_path(equal_path.clone()),\n         },"}, {"sha": "9f46247908d0df81e008d9ef010c207f92b29cb2", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -98,7 +98,7 @@ fn cs_partial_cmp(\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![field.self_expr.clone(), other_expr.clone()];\n+                let args = thin_vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, mut expr1, expr2) => {\n@@ -143,7 +143,7 @@ fn cs_partial_cmp(\n                         cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n                     let neq_arm =\n                         cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                    cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                    cx.expr_match(span, expr2, thin_vec![eq_arm, neq_arm])\n                 }\n             }\n             CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),"}, {"sha": "809f9838d20becd0965c226095302737ce40d2b2", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_debug(\n     cx: &mut ExtCtxt<'_>,\n@@ -94,7 +95,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     if fields.is_empty() {\n         // Special case for no fields.\n         let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+        let expr = cx.expr_call_global(span, fn_path_write_str, thin_vec![fmt, name]);\n         BlockOrExpr::new_expr(expr)\n     } else if fields.len() <= CUTOFF {\n         // Few enough fields that we can use a specific-length method.\n@@ -105,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         };\n         let fn_path_debug = cx.std_path(&[sym::fmt, sym::Formatter, Symbol::intern(&debug)]);\n \n-        let mut args = Vec::with_capacity(2 + fields.len() * args_per_field);\n+        let mut args = ThinVec::with_capacity(2 + fields.len() * args_per_field);\n         args.extend([fmt, name]);\n         for i in 0..fields.len() {\n             let field = &fields[i];\n@@ -121,8 +122,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         BlockOrExpr::new_expr(expr)\n     } else {\n         // Enough fields that we must use the any-length method.\n-        let mut name_exprs = Vec::with_capacity(fields.len());\n-        let mut value_exprs = Vec::with_capacity(fields.len());\n+        let mut name_exprs = ThinVec::with_capacity(fields.len());\n+        let mut value_exprs = ThinVec::with_capacity(fields.len());\n \n         for i in 0..fields.len() {\n             let field = &fields[i];\n@@ -177,7 +178,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         };\n         let fn_path_debug_internal = cx.std_path(&[sym::fmt, sym::Formatter, sym_debug]);\n \n-        let mut args = Vec::with_capacity(4);\n+        let mut args = ThinVec::with_capacity(4);\n         args.push(fmt);\n         args.push(name);\n         if is_struct {\n@@ -186,7 +187,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         args.push(cx.expr_ident(span, Ident::new(sym::values, span)));\n         let expr = cx.expr_call_global(span, fn_path_debug_internal, args);\n \n-        let mut stmts = Vec::with_capacity(3);\n+        let mut stmts = ThinVec::with_capacity(2);\n         if is_struct {\n             stmts.push(names_let.unwrap());\n         }\n@@ -223,18 +224,18 @@ fn show_fieldless_enum(\n             let pat = match &v.data {\n                 ast::VariantData::Tuple(fields, _) => {\n                     debug_assert!(fields.is_empty());\n-                    cx.pat_tuple_struct(span, variant_path, vec![])\n+                    cx.pat_tuple_struct(span, variant_path, ThinVec::new())\n                 }\n                 ast::VariantData::Struct(fields, _) => {\n                     debug_assert!(fields.is_empty());\n-                    cx.pat_struct(span, variant_path, vec![])\n+                    cx.pat_struct(span, variant_path, ThinVec::new())\n                 }\n                 ast::VariantData::Unit(_) => cx.pat_path(span, variant_path),\n             };\n             cx.arm(span, pat, cx.expr_str(span, v.ident.name))\n         })\n-        .collect::<Vec<_>>();\n+        .collect::<ThinVec<_>>();\n     let name = cx.expr_match(span, cx.expr_self(span), arms);\n     let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]))\n+    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, thin_vec![fmt, name]))\n }"}, {"sha": "3921533c84a19562343aed2b4e70e3f07052c56b", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,12 +3,12 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n-\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, Expr, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_rustc_decodable(\n     cx: &mut ExtCtxt<'_>,\n@@ -96,7 +96,7 @@ fn decodable_substructure(\n                         cx.expr_call_global(\n                             span,\n                             fn_read_struct_field_path.clone(),\n-                            vec![\n+                            thin_vec![\n                                 blkdecoder.clone(),\n                                 cx.expr_str(span, name),\n                                 cx.expr_usize(span, field),\n@@ -112,7 +112,7 @@ fn decodable_substructure(\n             cx.expr_call_global(\n                 trait_span,\n                 fn_read_struct_path,\n-                vec![\n+                thin_vec![\n                     decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n@@ -123,8 +123,8 @@ fn decodable_substructure(\n         StaticEnum(_, fields) => {\n             let variant = Ident::new(sym::i, trait_span);\n \n-            let mut arms = Vec::with_capacity(fields.len() + 1);\n-            let mut variants = Vec::with_capacity(fields.len());\n+            let mut arms = ThinVec::with_capacity(fields.len() + 1);\n+            let mut variants = ThinVec::with_capacity(fields.len());\n \n             let fn_read_enum_variant_arg_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum_variant_arg]);\n@@ -141,7 +141,7 @@ fn decodable_substructure(\n                             cx.expr_call_global(\n                                 span,\n                                 fn_read_enum_variant_arg_path.clone(),\n-                                vec![blkdecoder.clone(), idx, exprdecode.clone()],\n+                                thin_vec![blkdecoder.clone(), idx, exprdecode.clone()],\n                             ),\n                         )\n                     });\n@@ -162,15 +162,15 @@ fn decodable_substructure(\n             let result = cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_variant_path,\n-                vec![blkdecoder, variant_array_ref, lambda],\n+                thin_vec![blkdecoder, variant_array_ref, lambda],\n             );\n             let fn_read_enum_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum]);\n \n             cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_path,\n-                vec![\n+                thin_vec![\n                     decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),"}, {"sha": "4d753a2ed805cb6aaeb03c605861bfaa5d6bfcce", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -8,7 +8,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use smallvec::SmallVec;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_default(\n     cx: &mut ExtCtxt<'_>,\n@@ -60,7 +60,7 @@ fn default_struct_substructure(\n ) -> BlockOrExpr {\n     // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n     let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), ThinVec::new());\n \n     let expr = match summary {\n         Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),"}, {"sha": "a3b11309d0ce1a7eaae6ada7378ed84e559ff4ca", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -88,11 +88,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n-\n use rustc_ast::{AttrVec, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_rustc_encodable(\n     cx: &mut ExtCtxt<'_>,\n@@ -169,19 +169,20 @@ fn encodable_substructure(\n         Struct(_, fields) => {\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n-            let mut stmts = Vec::new();\n+            let mut stmts = ThinVec::new();\n             for (i, &FieldInfo { name, ref self_expr, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name,\n                     None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_expr.clone());\n-                let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n+                let enc =\n+                    cx.expr_call(span, fn_path.clone(), thin_vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_call_global(\n                     span,\n                     fn_emit_struct_field_path.clone(),\n-                    vec![\n+                    thin_vec![\n                         blkencoder.clone(),\n                         cx.expr_str(span, name),\n                         cx.expr_usize(span, i),\n@@ -203,7 +204,7 @@ fn encodable_substructure(\n \n             // unit structs have no fields and need to return Ok()\n             let blk = if stmts.is_empty() {\n-                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, ThinVec::new()));\n                 cx.lambda1(trait_span, ok, blkarg)\n             } else {\n                 cx.lambda_stmts_1(trait_span, stmts, blkarg)\n@@ -215,7 +216,7 @@ fn encodable_substructure(\n             let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_struct_path,\n-                vec![\n+                thin_vec![\n                     encoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n@@ -236,19 +237,22 @@ fn encodable_substructure(\n             let fn_emit_enum_variant_arg_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum_variant_arg]);\n \n-            let mut stmts = Vec::new();\n+            let mut stmts = ThinVec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n                 for (i, &FieldInfo { ref self_expr, span, .. }) in fields.iter().enumerate() {\n                     let self_ref = cx.expr_addr_of(span, self_expr.clone());\n-                    let enc =\n-                        cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n+                    let enc = cx.expr_call(\n+                        span,\n+                        fn_path.clone(),\n+                        thin_vec![self_ref, blkencoder.clone()],\n+                    );\n                     let lambda = cx.lambda1(span, enc, blkarg);\n \n                     let call = cx.expr_call_global(\n                         span,\n                         fn_emit_enum_variant_arg_path.clone(),\n-                        vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n+                        thin_vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n                     );\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n@@ -258,7 +262,7 @@ fn encodable_substructure(\n                     stmts.push(cx.stmt_expr(call));\n                 }\n             } else {\n-                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, ThinVec::new()));\n                 let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n@@ -272,7 +276,7 @@ fn encodable_substructure(\n             let call = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_variant_path,\n-                vec![\n+                thin_vec![\n                     blkencoder,\n                     name,\n                     cx.expr_usize(trait_span, *idx),\n@@ -287,9 +291,9 @@ fn encodable_substructure(\n             let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_path,\n-                vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n+                thin_vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n-            BlockOrExpr::new_mixed(vec![me], Some(expr))\n+            BlockOrExpr::new_mixed(thin_vec![me], Some(expr))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),"}, {"sha": "1f819beeb5d7d25643a66e717f18b670c4db7369", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -177,7 +177,7 @@ use std::cell::RefCell;\n use std::iter;\n use std::ops::Not;\n use std::vec;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n use ty::{Bounds, Path, Ref, Self_, Ty};\n \n pub mod ty;\n@@ -318,7 +318,7 @@ pub fn combine_substructure(\n }\n \n struct TypeParameter {\n-    bound_generic_params: Vec<ast::GenericParam>,\n+    bound_generic_params: ThinVec<ast::GenericParam>,\n     ty: P<ast::Ty>,\n }\n \n@@ -328,18 +328,18 @@ struct TypeParameter {\n /// avoiding the insertion of any unnecessary blocks.\n ///\n /// The statements come before the expression.\n-pub struct BlockOrExpr(Vec<ast::Stmt>, Option<P<Expr>>);\n+pub struct BlockOrExpr(ThinVec<ast::Stmt>, Option<P<Expr>>);\n \n impl BlockOrExpr {\n-    pub fn new_stmts(stmts: Vec<ast::Stmt>) -> BlockOrExpr {\n+    pub fn new_stmts(stmts: ThinVec<ast::Stmt>) -> BlockOrExpr {\n         BlockOrExpr(stmts, None)\n     }\n \n     pub fn new_expr(expr: P<Expr>) -> BlockOrExpr {\n-        BlockOrExpr(vec![], Some(expr))\n+        BlockOrExpr(ThinVec::new(), Some(expr))\n     }\n \n-    pub fn new_mixed(stmts: Vec<ast::Stmt>, expr: Option<P<Expr>>) -> BlockOrExpr {\n+    pub fn new_mixed(stmts: ThinVec<ast::Stmt>, expr: Option<P<Expr>>) -> BlockOrExpr {\n         BlockOrExpr(stmts, expr)\n     }\n \n@@ -355,7 +355,7 @@ impl BlockOrExpr {\n     fn into_expr(self, cx: &ExtCtxt<'_>, span: Span) -> P<Expr> {\n         if self.0.is_empty() {\n             match self.1 {\n-                None => cx.expr_block(cx.block(span, vec![])),\n+                None => cx.expr_block(cx.block(span, ThinVec::new())),\n                 Some(expr) => expr,\n             }\n         } else if self.0.len() == 1\n@@ -385,7 +385,7 @@ fn find_type_parameters(\n     struct Visitor<'a, 'b> {\n         cx: &'a ExtCtxt<'b>,\n         ty_param_names: &'a [Symbol],\n-        bound_generic_params_stack: Vec<ast::GenericParam>,\n+        bound_generic_params_stack: ThinVec<ast::GenericParam>,\n         type_params: Vec<TypeParameter>,\n     }\n \n@@ -422,7 +422,7 @@ fn find_type_parameters(\n     let mut visitor = Visitor {\n         cx,\n         ty_param_names,\n-        bound_generic_params_stack: Vec::new(),\n+        bound_generic_params_stack: ThinVec::new(),\n         type_params: Vec::new(),\n     };\n     visit::Visitor::visit_ty(&mut visitor, ty);\n@@ -594,7 +594,7 @@ impl<'a> TraitDef<'a> {\n         let span = generics.span.with_ctxt(ctxt);\n \n         // Create the generic parameters\n-        let params: Vec<_> = generics\n+        let params: ThinVec<_> = generics\n             .params\n             .iter()\n             .map(|param| match &param.kind {\n@@ -935,8 +935,8 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n         generics: &Generics,\n-    ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n-        let mut selflike_args = Vec::new();\n+    ) -> (Option<ast::ExplicitSelf>, ThinVec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+        let mut selflike_args = ThinVec::new();\n         let mut nonselflike_args = Vec::new();\n         let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n@@ -1133,7 +1133,7 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        selflike_args: Vec<P<Expr>>,\n+        selflike_args: ThinVec<P<Expr>>,\n         nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n@@ -1146,7 +1146,7 @@ impl<'a> MethodDef<'a> {\n         // There is no sensible code to be generated for *any* deriving on a\n         // zero-variant enum. So we just generate a failing expression.\n         if variants.is_empty() {\n-            return BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)));\n+            return BlockOrExpr(ThinVec::new(), Some(deriving::call_unreachable(cx, span)));\n         }\n \n         let prefixes = iter::once(\"__self\".to_string())\n@@ -1182,13 +1182,13 @@ impl<'a> MethodDef<'a> {\n             let other_selflike_exprs = tag_exprs;\n             let tag_field = FieldInfo { span, name: None, self_expr, other_selflike_exprs };\n \n-            let tag_let_stmts: Vec<_> = iter::zip(&tag_idents, &selflike_args)\n+            let tag_let_stmts: ThinVec<_> = iter::zip(&tag_idents, &selflike_args)\n                 .map(|(&ident, selflike_arg)| {\n                     let variant_value = deriving::call_intrinsic(\n                         cx,\n                         span,\n                         sym::discriminant_value,\n-                        vec![selflike_arg.clone()],\n+                        thin_vec![selflike_arg.clone()],\n                     );\n                     cx.stmt_let(span, false, ident, variant_value)\n                 })\n@@ -1247,7 +1247,7 @@ impl<'a> MethodDef<'a> {\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = selflike_args.len()\n-        let mut match_arms: Vec<ast::Arm> = variants\n+        let mut match_arms: ThinVec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n             .filter(|&(_, v)| !(unify_fieldless_variants && v.data.fields().is_empty()))\n@@ -1260,7 +1260,7 @@ impl<'a> MethodDef<'a> {\n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n                 let by_ref = ByRef::No; // because enums can't be repr(packed)\n-                let mut subpats: Vec<_> = trait_.create_struct_patterns(\n+                let mut subpats = trait_.create_struct_patterns(\n                     cx,\n                     variant_path,\n                     &variant.data,\n@@ -1336,7 +1336,7 @@ impl<'a> MethodDef<'a> {\n         //          ...\n         //          _ => ::core::intrinsics::unreachable()\n         //      }\n-        let get_match_expr = |mut selflike_args: Vec<P<Expr>>| {\n+        let get_match_expr = |mut selflike_args: ThinVec<P<Expr>>| {\n             let match_arg = if selflike_args.len() == 1 {\n                 selflike_args.pop().unwrap()\n             } else {\n@@ -1362,7 +1362,7 @@ impl<'a> MethodDef<'a> {\n             tag_let_stmts.append(&mut tag_check_plus_match.0);\n             BlockOrExpr(tag_let_stmts, tag_check_plus_match.1)\n         } else {\n-            BlockOrExpr(vec![], Some(get_match_expr(selflike_args)))\n+            BlockOrExpr(ThinVec::new(), Some(get_match_expr(selflike_args)))\n         }\n     }\n \n@@ -1427,7 +1427,7 @@ impl<'a> TraitDef<'a> {\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n         by_ref: ByRef,\n-    ) -> Vec<P<ast::Pat>> {\n+    ) -> ThinVec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {\n@@ -1599,7 +1599,7 @@ impl<'a> TraitDef<'a> {\n                         } else {\n                             // Wrap the expression in `{...}`, causing a copy.\n                             field_expr = cx.expr_block(\n-                                cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n+                                cx.block(struct_field.span, thin_vec![cx.stmt_expr(field_expr)]),\n                             );\n                         }\n                     }"}, {"sha": "26f91b714b46836d1c577dddc91af4463bc8170f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,6 +9,7 @@ use rustc_expand::base::ExtCtxt;\n use rustc_span::source_map::{respan, DUMMY_SP};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::ThinVec;\n \n /// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n /// for type parameters.\n@@ -102,7 +103,7 @@ impl Ty {\n             Path(p) => p.to_ty(cx, span, self_ty, self_generics),\n             Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n             Unit => {\n-                let ty = ast::TyKind::Tup(vec![]);\n+                let ty = ast::TyKind::Tup(ThinVec::new());\n                 cx.ty(span, ty)\n             }\n         }\n@@ -185,7 +186,11 @@ impl Bounds {\n \n         Generics {\n             params,\n-            where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n+            where_clause: ast::WhereClause {\n+                has_where_token: false,\n+                predicates: ThinVec::new(),\n+                span,\n+            },\n             span,\n         }\n     }"}, {"sha": "4eee573db4215849283231ca9cf00457e6c81157", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,11 +1,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-\n use rustc_ast::{AttrVec, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_hash(\n     cx: &mut ExtCtxt<'_>,\n@@ -60,7 +60,7 @@ fn hash_substructure(\n \n             cx.expr_path(cx.path_global(span, strs))\n         };\n-        let expr = cx.expr_call(span, hash_path, vec![expr, state_expr.clone()]);\n+        let expr = cx.expr_call(span, hash_path, thin_vec![expr, state_expr.clone()]);\n         cx.stmt_expr(expr)\n     };\n \n@@ -72,7 +72,7 @@ fn hash_substructure(\n         }\n         EnumTag(tag_field, match_expr) => {\n             assert!(tag_field.other_selflike_exprs.is_empty());\n-            let stmts = vec![call_hash(tag_field.span, tag_field.self_expr.clone())];\n+            let stmts = thin_vec![call_hash(tag_field.span, tag_field.self_expr.clone())];\n             (stmts, match_expr.clone())\n         }\n         _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\"),"}, {"sha": "d34336e7679c03bf3a0cd3a1542fcfdd6054997f", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::{GenericArg, Impl, ItemKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n macro path_local($x:ident) {\n     generic::ty::Path::new_local(sym::$x)\n@@ -92,7 +93,7 @@ fn call_intrinsic(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n     intrinsic: Symbol,\n-    args: Vec<P<ast::Expr>>,\n+    args: ThinVec<P<ast::Expr>>,\n ) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, intrinsic]);\n@@ -103,10 +104,10 @@ fn call_intrinsic(\n fn call_unreachable(cx: &ExtCtxt<'_>, span: Span) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, sym::unreachable]);\n-    let call = cx.expr_call_global(span, path, vec![]);\n+    let call = cx.expr_call_global(span, path, ThinVec::new());\n \n     cx.expr_block(P(ast::Block {\n-        stmts: vec![cx.stmt_expr(call)],\n+        stmts: thin_vec![cx.stmt_expr(call)],\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n         span,\n@@ -202,7 +203,7 @@ fn inject_impl_of_structural_trait(\n             generics,\n             of_trait: Some(trait_ref),\n             self_ty: self_type,\n-            items: Vec::new(),\n+            items: ThinVec::new(),\n         })),\n     );\n \n@@ -211,7 +212,7 @@ fn inject_impl_of_structural_trait(\n \n fn assert_ty_bounds(\n     cx: &mut ExtCtxt<'_>,\n-    stmts: &mut Vec<ast::Stmt>,\n+    stmts: &mut ThinVec<ast::Stmt>,\n     ty: P<ast::Ty>,\n     span: Span,\n     assert_path: &[Symbol],"}, {"sha": "6aa900f020163415b5e703ea23dc342ff28dbac5", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -8,8 +8,8 @@ use rustc_ast::{self as ast, GenericArg};\n use rustc_expand::base::{self, *};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-\n use std::env;\n+use thin_vec::thin_vec;\n \n pub fn expand_option_env<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n@@ -41,7 +41,7 @@ pub fn expand_option_env<'cx>(\n         Some(value) => cx.expr_call_global(\n             sp,\n             cx.std_path(&[sym::option, sym::Option, sym::Some]),\n-            vec![cx.expr_str(sp, value)],\n+            thin_vec![cx.expr_str(sp, value)],\n         ),\n     };\n     MacEager::expr(e)"}, {"sha": "41b51bae73645bbcb6fe30a841d45e79586a18aa", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::{Fn, ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -47,7 +47,7 @@ pub fn expand(\n     let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n \n     // Generate anonymous constant serving as container for the allocator methods.\n-    let const_ty = ecx.ty(ty_span, TyKind::Tup(Vec::new()));\n+    let const_ty = ecx.ty(ty_span, TyKind::Tup(ThinVec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n     let const_item = if is_stmt {\n@@ -70,7 +70,7 @@ struct AllocFnFactory<'a, 'b> {\n \n impl AllocFnFactory<'_, '_> {\n     fn allocator_fn(&self, method: &AllocatorMethod) -> Stmt {\n-        let mut abi_args = Vec::new();\n+        let mut abi_args = ThinVec::new();\n         let mut i = 0;\n         let mut mk = || {\n             let name = Ident::from_str_and_span(&format!(\"arg{}\", i), self.span);\n@@ -99,7 +99,7 @@ impl AllocFnFactory<'_, '_> {\n         self.cx.stmt_item(self.ty_span, item)\n     }\n \n-    fn call_allocator(&self, method: Symbol, mut args: Vec<P<Expr>>) -> P<Expr> {\n+    fn call_allocator(&self, method: Symbol, mut args: ThinVec<P<Expr>>) -> P<Expr> {\n         let method = self.cx.std_path(&[sym::alloc, sym::GlobalAlloc, method]);\n         let method = self.cx.expr_path(self.cx.path(self.ty_span, method));\n         let allocator = self.cx.path_ident(self.ty_span, self.global);\n@@ -117,7 +117,7 @@ impl AllocFnFactory<'_, '_> {\n     fn arg_ty(\n         &self,\n         ty: &AllocatorTy,\n-        args: &mut Vec<Param>,\n+        args: &mut ThinVec<Param>,\n         ident: &mut dyn FnMut() -> Ident,\n     ) -> P<Expr> {\n         match *ty {\n@@ -134,7 +134,7 @@ impl AllocFnFactory<'_, '_> {\n                 let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n                 let size = self.cx.expr_ident(self.span, size);\n                 let align = self.cx.expr_ident(self.span, align);\n-                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n+                let layout = self.cx.expr_call(self.span, layout_new, thin_vec![size, align]);\n                 layout\n             }\n \n@@ -168,7 +168,7 @@ impl AllocFnFactory<'_, '_> {\n                 (self.ptr_u8(), expr)\n             }\n \n-            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n+            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(ThinVec::new())), expr),\n \n             AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n                 panic!(\"can't convert `AllocatorTy` to an output\")"}, {"sha": "8afb6e56069b03f4b80af08f806807d886fe8be4", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -21,8 +21,10 @@ extern crate tracing;\n \n use crate::deriving::*;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n+use rustc_macros::fluent_messages;\n use rustc_span::symbol::sym;\n \n mod alloc_error_handler;\n@@ -54,6 +56,8 @@ pub mod proc_macro_harness;\n pub mod standard_library_imports;\n pub mod test_harness;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     let mut register = |name, kind| resolver.register_builtin_macro(name, kind);\n     macro register_bang($($name:ident: $f:expr,)*) {"}, {"sha": "bc513607ddd1d7e435cb8d0f28620840b8048f19", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -11,6 +11,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -314,11 +315,14 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, custom_derive),\n-                        vec![\n+                        thin_vec![\n                             cx.expr_str(span, cd.trait_name),\n                             cx.expr_array_ref(\n                                 span,\n-                                cd.attrs.iter().map(|&s| cx.expr_str(span, s)).collect::<Vec<_>>(),\n+                                cd.attrs\n+                                    .iter()\n+                                    .map(|&s| cx.expr_str(span, s))\n+                                    .collect::<ThinVec<_>>(),\n                             ),\n                             local_path(cx, cd.function_name),\n                         ],\n@@ -335,7 +339,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, ident),\n-                        vec![\n+                        thin_vec![\n                             cx.expr_str(span, ca.function_name.name),\n                             local_path(cx, ca.function_name),\n                         ],\n@@ -371,13 +375,13 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n         });\n \n     let block = cx.expr_block(\n-        cx.block(span, vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)]),\n+        cx.block(span, thin_vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)]),\n     );\n \n     let anon_constant = cx.item_const(\n         span,\n         Ident::new(kw::Underscore, span),\n-        cx.ty(span, ast::TyKind::Tup(Vec::new())),\n+        cx.ty(span, ast::TyKind::Tup(ThinVec::new())),\n         block,\n     );\n "}, {"sha": "e02c7e6c01b7e5570daea34e5b112bd4eefdf478", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use std::iter;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n /// #[test_case] is used by custom test authors to mark tests\n /// When building for test, it needs to make the item public and gensym the name\n@@ -179,19 +179,19 @@ pub fn expand_test_or_bench(\n         cx.expr_call(\n             sp,\n             cx.expr_path(test_path(\"StaticBenchFn\")),\n-            vec![\n+            thin_vec![\n                 // |b| self::test::assert_test_result(\n                 cx.lambda1(\n                     sp,\n                     cx.expr_call(\n                         sp,\n                         cx.expr_path(test_path(\"assert_test_result\")),\n-                        vec![\n+                        thin_vec![\n                             // super::$test_fn(b)\n                             cx.expr_call(\n                                 ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n-                                vec![cx.expr_ident(sp, b)],\n+                                thin_vec![cx.expr_ident(sp, b)],\n                             ),\n                         ],\n                     ),\n@@ -203,20 +203,20 @@ pub fn expand_test_or_bench(\n         cx.expr_call(\n             sp,\n             cx.expr_path(test_path(\"StaticTestFn\")),\n-            vec![\n+            thin_vec![\n                 // || {\n                 cx.lambda0(\n                     sp,\n                     // test::assert_test_result(\n                     cx.expr_call(\n                         sp,\n                         cx.expr_path(test_path(\"assert_test_result\")),\n-                        vec![\n+                        thin_vec![\n                             // $test_fn()\n                             cx.expr_call(\n                                 ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n-                                vec![],\n+                                ThinVec::new(),\n                             ), // )\n                         ],\n                     ), // }\n@@ -249,21 +249,21 @@ pub fn expand_test_or_bench(\n                 cx.expr_struct(\n                     sp,\n                     test_path(\"TestDescAndFn\"),\n-                    vec![\n+                    thin_vec![\n                         // desc: test::TestDesc {\n                         field(\n                             \"desc\",\n                             cx.expr_struct(\n                                 sp,\n                                 test_path(\"TestDesc\"),\n-                                vec![\n+                                thin_vec![\n                                     // name: \"path::to::test\"\n                                     field(\n                                         \"name\",\n                                         cx.expr_call(\n                                             sp,\n                                             cx.expr_path(test_path(\"StaticTestName\")),\n-                                            vec![cx.expr_str(sp, test_path_symbol)],\n+                                            thin_vec![cx.expr_str(sp, test_path_symbol)],\n                                         ),\n                                     ),\n                                     // ignore: true | false\n@@ -300,7 +300,7 @@ pub fn expand_test_or_bench(\n                                             ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n                                                 sp,\n                                                 cx.expr_path(should_panic_path(\"YesWithMessage\")),\n-                                                vec![cx.expr_str(sp, sym)],\n+                                                thin_vec![cx.expr_str(sp, sym)],\n                                             ),\n                                         },\n                                     ),"}, {"sha": "d8e3db9e8ee094036892a0dafb38d02adbc3dc4b", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -14,7 +14,8 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n use smallvec::{smallvec, SmallVec};\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n+use tracing::debug;\n \n use std::{iter, mem};\n \n@@ -299,7 +300,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     test_runner.span = sp;\n \n     let test_main_path_expr = ecx.expr_path(test_runner);\n-    let call_test_main = ecx.expr_call(sp, test_main_path_expr, vec![mk_tests_slice(cx, sp)]);\n+    let call_test_main = ecx.expr_call(sp, test_main_path_expr, thin_vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // extern crate test\n@@ -312,16 +313,16 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let main_attr = ecx.attr_word(sym::rustc_main, sp);\n \n     // pub fn main() { ... }\n-    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n+    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(ThinVec::new()));\n \n     // If no test runner is provided we need to import the test crate\n     let main_body = if cx.test_runner.is_none() {\n-        ecx.block(sp, vec![test_extern_stmt, call_test_main])\n+        ecx.block(sp, thin_vec![test_extern_stmt, call_test_main])\n     } else {\n-        ecx.block(sp, vec![call_test_main])\n+        ecx.block(sp, thin_vec![call_test_main])\n     };\n \n-    let decl = ecx.fn_decl(vec![], ast::FnRetTy::Ty(main_ret_ty));\n+    let decl = ecx.fn_decl(ThinVec::new(), ast::FnRetTy::Ty(main_ret_ty));\n     let sig = ast::FnSig { decl, header: ast::FnHeader::default(), span: sp };\n     let defaultness = ast::Defaultness::Final;\n     let main = ast::ItemKind::Fn(Box::new(ast::Fn {"}, {"sha": "74396a66f54e09fde1659036f52e8fa17b9c4953", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -405,9 +405,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     };\n \n     let extra_args = &args[fn_sig.inputs().skip_binder().len()..];\n-    let extra_args = fx\n-        .tcx\n-        .mk_type_list(extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))));\n+    let extra_args = fx.tcx.mk_type_list_from_iter(\n+        extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))),\n+    );\n     let fn_abi = if let Some(instance) = instance {\n         RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(instance, extra_args)\n     } else {"}, {"sha": "40bfe70771c1907aa58b3cc8e4cce2d566915ac8", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -56,7 +56,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                     Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n                 }\n             } else {\n-                let out_ty = fx.tcx.intern_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+                let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n                 let lhs = lhs.load_scalar(fx);\n                 let rhs = rhs.load_scalar(fx);\n@@ -78,7 +78,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n             assert!(checked);\n-            let out_ty = fx.tcx.intern_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n             let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n                 let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);"}, {"sha": "722e2754e8381b9ec113115d8be7ec4b87803c79", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -374,7 +374,7 @@ impl<'tcx> HasTargetSpec for FunctionCx<'_, '_, 'tcx> {\n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     pub(crate) fn monomorphize<T>(&self, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx> + Copy,\n+        T: TypeFoldable<TyCtxt<'tcx>> + Copy,\n     {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,"}, {"sha": "e5c4b244a1afd8f6f4dc4096b10fe3221013c54a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -191,7 +191,7 @@ fn llvm_add_sub<'tcx>(\n     // carry0 | carry1 -> carry or borrow respectively\n     let cb_out = fx.bcx.ins().bor(cb0, cb1);\n \n-    let layout = fx.layout_of(fx.tcx.intern_tup(&[fx.tcx.types.u8, fx.tcx.types.u64]));\n+    let layout = fx.layout_of(fx.tcx.mk_tup(&[fx.tcx.types.u8, fx.tcx.types.u64]));\n     let val = CValue::by_val_pair(cb_out, c, layout);\n     ret.write_cvalue(fx, val);\n }"}, {"sha": "80ce3dc932873fa46e45290a1f2e8113d2974299", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -86,7 +86,7 @@ mod prelude {\n     pub(crate) use rustc_middle::ty::layout::{self, LayoutOf, TyAndLayout};\n     pub(crate) use rustc_middle::ty::{\n         self, FloatTy, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut,\n-        TypeFoldable, UintTy,\n+        TypeFoldable, TypeVisitableExt, UintTy,\n     };\n     pub(crate) use rustc_target::abi::{Abi, Scalar, Size, VariantIdx};\n \n@@ -172,6 +172,11 @@ pub struct CraneliftCodegenBackend {\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n+    fn locale_resource(&self) -> &'static str {\n+        // FIXME(rust-lang/rust#100717) - cranelift codegen backend is not yet translated\n+        \"\"\n+    }\n+\n     fn init(&self, sess: &Session) {\n         use rustc_session::config::Lto;\n         match sess.lto() {"}, {"sha": "be908df83e8f59a1d85e57fd7ef4f273d2d90a9d", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -119,7 +119,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx,\n                     ParamEnv::reveal_all(),\n                     report.def_id,\n-                    tcx.intern_substs(&[GenericArg::from(main_ret_ty)]),\n+                    tcx.mk_substs(&[GenericArg::from(main_ret_ty)]),\n                 )\n                 .unwrap()\n                 .unwrap()\n@@ -146,7 +146,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx,\n                     ParamEnv::reveal_all(),\n                     start_def_id,\n-                    tcx.intern_substs(&[main_ret_ty.into()]),\n+                    tcx.mk_substs(&[main_ret_ty.into()]),\n                 )\n                 .unwrap()\n                 .unwrap()"}, {"sha": "c058ece96d8e3465fdb16e70060b4b7f9563f77f", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -289,7 +289,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n-    let out_layout = fx.layout_of(fx.tcx.intern_tup(&[in_lhs.layout().ty, fx.tcx.types.bool]));\n+    let out_layout = fx.layout_of(fx.tcx.mk_tup(&[in_lhs.layout().ty, fx.tcx.types.bool]));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n "}, {"sha": "6101b28ab0cdde9a42b69834de91ea4bff2d6198", "filename": "compiler/rustc_codegen_gcc/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl"}, {"sha": "9e3a22ee05d7ce1c51874636c0b121dc37fe8ec6", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,6 @@\n use gccjit::{FunctionType, RValue};\n use rustc_codegen_ssa::traits::BaseTypeMethods;\n-use rustc_middle::ty::{self, Instance, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n use crate::abi::FnAbiGccExt;"}, {"sha": "457006319afb8c315bc37ebf378fd23cb31bf5c1", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -383,7 +383,7 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                     tcx,\n                     ty::ParamEnv::reveal_all(),\n                     def_id,\n-                    tcx.intern_substs(&[]),\n+                    ty::List::empty(),\n                 )\n                 .unwrap().unwrap(),\n             ),"}, {"sha": "44538b415283c1cef48e9fb8a45c63edb9b827e5", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -73,7 +73,8 @@ use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModul\n use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_codegen_ssa::traits::{CodegenBackend, ExtraBackendMethods, ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{ErrorGuaranteed, Handler};\n+use rustc_errors::{DiagnosticMessage, ErrorGuaranteed, Handler, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n@@ -84,6 +85,8 @@ use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n use tempfile::TempDir;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n@@ -100,6 +103,10 @@ pub struct GccCodegenBackend {\n }\n \n impl CodegenBackend for GccCodegenBackend {\n+    fn locale_resource(&self) -> &'static str {\n+        crate::DEFAULT_LOCALE_RESOURCE\n+    }\n+\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n             sess.emit_warning(LTONotSupported {});"}, {"sha": "a7c868354fb27a9adbd2108570b409c44c079d73", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,7 +1,7 @@\n use rustc_codegen_ssa::traits::PreDefineMethods;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n-use rustc_middle::ty::{self, Instance, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_span::def_id::DefId;\n "}, {"sha": "ea2ce765053ffb83318e664f28ea5b20aebdb645", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,7 +3,7 @@ use std::fmt::Write;\n use gccjit::{Struct, Type};\n use crate::rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods};\n use rustc_middle::bug;\n-use rustc_middle::ty::{self, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};"}, {"sha": "e5df417370bb9030abf8ad18fe765b4bc0f265fc", "filename": "compiler/rustc_codegen_llvm/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl"}, {"sha": "6ee2a05ffd7b5b32ce7a6b7567bc494677fb2742", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -13,7 +13,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n-use rustc_middle::ty::{self, Instance, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes."}, {"sha": "3d29968d5d688c9f63a309db2131f5cc8c122e7a", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -520,14 +520,9 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    tcx.intern_substs(&[]),\n-                )\n-                .unwrap()\n-                .unwrap(),\n+                ty::Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, ty::List::empty())\n+                    .unwrap()\n+                    .unwrap(),\n             ),\n             _ => {\n                 let name = if wants_msvc_seh(self.sess()) {"}, {"sha": "5392534cfcb79e72df2a23014789c084851a615e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -27,7 +27,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TypeVisitableExt};\n use rustc_session::config::{self, DebugInfo};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;"}, {"sha": "bae88d942934cda346f20200c3c31591f178b081", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,9 +2,10 @@ use std::borrow::Cow;\n use std::ffi::CString;\n use std::path::Path;\n \n+use crate::fluent_generated as fluent;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{\n-    fluent, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed, Handler, IntoDiagnostic,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n@@ -27,9 +28,9 @@ pub(crate) struct UnknownCTargetFeature<'a> {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum PossibleFeature<'a> {\n-    #[help(possible_feature)]\n+    #[help(codegen_llvm_possible_feature)]\n     Some { rust_feature: &'a str },\n-    #[help(consider_filing_feature_request)]\n+    #[help(codegen_llvm_consider_filing_feature_request)]\n     None,\n }\n "}, {"sha": "c41e74c51a0dba2372cfc993c6d158bb0c84a9d3", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -34,7 +34,8 @@ use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{ErrorGuaranteed, FatalError, Handler};\n+use rustc_errors::{DiagnosticMessage, ErrorGuaranteed, FatalError, Handler, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::ty::query::Providers;\n@@ -83,6 +84,8 @@ mod type_of;\n mod va_arg;\n mod value;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n #[derive(Clone)]\n pub struct LlvmCodegenBackend(());\n \n@@ -246,6 +249,10 @@ impl LlvmCodegenBackend {\n }\n \n impl CodegenBackend for LlvmCodegenBackend {\n+    fn locale_resource(&self) -> &'static str {\n+        crate::DEFAULT_LOCALE_RESOURCE\n+    }\n+\n     fn init(&self, sess: &Session) {\n         llvm_util::init(sess); // Make sure llvm is inited\n     }"}, {"sha": "d0ae36349df1ae75adc8f00368902365c777d16c", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n pub use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n-use rustc_middle::ty::{self, Instance, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_session::config::CrateType;\n use rustc_target::spec::RelocModel;\n "}, {"sha": "e264ce78f0d67444886842ac3e61a8a7959d9836", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,7 +5,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n-use rustc_middle::ty::{self, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_target::abi::{Abi, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};"}, {"sha": "8fe5f8d50abe2aa9696ccb519f2c4e7b7b3079db", "filename": "compiler/rustc_codegen_ssa/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl"}, {"sha": "52c01b423a7d542d92b9448c2b8eb44fef427f11", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -473,13 +473,13 @@ impl<'a> Linker for GccLinker<'a> {\n         self.cmd.arg(path);\n     }\n     fn full_relro(&mut self) {\n-        self.linker_args(&[\"-zrelro\", \"-znow\"]);\n+        self.linker_args(&[\"-z\", \"relro\", \"-z\", \"now\"]);\n     }\n     fn partial_relro(&mut self) {\n-        self.linker_arg(\"-zrelro\");\n+        self.linker_args(&[\"-z\", \"relro\"]);\n     }\n     fn no_relro(&mut self) {\n-        self.linker_arg(\"-znorelro\");\n+        self.linker_args(&[\"-z\", \"norelro\"]);\n     }\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n@@ -758,7 +758,7 @@ impl<'a> Linker for GccLinker<'a> {\n         if self.sess.target.is_like_windows {\n             self.linker_arg(\"--nxcompat\");\n         } else if self.is_gnu {\n-            self.linker_arg(\"-znoexecstack\");\n+            self.linker_args(&[\"-z\", \"noexecstack\"]);\n         }\n     }\n \n@@ -1364,16 +1364,16 @@ impl<'a> Linker for L4Bender<'a> {\n     }\n \n     fn full_relro(&mut self) {\n-        self.cmd.arg(\"-zrelro\");\n-        self.cmd.arg(\"-znow\");\n+        self.cmd.arg(\"-z\").arg(\"relro\");\n+        self.cmd.arg(\"-z\").arg(\"now\");\n     }\n \n     fn partial_relro(&mut self) {\n-        self.cmd.arg(\"-zrelro\");\n+        self.cmd.arg(\"-z\").arg(\"relro\");\n     }\n \n     fn no_relro(&mut self) {\n-        self.cmd.arg(\"-znorelro\");\n+        self.cmd.arg(\"-z\").arg(\"norelro\");\n     }\n \n     fn cmd(&mut self) -> &mut Command {"}, {"sha": "067a3e167feea0bc44a45b2a443bbf7277ccc69b", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -373,7 +373,7 @@ fn upstream_monomorphizations_provider(\n                 ExportedSymbol::Generic(def_id, substs) => (def_id, substs),\n                 ExportedSymbol::DropGlue(ty) => {\n                     if let Some(drop_in_place_fn_def_id) = drop_in_place_fn_def_id {\n-                        (drop_in_place_fn_def_id, tcx.intern_substs(&[ty.into()]))\n+                        (drop_in_place_fn_def_id, tcx.mk_substs(&[ty.into()]))\n                     } else {\n                         // `drop_in_place` in place does not exist, don't try\n                         // to use it."}, {"sha": "73179249bc4d8637ab5034293b9a18780635f0bd", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -476,7 +476,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     cx.tcx(),\n                     ty::ParamEnv::reveal_all(),\n                     start_def_id,\n-                    cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+                    cx.tcx().mk_substs(&[main_ret_ty.into()]),\n                 )\n                 .unwrap()\n                 .unwrap(),"}, {"sha": "6dea7496fc3e6660ec891771db1d2a33b7cb67aa", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,8 +1,9 @@\n //! Errors emitted by codegen_ssa\n \n use crate::back::command::Command;\n+use crate::fluent_generated as fluent;\n use rustc_errors::{\n-    fluent, DiagnosticArgValue, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    DiagnosticArgValue, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n     IntoDiagnosticArg,\n };\n use rustc_macros::Diagnostic;\n@@ -388,7 +389,7 @@ pub struct LinkerNotFound {\n #[derive(Diagnostic)]\n #[diag(codegen_ssa_unable_to_exe_linker)]\n #[note]\n-#[note(command_note)]\n+#[note(codegen_ssa_command_note)]\n pub struct UnableToExeLinker {\n     pub linker_path: PathBuf,\n     pub error: Error,"}, {"sha": "ebe9e50ffe66da00a3692759bbb0e144c59664b9", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -25,7 +25,9 @@ extern crate rustc_middle;\n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir::def_id::CrateNum;\n+use rustc_macros::fluent_messages;\n use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n@@ -54,6 +56,8 @@ pub mod mono_item;\n pub mod target_features;\n pub mod traits;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n pub struct ModuleCodegen<M> {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be"}, {"sha": "f6c1b7a98aae7ebc8d5105e77f42f8511aa0381c", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,7 +16,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n-use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, Ty, TypeVisitableExt};\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n@@ -783,7 +783,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         let extra_args = &args[sig.inputs().skip_binder().len()..];\n-        let extra_args = bx.tcx().mk_type_list(extra_args.iter().map(|op_arg| {\n+        let extra_args = bx.tcx().mk_type_list_from_iter(extra_args.iter().map(|op_arg| {\n             let op_ty = op_arg.ty(self.mir, bx.tcx());\n             self.monomorphize(op_ty)\n         }));\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             slot\n         } else {\n             let layout = cx.layout_of(\n-                cx.tcx().intern_tup(&[cx.tcx().mk_mut_ptr(cx.tcx().types.u8), cx.tcx().types.i32]),\n+                cx.tcx().mk_tup(&[cx.tcx().mk_mut_ptr(cx.tcx().types.u8), cx.tcx().types.i32]),\n             );\n             let slot = PlaceRef::alloca(bx, layout);\n             self.personality_slot = Some(slot);"}, {"sha": "2ec9fdbf44f11ca9fb19a6e91faa3282999ca065", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,7 +3,7 @@ use crate::traits::*;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, TyAndLayout};\n-use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n use rustc_target::abi::call::{FnAbi, PassMode};\n \n use std::iter;\n@@ -105,7 +105,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphize<T>(&self, value: T) -> T\n     where\n-        T: Copy + TypeFoldable<'tcx>,\n+        T: Copy + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         debug!(\"monomorphize: self.instance={:?}\", self.instance);\n         self.instance.subst_mir_and_normalize_erasing_regions("}, {"sha": "3d856986fb4f7e7b7b8275850c01db2b03fa5393", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     lhs.layout.ty,\n                 );\n                 let val_ty = op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty);\n-                let operand_ty = bx.tcx().intern_tup(&[val_ty, bx.tcx().types.bool]);\n+                let operand_ty = bx.tcx().mk_tup(&[val_ty, bx.tcx().types.bool]);\n                 OperandRef { val: result, layout: bx.cx().layout_of(operand_ty) }\n             }\n "}, {"sha": "64bebe50ddbf23b17a26f5ad3af725a23f803a21", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -57,6 +57,10 @@ impl<'tcx, T> Backend<'tcx> for T where\n }\n \n pub trait CodegenBackend {\n+    /// Locale resources for diagnostic messages - a string the content of the Fluent resource.\n+    /// Called before `init` so that all other functions are able to emit translatable diagnostics.\n+    fn locale_resource(&self) -> &'static str;\n+\n     fn init(&self, _sess: &Session) {}\n     fn print(&self, _req: PrintRequest, _sess: &Session) {}\n     fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<Symbol> {"}, {"sha": "33bb116d6fa23f01c513d1b34b0d7e8ed9007070", "filename": "compiler/rustc_const_eval/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/const_eval.ftl"}, {"sha": "7564ba17b404a02e213e3815e1b90f570a286eb8", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -180,7 +180,7 @@ pub(super) fn op_to_const<'tcx>(\n                         (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n                     }\n                     (None, _offset) => (\n-                        ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n+                        ecx.tcx.mk_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n                             b\"\" as &[u8],\n                         )),\n                         0,"}, {"sha": "f8b7cc6d7e16bea19a3c69b8ce9d8fc1b048c608", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,12 +9,12 @@ pub(crate) struct UnstableInStable {\n     #[primary_span]\n     pub span: Span,\n     #[suggestion(\n-        unstable_sugg,\n+        const_eval_unstable_sugg,\n         code = \"#[rustc_const_unstable(feature = \\\"...\\\", issue = \\\"...\\\")]\\n\",\n         applicability = \"has-placeholders\"\n     )]\n     #[suggestion(\n-        bypass_sugg,\n+        const_eval_bypass_sugg,\n         code = \"#[rustc_allow_const_fn_unstable({gate})]\\n\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -35,15 +35,15 @@ pub(crate) struct StaticAccessErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(teach_note)]\n-    #[help(teach_help)]\n+    #[note(const_eval_teach_note)]\n+    #[help(const_eval_teach_help)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n #[diag(const_eval_raw_ptr_to_int)]\n #[note]\n-#[note(note2)]\n+#[note(const_eval_note2)]\n pub(crate) struct RawPtrToIntErr {\n     #[primary_span]\n     pub span: Span,\n@@ -118,7 +118,7 @@ pub(crate) struct UnallowedMutableRefs {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(teach_note)]\n+    #[note(const_eval_teach_note)]\n     pub teach: Option<()>,\n }\n \n@@ -128,7 +128,7 @@ pub(crate) struct UnallowedMutableRefsRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(teach_note)]\n+    #[note(const_eval_teach_note)]\n     pub teach: Option<()>,\n }\n #[derive(Diagnostic)]\n@@ -163,7 +163,7 @@ pub(crate) struct UnallowedHeapAllocations {\n     #[label]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(teach_note)]\n+    #[note(const_eval_teach_note)]\n     pub teach: Option<()>,\n }\n \n@@ -184,7 +184,7 @@ pub(crate) struct InteriorMutableDataRefer {\n     #[help]\n     pub opt_help: Option<()>,\n     pub kind: ConstContext,\n-    #[note(teach_note)]\n+    #[note(const_eval_teach_note)]\n     pub teach: Option<()>,\n }\n "}, {"sha": "3db102e484dfa78cd8854c5a67b1c41fc4cff32d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -489,7 +489,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Call this on things you got out of the MIR (so it is as generic as the current\n     /// stack frame), to bring it into the proper environment for this interpreter.\n-    pub(super) fn subst_from_current_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n+    pub(super) fn subst_from_current_frame_and_normalize_erasing_regions<\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n+    >(\n         &self,\n         value: T,\n     ) -> Result<T, InterpError<'tcx>> {\n@@ -498,7 +500,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Call this on things you got out of the MIR (so it is as generic as the provided\n     /// stack frame), to bring it into the proper environment for this interpreter.\n-    pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n+    pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<TyCtxt<'tcx>>>(\n         &self,\n         frame: &Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>,\n         value: T,"}, {"sha": "b220d21f68b72b0f2a371afd2f570fe3df8af166", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -135,7 +135,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     };\n     // link the alloc id to the actual allocation\n     leftover_allocations.extend(alloc.provenance().ptrs().iter().map(|&(_, alloc_id)| alloc_id));\n-    let alloc = tcx.intern_const_alloc(alloc);\n+    let alloc = tcx.mk_const_alloc(alloc);\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n     None\n }\n@@ -437,7 +437,7 @@ pub fn intern_const_alloc_recursive<\n                     alloc.mutability = Mutability::Not;\n                 }\n             }\n-            let alloc = tcx.intern_const_alloc(alloc);\n+            let alloc = tcx.mk_const_alloc(alloc);\n             tcx.set_alloc_id_memory(alloc_id, alloc);\n             for &(_, alloc_id) in alloc.inner().provenance().ptrs().iter() {\n                 if leftover_allocations.insert(alloc_id) {\n@@ -479,6 +479,6 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n         f(self, &dest.into())?;\n         let mut alloc = self.memory.alloc_map.remove(&dest.ptr.provenance.unwrap()).unwrap().1;\n         alloc.mutability = Mutability::Not;\n-        Ok(self.tcx.intern_const_alloc(alloc))\n+        Ok(self.tcx.mk_const_alloc(alloc))\n     }\n }"}, {"sha": "6e47646caeda881a7da15d2f1d5198e2b3534f3f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -45,7 +45,7 @@ fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<\n pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n     let path = crate::util::type_name(tcx, ty);\n     let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n-    tcx.intern_const_alloc(alloc)\n+    tcx.mk_const_alloc(alloc)\n }\n \n /// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated"}, {"sha": "cf52299b7ba825eb924c41daf6c7621391bcb1d3", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -96,7 +96,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let loc_ty = self\n             .tcx\n             .type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n-            .subst(*self.tcx, self.tcx.intern_substs(&[self.tcx.lifetimes.re_erased.into()]));\n+            .subst(*self.tcx, self.tcx.mk_substs(&[self.tcx.lifetimes.re_erased.into()]));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n "}, {"sha": "4decfe863e6349cadc71a1e99aecb9da8f4eadf1", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -19,7 +19,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx> {\n         let (val, overflowed, ty) = self.overflowing_binary_op(op, &left, &right)?;\n         debug_assert_eq!(\n-            self.tcx.intern_tup(&[ty, self.tcx.types.bool]),\n+            self.tcx.mk_tup(&[ty, self.tcx.types.bool]),\n             dest.layout.ty,\n             \"type mismatch for result of {:?}\",\n             op,"}, {"sha": "2aea7c79b6d3ed3331dca3007f1dfb5d3afa79dd", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -73,7 +73,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let fn_sig =\n                     self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig_binder);\n                 let extra_args = &args[fn_sig.inputs().len()..];\n-                let extra_args = self.tcx.mk_type_list(extra_args.iter().map(|arg| arg.layout.ty));\n+                let extra_args =\n+                    self.tcx.mk_type_list_from_iter(extra_args.iter().map(|arg| arg.layout.ty));\n \n                 let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n                     ty::FnPtr(_sig) => {"}, {"sha": "bf2b4ee69abfb048dd8ce6fff1542b86fadeb3e0", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,5 +1,7 @@\n use rustc_middle::mir::interpret::InterpResult;\n-use rustc_middle::ty::{self, ir::TypeVisitor, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,\n+};\n use std::ops::ControlFlow;\n \n /// Checks whether a type contains generic parameters which require substitution.\n@@ -9,7 +11,7 @@ use std::ops::ControlFlow;\n /// case these parameters are unused.\n pub(crate) fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n where\n-    T: TypeVisitable<'tcx>,\n+    T: TypeVisitable<TyCtxt<'tcx>>,\n {\n     debug!(\"ensure_monomorphic_enough: ty={:?}\", ty);\n     if !ty.needs_subst() {"}, {"sha": "fc6d61c79c2c435fdbeca2220050a166674b5076", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -34,10 +34,14 @@ pub mod interpret;\n pub mod transform;\n pub mod util;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n use rustc_target::abi::InitKind;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);\n     providers.eval_to_const_value_raw = const_eval::eval_to_const_value_raw_provider;"}, {"sha": "e4366f655e4712462a793fc5f6c18abe3a753298", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceC\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n-use rustc_middle::ty::{Binder, TraitRef, TypeVisitable};\n+use rustc_middle::ty::{Binder, TraitRef, TypeVisitableExt};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;"}, {"sha": "3f3b66b0645a83525d6000b7e7b27f4241fffa1c", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::mir::traversal::ReversePostorderIter;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, List, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, List, TyCtxt, TypeVisitableExt};\n use rustc_span::Span;\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -866,7 +866,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n             let mut projection = vec![PlaceElem::Deref];\n             projection.extend(place.projection);\n-            place.projection = tcx.intern_place_elems(&projection);\n+            place.projection = tcx.mk_place_elems(&projection);\n \n             // Create a temp to hold the promoted reference.\n             // This is because `*r` requires `r` to be a local,"}, {"sha": "068491646f47bfa73e63cf7c22357af2c2a317b5", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n     RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n     TerminatorKind, UnOp, START_BLOCK,\n };\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             ProjectionElem::Field(f, ty) => {\n-                let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n+                let parent = Place { local, projection: self.tcx.mk_place_elems(proj_base) };\n                 let parent_ty = parent.ty(&self.body.local_decls, self.tcx);\n                 let fail_out_of_bounds = |this: &Self, location| {\n                     this.fail(location, format!(\"Out of bounds field {:?} for {:?}\", f, parent_ty));"}, {"sha": "decbb6519ba37291c0155216dac6ff266dbd5bfe", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -29,8 +29,9 @@ smallvec = { version = \"1.8.1\", features = [\n stable_deref_trait = \"1.0.0\"\n stacker = \"0.1.15\"\n tempfile = \"3.2\"\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n+elsa = \"1.8\"\n \n [dependencies.parking_lot]\n version = \"0.11\""}, {"sha": "c4b11951ab7a08d477005d57ea2e2eb03a032887", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -27,7 +27,7 @@ pub struct Sccs<N: Idx, S: Idx> {\n     scc_data: SccData<S>,\n }\n \n-struct SccData<S: Idx> {\n+pub struct SccData<S: Idx> {\n     /// For each SCC, the range of `all_successors` where its\n     /// successors can be found.\n     ranges: IndexVec<S, Range<usize>>,\n@@ -43,6 +43,14 @@ impl<N: Idx, S: Idx + Ord> Sccs<N, S> {\n         SccsConstruction::construct(graph)\n     }\n \n+    pub fn scc_indices(&self) -> &IndexVec<N, S> {\n+        &self.scc_indices\n+    }\n+\n+    pub fn scc_data(&self) -> &SccData<S> {\n+        &self.scc_data\n+    }\n+\n     /// Returns the number of SCCs in the graph.\n     pub fn num_sccs(&self) -> usize {\n         self.scc_data.len()\n@@ -115,6 +123,14 @@ impl<S: Idx> SccData<S> {\n         self.ranges.len()\n     }\n \n+    pub fn ranges(&self) -> &IndexVec<S, Range<usize>> {\n+        &self.ranges\n+    }\n+\n+    pub fn all_successors(&self) -> &Vec<S> {\n+        &self.all_successors\n+    }\n+\n     /// Returns the successors of the given SCC.\n     fn successors(&self, scc: S) -> &[S] {\n         // Annoyingly, `range` does not implement `Copy`, so we have"}, {"sha": "31323c21df0092cef38cc422c024e0738833d56f", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -26,6 +26,10 @@ use std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n pub use std::sync::atomic::Ordering;\n pub use std::sync::atomic::Ordering::SeqCst;\n \n+pub use vec::AppendOnlyVec;\n+\n+mod vec;\n+\n cfg_if! {\n     if #[cfg(not(parallel_compiler))] {\n         pub auto trait Send {}"}, {"sha": "cbea4f059992282ffe7d5f9dd9d3b9c4a92de9ad", "filename": "compiler/rustc_data_structures/src/sync/vec.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -0,0 +1,41 @@\n+use std::marker::PhantomData;\n+\n+use rustc_index::vec::Idx;\n+\n+pub struct AppendOnlyVec<I: Idx, T: Copy> {\n+    #[cfg(not(parallel_compiler))]\n+    vec: elsa::vec::FrozenVec<T>,\n+    #[cfg(parallel_compiler)]\n+    vec: elsa::sync::LockFreeFrozenVec<T>,\n+    _marker: PhantomData<fn(&I)>,\n+}\n+\n+impl<I: Idx, T: Copy> AppendOnlyVec<I, T> {\n+    pub fn new() -> Self {\n+        Self {\n+            #[cfg(not(parallel_compiler))]\n+            vec: elsa::vec::FrozenVec::new(),\n+            #[cfg(parallel_compiler)]\n+            vec: elsa::sync::LockFreeFrozenVec::new(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn push(&self, val: T) -> I {\n+        #[cfg(not(parallel_compiler))]\n+        let i = self.vec.len();\n+        #[cfg(not(parallel_compiler))]\n+        self.vec.push(val);\n+        #[cfg(parallel_compiler)]\n+        let i = self.vec.push(val);\n+        I::new(i)\n+    }\n+\n+    pub fn get(&self, i: I) -> Option<T> {\n+        let i = i.index();\n+        #[cfg(not(parallel_compiler))]\n+        return self.vec.get_copy(i);\n+        #[cfg(parallel_compiler)]\n+        return self.vec.get(i);\n+    }\n+}"}, {"sha": "7b59a52cffedadcfaf839f1a6b81285fc064e5f4", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,6 +9,27 @@ edition = \"2021\"\n tracing = { version = \"0.1.35\" }\n serde_json = \"1.0.59\"\n rustc_log = { path = \"../rustc_log\" }\n+rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n+rustc_ast_passes = { path = \"../rustc_ast_passes\" }\n+rustc_attr = { path = \"../rustc_attr\" }\n+rustc_borrowck = { path = \"../rustc_borrowck\" }\n+rustc_builtin_macros = { path = \"../rustc_builtin_macros\" }\n+rustc_const_eval = { path = \"../rustc_const_eval\" }\n+rustc_error_messages = { path = \"../rustc_error_messages\" }\n+rustc_expand = { path = \"../rustc_expand\" }\n+rustc_hir_typeck = { path = \"../rustc_hir_typeck\" }\n+rustc_incremental = { path = \"../rustc_incremental\" }\n+rustc_infer = { path = \"../rustc_infer\" }\n+rustc_mir_build = { path = \"../rustc_mir_build\" }\n+rustc_mir_dataflow = { path = \"../rustc_mir_dataflow\" }\n+rustc_monomorphize = { path = \"../rustc_monomorphize\" }\n+rustc_passes = { path = \"../rustc_passes\" }\n+rustc_privacy = { path = \"../rustc_privacy\" }\n+rustc_query_system = { path = \"../rustc_query_system\" }\n+rustc_resolve = { path = \"../rustc_resolve\" }\n+rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n+rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "f19b1ff6426177c16eb24dd9093bfa268cb21464", "filename": "compiler/rustc_driver_impl/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_driver_impl%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_driver_impl%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl"}, {"sha": "464ddae476a5e0ed7460e1023d7c78b41c8881d9", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -23,11 +23,14 @@ use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n-use rustc_errors::{ErrorGuaranteed, PResult, TerminalUrl};\n+use rustc_errors::{\n+    DiagnosticMessage, ErrorGuaranteed, PResult, SubdiagnosticMessage, TerminalUrl,\n+};\n use rustc_feature::find_gated_cfg;\n use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n+use rustc_macros::fluent_messages;\n use rustc_metadata::locator;\n use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n@@ -61,6 +64,44 @@ use crate::session_diagnostics::{\n     RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n };\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n+pub static DEFAULT_LOCALE_RESOURCES: &[&str] = &[\n+    // tidy-alphabetical-start\n+    crate::DEFAULT_LOCALE_RESOURCE,\n+    rustc_ast_lowering::DEFAULT_LOCALE_RESOURCE,\n+    rustc_ast_passes::DEFAULT_LOCALE_RESOURCE,\n+    rustc_attr::DEFAULT_LOCALE_RESOURCE,\n+    rustc_borrowck::DEFAULT_LOCALE_RESOURCE,\n+    rustc_builtin_macros::DEFAULT_LOCALE_RESOURCE,\n+    rustc_codegen_ssa::DEFAULT_LOCALE_RESOURCE,\n+    rustc_const_eval::DEFAULT_LOCALE_RESOURCE,\n+    rustc_error_messages::DEFAULT_LOCALE_RESOURCE,\n+    rustc_expand::DEFAULT_LOCALE_RESOURCE,\n+    rustc_hir_analysis::DEFAULT_LOCALE_RESOURCE,\n+    rustc_hir_typeck::DEFAULT_LOCALE_RESOURCE,\n+    rustc_incremental::DEFAULT_LOCALE_RESOURCE,\n+    rustc_infer::DEFAULT_LOCALE_RESOURCE,\n+    rustc_interface::DEFAULT_LOCALE_RESOURCE,\n+    rustc_lint::DEFAULT_LOCALE_RESOURCE,\n+    rustc_metadata::DEFAULT_LOCALE_RESOURCE,\n+    rustc_middle::DEFAULT_LOCALE_RESOURCE,\n+    rustc_mir_build::DEFAULT_LOCALE_RESOURCE,\n+    rustc_mir_dataflow::DEFAULT_LOCALE_RESOURCE,\n+    rustc_monomorphize::DEFAULT_LOCALE_RESOURCE,\n+    rustc_parse::DEFAULT_LOCALE_RESOURCE,\n+    rustc_passes::DEFAULT_LOCALE_RESOURCE,\n+    rustc_plugin_impl::DEFAULT_LOCALE_RESOURCE,\n+    rustc_privacy::DEFAULT_LOCALE_RESOURCE,\n+    rustc_query_system::DEFAULT_LOCALE_RESOURCE,\n+    rustc_resolve::DEFAULT_LOCALE_RESOURCE,\n+    rustc_session::DEFAULT_LOCALE_RESOURCE,\n+    rustc_symbol_mangling::DEFAULT_LOCALE_RESOURCE,\n+    rustc_trait_selection::DEFAULT_LOCALE_RESOURCE,\n+    rustc_ty_utils::DEFAULT_LOCALE_RESOURCE,\n+    // tidy-alphabetical-end\n+];\n+\n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n \n@@ -218,6 +259,7 @@ fn run_compiler(\n         output_file: ofile,\n         output_dir: odir,\n         file_loader,\n+        locale_resources: DEFAULT_LOCALE_RESOURCES,\n         lint_caps: Default::default(),\n         parse_sess_created: None,\n         register_lints: None,\n@@ -443,7 +485,7 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let normalised =\n         if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n     match registry.try_find_description(&normalised) {\n-        Ok(Some(description)) => {\n+        Ok(description) => {\n             let mut is_in_code_block = false;\n             let mut text = String::new();\n             // Slice off the leading newline and print.\n@@ -467,9 +509,6 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n                 print!(\"{text}\");\n             }\n         }\n-        Ok(None) => {\n-            early_error(output, &format!(\"no extended information for {code}\"));\n-        }\n         Err(InvalidErrorCode) => {\n             early_error(output, &format!(\"{code} is not a valid error code\"));\n         }\n@@ -1162,7 +1201,7 @@ static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n /// hook.\n pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     let fallback_bundle =\n-        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+        rustc_errors::fallback_fluent_bundle(crate::DEFAULT_LOCALE_RESOURCES.to_vec(), false);\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,"}, {"sha": "df857be85adabf8bc9dfe9da11b26848cdf633d7", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -253,6 +253,7 @@ E0466: include_str!(\"./error_codes/E0466.md\"),\n E0468: include_str!(\"./error_codes/E0468.md\"),\n E0469: include_str!(\"./error_codes/E0469.md\"),\n E0472: include_str!(\"./error_codes/E0472.md\"),\n+E0476: include_str!(\"./error_codes/E0476.md\"),\n E0477: include_str!(\"./error_codes/E0477.md\"),\n E0478: include_str!(\"./error_codes/E0478.md\"),\n E0482: include_str!(\"./error_codes/E0482.md\"),\n@@ -512,7 +513,9 @@ E0790: include_str!(\"./error_codes/E0790.md\"),\n E0791: include_str!(\"./error_codes/E0791.md\"),\n E0792: include_str!(\"./error_codes/E0792.md\"),\n E0793: include_str!(\"./error_codes/E0793.md\"),\n-;\n+}\n+\n+// Undocumented removed error codes. Note that many removed error codes are documented.\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard\n //  E0019, // merged into E0015\n@@ -569,7 +572,7 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0246, // invalid recursive type\n //  E0247,\n //  E0248, // value used as a type, now reported earlier during resolution\n-           // as E0412\n+//         // as E0412\n //  E0249,\n //  E0257,\n //  E0258,\n@@ -611,7 +614,6 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0473, // dereference of reference outside its lifetime\n //  E0474, // captured variable `..` does not outlive the enclosing closure\n //  E0475, // index of slice outside its lifetime\n-    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n //  E0479, // the type `..` (provided as the value of a type parameter) is...\n //  E0480, // lifetime of method receiver does not outlive the method call\n //  E0481, // lifetime of function argument does not outlive the function call\n@@ -631,14 +633,14 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0558, // replaced with a generic attribute input check\n //  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n //  E0564, // only named lifetimes are allowed in `impl Trait`,\n-           // but `{}` was found in the type `{}`\n+//         // but `{}` was found in the type `{}`\n //  E0598, // lifetime of {} is too short to guarantee its contents can be...\n //  E0611, // merged into E0616\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n //  E0629, // missing 'feature' (rustc_const_unstable)\n //  E0630, // rustc_const_unstable attribute must be paired with stable/unstable\n-           // attribute\n+//         // attribute\n //  E0645, // trait aliases not finished\n //  E0694, // an unknown tool name found in scoped attributes\n //  E0702, // replaced with a generic attribute input check\n@@ -647,4 +649,3 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-}"}, {"sha": "fc141ba77f5df1ef6bf1bed0919cd1c13b060cc5", "filename": "compiler/rustc_error_codes/src/error_codes/E0476.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -0,0 +1,21 @@\n+The coerced type does not outlive the value being coerced to.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0476\n+#![feature(coerce_unsized)]\n+#![feature(unsize)]\n+\n+use std::marker::Unsize;\n+use std::ops::CoerceUnsized;\n+\n+// error: lifetime of the source pointer does not outlive lifetime bound of the\n+//        object type\n+impl<'a, 'b, T, S> CoerceUnsized<&'a T> for &'b S where S: Unsize<T> {}\n+```\n+\n+During a coercion, the \"source pointer\" (the coerced type) did not outlive the\n+\"object type\" (value being coerced to). In the above example, `'b` is not a\n+subtype of `'a`. This error can currently only be encountered with the unstable\n+`CoerceUnsized` trait which allows custom coercions of unsized types behind a\n+smart pointer to be implemented."}, {"sha": "d6b120e4dfcf23b81c3f029707beefdfb412cd35", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,10 +5,9 @@\n //! the goal being to make their maintenance easier.\n \n macro_rules! register_diagnostics {\n-    ($($ecode:ident: $message:expr,)* ; $($code:ident,)*) => (\n-        pub static DIAGNOSTICS: &[(&str, Option<&str>)] = &[\n-            $( (stringify!($ecode), Some($message)), )*\n-            $( (stringify!($code), None), )*\n+    ($($ecode:ident: $message:expr,)*) => (\n+        pub static DIAGNOSTICS: &[(&str, &str)] = &[\n+            $( (stringify!($ecode), $message), )*\n         ];\n     )\n }"}, {"sha": "e62923744482260f697a0083a88241a34cb0bc74", "filename": "compiler/rustc_error_messages/locales/en-US.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_messages%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_messages%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -0,0 +1 @@\n+# satisfy tidy lint by having a line in this file"}, {"sha": "5f28839f136d6276fd3fb465dd749b8edb7d5ad2", "filename": "compiler/rustc_error_messages/locales/en-US/ast_passes.ftl", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9fb185210eaa9d2de7e8ab1161897edf2eaae758/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9fb185210eaa9d2de7e8ab1161897edf2eaae758/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl?ref=9fb185210eaa9d2de7e8ab1161897edf2eaae758", "patch": "@@ -1,92 +0,0 @@\n-ast_passes_forbidden_let =\n-    `let` expressions are not supported here\n-    .note = only supported directly in conditions of `if` and `while` expressions\n-    .not_supported_or = `||` operators are not supported in let chain expressions\n-    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n-\n-ast_passes_forbidden_let_stable =\n-    expected expression, found statement (`let`)\n-    .note = variable declaration using `let` is a statement\n-\n-ast_passes_deprecated_where_clause_location =\n-    where clause not allowed here\n-\n-ast_passes_forbidden_assoc_constraint =\n-    associated type bounds are not allowed within structs, enums, or unions\n-\n-ast_passes_keyword_lifetime =\n-    lifetimes cannot use keyword names\n-\n-ast_passes_invalid_label =\n-    invalid label name `{$name}`\n-\n-ast_passes_invalid_visibility =\n-    unnecessary visibility qualifier\n-    .implied = `pub` not permitted here because it's implied\n-    .individual_impl_items = place qualifiers on individual impl items instead\n-    .individual_foreign_items = place qualifiers on individual foreign items instead\n-\n-ast_passes_trait_fn_const =\n-    functions in traits cannot be declared const\n-    .label = functions in traits cannot be const\n-\n-ast_passes_forbidden_lifetime_bound =\n-    lifetime bounds cannot be used in this context\n-\n-ast_passes_forbidden_non_lifetime_param =\n-    only lifetime parameters can be used in this context\n-\n-ast_passes_fn_param_too_many =\n-    function can not have more than {$max_num_args} arguments\n-\n-ast_passes_fn_param_c_var_args_only =\n-    C-variadic function must be declared with at least one named argument\n-\n-ast_passes_fn_param_c_var_args_not_last =\n-    `...` must be the last argument of a C-variadic function\n-\n-ast_passes_fn_param_doc_comment =\n-    documentation comments cannot be applied to function parameters\n-    .label = doc comments are not allowed here\n-\n-ast_passes_fn_param_forbidden_attr =\n-    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n-\n-ast_passes_fn_param_forbidden_self =\n-    `self` parameter is only allowed in associated functions\n-    .label = not semantically valid as function parameter\n-    .note = associated functions are those in `impl` or `trait` definitions\n-\n-ast_passes_forbidden_default =\n-    `default` is only allowed on items in trait impls\n-    .label = `default` because of this\n-\n-ast_passes_assoc_const_without_body =\n-    associated constant in `impl` without body\n-    .suggestion = provide a definition for the constant\n-\n-ast_passes_assoc_fn_without_body =\n-    associated function in `impl` without body\n-    .suggestion = provide a definition for the function\n-\n-ast_passes_assoc_type_without_body =\n-    associated type in `impl` without body\n-    .suggestion = provide a definition for the type\n-\n-ast_passes_const_without_body =\n-    free constant item without body\n-    .suggestion = provide a definition for the constant\n-\n-ast_passes_static_without_body =\n-    free static item without body\n-    .suggestion = provide a definition for the static\n-\n-ast_passes_ty_alias_without_body =\n-    free type alias without body\n-    .suggestion = provide a definition for the type\n-\n-ast_passes_fn_without_body =\n-    free function without a body\n-    .suggestion = provide a definition for the function\n-\n-ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block"}, {"sha": "429bdd2777f912db3e7d3d57a17a1ca7074207fc", "filename": "compiler/rustc_error_messages/locales/en-US/errors.ftl", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9fb185210eaa9d2de7e8ab1161897edf2eaae758/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ferrors.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9fb185210eaa9d2de7e8ab1161897edf2eaae758/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ferrors.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ferrors.ftl?ref=9fb185210eaa9d2de7e8ab1161897edf2eaae758", "patch": "@@ -1,13 +0,0 @@\n-errors_target_invalid_address_space = invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n-\n-errors_target_invalid_bits = invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n-\n-errors_target_missing_alignment = missing alignment for `{$cause}` in \"data-layout\"\n-\n-errors_target_invalid_alignment = invalid alignment for `{$cause}` in \"data-layout\": {$err}\n-\n-errors_target_inconsistent_architecture = inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n-\n-errors_target_inconsistent_pointer_width = inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n-\n-errors_target_invalid_bits_size = {$err}"}, {"sha": "010e5f060bf0b86df7b34be46ed728363b2babdc", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -34,47 +34,7 @@ use intl_memoizer::IntlLangMemoizer;\n pub use fluent_bundle::{self, types::FluentType, FluentArgs, FluentError, FluentValue};\n pub use unic_langid::{langid, LanguageIdentifier};\n \n-// Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n-fluent_messages! {\n-    // tidy-alphabetical-start\n-    ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n-    ast_passes => \"../locales/en-US/ast_passes.ftl\",\n-    attr => \"../locales/en-US/attr.ftl\",\n-    borrowck => \"../locales/en-US/borrowck.ftl\",\n-    builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n-    codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n-    codegen_llvm => \"../locales/en-US/codegen_llvm.ftl\",\n-    codegen_ssa => \"../locales/en-US/codegen_ssa.ftl\",\n-    compiletest => \"../locales/en-US/compiletest.ftl\",\n-    const_eval => \"../locales/en-US/const_eval.ftl\",\n-    driver => \"../locales/en-US/driver.ftl\",\n-    errors => \"../locales/en-US/errors.ftl\",\n-    expand => \"../locales/en-US/expand.ftl\",\n-    hir_analysis => \"../locales/en-US/hir_analysis.ftl\",\n-    hir_typeck => \"../locales/en-US/hir_typeck.ftl\",\n-    incremental => \"../locales/en-US/incremental.ftl\",\n-    infer => \"../locales/en-US/infer.ftl\",\n-    interface => \"../locales/en-US/interface.ftl\",\n-    lint => \"../locales/en-US/lint.ftl\",\n-    metadata => \"../locales/en-US/metadata.ftl\",\n-    middle => \"../locales/en-US/middle.ftl\",\n-    mir_build => \"../locales/en-US/mir_build.ftl\",\n-    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n-    monomorphize => \"../locales/en-US/monomorphize.ftl\",\n-    parse => \"../locales/en-US/parse.ftl\",\n-    passes => \"../locales/en-US/passes.ftl\",\n-    plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n-    privacy => \"../locales/en-US/privacy.ftl\",\n-    query_system => \"../locales/en-US/query_system.ftl\",\n-    resolve => \"../locales/en-US/resolve.ftl\",\n-    session => \"../locales/en-US/session.ftl\",\n-    symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n-    trait_selection => \"../locales/en-US/trait_selection.ftl\",\n-    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n-    // tidy-alphabetical-end\n-}\n-\n-pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};\n+fluent_messages! { \"../locales/en-US.ftl\" }\n \n pub type FluentBundle = fluent_bundle::bundle::FluentBundle<FluentResource, IntlLangMemoizer>;\n \n@@ -175,7 +135,10 @@ pub fn fluent_bundle(\n \n     let fallback_locale = langid!(\"en-US\");\n     let requested_fallback_locale = requested_locale.as_ref() == Some(&fallback_locale);\n-\n+    trace!(?requested_fallback_locale);\n+    if requested_fallback_locale && additional_ftl_path.is_none() {\n+        return Ok(None);\n+    }\n     // If there is only `-Z additional-ftl-path`, assume locale is \"en-US\", otherwise use user\n     // provided locale.\n     let locale = requested_locale.clone().unwrap_or(fallback_locale);\n@@ -193,7 +156,7 @@ pub fn fluent_bundle(\n     bundle.set_use_isolating(with_directionality_markers);\n \n     // If the user requests the default locale then don't try to load anything.\n-    if !requested_fallback_locale && let Some(requested_locale) = requested_locale {\n+    if let Some(requested_locale) = requested_locale {\n         let mut found_resources = false;\n         for sysroot in user_provided_sysroot.iter_mut().chain(sysroot_candidates.iter_mut()) {\n             sysroot.push(\"share\");\n@@ -263,7 +226,7 @@ pub type LazyFallbackBundle = Lrc<Lazy<FluentBundle, impl FnOnce() -> FluentBund\n /// Return the default `FluentBundle` with standard \"en-US\" diagnostic messages.\n #[instrument(level = \"trace\")]\n pub fn fallback_fluent_bundle(\n-    resources: &'static [&'static str],\n+    resources: Vec<&'static str>,\n     with_directionality_markers: bool,\n ) -> LazyFallbackBundle {\n     Lrc::new(Lazy::new(move || {"}, {"sha": "dde1d6c0a819c6560d36ad532c4ef9c42e772793", "filename": "compiler/rustc_errors/locales/en-US.ftl", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -0,0 +1,19 @@\n+errors_target_invalid_address_space =\n+    invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n+\n+errors_target_invalid_bits =\n+    invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n+\n+errors_target_missing_alignment =\n+    missing alignment for `{$cause}` in \"data-layout\"\n+\n+errors_target_invalid_alignment =\n+    invalid alignment for `{$cause}` in \"data-layout\": {$err}\n+\n+errors_target_inconsistent_architecture =\n+    inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n+\n+errors_target_inconsistent_pointer_width =\n+    inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n+\n+errors_target_invalid_bits_size = {$err}"}, {"sha": "e82bad67b21ecc122043dc34ff5eceb5c857f0c0", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,5 @@\n-use crate::{\n-    fluent, DiagnosticArgValue, DiagnosticBuilder, Handler, IntoDiagnostic, IntoDiagnosticArg,\n-};\n+use crate::fluent_generated as fluent;\n+use crate::{DiagnosticArgValue, DiagnosticBuilder, Handler, IntoDiagnostic, IntoDiagnosticArg};\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_hir as hir;\n@@ -55,6 +54,7 @@ macro_rules! into_diagnostic_arg_using_display {\n }\n \n into_diagnostic_arg_using_display!(\n+    ast::ParamKindOrd,\n     i8,\n     u8,\n     i16,"}, {"sha": "f32d6b96b9b2429d13e47d61f29789c23daaf392", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -580,7 +580,7 @@ impl DiagnosticCode {\n             let je_result =\n                 je.registry.as_ref().map(|registry| registry.try_find_description(&s)).unwrap();\n \n-            DiagnosticCode { code: s, explanation: je_result.unwrap_or(None) }\n+            DiagnosticCode { code: s, explanation: je_result.ok() }\n         })\n     }\n }"}, {"sha": "671dc449eaa73072fe92229a514e9486ed3a73e6", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -46,7 +46,7 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n         let fallback_bundle =\n-            crate::fallback_fluent_bundle(rustc_error_messages::DEFAULT_LOCALE_RESOURCES, false);\n+            crate::fallback_fluent_bundle(vec![crate::DEFAULT_LOCALE_RESOURCE], false);\n \n         let output = Arc::new(Mutex::new(Vec::new()));\n         let je = JsonEmitter::new("}, {"sha": "cbf595089ccc68c7e874ef5c2250ca810ca28a73", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -36,13 +36,13 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n pub use rustc_error_messages::{\n-    fallback_fluent_bundle, fluent, fluent_bundle, DelayDm, DiagnosticMessage, FluentBundle,\n+    fallback_fluent_bundle, fluent_bundle, DelayDm, DiagnosticMessage, FluentBundle,\n     LanguageIdentifier, LazyFallbackBundle, MultiSpan, SpanLabel, SubdiagnosticMessage,\n-    DEFAULT_LOCALE_RESOURCES,\n };\n pub use rustc_lint_defs::{pluralize, Applicability};\n+use rustc_macros::fluent_messages;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::HashStableContext;\n+pub use rustc_span::ErrorGuaranteed;\n use rustc_span::{Loc, Span};\n \n use std::borrow::Cow;\n@@ -76,6 +76,8 @@ pub use snippet::Style;\n pub type PErr<'a> = DiagnosticBuilder<'a, ErrorGuaranteed>;\n pub type PResult<'a, T> = Result<T, PErr<'a>>;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n // (See also the comment on `DiagnosticBuilderInner`'s `diagnostic` field.)\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -1475,9 +1477,7 @@ impl HandlerInner {\n                 .emitted_diagnostic_codes\n                 .iter()\n                 .filter_map(|x| match &x {\n-                    DiagnosticId::Error(s)\n-                        if registry.try_find_description(s).map_or(false, |o| o.is_some()) =>\n-                    {\n+                    DiagnosticId::Error(s) if registry.try_find_description(s).is_ok() => {\n                         Some(s.clone())\n                     }\n                     _ => None,\n@@ -1844,17 +1844,3 @@ pub enum TerminalUrl {\n     Yes,\n     Auto,\n }\n-\n-/// Useful type to use with `Result<>` indicate that an error has already\n-/// been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, Encodable, Decodable, Hash, PartialEq, Eq, PartialOrd, Ord)]\n-#[derive(HashStable_Generic)]\n-pub struct ErrorGuaranteed(());\n-\n-impl ErrorGuaranteed {\n-    /// To be used only if you really know what you are doing... ideally, we would find a way to\n-    /// eliminate all calls to this method.\n-    pub fn unchecked_claim_error_was_emitted() -> Self {\n-        ErrorGuaranteed(())\n-    }\n-}"}, {"sha": "f26d8e7ebdc34241da30bda5d32d0eefd5d48a7f", "filename": "compiler/rustc_errors/src/registry.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,21 +5,17 @@ pub struct InvalidErrorCode;\n \n #[derive(Clone)]\n pub struct Registry {\n-    long_descriptions: FxHashMap<&'static str, Option<&'static str>>,\n+    long_descriptions: FxHashMap<&'static str, &'static str>,\n }\n \n impl Registry {\n-    pub fn new(long_descriptions: &[(&'static str, Option<&'static str>)]) -> Registry {\n+    pub fn new(long_descriptions: &[(&'static str, &'static str)]) -> Registry {\n         Registry { long_descriptions: long_descriptions.iter().copied().collect() }\n     }\n \n     /// Returns `InvalidErrorCode` if the code requested does not exist in the\n-    /// registry. Otherwise, returns an `Option` where `None` means the error\n-    /// code is valid but has no extended information.\n-    pub fn try_find_description(\n-        &self,\n-        code: &str,\n-    ) -> Result<Option<&'static str>, InvalidErrorCode> {\n+    /// registry.\n+    pub fn try_find_description(&self, code: &str) -> Result<&'static str, InvalidErrorCode> {\n         self.long_descriptions.get(code).copied().ok_or(InvalidErrorCode)\n     }\n }"}, {"sha": "ed35eb1b6c4ad8f567180cc9119ff7aa8c097938", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,9 +1,10 @@\n-use crate::error::TranslateError;\n+use crate::error::{TranslateError, TranslateErrorKind};\n use crate::snippet::Style;\n use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n+use std::env;\n use std::error::Report;\n \n /// Convert diagnostic arguments (a rustc internal type that exists to implement\n@@ -94,12 +95,29 @@ pub trait Translate {\n                 // The primary bundle was present and translation succeeded\n                 Some(Ok(t)) => t,\n \n-                // Always yeet out for errors on debug\n-                Some(Err(primary)) if cfg!(debug_assertions) => do yeet primary,\n-\n                 // If `translate_with_bundle` returns `Err` with the primary bundle, this is likely\n-                // just that the primary bundle doesn't contain the message being translated or\n-                // something else went wrong) so proceed to the fallback bundle.\n+                // just that the primary bundle doesn't contain the message being translated, so\n+                // proceed to the fallback bundle.\n+                Some(Err(\n+                    primary @ TranslateError::One {\n+                        kind: TranslateErrorKind::MessageMissing, ..\n+                    },\n+                )) => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| primary.and(fallback))?,\n+\n+                // Always yeet out for errors on debug (unless\n+                // `RUSTC_TRANSLATION_NO_DEBUG_ASSERT` is set in the environment - this allows\n+                // local runs of the test suites, of builds with debug assertions, to test the\n+                // behaviour in a normal build).\n+                Some(Err(primary))\n+                    if cfg!(debug_assertions)\n+                        && env::var(\"RUSTC_TRANSLATION_NO_DEBUG_ASSERT\").is_err() =>\n+                {\n+                    do yeet primary\n+                }\n+\n+                // ..otherwise, for end users, an error about this wouldn't be useful or actionable, so\n+                // just hide it and try with the fallback bundle.\n                 Some(Err(primary)) => translate_with_bundle(self.fallback_fluent_bundle())\n                     .map_err(|fallback| primary.and(fallback))?,\n "}, {"sha": "c971714e05bb3cbcafb3d17e4468da11035343ca", "filename": "compiler/rustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -24,5 +24,5 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "b475d285f6b7e093ead43bc683d89318c066229b", "filename": "compiler/rustc_expand/locales/en-US.ftl", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -129,3 +129,7 @@ expand_module_multiple_candidates =\n     .help = delete or rename one of them to remove the ambiguity\n \n expand_trace_macro = trace_macro\n+\n+expand_proc_macro_panicked =\n+    proc macro panicked\n+    .help = message: {$message}", "previous_filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl"}, {"sha": "22bc90f5cac2ee8e1d44d9ed19c71f30f98ad3b5", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -29,10 +29,11 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n-\n+use std::default::Default;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use thin_vec::ThinVec;\n \n pub(crate) use rustc_span::hygiene::MacroKind;\n \n@@ -554,7 +555,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span, is_error: bool) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(ThinVec::new()) },\n             span: sp,\n             attrs: ast::AttrVec::new(),\n             tokens: None,\n@@ -570,7 +571,7 @@ impl DummyResult {\n     pub fn raw_ty(sp: Span, is_error: bool) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(ThinVec::new()) },\n             span: sp,\n             tokens: None,\n         })"}, {"sha": "8a78c3296f9cfdc5e86cbf9dc97701385d9a6b78", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::{attr, token, util::literal};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<Ident>) -> ast::Path {\n@@ -125,7 +125,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n         ast::PolyTraitRef {\n-            bound_generic_params: Vec::new(),\n+            bound_generic_params: ThinVec::new(),\n             trait_ref: self.trait_ref(path),\n             span,\n         }\n@@ -221,14 +221,14 @@ impl<'a> ExtCtxt<'a> {\n     pub fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n         self.block(\n             expr.span,\n-            vec![ast::Stmt {\n+            thin_vec![ast::Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 span: expr.span,\n                 kind: ast::StmtKind::Expr(expr),\n             }],\n         )\n     }\n-    pub fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+    pub fn block(&self, span: Span, stmts: ThinVec<ast::Stmt>) -> P<ast::Block> {\n         P(ast::Block {\n             stmts,\n             id: ast::DUMMY_NODE_ID,\n@@ -284,18 +284,23 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         expr: P<ast::Expr>,\n-        args: Vec<P<ast::Expr>>,\n+        args: ThinVec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n-    pub fn expr_call_ident(&self, span: Span, id: Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_call_ident(\n+        &self,\n+        span: Span,\n+        id: Ident,\n+        args: ThinVec<P<ast::Expr>>,\n+    ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n     pub fn expr_call_global(\n         &self,\n         sp: Span,\n         fn_path: Vec<Ident>,\n-        args: Vec<P<ast::Expr>>,\n+        args: ThinVec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n@@ -318,7 +323,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         path: ast::Path,\n-        fields: Vec<ast::ExprField>,\n+        fields: ThinVec<ast::ExprField>,\n     ) -> P<ast::Expr> {\n         self.expr(\n             span,\n@@ -334,7 +339,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         id: Ident,\n-        fields: Vec<ast::ExprField>,\n+        fields: ThinVec<ast::ExprField>,\n     ) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n@@ -372,12 +377,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     /// `[expr1, expr2, ...]`\n-    pub fn expr_array(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_array(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n \n     /// `&[expr1, expr2, ...]`\n-    pub fn expr_array_ref(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_array_ref(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_array(sp, exprs))\n     }\n \n@@ -387,22 +392,22 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n-        self.expr_call_global(sp, some, vec![expr])\n+        self.expr_call_global(sp, some, thin_vec![expr])\n     }\n \n     pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n         let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n         self.expr_path(self.path_global(sp, none))\n     }\n-    pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_tuple(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n     pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         self.expr_call_global(\n             span,\n             [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n-            vec![self.expr_str(span, msg)],\n+            thin_vec![self.expr_str(span, msg)],\n         )\n     }\n \n@@ -412,7 +417,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n-        self.expr_call_global(sp, ok, vec![expr])\n+        self.expr_call_global(sp, ok, thin_vec![expr])\n     }\n \n     pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n@@ -426,12 +431,12 @@ impl<'a> ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // `Ok(__try_var)` pattern\n-        let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n+        let ok_pat = self.pat_tuple_struct(sp, ok_path, thin_vec![binding_pat.clone()]);\n \n         // `Err(__try_var)` (pattern and expression respectively)\n-        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n+        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), thin_vec![binding_pat]);\n         let err_inner_expr =\n-            self.expr_call(sp, self.expr_path(err_path), vec![binding_expr.clone()]);\n+            self.expr_call(sp, self.expr_path(err_path), thin_vec![binding_expr.clone()]);\n         // `return Err(__try_var)`\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n@@ -441,7 +446,7 @@ impl<'a> ExtCtxt<'a> {\n         let err_arm = self.arm(sp, err_pat, err_expr);\n \n         // `match head { Ok() => ..., Err() => ... }`\n-        self.expr_match(sp, head, vec![ok_arm, err_arm])\n+        self.expr_match(sp, head, thin_vec![ok_arm, err_arm])\n     }\n \n     pub fn pat(&self, span: Span, kind: PatKind) -> P<ast::Pat> {\n@@ -473,26 +478,26 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         path: ast::Path,\n-        subpats: Vec<P<ast::Pat>>,\n+        subpats: ThinVec<P<ast::Pat>>,\n     ) -> P<ast::Pat> {\n         self.pat(span, PatKind::TupleStruct(None, path, subpats))\n     }\n     pub fn pat_struct(\n         &self,\n         span: Span,\n         path: ast::Path,\n-        field_pats: Vec<ast::PatField>,\n+        field_pats: ThinVec<ast::PatField>,\n     ) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(None, path, field_pats, false))\n     }\n-    pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+    pub fn pat_tuple(&self, span: Span, pats: ThinVec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats))\n     }\n \n     pub fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n+        self.pat_tuple_struct(span, path, thin_vec![pat])\n     }\n \n     pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n@@ -511,7 +516,7 @@ impl<'a> ExtCtxt<'a> {\n         self.arm(span, self.pat_wild(span), self.expr_unreachable(span))\n     }\n \n-    pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n+    pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: ThinVec<ast::Arm>) -> P<Expr> {\n         self.expr(span, ast::ExprKind::Match(arg, arms))\n     }\n \n@@ -562,7 +567,12 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>, ident: Ident) -> P<ast::Expr> {\n+    pub fn lambda_stmts_1(\n+        &self,\n+        span: Span,\n+        stmts: ThinVec<ast::Stmt>,\n+        ident: Ident,\n+    ) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n@@ -579,7 +589,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     // `self` is unused but keep it as method for the convenience use.\n-    pub fn fn_decl(&self, inputs: Vec<ast::Param>, output: ast::FnRetTy) -> P<ast::FnDecl> {\n+    pub fn fn_decl(&self, inputs: ThinVec<ast::Param>, output: ast::FnRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl { inputs, output })\n     }\n "}, {"sha": "01500c2c77c90aac5a2ac28a6da84abdfa724461", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -24,6 +24,7 @@ use rustc_session::Session;\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use thin_vec::ThinVec;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n@@ -206,7 +207,7 @@ pub fn features(\n         None => {\n             // The entire crate is unconfigured.\n             krate.attrs = ast::AttrVec::new();\n-            krate.items = Vec::new();\n+            krate.items = ThinVec::new();\n             Features::default()\n         }\n         Some(attrs) => {"}, {"sha": "70ab222b484700b7620cfce71992389ae40ac36a", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -65,7 +65,7 @@ pub(crate) struct MacroConstStability {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(label2)]\n+    #[label(expand_label2)]\n     pub head_span: Span,\n }\n \n@@ -75,7 +75,7 @@ pub(crate) struct MacroBodyStability {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(label2)]\n+    #[label(expand_label2)]\n     pub head_span: Span,\n }\n \n@@ -188,7 +188,7 @@ pub(crate) struct FeatureRemoved<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[note(reason)]\n+#[note(expand_reason)]\n pub(crate) struct FeatureRemovedReason<'a> {\n     pub reason: &'a str,\n }\n@@ -223,12 +223,12 @@ pub(crate) struct MalformedFeatureAttribute {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum MalformedFeatureAttributeHelp {\n-    #[label(expected)]\n+    #[label(expand_expected)]\n     Label {\n         #[primary_span]\n         span: Span,\n     },\n-    #[suggestion(expected, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(expand_expected, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n     Suggestion {\n         #[primary_span]\n         span: Span,\n@@ -306,7 +306,7 @@ pub(crate) struct IncompleteParse<'a> {\n     pub kind_name: &'a str,\n \n     #[suggestion(\n-        suggestion_add_semi,\n+        expand_suggestion_add_semi,\n         style = \"verbose\",\n         code = \";\",\n         applicability = \"maybe-incorrect\"\n@@ -340,7 +340,7 @@ pub(crate) struct ModuleInBlock {\n }\n \n #[derive(Subdiagnostic)]\n-#[note(note)]\n+#[note(expand_note)]\n pub(crate) struct ModuleInBlockName {\n     #[primary_span]\n     pub span: Span,\n@@ -375,3 +375,18 @@ pub struct TraceMacro {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_proc_macro_panicked)]\n+pub(crate) struct ProcMacroPanicked {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub message: Option<ProcMacroPanickedHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(expand_help)]\n+pub(crate) struct ProcMacroPanickedHelp {\n+    pub message: String,\n+}"}, {"sha": "634e206e58ab47f7cb119130cea5d5c0422a885d", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -20,6 +20,9 @@ extern crate tracing;\n \n extern crate proc_macro as pm;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n+\n mod placeholders;\n mod proc_macro_server;\n \n@@ -60,3 +63,5 @@ mod tokenstream {\n mod mut_visit {\n     mod tests;\n }\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "3779af19e122f1b81cb9123b4de2c2372d22b8d8", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -12,8 +12,8 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::iter::once;\n-\n use std::path::{self, Path, PathBuf};\n+use thin_vec::ThinVec;\n \n #[derive(Copy, Clone)]\n pub enum DirOwnership {\n@@ -31,7 +31,7 @@ pub struct ModulePathSuccess {\n }\n \n pub(crate) struct ParsedExternalMod {\n-    pub items: Vec<P<Item>>,\n+    pub items: ThinVec<P<Item>>,\n     pub spans: ModSpans,\n     pub file_path: PathBuf,\n     pub dir_path: PathBuf,"}, {"sha": "8b37728b60fea3e86b6382aaf3cd2f6209ce824e", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -18,7 +18,10 @@ use rustc_span::{BytePos, FileName, Pos, Span};\n use std::path::PathBuf;\n \n fn sess() -> ParseSess {\n-    ParseSess::new(FilePathMapping::empty())\n+    ParseSess::new(\n+        vec![crate::DEFAULT_LOCALE_RESOURCE, rustc_parse::DEFAULT_LOCALE_RESOURCE],\n+        FilePathMapping::empty(),\n+    )\n }\n \n /// Parses an item."}, {"sha": "cef64a1047902afdf12fb0f5cf87dfb6a2cefbc5", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,4 +1,5 @@\n use crate::base::{self, *};\n+use crate::errors;\n use crate::proc_macro_server;\n \n use rustc_ast as ast;\n@@ -60,11 +61,12 @@ impl base::BangProcMacro for BangProcMacro {\n         let strategy = exec_strategy(ecx);\n         let server = proc_macro_server::Rustc::new(ecx);\n         self.client.run(&strategy, server, input, proc_macro_backtrace).map_err(|e| {\n-            let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n-            if let Some(s) = e.as_str() {\n-                err.help(&format!(\"message: {}\", s));\n-            }\n-            err.emit()\n+            ecx.sess.emit_err(errors::ProcMacroPanicked {\n+                span,\n+                message: e\n+                    .as_str()\n+                    .map(|message| errors::ProcMacroPanickedHelp { message: message.into() }),\n+            })\n         })\n     }\n }"}, {"sha": "14918d3c190a5c75789a282e549a964f09e35097", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -34,7 +34,10 @@ where\n \n /// Maps a string to tts, using a made-up filename.\n pub(crate) fn string_to_stream(source_str: String) -> TokenStream {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n+    let ps = ParseSess::new(\n+        vec![crate::DEFAULT_LOCALE_RESOURCE, rustc_parse::DEFAULT_LOCALE_RESOURCE],\n+        FilePathMapping::empty(),\n+    );\n     source_file_to_stream(\n         &ps,\n         ps.source_map().new_source_file(PathBuf::from(\"bogofile\").into(), source_str),\n@@ -45,7 +48,10 @@ pub(crate) fn string_to_stream(source_str: String) -> TokenStream {\n \n /// Parses a string, returns a crate.\n pub(crate) fn string_to_crate(source_str: String) -> ast::Crate {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n+    let ps = ParseSess::new(\n+        vec![crate::DEFAULT_LOCALE_RESOURCE, rustc_parse::DEFAULT_LOCALE_RESOURCE],\n+        FilePathMapping::empty(),\n+    );\n     with_error_checking_parse(source_str, &ps, |p| p.parse_crate_mod())\n }\n \n@@ -127,8 +133,10 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     create_default_session_if_not_set_then(|_| {\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n-        let fallback_bundle =\n-            rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle(\n+            vec![crate::DEFAULT_LOCALE_RESOURCE, rustc_parse::DEFAULT_LOCALE_RESOURCE],\n+            false,\n+        );\n         let source_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         source_map.new_source_file(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n "}, {"sha": "8c58129c800f8cbc113ba06cd75155f33d2b8e3e", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -124,6 +124,11 @@ pub enum DefKind {\n }\n \n impl DefKind {\n+    /// Get an English description for the item's kind.\n+    ///\n+    /// If you have access to `TyCtxt`, use `TyCtxt::def_descr` or\n+    /// `TyCtxt::def_kind_descr` instead, because they give better\n+    /// information for generators and associated functions.\n     pub fn descr(self, def_id: DefId) -> &'static str {\n         match self {\n             DefKind::Fn => \"function\",\n@@ -166,6 +171,10 @@ impl DefKind {\n     }\n \n     /// Gets an English article for the definition.\n+    ///\n+    /// If you have access to `TyCtxt`, use `TyCtxt::def_descr_article` or\n+    /// `TyCtxt::def_kind_descr_article` instead, because they give better\n+    /// information for generators and associated functions.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             DefKind::AssocTy"}, {"sha": "8ceb176491b6f95d37934f00f2cba89dd721f99f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -280,6 +280,8 @@ pub enum DefPathData {\n     AnonConst,\n     /// An `impl Trait` type node.\n     ImplTrait,\n+    /// `impl Trait` generated associated type node.\n+    ImplTraitAssocTy,\n }\n \n impl Definitions {\n@@ -403,7 +405,7 @@ impl DefPathData {\n             TypeNs(name) | ValueNs(name) | MacroNs(name) | LifetimeNs(name) => Some(name),\n \n             Impl | ForeignMod | CrateRoot | Use | GlobalAsm | ClosureExpr | Ctor | AnonConst\n-            | ImplTrait => None,\n+            | ImplTrait | ImplTraitAssocTy => None,\n         }\n     }\n \n@@ -422,7 +424,7 @@ impl DefPathData {\n             ClosureExpr => DefPathDataName::Anon { namespace: sym::closure },\n             Ctor => DefPathDataName::Anon { namespace: sym::constructor },\n             AnonConst => DefPathDataName::Anon { namespace: sym::constant },\n-            ImplTrait => DefPathDataName::Anon { namespace: sym::opaque },\n+            ImplTrait | ImplTraitAssocTy => DefPathDataName::Anon { namespace: sym::opaque },\n         }\n     }\n }"}, {"sha": "72e9f7c13437e3366e0ecfd8bc16fd3251ac974b", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -369,10 +369,10 @@ impl<'hir> GenericArgs<'hir> {\n \n     pub fn has_err(&self) -> bool {\n         self.args.iter().any(|arg| match arg {\n-            GenericArg::Type(ty) => matches!(ty.kind, TyKind::Err),\n+            GenericArg::Type(ty) => matches!(ty.kind, TyKind::Err(_)),\n             _ => false,\n         }) || self.bindings.iter().any(|arg| match arg.kind {\n-            TypeBindingKind::Equality { term: Term::Ty(ty) } => matches!(ty.kind, TyKind::Err),\n+            TypeBindingKind::Equality { term: Term::Ty(ty) } => matches!(ty.kind, TyKind::Err(_)),\n             _ => false,\n         })\n     }\n@@ -1688,7 +1688,7 @@ impl Expr<'_> {\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n-            ExprKind::Err => ExprPrecedence::Err,\n+            ExprKind::Err(_) => ExprPrecedence::Err,\n         }\n     }\n \n@@ -1754,7 +1754,7 @@ impl Expr<'_> {\n             | ExprKind::Yield(..)\n             | ExprKind::Cast(..)\n             | ExprKind::DropTemps(..)\n-            | ExprKind::Err => false,\n+            | ExprKind::Err(_) => false,\n         }\n     }\n \n@@ -1840,7 +1840,7 @@ impl Expr<'_> {\n             | ExprKind::Binary(..)\n             | ExprKind::Yield(..)\n             | ExprKind::DropTemps(..)\n-            | ExprKind::Err => true,\n+            | ExprKind::Err(_) => true,\n         }\n     }\n \n@@ -2013,7 +2013,7 @@ pub enum ExprKind<'hir> {\n     Yield(&'hir Expr<'hir>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n-    Err,\n+    Err(rustc_span::ErrorGuaranteed),\n }\n \n /// Represents an optionally `Self`-qualified value/type path or associated extension.\n@@ -2676,7 +2676,7 @@ pub enum TyKind<'hir> {\n     /// specified. This can appear anywhere in a type.\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n-    Err,\n+    Err(rustc_span::ErrorGuaranteed),\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "cc0f64017e426d7c78111475e0d7bab4711ecd13", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -790,7 +790,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::Err(_) => {}\n     }\n }\n \n@@ -844,7 +844,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n             visitor.visit_lifetime(lifetime);\n         }\n         TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n-        TyKind::Infer | TyKind::Err => {}\n+        TyKind::Infer | TyKind::Err(_) => {}\n     }\n }\n "}, {"sha": "60fa5a99e103c7296699d5fdf7095fc2ef2bc207", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -302,8 +302,6 @@ language_item_table! {\n     Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n-    FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-\n     OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n     OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n "}, {"sha": "fab16b80fb59ceac7f6298d616fe2d2c415a8d57", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,7 +9,6 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n-tracing = \"0.1\"\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n@@ -27,3 +26,5 @@ rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "50b0816889ba2120dd9c4dd18716301dd9379cb1", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "renamed", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -33,20 +33,7 @@ hir_analysis_field_already_declared =\n     .label = field already declared\n     .previous_decl_label = `{$field_name}` first declared here\n \n-hir_analysis_copy_impl_on_type_with_dtor =\n-    the trait `Copy` may not be implemented for this type; the type has a destructor\n-    .label = `Copy` not allowed on types with destructors\n-\n-hir_analysis_multiple_relaxed_default_bounds =\n-    type parameter has more than one relaxed default bound, only one is supported\n-\n-hir_analysis_copy_impl_on_non_adt =\n-    the trait `Copy` may not be implemented for this type\n-    .label = type is not a structure or enumeration\n-\n-hir_analysis_trait_object_declared_with_no_traits =\n-    at least one trait is required for an object type\n-    .alias_span = this alias does not contain a trait\n+hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n \n hir_analysis_ambiguous_lifetime_bound =\n     ambiguous lifetime bound, explicit lifetime bound required\n@@ -68,6 +55,25 @@ hir_analysis_value_of_associated_struct_already_specified =\n hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n     .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n+hir_analysis_manual_implementation =\n+    manual implementations of `{$trait_name}` are experimental\n+    .label = manual implementations of `{$trait_name}` are experimental\n+    .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n+\n+hir_analysis_unused_extern_crate =\n+    unused extern crate\n+    .suggestion = remove it\n+\n+hir_analysis_extern_crate_not_idiomatic =\n+    `extern crate` is not idiomatic in the new edition\n+    .suggestion = convert it to a `{$msg_code}`\n+\n+hir_analysis_trait_object_declared_with_no_traits =\n+    at least one trait is required for an object type\n+    .alias_span = this alias does not contain a trait\n+\n hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n         [one] parameter\n@@ -90,20 +96,16 @@ hir_analysis_missing_type_params =\n     } to {$parameters}\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n-hir_analysis_manual_implementation =\n-    manual implementations of `{$trait_name}` are experimental\n-    .label = manual implementations of `{$trait_name}` are experimental\n-    .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n-\n-hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n+hir_analysis_copy_impl_on_type_with_dtor =\n+    the trait `Copy` may not be implemented for this type; the type has a destructor\n+    .label = `Copy` not allowed on types with destructors\n \n-hir_analysis_unused_extern_crate =\n-    unused extern crate\n-    .suggestion = remove it\n+hir_analysis_multiple_relaxed_default_bounds =\n+    type parameter has more than one relaxed default bound, only one is supported\n \n-hir_analysis_extern_crate_not_idiomatic =\n-    `extern crate` is not idiomatic in the new edition\n-    .suggestion = convert it to a `{$msg_code}`\n+hir_analysis_copy_impl_on_non_adt =\n+    the trait `Copy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n \n hir_analysis_const_impl_for_non_const_trait =\n     const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n@@ -124,3 +126,32 @@ hir_analysis_linkage_type =\n hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n     .label = deref recursion limit reached\n     .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+hir_analysis_where_clause_on_main = `main` function is not allowed to have a `where` clause\n+    .label = `main` cannot have a `where` clause\n+\n+hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n+    .suggestion = remove this annotation\n+\n+hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n+    .label = `start` is not allowed to be `#[track_caller]`\n+\n+hir_analysis_start_not_async = `start` is not allowed to be `async`\n+    .label = `start` is not allowed to be `async`\n+\n+hir_analysis_start_function_where = start function is not allowed to have a `where` clause\n+    .label = start function cannot have a `where` clause\n+\n+hir_analysis_start_function_parameters = start function is not allowed to have type parameters\n+    .label = start function cannot have type parameters\n+\n+hir_analysis_main_function_return_type_generic = `main` function return type is not allowed to have generic parameters\n+\n+hir_analysis_main_function_async = `main` function is not allowed to be `async`\n+    .label = `main` function is not allowed to be `async`\n+\n+hir_analysis_main_function_generic_parameters = `main` function is not allowed to have generic parameters\n+    .label = `main` cannot have generic parameters\n+\n+hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n+    .label = C-variadic function must have a compatible calling convention", "previous_filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl"}, {"sha": "c49e4d9d5818e35d1eac2e6eb9d6a8fcba366ab7", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -304,10 +304,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if let Some(did) = adt_did {\n                 err.span_label(\n                     tcx.def_span(did),\n-                    format!(\n-                        \"associated item `{name}` not found for this {}\",\n-                        tcx.def_kind(did).descr(did)\n-                    ),\n+                    format!(\"associated item `{name}` not found for this {}\", tcx.def_descr(did)),\n                 );\n             }\n         };\n@@ -380,7 +377,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     // `<Foo as Iterator>::Item = String`.\n                     let projection_ty = pred.skip_binder().projection_ty;\n \n-                    let substs_with_infer_self = tcx.mk_substs(\n+                    let substs_with_infer_self = tcx.mk_substs_from_iter(\n                         std::iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n                             .chain(projection_ty.substs.iter().skip(1)),\n                     );"}, {"sha": "7f6518ffd7148bee6eba65e5c6018496e9046afb", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -370,7 +370,7 @@ pub fn create_substs_for_generic_args<'tcx, 'a>(\n         }\n     }\n \n-    tcx.intern_substs(&substs)\n+    tcx.mk_substs(&substs)\n }\n \n /// Checks that the correct number of generic arguments have been provided."}, {"sha": "a15cf454df72f30ead7aabfafb1f3fe92611e90b", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -35,7 +35,7 @@ use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n-use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n@@ -381,7 +381,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // here and so associated type bindings will be handled regardless of whether there are any\n         // non-`Self` generic parameters.\n         if generics.params.is_empty() {\n-            return (tcx.intern_substs(parent_substs), arg_count);\n+            return (tcx.mk_substs(parent_substs), arg_count);\n         }\n \n         struct SubstsForAstPathCtxt<'a, 'tcx> {\n@@ -429,7 +429,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     if let (hir::TyKind::Infer, false) = (&ty.kind, self.astconv.allow_ty_infer()) {\n                         self.inferred_params.push(ty.span);\n-                        tcx.ty_error().into()\n+                        tcx.ty_error_misc().into()\n                     } else {\n                         self.astconv.ast_ty_to_ty(ty).into()\n                     }\n@@ -502,14 +502,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 _ => false,\n                             }) {\n                                 // Avoid ICE #86756 when type error recovery goes awry.\n-                                return tcx.ty_error().into();\n+                                return tcx.ty_error_misc().into();\n                             }\n                             tcx.at(self.span).type_of(param.def_id).subst(tcx, substs).into()\n                         } else if infer_args {\n                             self.astconv.ty_infer(Some(param), self.span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            tcx.ty_error().into()\n+                            tcx.ty_error_misc().into()\n                         }\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n@@ -518,8 +518,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .type_of(param.def_id)\n                             .no_bound_vars()\n                             .expect(\"const parameter types cannot be generic\");\n-                        if ty.references_error() {\n-                            return tcx.const_error(ty).into();\n+                        if let Err(guar) = ty.error_reported() {\n+                            return tcx.const_error_with_guaranteed(ty, guar).into();\n                         }\n                         if !infer_args && has_default {\n                             tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n@@ -1217,7 +1217,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     | (hir::def::DefKind::AssocConst, ty::TermKind::Const(_)) => (),\n                     (_, _) => {\n                         let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n-                        let expected = def_kind.descr(assoc_item_def_id);\n+                        let expected = tcx.def_descr(assoc_item_def_id);\n                         let mut err = tcx.sess.struct_span_err(\n                             binding.span,\n                             &format!(\"expected {expected} bound, found {got}\"),\n@@ -1239,9 +1239,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         }\n                         let reported = err.emit();\n                         term = match def_kind {\n-                            hir::def::DefKind::AssocTy => {\n-                                tcx.ty_error_with_guaranteed(reported).into()\n-                            }\n+                            hir::def::DefKind::AssocTy => tcx.ty_error(reported).into(),\n                             hir::def::DefKind::AssocConst => tcx\n                                 .const_error_with_guaranteed(\n                                     tcx.type_of(assoc_item_def_id)\n@@ -1397,7 +1395,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .map(|trait_ref| tcx.def_span(trait_ref));\n             let reported =\n                 tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span, trait_alias_span });\n-            return tcx.ty_error_with_guaranteed(reported);\n+            return tcx.ty_error(reported);\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1414,7 +1412,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &object_safety_violations,\n                 )\n                 .emit();\n-                return tcx.ty_error_with_guaranteed(reported);\n+                return tcx.ty_error(reported);\n             }\n         }\n \n@@ -1523,15 +1521,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         if arg == dummy_self.into() {\n                             let param = &generics.params[index];\n                             missing_type_params.push(param.name);\n-                            return tcx.ty_error().into();\n+                            return tcx.ty_error_misc().into();\n                         } else if arg.walk().any(|arg| arg == dummy_self.into()) {\n                             references_self = true;\n-                            return tcx.ty_error().into();\n+                            return tcx.ty_error_misc().into();\n                         }\n                         arg\n                     })\n                     .collect();\n-                let substs = tcx.intern_substs(&substs[..]);\n+                let substs = tcx.mk_substs(&substs);\n \n                 let span = i.bottom().1;\n                 let empty_generic_args = hir_trait_bounds.iter().any(|hir_bound| {\n@@ -1552,7 +1550,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         i.bottom().1,\n                         E0038,\n                         \"the {} `{}` cannot be made into an object\",\n-                        tcx.def_kind(def_id).descr(def_id),\n+                        tcx.def_descr(def_id),\n                         tcx.item_name(def_id),\n                     );\n                     err.note(\n@@ -1579,20 +1577,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     false\n                 });\n                 if references_self {\n-                    tcx.sess\n+                    let guar = tcx\n+                        .sess\n                         .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n                     let substs: Vec<_> = b\n                         .projection_ty\n                         .substs\n                         .iter()\n                         .map(|arg| {\n                             if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                                return tcx.ty_error().into();\n+                                return tcx.ty_error(guar).into();\n                             }\n                             arg\n                         })\n                         .collect();\n-                    b.projection_ty.substs = tcx.intern_substs(&substs[..]);\n+                    b.projection_ty.substs = tcx.mk_substs(&substs);\n                 }\n \n                 ty::ExistentialProjection::erase_self_ty(tcx, b)\n@@ -1614,7 +1613,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));\n         v.dedup();\n-        let existential_predicates = tcx.intern_poly_existential_predicates(&v);\n+        let existential_predicates = tcx.mk_poly_existential_predicates(&v);\n \n         // Use explicitly-specified region bound.\n         let region_bound = if !lifetime.is_elided() {\n@@ -2174,7 +2173,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             \"`{}` could{} refer to the {} defined here\",\n                             assoc_ident,\n                             also,\n-                            kind.descr(def_id)\n+                            tcx.def_kind_descr(kind, def_id)\n                         );\n                         lint.span_note(tcx.def_span(def_id), &note_msg);\n                     };\n@@ -2350,7 +2349,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let kind = DefKind::AssocTy;\n \n         if !tcx.visibility(item).is_accessible_from(def_scope, tcx) {\n-            let kind = kind.descr(item);\n+            let kind = tcx.def_kind_descr(kind, item);\n             let msg = format!(\"{kind} `{name}` is private\");\n             let def_span = tcx.def_span(item);\n             tcx.sess\n@@ -2473,7 +2472,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 &[path_str],\n                 item_segment.ident.name,\n             );\n-            return tcx.ty_error_with_guaranteed(reported)\n+            return tcx.ty_error(reported)\n         };\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n@@ -2811,7 +2810,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             var: ty::BoundVar::from_u32(index),\n                             kind: ty::BoundTyKind::Param(def_id, name),\n                         };\n-                        tcx.mk_ty(ty::Bound(debruijn, br))\n+                        tcx.mk_bound(debruijn, br)\n                     }\n                     Some(rbv::ResolvedArg::EarlyBound(_)) => {\n                         let def_id = def_id.expect_local();\n@@ -2820,7 +2819,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n                         tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n                     }\n-                    Some(rbv::ResolvedArg::Error(guar)) => tcx.ty_error_with_guaranteed(guar),\n+                    Some(rbv::ResolvedArg::Error(guar)) => tcx.ty_error(guar),\n                     arg => bug!(\"unexpected bound var resolution for {hir_id:?}: {arg:?}\"),\n                 }\n             }\n@@ -2932,7 +2931,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     {\n                         err.span_note(impl_.self_ty.span, \"not a concrete type\");\n                     }\n-                    tcx.ty_error_with_guaranteed(err.emit())\n+                    tcx.ty_error(err.emit())\n                 } else {\n                     ty\n                 }\n@@ -2985,7 +2984,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .sess\n                     .delay_span_bug(path.span, \"path with `Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n-                self.tcx().ty_error_with_guaranteed(e)\n+                self.tcx().ty_error(e)\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }\n@@ -3021,7 +3020,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_ref(r, ty::TypeAndMut { ty: t, mutbl: mt.mutbl })\n             }\n             hir::TyKind::Never => tcx.types.never,\n-            hir::TyKind::Tup(fields) => tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(t))),\n+            hir::TyKind::Tup(fields) => {\n+                tcx.mk_tup_from_iter(fields.iter().map(|t| self.ast_ty_to_ty(t)))\n+            }\n             hir::TyKind::BareFn(bf) => {\n                 require_c_abi_if_c_variadic(tcx, bf.decl, bf.abi, ast_ty.span);\n \n@@ -3064,7 +3065,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n-                    .unwrap_or_else(|_| tcx.ty_error())\n+                    .unwrap_or_else(|guar| tcx.ty_error(guar))\n             }\n             &hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n@@ -3112,7 +3113,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)\n             }\n-            hir::TyKind::Err => tcx.ty_error(),\n+            hir::TyKind::Err(guar) => tcx.ty_error(*guar),\n         };\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);"}, {"sha": "ba2d4319af6e20b2918f3b3117d61c74280baa89", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,7 +3,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::NormalizeExt;\n use crate::traits::{self, TraitEngine, TraitEngineExt};\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::TypeVisitable;\n+use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::Limit;\n use rustc_span::def_id::LocalDefId;"}, {"sha": "4ea471f8f05532475bd28ef366c29370061a9956", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -23,6 +23,7 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n use rustc_middle::ty::{\n     self, AdtDef, DefIdTree, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt,\n };\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n@@ -255,7 +256,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         selftys: Vec<(Span, Option<String>)>,\n     }\n \n-    impl<'tcx> ty::visit::ir::TypeVisitor<TyCtxt<'tcx>> for ProhibitOpaqueVisitor<'tcx> {\n+    impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for ProhibitOpaqueVisitor<'tcx> {\n         type BreakTy = Ty<'tcx>;\n \n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -1418,7 +1419,7 @@ fn opaque_type_cycle_error(\n                     opaques: Vec<DefId>,\n                     closures: Vec<DefId>,\n                 }\n-                impl<'tcx> ty::visit::ir::TypeVisitor<TyCtxt<'tcx>> for OpaqueTypeCollector {\n+                impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n                             ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n@@ -1460,7 +1461,7 @@ fn opaque_type_cycle_error(\n                                     span,\n                                     format!(\n                                         \"{} captures itself here\",\n-                                        tcx.def_kind(closure_def_id).descr(closure_def_id)\n+                                        tcx.def_descr(closure_def_id)\n                                     ),\n                                 );\n                             }"}, {"sha": "89b4e6227bd616b1ca6693ba62a34229961b6dfa", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,7 +16,8 @@ use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n use rustc_middle::ty::{\n-    self, ir::TypeFolder, DefIdTree, InternalSubsts, Ty, TypeFoldable, TypeSuperFoldable,\n+    self, DefIdTree, InternalSubsts, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitableExt,\n };\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n@@ -195,7 +196,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_def_id);\n     let param_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&hybrid_preds.predicates),\n+        tcx.mk_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n         hir::Constness::NotConst,\n     );\n@@ -789,7 +790,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, tcx.ty_error_with_guaranteed(reported));\n+                collected_tys.insert(def_id, tcx.ty_error(reported));\n             }\n         }\n     }\n@@ -1794,7 +1795,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     let impl_ty_span = tcx.def_span(impl_ty_def_id);\n     let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_def_id);\n     let param_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&hybrid_preds.predicates),\n+        tcx.mk_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n         hir::Constness::NotConst,\n     );\n@@ -1936,8 +1937,8 @@ pub(super) fn check_type_bounds<'tcx>(\n             .into()\n         }\n     });\n-    let bound_vars = tcx.intern_bound_variable_kinds(&bound_vars);\n-    let impl_ty_substs = tcx.intern_substs(&substs);\n+    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n+    let impl_ty_substs = tcx.mk_substs(&substs);\n     let container_id = impl_ty.container_id(tcx);\n \n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n@@ -1977,11 +1978,7 @@ pub(super) fn check_type_bounds<'tcx>(\n                 .to_predicate(tcx),\n             ),\n         };\n-        ty::ParamEnv::new(\n-            tcx.intern_predicates(&predicates),\n-            Reveal::UserFacing,\n-            param_env.constness(),\n-        )\n+        ty::ParamEnv::new(tcx.mk_predicates(&predicates), Reveal::UserFacing, param_env.constness())\n     };\n     debug!(?normalize_param_env);\n "}, {"sha": "2bb724138f584a36f2da5a5d1dd43558e7219c0e", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -71,7 +71,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n     let drop_impl_span = tcx.def_span(drop_impl_did);\n     let item_span = tcx.def_span(self_type_did);\n-    let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n+    let self_descr = tcx.def_descr(self_type_did);\n     let mut err =\n         struct_span_err!(tcx.sess, drop_impl_span, E0366, \"`Drop` impls cannot be specialized\");\n     match arg {\n@@ -217,7 +217,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n             let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_kind(self_type_did).descr(self_type_did.to_def_id());\n+            let self_descr = tcx.def_descr(self_type_did.to_def_id());\n             let reported = struct_span_err!(\n                 tcx.sess,\n                 predicate_sp,"}, {"sha": "054284cced5adb85a36d507fa9edccc475b250ec", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -137,7 +137,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let intrinsic_name = tcx.item_name(intrinsic_id);\n     let name_str = intrinsic_name.as_str();\n \n-    let bound_vars = tcx.intern_bound_variable_kinds(&[\n+    let bound_vars = tcx.mk_bound_variable_kinds(&[\n         ty::BoundVariableKind::Region(ty::BrAnon(0, None)),\n         ty::BoundVariableKind::Region(ty::BrEnv),\n     ]);\n@@ -165,7 +165,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             \"cxchg\" | \"cxchgweak\" => (\n                 1,\n                 vec![tcx.mk_mut_ptr(param(0)), param(0), param(0)],\n-                tcx.intern_tup(&[param(0), tcx.types.bool]),\n+                tcx.mk_tup(&[param(0), tcx.types.bool]),\n             ),\n             \"load\" => (1, vec![tcx.mk_imm_ptr(param(0))], param(0)),\n             \"store\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n@@ -317,7 +317,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             | sym::bitreverse => (1, vec![param(0)], param(0)),\n \n             sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n+                (1, vec![param(0), param(0)], tcx.mk_tup(&[param(0), tcx.types.bool]))\n             }\n \n             sym::ptr_guaranteed_cmp => {\n@@ -372,7 +372,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 (\n                     1,\n                     vec![tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0))],\n-                    tcx.mk_projection(discriminant_def_id, tcx.intern_substs(&[param(0).into()])),\n+                    tcx.mk_projection(discriminant_def_id, tcx.mk_substs(&[param(0).into()])),\n                 )\n             }\n "}, {"sha": "b1d5a27be9397dee6ff0f37cfdde09296ebe8f00", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n+use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitableExt, UintTy};\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{Symbol, DUMMY_SP};"}, {"sha": "4cccdf30c5fa6c16967a904257e8fae4ed4e8639", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 59, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,8 +16,8 @@ use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n-    self, ir::TypeVisitor, AdtKind, DefIdTree, GenericParamDefKind, Ty, TyCtxt, TypeFoldable,\n-    TypeSuperVisitable,\n+    self, AdtKind, GenericParamDefKind, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n+    TypeVisitable, TypeVisitableExt, TypeVisitor,\n };\n use rustc_middle::ty::{GenericArgKind, InternalSubsts};\n use rustc_session::parse::feature_err;\n@@ -56,7 +56,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n     // `ObligationCtxt::normalize`, but provides a nice `ObligationCauseCode`.\n     fn normalize<T>(&self, span: Span, loc: Option<WellFormedLoc>, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.ocx.normalize(\n             &ObligationCause::new(span, self.body_def_id, ObligationCauseCode::WellFormed(loc)),\n@@ -277,56 +277,6 @@ fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n     };\n     check_object_unsafe_self_trait_by_name(tcx, trait_item);\n     check_associated_item(tcx, def_id, span, method_sig);\n-\n-    let encl_trait_def_id = tcx.local_parent(def_id);\n-    let encl_trait = tcx.hir().expect_item(encl_trait_def_id);\n-    let encl_trait_def_id = encl_trait.owner_id.to_def_id();\n-    let fn_lang_item_name = if Some(encl_trait_def_id) == tcx.lang_items().fn_trait() {\n-        Some(\"fn\")\n-    } else if Some(encl_trait_def_id) == tcx.lang_items().fn_mut_trait() {\n-        Some(\"fn_mut\")\n-    } else {\n-        None\n-    };\n-\n-    if let (Some(fn_lang_item_name), \"call\") =\n-        (fn_lang_item_name, trait_item.ident.name.to_ident_string().as_str())\n-    {\n-        // We are looking at the `call` function of the `fn` or `fn_mut` lang item.\n-        // Do some rudimentary sanity checking to avoid an ICE later (issue #83471).\n-        if let Some(hir::FnSig { decl, span, .. }) = method_sig {\n-            if let [self_ty, _] = decl.inputs {\n-                if !matches!(self_ty.kind, hir::TyKind::Ref(_, _)) {\n-                    tcx.sess\n-                        .struct_span_err(\n-                            self_ty.span,\n-                            &format!(\n-                                \"first argument of `call` in `{fn_lang_item_name}` lang item must be a reference\",\n-                            ),\n-                        )\n-                        .emit();\n-                }\n-            } else {\n-                tcx.sess\n-                    .struct_span_err(\n-                        *span,\n-                        &format!(\n-                            \"`call` function in `{fn_lang_item_name}` lang item takes exactly two arguments\",\n-                        ),\n-                    )\n-                    .emit();\n-            }\n-        } else {\n-            tcx.sess\n-                .struct_span_err(\n-                    trait_item.span,\n-                    &format!(\n-                        \"`call` trait item in `{fn_lang_item_name}` lang item must be a function\",\n-                    ),\n-                )\n-                .emit();\n-        }\n-    }\n }\n \n /// Require that the user writes where clauses on GATs for the implicit\n@@ -543,8 +493,9 @@ fn augment_param_env<'tcx>(\n         return param_env;\n     }\n \n-    let bounds =\n-        tcx.mk_predicates(param_env.caller_bounds().iter().chain(new_predicates.iter().cloned()));\n+    let bounds = tcx.mk_predicates_from_iter(\n+        param_env.caller_bounds().iter().chain(new_predicates.iter().cloned()),\n+    );\n     // FIXME(compiler-errors): Perhaps there is a case where we need to normalize this\n     // i.e. traits::normalize_param_env_or_error\n     ty::ParamEnv::new(bounds, param_env.reveal(), param_env.constness())\n@@ -560,7 +511,7 @@ fn augment_param_env<'tcx>(\n ///     fn into_iter<'a>(&'a self) -> Self::Iter<'a>;\n /// }\n /// ```\n-fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n+fn gather_gat_bounds<'tcx, T: TypeFoldable<TyCtxt<'tcx>>>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     item_def_id: hir::OwnerId,\n@@ -758,7 +709,7 @@ struct GATSubstCollector<'tcx> {\n }\n \n impl<'tcx> GATSubstCollector<'tcx> {\n-    fn visit<T: TypeFoldable<'tcx>>(\n+    fn visit<T: TypeFoldable<TyCtxt<'tcx>>>(\n         gat: DefId,\n         t: T,\n     ) -> (FxHashSet<(ty::Region<'tcx>, usize)>, FxHashSet<(Ty<'tcx>, usize)>) {\n@@ -1432,7 +1383,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             struct CountParams {\n                 params: FxHashSet<u32>,\n             }\n-            impl<'tcx> ty::visit::ir::TypeVisitor<TyCtxt<'tcx>> for CountParams {\n+            impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for CountParams {\n                 type BreakTy = ();\n \n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -1526,7 +1477,7 @@ fn check_fn_or_method<'tcx>(\n         |idx| hir_decl.inputs.get(idx).map_or(hir_decl.output.span(), |arg: &hir::Ty<'_>| arg.span);\n \n     sig.inputs_and_output =\n-        tcx.mk_type_list(sig.inputs_and_output.iter().enumerate().map(|(idx, ty)| {\n+        tcx.mk_type_list_from_iter(sig.inputs_and_output.iter().enumerate().map(|(idx, ty)| {\n             wfcx.normalize(\n                 arg_span(idx),\n                 Some(WellFormedLoc::Param {"}, {"sha": "875c5f1fd00430c02ca623f05fda8d45c1644dbd", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::infer::{self, RegionResolutionError};\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n-use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{\n     type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,"}, {"sha": "23490bc091c1c75496322f8f4f862dbfaab85d4b", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -8,7 +8,7 @@\n use rustc_errors::{error_code, struct_span_err};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n use rustc_span::sym;\n use rustc_trait_selection::traits;\n "}, {"sha": "1f2de3f21f8d9c6aa1ad51be400d8229ebedb3a5", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -8,7 +8,8 @@ use rustc_hir as hir;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n-    self, ir::TypeVisitor, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+    self, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n+    TypeVisitor,\n };\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -531,7 +532,7 @@ fn lint_auto_trait_impl<'tcx>(\n         }),\n         |lint| {\n             let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n+            let self_descr = tcx.def_descr(self_type_did);\n             match arg {\n                 ty::util::NotUniqueParam::DuplicateParam(arg) => {\n                     lint.note(&format!(\"`{}` is mentioned multiple times\", arg));"}, {"sha": "604d54cafb5323e13d882e33ae689e0fdccd98e0", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 }\n                 _ => {}\n             }\n-            self.tcx().ty_error_with_guaranteed(err.emit())\n+            self.tcx().ty_error(err.emit())\n         }\n     }\n \n@@ -905,7 +905,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n         }\n         _ => bug!(),\n     };\n-    tcx.alloc_adt_def(def_id.to_def_id(), kind, variants, repr)\n+    tcx.mk_adt_def(def_id.to_def_id(), kind, variants, repr)\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {"}, {"sha": "9cf3ff65a91cab6fe4d57a5519739a21afd2f23a", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -103,7 +103,7 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates(\n+    let bounds = tcx.mk_predicates_from_iter(\n         util::elaborate_predicates(\n             tcx,\n             tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),"}, {"sha": "6c00b8ff7bdeed3ce74cb6524eb4c03e475aed3e", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -17,7 +17,8 @@ use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeNa\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_bound_vars::*;\n-use rustc_middle::ty::{self, ir::TypeVisitor, DefIdTree, TyCtxt, TypeSuperVisitable};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt, TypeSuperVisitable, TypeVisitor};\n+use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -923,17 +924,16 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-\n                         let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                             bound_generic_params\n-                            .iter()\n-                            .enumerate()\n-                            .map(|(late_bound_idx, param)| {\n-                                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n-                                let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n-                                (pair, r)\n-                            })\n-                            .unzip();\n+                                .iter()\n+                                .enumerate()\n+                                .map(|(late_bound_idx, param)| {\n+                                    let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                                    let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n+                                    (pair, r)\n+                                })\n+                                .unzip();\n                         this.record_late_bound_vars(hir_id, binders.clone());\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n@@ -968,20 +968,22 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                                     continue;\n                                 }\n                                 this.insert_lifetime(lt, ResolvedArg::StaticLifetime);\n-                                this.tcx\n-                                    .sess\n-                                    .struct_span_warn(\n-                                        lifetime.ident.span,\n-                                        &format!(\n-                                            \"unnecessary lifetime parameter `{}`\",\n+                                this.tcx.struct_span_lint_hir(\n+                                    lint::builtin::UNUSED_LIFETIMES,\n+                                    lifetime.hir_id,\n+                                    lifetime.ident.span,\n+                                    format!(\n+                                        \"unnecessary lifetime parameter `{}`\",\n+                                        lifetime.ident\n+                                    ),\n+                                    |lint| {\n+                                        let help = &format!(\n+                                            \"you can use the `'static` lifetime directly, in place of `{}`\",\n                                             lifetime.ident,\n-                                        ),\n-                                    )\n-                                    .help(&format!(\n-                                        \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                        lifetime.ident,\n-                                    ))\n-                                    .emit();\n+                                        );\n+                                        lint.help(help)\n+                                    },\n+                                );\n                             }\n                         }\n                     }"}, {"sha": "50073d94ea5c975a3fe84372c950f73cd369bf0c", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{\n-    self, ir::TypeFolder, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeSuperFoldable, TypeVisitable,\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n@@ -319,8 +319,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                 ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n                     match self_ty.find_self_aliases() {\n                         spans if spans.len() > 0 => {\n-                            tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: (), });\n-                            tcx.ty_error()\n+                            let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: () });\n+                            tcx.ty_error(guar)\n                         },\n                         _ => icx.to_ty(*self_ty),\n                     }\n@@ -599,8 +599,9 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n             // // constant does not contain interior mutability.\n             // ```\n             let tables = self.tcx.typeck(item_def_id);\n-            if let Some(_) = tables.tainted_by_errors {\n-                self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error() });\n+            if let Some(guar) = tables.tainted_by_errors {\n+                self.found =\n+                    Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n                 return;\n             }\n             let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n@@ -618,8 +619,8 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 debug!(?concrete_type, \"found constraint\");\n                 if let Some(prev) = &mut self.found {\n                     if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        prev.report_mismatch(&concrete_type, self.tcx);\n-                        prev.ty = self.tcx.ty_error();\n+                        let guar = prev.report_mismatch(&concrete_type, self.tcx);\n+                        prev.ty = self.tcx.ty_error(guar);\n                     }\n                 } else {\n                     self.found = Some(concrete_type);\n@@ -706,7 +707,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error_with_guaranteed(reported);\n+        return tcx.ty_error(reported);\n     };\n \n     // Only check against typeck if we didn't already error\n@@ -814,11 +815,11 @@ fn find_opaque_ty_constraints_for_rpit(\n \n     concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n         let table = tcx.typeck(owner_def_id);\n-        if let Some(_) = table.tainted_by_errors {\n+        if let Some(guar) = table.tainted_by_errors {\n             // Some error in the\n             // owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n-            tcx.ty_error()\n+            tcx.ty_error(guar)\n         } else {\n             table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n                 // We failed to resolve the opaque type or it"}, {"sha": "e18b0f082798b3f661fa256fb2384ba7357d8a54", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_middle::ty::visit::{ir::TypeVisitor, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::source_map::Span;\n use std::ops::ControlFlow;\n@@ -43,7 +43,7 @@ pub fn parameters_for_impl<'tcx>(\n /// of parameters whose values are needed in order to constrain `ty` - these\n /// differ, with the latter being a superset, in the presence of projections.\n pub fn parameters_for<'tcx>(\n-    t: &impl TypeVisitable<'tcx>,\n+    t: &impl TypeVisitable<TyCtxt<'tcx>>,\n     include_nonconstraining: bool,\n ) -> Vec<Parameter> {\n     let mut collector = ParameterCollector { parameters: vec![], include_nonconstraining };"}, {"sha": "a566e73912e4586a68874dca1a940d6525174050", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 104, "deletions": 15, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,7 +1,10 @@\n //! Errors emitted by `rustc_hir_analysis`.\n \n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n-use rustc_errors::{IntoDiagnostic, MultiSpan};\n+use crate::fluent_generated as fluent;\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    MultiSpan,\n+};\n use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n@@ -41,11 +44,11 @@ pub struct LifetimesOrBoundsMismatchOnTrait {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(generics_label)]\n+    #[label(hir_analysis_generics_label)]\n     pub generics_span: Option<Span>,\n-    #[label(where_label)]\n+    #[label(hir_analysis_where_label)]\n     pub where_span: Option<Span>,\n-    #[label(bounds_label)]\n+    #[label(hir_analysis_bounds_label)]\n     pub bounds_span: Vec<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n@@ -57,7 +60,7 @@ pub struct AsyncTraitImplShouldBeAsync {\n     #[primary_span]\n     // #[label]\n     pub span: Span,\n-    #[label(trait_item_label)]\n+    #[label(hir_analysis_trait_item_label)]\n     pub trait_item_span: Option<Span>,\n     pub method_name: Symbol,\n }\n@@ -77,7 +80,7 @@ pub struct FieldAlreadyDeclared {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(previous_decl_label)]\n+    #[label(hir_analysis_previous_decl_label)]\n     pub prev_span: Span,\n }\n \n@@ -109,7 +112,7 @@ pub struct CopyImplOnNonAdt {\n pub struct TraitObjectDeclaredWithNoTraits {\n     #[primary_span]\n     pub span: Span,\n-    #[label(alias_span)]\n+    #[label(hir_analysis_alias_span)]\n     pub trait_alias_span: Option<Span>,\n }\n \n@@ -145,7 +148,7 @@ pub struct ValueOfAssociatedStructAlreadySpecified {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(previous_bound_label)]\n+    #[label(hir_analysis_previous_bound_label)]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n@@ -175,7 +178,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::hir_analysis_missing_type_params,\n+            fluent::hir_analysis_missing_type_params,\n             error_code!(E0393),\n         );\n         err.set_arg(\"parameterCount\", self.missing_type_params.len());\n@@ -188,7 +191,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 .join(\", \"),\n         );\n \n-        err.span_label(self.def_span, rustc_errors::fluent::label);\n+        err.span_label(self.def_span, fluent::hir_analysis_label);\n \n         let mut suggested = false;\n         // Don't suggest setting the type params if there are some already: the order is\n@@ -203,7 +206,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 // least we can clue them to the correct syntax `Iterator<Type>`.\n                 err.span_suggestion(\n                     self.span,\n-                    rustc_errors::fluent::suggestion,\n+                    fluent::hir_analysis_suggestion,\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n@@ -219,10 +222,10 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n             }\n         }\n         if !suggested {\n-            err.span_label(self.span, rustc_errors::fluent::no_suggestion_label);\n+            err.span_label(self.span, fluent::hir_analysis_no_suggestion_label);\n         }\n \n-        err.note(rustc_errors::fluent::note);\n+        err.note(fluent::hir_analysis_note);\n         err\n     }\n }\n@@ -274,7 +277,7 @@ pub struct ConstImplForNonConstTrait {\n     pub local_trait_span: Option<Span>,\n     #[note]\n     pub marking: (),\n-    #[note(adding)]\n+    #[note(hir_analysis_adding)]\n     pub adding: (),\n }\n \n@@ -312,3 +315,89 @@ pub struct AutoDerefReachedRecursionLimit<'a> {\n     pub suggested_limit: rustc_session::Limit,\n     pub crate_name: Symbol,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_where_clause_on_main, code = \"E0646\")]\n+pub(crate) struct WhereClauseOnMain {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub generics_span: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_track_caller_on_main)]\n+pub(crate) struct TrackCallerOnMain {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"\")]\n+    pub span: Span,\n+    #[label(hir_analysis_track_caller_on_main)]\n+    pub annotated: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_not_track_caller)]\n+pub(crate) struct StartTrackCaller {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_not_async, code = \"E0752\")]\n+pub(crate) struct StartAsync {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_function_where, code = \"E0647\")]\n+pub(crate) struct StartFunctionWhere {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_function_parameters, code = \"E0132\")]\n+pub(crate) struct StartFunctionParameters {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_main_function_return_type_generic, code = \"E0131\")]\n+pub(crate) struct MainFunctionReturnTypeGeneric {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_main_function_async, code = \"E0752\")]\n+pub(crate) struct MainFunctionAsync {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub asyncness: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_main_function_generic_parameters, code = \"E0131\")]\n+pub(crate) struct MainFunctionGenericParameters {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub label_span: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_variadic_function_compatible_convention, code = \"E0045\")]\n+pub(crate) struct VariadicFunctionCompatibleConvention<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub conventions: &'a str,\n+}"}, {"sha": "e330fcc785770e632284e6649c56051e14cf7a71", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::{ForeignItem, ForeignItemKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, ir::TypeFolder, Region, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, Region, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::def_id::LocalDefId;\n use rustc_trait_selection::traits;\n "}, {"sha": "82a96f8e67408582d0b7b1834b422a527abb009e", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,7 +16,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n use rustc_span::{Span, Symbol};\n \n mod min_specialization;"}, {"sha": "daa5d15704d878bb1af381400eac0bb108a60e80", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -76,7 +76,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::specialization_graph::Node;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;"}, {"sha": "33c132fd5349bc4e61abf1daf5808cc99bb743e9", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 26, "deletions": 77, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -98,10 +98,12 @@ mod outlives;\n pub mod structured_errors;\n mod variance;\n \n-use rustc_errors::{struct_span_err, ErrorGuaranteed};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -118,8 +120,9 @@ use std::ops::Not;\n use astconv::AstConv;\n use bounds::Bounds;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n-    const ERROR_HEAD: &str = \"C-variadic function must have a compatible calling convention\";\n     const CONVENTIONS_UNSTABLE: &str = \"`C`, `cdecl`, `win64`, `sysv64` or `efiapi`\";\n     const CONVENTIONS_STABLE: &str = \"`C` or `cdecl`\";\n     const UNSTABLE_EXPLAIN: &str =\n@@ -151,8 +154,7 @@ fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi\n         (true, false) => CONVENTIONS_UNSTABLE,\n     };\n \n-    let mut err = struct_span_err!(tcx.sess, span, E0045, \"{}, like {}\", ERROR_HEAD, conventions);\n-    err.span_label(span, ERROR_HEAD).emit();\n+    tcx.sess.emit_err(errors::VariadicFunctionCompatibleConvention { span, conventions });\n }\n \n fn require_same_types<'tcx>(\n@@ -254,53 +256,30 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     let main_fn_predicates = tcx.predicates_of(main_def_id);\n     if main_fn_generics.count() != 0 || !main_fnsig.bound_vars().is_empty() {\n         let generics_param_span = main_fn_generics_params_span(tcx, main_def_id);\n-        let msg = \"`main` function is not allowed to have generic \\\n-            parameters\";\n-        let mut diag =\n-            struct_span_err!(tcx.sess, generics_param_span.unwrap_or(main_span), E0131, \"{}\", msg);\n-        if let Some(generics_param_span) = generics_param_span {\n-            let label = \"`main` cannot have generic parameters\";\n-            diag.span_label(generics_param_span, label);\n-        }\n-        diag.emit();\n+        tcx.sess.emit_err(errors::MainFunctionGenericParameters {\n+            span: generics_param_span.unwrap_or(main_span),\n+            label_span: generics_param_span,\n+        });\n         error = true;\n     } else if !main_fn_predicates.predicates.is_empty() {\n         // generics may bring in implicit predicates, so we skip this check if generics is present.\n         let generics_where_clauses_span = main_fn_where_clauses_span(tcx, main_def_id);\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            generics_where_clauses_span.unwrap_or(main_span),\n-            E0646,\n-            \"`main` function is not allowed to have a `where` clause\"\n-        );\n-        if let Some(generics_where_clauses_span) = generics_where_clauses_span {\n-            diag.span_label(generics_where_clauses_span, \"`main` cannot have a `where` clause\");\n-        }\n-        diag.emit();\n+        tcx.sess.emit_err(errors::WhereClauseOnMain {\n+            span: generics_where_clauses_span.unwrap_or(main_span),\n+            generics_span: generics_where_clauses_span,\n+        });\n         error = true;\n     }\n \n     let main_asyncness = tcx.asyncness(main_def_id);\n     if let hir::IsAsync::Async = main_asyncness {\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            main_span,\n-            E0752,\n-            \"`main` function is not allowed to be `async`\"\n-        );\n         let asyncness_span = main_fn_asyncness_span(tcx, main_def_id);\n-        if let Some(asyncness_span) = asyncness_span {\n-            diag.span_label(asyncness_span, \"`main` function is not allowed to be `async`\");\n-        }\n-        diag.emit();\n+        tcx.sess.emit_err(errors::MainFunctionAsync { span: main_span, asyncness: asyncness_span });\n         error = true;\n     }\n \n     for attr in tcx.get_attrs(main_def_id, sym::track_caller) {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"`main` function is not allowed to be `#[track_caller]`\")\n-            .span_label(main_span, \"`main` function is not allowed to be `#[track_caller]`\")\n-            .emit();\n+        tcx.sess.emit_err(errors::TrackCallerOnMain { span: attr.span, annotated: main_span });\n         error = true;\n     }\n \n@@ -313,9 +292,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let return_ty = main_fnsig.output();\n         let return_ty_span = main_fn_return_type_span(tcx, main_def_id).unwrap_or(main_span);\n         if !return_ty.bound_vars().is_empty() {\n-            let msg = \"`main` function return type is not allowed to have generic \\\n-                    parameters\";\n-            struct_span_err!(tcx.sess, return_ty_span, E0131, \"{}\", msg).emit();\n+            tcx.sess.emit_err(errors::MainFunctionReturnTypeGeneric { span: return_ty_span });\n             error = true;\n         }\n         let return_ty = return_ty.skip_binder();\n@@ -372,56 +349,28 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                 if let hir::ItemKind::Fn(sig, generics, _) = &it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            generics.span,\n-                            E0132,\n-                            \"start function is not allowed to have type parameters\"\n-                        )\n-                        .span_label(generics.span, \"start function cannot have type parameters\")\n-                        .emit();\n+                        tcx.sess.emit_err(errors::StartFunctionParameters { span: generics.span });\n                         error = true;\n                     }\n                     if generics.has_where_clause_predicates {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            generics.where_clause_span,\n-                            E0647,\n-                            \"start function is not allowed to have a `where` clause\"\n-                        )\n-                        .span_label(\n-                            generics.where_clause_span,\n-                            \"start function cannot have a `where` clause\",\n-                        )\n-                        .emit();\n+                        tcx.sess.emit_err(errors::StartFunctionWhere {\n+                            span: generics.where_clause_span,\n+                        });\n                         error = true;\n                     }\n                     if let hir::IsAsync::Async = sig.header.asyncness {\n                         let span = tcx.def_span(it.owner_id);\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0752,\n-                            \"`start` is not allowed to be `async`\"\n-                        )\n-                        .span_label(span, \"`start` is not allowed to be `async`\")\n-                        .emit();\n+                        tcx.sess.emit_err(errors::StartAsync { span: span });\n                         error = true;\n                     }\n \n                     let attrs = tcx.hir().attrs(start_id);\n                     for attr in attrs {\n                         if attr.has_name(sym::track_caller) {\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    attr.span,\n-                                    \"`start` is not allowed to be `#[track_caller]`\",\n-                                )\n-                                .span_label(\n-                                    start_span,\n-                                    \"`start` is not allowed to be `#[track_caller]`\",\n-                                )\n-                                .emit();\n+                            tcx.sess.emit_err(errors::StartTrackCaller {\n+                                span: attr.span,\n+                                start: start_span,\n+                            });\n                             error = true;\n                         }\n                     }"}, {"sha": "089491bef5ea5a216fc8cd7221dfbfbfe70a8cb7", "filename": "compiler/rustc_hir_analysis/src/structured_errors/missing_cast_for_variadic_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,6 @@\n use crate::structured_errors::StructuredDiagnostic;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n-use rustc_middle::ty::{Ty, TypeVisitable};\n+use rustc_middle::ty::{Ty, TypeVisitableExt};\n use rustc_session::Session;\n use rustc_span::Span;\n "}, {"sha": "3b9fb367813d8f7c405b4170aa3be84cbf59feb2", "filename": "compiler/rustc_hir_analysis/src/structured_errors/sized_unsized_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,6 @@\n use crate::structured_errors::StructuredDiagnostic;\n use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n-use rustc_middle::ty::{Ty, TypeVisitable};\n+use rustc_middle::ty::{Ty, TypeVisitableExt};\n use rustc_session::Session;\n use rustc_span::Span;\n "}, {"sha": "cae884ae8fb73c47d721305ef985a1f7cf751875", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -439,7 +439,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n     fn create_error_message(&self) -> String {\n         let def_path = self.tcx.def_path_str(self.def_id);\n-        let def_kind = self.tcx.def_kind(self.def_id).descr(self.def_id);\n+        let def_kind = self.tcx.def_descr(self.def_id);\n         let (quantifier, bound) = self.get_quantifier_and_bound();\n         let kind = self.kind();\n         let provided_lt_args = self.num_provided_lifetime_args();\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n         if self.gen_args.span_ext().is_some() {\n             format!(\n-                \"this {} takes {}{} {} argument{} but {} {} supplied\",\n+                \"{} takes {}{} {} argument{} but {} {} supplied\",\n                 def_kind,\n                 quantifier,\n                 bound,\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         };\n \n         let msg = {\n-            let def_kind = self.tcx.def_kind(self.def_id).descr(self.def_id);\n+            let def_kind = self.tcx.def_descr(self.def_id);\n             let (quantifier, bound) = self.get_quantifier_and_bound();\n \n             let params = if bound == 0 {"}, {"sha": "5d5c8ca604a04f77ccd0c02286d751b4f9f93720", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,10 +7,8 @@ use rustc_arena::DroplessArena;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-#[cfg(not(bootstrap))]\n-use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, CrateVariancesMap, SubstsRef, Ty, TyCtxt};\n-use rustc_middle::ty::{DefIdTree, TypeSuperVisitable};\n+use rustc_middle::ty::{DefIdTree, TypeSuperVisitable, TypeVisitable};\n use std::ops::ControlFlow;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n@@ -101,7 +99,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         }\n     }\n \n-    impl<'tcx> ty::ir::TypeVisitor<TyCtxt<'tcx>> for OpaqueTypeLifetimeCollector<'tcx> {\n+    impl<'tcx> ty::TypeVisitor<TyCtxt<'tcx>> for OpaqueTypeLifetimeCollector<'tcx> {\n         #[instrument(level = \"trace\", skip(self), ret)]\n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if let ty::RegionKind::ReEarlyBound(ebr) = r.kind() {"}, {"sha": "c021fca71339038652d8047d74df664f864285c4", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -358,7 +358,7 @@ impl<'a> State<'a> {\n                 self.print_anon_const(e);\n                 self.word(\")\");\n             }\n-            hir::TyKind::Err => {\n+            hir::TyKind::Err(_) => {\n                 self.popen();\n                 self.word(\"/*ERROR*/\");\n                 self.pclose();\n@@ -1559,7 +1559,7 @@ impl<'a> State<'a> {\n                 self.word_space(\"yield\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n             }\n-            hir::ExprKind::Err => {\n+            hir::ExprKind::Err(_) => {\n                 self.popen();\n                 self.word(\"/*ERROR*/\");\n                 self.pclose();"}, {"sha": "adfcbc36a4d029cc33509a9d9350d94fa292a92c", "filename": "compiler/rustc_hir_typeck/locales/en-US.ftl", "status": "renamed", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,17 +1,26 @@\n-hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n-hir_typeck_fru_expr = this expression does not end in a comma...\n-hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n-hir_typeck_fru_suggestion =\n-    to set the remaining fields{$expr ->\n-        [NONE]{\"\"}\n-        *[other] {\" \"}from `{$expr}`\n-    }, separate the last named field with a comma\n-\n hir_typeck_field_multiply_specified_in_initializer =\n     field `{$ident}` specified more than once\n     .label = used more than once\n     .previous_use_label = first use of `{$ident}`\n \n+hir_typeck_copy_impl_on_type_with_dtor =\n+    the trait `Copy` may not be implemented for this type; the type has a destructor\n+    .label = `Copy` not allowed on types with destructors\n+\n+hir_typeck_multiple_relaxed_default_bounds =\n+    type parameter has more than one relaxed default bound, only one is supported\n+\n+hir_typeck_copy_impl_on_non_adt =\n+    the trait `Copy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+hir_typeck_trait_object_declared_with_no_traits =\n+    at least one trait is required for an object type\n+    .alias_span = this alias does not contain a trait\n+\n+hir_typeck_functional_record_update_on_non_struct =\n+    functional record update syntax requires a struct\n+\n hir_typeck_return_stmt_outside_of_fn_body =\n     return statement outside of function body\n     .encl_body_label = the return is part of this body...\n@@ -26,9 +35,6 @@ hir_typeck_struct_expr_non_exhaustive =\n hir_typeck_method_call_on_unknown_type =\n     the type of this value must be known to call a method on a raw pointer on it\n \n-hir_typeck_functional_record_update_on_non_struct =\n-    functional record update syntax requires a struct\n-\n hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n     .label = temporary value\n \n@@ -44,9 +50,6 @@ hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on\n \n hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n \n-hir_typeck_op_trait_generic_params =\n-    `{$method_name}` must not have any generic parameters\n-\n hir_typeck_lang_start_incorrect_number_params = incorrect number of parameters for the `start` lang item\n hir_typeck_lang_start_incorrect_number_params_note_expected_count = the `start` lang item should have four parameters, but found {$found_param_count}\n \n@@ -63,3 +66,14 @@ hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n \n hir_typeck_convert_to_str = try converting the passed type into a `&str`\n+\n+hir_typeck_op_trait_generic_params = `{$method_name}` must not have any generic parameters\n+\n+hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n+hir_typeck_fru_expr = this expression does not end in a comma...\n+hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n+hir_typeck_fru_suggestion =\n+    to set the remaining fields{$expr ->\n+        [NONE]{\"\"}\n+        *[other] {\" \"}from `{$expr}`\n+    }, separate the last named field with a comma", "previous_filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl"}, {"sha": "6a0d5c01109df5cd5547124cd16ba5b5798fa9a6", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Some(trait_def_id) = opt_trait_def_id else { continue };\n \n             let opt_input_type = opt_arg_exprs.map(|arg_exprs| {\n-                self.tcx.mk_tup(arg_exprs.iter().map(|e| {\n+                self.tcx.mk_tup_from_iter(arg_exprs.iter().map(|e| {\n                     self.next_ty_var(TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeInference,\n                         span: e.span,\n@@ -247,6 +247,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 adjusted_ty,\n                 opt_input_type.as_ref().map(slice::from_ref),\n             ) {\n+                // Check for `self` receiver on the method, otherwise we can't use this as a `Fn*` trait.\n+                if !self.tcx.associated_item(ok.value.def_id).fn_has_self_parameter {\n+                    self.tcx.sess.delay_span_bug(\n+                        call_expr.span,\n+                        \"input to overloaded call fn is not a self receiver\",\n+                    );\n+                    return None;\n+                }\n+\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n@@ -257,7 +266,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // caused an error elsewhere.\n                         self.tcx\n                             .sess\n-                            .delay_span_bug(call_expr.span, \"input to call/call_mut is not a ref?\");\n+                            .delay_span_bug(call_expr.span, \"input to call/call_mut is not a ref\");\n                         return None;\n                     };\n \n@@ -271,6 +280,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         target: method.sig.inputs()[0],\n                     });\n                 }\n+\n                 return Some((autoref, method));\n             }\n         }\n@@ -428,7 +438,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let err = self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n \n-                return self.tcx.ty_error_with_guaranteed(err);\n+                return self.tcx.ty_error(err);\n             }\n         };\n \n@@ -661,7 +671,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n             {\n                 let descr = match maybe_def {\n-                    DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n+                    DefIdOrName::DefId(def_id) => self.tcx.def_descr(def_id),\n                     DefIdOrName::Name(name) => name,\n                 };\n                 err.span_label(\n@@ -823,7 +833,7 @@ impl<'a, 'tcx> DeferredCallResolution<'tcx> {\n                 );\n                 err.help(\n                     \"make sure the `fn`/`fn_mut`/`fn_once` lang items are defined \\\n-                     and have associated `call`/`call_mut`/`call_once` functions\",\n+                     and have correctly defined `call`/`call_mut`/`call_once` methods\",\n                 );\n                 err.emit();\n             }"}, {"sha": "316c2a7eeeb4bc99b0dfc10aa4fa3611c8280f84", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -41,7 +41,7 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n+use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitableExt, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n use rustc_span::def_id::{DefId, LOCAL_CRATE};"}, {"sha": "d84fabb783490d90ee857db0b31a39fd00d231ef", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,6 +3,7 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use hir::def::DefKind;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n@@ -11,8 +12,8 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, ir::TypeVisitor, Ty, TyCtxt, TypeSuperVisitable};\n+use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n@@ -126,7 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // the `closures` table.\n         let sig = bound_sig.map_bound(|sig| {\n             self.tcx.mk_fn_sig(\n-                [self.tcx.intern_tup(sig.inputs())],\n+                [self.tcx.mk_tup(sig.inputs())],\n                 sig.output(),\n                 sig.c_variadic,\n                 sig.unsafety,\n@@ -488,17 +489,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n         let expected_span =\n             expected_sig.cause_span.unwrap_or_else(|| self.tcx.def_span(expr_def_id));\n-        self.report_arg_count_mismatch(\n-            expected_span,\n-            closure_span,\n-            expected_args,\n-            found_args,\n-            true,\n-            closure_arg_span,\n-        )\n-        .emit();\n-\n-        let error_sig = self.error_sig_of_closure(decl);\n+        let guar = self\n+            .report_arg_count_mismatch(\n+                expected_span,\n+                closure_span,\n+                expected_args,\n+                found_args,\n+                true,\n+                closure_arg_span,\n+            )\n+            .emit();\n+\n+        let error_sig = self.error_sig_of_closure(decl, guar);\n \n         self.closure_sigs(expr_def_id, body, error_sig)\n     }\n@@ -561,8 +563,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) {\n                 // Check that E' = S'.\n                 let cause = self.misc(hir_ty.span);\n-                let InferOk { value: (), obligations } =\n-                    self.at(&cause, self.param_env).eq(*expected_ty, supplied_ty)?;\n+                let InferOk { value: (), obligations } = self\n+                    .at(&cause, self.param_env)\n+                    .define_opaque_types(true)\n+                    .eq(*expected_ty, supplied_ty)?;\n                 all_obligations.extend(obligations);\n             }\n \n@@ -574,6 +578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let cause = &self.misc(decl.output.span());\n             let InferOk { value: (), obligations } = self\n                 .at(cause, self.param_env)\n+                .define_opaque_types(true)\n                 .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n             all_obligations.extend(obligations);\n \n@@ -789,13 +794,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Converts the types that the user supplied, in case that doing\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n-    fn error_sig_of_closure(&self, decl: &hir::FnDecl<'_>) -> ty::PolyFnSig<'tcx> {\n+    fn error_sig_of_closure(\n+        &self,\n+        decl: &hir::FnDecl<'_>,\n+        guar: ErrorGuaranteed,\n+    ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n+        let err_ty = self.tcx.ty_error(guar);\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them.\n             astconv.ast_ty_to_ty(a);\n-            self.tcx.ty_error()\n+            err_ty\n         });\n \n         if let hir::FnRetTy::Return(ref output) = decl.output {\n@@ -804,7 +814,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = ty::Binder::dummy(self.tcx.mk_fn_sig(\n             supplied_arguments,\n-            self.tcx.ty_error(),\n+            err_ty,\n             decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,"}, {"sha": "00b86890b33f4ec54e2449444b69ccb58e8caaf6", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -54,7 +54,7 @@ use rustc_middle::ty::adjustment::{\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TypeAndMut};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n@@ -143,11 +143,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n+            let at = self.at(&self.cause, self.fcx.param_env).define_opaque_types(true);\n             if self.use_lub {\n-                self.at(&self.cause, self.fcx.param_env).lub(b, a)\n+                at.lub(b, a)\n             } else {\n-                self.at(&self.cause, self.fcx.param_env)\n-                    .sup(b, a)\n+                at.sup(b, a)\n                     .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n             }\n         })\n@@ -170,12 +170,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n-        if a.references_error() || b.references_error() {\n+        if let Err(guar) = (a, b).error_reported() {\n             // Best-effort try to unify these types -- we're already on the error path,\n             // so this will have the side-effect of making sure we have no ambiguities\n             // due to `[type error]` and `_` not coercing together.\n-            let _ = self.commit_if_ok(|_| self.at(&self.cause, self.param_env).eq(a, b));\n-            return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n+            let _ = self.commit_if_ok(|_| {\n+                self.at(&self.cause, self.param_env).define_opaque_types(true).eq(a, b)\n+            });\n+            return success(vec![], self.fcx.tcx.ty_error(guar), vec![]);\n         }\n \n         // Coercing from `!` to any type is allowed:\n@@ -995,7 +997,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n         self.apply_adjustments(expr, adjustments);\n-        Ok(if expr_ty.references_error() { self.tcx.ty_error() } else { target })\n+        Ok(if let Err(guar) = expr_ty.error_reported() { self.tcx.ty_error(guar) } else { target })\n     }\n \n     /// Same as `try_coerce()`, but without side-effects.\n@@ -1432,8 +1434,8 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n         // If we see any error types, just propagate that error\n         // upwards.\n-        if expression_ty.references_error() || self.merged_ty().references_error() {\n-            self.final_ty = Some(fcx.tcx.ty_error());\n+        if let Err(guar) = (expression_ty, self.merged_ty()).error_reported() {\n+            self.final_ty = Some(fcx.tcx.ty_error(guar));\n             return;\n         }\n \n@@ -1484,6 +1486,8 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             // Another example is `break` with no argument expression.\n             assert!(expression_ty.is_unit(), \"if let hack without unit type\");\n             fcx.at(cause, fcx.param_env)\n+                // needed for tests/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs\n+                .define_opaque_types(true)\n                 .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n                 .map(|infer_ok| {\n                     fcx.register_infer_ok_obligations(infer_ok);\n@@ -1616,7 +1620,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n                 let reported = err.emit_unless(unsized_return);\n \n-                self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(reported));\n+                self.final_ty = Some(fcx.tcx.ty_error(reported));\n             }\n         }\n     }"}, {"sha": "34d62987c3b0afc12cd6d20cb5c2b6c2b9c3d81b", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitable};\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitableExt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).sup(expected, actual) {\n+        match self.at(cause, self.param_env).define_opaque_types(true).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).eq(expected, actual) {\n+        match self.at(cause, self.param_env).define_opaque_types(true).eq(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "3eee2278dcaddb56acbd67fa479f84c7cc0767b5", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,4 +1,5 @@\n //! Errors emitted by `rustc_hir_typeck`.\n+use crate::fluent_generated as fluent;\n use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, MultiSpan, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n@@ -14,7 +15,7 @@ pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(previous_use_label)]\n+    #[label(hir_typeck_previous_use_label)]\n     pub prev_span: Span,\n     pub ident: Ident,\n }\n@@ -24,9 +25,9 @@ pub struct FieldMultiplySpecifiedInInitializer {\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n-    #[label(encl_body_label)]\n+    #[label(hir_typeck_encl_body_label)]\n     pub encl_body_span: Option<Span>,\n-    #[label(encl_fn_label)]\n+    #[label(hir_typeck_encl_fn_label)]\n     pub encl_fn_span: Option<Span>,\n }\n \n@@ -157,20 +158,17 @@ impl AddToDiagnostic for TypeMismatchFruTypo {\n \n         // Only explain that `a ..b` is a range if it's split up\n         if self.expr_span.between(self.fru_span).is_empty() {\n-            diag.span_note(\n-                self.expr_span.to(self.fru_span),\n-                rustc_errors::fluent::hir_typeck_fru_note,\n-            );\n+            diag.span_note(self.expr_span.to(self.fru_span), fluent::hir_typeck_fru_note);\n         } else {\n             let mut multispan: MultiSpan = vec![self.expr_span, self.fru_span].into();\n-            multispan.push_span_label(self.expr_span, rustc_errors::fluent::hir_typeck_fru_expr);\n-            multispan.push_span_label(self.fru_span, rustc_errors::fluent::hir_typeck_fru_expr2);\n-            diag.span_note(multispan, rustc_errors::fluent::hir_typeck_fru_note);\n+            multispan.push_span_label(self.expr_span, fluent::hir_typeck_fru_expr);\n+            multispan.push_span_label(self.fru_span, fluent::hir_typeck_fru_expr2);\n+            diag.span_note(multispan, fluent::hir_typeck_fru_note);\n         }\n \n         diag.span_suggestion(\n             self.expr_span.shrink_to_hi(),\n-            rustc_errors::fluent::hir_typeck_fru_suggestion,\n+            fluent::hir_typeck_fru_suggestion,\n             \", \",\n             Applicability::MaybeIncorrect,\n         );"}, {"sha": "7fc4ccb04ee0bd1b49991451f4aecd164a2ba880", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 68, "deletions": 53, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -42,7 +42,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::error::TypeError::FieldMisMatch;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitableExt};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::parse::feature_err;\n use rustc_span::edit_distance::find_best_match_for_name;\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &adjustments[..] {\n                     target.to_owned()\n                 } else {\n-                    self.tcx().ty_error_with_guaranteed(reported)\n+                    self.tcx().ty_error(reported)\n                 };\n             }\n \n@@ -313,7 +313,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     tcx.types.never\n                 } else {\n                     // There was an error; make type-check fail.\n-                    tcx.ty_error()\n+                    tcx.ty_error_misc()\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Field(base, field) => self.check_field(expr, &base, field, expected),\n             ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n-            hir::ExprKind::Err => tcx.ty_error(),\n+            hir::ExprKind::Err(guar) => tcx.ty_error(guar),\n         }\n     }\n \n@@ -402,7 +402,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n                         }\n-                        oprnd_t = tcx.ty_error_with_guaranteed(err.emit());\n+                        oprnd_t = tcx.ty_error(err.emit());\n                     }\n                 }\n                 hir::UnOp::Not => {\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n-            _ if tm.ty.references_error() => self.tcx.ty_error(),\n+            _ if tm.ty.references_error() => self.tcx.ty_error_misc(),\n             hir::BorrowKind::Raw => {\n                 self.check_named_place_expr(oprnd);\n                 self.tcx.mk_ptr(tm)\n@@ -531,11 +531,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let e =\n                     self.tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n-                tcx.ty_error_with_guaranteed(e)\n+                tcx.ty_error(e)\n             }\n             Res::Def(DefKind::Variant, _) => {\n                 let e = report_unexpected_variant_res(tcx, res, qpath, expr.span, \"E0533\", \"value\");\n-                tcx.ty_error_with_guaranteed(e)\n+                tcx.ty_error(e)\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the loop context is not a `loop { }`, then break with\n                 // a value is illegal, and `opt_coerce_to` will be `None`.\n                 // Just set expectation to error in that case.\n-                let coerce_to = opt_coerce_to.unwrap_or_else(|| tcx.ty_error());\n+                let coerce_to = opt_coerce_to.unwrap_or_else(|| tcx.ty_error_misc());\n \n                 // Recurse without `enclosing_breakables` borrowed.\n                 e_ty = self.check_expr_with_hint(e, coerce_to);\n@@ -1033,7 +1033,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let result_ty = coerce.complete(self);\n-        if cond_ty.references_error() { self.tcx.ty_error() } else { result_ty }\n+        if let Err(guar) = cond_ty.error_reported() { self.tcx.ty_error(guar) } else { result_ty }\n     }\n \n     /// Type check assignment expression `expr` of form `lhs = rhs`.\n@@ -1109,7 +1109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If the assignment expression itself is ill-formed, don't\n             // bother emitting another error\n             let reported = err.emit_unless(lhs_ty.references_error() || rhs_ty.references_error());\n-            return self.tcx.ty_error_with_guaranteed(reported);\n+            return self.tcx.ty_error(reported);\n         }\n \n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n@@ -1155,8 +1155,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n-        if lhs_ty.references_error() || rhs_ty.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = (lhs_ty, rhs_ty).error_reported() {\n+            self.tcx.ty_error(guar)\n         } else {\n             self.tcx.mk_unit()\n         }\n@@ -1274,8 +1274,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let t_expr = self.resolve_vars_if_possible(t_expr);\n \n         // Eagerly check for some obvious errors.\n-        if t_expr.references_error() || t_cast.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = (t_expr, t_cast).error_reported() {\n+            self.tcx.ty_error(guar)\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -1296,7 +1296,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }\n-                Err(_) => self.tcx.ty_error(),\n+                Err(guar) => self.tcx.ty_error(guar),\n             }\n         }\n     }\n@@ -1423,8 +1423,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if element_ty.references_error() {\n-            return tcx.ty_error();\n+        if let Err(guar) = element_ty.error_reported() {\n+            return tcx.ty_error(guar);\n         }\n \n         self.check_repeat_element_needs_copy_bound(element, count, element_ty);\n@@ -1492,9 +1492,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n         });\n-        let tuple = self.tcx.mk_tup(elt_ts_iter);\n-        if tuple.references_error() {\n-            self.tcx.ty_error()\n+        let tuple = self.tcx.mk_tup_from_iter(elt_ts_iter);\n+        if let Err(guar) = tuple.error_reported() {\n+            self.tcx.ty_error(guar)\n         } else {\n             self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n             tuple\n@@ -1510,9 +1510,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         // Find the relevant variant\n-        let Some((variant, adt_ty)) = self.check_struct_path(qpath, expr.hir_id) else {\n-            self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.ty_error();\n+        let (variant, adt_ty) = match self.check_struct_path(qpath, expr.hir_id) {\n+            Ok(data) => data,\n+            Err(guar) => {\n+                self.check_struct_fields_on_error(fields, base_expr);\n+                return self.tcx.ty_error(guar);\n+            }\n         };\n \n         // Prohibit struct expressions when non-exhaustive flag is set.\n@@ -1594,12 +1597,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.field_ty(field.span, v_field, substs)\n             } else {\n                 error_happened = true;\n-                if let Some(prev_span) = seen_fields.get(&ident) {\n+                let guar = if let Some(prev_span) = seen_fields.get(&ident) {\n                     tcx.sess.emit_err(FieldMultiplySpecifiedInInitializer {\n                         span: field.ident.span,\n                         prev_span: *prev_span,\n                         ident,\n-                    });\n+                    })\n                 } else {\n                     self.report_unknown_field(\n                         adt_ty,\n@@ -1608,10 +1611,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ast_fields,\n                         adt.variant_descr(),\n                         expr_span,\n-                    );\n-                }\n+                    )\n+                };\n \n-                tcx.ty_error()\n+                tcx.ty_error(guar)\n             };\n \n             // Make sure to give a type to the field even if there's\n@@ -1994,14 +1997,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         skip_fields: &[hir::ExprField<'_>],\n         kind_name: &str,\n         expr_span: Span,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         if variant.is_recovered() {\n-            self.set_tainted_by_errors(\n-                self.tcx\n-                    .sess\n-                    .delay_span_bug(expr_span, \"parser recovered but no error was emitted\"),\n-            );\n-            return;\n+            let guar = self\n+                .tcx\n+                .sess\n+                .delay_span_bug(expr_span, \"parser recovered but no error was emitted\");\n+            self.set_tainted_by_errors(guar);\n+            return guar;\n         }\n         let mut err = self.err_ctxt().type_error_struct_with_diag(\n             field.ident.span,\n@@ -2115,7 +2118,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n             }\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     // Return a hint about the closest match in field names\n@@ -2256,21 +2259,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, base_ty, field, did, expected.only_has_type(self));\n-            return self.tcx().ty_error();\n+            let guar = self.ban_private_field_access(\n+                expr,\n+                base_ty,\n+                field,\n+                did,\n+                expected.only_has_type(self),\n+            );\n+            return self.tcx().ty_error(guar);\n         }\n \n-        if field.name == kw::Empty {\n+        let guar = if field.name == kw::Empty {\n+            self.tcx.sess.delay_span_bug(field.span, \"field name with no name\")\n         } else if self.method_exists(\n             field,\n             base_ty,\n             expr.hir_id,\n             true,\n             expected.only_has_type(self),\n         ) {\n-            self.ban_take_value_of_method(expr, base_ty, field);\n+            self.ban_take_value_of_method(expr, base_ty, field)\n         } else if !base_ty.is_primitive_ty() {\n-            self.ban_nonexisting_field(field, base, expr, base_ty);\n+            self.ban_nonexisting_field(field, base, expr, base_ty)\n         } else {\n             let field_name = field.to_string();\n             let mut err = type_error_struct!(\n@@ -2339,10 +2349,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            err.emit();\n-        }\n+            err.emit()\n+        };\n \n-        self.tcx().ty_error()\n+        self.tcx().ty_error(guar)\n     }\n \n     fn suggest_await_on_field_access(\n@@ -2388,7 +2398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         base_ty: Ty<'tcx>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         debug!(\n             \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, base_ty={:?}\",\n             ident, base, expr, base_ty\n@@ -2436,7 +2446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             HelpUseLatestEdition::new().add_to_diagnostic(&mut err);\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn ban_private_field_access(\n@@ -2446,9 +2456,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n         base_did: DefId,\n         return_ty: Option<Ty<'tcx>>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let struct_path = self.tcx().def_path_str(base_did);\n-        let kind_name = self.tcx().def_kind(base_did).descr(base_did);\n+        let kind_name = self.tcx().def_descr(base_did);\n         let mut err = struct_span_err!(\n             self.tcx().sess,\n             field.span,\n@@ -2469,10 +2479,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 None,\n             );\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr<'tcx>, expr_t: Ty<'tcx>, field: Ident) {\n+    fn ban_take_value_of_method(\n+        &self,\n+        expr: &hir::Expr<'tcx>,\n+        expr_t: Ty<'tcx>,\n+        field: Ident,\n+    ) -> ErrorGuaranteed {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,\n@@ -2544,7 +2559,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.help(\"methods are immutable and cannot be assigned to\");\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn point_at_param_definition(&self, err: &mut Diagnostic, param: ty::ParamTy) {\n@@ -2829,7 +2844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     let reported = err.emit();\n-                    self.tcx.ty_error_with_guaranteed(reported)\n+                    self.tcx.ty_error(reported)\n                 }\n             }\n         }"}, {"sha": "b9a058d6bba2c8732779a6a214c04f06497c4392", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)\n-            | hir::ExprKind::Err => {}\n+            | hir::ExprKind::Err(_) => {}\n \n             hir::ExprKind::Loop(blk, ..) => {\n                 self.walk_block(blk);"}, {"sha": "b7ae621c6859f390524b2480ad03e3155bad0502", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // type, `?T` is not considered unsolved, but `?I` is. The\n         // same is true for float variables.)\n         let fallback = match ty.kind() {\n-            _ if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n+            _ if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error(e),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {"}, {"sha": "60e55c7b0cf57cc25dd1cb467b03bd1c5e2aebd1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -23,9 +23,9 @@ use rustc_infer::infer::InferResult;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, Ty, UserType,\n+    self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, Ty, TyCtxt, UserType,\n };\n use rustc_middle::ty::{GenericArgKind, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn normalize<T>(&self, span: Span, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.register_infer_ok_obligations(\n             self.at(&self.misc(span), self.param_env).normalize(value),\n@@ -443,15 +443,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // sufficiently enforced with erased regions. =)\n     fn can_contain_user_lifetime_bounds<T>(t: T) -> bool\n     where\n-        T: TypeVisitable<'tcx>,\n+        T: TypeVisitable<TyCtxt<'tcx>>,\n     {\n         t.has_free_regions() || t.has_projections() || t.has_infer_types()\n     }\n \n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n+            None if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error(e),\n             None => {\n                 bug!(\n                     \"no type for node {} in fcx {}\",\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => Some(t),\n-            None if let Some(e) = self.tainted_by_errors() => Some(self.tcx.ty_error_with_guaranteed(e)),\n+            None if let Some(e) = self.tainted_by_errors() => Some(self.tcx.ty_error(e)),\n             None => None,\n         }\n     }\n@@ -701,7 +701,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        vec![self.tcx.ty_error(); len]\n+        let ty_error = self.tcx.ty_error_misc();\n+        vec![ty_error; len]\n     }\n \n     /// Unifies the output type with the expected type early, for more coercions\n@@ -1161,7 +1162,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     let reported = err.emit();\n-                    return (tcx.ty_error_with_guaranteed(reported), res);\n+                    return (tcx.ty_error(reported), res);\n                 }\n             }\n         } else {\n@@ -1417,7 +1418,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n                     .emit()\n             });\n-            let err = self.tcx.ty_error_with_guaranteed(e);\n+            let err = self.tcx.ty_error(e);\n             self.demand_suptype(sp, err, ty);\n             err\n         }"}, {"sha": "d64492e503db0544139527cc93090c107033d68f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::{\n-    self, ir::TypeVisitor, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+    self, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_span::{self, Span};\n use rustc_trait_selection::traits;\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         true\n     }\n \n-    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n+    fn find_ambiguous_parameter_in<T: TypeVisitable<TyCtxt<'tcx>>>(\n         &self,\n         item_def_id: DefId,\n         t: T,"}, {"sha": "2e62e13648c95140a7ba0a3c0c2bc55166819b9c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -10,7 +10,9 @@ use crate::{\n };\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n+use rustc_errors::{\n+    pluralize, Applicability, Diagnostic, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -25,7 +27,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{kw, Ident};\n@@ -72,7 +74,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n                 let ty = self.resolve_vars_if_possible(ty);\n                 if ty.has_non_region_infer() {\n-                    self.tcx.ty_error()\n+                    self.tcx.ty_error_misc()\n                 } else {\n                     self.tcx.erase_regions(ty)\n                 }\n@@ -100,7 +102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let err_inputs = match tuple_arguments {\n                 DontTupleArguments => err_inputs,\n-                TupleArguments => vec![self.tcx.intern_tup(&err_inputs)],\n+                TupleArguments => vec![self.tcx.mk_tup(&err_inputs)],\n             };\n \n             self.check_argument_types(\n@@ -113,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tuple_arguments,\n                 method.ok().map(|method| method.def_id),\n             );\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error_misc();\n         }\n \n         let method = method.unwrap();\n@@ -533,7 +535,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .typeck_results\n                     .borrow()\n                     .expr_ty_adjusted_opt(*expr)\n-                    .unwrap_or_else(|| tcx.ty_error());\n+                    .unwrap_or_else(|| tcx.ty_error_misc());\n                 (self.resolve_vars_if_possible(ty), normalize_span(expr.span))\n             })\n             .collect();\n@@ -640,7 +642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && provided_arg_tys.len() == formal_and_expected_inputs.len() - 1 + tys.len()\n             {\n                 // Wrap up the N provided arguments starting at this position in a tuple.\n-                let provided_as_tuple = tcx.mk_tup(\n+                let provided_as_tuple = tcx.mk_tup_from_iter(\n                     provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx).take(tys.len()),\n                 );\n \n@@ -932,25 +934,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     labels\n                         .push((provided_span, format!(\"unexpected argument{}\", provided_ty_name)));\n                     let mut span = provided_span;\n-                    if arg_idx.index() > 0\n+                    if span.can_be_used_for_suggestions() {\n+                        if arg_idx.index() > 0\n                         && let Some((_, prev)) = provided_arg_tys\n                             .get(ProvidedIdx::from_usize(arg_idx.index() - 1)\n                     ) {\n                         // Include previous comma\n-                        span = span.with_lo(prev.hi());\n-                    } else if let Some((_, next)) = provided_arg_tys.get(\n-                        ProvidedIdx::from_usize(arg_idx.index() + 1),\n-                    ) {\n-                        // Include next comma\n-                        span = span.until(*next);\n+                        span = prev.shrink_to_hi().to(span);\n                     }\n-                    suggestions.push((span, String::new()));\n+                        suggestions.push((span, String::new()));\n \n-                    suggestion_text = match suggestion_text {\n-                        SuggestionText::None => SuggestionText::Remove(false),\n-                        SuggestionText::Remove(_) => SuggestionText::Remove(true),\n-                        _ => SuggestionText::DidYouMean,\n-                    };\n+                        suggestion_text = match suggestion_text {\n+                            SuggestionText::None => SuggestionText::Remove(false),\n+                            SuggestionText::Remove(_) => SuggestionText::Remove(true),\n+                            _ => SuggestionText::DidYouMean,\n+                        };\n+                    }\n                 }\n                 Error::Missing(expected_idx) => {\n                     // If there are multiple missing arguments adjacent to each other,\n@@ -1289,23 +1288,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n-            ast::LitKind::Err => tcx.ty_error(),\n+            ast::LitKind::Err => tcx.ty_error_misc(),\n         }\n     }\n \n     pub fn check_struct_path(\n         &self,\n         qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n-    ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n+    ) -> Result<(&'tcx ty::VariantDef, Ty<'tcx>), ErrorGuaranteed> {\n         let path_span = qpath.span();\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n-                self.set_tainted_by_errors(\n-                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\"),\n-                );\n-                return None;\n+                let guar =\n+                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(guar);\n+                return Err(guar);\n             }\n             Res::Def(DefKind::Variant, _) => match ty.normalized.ty_adt_def() {\n                 Some(adt) => {\n@@ -1333,28 +1332,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Check bounds on type arguments used in the path.\n             self.add_required_obligations_for_hir(path_span, did, substs, hir_id);\n \n-            Some((variant, ty.normalized))\n+            Ok((variant, ty.normalized))\n         } else {\n-            match ty.normalized.kind() {\n-                ty::Error(_) => {\n+            Err(match *ty.normalized.kind() {\n+                ty::Error(guar) => {\n                     // E0071 might be caused by a spelling error, which will have\n                     // already caused an error message and probably a suggestion\n                     // elsewhere. Refrain from emitting more unhelpful errors here\n                     // (issue #88844).\n+                    guar\n                 }\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        path_span,\n-                        E0071,\n-                        \"expected struct, variant or union type, found {}\",\n-                        ty.normalized.sort_string(self.tcx)\n-                    )\n-                    .span_label(path_span, \"not a struct\")\n-                    .emit();\n-                }\n-            }\n-            None\n+                _ => struct_span_err!(\n+                    self.tcx.sess,\n+                    path_span,\n+                    E0071,\n+                    \"expected struct, variant or union type, found {}\",\n+                    ty.normalized.sort_string(self.tcx)\n+                )\n+                .span_label(path_span, \"not a struct\")\n+                .emit(),\n+            })\n         }\n     }\n \n@@ -1718,9 +1715,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx hir::Pat<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        if ty.references_error() {\n+        if let Err(guar) = ty.error_reported() {\n             // Override the types everywhere with `err()` to avoid knock on errors.\n-            let err = self.tcx.ty_error();\n+            let err = self.tcx.ty_error(guar);\n             self.write_ty(hir_id, err);\n             self.write_ty(pat.hir_id, err);\n             let local_ty = LocalTy { decl_ty: err, revealed_ty: err };\n@@ -1749,7 +1746,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let result = self\n                     .astconv()\n                     .associated_path_to_ty(hir_id, path_span, ty.raw, qself, segment, true);\n-                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let ty =\n+                    result.map(|(ty, _, _)| ty).unwrap_or_else(|guar| self.tcx().ty_error(guar));\n                 let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n@@ -1941,8 +1939,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 spans.push_span_label(param.span, \"\");\n             }\n \n-            let def_kind = self.tcx.def_kind(def_id);\n-            err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+            err.span_note(spans, &format!(\"{} defined here\", self.tcx.def_descr(def_id)));\n         } else if let Some(hir::Node::Expr(e)) = self.tcx.hir().get_if_local(def_id)\n             && let hir::ExprKind::Closure(hir::Closure { body, .. }) = &e.kind\n         {\n@@ -1955,10 +1952,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             err.span_note(span, &format!(\"{} defined here\", kind));\n         } else {\n-            let def_kind = self.tcx.def_kind(def_id);\n             err.span_note(\n                 self.tcx.def_span(def_id),\n-                &format!(\"{} defined here\", def_kind.descr(def_id)),\n+                &format!(\"{} defined here\", self.tcx.def_descr(def_id)),\n             );\n         }\n     }"}, {"sha": "1dea3e6f900d4dd72741396cc0ecbca9fe405963", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -18,7 +18,7 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span, DUMMY_SP};"}, {"sha": "c49621b7c2488095ac150deaf92c7ecdc0deef38", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,9 +1,10 @@\n use super::FnCtxt;\n \n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n+use crate::fluent_generated as fluent;\n use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n-use rustc_errors::{fluent, Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n@@ -16,7 +17,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n-    TypeVisitable,\n+    TypeVisitableExt,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n@@ -120,7 +121,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n                     DefKind::Ctor(CtorOf::Struct, _) => \"construct this tuple struct\".to_string(),\n                     DefKind::Ctor(CtorOf::Variant, _) => \"construct this tuple variant\".to_string(),\n-                    kind => format!(\"call this {}\", kind.descr(def_id)),\n+                    kind => format!(\"call this {}\", self.tcx.def_kind_descr(kind, def_id)),\n                 },\n                 DefIdOrName::Name(name) => format!(\"call this {name}\"),\n             };\n@@ -339,7 +340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     CtorOf::Variant => \"an enum variant\",\n                 }));\n             } else {\n-                let descr = kind.descr(def_id);\n+                let descr = self.tcx.def_kind_descr(kind, def_id);\n                 err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n             }\n             return true;"}, {"sha": "7c0402b1c7fb86c8c16aca1bfd5931d59f3610a2", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -12,7 +12,7 @@ use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::{\n     hir::map::Map,\n-    ty::{ParamEnv, TyCtxt, TypeVisitable, TypeckResults},\n+    ty::{ParamEnv, TyCtxt, TypeVisitableExt, TypeckResults},\n };\n use std::mem::swap;\n \n@@ -219,7 +219,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Struct(..)\n             | ExprKind::Repeat(..)\n             | ExprKind::Yield(..)\n-            | ExprKind::Err => (),\n+            | ExprKind::Err(_) => (),\n         }\n     }\n \n@@ -483,7 +483,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Closure { .. }\n             | ExprKind::ConstBlock(..)\n             | ExprKind::DropTemps(..)\n-            | ExprKind::Err\n+            | ExprKind::Err(_)\n             | ExprKind::Field(..)\n             | ExprKind::Index(..)\n             | ExprKind::InlineAsm(..)"}, {"sha": "fa3887362d99caa3ec6196ba076e07bca69b82f3", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,7 +9,7 @@ use rustc_hir as hir;\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_middle::{\n     hir::place::{PlaceBase, Projection, ProjectionKind},\n-    ty::TypeVisitable,\n+    ty::TypeVisitableExt,\n };\n \n pub(super) fn find_consumed_and_borrowed<'a, 'tcx>("}, {"sha": "2e41c2041f88868f441cb2b5ca8505d2f76e0353", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::fold::FnMutDelegate;\n-use rustc_middle::ty::{self, BoundVariableKind, RvalueScopes, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, BoundVariableKind, RvalueScopes, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n@@ -311,8 +311,8 @@ pub fn resolve_interior<'a, 'tcx>(\n     };\n \n     // Extract type components to build the witness type.\n-    let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n-    let bound_vars = fcx.tcx.intern_bound_variable_kinds(&bound_vars);\n+    let type_list = fcx.tcx.mk_type_list_from_iter(type_causes.iter().map(|cause| cause.ty));\n+    let bound_vars = fcx.tcx.mk_bound_variable_kinds(&bound_vars);\n     let witness =\n         fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n "}, {"sha": "26020382d8148cc6a06634c9870a5bfb0b925f9a", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};"}, {"sha": "19d2befc438791342225f5e90cefe32ca7756374", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_target::abi::{Pointer, VariantIdx};\n \n use super::FnCtxt;"}, {"sha": "91fd8fad73c7b1647be76c025324a931b01d0e84", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -53,21 +53,27 @@ use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_errors::{struct_span_err, DiagnosticId, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{\n+    struct_span_err, DiagnosticId, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n+    SubdiagnosticMessage,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirIdMap, Node};\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_hir_analysis::check::check_abi;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_macros::fluent_messages;\n use rustc_middle::traits;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config;\n use rustc_session::Session;\n use rustc_span::def_id::{DefId, LocalDefId};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }\n \n #[macro_export]\n macro_rules! type_error_struct {\n@@ -201,6 +207,11 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n+        let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+            param_env.without_const()\n+        } else {\n+            param_env\n+        };\n         let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n \n         if let Some(hir::FnSig { header, decl, .. }) = fn_sig {"}, {"sha": "bcfc61bffb2c66038c2b4964d1fd16b67724e542", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -51,7 +51,7 @@\n use rustc_middle::hir::place::*;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n     fn resolve_vars_if_possible<T>(&self, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.infcx.resolve_vars_if_possible(value)\n     }\n@@ -383,7 +383,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Repeat(..)\n             | hir::ExprKind::InlineAsm(..)\n             | hir::ExprKind::Box(..)\n-            | hir::ExprKind::Err => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),\n+            | hir::ExprKind::Err(_) => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),\n         }\n     }\n "}, {"sha": "169f128e0a00388c700451bbb443846be9568d3a", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{self, SubstsRef};\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, UserSubsts, UserType};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits;\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n     fn instantiate_binder_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n-        T: TypeFoldable<'tcx> + Copy,\n+        T: TypeFoldable<TyCtxt<'tcx>> + Copy,\n     {\n         self.fcx.instantiate_binder_with_fresh_vars(self.span, infer::FnCall, value)\n     }"}, {"sha": "0456dd56c340e219a56f650d75ef7223f1444d9d", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, GenericParamDefKind, Ty, TypeVisitableExt};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -380,6 +380,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n             return None;\n         };\n+\n+        if method_item.kind != ty::AssocKind::Fn {\n+            self.tcx.sess.delay_span_bug(tcx.def_span(method_item.def_id), \"not a method\");\n+            return None;\n+        }\n+\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n "}, {"sha": "3bef5cfcd780ef8aa9f8639364619bafd7b8699b", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 6, "deletions": 61, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::ToPredicate;\n-use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint;\n use rustc_span::def_id::DefId;\n@@ -1095,17 +1095,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_core(&self) -> Option<PickResult<'tcx>> {\n-        let pick = self.pick_all_method(Some(&mut vec![]));\n-\n-        // In this case unstable picking is done by `pick_method`.\n-        if !self.tcx.sess.opts.unstable_opts.pick_stable_methods_before_any_unstable {\n-            return pick;\n-        }\n-\n-        if pick.is_none() {\n-            return self.pick_all_method(None);\n-        }\n-        pick\n+        // Pick stable methods only first, and consider unstable candidates if not found.\n+        self.pick_all_method(Some(&mut vec![])).or_else(|| self.pick_all_method(None))\n     }\n \n     fn pick_all_method(\n@@ -1244,54 +1235,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_method_with_unstable(&self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n-\n-        let mut possibly_unsatisfied_predicates = Vec::new();\n-\n-        for (kind, candidates) in\n-            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n-        {\n-            debug!(\"searching {} candidates\", kind);\n-            let res = self.consider_candidates(\n-                self_ty,\n-                candidates,\n-                &mut possibly_unsatisfied_predicates,\n-                Some(&mut vec![]),\n-            );\n-            if res.is_some() {\n-                return res;\n-            }\n-        }\n-\n-        for (kind, candidates) in\n-            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n-        {\n-            debug!(\"searching unstable {kind} candidates\");\n-            let res = self.consider_candidates(\n-                self_ty,\n-                candidates,\n-                &mut possibly_unsatisfied_predicates,\n-                None,\n-            );\n-            if res.is_some() {\n-                return res;\n-            }\n-        }\n-\n-        self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n-        None\n-    }\n-\n     fn pick_method(\n         &self,\n         self_ty: Ty<'tcx>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n-        if !self.tcx.sess.opts.unstable_opts.pick_stable_methods_before_any_unstable {\n-            return self.pick_method_with_unstable(self_ty);\n-        }\n-\n         debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n@@ -1418,8 +1366,8 @@ impl<'tcx> Pick<'tcx> {\n             span,\n             format!(\n                 \"{} {} with this name may be added to the standard library in the future\",\n-                def_kind.article(),\n-                def_kind.descr(self.item.def_id),\n+                tcx.def_kind_descr_article(def_kind, self.item.def_id),\n+                tcx.def_kind_descr(def_kind, self.item.def_id),\n             ),\n             |lint| {\n                 match (self.item.kind, self.item.container) {\n@@ -1488,7 +1436,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n-                    .define_opaque_types(false)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n@@ -1518,7 +1465,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // First check that the self type can be related.\n             let sub_obligations = match self\n                 .at(&ObligationCause::dummy(), self.param_env)\n-                .define_opaque_types(false)\n                 .sup(probe.xform_self_ty, self_ty)\n             {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n@@ -1735,7 +1681,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let ProbeResult::Match = result\n                     && self\n                     .at(&ObligationCause::dummy(), self.param_env)\n-                    .define_opaque_types(false)\n                     .sup(return_ty, xform_ret_ty)\n                     .is_err()\n                 {\n@@ -1960,7 +1905,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     ///    so forth.\n     fn erase_late_bound_regions<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.tcx.erase_late_bound_regions(value)\n     }"}, {"sha": "47a4d4e72dffd9a8951e084268c6708a948d1b3d", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n-use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             MethodError::PrivateMatch(kind, def_id, out_of_scope_traits) => {\n-                let kind = kind.descr(def_id);\n+                let kind = self.tcx.def_kind_descr(kind, def_id);\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     item_name.span,\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // `<Foo as Iterator>::Item = String`.\n                         let projection_ty = pred.skip_binder().projection_ty;\n \n-                        let substs_with_infer_self = tcx.mk_substs(\n+                        let substs_with_infer_self = tcx.mk_substs_from_iter(\n                             iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n                                 .chain(projection_ty.substs.iter().skip(1)),\n                         );\n@@ -1062,8 +1062,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         &format!(\n                             \"there is {} {} with a similar name\",\n-                            def_kind.article(),\n-                            def_kind.descr(similar_candidate.def_id),\n+                            self.tcx.def_kind_descr_article(def_kind, similar_candidate.def_id),\n+                            self.tcx.def_kind_descr(def_kind, similar_candidate.def_id)\n                         ),\n                         similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n@@ -1172,7 +1172,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             path,\n                             ty,\n                             item.kind,\n-                            item.def_id,\n+                            self.tcx.def_kind_descr(item.kind.as_def_kind(), item.def_id),\n                             sugg_span,\n                             idx,\n                             self.tcx.sess.source_map(),\n@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             path,\n                             rcvr_ty,\n                             item.kind,\n-                            item.def_id,\n+                            self.tcx.def_kind_descr(item.kind.as_def_kind(), item.def_id),\n                             sugg_span,\n                             idx,\n                             self.tcx.sess.source_map(),\n@@ -1252,7 +1252,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Adt(def, substs) = target_ty.kind() {\n                 // If there are any inferred arguments, (`{integer}`), we should replace\n                 // them with underscores to allow the compiler to infer them\n-                let infer_substs = self.tcx.mk_substs(substs.into_iter().map(|arg| {\n+                let infer_substs = self.tcx.mk_substs_from_iter(substs.into_iter().map(|arg| {\n                     if !arg.is_suggestable(self.tcx, true) {\n                         has_unsuggestable_args = true;\n                         match arg.unpack() {\n@@ -2853,7 +2853,7 @@ fn print_disambiguation_help<'tcx>(\n     trait_name: String,\n     rcvr_ty: Ty<'_>,\n     kind: ty::AssocKind,\n-    def_id: DefId,\n+    def_kind_descr: &'static str,\n     span: Span,\n     candidate: Option<usize>,\n     source_map: &source_map::SourceMap,\n@@ -2886,7 +2886,7 @@ fn print_disambiguation_help<'tcx>(\n         span,\n         &format!(\n             \"disambiguate the {} for {}\",\n-            kind.as_def_kind().descr(def_id),\n+            def_kind_descr,\n             if let Some(candidate) = candidate {\n                 format!(\"candidate #{}\", candidate)\n             } else {"}, {"sha": "a4b325a9b798435b7ca54e6201b108da7a5263c0", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n-    self, ir::TypeFolder, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeSuperFoldable, TypeVisitable,\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n@@ -297,7 +297,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method.sig.output()\n             }\n             // error types are considered \"builtin\"\n-            Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n+            Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => {\n+                self.tcx.ty_error_misc()\n+            }\n             Err(errors) => {\n                 let (_, trait_def_id) =\n                     lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n@@ -518,7 +520,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 let reported = err.emit();\n-                self.tcx.ty_error_with_guaranteed(reported)\n+                self.tcx.ty_error(reported)\n             }\n         };\n \n@@ -631,7 +633,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Err(errors) => {\n                 let actual = self.resolve_vars_if_possible(operand_ty);\n-                if !actual.references_error() {\n+                let guar = actual.error_reported().err().unwrap_or_else(|| {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         ex.span,\n@@ -701,9 +703,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    err.emit();\n-                }\n-                self.tcx.ty_error()\n+                    err.emit()\n+                });\n+                self.tcx.ty_error(guar)\n             }\n         }\n     }"}, {"sha": "c36c75e444368fb3c0bee4863145746bbadd5f1d", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 145, "deletions": 111, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{HirId, Pat, PatKind};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::middle::stability::EvalResult;\n-use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeVisitableExt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n@@ -475,8 +475,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n             // There exists a side that didn't meet our criteria that the end-point\n             // be of a numeric or char type, as checked in `calc_side` above.\n-            self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.ty_error();\n+            let guar = self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error(guar);\n         }\n \n         // Unify each side with `expected`.\n@@ -496,7 +496,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         demand_eqtype(&mut rhs, lhs);\n \n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error_misc();\n         }\n \n         // Find the unified type and check if it's of numeric or char type again.\n@@ -511,8 +511,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let Some((ref mut fail, _, _)) = rhs {\n                 *fail = true;\n             }\n-            self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.ty_error();\n+            let guar = self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error(guar);\n         }\n         ty\n     }\n@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         lhs: Option<(bool, Ty<'tcx>, Span)>,\n         rhs: Option<(bool, Ty<'tcx>, Span)>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let span = match (lhs, rhs) {\n             (Some((true, ..)), Some((true, ..))) => span,\n             (Some((true, _, sp)), _) => sp,\n@@ -573,7 +573,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     type between two end-points, you can use a guard.\",\n             );\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     fn check_pat_ident(\n@@ -807,29 +807,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n+    pub fn check_dereferenceable(\n+        &self,\n+        span: Span,\n+        expected: Ty<'tcx>,\n+        inner: &Pat<'_>,\n+    ) -> Result<(), ErrorGuaranteed> {\n         if let PatKind::Binding(..) = inner.kind\n             && let Some(mt) = self.shallow_resolve(expected).builtin_deref(true)\n             && let ty::Dynamic(..) = mt.ty.kind()\n         {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    let type_str = self.ty_to_string(expected);\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        type_str\n-                    );\n-                    err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n-                    }\n-                    err.emit();\n-                    return false;\n-                }\n-        true\n+            // This is \"x = SomeTrait\" being reduced from\n+            // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+            let type_str = self.ty_to_string(expected);\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                span,\n+                E0033,\n+                \"type `{}` cannot be dereferenced\",\n+                type_str\n+            );\n+            err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n+            }\n+            return Err(err.emit());\n+        }\n+        Ok(())\n     }\n \n     fn check_pat_struct(\n@@ -843,13 +847,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n-        let Some((variant, pat_ty)) = self.check_struct_path(qpath, pat.hir_id) else {\n-            let err = self.tcx.ty_error();\n-            for field in fields {\n-                let ti = ti;\n-                self.check_pat(field.pat, err, def_bm, ti);\n+        let (variant, pat_ty) = match self.check_struct_path(qpath, pat.hir_id) {\n+            Ok(data) => data,\n+            Err(guar) => {\n+                let err = self.tcx.ty_error(guar);\n+                for field in fields {\n+                    let ti = ti;\n+                    self.check_pat(field.pat, err, def_bm, ti);\n+                }\n+                return err;\n             }\n-            return err;\n         };\n \n         // Type-check the path.\n@@ -859,7 +866,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, has_rest_pat, def_bm, ti) {\n             pat_ty\n         } else {\n-            self.tcx.ty_error()\n+            self.tcx.ty_error_misc()\n         }\n     }\n \n@@ -879,12 +886,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Res::Err => {\n                 let e = tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::Variant, _) => {\n                 let expected = \"unit struct, unit variant or constant\";\n                 let e = report_unexpected_variant_res(tcx, res, qpath, pat.span, \"E0533\", expected);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::SelfCtor(..)\n             | Res::Def(\n@@ -1027,7 +1034,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let on_error = |e| {\n             for pat in subpats {\n-                self.check_pat(pat, tcx.ty_error_with_guaranteed(e), def_bm, ti);\n+                self.check_pat(pat, tcx.ty_error(e), def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -1044,27 +1051,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n             self.set_tainted_by_errors(e);\n             on_error(e);\n-            return tcx.ty_error_with_guaranteed(e);\n+            return tcx.ty_error(e);\n         }\n \n         // Type-check the path.\n         let (pat_ty, res) =\n             self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n         if !pat_ty.is_fn() {\n             let e = report_unexpected_res(res);\n-            return tcx.ty_error_with_guaranteed(e);\n+            return tcx.ty_error(e);\n         }\n \n         let variant = match res {\n             Res::Err => {\n                 let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n                 on_error(e);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n                 let e = report_unexpected_res(res);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => tcx.expect_variant_res(res),\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n@@ -1105,7 +1112,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pattern has wrong number of fields.\n             let e = self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n             on_error(e);\n-            return tcx.ty_error_with_guaranteed(e);\n+            return tcx.ty_error(e);\n         }\n         pat_ty\n     }\n@@ -1295,17 +1302,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span },\n             )\n         });\n-        let element_tys = tcx.mk_type_list(element_tys_iter);\n-        let pat_ty = tcx.intern_tup(element_tys);\n+        let element_tys = tcx.mk_type_list_from_iter(element_tys_iter);\n+        let pat_ty = tcx.mk_tup(element_tys);\n         if let Some(mut err) = self.demand_eqtype_pat_diag(span, expected, pat_ty, ti) {\n             let reported = err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n-            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error_with_guaranteed(reported));\n+            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error(reported));\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, tcx.ty_error_with_guaranteed(reported), def_bm, ti);\n+                self.check_pat(elem, tcx.ty_error(reported), def_bm, ti);\n             }\n-            tcx.mk_tup(element_tys_iter)\n+            tcx.mk_tup_from_iter(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n                 self.check_pat(elem, element_tys[i], def_bm, ti);\n@@ -1349,9 +1356,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n-                    self.error_field_already_bound(span, field.ident, *occupied.get());\n                     no_field_errors = false;\n-                    tcx.ty_error()\n+                    let guar = self.error_field_already_bound(span, field.ident, *occupied.get());\n+                    tcx.ty_error(guar)\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n@@ -1365,7 +1372,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .unwrap_or_else(|| {\n                             inexistent_fields.push(field);\n                             no_field_errors = false;\n-                            tcx.ty_error()\n+                            tcx.ty_error_misc()\n                         })\n                 }\n             };\n@@ -1536,7 +1543,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn error_field_already_bound(&self, span: Span, ident: Ident, other_field: Span) {\n+    fn error_field_already_bound(\n+        &self,\n+        span: Span,\n+        ident: Ident,\n+        other_field: Span,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1546,7 +1558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n         .span_label(span, format!(\"multiple uses of `{ident}` in pattern\"))\n         .span_label(other_field, format!(\"first use of `{ident}`\"))\n-        .emit();\n+        .emit()\n     }\n \n     fn error_inexistent_fields(\n@@ -1919,19 +1931,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, inner) {\n-            // Here, `demand::subtype` is good enough, but I don't\n-            // think any errors can be introduced by using `demand::eqtype`.\n-            let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::TypeInference,\n-                span: inner.span,\n-            });\n-            let box_ty = tcx.mk_box(inner_ty);\n-            self.demand_eqtype_pat(span, expected, box_ty, ti);\n-            (box_ty, inner_ty)\n-        } else {\n-            let err = tcx.ty_error();\n-            (err, err)\n+        let (box_ty, inner_ty) = match self.check_dereferenceable(span, expected, inner) {\n+            Ok(()) => {\n+                // Here, `demand::subtype` is good enough, but I don't\n+                // think any errors can be introduced by using `demand::eqtype`.\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span: inner.span,\n+                });\n+                let box_ty = tcx.mk_box(inner_ty);\n+                self.demand_eqtype_pat(span, expected, box_ty, ti);\n+                (box_ty, inner_ty)\n+            }\n+            Err(guar) => {\n+                let err = tcx.ty_error(guar);\n+                (err, err)\n+            }\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n         box_ty\n@@ -1949,37 +1964,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (ref_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, inner) {\n-            // `demand::subtype` would be good enough, but using `eqtype` turns\n-            // out to be equally general. See (note_1) for details.\n-\n-            // Take region, inner-type from expected type if we can,\n-            // to avoid creating needless variables. This also helps with\n-            // the bad interactions of the given hack detailed in (note_1).\n-            debug!(\"check_pat_ref: expected={:?}\", expected);\n-            match *expected.kind() {\n-                ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n-                _ => {\n-                    let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n-                        span: inner.span,\n-                    });\n-                    let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n-                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n-                    let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n-\n-                    // Look for a case like `fn foo(&foo: u32)` and suggest\n-                    // `fn foo(foo: &u32)`\n-                    if let Some(mut err) = err {\n-                        self.borrow_pat_suggestion(&mut err, pat);\n-                        err.emit();\n+        let (ref_ty, inner_ty) = match self.check_dereferenceable(pat.span, expected, inner) {\n+            Ok(()) => {\n+                // `demand::subtype` would be good enough, but using `eqtype` turns\n+                // out to be equally general. See (note_1) for details.\n+\n+                // Take region, inner-type from expected type if we can,\n+                // to avoid creating needless variables. This also helps with\n+                // the bad interactions of the given hack detailed in (note_1).\n+                debug!(\"check_pat_ref: expected={:?}\", expected);\n+                match *expected.kind() {\n+                    ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n+                    _ => {\n+                        let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: inner.span,\n+                        });\n+                        let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n+                        debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n+                        let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n+\n+                        // Look for a case like `fn foo(&foo: u32)` and suggest\n+                        // `fn foo(foo: &u32)`\n+                        if let Some(mut err) = err {\n+                            self.borrow_pat_suggestion(&mut err, pat);\n+                            err.emit();\n+                        }\n+                        (ref_ty, inner_ty)\n                     }\n-                    (ref_ty, inner_ty)\n                 }\n             }\n-        } else {\n-            let err = tcx.ty_error();\n-            (err, err)\n+            Err(guar) => {\n+                let err = tcx.ty_error(guar);\n+                (err, err)\n+            }\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n         ref_ty\n@@ -2027,10 +2045,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Slice(element_ty) => (element_ty, Some(expected), expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n-                if !expected.references_error() {\n-                    self.error_expected_array_or_slice(span, expected, ti);\n-                }\n-                let err = self.tcx.ty_error();\n+                let guar = expected\n+                    .error_reported()\n+                    .err()\n+                    .unwrap_or_else(|| self.error_expected_array_or_slice(span, expected, ti));\n+                let err = self.tcx.ty_error(guar);\n                 (err, Some(err), err)\n             }\n         };\n@@ -2063,7 +2082,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         len: ty::Const<'tcx>,\n         min_len: u64,\n     ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n-        if let Some(len) = len.try_eval_target_usize(self.tcx, self.param_env) {\n+        let guar = if let Some(len) = len.try_eval_target_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n                 // ...and since there is no variable-length pattern,\n@@ -2073,15 +2092,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return (None, arr_ty);\n                 }\n \n-                self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                self.error_scrutinee_inconsistent_length(span, min_len, len)\n             } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n                 return (Some(self.tcx.mk_array(element_ty, pat_len)), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n-                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len);\n+                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len)\n             }\n         } else if slice.is_none() {\n             // We have a pattern with a fixed length,\n@@ -2093,14 +2112,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We have a variable-length pattern and don't know the array length.\n             // This happens if we have e.g.,\n             // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n-            self.error_scrutinee_unfixed_length(span);\n-        }\n+            self.error_scrutinee_unfixed_length(span)\n+        };\n \n         // If we get here, we must have emitted an error.\n-        (Some(self.tcx.ty_error()), arr_ty)\n+        (Some(self.tcx.ty_error(guar)), arr_ty)\n     }\n \n-    fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+    fn error_scrutinee_inconsistent_length(\n+        &self,\n+        span: Span,\n+        min_len: u64,\n+        size: u64,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2111,10 +2135,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             size,\n         )\n         .span_label(span, format!(\"expected {} element{}\", size, pluralize!(size)))\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_scrutinee_with_rest_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+    fn error_scrutinee_with_rest_inconsistent_length(\n+        &self,\n+        span: Span,\n+        min_len: u64,\n+        size: u64,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2128,20 +2157,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             format!(\"pattern cannot match array of {} element{}\", size, pluralize!(size),),\n         )\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_scrutinee_unfixed_length(&self, span: Span) {\n+    fn error_scrutinee_unfixed_length(&self, span: Span) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n             E0730,\n             \"cannot pattern-match on an array without a fixed length\",\n         )\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_expected_array_or_slice(&self, span: Span, expected_ty: Ty<'tcx>, ti: TopInfo<'tcx>) {\n+    fn error_expected_array_or_slice(\n+        &self,\n+        span: Span,\n+        expected_ty: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) -> ErrorGuaranteed {\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2185,7 +2219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         err.span_label(span, format!(\"pattern cannot match with input type `{expected_ty}`\"));\n-        err.emit();\n+        err.emit()\n     }\n \n     fn is_slice_or_array_or_vector(&self, ty: Ty<'tcx>) -> (bool, Ty<'tcx>) {"}, {"sha": "8fcec3363c0be13379ba0797e4e43d67bd3e30dd", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -91,10 +91,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         }\n         let reported = err.emit();\n-        Some((\n-            self.tcx.ty_error_with_guaranteed(reported),\n-            self.tcx.ty_error_with_guaranteed(reported),\n-        ))\n+        Some((self.tcx.ty_error(reported), self.tcx.ty_error(reported)))\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef"}, {"sha": "e94915c754e8f95727f30543e5fd060b56641dd7", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Build a tuple (U0..Un) of the final upvar types U0..Un\n         // and unify the upvar tuple type in the closure with it:\n-        let final_tupled_upvars_type = self.tcx.intern_tup(&final_upvar_tys);\n+        let final_tupled_upvars_type = self.tcx.mk_tup(&final_upvar_tys);\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n         let fake_reads = delegate\n@@ -315,8 +315,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.typeck_results.borrow_mut().closure_size_eval.insert(\n                 closure_def_id,\n                 ClosureSizeProfileData {\n-                    before_feature_tys: self.tcx.intern_tup(&before_feature_tys),\n-                    after_feature_tys: self.tcx.intern_tup(&after_feature_tys),\n+                    before_feature_tys: self.tcx.mk_tup(&before_feature_tys),\n+                    after_feature_tys: self.tcx.mk_tup(&after_feature_tys),\n                 },\n             );\n         }"}, {"sha": "00348f3afdc442a294cf0c7e508ed9cd282de0c4", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -13,8 +13,8 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n-use rustc_middle::ty::fold::{ir::TypeFolder, TypeFoldable, TypeSuperFoldable};\n-use rustc_middle::ty::visit::TypeSuperVisitable;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::TypeckResults;\n use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -561,7 +561,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             struct RecursionChecker {\n                 def_id: LocalDefId,\n             }\n-            impl<'tcx> ty::ir::TypeVisitor<TyCtxt<'tcx>> for RecursionChecker {\n+            impl<'tcx> ty::TypeVisitor<TyCtxt<'tcx>> for RecursionChecker {\n                 type BreakTy = ();\n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                     if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *t.kind() {\n@@ -685,7 +685,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn resolve<T>(&mut self, x: T, span: &dyn Locatable) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let mut resolver = Resolver::new(self.fcx, span, self.body);\n         let x = x.fold_with(&mut resolver);\n@@ -797,7 +797,7 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 let e = self.report_error(t);\n                 self.replaced_with_error = Some(e);\n-                self.interner().ty_error_with_guaranteed(e)\n+                self.interner().ty_error(e)\n             }\n         }\n     }"}, {"sha": "ad89393956e680abf0f5333b671451c265c501e3", "filename": "compiler/rustc_incremental/Cargo.toml", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,16 +6,17 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n-rustc_graphviz = { path = \"../rustc_graphviz\" }\n-tracing = \"0.1\"\n rand = \"0.8.4\"\n-rustc_middle = { path = \"../rustc_middle\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n+rustc_span = { path = \"../rustc_span\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "4852ee0d9595cce228848c111ade539948223938", "filename": "compiler/rustc_incremental/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/incremental.ftl"}, {"sha": "b4b0ea00c50c0d1eaf47e870eaaafb7b369b563f", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::*;\n use rustc_span::symbol::{sym, Symbol};\n+use thin_vec::ThinVec;\n \n #[allow(missing_docs)]\n pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n@@ -138,7 +139,7 @@ impl<'tcx> AssertModuleSource<'tcx> {\n     }\n \n     fn field(&self, attr: &ast::Attribute, name: Symbol) -> Symbol {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;"}, {"sha": "511e466c2aeb1d55d5ab6e4872e3e61945822009", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -31,3 +31,8 @@ pub use persist::save_dep_graph;\n pub use persist::save_work_product_index;\n pub use persist::LoadResult;\n pub use persist::{build_dep_graph, load_dep_graph, DepGraphFuture};\n+\n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "b839416c9195714f5e2b7883edce8c963d7a84ad", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -31,6 +31,8 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use std::iter::FromIterator;\n+use thin_vec::ThinVec;\n \n const LOADED_FROM_DISK: Symbol = sym::loaded_from_disk;\n const EXCEPT: Symbol = sym::except;\n@@ -205,7 +207,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n     /// `loaded_from_disk=` attribute value\n     fn loaded_from_disk(&self, attr: &Attribute) -> Labels {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(LOADED_FROM_DISK) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n@@ -217,7 +219,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n     /// `except=` attribute value\n     fn except(&self, attr: &Attribute) -> Labels {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n@@ -397,7 +399,7 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n     let mut cfg = None;\n-    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+    for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n         if item.has_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);"}, {"sha": "c5b2b6c2d735758dddf390e189091c1e96ba6306", "filename": "compiler/rustc_infer/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl"}, {"sha": "7dccd0bb930c3afded74c9af21e43fd28f39e4e3", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,6 @@\n use hir::GenericParamKind;\n use rustc_errors::{\n-    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n+    AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n     IntoDiagnosticArg, MultiSpan, SubdiagnosticMessage,\n };\n use rustc_hir as hir;\n@@ -12,9 +12,10 @@ use rustc_span::symbol::kw;\n use rustc_span::Symbol;\n use rustc_span::{symbol::Ident, BytePos, Span};\n \n-use crate::infer::error_reporting::nice_region_error::placeholder_error::Highlighted;\n+use crate::fluent_generated as fluent;\n use crate::infer::error_reporting::{\n     need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    nice_region_error::placeholder_error::Highlighted,\n     ObligationCauseAsDiagArg,\n };\n \n@@ -26,9 +27,9 @@ pub struct OpaqueHiddenTypeDiag {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[note(opaque_type)]\n+    #[note(infer_opaque_type)]\n     pub opaque_type: Span,\n-    #[note(hidden_type)]\n+    #[note(infer_hidden_type)]\n     pub hidden_type: Span,\n }\n \n@@ -768,11 +769,11 @@ impl<'tcx> ActualImplExplNotes<'tcx> {\n pub struct TraitPlaceholderMismatch<'tcx> {\n     #[primary_span]\n     pub span: Span,\n-    #[label(label_satisfy)]\n+    #[label(infer_label_satisfy)]\n     pub satisfy_span: Option<Span>,\n-    #[label(label_where)]\n+    #[label(infer_label_where)]\n     pub where_span: Option<Span>,\n-    #[label(label_dup)]\n+    #[label(infer_label_dup)]\n     pub dup_span: Option<Span>,\n     pub def_id: String,\n     pub trait_def_id: String,\n@@ -808,11 +809,11 @@ pub struct RelationshipHelp;\n #[diag(infer_trait_impl_diff)]\n pub struct TraitImplDiff {\n     #[primary_span]\n-    #[label(found)]\n+    #[label(infer_found)]\n     pub sp: Span,\n-    #[label(expected)]\n+    #[label(infer_expected)]\n     pub trait_sp: Span,\n-    #[note(expected_found)]\n+    #[note(infer_expected_found)]\n     pub note: (),\n     #[subdiagnostic]\n     pub param_help: ConsiderBorrowingParamHelp,\n@@ -852,10 +853,10 @@ impl AddToDiagnostic for DynTraitConstraintSuggestion {\n #[derive(Diagnostic)]\n #[diag(infer_but_calling_introduces, code = \"E0772\")]\n pub struct ButCallingIntroduces {\n-    #[label(label1)]\n+    #[label(infer_label1)]\n     pub param_ty_span: Span,\n     #[primary_span]\n-    #[label(label2)]\n+    #[label(infer_label2)]\n     pub cause_span: Span,\n \n     pub has_param_name: bool,\n@@ -913,15 +914,15 @@ impl AddToDiagnostic for MoreTargeted {\n pub struct ButNeedsToSatisfy {\n     #[primary_span]\n     pub sp: Span,\n-    #[label(influencer)]\n+    #[label(infer_influencer)]\n     pub influencer_point: Span,\n-    #[label(used_here)]\n+    #[label(infer_used_here)]\n     pub spans: Vec<Span>,\n-    #[label(require)]\n+    #[label(infer_require)]\n     pub require_span_as_label: Option<Span>,\n-    #[note(require)]\n+    #[note(infer_require)]\n     pub require_span_as_note: Option<Span>,\n-    #[note(introduced_by_bound)]\n+    #[note(infer_introduced_by_bound)]\n     pub bound: Option<Span>,\n \n     #[subdiagnostic]"}, {"sha": "ef543b1fb9353de6e93f22282f08590e17518dd1", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,7 +1,6 @@\n+use crate::fluent_generated as fluent;\n use crate::infer::error_reporting::nice_region_error::find_anon_type;\n-use rustc_errors::{\n-    self, fluent, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, SubdiagnosticMessage,\n-};\n+use rustc_errors::{self, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, SubdiagnosticMessage};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n "}, {"sha": "c952ddc827a4a9d417f058501ce52e7703f1c6c5", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env, define_opaque_types: true }\n+        At { infcx: self, cause, param_env, define_opaque_types: false }\n     }\n \n     /// Forks the inference context, creating a new inference context with the same inference"}, {"sha": "7ffd39de781b46295461ef1f5688518c7cc10aa2", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -10,9 +10,9 @@ use crate::infer::canonical::{\n };\n use crate::infer::InferCtxt;\n use rustc_middle::ty::flags::FlagComputation;\n-use rustc_middle::ty::fold::{ir::TypeFolder, TypeFoldable, TypeSuperFoldable};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::subst::GenericArg;\n-use rustc_middle::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n+use rustc_middle::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags, TypeVisitableExt};\n use std::sync::atomic::Ordering;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -41,7 +41,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonical<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n \n@@ -60,7 +60,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonical<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n \n@@ -100,7 +100,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query-result\n     pub fn canonicalize_response<V>(&self, value: V) -> Canonical<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -114,7 +114,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonical<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -136,7 +136,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonical<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n \n@@ -333,7 +333,7 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n \n     fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.binder_index.shift_in(1);\n         let t = t.super_fold_with(self);\n@@ -530,7 +530,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonical<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::NEEDS_INFER |\n@@ -572,7 +572,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         debug_assert!(!out_value.needs_infer() && !out_value.has_placeholders());\n \n         let canonical_variables =\n-            tcx.intern_canonical_var_infos(&canonicalizer.universe_canonicalized_variables());\n+            tcx.mk_canonical_var_infos(&canonicalizer.universe_canonicalized_variables());\n \n         let max_universe = canonical_variables\n             .iter()"}, {"sha": "8c782a933a5bac8b9ba37e282c03ec0c8c89efba", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -26,7 +26,7 @@ use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVari\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArg;\n-use rustc_middle::ty::{self, List};\n+use rustc_middle::ty::{self, List, TyCtxt};\n use rustc_span::source_map::Span;\n \n pub use rustc_middle::infer::canonical::*;\n@@ -55,7 +55,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         canonical: &Canonical<'tcx, T>,\n     ) -> (T, CanonicalVarValues<'tcx>)\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         // For each universe that is referred to in the incoming\n         // query, create a universe in our local inference context. In\n@@ -88,7 +88,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> CanonicalVarValues<'tcx> {\n         CanonicalVarValues {\n-            var_values: self.tcx.mk_substs(\n+            var_values: self.tcx.mk_substs_from_iter(\n                 variables\n                     .iter()\n                     .map(|info| self.instantiate_canonical_var(span, info, &universe_map)),"}, {"sha": "832af91a4313c5a7228700967dad1d0a4ccb4a1c", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n use std::iter;\n \n@@ -59,7 +59,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Fallible<CanonicalQueryResponse<'tcx, T>>\n     where\n-        T: Debug + TypeFoldable<'tcx>,\n+        T: Debug + TypeFoldable<TyCtxt<'tcx>>,\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n@@ -85,7 +85,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         answer: T,\n     ) -> Canonical<'tcx, QueryResponse<'tcx, T>>\n     where\n-        T: Debug + TypeFoldable<'tcx>,\n+        T: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.canonicalize_response(QueryResponse {\n             var_values: inference_vars,\n@@ -106,7 +106,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Result<QueryResponse<'tcx, T>, NoSolution>\n     where\n-        T: Debug + TypeFoldable<'tcx>,\n+        T: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let tcx = self.tcx;\n \n@@ -180,7 +180,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, R>\n     where\n-        R: Debug + TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let InferOk { value: result_subst, mut obligations } =\n             self.query_response_substitution(cause, param_env, original_values, query_response)?;\n@@ -242,7 +242,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n     ) -> InferResult<'tcx, R>\n     where\n-        R: Debug + TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let InferOk { value: result_subst, mut obligations } = self\n             .query_response_substitution_guess(cause, param_env, original_values, query_response)?;\n@@ -356,7 +356,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n-        R: Debug + TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         debug!(\n             \"query_response_substitution(original_values={:#?}, query_response={:#?})\",\n@@ -393,6 +393,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// will instantiate fresh inference variables for each canonical\n     /// variable instead. Therefore, the result of this method must be\n     /// properly unified\n+    #[instrument(level = \"debug\", skip(self, cause, param_env))]\n     fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -401,13 +402,8 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n-        R: Debug + TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        debug!(\n-            \"query_response_substitution_guess(original_values={:#?}, query_response={:#?})\",\n-            original_values, query_response,\n-        );\n-\n         // For each new universe created in the query result that did\n         // not appear in the original query, create a local\n         // superuniverse.\n@@ -478,8 +474,8 @@ impl<'tcx> InferCtxt<'tcx> {\n         // given variable in the loop above, use that. Otherwise, use\n         // a fresh inference variable.\n         let result_subst = CanonicalVarValues {\n-            var_values: self.tcx.mk_substs(query_response.variables.iter().enumerate().map(\n-                |(index, info)| {\n+            var_values: self.tcx.mk_substs_from_iter(\n+                query_response.variables.iter().enumerate().map(|(index, info)| {\n                     if info.is_existential() {\n                         match opt_values[BoundVar::new(index)] {\n                             Some(k) => k,\n@@ -492,8 +488,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                             universe_map[u.as_usize()]\n                         })\n                     }\n-                },\n-            )),\n+                }),\n+            ),\n         };\n \n         let mut obligations = vec![];\n@@ -502,7 +498,9 @@ impl<'tcx> InferCtxt<'tcx> {\n         for &(a, b) in &query_response.value.opaque_types {\n             let a = substitute_value(self.tcx, &result_subst, a);\n             let b = substitute_value(self.tcx, &result_subst, b);\n-            obligations.extend(self.at(cause, param_env).eq(a, b)?.obligations);\n+            debug!(?a, ?b, \"constrain opaque type\");\n+            obligations\n+                .extend(self.at(cause, param_env).define_opaque_types(true).eq(a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })\n@@ -523,7 +521,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, ()>\n     where\n-        R: Debug + TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n         // A closure that yields the result value for the given\n         // canonical variable; this is taken from\n@@ -683,7 +681,11 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.infcx.create_next_universe()\n     }\n \n-    fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n+    fn next_existential_region_var(\n+        &mut self,\n+        from_forall: bool,\n+        _name: Option<Symbol>,\n+    ) -> ty::Region<'tcx> {\n         let origin = NllRegionVariableOrigin::Existential { from_forall };\n         self.infcx.next_nll_region_var(origin)\n     }"}, {"sha": "c5c6fc41b9e910eb6406a89d10fdc612973302c5", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -16,7 +16,7 @@ pub(super) trait CanonicalExt<'tcx, V> {\n     /// with the value given in `var_values`.\n     fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n-        V: TypeFoldable<'tcx>;\n+        V: TypeFoldable<TyCtxt<'tcx>>;\n \n     /// Allows one to apply a substitute to some subset of\n     /// `self.value`. Invoke `projection_fn` with `self.value` to get\n@@ -31,13 +31,13 @@ pub(super) trait CanonicalExt<'tcx, V> {\n         projection_fn: impl FnOnce(&V) -> T,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>;\n+        T: TypeFoldable<TyCtxt<'tcx>>;\n }\n \n impl<'tcx, V> CanonicalExt<'tcx, V> for Canonical<'tcx, V> {\n     fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n-        V: TypeFoldable<'tcx>,\n+        V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.substitute_projected(tcx, var_values, |value| value.clone())\n     }\n@@ -49,7 +49,7 @@ impl<'tcx, V> CanonicalExt<'tcx, V> for Canonical<'tcx, V> {\n         projection_fn: impl FnOnce(&V) -> T,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         assert_eq!(self.variables.len(), var_values.len());\n         let value = projection_fn(&self.value);\n@@ -66,7 +66,7 @@ pub(super) fn substitute_value<'tcx, T>(\n     value: T,\n ) -> T\n where\n-    T: TypeFoldable<'tcx>,\n+    T: TypeFoldable<TyCtxt<'tcx>>,\n {\n     if var_values.var_values.is_empty() {\n         value"}, {"sha": "33292e871b11cdb0b52593d86f4cc94802c43567", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -40,8 +40,8 @@ use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{\n-    self, ir::FallibleTypeFolder, AliasKind, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable,\n-    TypeSuperFoldable,\n+    self, AliasKind, FallibleTypeFolder, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable,\n+    TypeSuperFoldable, TypeVisitableExt,\n };\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n@@ -478,10 +478,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         self.obligations.extend(obligations.into_iter());\n     }\n \n-    pub fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n-    ) {\n+    pub fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ToPredicate<'tcx>>) {\n         self.obligations.extend(obligations.into_iter().map(|to_pred| {\n             Obligation::new(self.infcx.tcx, self.trace.cause.clone(), self.param_env, to_pred)\n         }))\n@@ -814,10 +811,7 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n     /// Register predicates that must hold in order for this relation to hold. Uses\n     /// a default obligation cause, [`ObligationEmittingRelation::register_obligations`] should\n     /// be used if control over the obligaton causes is required.\n-    fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n-    );\n+    fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ToPredicate<'tcx>>);\n \n     /// Register an obligation that both constants must be equal to each other.\n     ///"}, {"sha": "54a62326ef7bdce1107032e67166fb08bba3b5cd", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,7 +6,7 @@ use super::Subtype;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::TyVar;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n \n use rustc_hir::def_id::DefId;\n \n@@ -201,10 +201,7 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for Equate<'_, '_, 'tcx> {\n-    fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n-    ) {\n+    fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ty::ToPredicate<'tcx>>) {\n         self.fields.register_predicates(obligations);\n     }\n "}, {"sha": "79efc1ce7bfc0fb8c42963bf8eaba2051b7ae324", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -72,7 +72,7 @@ use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n-    TypeVisitable,\n+    TypeVisitable, TypeVisitableExt,\n };\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n@@ -129,21 +129,16 @@ pub(super) fn note_and_explain_region<'tcx>(\n     alt_span: Option<Span>,\n ) {\n     let (description, span) = match *region {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n-            msg_span_from_free_region(tcx, region, alt_span)\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::RePlaceholder(_) | ty::ReStatic => {\n+            msg_span_from_named_region(tcx, region, alt_span)\n         }\n \n-        ty::RePlaceholder(_) => return,\n-\n         ty::ReError(_) => return,\n \n-        // FIXME(#13998) RePlaceholder should probably print like\n-        // ReFree rather than dumping Debug output on the user.\n-        //\n         // We shouldn't really be having unification failures with ReVar\n         // and ReLateBound though.\n         ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-            (format!(\"lifetime {:?}\", region), alt_span)\n+            (format!(\"lifetime `{region}`\"), alt_span)\n         }\n     };\n \n@@ -157,12 +152,12 @@ fn explain_free_region<'tcx>(\n     region: ty::Region<'tcx>,\n     suffix: &str,\n ) {\n-    let (description, span) = msg_span_from_free_region(tcx, region, None);\n+    let (description, span) = msg_span_from_named_region(tcx, region, None);\n \n     label_msg_span(err, prefix, description, span, suffix);\n }\n \n-fn msg_span_from_free_region<'tcx>(\n+fn msg_span_from_named_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     region: ty::Region<'tcx>,\n     alt_span: Option<Span>,\n@@ -173,6 +168,18 @@ fn msg_span_from_free_region<'tcx>(\n             (msg, Some(span))\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            name: ty::BoundRegionKind::BrNamed(def_id, name),\n+            ..\n+        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            name: ty::BoundRegionKind::BrAnon(_, Some(span)),\n+            ..\n+        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            name: ty::BoundRegionKind::BrAnon(_, None),\n+            ..\n+        }) => (format!(\"an anonymous lifetime\"), None),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -918,7 +925,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     ) -> Option<()> {\n         // FIXME/HACK: Go back to `SubstsRef` to use its inherent methods,\n         // ideally that shouldn't be necessary.\n-        let sub = self.tcx.intern_substs(sub);\n+        let sub = self.tcx.mk_substs(sub);\n         for (i, ta) in sub.types().enumerate() {\n             if ta == other_ty {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, other_ty);\n@@ -1443,8 +1450,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         impl<'tcx> OpaqueTypesVisitor<'tcx> {\n             fn visit_expected_found(\n                 tcx: TyCtxt<'tcx>,\n-                expected: impl TypeVisitable<'tcx>,\n-                found: impl TypeVisitable<'tcx>,\n+                expected: impl TypeVisitable<TyCtxt<'tcx>>,\n+                found: impl TypeVisitable<TyCtxt<'tcx>>,\n                 ignore_span: Span,\n             ) -> Self {\n                 let mut types_visitor = OpaqueTypesVisitor {\n@@ -1494,7 +1501,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n         }\n \n-        impl<'tcx> ty::visit::ir::TypeVisitor<TyCtxt<'tcx>> for OpaqueTypesVisitor<'tcx> {\n+        impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for OpaqueTypesVisitor<'tcx> {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 if let Some((kind, def_id)) = TyCategory::from_ty(self.tcx, t) {\n                     let span = self.tcx.def_span(def_id);\n@@ -2199,7 +2206,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\".\n-    fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + TypeFoldable<TyCtxt<'tcx>>>(\n         &self,\n         exp_found: ty::error::ExpectedFound<T>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>"}, {"sha": "e242900fd2329cd158ebcc1fbf5f81b37580c8a8", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -122,7 +122,7 @@ impl InferenceDiagnosticsParentData {\n             tcx.def_key(parent_def_id).disambiguated_data.data.get_opt_name()?.to_string();\n \n         Some(InferenceDiagnosticsParentData {\n-            prefix: tcx.def_kind(parent_def_id).descr(parent_def_id),\n+            prefix: tcx.def_descr(parent_def_id),\n             name: parent_name,\n         })\n     }"}, {"sha": "b06ff10d86eb092d08e4c5e01e43e563950f0601", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -17,8 +17,7 @@ use rustc_hir::{\n     TyKind,\n };\n use rustc_middle::ty::{\n-    self, ir::TypeVisitor, AssocItemContainer, StaticLifetimeVisitor, Ty, TyCtxt,\n-    TypeSuperVisitable,\n+    self, AssocItemContainer, StaticLifetimeVisitor, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::Span;"}, {"sha": "2875448ee157c173f78a5baafc5edd0ed3a5d0be", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n \n-        impl<'tcx> ty::visit::ir::TypeVisitor<TyCtxt<'tcx>> for HighlightBuilder<'tcx> {\n+        impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for HighlightBuilder<'tcx> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 if !r.has_name() && self.counter <= 3 {\n                     self.highlight.highlighting_region(r, self.counter);"}, {"sha": "db4b8af4683e37dd68153668250dfaf197189437", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n     fn includes_region(\n         &self,\n-        ty: Binder<'tcx, impl TypeVisitable<'tcx>>,\n+        ty: Binder<'tcx, impl TypeVisitable<TyCtxt<'tcx>>>,\n         region: ty::BoundRegionKind,\n     ) -> bool {\n         let late_bound_regions = self.tcx().collect_referenced_late_bound_regions(&ty);"}, {"sha": "7ffe1fd20b49ae03b5b33151af67a3ee91c08fe4", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,10 +2,11 @@ use crate::errors::{\n     note_and_explain, FullfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n     RefLongerThanData, RegionOriginNote, WhereClauseSuggestions,\n };\n+use crate::fluent_generated as fluent;\n use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n-    fluent, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic,\n+    AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic,\n };\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::traits::ObligationCauseCode;"}, {"sha": "55dcfd05e0ad38d8df346943dfc903266fb43900", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::traits::{\n     StatementAsExpression,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n+use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitableExt};\n use rustc_span::{sym, BytePos, Span};\n \n use crate::errors::{"}, {"sha": "f09f93abf45d6f7488ef241cb923a51ebbbbd5c7", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -33,8 +33,8 @@\n use super::InferCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::infer::unify_key::ToType;\n-use rustc_middle::ty::fold::ir::TypeFolder;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable};\n+use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitableExt};\n use std::collections::hash_map::Entry;\n \n pub struct TypeFreshener<'a, 'tcx> {"}, {"sha": "86c2c2be4a805000a1f9700aa4a088843323db3e", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,4 +1,4 @@\n-use rustc_middle::ty::fold::{ir::TypeFolder, TypeFoldable, TypeSuperFoldable};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt, TyVid};\n \n use super::type_variable::TypeVariableOrigin;\n@@ -98,7 +98,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn fudge_inference_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce() -> Result<T, E>,\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let variable_lengths = self.variable_lengths();\n         let (mut fudger, value) = self.probe(|_| {"}, {"sha": "49df393d83b3efec5418086a592a121524a8894c", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,7 +7,7 @@ use super::Subtype;\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx, 'tcx> {\n@@ -148,10 +148,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for Glb<'_, '_, 'tcx> {\n-    fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n-    ) {\n+    fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ty::ToPredicate<'tcx>>) {\n         self.fields.register_predicates(obligations);\n     }\n "}, {"sha": "d1897cf24b4a0cc9ffa1c88800561c126ca9e429", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -6,7 +6,7 @@ use super::{HigherRankedType, InferCtxt};\n use crate::infer::CombinedSnapshot;\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::{self, Binder, TypeFoldable};\n+use rustc_middle::ty::{self, Binder, TyCtxt, TypeFoldable};\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     /// Checks whether `for<..> sub <: for<..> sup` holds.\n@@ -72,7 +72,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn instantiate_binder_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n-        T: TypeFoldable<'tcx> + Copy,\n+        T: TypeFoldable<TyCtxt<'tcx>> + Copy,\n     {\n         if let Some(inner) = binder.no_bound_vars() {\n             return inner;"}, {"sha": "335eb4c54062f45983d9b1daabaef700ec290c1e", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1024,7 +1024,7 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n impl<'tcx> LexicalRegionResolutions<'tcx> {\n     fn normalize<T>(&self, tcx: TyCtxt<'tcx>, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         tcx.fold_regions(value, |r, _db| self.resolve_region(tcx, r))\n     }\n@@ -1046,7 +1046,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n             ty::ReVar(rid) => match self.values[rid] {\n                 VarValue::Empty(_) => r,\n                 VarValue::Value(r) => r,\n-                VarValue::ErrorValue => tcx.mk_re_error_misc(),\n+                VarValue::ErrorValue => tcx.lifetimes.re_static,\n             },\n             _ => r,\n         };"}, {"sha": "c871ccb21f8de6a3a4d1790d9e64f04f9c6a67a9", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,7 +7,7 @@ use super::Subtype;\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx, 'tcx> {\n@@ -148,10 +148,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for Lub<'_, '_, 'tcx> {\n-    fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n-    ) {\n+    fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ty::ToPredicate<'tcx>>) {\n         self.fields.register_predicates(obligations);\n     }\n "}, {"sha": "cf8007c964dc04dd0f68afaad1bf3d47a989f321", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -26,10 +26,10 @@ use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BoundVarReplacerDelegate;\n-use rustc_middle::ty::fold::{ir::TypeFolder, TypeFoldable, TypeSuperFoldable};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n pub use rustc_middle::ty::IntVarValue;\n use rustc_middle::ty::{self, GenericParamDefKind, InferConst, InferTy, Ty, TyCtxt};\n use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n@@ -264,7 +264,7 @@ pub struct InferCtxt<'tcx> {\n     /// short lived InferCtxt within queries. The opaque type obligations are forwarded\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n     ///\n-    /// It is default value is `DefiningAnchor::Error`, this way it is easier to catch errors that\n+    /// Its default value is `DefiningAnchor::Error`, this way it is easier to catch errors that\n     /// might come up during inference or typeck.\n     pub defining_use_anchor: DefiningAnchor,\n \n@@ -617,7 +617,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         canonical: &Canonical<'tcx, T>,\n     ) -> (InferCtxt<'tcx>, T, CanonicalVarValues<'tcx>)\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         let infcx = self.build();\n         let (value, subst) = infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n@@ -697,7 +697,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.in_snapshot.get()\n     }\n \n-    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n+    pub fn freshen<T: TypeFoldable<TyCtxt<'tcx>>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n \n@@ -1111,11 +1111,13 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn next_nll_region_var(&self, origin: NllRegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var(RegionVariableOrigin::Nll(origin))\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn next_nll_region_var_in_universe(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -1369,7 +1371,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// will be resolving them as well, e.g. in a loop).\n     pub fn shallow_resolve<T>(&self, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         value.fold_with(&mut ShallowResolver { infcx: self })\n     }\n@@ -1386,7 +1388,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// at will.\n     pub fn resolve_vars_if_possible<T>(&self, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         if !value.has_non_region_infer() {\n             return value;\n@@ -1397,7 +1399,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     pub fn resolve_numeric_literals_with_default<T>(&self, value: T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         if !value.needs_infer() {\n             return value; // Avoid duplicated subst-folding.\n@@ -1412,7 +1414,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         value: &T,\n     ) -> Option<(ty::Term<'tcx>, Option<Span>)>\n     where\n-        T: TypeVisitable<'tcx>,\n+        T: TypeVisitable<TyCtxt<'tcx>>,\n     {\n         value.visit_with(&mut resolve::UnresolvedTypeOrConstFinder::new(self)).break_value()\n     }\n@@ -1427,7 +1429,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n \n-    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: T) -> FixupResult<'tcx, T> {\n+    pub fn fully_resolve<T: TypeFoldable<TyCtxt<'tcx>>>(&self, value: T) -> FixupResult<'tcx, T> {\n         /*!\n          * Attempts to resolve all type/region/const variables in\n          * `value`. Region inference must have been run already (e.g.,\n@@ -1460,7 +1462,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         value: ty::Binder<'tcx, T>,\n     ) -> T\n     where\n-        T: TypeFoldable<'tcx> + Copy,\n+        T: TypeFoldable<TyCtxt<'tcx>> + Copy,\n     {\n         if let Some(inner) = value.no_bound_vars() {\n             return inner;"}, {"sha": "6e413a7f41287a273f64d974c682a684cb2954d3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -29,9 +29,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::visit::{ir::TypeVisitor, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n use std::ops::ControlFlow;\n \n@@ -100,7 +100,11 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// we will invoke this method to instantiate `'a` with an\n     /// inference variable (though `'b` would be instantiated first,\n     /// as a placeholder).\n-    fn next_existential_region_var(&mut self, was_placeholder: bool) -> ty::Region<'tcx>;\n+    fn next_existential_region_var(\n+        &mut self,\n+        was_placeholder: bool,\n+        name: Option<Symbol>,\n+    ) -> ty::Region<'tcx>;\n \n     /// Creates a new region variable representing a\n     /// higher-ranked region that is instantiated universally.\n@@ -188,7 +192,7 @@ where\n                     let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n                     delegate.next_placeholder_region(placeholder)\n                 } else {\n-                    delegate.next_existential_region_var(true)\n+                    delegate.next_existential_region_var(true, br.kind.get_name())\n                 }\n             }\n         };\n@@ -759,10 +763,7 @@ impl<'tcx, D> ObligationEmittingRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n-    ) {\n+    fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ty::ToPredicate<'tcx>>) {\n         self.delegate.register_obligations(\n             obligations\n                 .into_iter()\n@@ -793,7 +794,7 @@ struct ScopeInstantiator<'me, 'tcx> {\n }\n \n impl<'me, 'tcx> TypeVisitor<TyCtxt<'tcx>> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeVisitable<'tcx>>(\n+    fn visit_binder<T: TypeVisitable<TyCtxt<'tcx>>>(\n         &mut self,\n         t: &ty::Binder<'tcx, T>,\n     ) -> ControlFlow<Self::BreakTy> {"}, {"sha": "d5c824d4c41c8e654ba35acc602b19826bf1003b", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -12,8 +12,8 @@ use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::GenericArgKind;\n use rustc_middle::ty::{\n-    self, ir::TypeVisitor, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable,\n-    TypeSuperVisitable, TypeVisitable,\n+    self, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n+    TypeVisitable, TypeVisitableExt, TypeVisitor,\n };\n use rustc_span::Span;\n \n@@ -45,7 +45,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n impl<'tcx> InferCtxt<'tcx> {\n     /// This is a backwards compatibility hack to prevent breaking changes from\n     /// lazy TAIT around RPIT handling.\n-    pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<'tcx>>(\n+    pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<TyCtxt<'tcx>>>(\n         &self,\n         value: T,\n         body_id: LocalDefId,\n@@ -427,7 +427,7 @@ impl<'tcx, OP> TypeVisitor<TyCtxt<'tcx>> for ConstrainOpaqueTypeRegionVisitor<'t\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n-    fn visit_binder<T: TypeVisitable<'tcx>>(\n+    fn visit_binder<T: TypeVisitable<TyCtxt<'tcx>>>(\n         &mut self,\n         t: &ty::Binder<'tcx, T>,\n     ) -> ControlFlow<Self::BreakTy> {\n@@ -545,8 +545,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             origin,\n         );\n         if let Some(prev) = prev {\n-            obligations =\n-                self.at(&cause, param_env).eq_exp(a_is_expected, prev, hidden_ty)?.obligations;\n+            obligations = self\n+                .at(&cause, param_env)\n+                .define_opaque_types(true)\n+                .eq_exp(a_is_expected, prev, hidden_ty)?\n+                .obligations;\n         }\n \n         let item_bounds = tcx.bound_explicit_item_bounds(def_id.to_def_id());"}, {"sha": "ff23087fe8d8aae4d4582d4424068f0e6e5d625a", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -4,7 +4,7 @@\n \n use rustc_data_structures::sso::SsoHashSet;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use smallvec::{smallvec, SmallVec};\n \n #[derive(Debug)]"}, {"sha": "bbe7d4c63f7947937c8ba37015410e4e3bc17f60", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -69,7 +69,7 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n use smallvec::smallvec;\n \n impl<'tcx> InferCtxt<'tcx> {"}, {"sha": "3c6cc2b90010f664f9d427b687f20f06ad49c41d", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,7 +1,7 @@\n use std::collections::hash_map::Entry;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::TypeVisitable;\n+use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{\n     self,\n     error::TypeError,\n@@ -186,7 +186,8 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, pattern: Ty<'tcx>, value: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        if let ty::Error(_) = pattern.kind() {\n+        // FIXME(non_lifetime_binders): What to do here?\n+        if matches!(pattern.kind(), ty::Error(_) | ty::Bound(..)) {\n             // Unlike normal `TypeRelation` rules, `ty::Error` does not equal any type.\n             self.no_match()\n         } else if pattern == value {"}, {"sha": "5bb35832930bf88c86170c3ec1807ff4be774b22", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,11 +1,8 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::fold::{\n-    ir::{FallibleTypeFolder, TypeFolder},\n-    TypeSuperFoldable,\n-};\n-use rustc_middle::ty::visit::{ir::TypeVisitor, TypeSuperVisitable};\n+use rustc_middle::ty::fold::{FallibleTypeFolder, TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitableExt, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n use std::ops::ControlFlow;\n@@ -200,7 +197,7 @@ impl<'a, 'tcx> TypeVisitor<TyCtxt<'tcx>> for UnresolvedTypeOrConstFinder<'a, 'tc\n /// then an `Err` result is returned.\n pub fn fully_resolve<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> FixupResult<'tcx, T>\n where\n-    T: TypeFoldable<'tcx>,\n+    T: TypeFoldable<TyCtxt<'tcx>>,\n {\n     value.try_fold_with(&mut FullTypeResolver { infcx })\n }"}, {"sha": "3e8c2052de89d7135790f2b4b936222d035137a1", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -3,7 +3,7 @@ use super::{ObligationEmittingRelation, SubregionOrigin};\n \n use crate::traits::{Obligation, PredicateObligations};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::TyVar;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::mem;\n@@ -126,7 +126,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n \n             (&ty::Error(e), _) | (_, &ty::Error(e)) => {\n                 infcx.set_tainted_by_errors(e);\n-                Ok(self.tcx().ty_error_with_guaranteed(e))\n+                Ok(self.tcx().ty_error(e))\n             }\n \n             (\n@@ -228,10 +228,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for Sub<'_, '_, 'tcx> {\n-    fn register_predicates(\n-        &mut self,\n-        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n-    ) {\n+    fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ty::ToPredicate<'tcx>>) {\n         self.fields.register_predicates(obligations);\n     }\n "}, {"sha": "bdc313c2141467d332dc2869842408f7dc4e5c55", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -13,6 +13,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(extend_one)]\n@@ -33,6 +34,11 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n+\n mod errors;\n pub mod infer;\n pub mod traits;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "3a5273b0359e4a1aa01a5571f95ab98f8adf69b5", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,7 +2,7 @@ use crate::traits;\n use crate::traits::project::Normalized;\n use rustc_middle::ty::fold::{FallibleTypeFolder, TypeFoldable};\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitor};\n-use rustc_middle::ty::{self, ir, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n \n use std::fmt;\n use std::ops::ControlFlow;\n@@ -61,8 +61,13 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n-impl<'tcx, O: TypeFoldable<'tcx>> ir::TypeFoldable<TyCtxt<'tcx>> for traits::Obligation<'tcx, O> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+impl<'tcx, O: TypeFoldable<TyCtxt<'tcx>>> TypeFoldable<TyCtxt<'tcx>>\n+    for traits::Obligation<'tcx, O>\n+{\n+    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(traits::Obligation {\n             cause: self.cause,\n             recursion_depth: self.recursion_depth,\n@@ -72,8 +77,10 @@ impl<'tcx, O: TypeFoldable<'tcx>> ir::TypeFoldable<TyCtxt<'tcx>> for traits::Obl\n     }\n }\n \n-impl<'tcx, O: TypeVisitable<'tcx>> ir::TypeVisitable<TyCtxt<'tcx>> for traits::Obligation<'tcx, O> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+impl<'tcx, O: TypeVisitable<TyCtxt<'tcx>>> TypeVisitable<TyCtxt<'tcx>>\n+    for traits::Obligation<'tcx, O>\n+{\n+    fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.predicate.visit_with(visitor)?;\n         self.param_env.visit_with(visitor)\n     }"}, {"sha": "c07ff516579947859dd597b946a467b43abf893b", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -116,11 +116,11 @@ pub fn elaborate_predicates_with_span<'tcx>(\n \n pub fn elaborate_obligations<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    mut obligations: Vec<PredicateObligation<'tcx>>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let mut visited = PredicateSet::new(tcx);\n-    obligations.retain(|obligation| visited.insert(obligation.predicate));\n-    Elaborator { stack: obligations, visited }\n+    let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n+    elaborator.extend_deduped(obligations);\n+    elaborator\n }\n \n fn predicate_obligation<'tcx>(\n@@ -132,6 +132,15 @@ fn predicate_obligation<'tcx>(\n }\n \n impl<'tcx> Elaborator<'tcx> {\n+    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>) {\n+        // Only keep those bounds that we haven't already seen.\n+        // This is necessary to prevent infinite recursion in some\n+        // cases. One common case is when people define\n+        // `trait Sized: Sized { }` rather than `trait Sized { }`.\n+        // let visited = &mut self.visited;\n+        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n+    }\n+\n     pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n@@ -172,15 +181,7 @@ impl<'tcx> Elaborator<'tcx> {\n                         )\n                     });\n                 debug!(?data, ?obligations, \"super_predicates\");\n-\n-                // Only keep those bounds that we haven't already seen.\n-                // This is necessary to prevent infinite recursion in some\n-                // cases. One common case is when people define\n-                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n-                let visited = &mut self.visited;\n-                let obligations = obligations.filter(|o| visited.insert(o.predicate));\n-\n-                self.stack.extend(obligations);\n+                self.extend_deduped(obligations);\n             }\n             ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n@@ -237,10 +238,9 @@ impl<'tcx> Elaborator<'tcx> {\n                     return;\n                 }\n \n-                let visited = &mut self.visited;\n                 let mut components = smallvec![];\n                 push_outlives_components(tcx, ty_max, &mut components);\n-                self.stack.extend(\n+                self.extend_deduped(\n                     components\n                         .into_iter()\n                         .filter_map(|component| match component {\n@@ -280,7 +280,6 @@ impl<'tcx> Elaborator<'tcx> {\n                         .map(|predicate_kind| {\n                             bound_predicate.rebind(predicate_kind).to_predicate(tcx)\n                         })\n-                        .filter(|&predicate| visited.insert(predicate))\n                         .map(|predicate| {\n                             predicate_obligation(\n                                 predicate,"}, {"sha": "da58492ccf27c6bbe76c4ff327fd2cfaaaa3e1bd", "filename": "compiler/rustc_interface/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -11,10 +11,6 @@ interface_mixed_bin_crate =\n interface_mixed_proc_macro_crate =\n     cannot mix `proc-macro` crate type with others\n \n-interface_proc_macro_doc_without_arg =\n-    Trying to document proc macro crate without passing '--crate-type proc-macro to rustdoc\n-    .warn = The generated documentation may be incorrect\n-\n interface_error_writing_dependencies =\n     error writing dependencies to `{$path}`: {$error}\n ", "previous_filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl"}, {"sha": "0eedee250269e4cfc0481b57996b558574142430", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -31,10 +31,6 @@ pub struct MixedBinCrate;\n #[diag(interface_mixed_proc_macro_crate)]\n pub struct MixedProcMacroCrate;\n \n-#[derive(Diagnostic)]\n-#[diag(interface_proc_macro_doc_without_arg)]\n-pub struct ProcMacroDocWithoutArg;\n-\n #[derive(Diagnostic)]\n #[diag(interface_error_writing_dependencies)]\n pub struct ErrorWritingDependencies<'a> {"}, {"sha": "5e38ca034ac1ffd9797b75ed3a5ef38059a08ce0", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -222,6 +222,7 @@ pub struct Config {\n     pub output_dir: Option<PathBuf>,\n     pub output_file: Option<PathBuf>,\n     pub file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    pub locale_resources: &'static [&'static str],\n \n     pub lint_caps: FxHashMap<lint::LintId, lint::Level>,\n \n@@ -267,6 +268,7 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n                 config.opts,\n                 config.crate_cfg,\n                 config.crate_check_cfg,\n+                config.locale_resources,\n                 config.file_loader,\n                 CompilerIO {\n                     input: config.input,"}, {"sha": "1abbe8d4fabef80e2148eb32352fc3978fd5df11", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -12,6 +12,9 @@\n #[macro_use]\n extern crate tracing;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n+\n mod callbacks;\n mod errors;\n pub mod interface;\n@@ -27,3 +30,5 @@ pub use queries::Queries;\n \n #[cfg(test)]\n mod tests;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "81c1d665ef0726a60e8061b64673444f2f134792", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -287,28 +287,18 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         sess.emit_warning(errors::ProcMacroCratePanicAbort);\n     }\n \n-    // For backwards compatibility, we don't try to run proc macro injection\n-    // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n-    // specified. This should only affect users who manually invoke 'rustdoc', as\n-    // 'cargo doc' will automatically pass the proper '--crate-type' flags.\n-    // However, we do emit a warning, to let such users know that they should\n-    // start passing '--crate-type proc-macro'\n-    if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n-        sess.emit_warning(errors::ProcMacroDocWithoutArg);\n-    } else {\n-        krate = sess.time(\"maybe_create_a_macro_crate\", || {\n-            let is_test_crate = sess.opts.test;\n-            rustc_builtin_macros::proc_macro_harness::inject(\n-                sess,\n-                resolver,\n-                krate,\n-                is_proc_macro_crate,\n-                has_proc_macro_decls,\n-                is_test_crate,\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n+    krate = sess.time(\"maybe_create_a_macro_crate\", || {\n+        let is_test_crate = sess.opts.test;\n+        rustc_builtin_macros::proc_macro_harness::inject(\n+            sess,\n+            resolver,\n+            krate,\n+            is_proc_macro_crate,\n+            has_proc_macro_decls,\n+            is_test_crate,\n+            sess.diagnostic(),\n+        )\n+    });\n \n     // Done with macro expansion!\n "}, {"sha": "a96cc95a38446666304d170be928beeead074b0a", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,11 +7,10 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{Lrc, OnceCell, RwLock, WorkerLocal};\n+use rustc_data_structures::sync::{AppendOnlyVec, Lrc, OnceCell, RwLock, WorkerLocal};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_incremental::DepGraphFuture;\n-use rustc_index::vec::IndexVec;\n use rustc_lint::LintStore;\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n@@ -195,10 +194,9 @@ impl<'tcx> Queries<'tcx> {\n \n             let cstore = RwLock::new(Box::new(CStore::new(sess)) as _);\n             let definitions = RwLock::new(Definitions::new(sess.local_stable_crate_id()));\n-            let mut source_span = IndexVec::default();\n+            let source_span = AppendOnlyVec::new();\n             let _id = source_span.push(krate.spans.inner_span);\n             debug_assert_eq!(_id, CRATE_DEF_ID);\n-            let source_span = RwLock::new(source_span);\n             let untracked = Untracked { cstore, source_span, definitions };\n \n             let qcx = passes::create_global_ctxt("}, {"sha": "18d84a7023aa14ef4ca7a0f00c320db9456264ba", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -50,7 +50,7 @@ fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n         output_file: None,\n         temps_dir,\n     };\n-    let sess = build_session(sessopts, io, None, registry, Default::default(), None, None);\n+    let sess = build_session(sessopts, io, None, registry, vec![], Default::default(), None, None);\n     (sess, cfg)\n }\n \n@@ -756,6 +756,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(instrument_coverage, Some(InstrumentCoverage::All));\n     tracked!(instrument_mcount, true);\n     tracked!(instrument_xray, Some(InstrumentXRay::default()));\n+    tracked!(link_directives, false);\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });\n@@ -776,7 +777,6 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(packed_bundled_libs, true);\n     tracked!(panic_abort_tests, true);\n     tracked!(panic_in_drop, PanicStrategy::Abort);\n-    tracked!(pick_stable_methods_before_any_unstable, false);\n     tracked!(plt, Some(true));\n     tracked!(polonius, true);\n     tracked!(precise_enum_drop_elaboration, false);"}, {"sha": "e5d2fb2ea280757cbb8ed568062aa45fcdae96ef", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -59,6 +59,7 @@ pub fn create_session(\n     sopts: config::Options,\n     cfg: FxHashSet<(String, Option<String>)>,\n     check_cfg: CheckCfg,\n+    locale_resources: &'static [&'static str],\n     file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n     io: CompilerIO,\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n@@ -89,11 +90,15 @@ pub fn create_session(\n         }\n     };\n \n+    let mut locale_resources = Vec::from(locale_resources);\n+    locale_resources.push(codegen_backend.locale_resource());\n+\n     let mut sess = session::build_session(\n         sopts,\n         io,\n         bundle,\n         descriptions,\n+        locale_resources,\n         lint_caps,\n         file_loader,\n         target_override,"}, {"sha": "68e62c9789aed9fda1e5a0118d1642cd4f8c6f95", "filename": "compiler/rustc_lint/locales/en-US.ftl", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -24,6 +24,13 @@ lint_for_loops_over_fallibles =\n     .use_while_let = to check pattern in a loop use `while let`\n     .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n \n+lint_map_unit_fn = `Iterator::map` call that discard the iterator's values\n+    .note = `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+    .function_label = this function returns `()`, which is likely not what you wanted\n+    .argument_label = called `Iterator::map` with callable that returns `()`\n+    .map_label = after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+    .suggestion = you might have meant to use `Iterator::for_each`\n+\n lint_non_binding_let_on_sync_lock =\n     non-binding let on a synchronization lock\n ", "previous_filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl"}, {"sha": "bccb0a94e986d493c7a251eafb02bbef5e46ebbf", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,5 +1,7 @@\n-use crate::lints::{ArrayIntoIterDiag, ArrayIntoIterDiagSub};\n-use crate::{LateContext, LateLintPass, LintContext};\n+use crate::{\n+    lints::{ArrayIntoIterDiag, ArrayIntoIterDiagSub},\n+    LateContext, LateLintPass, LintContext,\n+};\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};"}, {"sha": "59540aaf18fc5b778af3386cf16ae4e05c73fc68", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -20,6 +20,7 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n+use crate::fluent_generated as fluent;\n use crate::{\n     errors::BuiltinEllpisisInclusiveRangePatterns,\n     lints::{\n@@ -50,7 +51,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{fluent, Applicability, DecorateLint, MultiSpan};\n+use rustc_errors::{Applicability, DecorateLint, MultiSpan};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -676,21 +677,21 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(item.owner_id);\n-                (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n+                (def, cx.tcx.mk_adt(def, ty::List::empty()))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(item.owner_id);\n-                (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n+                (def, cx.tcx.mk_adt(def, ty::List::empty()))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(item.owner_id);\n-                (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n+                (def, cx.tcx.mk_adt(def, ty::List::empty()))\n             }\n             _ => return,\n         };\n@@ -1583,7 +1584,7 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc_middle::ty::visit::TypeVisitable;\n+        use rustc_middle::ty::visit::TypeVisitableExt;\n         use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n@@ -2635,7 +2636,13 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 cx.emit_spanned_lint(\n                     INVALID_VALUE,\n                     expr.span,\n-                    BuiltinUnpermittedTypeInit { msg, ty: conjured_ty, label: expr.span, sub },\n+                    BuiltinUnpermittedTypeInit {\n+                        msg,\n+                        ty: conjured_ty,\n+                        label: expr.span,\n+                        sub,\n+                        tcx: cx.tcx,\n+                    },\n                 );\n             }\n         }"}, {"sha": "f1ba192f2bcc02e6c026720a95df4dd6304a12ed", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -4,7 +4,7 @@ use crate::{\n     LateContext, LateLintPass,\n };\n use rustc_hir as hir;\n-use rustc_middle::ty::{visit::TypeVisitable, Ty};\n+use rustc_middle::ty::{visit::TypeVisitableExt, Ty};\n use rustc_span::{symbol::sym, Span};\n \n declare_lint! {"}, {"sha": "9af5284df1e2959148c460466c97c96af3d82e90", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,6 +1,6 @@\n+use crate::fluent_generated as fluent;\n use rustc_errors::{\n-    fluent, AddToDiagnostic, Diagnostic, ErrorGuaranteed, Handler, IntoDiagnostic,\n-    SubdiagnosticMessage,\n+    AddToDiagnostic, Diagnostic, ErrorGuaranteed, Handler, IntoDiagnostic, SubdiagnosticMessage,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::lint::Level;\n@@ -116,7 +116,7 @@ impl IntoDiagnostic<'_> for CheckNameUnknown {\n         let mut diag = handler.struct_err(fluent::lint_check_name_unknown);\n         diag.code(rustc_errors::error_code!(E0602));\n         if let Some(suggestion) = self.suggestion {\n-            diag.help(fluent::help);\n+            diag.help(fluent::lint_help);\n             diag.set_arg(\"suggestion\", suggestion);\n         }\n         diag.set_arg(\"lint_name\", self.lint_name);"}, {"sha": "bc7488fab4a5c995bdd69d3df9eb5828f5300273", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,13 +1,16 @@\n-use crate::context::{CheckLintNameResult, LintStore};\n-use crate::late::unerased_lint_store;\n-use crate::lints::{\n-    DeprecatedLintName, IgnoredUnlessCrateSpecified, OverruledAtributeLint, RenamedOrRemovedLint,\n-    RenamedOrRemovedLintSuggestion, UnknownLint, UnknownLintSuggestion,\n+use crate::{\n+    context::{CheckLintNameResult, LintStore},\n+    fluent_generated as fluent,\n+    late::unerased_lint_store,\n+    lints::{\n+        DeprecatedLintName, IgnoredUnlessCrateSpecified, OverruledAtributeLint,\n+        RenamedOrRemovedLint, RenamedOrRemovedLintSuggestion, UnknownLint, UnknownLintSuggestion,\n+    },\n };\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, DecorateLint, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n+use rustc_errors::{DecorateLint, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirId;\n@@ -983,7 +986,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     fluent::lint_unknown_gated_lint,\n                     |lint| {\n                         lint.set_arg(\"name\", lint_id.lint.name_lower());\n-                        lint.note(fluent::note);\n+                        lint.note(fluent::lint_note);\n                         add_feature_diagnostics(lint, &self.sess.parse_sess, feature);\n                         lint\n                     },"}, {"sha": "35dc533e56c24ea900ad26f4ed9bd11850d46d11", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -63,6 +63,7 @@ mod late;\n mod let_underscore;\n mod levels;\n mod lints;\n+mod map_unit_fn;\n mod methods;\n mod multiple_supertrait_upcastable;\n mod non_ascii_idents;\n@@ -80,8 +81,10 @@ mod unused;\n pub use array_into_iter::ARRAY_INTO_ITER;\n \n use rustc_ast as ast;\n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n+use rustc_macros::fluent_messages;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n@@ -98,6 +101,7 @@ use for_loops_over_fallibles::*;\n use hidden_unicode_codepoints::*;\n use internal::*;\n use let_underscore::*;\n+use map_unit_fn::*;\n use methods::*;\n use multiple_supertrait_upcastable::*;\n use non_ascii_idents::*;\n@@ -122,6 +126,8 @@ pub use rustc_session::lint::Level::{self, *};\n pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Lint, LintId};\n pub use rustc_session::lint::{LintArray, LintPass};\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n pub fn provide(providers: &mut Providers) {\n     levels::provide(providers);\n     expect::provide(providers);\n@@ -235,6 +241,7 @@ late_lint_methods!(\n             NamedAsmLabels: NamedAsmLabels,\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n             MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n+            MapUnitFn: MapUnitFn,\n         ]\n     ]\n );\n@@ -294,7 +301,8 @@ fn register_builtins(store: &mut LintStore) {\n         UNUSED_LABELS,\n         UNUSED_PARENS,\n         UNUSED_BRACES,\n-        REDUNDANT_SEMICOLONS\n+        REDUNDANT_SEMICOLONS,\n+        MAP_UNIT_FN\n     );\n \n     add_lint_group!(\"let_underscore\", LET_UNDERSCORE_DROP, LET_UNDERSCORE_LOCK);"}, {"sha": "20ab0af5856518a22d7099d3c3160849f59f555e", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 89, "deletions": 60, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,13 +2,16 @@\n #![allow(rustc::diagnostic_outside_of_impl)]\n use std::num::NonZeroU32;\n \n+use crate::fluent_generated as fluent;\n use rustc_errors::{\n-    fluent, AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage,\n-    DiagnosticStyledString, SuggestionStyle,\n+    AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage, DiagnosticStyledString,\n+    SuggestionStyle,\n };\n use rustc_hir::def_id::DefId;\n use rustc_macros::{LintDiagnostic, Subdiagnostic};\n-use rustc_middle::ty::{PolyExistentialTraitRef, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    inhabitedness::InhabitedPredicate, PolyExistentialTraitRef, Predicate, Ty, TyCtxt,\n+};\n use rustc_session::parse::ParseSess;\n use rustc_span::{edition::Edition, sym, symbol::Ident, Span, Symbol};\n \n@@ -21,20 +24,23 @@ use crate::{\n #[diag(lint_array_into_iter)]\n pub struct ArrayIntoIterDiag<'a> {\n     pub target: &'a str,\n-    #[suggestion(use_iter_suggestion, code = \"iter\", applicability = \"machine-applicable\")]\n+    #[suggestion(lint_use_iter_suggestion, code = \"iter\", applicability = \"machine-applicable\")]\n     pub suggestion: Span,\n     #[subdiagnostic]\n     pub sub: Option<ArrayIntoIterDiagSub>,\n }\n \n #[derive(Subdiagnostic)]\n pub enum ArrayIntoIterDiagSub {\n-    #[suggestion(remove_into_iter_suggestion, code = \"\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(lint_remove_into_iter_suggestion, code = \"\", applicability = \"maybe-incorrect\")]\n     RemoveIntoIter {\n         #[primary_span]\n         span: Span,\n     },\n-    #[multipart_suggestion(use_explicit_into_iter_suggestion, applicability = \"maybe-incorrect\")]\n+    #[multipart_suggestion(\n+        lint_use_explicit_into_iter_suggestion,\n+        applicability = \"maybe-incorrect\"\n+    )]\n     UseExplicitIntoIter {\n         #[suggestion_part(code = \"IntoIterator::into_iter(\")]\n         start_span: Span,\n@@ -161,13 +167,13 @@ pub struct BuiltinDeprecatedAttrLink<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum BuiltinDeprecatedAttrLinkSuggestion<'a> {\n-    #[suggestion(msg_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    #[suggestion(lint_msg_suggestion, code = \"\", applicability = \"machine-applicable\")]\n     Msg {\n         #[primary_span]\n         suggestion: Span,\n         msg: &'a str,\n     },\n-    #[suggestion(default_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    #[suggestion(lint_default_suggestion, code = \"\", applicability = \"machine-applicable\")]\n     Default {\n         #[primary_span]\n         suggestion: Span,\n@@ -199,9 +205,9 @@ pub struct BuiltinUnusedDocComment<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum BuiltinUnusedDocCommentSub {\n-    #[help(plain_help)]\n+    #[help(lint_plain_help)]\n     PlainHelp,\n-    #[help(block_help)]\n+    #[help(lint_block_help)]\n     BlockHelp,\n }\n \n@@ -240,7 +246,7 @@ impl<'a> DecorateLint<'a, ()> for BuiltinUngatedAsyncFnTrackCaller<'_> {\n         self,\n         diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n     ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n-        diag.span_label(self.label, fluent::label);\n+        diag.span_label(self.label, fluent::lint_label);\n         rustc_session::parse::add_feature_diagnostics(\n             diag,\n             &self.parse_sess,\n@@ -335,7 +341,7 @@ impl AddToDiagnostic for BuiltinTypeAliasGenericBoundsSuggestion {\n         ) -> rustc_errors::SubdiagnosticMessage,\n     {\n         diag.multipart_suggestion(\n-            fluent::suggestion,\n+            fluent::lint_suggestion,\n             self.suggestions,\n             Applicability::MachineApplicable,\n         );\n@@ -386,7 +392,7 @@ pub struct BuiltinExplicitOutlives {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(suggestion)]\n+#[multipart_suggestion(lint_suggestion)]\n pub struct BuiltinExplicitOutlivesSuggestion {\n     #[suggestion_part(code = \"\")]\n     pub spans: Vec<Span>,\n@@ -405,11 +411,11 @@ pub struct BuiltinIncompleteFeatures {\n }\n \n #[derive(Subdiagnostic)]\n-#[help(help)]\n+#[help(lint_help)]\n pub struct BuiltinIncompleteFeaturesHelp;\n \n #[derive(Subdiagnostic)]\n-#[note(note)]\n+#[note(lint_note)]\n pub struct BuiltinIncompleteFeaturesNote {\n     pub n: NonZeroU32,\n }\n@@ -419,6 +425,7 @@ pub struct BuiltinUnpermittedTypeInit<'a> {\n     pub ty: Ty<'a>,\n     pub label: Span,\n     pub sub: BuiltinUnpermittedTypeInitSub,\n+    pub tcx: TyCtxt<'a>,\n }\n \n impl<'a> DecorateLint<'a, ()> for BuiltinUnpermittedTypeInit<'_> {\n@@ -428,7 +435,13 @@ impl<'a> DecorateLint<'a, ()> for BuiltinUnpermittedTypeInit<'_> {\n     ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n         diag.set_arg(\"ty\", self.ty);\n         diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label);\n-        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label_suggestion);\n+        if let InhabitedPredicate::True = self.ty.inhabited_predicate(self.tcx) {\n+            // Only suggest late `MaybeUninit::assume_init` initialization if the type is inhabited.\n+            diag.span_label(\n+                self.label,\n+                fluent::lint_builtin_unpermitted_type_init_label_suggestion,\n+            );\n+        }\n         self.sub.add_to_diagnostic(diag);\n         diag\n     }\n@@ -473,9 +486,9 @@ pub enum BuiltinClashingExtern<'a> {\n     SameName {\n         this: Symbol,\n         orig: Symbol,\n-        #[label(previous_decl_label)]\n+        #[label(lint_previous_decl_label)]\n         previous_decl_label: Span,\n-        #[label(mismatch_label)]\n+        #[label(lint_mismatch_label)]\n         mismatch_label: Span,\n         #[subdiagnostic]\n         sub: BuiltinClashingExternSub<'a>,\n@@ -484,9 +497,9 @@ pub enum BuiltinClashingExtern<'a> {\n     DiffName {\n         this: Symbol,\n         orig: Symbol,\n-        #[label(previous_decl_label)]\n+        #[label(lint_previous_decl_label)]\n         previous_decl_label: Span,\n-        #[label(mismatch_label)]\n+        #[label(lint_mismatch_label)]\n         mismatch_label: Span,\n         #[subdiagnostic]\n         sub: BuiltinClashingExternSub<'a>,\n@@ -562,7 +575,7 @@ pub struct SupertraitAsDerefTarget<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(label)]\n+#[label(lint_label)]\n pub struct SupertraitAsDerefTargetLabel {\n     #[primary_span]\n     pub label: Span,\n@@ -595,7 +608,7 @@ pub struct Expectation {\n }\n \n #[derive(Subdiagnostic)]\n-#[note(rationale)]\n+#[note(lint_rationale)]\n pub struct ExpectationNote {\n     pub rationale: Symbol,\n }\n@@ -616,13 +629,13 @@ pub struct ForLoopsOverFalliblesDiag<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum ForLoopsOverFalliblesLoopSub<'a> {\n-    #[suggestion(remove_next, code = \".by_ref()\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(lint_remove_next, code = \".by_ref()\", applicability = \"maybe-incorrect\")]\n     RemoveNext {\n         #[primary_span]\n         suggestion: Span,\n         recv_snip: String,\n     },\n-    #[multipart_suggestion(use_while_let, applicability = \"maybe-incorrect\")]\n+    #[multipart_suggestion(lint_use_while_let, applicability = \"maybe-incorrect\")]\n     UseWhileLet {\n         #[suggestion_part(code = \"while let {var}(\")]\n         start_span: Span,\n@@ -633,14 +646,14 @@ pub enum ForLoopsOverFalliblesLoopSub<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(use_question_mark, code = \"?\", applicability = \"maybe-incorrect\")]\n+#[suggestion(lint_use_question_mark, code = \"?\", applicability = \"maybe-incorrect\")]\n pub struct ForLoopsOverFalliblesQuestionMark {\n     #[primary_span]\n     pub suggestion: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(lint_suggestion, applicability = \"maybe-incorrect\")]\n pub struct ForLoopsOverFalliblesSuggestion<'a> {\n     pub var: &'a str,\n     #[suggestion_part(code = \"if let {var}(\")]\n@@ -699,13 +712,13 @@ impl AddToDiagnostic for HiddenUnicodeCodepointsDiagSub {\n         match self {\n             HiddenUnicodeCodepointsDiagSub::Escape { spans } => {\n                 diag.multipart_suggestion_with_style(\n-                    fluent::suggestion_remove,\n+                    fluent::lint_suggestion_remove,\n                     spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n                     Applicability::MachineApplicable,\n                     SuggestionStyle::HideCodeAlways,\n                 );\n                 diag.multipart_suggestion(\n-                    fluent::suggestion_escape,\n+                    fluent::lint_suggestion_escape,\n                     spans\n                         .into_iter()\n                         .map(|(c, span)| {\n@@ -728,13 +741,29 @@ impl AddToDiagnostic for HiddenUnicodeCodepointsDiagSub {\n                         .collect::<Vec<String>>()\n                         .join(\", \"),\n                 );\n-                diag.note(fluent::suggestion_remove);\n-                diag.note(fluent::no_suggestion_note_escape);\n+                diag.note(fluent::lint_suggestion_remove);\n+                diag.note(fluent::lint_no_suggestion_note_escape);\n             }\n         }\n     }\n }\n \n+// map_unit_fn.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_map_unit_fn)]\n+#[note]\n+pub struct MappingToUnit {\n+    #[label(lint_function_label)]\n+    pub function_label: Span,\n+    #[label(lint_argument_label)]\n+    pub argument_label: Span,\n+    #[label(lint_map_label)]\n+    pub map_label: Span,\n+    #[suggestion(style = \"verbose\", code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+    pub replace: String,\n+}\n+\n // internal.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_default_hash_types)]\n@@ -874,7 +903,7 @@ pub struct RenamedOrRemovedLint<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(suggestion, code = \"{replace}\", applicability = \"machine-applicable\")]\n+#[suggestion(lint_suggestion, code = \"{replace}\", applicability = \"machine-applicable\")]\n pub struct RenamedOrRemovedLintSuggestion<'a> {\n     #[primary_span]\n     pub suggestion: Span,\n@@ -890,7 +919,7 @@ pub struct UnknownLint {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+#[suggestion(lint_suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n pub struct UnknownLintSuggestion {\n     #[primary_span]\n     pub suggestion: Span,\n@@ -910,9 +939,9 @@ pub struct IgnoredUnlessCrateSpecified<'a> {\n #[note]\n #[help]\n pub struct CStringPtr {\n-    #[label(as_ptr_label)]\n+    #[label(lint_as_ptr_label)]\n     pub as_ptr: Span,\n-    #[label(unwrap_label)]\n+    #[label(lint_unwrap_label)]\n     pub unwrap: Span,\n }\n \n@@ -943,7 +972,7 @@ pub struct ConfusableIdentifierPair {\n \n #[derive(LintDiagnostic)]\n #[diag(lint_mixed_script_confusables)]\n-#[note(includes_note)]\n+#[note(lint_includes_note)]\n #[note]\n pub struct MixedScriptConfusables {\n     pub set: String,\n@@ -963,17 +992,17 @@ impl<'a> DecorateLint<'a, ()> for NonFmtPanicUnused {\n         diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n     ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n         diag.set_arg(\"count\", self.count);\n-        diag.note(fluent::note);\n+        diag.note(fluent::lint_note);\n         if let Some(span) = self.suggestion {\n             diag.span_suggestion(\n                 span.shrink_to_hi(),\n-                fluent::add_args_suggestion,\n+                fluent::lint_add_args_suggestion,\n                 \", ...\",\n                 Applicability::HasPlaceholders,\n             );\n             diag.span_suggestion(\n                 span.shrink_to_lo(),\n-                fluent::add_fmt_suggestion,\n+                fluent::lint_add_fmt_suggestion,\n                 \"\\\"{}\\\", \",\n                 Applicability::MachineApplicable,\n             );\n@@ -1007,12 +1036,12 @@ pub struct NonCamelCaseType<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum NonCamelCaseTypeSub {\n-    #[label(label)]\n+    #[label(lint_label)]\n     Label {\n         #[primary_span]\n         span: Span,\n     },\n-    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(lint_suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n     Suggestion {\n         #[primary_span]\n         span: Span,\n@@ -1048,32 +1077,32 @@ impl AddToDiagnostic for NonSnakeCaseDiagSub {\n     {\n         match self {\n             NonSnakeCaseDiagSub::Label { span } => {\n-                diag.span_label(span, fluent::label);\n+                diag.span_label(span, fluent::lint_label);\n             }\n             NonSnakeCaseDiagSub::Help => {\n-                diag.help(fluent::help);\n+                diag.help(fluent::lint_help);\n             }\n             NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion } => {\n                 diag.span_suggestion(\n                     span,\n-                    fluent::convert_suggestion,\n+                    fluent::lint_convert_suggestion,\n                     suggestion,\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n             NonSnakeCaseDiagSub::RenameOrConvertSuggestion { span, suggestion } => {\n                 diag.span_suggestion(\n                     span,\n-                    fluent::rename_or_convert_suggestion,\n+                    fluent::lint_rename_or_convert_suggestion,\n                     suggestion,\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n             NonSnakeCaseDiagSub::SuggestionAndNote { span } => {\n-                diag.note(fluent::cannot_convert_note);\n+                diag.note(fluent::lint_cannot_convert_note);\n                 diag.span_suggestion(\n                     span,\n-                    fluent::rename_suggestion,\n+                    fluent::lint_rename_suggestion,\n                     \"\",\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -1093,12 +1122,12 @@ pub struct NonUpperCaseGlobal<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum NonUpperCaseGlobalSub {\n-    #[label(label)]\n+    #[label(lint_label)]\n     Label {\n         #[primary_span]\n         span: Span,\n     },\n-    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(lint_suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n     Suggestion {\n         #[primary_span]\n         span: Span,\n@@ -1216,11 +1245,11 @@ impl AddToDiagnostic for OverflowingBinHexSign {\n     {\n         match self {\n             OverflowingBinHexSign::Positive => {\n-                diag.note(fluent::positive_note);\n+                diag.note(fluent::lint_positive_note);\n             }\n             OverflowingBinHexSign::Negative => {\n-                diag.note(fluent::negative_note);\n-                diag.note(fluent::negative_becomes_note);\n+                diag.note(fluent::lint_negative_note);\n+                diag.note(fluent::lint_negative_becomes_note);\n             }\n         }\n     }\n@@ -1229,7 +1258,7 @@ impl AddToDiagnostic for OverflowingBinHexSign {\n #[derive(Subdiagnostic)]\n pub enum OverflowingBinHexSub<'a> {\n     #[suggestion(\n-        suggestion,\n+        lint_suggestion,\n         code = \"{sans_suffix}{suggestion_ty}\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -1239,7 +1268,7 @@ pub enum OverflowingBinHexSub<'a> {\n         suggestion_ty: &'a str,\n         sans_suffix: &'a str,\n     },\n-    #[help(help)]\n+    #[help(lint_help)]\n     Help { suggestion_ty: &'a str },\n }\n \n@@ -1256,7 +1285,7 @@ pub struct OverflowingInt<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[help(help)]\n+#[help(lint_help)]\n pub struct OverflowingIntHelp<'a> {\n     pub suggestion_ty: &'a str,\n }\n@@ -1308,13 +1337,13 @@ impl<'a> DecorateLint<'a, ()> for ImproperCTypes<'_> {\n     ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n         diag.set_arg(\"ty\", self.ty);\n         diag.set_arg(\"desc\", self.desc);\n-        diag.span_label(self.label, fluent::label);\n+        diag.span_label(self.label, fluent::lint_label);\n         if let Some(help) = self.help {\n             diag.help(help);\n         }\n         diag.note(self.note);\n         if let Some(note) = self.span_note {\n-            diag.span_note(note, fluent::note);\n+            diag.span_note(note, fluent::lint_note);\n         }\n         diag\n     }\n@@ -1407,7 +1436,7 @@ pub struct UnusedDef<'a, 'b> {\n #[derive(Subdiagnostic)]\n pub enum UnusedDefSuggestion {\n     #[suggestion(\n-        suggestion,\n+        lint_suggestion,\n         style = \"verbose\",\n         code = \"let _ = \",\n         applicability = \"machine-applicable\"\n@@ -1451,13 +1480,13 @@ pub struct PathStatementDrop {\n \n #[derive(Subdiagnostic)]\n pub enum PathStatementDropSub {\n-    #[suggestion(suggestion, code = \"drop({snippet});\", applicability = \"machine-applicable\")]\n+    #[suggestion(lint_suggestion, code = \"drop({snippet});\", applicability = \"machine-applicable\")]\n     Suggestion {\n         #[primary_span]\n         span: Span,\n         snippet: String,\n     },\n-    #[help(help)]\n+    #[help(lint_help)]\n     Help {\n         #[primary_span]\n         span: Span,\n@@ -1478,7 +1507,7 @@ pub struct UnusedDelim<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(lint_suggestion, applicability = \"machine-applicable\")]\n pub struct UnusedDelimSuggestion {\n     #[suggestion_part(code = \"{start_replace}\")]\n     pub start_span: Span,"}, {"sha": "62e8b4fe9e4a2073b7763ceb5174fc1117d34b4f", "filename": "compiler/rustc_lint/src/map_unit_fn.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -0,0 +1,120 @@\n+use crate::lints::MappingToUnit;\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+use rustc_hir::{Expr, ExprKind, HirId, Stmt, StmtKind};\n+use rustc_middle::{\n+    query::Key,\n+    ty::{self, Ty},\n+};\n+\n+declare_lint! {\n+    /// The `map_unit_fn` lint checks for `Iterator::map` receive\n+    /// a callable that returns `()`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo(items: &mut Vec<u8>) {\n+    ///     items.sort();\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut x: Vec<Vec<u8>> = vec![\n+    ///         vec![0, 2, 1],\n+    ///         vec![5, 4, 3],\n+    ///     ];\n+    ///     x.iter_mut().map(foo);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Mapping to `()` is almost always a mistake.\n+    pub MAP_UNIT_FN,\n+    Warn,\n+    \"`Iterator::map` call that discard the iterator's values\"\n+}\n+\n+declare_lint_pass!(MapUnitFn => [MAP_UNIT_FN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapUnitFn {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &Stmt<'_>) {\n+        if stmt.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let StmtKind::Semi(expr) = stmt.kind {\n+            if let ExprKind::MethodCall(path, receiver, args, span) = expr.kind {\n+                if path.ident.name.as_str() == \"map\" {\n+                    if receiver.span.from_expansion()\n+                        || args.iter().any(|e| e.span.from_expansion())\n+                        || !is_impl_slice(cx, receiver)\n+                        || !is_diagnostic_name(cx, expr.hir_id, \"IteratorMap\")\n+                    {\n+                        return;\n+                    }\n+                    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+                    if let ty::FnDef(id, _) = arg_ty.kind() {\n+                        let fn_ty = cx.tcx.fn_sig(id).skip_binder();\n+                        let ret_ty = fn_ty.output().skip_binder();\n+                        if is_unit_type(ret_ty) {\n+                            cx.emit_spanned_lint(\n+                                MAP_UNIT_FN,\n+                                span,\n+                                MappingToUnit {\n+                                    function_label: cx.tcx.span_of_impl(*id).unwrap(),\n+                                    argument_label: args[0].span,\n+                                    map_label: arg_ty.default_span(cx.tcx),\n+                                    suggestion: path.ident.span,\n+                                    replace: \"for_each\".to_string(),\n+                                },\n+                            )\n+                        }\n+                    } else if let ty::Closure(id, subs) = arg_ty.kind() {\n+                        let cl_ty = subs.as_closure().sig();\n+                        let ret_ty = cl_ty.output().skip_binder();\n+                        if is_unit_type(ret_ty) {\n+                            cx.emit_spanned_lint(\n+                                MAP_UNIT_FN,\n+                                span,\n+                                MappingToUnit {\n+                                    function_label: cx.tcx.span_of_impl(*id).unwrap(),\n+                                    argument_label: args[0].span,\n+                                    map_label: arg_ty.default_span(cx.tcx),\n+                                    suggestion: path.ident.span,\n+                                    replace: \"for_each\".to_string(),\n+                                },\n+                            )\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_impl_slice(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id) {\n+            return cx.tcx.type_of(impl_id).skip_binder().is_slice();\n+        }\n+    }\n+    false\n+}\n+\n+fn is_unit_type(ty: Ty<'_>) -> bool {\n+    ty.is_unit() || ty.is_never()\n+}\n+\n+fn is_diagnostic_name(cx: &LateContext<'_>, id: HirId, name: &str) -> bool {\n+    if let Some(def_id) = cx.typeck_results().type_dependent_def_id(id) {\n+        if let Some(item) = cx.tcx.get_diagnostic_name(def_id) {\n+            if item.as_str() == name {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "5bb1abfd2ec9792eef634d6f3b5a9cd60871d9d5", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,7 +1,7 @@\n use crate::lints::{NonFmtPanicBraces, NonFmtPanicUnused};\n-use crate::{LateContext, LateLintPass, LintContext};\n+use crate::{fluent_generated as fluent, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_errors::{fluent, Applicability};\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::lint::in_external_macro;\n@@ -122,18 +122,18 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint_non_fmt_panic, |lint| {\n         lint.set_arg(\"name\", symbol);\n-        lint.note(fluent::note);\n-        lint.note(fluent::more_info_note);\n+        lint.note(fluent::lint_note);\n+        lint.note(fluent::lint_more_info_note);\n         if !is_arg_inside_call(arg_span, span) {\n             // No clue where this argument is coming from.\n             return lint;\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            lint.note(fluent::supports_fmt_note);\n+            lint.note(fluent::lint_supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n                 lint.multipart_suggestion(\n-                    fluent::supports_fmt_suggestion,\n+                    fluent::lint_supports_fmt_suggestion,\n                     vec![\n                         (arg_span.until(open.shrink_to_hi()), \"\".into()),\n                         (close.until(arg_span.shrink_to_hi()), \"\".into()),\n@@ -179,15 +179,15 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             if suggest_display {\n                 lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    fluent::display_suggestion,\n+                    fluent::lint_display_suggestion,\n                     \"\\\"{}\\\", \",\n                     fmt_applicability,\n                 );\n             } else if suggest_debug {\n                 lint.set_arg(\"ty\", ty);\n                 lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    fluent::debug_suggestion,\n+                    fluent::lint_debug_suggestion,\n                     \"\\\"{:?}\\\", \",\n                     fmt_applicability,\n                 );\n@@ -197,7 +197,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 if let Some((open, close, del)) = find_delimiters(cx, span) {\n                     lint.set_arg(\"already_suggested\", suggest_display || suggest_debug);\n                     lint.multipart_suggestion(\n-                        fluent::panic_suggestion,\n+                        fluent::lint_panic_suggestion,\n                         if del == '(' {\n                             vec![(span.until(open), \"std::panic::panic_any\".into())]\n                         } else {"}, {"sha": "883a56cb3ce6b047c32400514776ef5a6bf96b6b", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n struct OpaqueHiddenInferredBoundLint<'tcx> {\n     ty: Ty<'tcx>,\n     proj_ty: Ty<'tcx>,\n-    #[label(specifically)]\n+    #[label(lint_specifically)]\n     assoc_pred_span: Span,\n     #[subdiagnostic]\n     add_bound: Option<AddBound<'tcx>>,"}, {"sha": "85958c4170569574ddc786191fcd13224dac2d3c", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1,19 +1,24 @@\n-use crate::lints::{\n-    AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, ImproperCTypes,\n-    InvalidAtomicOrderingDiag, OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign,\n-    OverflowingBinHexSub, OverflowingInt, OverflowingIntHelp, OverflowingLiteral, OverflowingUInt,\n-    RangeEndpointOutOfRange, UnusedComparisons, VariantSizeDifferencesDiag,\n+use crate::{\n+    fluent_generated as fluent,\n+    lints::{\n+        AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, ImproperCTypes,\n+        InvalidAtomicOrderingDiag, OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign,\n+        OverflowingBinHexSub, OverflowingInt, OverflowingIntHelp, OverflowingLiteral,\n+        OverflowingUInt, RangeEndpointOutOfRange, UnusedComparisons, VariantSizeDifferencesDiag,\n+    },\n };\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{fluent, DiagnosticMessage};\n+use rustc_errors::DiagnosticMessage;\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n+};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n@@ -1144,7 +1149,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         struct ProhibitOpaqueTypes;\n-        impl<'tcx> ty::visit::ir::TypeVisitor<TyCtxt<'tcx>> for ProhibitOpaqueTypes {\n+        impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for ProhibitOpaqueTypes {\n             type BreakTy = Ty<'tcx>;\n \n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {"}, {"sha": "46ec1a2dca1f7e22437e8eac90a373229454f159", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -4103,3 +4103,33 @@ declare_lint! {\n     };\n     report_in_external_macro\n }\n+\n+declare_lint! {\n+    /// The `invalid_macro_export_arguments` lint detects cases where `#[macro_export]` is being used with invalid arguments.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(invalid_macro_export_arguments)]\n+    ///\n+    /// #[macro_export(invalid_parameter)]\n+    /// macro_rules! myMacro {\n+    ///    () => {\n+    ///         // [...]\n+    ///    }\n+    /// }\n+    ///\n+    /// #[macro_export(too, many, items)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The only valid argument is `#[macro_export(local_inner_macros)]` or no argument (`#[macro_export]`).\n+    /// You can't have multiple arguments in a `#[macro_export(..)]`, or mention arguments other than `local_inner_macros`.\n+    ///\n+    pub INVALID_MACRO_EXPORT_ARGUMENTS,\n+    Warn,\n+    \"\\\"invalid_parameter\\\" isn't a valid argument for `#[macro_export]`\",\n+}"}, {"sha": "12a954258d1de682e8531455f4fff334b3bd7170", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -57,7 +57,7 @@ impl<'a> DiagnosticDerive<'a> {\n                 }\n                 Some(slug) => {\n                     quote! {\n-                        let mut #diag = #handler.struct_diagnostic(rustc_errors::fluent::#slug);\n+                        let mut #diag = #handler.struct_diagnostic(crate::fluent_generated::#slug);\n                     }\n                 }\n             };\n@@ -149,7 +149,7 @@ impl<'a> LintDiagnosticDerive<'a> {\n                 }\n                 Some(slug) => {\n                     quote! {\n-                        rustc_errors::fluent::#slug.into()\n+                        crate::fluent_generated::#slug.into()\n                     }\n                 }\n             }"}, {"sha": "46068f8c868cd7fba6f8a58cd318434450620a16", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -452,7 +452,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(quote! {\n                     #diag.span_suggestions_with_style(\n                         #span_field,\n-                        rustc_errors::fluent::#slug,\n+                        crate::fluent_generated::#slug,\n                         #code_field,\n                         #applicability,\n                         #style\n@@ -476,7 +476,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         quote! {\n             #diag.#fn_name(\n                 #field_binding,\n-                rustc_errors::fluent::#fluent_attr_identifier\n+                crate::fluent_generated::#fluent_attr_identifier\n             );\n         }\n     }\n@@ -486,7 +486,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: Path) -> TokenStream {\n         let diag = &self.parent.diag;\n         quote! {\n-            #diag.#kind(rustc_errors::fluent::#fluent_attr_identifier);\n+            #diag.#kind(crate::fluent_generated::#fluent_attr_identifier);\n         }\n     }\n "}, {"sha": "38c0f4895db06ecb2315c9994b02daf61c134d0b", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 220, "deletions": 229, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -19,52 +19,9 @@ use std::{\n     io::Read,\n     path::{Path, PathBuf},\n };\n-use syn::{\n-    parse::{Parse, ParseStream},\n-    parse_macro_input,\n-    punctuated::Punctuated,\n-    token, Ident, LitStr, Result,\n-};\n+use syn::{parse_macro_input, Ident, LitStr};\n use unic_langid::langid;\n \n-struct Resource {\n-    krate: Ident,\n-    #[allow(dead_code)]\n-    fat_arrow_token: token::FatArrow,\n-    resource_path: LitStr,\n-}\n-\n-impl Parse for Resource {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        Ok(Resource {\n-            krate: input.parse()?,\n-            fat_arrow_token: input.parse()?,\n-            resource_path: input.parse()?,\n-        })\n-    }\n-}\n-\n-struct Resources(Punctuated<Resource, token::Comma>);\n-\n-impl Parse for Resources {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let mut resources = Punctuated::new();\n-        loop {\n-            if input.is_empty() || input.peek(token::Brace) {\n-                break;\n-            }\n-            let value = input.parse()?;\n-            resources.push_value(value);\n-            if !input.peek(token::Comma) {\n-                break;\n-            }\n-            let punct = input.parse()?;\n-            resources.push_punct(punct);\n-        }\n-        Ok(Resources(resources))\n-    }\n-}\n-\n /// Helper function for returning an absolute path for macro-invocation relative file paths.\n ///\n /// If the input is already absolute, then the input is returned. If the input is not absolute,\n@@ -84,251 +41,285 @@ fn invocation_relative_path_to_absolute(span: Span, path: &str) -> PathBuf {\n     }\n }\n \n+/// Tokens to be returned when the macro cannot proceed.\n+fn failed(crate_name: &Ident) -> proc_macro::TokenStream {\n+    quote! {\n+        pub static DEFAULT_LOCALE_RESOURCE: &'static str = \"\";\n+\n+        #[allow(non_upper_case_globals)]\n+        #[doc(hidden)]\n+        pub(crate) mod fluent_generated {\n+            pub mod #crate_name {\n+            }\n+\n+            pub mod _subdiag {\n+                pub const help: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"help\"));\n+                pub const note: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n+                pub const warn: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"warn\"));\n+                pub const label: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"label\"));\n+                pub const suggestion: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"suggestion\"));\n+            }\n+        }\n+    }\n+    .into()\n+}\n+\n /// See [rustc_macros::fluent_messages].\n pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    let resources = parse_macro_input!(input as Resources);\n+    let crate_name = std::env::var(\"CARGO_PKG_NAME\")\n+        // If `CARGO_PKG_NAME` is missing, then we're probably running in a test, so use\n+        // `no_crate`.\n+        .unwrap_or_else(|_| \"no_crate\".to_string())\n+        .replace(\"rustc_\", \"\");\n \n     // Cannot iterate over individual messages in a bundle, so do that using the\n     // `FluentResource` instead. Construct a bundle anyway to find out if there are conflicting\n     // messages in the resources.\n     let mut bundle = FluentBundle::new(vec![langid!(\"en-US\")]);\n \n-    // Map of Fluent identifiers to the `Span` of the resource that defined them, used for better\n-    // diagnostics.\n-    let mut previous_defns = HashMap::new();\n-\n     // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n     // constant created for a given attribute is the same.\n     let mut previous_attrs = HashSet::new();\n \n-    let mut includes = TokenStream::new();\n-    let mut generated = TokenStream::new();\n+    let resource_str = parse_macro_input!(input as LitStr);\n+    let resource_span = resource_str.span().unwrap();\n+    let relative_ftl_path = resource_str.value();\n+    let absolute_ftl_path = invocation_relative_path_to_absolute(resource_span, &relative_ftl_path);\n \n-    for res in resources.0 {\n-        let krate_span = res.krate.span().unwrap();\n-        let path_span = res.resource_path.span().unwrap();\n+    let crate_name = Ident::new(&crate_name, resource_str.span());\n \n-        let relative_ftl_path = res.resource_path.value();\n-        let absolute_ftl_path =\n-            invocation_relative_path_to_absolute(krate_span, &relative_ftl_path);\n-        // As this macro also outputs an `include_str!` for this file, the macro will always be\n-        // re-executed when the file changes.\n-        let mut resource_file = match File::open(absolute_ftl_path) {\n-            Ok(resource_file) => resource_file,\n-            Err(e) => {\n-                Diagnostic::spanned(path_span, Level::Error, \"could not open Fluent resource\")\n-                    .note(e.to_string())\n-                    .emit();\n-                continue;\n-            }\n-        };\n-        let mut resource_contents = String::new();\n-        if let Err(e) = resource_file.read_to_string(&mut resource_contents) {\n-            Diagnostic::spanned(path_span, Level::Error, \"could not read Fluent resource\")\n+    // As this macro also outputs an `include_str!` for this file, the macro will always be\n+    // re-executed when the file changes.\n+    let mut resource_file = match File::open(absolute_ftl_path) {\n+        Ok(resource_file) => resource_file,\n+        Err(e) => {\n+            Diagnostic::spanned(resource_span, Level::Error, \"could not open Fluent resource\")\n                 .note(e.to_string())\n                 .emit();\n-            continue;\n+            return failed(&crate_name);\n         }\n-        let resource = match FluentResource::try_new(resource_contents) {\n-            Ok(resource) => resource,\n-            Err((this, errs)) => {\n-                Diagnostic::spanned(path_span, Level::Error, \"could not parse Fluent resource\")\n-                    .help(\"see additional errors emitted\")\n-                    .emit();\n-                for ParserError { pos, slice: _, kind } in errs {\n-                    let mut err = kind.to_string();\n-                    // Entirely unnecessary string modification so that the error message starts\n-                    // with a lowercase as rustc errors do.\n-                    err.replace_range(\n-                        0..1,\n-                        &err.chars().next().unwrap().to_lowercase().to_string(),\n-                    );\n+    };\n+    let mut resource_contents = String::new();\n+    if let Err(e) = resource_file.read_to_string(&mut resource_contents) {\n+        Diagnostic::spanned(resource_span, Level::Error, \"could not read Fluent resource\")\n+            .note(e.to_string())\n+            .emit();\n+        return failed(&crate_name);\n+    }\n+\n+    let resource = match FluentResource::try_new(resource_contents) {\n+        Ok(resource) => resource,\n+        Err((this, errs)) => {\n+            Diagnostic::spanned(resource_span, Level::Error, \"could not parse Fluent resource\")\n+                .help(\"see additional errors emitted\")\n+                .emit();\n+            for ParserError { pos, slice: _, kind } in errs {\n+                let mut err = kind.to_string();\n+                // Entirely unnecessary string modification so that the error message starts\n+                // with a lowercase as rustc errors do.\n+                err.replace_range(0..1, &err.chars().next().unwrap().to_lowercase().to_string());\n \n-                    let line_starts: Vec<usize> = std::iter::once(0)\n-                        .chain(\n-                            this.source()\n-                                .char_indices()\n-                                .filter_map(|(i, c)| Some(i + 1).filter(|_| c == '\\n')),\n-                        )\n-                        .collect();\n-                    let line_start = line_starts\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(line, idx)| (line + 1, idx))\n-                        .filter(|(_, idx)| **idx <= pos.start)\n-                        .last()\n-                        .unwrap()\n-                        .0;\n+                let line_starts: Vec<usize> = std::iter::once(0)\n+                    .chain(\n+                        this.source()\n+                            .char_indices()\n+                            .filter_map(|(i, c)| Some(i + 1).filter(|_| c == '\\n')),\n+                    )\n+                    .collect();\n+                let line_start = line_starts\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(line, idx)| (line + 1, idx))\n+                    .filter(|(_, idx)| **idx <= pos.start)\n+                    .last()\n+                    .unwrap()\n+                    .0;\n \n-                    let snippet = Snippet {\n-                        title: Some(Annotation {\n-                            label: Some(&err),\n-                            id: None,\n+                let snippet = Snippet {\n+                    title: Some(Annotation {\n+                        label: Some(&err),\n+                        id: None,\n+                        annotation_type: AnnotationType::Error,\n+                    }),\n+                    footer: vec![],\n+                    slices: vec![Slice {\n+                        source: this.source(),\n+                        line_start,\n+                        origin: Some(&relative_ftl_path),\n+                        fold: true,\n+                        annotations: vec![SourceAnnotation {\n+                            label: \"\",\n                             annotation_type: AnnotationType::Error,\n-                        }),\n-                        footer: vec![],\n-                        slices: vec![Slice {\n-                            source: this.source(),\n-                            line_start,\n-                            origin: Some(&relative_ftl_path),\n-                            fold: true,\n-                            annotations: vec![SourceAnnotation {\n-                                label: \"\",\n-                                annotation_type: AnnotationType::Error,\n-                                range: (pos.start, pos.end - 1),\n-                            }],\n+                            range: (pos.start, pos.end - 1),\n                         }],\n-                        opt: Default::default(),\n-                    };\n-                    let dl = DisplayList::from(snippet);\n-                    eprintln!(\"{dl}\\n\");\n-                }\n-                continue;\n+                    }],\n+                    opt: Default::default(),\n+                };\n+                let dl = DisplayList::from(snippet);\n+                eprintln!(\"{dl}\\n\");\n             }\n-        };\n \n-        let mut constants = TokenStream::new();\n-        let mut messagerefs = Vec::new();\n-        for entry in resource.entries() {\n-            let span = res.krate.span();\n-            if let Entry::Message(Message { id: Identifier { name }, attributes, value, .. }) =\n-                entry\n-            {\n-                let _ = previous_defns.entry(name.to_string()).or_insert(path_span);\n+            return failed(&crate_name);\n+        }\n+    };\n \n-                if name.contains('-') {\n-                    Diagnostic::spanned(\n-                        path_span,\n-                        Level::Error,\n-                        format!(\"name `{name}` contains a '-' character\"),\n-                    )\n-                    .help(\"replace any '-'s with '_'s\")\n-                    .emit();\n-                }\n+    let mut constants = TokenStream::new();\n+    let mut previous_defns = HashMap::new();\n+    let mut message_refs = Vec::new();\n+    for entry in resource.entries() {\n+        if let Entry::Message(Message { id: Identifier { name }, attributes, value, .. }) = entry {\n+            let _ = previous_defns.entry(name.to_string()).or_insert(resource_span);\n+            if name.contains('-') {\n+                Diagnostic::spanned(\n+                    resource_span,\n+                    Level::Error,\n+                    format!(\"name `{name}` contains a '-' character\"),\n+                )\n+                .help(\"replace any '-'s with '_'s\")\n+                .emit();\n+            }\n \n-                if let Some(Pattern { elements }) = value {\n-                    for elt in elements {\n-                        if let PatternElement::Placeable {\n-                            expression:\n-                                Expression::Inline(InlineExpression::MessageReference { id, .. }),\n-                        } = elt\n-                        {\n-                            messagerefs.push((id.name, *name));\n-                        }\n+            if let Some(Pattern { elements }) = value {\n+                for elt in elements {\n+                    if let PatternElement::Placeable {\n+                        expression:\n+                            Expression::Inline(InlineExpression::MessageReference { id, .. }),\n+                    } = elt\n+                    {\n+                        message_refs.push((id.name, *name));\n                     }\n                 }\n+            }\n \n-                // Require that the message name starts with the crate name\n-                // `hir_typeck_foo_bar` (in `hir_typeck.ftl`)\n-                // `const_eval_baz` (in `const_eval.ftl`)\n-                // `const-eval-hyphen-having` => `hyphen_having` (in `const_eval.ftl`)\n-                // The last case we error about above, but we want to fall back gracefully\n-                // so that only the error is being emitted and not also one about the macro\n-                // failing.\n-                let crate_prefix = format!(\"{}_\", res.krate);\n+            // `typeck_foo_bar` => `foo_bar` (in `typeck.ftl`)\n+            // `const_eval_baz` => `baz` (in `const_eval.ftl`)\n+            // `const-eval-hyphen-having` => `hyphen_having` (in `const_eval.ftl`)\n+            // The last case we error about above, but we want to fall back gracefully\n+            // so that only the error is being emitted and not also one about the macro\n+            // failing.\n+            let crate_prefix = format!(\"{crate_name}_\");\n \n-                let snake_name = name.replace('-', \"_\");\n-                if !snake_name.starts_with(&crate_prefix) {\n+            let snake_name = name.replace('-', \"_\");\n+            if !snake_name.starts_with(&crate_prefix) {\n+                Diagnostic::spanned(\n+                    resource_span,\n+                    Level::Error,\n+                    format!(\"name `{name}` does not start with the crate name\"),\n+                )\n+                .help(format!(\n+                    \"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"\n+                ))\n+                .emit();\n+            };\n+            let snake_name = Ident::new(&snake_name, resource_str.span());\n+\n+            if !previous_attrs.insert(snake_name.clone()) {\n+                continue;\n+            }\n+\n+            let msg = format!(\"Constant referring to Fluent message `{name}` from `{crate_name}`\");\n+            constants.extend(quote! {\n+                #[doc = #msg]\n+                pub const #snake_name: crate::DiagnosticMessage =\n+                    crate::DiagnosticMessage::FluentIdentifier(\n+                        std::borrow::Cow::Borrowed(#name),\n+                        None\n+                    );\n+            });\n+\n+            for Attribute { id: Identifier { name: attr_name }, .. } in attributes {\n+                let snake_name = Ident::new(\n+                    &format!(\"{}{}\", &crate_prefix, &attr_name.replace('-', \"_\")),\n+                    resource_str.span(),\n+                );\n+                if !previous_attrs.insert(snake_name.clone()) {\n+                    continue;\n+                }\n+\n+                if attr_name.contains('-') {\n                     Diagnostic::spanned(\n-                        path_span,\n+                        resource_span,\n                         Level::Error,\n-                        format!(\"name `{name}` does not start with the crate name\"),\n+                        format!(\"attribute `{attr_name}` contains a '-' character\"),\n                     )\n-                    .help(format!(\n-                        \"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"\n-                    ))\n+                    .help(\"replace any '-'s with '_'s\")\n                     .emit();\n-                };\n-\n-                let snake_name = Ident::new(&snake_name, span);\n+                }\n \n+                let msg = format!(\n+                    \"Constant referring to Fluent message `{name}.{attr_name}` from `{crate_name}`\"\n+                );\n                 constants.extend(quote! {\n-                    pub const #snake_name: crate::DiagnosticMessage =\n-                        crate::DiagnosticMessage::FluentIdentifier(\n-                            std::borrow::Cow::Borrowed(#name),\n-                            None\n+                    #[doc = #msg]\n+                    pub const #snake_name: crate::SubdiagnosticMessage =\n+                        crate::SubdiagnosticMessage::FluentAttr(\n+                            std::borrow::Cow::Borrowed(#attr_name)\n                         );\n                 });\n-\n-                for Attribute { id: Identifier { name: attr_name }, .. } in attributes {\n-                    let snake_name = Ident::new(&attr_name.replace('-', \"_\"), span);\n-                    if !previous_attrs.insert(snake_name.clone()) {\n-                        continue;\n-                    }\n-\n-                    if attr_name.contains('-') {\n-                        Diagnostic::spanned(\n-                            path_span,\n-                            Level::Error,\n-                            format!(\"attribute `{attr_name}` contains a '-' character\"),\n-                        )\n-                        .help(\"replace any '-'s with '_'s\")\n-                        .emit();\n-                    }\n-\n-                    constants.extend(quote! {\n-                        pub const #snake_name: crate::SubdiagnosticMessage =\n-                            crate::SubdiagnosticMessage::FluentAttr(\n-                                std::borrow::Cow::Borrowed(#attr_name)\n-                            );\n-                    });\n-                }\n             }\n         }\n+    }\n \n-        for (mref, name) in messagerefs.into_iter() {\n-            if !previous_defns.contains_key(mref) {\n-                Diagnostic::spanned(\n-                    path_span,\n-                    Level::Error,\n-                    format!(\"referenced message `{mref}` does not exist (in message `{name}`)\"),\n-                )\n-                .help(&format!(\"you may have meant to use a variable reference (`{{${mref}}}`)\"))\n-                .emit();\n-            }\n+    for (mref, name) in message_refs.into_iter() {\n+        if !previous_defns.contains_key(mref) {\n+            Diagnostic::spanned(\n+                resource_span,\n+                Level::Error,\n+                format!(\"referenced message `{mref}` does not exist (in message `{name}`)\"),\n+            )\n+            .help(&format!(\"you may have meant to use a variable reference (`{{${mref}}}`)\"))\n+            .emit();\n         }\n+    }\n \n-        if let Err(errs) = bundle.add_resource(resource) {\n-            for e in errs {\n-                match e {\n-                    FluentError::Overriding { kind, id } => {\n-                        Diagnostic::spanned(\n-                            path_span,\n-                            Level::Error,\n-                            format!(\"overrides existing {kind}: `{id}`\"),\n-                        )\n-                        .span_help(previous_defns[&id], \"previously defined in this resource\")\n-                        .emit();\n-                    }\n-                    FluentError::ResolverError(_) | FluentError::ParserError(_) => unreachable!(),\n+    if let Err(errs) = bundle.add_resource(resource) {\n+        for e in errs {\n+            match e {\n+                FluentError::Overriding { kind, id } => {\n+                    Diagnostic::spanned(\n+                        resource_span,\n+                        Level::Error,\n+                        format!(\"overrides existing {kind}: `{id}`\"),\n+                    )\n+                    .emit();\n                 }\n+                FluentError::ResolverError(_) | FluentError::ParserError(_) => unreachable!(),\n             }\n         }\n-\n-        includes.extend(quote! { include_str!(#relative_ftl_path), });\n-\n-        generated.extend(constants);\n     }\n \n     quote! {\n+        /// Raw content of Fluent resource for this crate, generated by `fluent_messages` macro,\n+        /// imported by `rustc_driver` to include all crates' resources in one bundle.\n+        pub static DEFAULT_LOCALE_RESOURCE: &'static str = include_str!(#relative_ftl_path);\n+\n         #[allow(non_upper_case_globals)]\n         #[doc(hidden)]\n-        pub mod fluent_generated {\n-            pub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] = &[\n-                #includes\n-            ];\n-\n-            #generated\n+        /// Auto-generated constants for type-checked references to Fluent messages.\n+        pub(crate) mod fluent_generated {\n+            #constants\n \n+            /// Constants expected to exist by the diagnostic derive macros to use as default Fluent\n+            /// identifiers for different subdiagnostic kinds.\n             pub mod _subdiag {\n+                /// Default for `#[help]`\n                 pub const help: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"help\"));\n+                /// Default for `#[note]`\n                 pub const note: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n+                /// Default for `#[warn]`\n                 pub const warn: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"warn\"));\n+                /// Default for `#[label]`\n                 pub const label: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"label\"));\n+                /// Default for `#[suggestion]`\n                 pub const suggestion: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"suggestion\"));\n             }"}, {"sha": "90660fc1f93db8e137789eacbd7faeb0b1334533", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -512,7 +512,9 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         let mut calls = TokenStream::new();\n         for (kind, slug) in kind_slugs {\n             let message = format_ident!(\"__message\");\n-            calls.extend(quote! { let #message = #f(#diag, rustc_errors::fluent::#slug.into()); });\n+            calls.extend(\n+                quote! { let #message = #f(#diag, crate::fluent_generated::#slug.into()); },\n+            );\n \n             let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n             let call = match kind {"}, {"sha": "737500cc257eb05e72021b6bd317a271dc1c1727", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -61,9 +61,7 @@ pub fn newtype_index(input: TokenStream) -> TokenStream {\n /// For example, given the following invocation of the macro..\n ///\n /// ```ignore (rust)\n-/// fluent_messages! {\n-///     typeck => \"./typeck.ftl\",\n-/// }\n+/// fluent_messages! { \"./typeck.ftl\" }\n /// ```\n /// ..where `typeck.ftl` has the following contents..\n ///\n@@ -77,9 +75,7 @@ pub fn newtype_index(input: TokenStream) -> TokenStream {\n /// will generate the following code:\n ///\n /// ```ignore (rust)\n-/// pub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] = &[\n-///     include_str!(\"./typeck.ftl\"),\n-/// ];\n+/// pub static DEFAULT_LOCALE_RESOURCE: &'static [&'static str] = include_str!(\"./typeck.ftl\");\n ///\n /// mod fluent_generated {\n ///     mod typeck {"}, {"sha": "388e254cd64530fe82b7cd9f043c7a59957fa360", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -37,16 +37,16 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n                 bind.to_token_stream()\n             } else {\n                 quote! {\n-                    ::rustc_middle::ty::fold::ir::TypeFoldable::try_fold_with(#bind, __folder)?\n+                    ::rustc_middle::ty::fold::TypeFoldable::try_fold_with(#bind, __folder)?\n                 }\n             }\n         })\n     });\n \n     s.bound_impl(\n-        quote!(::rustc_middle::ty::fold::ir::TypeFoldable<::rustc_middle::ty::TyCtxt<'tcx>>),\n+        quote!(::rustc_middle::ty::fold::TypeFoldable<::rustc_middle::ty::TyCtxt<'tcx>>),\n         quote! {\n-            fn try_fold_with<__F: ::rustc_middle::ty::fold::FallibleTypeFolder<'tcx>>(\n+            fn try_fold_with<__F: ::rustc_middle::ty::fold::FallibleTypeFolder<::rustc_middle::ty::TyCtxt<'tcx>>>(\n                 self,\n                 __folder: &mut __F\n             ) -> Result<Self, __F::Error> {"}, {"sha": "f6f4c4779c302e48a7cad8ffa720a5bd413226d3", "filename": "compiler/rustc_macros/src/type_visitable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -30,15 +30,15 @@ pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n     s.add_bounds(synstructure::AddBounds::Generics);\n     let body_visit = s.each(|bind| {\n         quote! {\n-            ::rustc_middle::ty::visit::ir::TypeVisitable::visit_with(#bind, __visitor)?;\n+            ::rustc_middle::ty::visit::TypeVisitable::visit_with(#bind, __visitor)?;\n         }\n     });\n     s.bind_with(|_| synstructure::BindStyle::Move);\n \n     s.bound_impl(\n-        quote!(::rustc_middle::ty::visit::ir::TypeVisitable<::rustc_middle::ty::TyCtxt<'tcx>>),\n+        quote!(::rustc_middle::ty::visit::TypeVisitable<::rustc_middle::ty::TyCtxt<'tcx>>),\n         quote! {\n-            fn visit_with<__V: ::rustc_middle::ty::visit::TypeVisitor<'tcx>>(\n+            fn visit_with<__V: ::rustc_middle::ty::visit::TypeVisitor<::rustc_middle::ty::TyCtxt<'tcx>>>(\n                 &self,\n                 __visitor: &mut __V\n             ) -> ::std::ops::ControlFlow<__V::BreakTy> {"}, {"sha": "79b8b417257045a6b60f244acf4f4a0f7acc35d5", "filename": "compiler/rustc_metadata/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl"}, {"sha": "51b41b5f6a2148c90e3d81d1e01941ef44b9315b", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -9,6 +9,7 @@ use rustc_session::config;\n use rustc_span::{sym, Span, Symbol};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n+use crate::fluent_generated as fluent;\n use crate::locator::CrateFlavor;\n \n #[derive(Diagnostic)]\n@@ -491,7 +492,7 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_multiple_candidates);\n+        let mut diag = handler.struct_err(fluent::metadata_multiple_candidates);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"flavor\", self.flavor);\n         diag.code(error_code!(E0464));\n@@ -590,7 +591,7 @@ impl IntoDiagnostic<'_> for InvalidMetadataFiles {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_invalid_meta_files);\n+        let mut diag = handler.struct_err(fluent::metadata_invalid_meta_files);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n         diag.code(error_code!(E0786));\n@@ -619,7 +620,7 @@ impl IntoDiagnostic<'_> for CannotFindCrate {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_cannot_find_crate);\n+        let mut diag = handler.struct_err(fluent::metadata_cannot_find_crate);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"current_crate\", self.current_crate);\n         diag.set_arg(\"add_info\", self.add_info);\n@@ -630,32 +631,32 @@ impl IntoDiagnostic<'_> for CannotFindCrate {\n             && self.locator_triple != TargetTriple::from_triple(config::host_triple())\n         {\n             if self.missing_core {\n-                diag.note(rustc_errors::fluent::metadata_target_not_installed);\n+                diag.note(fluent::metadata_target_not_installed);\n             } else {\n-                diag.note(rustc_errors::fluent::metadata_target_no_std_support);\n+                diag.note(fluent::metadata_target_no_std_support);\n             }\n             // NOTE: this suggests using rustup, even though the user may not have it installed.\n             // That's because they could choose to install it; or this may give them a hint which\n             // target they need to install from their distro.\n             if self.missing_core {\n-                diag.help(rustc_errors::fluent::metadata_consider_downloading_target);\n+                diag.help(fluent::metadata_consider_downloading_target);\n             }\n             // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n             // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n             // If it's not a dummy, that means someone added `extern crate std` explicitly and\n             // `#![no_std]` won't help.\n             if !self.missing_core && self.span.is_dummy() {\n-                diag.note(rustc_errors::fluent::metadata_std_required);\n+                diag.note(fluent::metadata_std_required);\n             }\n             if self.is_nightly_build {\n-                diag.help(rustc_errors::fluent::metadata_consider_building_std);\n+                diag.help(fluent::metadata_consider_building_std);\n             }\n         } else if self.crate_name == self.profiler_runtime {\n-            diag.note(rustc_errors::fluent::metadata_compiler_missing_profiler);\n+            diag.note(fluent::metadata_compiler_missing_profiler);\n         } else if self.crate_name.as_str().starts_with(\"rustc_\") {\n-            diag.help(rustc_errors::fluent::metadata_install_missing_components);\n+            diag.help(fluent::metadata_install_missing_components);\n         }\n-        diag.span_label(self.span, rustc_errors::fluent::metadata_cant_find_crate);\n+        diag.span_label(self.span, fluent::metadata_cant_find_crate);\n         diag\n     }\n }"}, {"sha": "6f6d3731ceaceb0765f19cf20b93c894d30dd38a", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -30,6 +30,8 @@ extern crate rustc_data_structures;\n extern crate tracing;\n \n pub use rmeta::{provide, provide_extern};\n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n \n mod dependency_format;\n mod foreign_modules;\n@@ -44,3 +46,5 @@ pub mod locator;\n pub use fs::{emit_wrapper_file, METADATA_FILENAME};\n pub use native_libs::find_native_static_library;\n pub use rmeta::{encode_metadata, EncodedMetadata, METADATA_HEADER};\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "d6f68b2e140553e79cafe1b16e2ca7911e97400b", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -103,8 +103,13 @@ impl<'tcx> Collector<'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        let sess = &self.tcx.sess;\n+        let sess = self.tcx.sess;\n         let features = self.tcx.features();\n+\n+        if !sess.opts.unstable_opts.link_directives {\n+            return;\n+        }\n+\n         for m in self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| a.has_name(sym::link)) {\n             let Some(items) = m.meta_item_list() else {\n                 continue;\n@@ -502,7 +507,7 @@ impl<'tcx> Collector<'tcx> {\n                 .subst_identity()\n                 .fn_sig(self.tcx)\n                 .inputs()\n-                .map_bound(|slice| self.tcx.intern_type_list(slice)),\n+                .map_bound(|slice| self.tcx.mk_type_list(slice)),\n         );\n \n         argument_types"}, {"sha": "b1e59b0a470b5735415aec4ca1f83af29355944d", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -910,7 +910,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n         };\n \n-        tcx.alloc_adt_def(did, adt_kind, variants, repr)\n+        tcx.mk_adt_def(did, adt_kind, variants, repr)\n     }\n \n     fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {"}, {"sha": "83a0e833edc1d74b78f9bb778844ef0c87fbb47f", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -254,6 +254,8 @@ provide! { tcx, def_id, other, cdata,\n             .process_decoded(tcx, || panic!(\"{def_id:?} does not have trait_impl_trait_tys\")))\n      }\n \n+    associated_items_for_impl_trait_in_trait => { table_defaulted_array }\n+\n     visibility => { cdata.get_visibility(def_id.index) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {"}, {"sha": "f0dafe73c004e9c99a41c98d0591fd985c3fdf93", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -1129,6 +1129,11 @@ fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     })\n }\n \n+// Return `false` to avoid encoding impl trait in trait, while we don't use the query.\n+fn should_encode_fn_impl_trait_in_trait<'tcx>(_tcx: TyCtxt<'tcx>, _def_id: DefId) -> bool {\n+    false\n+}\n+\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n@@ -1137,8 +1142,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             is_doc_hidden: false,\n         };\n         let attr_iter = tcx\n-            .hir()\n-            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n+            .opt_local_def_id_to_hir_id(def_id)\n+            .map_or(Default::default(), |hir_id| tcx.hir().attrs(hir_id))\n             .iter()\n             .filter(|attr| analyze_attr(attr, &mut state));\n \n@@ -1211,6 +1216,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n+            if should_encode_fn_impl_trait_in_trait(tcx, def_id) {\n+                let table = tcx.associated_items_for_impl_trait_in_trait(def_id);\n+                record_defaulted_array!(self.tables.associated_items_for_impl_trait_in_trait[def_id] <- table);\n+            }\n         }\n \n         let inherent_impls = tcx.with_stable_hashing_context(|hcx| {"}, {"sha": "a7ec2d790b73a9efc962a67d2c5bedfd10d61243", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -354,6 +354,7 @@ define_tables! {\n     explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n     inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n+    associated_items_for_impl_trait_in_trait: Table<DefIndex, LazyArray<DefId>>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,"}, {"sha": "a2b78cc298570d55020d64e946a5982f8b41d0d9", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -34,7 +34,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "4f4e5c6a2c9c2218bed43d2e41ec213e9b4aa2e0", "filename": "compiler/rustc_middle/locales/en-US.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Flocales%2Fen-US.ftl?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "previous_filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl"}, {"sha": "2df851a7857715d5c02764fe09feb0b3989e764a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -849,6 +849,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn get_fn_output(self, def_id: LocalDefId) -> Option<&'hir FnRetTy<'hir>> {\n+        match self.tcx.hir_owner(OwnerId { def_id }) {\n+            Some(Owner { node, .. }) => node.fn_decl().map(|fn_decl| &fn_decl.output),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn expect_variant(self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,"}, {"sha": "2e2ca6a27888ead9c7d4f6b931237e609acd9dda", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -121,13 +121,13 @@ pub fn provide(providers: &mut Providers) {\n         let node = owner.node();\n         Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n     };\n-    providers.local_def_id_to_hir_id = |tcx, id| {\n+    providers.opt_local_def_id_to_hir_id = |tcx, id| {\n         let owner = tcx.hir_crate(()).owners[id].map(|_| ());\n-        match owner {\n+        Some(match owner {\n             MaybeOwner::Owner(_) => HirId::make_owner(id),\n             MaybeOwner::Phantom => bug!(\"No HirId for {:?}\", id),\n             MaybeOwner::NonOwner(hir_id) => hir_id,\n-        }\n+        })\n     };\n     providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id.def_id].map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {"}, {"sha": "8712514a384c108e21fe5726500117fb20f31db0", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -42,12 +42,12 @@ pub struct Canonical<'tcx, V> {\n \n pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo<'tcx>>;\n \n-impl<'tcx> ty::ir::TypeFoldable<TyCtxt<'tcx>> for CanonicalVarInfos<'tcx> {\n-    fn try_fold_with<F: ty::FallibleTypeFolder<'tcx>>(\n+impl<'tcx> ty::TypeFoldable<TyCtxt<'tcx>> for CanonicalVarInfos<'tcx> {\n+    fn try_fold_with<F: ty::FallibleTypeFolder<TyCtxt<'tcx>>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n-        ty::util::fold_list(self, folder, |tcx, v| tcx.intern_canonical_var_infos(v))\n+        ty::util::fold_list(self, folder, |tcx, v| tcx.mk_canonical_var_infos(v))\n     }\n }\n \n@@ -342,7 +342,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n         infos: CanonicalVarInfos<'tcx>,\n     ) -> CanonicalVarValues<'tcx> {\n         CanonicalVarValues {\n-            var_values: tcx.mk_substs(infos.iter().enumerate().map(\n+            var_values: tcx.mk_substs_from_iter(infos.iter().enumerate().map(\n                 |(i, info)| -> ty::GenericArg<'tcx> {\n                     match info.kind {\n                         CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {"}, {"sha": "c33b9d84eb0a098deb16f04cb28bbf405c21d989", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -73,6 +73,9 @@ extern crate tracing;\n #[macro_use]\n extern crate smallvec;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -105,3 +108,5 @@ pub mod util {\n \n // Allows macros to refer to this crate as `::rustc_middle`\n extern crate self as rustc_middle;\n+\n+fluent_messages! { \"../locales/en-US.ftl\" }"}, {"sha": "a8d71ce030c2a230f61dd33848a496b4e5c78201", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -69,26 +69,26 @@ macro_rules! CloneLiftImpls {\n macro_rules! TrivialTypeTraversalImpls {\n     (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n         $(\n-            impl<$tcx> $crate::ty::fold::ir::TypeFoldable<$crate::ty::TyCtxt<$tcx>> for $ty {\n-                fn try_fold_with<F: $crate::ty::fold::FallibleTypeFolder<$tcx>>(\n+            impl<$tcx> $crate::ty::fold::TypeFoldable<$crate::ty::TyCtxt<$tcx>> for $ty {\n+                fn try_fold_with<F: $crate::ty::fold::FallibleTypeFolder<$crate::ty::TyCtxt<$tcx>>>(\n                     self,\n                     _: &mut F,\n                 ) -> ::std::result::Result<Self, F::Error> {\n                     Ok(self)\n                 }\n \n                 #[inline]\n-                fn fold_with<F: $crate::ty::fold::TypeFolder<$tcx>>(\n+                fn fold_with<F: $crate::ty::fold::TypeFolder<$crate::ty::TyCtxt<$tcx>>>(\n                     self,\n                     _: &mut F,\n                 ) -> Self {\n                     self\n                 }\n             }\n \n-            impl<$tcx> $crate::ty::visit::ir::TypeVisitable<$crate::ty::TyCtxt<$tcx>> for $ty {\n+            impl<$tcx> $crate::ty::visit::TypeVisitable<$crate::ty::TyCtxt<$tcx>> for $ty {\n                 #[inline]\n-                fn visit_with<F: $crate::ty::visit::TypeVisitor<$tcx>>(\n+                fn visit_with<F: $crate::ty::visit::TypeVisitor<$crate::ty::TyCtxt<$tcx>>>(\n                     &self,\n                     _: &mut F)\n                     -> ::std::ops::ControlFlow<F::BreakTy>"}, {"sha": "354c84e2209a36c86ce10ce06c93800000e5636a", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -255,7 +255,7 @@ fn late_report_deprecation(\n     let method_span = method_span.unwrap_or(span);\n     tcx.struct_span_lint_hir(lint, hir_id, method_span, message, |diag| {\n         if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-            let kind = tcx.def_kind(def_id).descr(def_id);\n+            let kind = tcx.def_descr(def_id);\n             deprecation_suggestion(diag, kind, suggestion, method_span);\n         }\n         diag\n@@ -392,7 +392,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     let lint = deprecation_lint(is_in_effect);\n                     if self.lint_level_at_node(lint, id).0 != Level::Allow {\n                         let def_path = with_no_trimmed_paths!(self.def_path_str(def_id));\n-                        let def_kind = self.def_kind(def_id).descr(def_id);\n+                        let def_kind = self.def_descr(def_id);\n \n                         late_report_deprecation(\n                             self,"}, {"sha": "856d821a5cf1452473575395b27592da2f6cc99b", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -2,7 +2,7 @@ use super::{ErrorHandled, EvalToConstValueResult, EvalToValTreeResult, GlobalId}\n \n use crate::mir;\n use crate::ty::subst::InternalSubsts;\n-use crate::ty::visit::TypeVisitable;\n+use crate::ty::visit::TypeVisitableExt;\n use crate::ty::{self, query::TyCtxtAt, query::TyCtxtEnsure, TyCtxt};\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;"}, {"sha": "0d78c6135b3369c3011a1e16b0c1c5c1c083cd0b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -7,10 +7,10 @@ use crate::mir::interpret::{\n };\n use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n-use crate::ty::fold::{ir::TypeFoldable, FallibleTypeFolder};\n+use crate::ty::fold::{FallibleTypeFolder, TypeFoldable};\n use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::visit::{TypeVisitable, TypeVisitor};\n-use crate::ty::{self, ir, DefIdTree, List, Ty, TyCtxt};\n+use crate::ty::visit::{TypeVisitable, TypeVisitableExt, TypeVisitor};\n+use crate::ty::{self, DefIdTree, List, Ty, TyCtxt};\n use crate::ty::{AdtDef, InstanceDef, ScalarInt, UserTypeAnnotationIndex};\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n \n@@ -1620,7 +1620,7 @@ impl<'tcx> Place<'tcx> {\n             &v\n         };\n \n-        Place { local: self.local, projection: tcx.intern_place_elems(new_projections) }\n+        Place { local: self.local, projection: tcx.mk_place_elems(new_projections) }\n     }\n }\n \n@@ -2530,13 +2530,14 @@ impl<'tcx> ConstantKind<'tcx> {\n         {\n             InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n         } else {\n-            tcx.intern_substs(&[])\n+            List::empty()\n         };\n         debug!(?parent_substs);\n \n         let did = def.did.to_def_id();\n         let child_substs = InternalSubsts::identity_for_item(tcx, did);\n-        let substs = tcx.mk_substs(parent_substs.into_iter().chain(child_substs.into_iter()));\n+        let substs =\n+            tcx.mk_substs_from_iter(parent_substs.into_iter().chain(child_substs.into_iter()));\n         debug!(?substs);\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n@@ -2755,16 +2756,22 @@ impl UserTypeProjection {\n }\n \n impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for UserTypeProjection {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(UserTypeProjection {\n             base: self.base.try_fold_with(folder)?,\n             projs: self.projs.try_fold_with(folder)?,\n         })\n     }\n }\n \n-impl<'tcx> ir::TypeVisitable<TyCtxt<'tcx>> for UserTypeProjection {\n-    fn visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> ControlFlow<Vs::BreakTy> {\n+impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for UserTypeProjection {\n+    fn visit_with<Vs: TypeVisitor<TyCtxt<'tcx>>>(\n+        &self,\n+        visitor: &mut Vs,\n+    ) -> ControlFlow<Vs::BreakTy> {\n         self.base.visit_with(visitor)\n         // Note: there's nothing in `self.proj` to visit.\n     }"}, {"sha": "0aa2c500f51fbf018731effd16b5b497b1e90b41", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb45103358c0fef99d7659e0949b3c65b3eabdd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=cb45103358c0fef99d7659e0949b3c65b3eabdd6", "patch": "@@ -194,14 +194,16 @@ impl<'tcx> Rvalue<'tcx> {\n                 let lhs_ty = lhs.ty(local_decls, tcx);\n                 let rhs_ty = rhs.ty(local_decls, tcx);\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n-                tcx.intern_tup(&[ty, tcx.types.bool])\n+                tcx.mk_tup(&[ty, tcx.types.bool])\n             }\n             Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, ref operand) => operand.ty(local_decls, tcx),\n             Rvalue::Discriminant(ref place) => place.ty(local_decls, tcx).ty.discriminant_ty(tcx),\n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => tcx.types.usize,\n             Rvalue::Aggregate(ref ak, ref ops) => match **ak {\n                 AggregateKind::Array(ty) => tcx.mk_array(ty, ops.len() as u64),\n-                AggregateKind::Tuple => tcx.mk_tup(ops.iter().map(|op| op.ty(local_decls, tcx))),\n+                AggregateKind::Tuple => {\n+                    tcx.mk_tup_from_iter(ops.iter().map(|op| op.ty(local_decls, tcx)))\n+                }\n                 AggregateKind::Adt(did, _, substs, _, _) => tcx.type_of(did).subst(tcx, substs),\n                 AggregateKind::Closure(did, substs) => tcx.mk_closure(did, substs),\n                 AggregateKind::Generator(did, substs, movability) => {"}]}