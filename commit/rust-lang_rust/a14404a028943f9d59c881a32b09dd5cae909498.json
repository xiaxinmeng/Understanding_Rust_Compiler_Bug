{"sha": "a14404a028943f9d59c881a32b09dd5cae909498", "node_id": "C_kwDOAAsO6NoAKGExNDQwNGEwMjg5NDNmOWQ1OWM4ODFhMzJiMDlkZDVjYWU5MDk0OTg", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-07-21T00:57:56Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-07-21T00:57:56Z"}, "message": "Sync core::simd up to rust-lang/portable-simd@2e081db92aa3ee0a4563bc28ce01bdad5b1b2efd", "tree": {"sha": "867e5d329f8e23916f434178cda59ce234532212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/867e5d329f8e23916f434178cda59ce234532212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a14404a028943f9d59c881a32b09dd5cae909498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a14404a028943f9d59c881a32b09dd5cae909498", "html_url": "https://github.com/rust-lang/rust/commit/a14404a028943f9d59c881a32b09dd5cae909498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a14404a028943f9d59c881a32b09dd5cae909498/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "246f66a905c2815f2c9b9c3d6b1e0649f3360ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8", "html_url": "https://github.com/rust-lang/rust/commit/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8"}, {"sha": "2e081db92aa3ee0a4563bc28ce01bdad5b1b2efd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e081db92aa3ee0a4563bc28ce01bdad5b1b2efd", "html_url": "https://github.com/rust-lang/rust/commit/2e081db92aa3ee0a4563bc28ce01bdad5b1b2efd"}], "stats": {"total": 2487, "additions": 1606, "deletions": 881}, "files": [{"sha": "17ade06ae80f9eaa8e02f78ce100303219c14ff8", "filename": "library/portable-simd/beginners-guide.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fbeginners-guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fbeginners-guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fbeginners-guide.md?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -82,5 +82,10 @@ Fortunately, most SIMD types have a fairly predictable size. `i32x4` is bit-equi\n \n However, this is not the same as alignment. Computer architectures generally prefer aligned accesses, especially when moving data between memory and vector registers, and while some support specialized operations that can bend the rules to help with this, unaligned access is still typically slow, or even undefined behavior. In addition, different architectures can require different alignments when interacting with their native SIMD types. For this reason, any `#[repr(simd)]` type has a non-portable alignment. If it is necessary to directly interact with the alignment of these types, it should be via [`mem::align_of`].\n \n+When working with slices, data correctly aligned for SIMD can be acquired using the [`as_simd`] and [`as_simd_mut`] methods of the slice primitive.\n+\n [`mem::transmute`]: https://doc.rust-lang.org/core/mem/fn.transmute.html\n [`mem::align_of`]: https://doc.rust-lang.org/core/mem/fn.align_of.html\n+[`as_simd`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_simd\n+[`as_simd_mut`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_simd_mut\n+"}, {"sha": "8a29cf15696ed12cfabf780d58005781b92ec64b", "filename": "library/portable-simd/crates/core_simd/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -9,7 +9,8 @@ categories = [\"hardware-support\", \"no-std\"]\n license = \"MIT OR Apache-2.0\"\n \n [features]\n-default = []\n+default = [\"as_crate\"]\n+as_crate = []\n std = []\n generic_const_exprs = []\n "}, {"sha": "7b0d0a6864b9e631f5e4be1c417fcf5b4c01ef6e", "filename": "library/portable-simd/crates/core_simd/src/comparisons.rs", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=246f66a905c2815f2c9b9c3d6b1e0649f3360ef8", "patch": "@@ -1,120 +0,0 @@\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    T: SimdElement + PartialEq,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Test if each lane is equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n-    }\n-\n-    /// Test if each lane is not equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    T: SimdElement + PartialOrd,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Test if each lane is less than the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n-    }\n-\n-    /// Test if each lane is greater than the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n-    }\n-\n-    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n-    }\n-\n-    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n-    }\n-}\n-\n-macro_rules! impl_ord_methods_vector {\n-    { $type:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns the lane-wise minimum with `other`.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn min(self, other: Self) -> Self {\n-                self.lanes_gt(other).select(other, self)\n-            }\n-\n-            /// Returns the lane-wise maximum with `other`.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn max(self, other: Self) -> Self {\n-                self.lanes_lt(other).select(other, self)\n-            }\n-\n-            /// Restrict each lane to a certain interval.\n-            ///\n-            /// For each lane, returns `max` if `self` is greater than `max`, and `min` if `self` is\n-            /// less than `min`. Otherwise returns `self`.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `min > max` on any lane.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn clamp(self, min: Self, max: Self) -> Self {\n-                assert!(\n-                    min.lanes_le(max).all(),\n-                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n-                );\n-                self.max(min).min(max)\n-            }\n-        }\n-    }\n-}\n-\n-impl_ord_methods_vector!(i8);\n-impl_ord_methods_vector!(i16);\n-impl_ord_methods_vector!(i32);\n-impl_ord_methods_vector!(i64);\n-impl_ord_methods_vector!(isize);\n-impl_ord_methods_vector!(u8);\n-impl_ord_methods_vector!(u16);\n-impl_ord_methods_vector!(u32);\n-impl_ord_methods_vector!(u64);\n-impl_ord_methods_vector!(usize);"}, {"sha": "701eb66b248afb2877a08b10b3c0537d22dfc1db", "filename": "library/portable-simd/crates/core_simd/src/elements.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -0,0 +1,11 @@\n+mod float;\n+mod int;\n+mod uint;\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+\n+pub use float::*;\n+pub use int::*;\n+pub use uint::*;"}, {"sha": "d6022327055602a31afae2c0ec69de9ba5e2db21", "filename": "library/portable-simd/crates/core_simd/src/elements/float.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -0,0 +1,357 @@\n+use super::sealed::Sealed;\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialEq, SimdPartialOrd,\n+    SupportedLaneCount,\n+};\n+\n+/// Operations on SIMD vectors of floats.\n+pub trait SimdFloat: Copy + Sealed {\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Bit representation of this SIMD vector type.\n+    type Bits;\n+\n+    /// Raw transmutation to an unsigned integer vector type with the\n+    /// same size and number of lanes.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_bits(self) -> Self::Bits;\n+\n+    /// Raw transmutation from an unsigned integer vector type with the\n+    /// same size and number of lanes.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn from_bits(bits: Self::Bits) -> Self;\n+\n+    /// Produces a vector where every lane has the absolute value of the\n+    /// equivalently-indexed lane in `self`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn abs(self) -> Self;\n+\n+    /// Takes the reciprocal (inverse) of each lane, `1/x`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn recip(self) -> Self;\n+\n+    /// Converts each lane from radians to degrees.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_degrees(self) -> Self;\n+\n+    /// Converts each lane from degrees to radians.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_radians(self) -> Self;\n+\n+    /// Returns true for each lane if it has a positive sign, including\n+    /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_sign_positive(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if it has a negative sign, including\n+    /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_sign_negative(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_nan(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is positive infinity or negative infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_infinite(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is neither infinite nor `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_finite(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is subnormal.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_subnormal(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is neither zero, infinite,\n+    /// subnormal, nor `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_normal(self) -> Self::Mask;\n+\n+    /// Replaces each lane with a number that represents its sign.\n+    ///\n+    /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n+    /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n+    /// * `NAN` if the number is `NAN`\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn signum(self) -> Self;\n+\n+    /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n+    ///\n+    /// For any lane containing a `NAN`, a `NAN` with the sign of `sign` is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn copysign(self, sign: Self) -> Self;\n+\n+    /// Returns the minimum of each lane.\n+    ///\n+    /// If one of the values is `NAN`, then the other value is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_min(self, other: Self) -> Self;\n+\n+    /// Returns the maximum of each lane.\n+    ///\n+    /// If one of the values is `NAN`, then the other value is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_max(self, other: Self) -> Self;\n+\n+    /// Restrict each lane to a certain interval unless it is NaN.\n+    ///\n+    /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n+    /// greater than `max`, and the corresponding lane in `min` if the lane is less\n+    /// than `min`.  Otherwise returns the lane in `self`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{f32x2, SimdFloat};\n+    /// let v = f32x2::from_array([1., 2.]);\n+    /// assert_eq!(v.reduce_sum(), 3.);\n+    /// ```\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Reducing multiply.  Returns the product of the lanes of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{f32x2, SimdFloat};\n+    /// let v = f32x2::from_array([3., 4.]);\n+    /// assert_eq!(v.reduce_product(), 12.);\n+    /// ```\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    ///\n+    /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+    /// return either.\n+    ///\n+    /// This function will not return `NaN` unless all lanes are `NaN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{f32x2, SimdFloat};\n+    /// let v = f32x2::from_array([1., 2.]);\n+    /// assert_eq!(v.reduce_max(), 2.);\n+    ///\n+    /// // NaN values are skipped...\n+    /// let v = f32x2::from_array([1., f32::NAN]);\n+    /// assert_eq!(v.reduce_max(), 1.);\n+    ///\n+    /// // ...unless all values are NaN\n+    /// let v = f32x2::from_array([f32::NAN, f32::NAN]);\n+    /// assert!(v.reduce_max().is_nan());\n+    /// ```\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    ///\n+    /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+    /// return either.\n+    ///\n+    /// This function will not return `NaN` unless all lanes are `NaN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{f32x2, SimdFloat};\n+    /// let v = f32x2::from_array([3., 7.]);\n+    /// assert_eq!(v.reduce_min(), 3.);\n+    ///\n+    /// // NaN values are skipped...\n+    /// let v = f32x2::from_array([1., f32::NAN]);\n+    /// assert_eq!(v.reduce_min(), 1.);\n+    ///\n+    /// // ...unless all values are NaN\n+    /// let v = f32x2::from_array([f32::NAN, f32::NAN]);\n+    /// assert!(v.reduce_min().is_nan());\n+    /// ```\n+    fn reduce_min(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty { bits: $bits_ty:ty, mask: $mask_ty:ty }),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdFloat for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$mask_ty as SimdElement>::Mask, LANES>;\n+            type Scalar = $ty;\n+            type Bits = Simd<$bits_ty, LANES>;\n+\n+            #[inline]\n+            fn to_bits(self) -> Simd<$bits_ty, LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Self::Bits>());\n+                // Safety: transmuting between vector types is safe\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n+\n+            #[inline]\n+            fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Self::Bits>());\n+                // Safety: transmuting between vector types is safe\n+                unsafe { core::mem::transmute_copy(&bits) }\n+            }\n+\n+            #[inline]\n+            fn abs(self) -> Self {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_fabs(self) }\n+            }\n+\n+            #[inline]\n+            fn recip(self) -> Self {\n+                Self::splat(1.0) / self\n+            }\n+\n+            #[inline]\n+            fn to_degrees(self) -> Self {\n+                // to_degrees uses a special constant for better precision, so extract that constant\n+                self * Self::splat(Self::Scalar::to_degrees(1.))\n+            }\n+\n+            #[inline]\n+            fn to_radians(self) -> Self {\n+                self * Self::splat(Self::Scalar::to_radians(1.))\n+            }\n+\n+            #[inline]\n+            fn is_sign_positive(self) -> Self::Mask {\n+                !self.is_sign_negative()\n+            }\n+\n+            #[inline]\n+            fn is_sign_negative(self) -> Self::Mask {\n+                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n+                sign_bits.simd_gt(Simd::splat(0))\n+            }\n+\n+            #[inline]\n+            fn is_nan(self) -> Self::Mask {\n+                self.simd_ne(self)\n+            }\n+\n+            #[inline]\n+            fn is_infinite(self) -> Self::Mask {\n+                self.abs().simd_eq(Self::splat(Self::Scalar::INFINITY))\n+            }\n+\n+            #[inline]\n+            fn is_finite(self) -> Self::Mask {\n+                self.abs().simd_lt(Self::splat(Self::Scalar::INFINITY))\n+            }\n+\n+            #[inline]\n+            fn is_subnormal(self) -> Self::Mask {\n+                self.abs().simd_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(Self::Scalar::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n+            }\n+\n+            #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+            fn is_normal(self) -> Self::Mask {\n+                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> Self {\n+                self.is_nan().select(Self::splat(Self::Scalar::NAN), Self::splat(1.0).copysign(self))\n+            }\n+\n+            #[inline]\n+            fn copysign(self, sign: Self) -> Self {\n+                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n+                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n+                Self::from_bits(sign_bit | magnitude)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                // Safety: `self` and `other` are float vectors\n+                unsafe { intrinsics::simd_fmin(self, other) }\n+            }\n+\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                // Safety: `self` and `other` are floating point vectors\n+                unsafe { intrinsics::simd_fmax(self, other) }\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                let mut x = self;\n+                x = x.simd_lt(min).select(min, x);\n+                x = x.simd_gt(max).select(max, x);\n+                x\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // LLVM sum is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().sum()\n+                } else {\n+                    // Safety: `self` is a float vector\n+                    unsafe { intrinsics::simd_reduce_add_ordered(self, 0.) }\n+                }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // LLVM product is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().product()\n+                } else {\n+                    // Safety: `self` is a float vector\n+                    unsafe { intrinsics::simd_reduce_mul_ordered(self, 1.) }\n+                }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { f32 { bits: u32, mask: i32 }, f64 { bits: u64, mask: i64 } }"}, {"sha": "9b8c37ed466ecd3fc877f853218b0d3c76e653c6", "filename": "library/portable-simd/crates/core_simd/src/elements/int.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -0,0 +1,298 @@\n+use super::sealed::Sealed;\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialOrd, SupportedLaneCount,\n+};\n+\n+/// Operations on SIMD vectors of signed integers.\n+pub trait SimdInt: Copy + Sealed {\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Lanewise saturating add.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdInt};\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x + max;\n+    /// let sat = x.saturating_add(max);\n+    /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n+    /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n+    /// ```\n+    fn saturating_add(self, second: Self) -> Self;\n+\n+    /// Lanewise saturating subtract.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdInt};\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x - max;\n+    /// let sat = x.saturating_sub(max);\n+    /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n+    /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n+    fn saturating_sub(self, second: Self) -> Self;\n+\n+    /// Lanewise absolute value, implemented in Rust.\n+    /// Every lane becomes its absolute value.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdInt};\n+    /// use core::i32::{MIN, MAX};\n+    /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n+    /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n+    /// ```\n+    fn abs(self) -> Self;\n+\n+    /// Lanewise saturating absolute value, implemented in Rust.\n+    /// As abs(), except the MIN value becomes MAX instead of itself.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdInt};\n+    /// use core::i32::{MIN, MAX};\n+    /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n+    /// let unsat = xs.abs();\n+    /// let sat = xs.saturating_abs();\n+    /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n+    /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n+    /// ```\n+    fn saturating_abs(self) -> Self;\n+\n+    /// Lanewise saturating negation, implemented in Rust.\n+    /// As neg(), except the MIN value becomes MAX instead of itself.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdInt};\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n+    /// let unsat = -x;\n+    /// let sat = x.saturating_neg();\n+    /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n+    /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n+    /// ```\n+    fn saturating_neg(self) -> Self;\n+\n+    /// Returns true for each positive lane and false if it is zero or negative.\n+    fn is_positive(self) -> Self::Mask;\n+\n+    /// Returns true for each negative lane and false if it is zero or positive.\n+    fn is_negative(self) -> Self::Mask;\n+\n+    /// Returns numbers representing the sign of each lane.\n+    /// * `0` if the number is zero\n+    /// * `1` if the number is positive\n+    /// * `-1` if the number is negative\n+    fn signum(self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector, with wrapping addition.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{i32x4, SimdInt};\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_sum(), 10);\n+    ///\n+    /// // SIMD integer addition is always wrapping\n+    /// let v = i32x4::from_array([i32::MAX, 1, 0, 0]);\n+    /// assert_eq!(v.reduce_sum(), i32::MIN);\n+    /// ```\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Returns the product of the lanes of the vector, with wrapping multiplication.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{i32x4, SimdInt};\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_product(), 24);\n+    ///\n+    /// // SIMD integer multiplication is always wrapping\n+    /// let v = i32x4::from_array([i32::MAX, 2, 1, 1]);\n+    /// assert!(v.reduce_product() < i32::MAX);\n+    /// ```\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{i32x4, SimdInt};\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_max(), 4);\n+    /// ```\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{i32x4, SimdInt};\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_min(), 1);\n+    /// ```\n+    fn reduce_min(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"and\" across the lanes of the vector.\n+    fn reduce_and(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"or\" across the lanes of the vector.\n+    fn reduce_or(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"xor\" across the lanes of the vector.\n+    fn reduce_xor(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdInt for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$ty as SimdElement>::Mask, LANES>;\n+            type Scalar = $ty;\n+\n+            #[inline]\n+            fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_add(self, second) }\n+            }\n+\n+            #[inline]\n+            fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_sub(self, second) }\n+            }\n+\n+            #[inline]\n+            fn abs(self) -> Self {\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> Simd::splat(SHR);\n+                (self^m) - m\n+            }\n+\n+            #[inline]\n+            fn saturating_abs(self) -> Self {\n+                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> Simd::splat(SHR);\n+                (self^m).saturating_sub(m)\n+            }\n+\n+            #[inline]\n+            fn saturating_neg(self) -> Self {\n+                Self::splat(0).saturating_sub(self)\n+            }\n+\n+            #[inline]\n+            fn is_positive(self) -> Self::Mask {\n+                self.simd_gt(Self::splat(0))\n+            }\n+\n+            #[inline]\n+            fn is_negative(self) -> Self::Mask {\n+                self.simd_lt(Self::splat(0))\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> Self {\n+                self.is_positive().select(\n+                    Self::splat(1),\n+                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n+                )\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_and(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_or(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_xor(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_xor(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { i8, i16, i32, i64, isize }"}, {"sha": "21e7e76eb3de57b021add8b8b123330c4e09f295", "filename": "library/portable-simd/crates/core_simd/src/elements/uint.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -0,0 +1,139 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Simd, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of unsigned integers.\n+pub trait SimdUint: Copy + Sealed {\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Lanewise saturating add.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdUint};\n+    /// use core::u32::MAX;\n+    /// let x = Simd::from_array([2, 1, 0, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x + max;\n+    /// let sat = x.saturating_add(max);\n+    /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n+    /// assert_eq!(sat, max);\n+    /// ```\n+    fn saturating_add(self, second: Self) -> Self;\n+\n+    /// Lanewise saturating subtract.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdUint};\n+    /// use core::u32::MAX;\n+    /// let x = Simd::from_array([2, 1, 0, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x - max;\n+    /// let sat = x.saturating_sub(max);\n+    /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n+    /// assert_eq!(sat, Simd::splat(0));\n+    fn saturating_sub(self, second: Self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector, with wrapping addition.\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Returns the product of the lanes of the vector, with wrapping multiplication.\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    fn reduce_min(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"and\" across the lanes of the vector.\n+    fn reduce_and(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"or\" across the lanes of the vector.\n+    fn reduce_or(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"xor\" across the lanes of the vector.\n+    fn reduce_xor(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdUint for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Scalar = $ty;\n+\n+            #[inline]\n+            fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_add(self, second) }\n+            }\n+\n+            #[inline]\n+            fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_sub(self, second) }\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_and(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_or(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_xor(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_xor(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { u8, u16, u32, u64, usize }"}, {"sha": "c7111f720a8ac51ba99b38cfc24dab07d616dea4", "filename": "library/portable-simd/crates/core_simd/src/eq.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -0,0 +1,73 @@\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+\n+/// Parallel `PartialEq`.\n+pub trait SimdPartialEq {\n+    /// The mask type returned by each comparison.\n+    type Mask;\n+\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_eq(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_ne(self, other: Self) -> Self::Mask;\n+}\n+\n+macro_rules! impl_number {\n+    { $($number:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialEq for Simd<$number, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$number as SimdElement>::Mask, LANES>;\n+\n+            #[inline]\n+            fn simd_eq(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_ne(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_number! { f32, f64, u8, u16, u32, u64, usize, i8, i16, i32, i64, isize }\n+\n+macro_rules! impl_mask {\n+    { $($integer:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialEq for Mask<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Self;\n+\n+            #[inline]\n+            fn simd_eq(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_eq(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_ne(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_ne(self.to_int(), other.to_int())) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_mask! { i8, i16, i32, i64, isize }"}, {"sha": "63723e2ec13c4902cb8daa6c06674889747ab2f4", "filename": "library/portable-simd/crates/core_simd/src/lane_count.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -3,15 +3,19 @@ mod sealed {\n }\n use sealed::Sealed;\n \n-/// A type representing a vector lane count.\n+/// Specifies the number of lanes in a SIMD vector as a type.\n pub struct LaneCount<const LANES: usize>;\n \n impl<const LANES: usize> LaneCount<LANES> {\n     /// The number of bytes in a bitmask with this many lanes.\n     pub const BITMASK_LEN: usize = (LANES + 7) / 8;\n }\n \n-/// Helper trait for vector lane counts.\n+/// Statically guarantees that a lane count is marked as supported.\n+///\n+/// This trait is *sealed*: the list of implementors below is total.\n+/// Users do not have the ability to mark additional `LaneCount<N>` values as supported.\n+/// Only SIMD vectors with supported lane counts are constructable.\n pub trait SupportedLaneCount: Sealed {\n     #[doc(hidden)]\n     type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;"}, {"sha": "715f258f617df25961052a021a349b248d87b8d0", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -12,7 +12,7 @@\n #![cfg_attr(feature = \"generic_const_exprs\", feature(generic_const_exprs))]\n #![cfg_attr(feature = \"generic_const_exprs\", allow(incomplete_features))]\n #![warn(missing_docs)]\n-#![deny(unsafe_op_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn, clippy::undocumented_unsafe_blocks)]\n #![unstable(feature = \"portable_simd\", issue = \"86656\")]\n //! Portable SIMD module.\n "}, {"sha": "c36c336d8a216ce91fdf04f668020bf4b477eb28", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -15,7 +15,10 @@ mod mask_impl;\n mod to_bitmask;\n pub use to_bitmask::ToBitMask;\n \n-use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n+#[cfg(feature = \"generic_const_exprs\")]\n+pub use to_bitmask::{bitmask_len, ToBitMaskArray};\n+\n+use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SimdPartialEq, SupportedLaneCount};\n use core::cmp::Ordering;\n use core::{fmt, mem};\n \n@@ -56,7 +59,7 @@ macro_rules! impl_element {\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n-                (value.lanes_eq(Simd::splat(0)) | value.lanes_eq(Simd::splat(-1))).all()\n+                (value.simd_eq(Simd::splat(0 as _)) | value.simd_eq(Simd::splat(-1 as _))).all()\n             }\n \n             fn eq(self, other: Self) -> bool { self == other }\n@@ -65,6 +68,7 @@ macro_rules! impl_element {\n             const FALSE: Self = 0;\n         }\n \n+        // Safety: this is a valid mask element type\n         unsafe impl MaskElement for $ty {}\n     }\n }\n@@ -77,6 +81,8 @@ impl_element! { isize }\n \n /// A SIMD vector mask for `LANES` elements of width specified by `Element`.\n ///\n+/// Masks represent boolean inclusion/exclusion on a per-lane basis.\n+///\n /// The layout of this type is unspecified.\n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(mask_impl::Mask<T, LANES>)\n@@ -179,6 +185,13 @@ where\n         self.0.to_int()\n     }\n \n+    /// Converts the mask to a mask of any other lane size.\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    pub fn cast<U: MaskElement>(self) -> Mask<U, LANES> {\n+        Mask(self.0.convert())\n+    }\n+\n     /// Tests the value of the specified lane.\n     ///\n     /// # Safety\n@@ -507,58 +520,58 @@ where\n     }\n }\n \n-/// Vector of eight 8-bit masks\n+/// A mask for SIMD vectors with eight elements of 8 bits.\n pub type mask8x8 = Mask<i8, 8>;\n \n-/// Vector of 16 8-bit masks\n+/// A mask for SIMD vectors with 16 elements of 8 bits.\n pub type mask8x16 = Mask<i8, 16>;\n \n-/// Vector of 32 8-bit masks\n+/// A mask for SIMD vectors with 32 elements of 8 bits.\n pub type mask8x32 = Mask<i8, 32>;\n \n-/// Vector of 16 8-bit masks\n+/// A mask for SIMD vectors with 64 elements of 8 bits.\n pub type mask8x64 = Mask<i8, 64>;\n \n-/// Vector of four 16-bit masks\n+/// A mask for SIMD vectors with four elements of 16 bits.\n pub type mask16x4 = Mask<i16, 4>;\n \n-/// Vector of eight 16-bit masks\n+/// A mask for SIMD vectors with eight elements of 16 bits.\n pub type mask16x8 = Mask<i16, 8>;\n \n-/// Vector of 16 16-bit masks\n+/// A mask for SIMD vectors with 16 elements of 16 bits.\n pub type mask16x16 = Mask<i16, 16>;\n \n-/// Vector of 32 16-bit masks\n+/// A mask for SIMD vectors with 32 elements of 16 bits.\n pub type mask16x32 = Mask<i16, 32>;\n \n-/// Vector of two 32-bit masks\n+/// A mask for SIMD vectors with two elements of 32 bits.\n pub type mask32x2 = Mask<i32, 2>;\n \n-/// Vector of four 32-bit masks\n+/// A mask for SIMD vectors with four elements of 32 bits.\n pub type mask32x4 = Mask<i32, 4>;\n \n-/// Vector of eight 32-bit masks\n+/// A mask for SIMD vectors with eight elements of 32 bits.\n pub type mask32x8 = Mask<i32, 8>;\n \n-/// Vector of 16 32-bit masks\n+/// A mask for SIMD vectors with 16 elements of 32 bits.\n pub type mask32x16 = Mask<i32, 16>;\n \n-/// Vector of two 64-bit masks\n+/// A mask for SIMD vectors with two elements of 64 bits.\n pub type mask64x2 = Mask<i64, 2>;\n \n-/// Vector of four 64-bit masks\n+/// A mask for SIMD vectors with four elements of 64 bits.\n pub type mask64x4 = Mask<i64, 4>;\n \n-/// Vector of eight 64-bit masks\n+/// A mask for SIMD vectors with eight elements of 64 bits.\n pub type mask64x8 = Mask<i64, 8>;\n \n-/// Vector of two pointer-width masks\n+/// A mask for SIMD vectors with two elements of pointer width.\n pub type masksizex2 = Mask<isize, 2>;\n \n-/// Vector of four pointer-width masks\n+/// A mask for SIMD vectors with four elements of pointer width.\n pub type masksizex4 = Mask<isize, 4>;\n \n-/// Vector of eight pointer-width masks\n+/// A mask for SIMD vectors with eight elements of pointer width.\n pub type masksizex8 = Mask<isize, 8>;\n \n macro_rules! impl_from {\n@@ -569,7 +582,7 @@ macro_rules! impl_from {\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn from(value: Mask<$from, LANES>) -> Self {\n-                Self(value.0.convert())\n+                value.cast()\n             }\n         }\n         )*"}, {"sha": "365ecc0a3251ec0687515ec443c1b8e505e939b2", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -115,6 +115,26 @@ where\n         unsafe { Self(intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n+    pub fn to_bitmask_array<const N: usize>(self) -> [u8; N] {\n+        assert!(core::mem::size_of::<Self>() == N);\n+\n+        // Safety: converting an integer to an array of bytes of the same size is safe\n+        unsafe { core::mem::transmute_copy(&self.0) }\n+    }\n+\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    pub fn from_bitmask_array<const N: usize>(bitmask: [u8; N]) -> Self {\n+        assert!(core::mem::size_of::<Self>() == N);\n+\n+        // Safety: converting an array of bytes to an integer of the same size is safe\n+        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    }\n+\n     #[inline]\n     pub fn to_bitmask_integer<U>(self) -> U\n     where"}, {"sha": "adf0fcbeae2bd2af551e083312cc4dadd1924e4d", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 81, "deletions": 4, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -4,6 +4,9 @@ use super::MaskElement;\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n \n+#[cfg(feature = \"generic_const_exprs\")]\n+use crate::simd::ToBitMaskArray;\n+\n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n where\n@@ -68,14 +71,26 @@ where\n \n // Used for bitmask bit order workaround\n pub(crate) trait ReverseBits {\n-    fn reverse_bits(self) -> Self;\n+    // Reverse the least significant `n` bits of `self`.\n+    // (Remaining bits must be 0.)\n+    fn reverse_bits(self, n: usize) -> Self;\n }\n \n macro_rules! impl_reverse_bits {\n     { $($int:ty),* } => {\n         $(\n         impl ReverseBits for $int {\n-            fn reverse_bits(self) -> Self { <$int>::reverse_bits(self) }\n+            #[inline(always)]\n+            fn reverse_bits(self, n: usize) -> Self {\n+                let rev = <$int>::reverse_bits(self);\n+                let bitsize = core::mem::size_of::<$int>() * 8;\n+                if n < bitsize {\n+                    // Shift things back to the right\n+                    rev >> (bitsize - n)\n+                } else {\n+                    rev\n+                }\n+            }\n         }\n         )*\n     }\n@@ -127,6 +142,68 @@ where\n         unsafe { Mask(intrinsics::simd_cast(self.0)) }\n     }\n \n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n+    pub fn to_bitmask_array<const N: usize>(self) -> [u8; N]\n+    where\n+        super::Mask<T, LANES>: ToBitMaskArray,\n+        [(); <super::Mask<T, LANES> as ToBitMaskArray>::BYTES]: Sized,\n+    {\n+        assert_eq!(<super::Mask<T, LANES> as ToBitMaskArray>::BYTES, N);\n+\n+        // Safety: N is the correct bitmask size\n+        unsafe {\n+            // Compute the bitmask\n+            let bitmask: [u8; <super::Mask<T, LANES> as ToBitMaskArray>::BYTES] =\n+                intrinsics::simd_bitmask(self.0);\n+\n+            // Transmute to the return type, previously asserted to be the same size\n+            let mut bitmask: [u8; N] = core::mem::transmute_copy(&bitmask);\n+\n+            // LLVM assumes bit order should match endianness\n+            if cfg!(target_endian = \"big\") {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n+            };\n+\n+            bitmask\n+        }\n+    }\n+\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    pub fn from_bitmask_array<const N: usize>(mut bitmask: [u8; N]) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMaskArray,\n+        [(); <super::Mask<T, LANES> as ToBitMaskArray>::BYTES]: Sized,\n+    {\n+        assert_eq!(<super::Mask<T, LANES> as ToBitMaskArray>::BYTES, N);\n+\n+        // Safety: N is the correct bitmask size\n+        unsafe {\n+            // LLVM assumes bit order should match endianness\n+            if cfg!(target_endian = \"big\") {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n+            }\n+\n+            // Transmute to the bitmask type, previously asserted to be the same size\n+            let bitmask: [u8; <super::Mask<T, LANES> as ToBitMaskArray>::BYTES] =\n+                core::mem::transmute_copy(&bitmask);\n+\n+            // Compute the regular mask\n+            Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n+                bitmask,\n+                Self::splat(true).to_int(),\n+                Self::splat(false).to_int(),\n+            ))\n+        }\n+    }\n+\n     #[inline]\n     pub(crate) fn to_bitmask_integer<U: ReverseBits>(self) -> U\n     where\n@@ -137,7 +214,7 @@ where\n \n         // LLVM assumes bit order should match endianness\n         if cfg!(target_endian = \"big\") {\n-            bitmask.reverse_bits()\n+            bitmask.reverse_bits(LANES)\n         } else {\n             bitmask\n         }\n@@ -150,7 +227,7 @@ where\n     {\n         // LLVM assumes bit order should match endianness\n         let bitmask = if cfg!(target_endian = \"big\") {\n-            bitmask.reverse_bits()\n+            bitmask.reverse_bits(LANES)\n         } else {\n             bitmask\n         };"}, {"sha": "65d3ce9be65ecfa123585f3b6e9ccedb0ae07d58", "filename": "library/portable-simd/crates/core_simd/src/masks/to_bitmask.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -16,11 +16,7 @@ where\n /// Converts masks to and from integer bitmasks.\n ///\n /// Each bit of the bitmask corresponds to a mask lane, starting with the LSB.\n-///\n-/// # Safety\n-/// This trait is `unsafe` and sealed, since the `BitMask` type must match the number of lanes in\n-/// the mask.\n-pub unsafe trait ToBitMask: Sealed {\n+pub trait ToBitMask: Sealed {\n     /// The integer bitmask type.\n     type BitMask;\n \n@@ -31,10 +27,25 @@ pub unsafe trait ToBitMask: Sealed {\n     fn from_bitmask(bitmask: Self::BitMask) -> Self;\n }\n \n+/// Converts masks to and from byte array bitmasks.\n+///\n+/// Each bit of the bitmask corresponds to a mask lane, starting with the LSB of the first byte.\n+#[cfg(feature = \"generic_const_exprs\")]\n+pub trait ToBitMaskArray: Sealed {\n+    /// The length of the bitmask array.\n+    const BYTES: usize;\n+\n+    /// Converts a mask to a bitmask.\n+    fn to_bitmask_array(self) -> [u8; Self::BYTES];\n+\n+    /// Converts a bitmask to a mask.\n+    fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self;\n+}\n+\n macro_rules! impl_integer_intrinsic {\n-    { $(unsafe impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n+    { $(impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n         $(\n-        unsafe impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n+        impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n             type BitMask = $int;\n \n             fn to_bitmask(self) -> $int {\n@@ -50,11 +61,33 @@ macro_rules! impl_integer_intrinsic {\n }\n \n impl_integer_intrinsic! {\n-    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 1>\n-    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 2>\n-    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 4>\n-    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 8>\n-    unsafe impl ToBitMask<BitMask=u16> for Mask<_, 16>\n-    unsafe impl ToBitMask<BitMask=u32> for Mask<_, 32>\n-    unsafe impl ToBitMask<BitMask=u64> for Mask<_, 64>\n+    impl ToBitMask<BitMask=u8> for Mask<_, 1>\n+    impl ToBitMask<BitMask=u8> for Mask<_, 2>\n+    impl ToBitMask<BitMask=u8> for Mask<_, 4>\n+    impl ToBitMask<BitMask=u8> for Mask<_, 8>\n+    impl ToBitMask<BitMask=u16> for Mask<_, 16>\n+    impl ToBitMask<BitMask=u32> for Mask<_, 32>\n+    impl ToBitMask<BitMask=u64> for Mask<_, 64>\n+}\n+\n+/// Returns the minimum numnber of bytes in a bitmask with `lanes` lanes.\n+#[cfg(feature = \"generic_const_exprs\")]\n+pub const fn bitmask_len(lanes: usize) -> usize {\n+    (lanes + 7) / 8\n+}\n+\n+#[cfg(feature = \"generic_const_exprs\")]\n+impl<T: MaskElement, const LANES: usize> ToBitMaskArray for Mask<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    const BYTES: usize = bitmask_len(LANES);\n+\n+    fn to_bitmask_array(self) -> [u8; Self::BYTES] {\n+        self.0.to_bitmask_array()\n+    }\n+\n+    fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self {\n+        Mask(mask_impl::Mask::from_bitmask_array(bitmask))\n+    }\n }"}, {"sha": "606021e983ed176b2c73c8117b9dde4f362bf808", "filename": "library/portable-simd/crates/core_simd/src/math.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=246f66a905c2815f2c9b9c3d6b1e0649f3360ef8", "patch": "@@ -1,156 +0,0 @@\n-use crate::simd::intrinsics::{simd_saturating_add, simd_saturating_sub};\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-macro_rules! impl_uint_arith {\n-    ($($ty:ty),+) => {\n-        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n-\n-            /// Lanewise saturating add.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n-            /// let x = Simd::from_array([2, 1, 0, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x + max;\n-            /// let sat = x.saturating_add(max);\n-            /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n-            /// assert_eq!(sat, max);\n-            /// ```\n-            #[inline]\n-            pub fn saturating_add(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_add(self, second) }\n-            }\n-\n-            /// Lanewise saturating subtract.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n-            /// let x = Simd::from_array([2, 1, 0, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x - max;\n-            /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n-            /// assert_eq!(sat, Simd::splat(0));\n-            #[inline]\n-            pub fn saturating_sub(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_sub(self, second) }\n-            }\n-        })+\n-    }\n-}\n-\n-macro_rules! impl_int_arith {\n-    ($($ty:ty),+) => {\n-        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n-\n-            /// Lanewise saturating add.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x + max;\n-            /// let sat = x.saturating_add(max);\n-            /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n-            /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_add(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_add(self, second) }\n-            }\n-\n-            /// Lanewise saturating subtract.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x - max;\n-            /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n-            /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n-            #[inline]\n-            pub fn saturating_sub(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_sub(self, second) }\n-            }\n-\n-            /// Lanewise absolute value, implemented in Rust.\n-            /// Every lane becomes its absolute value.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n-            /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n-            /// ```\n-            #[inline]\n-            pub fn abs(self) -> Self {\n-                const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> Simd::splat(SHR);\n-                (self^m) - m\n-            }\n-\n-            /// Lanewise saturating absolute value, implemented in Rust.\n-            /// As abs(), except the MIN value becomes MAX instead of itself.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n-            /// let unsat = xs.abs();\n-            /// let sat = xs.saturating_abs();\n-            /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n-            /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_abs(self) -> Self {\n-                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n-                const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> Simd::splat(SHR);\n-                (self^m).saturating_sub(m)\n-            }\n-\n-            /// Lanewise saturating negation, implemented in Rust.\n-            /// As neg(), except the MIN value becomes MAX instead of itself.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n-            /// let unsat = -x;\n-            /// let sat = x.saturating_neg();\n-            /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n-            /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_neg(self) -> Self {\n-                Self::splat(0).saturating_sub(self)\n-            }\n-        })+\n-    }\n-}\n-\n-impl_uint_arith! { u8, u16, u32, u64, usize }\n-impl_int_arith! { i8, i16, i32, i64, isize }"}, {"sha": "b472aa3abe2102d2c2af709d7c252be6b6f83b52", "filename": "library/portable-simd/crates/core_simd/src/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -1,6 +1,3 @@\n-#[macro_use]\n-mod reduction;\n-\n #[macro_use]\n mod swizzle;\n \n@@ -9,14 +6,14 @@ pub(crate) mod intrinsics;\n #[cfg(feature = \"generic_const_exprs\")]\n mod to_bytes;\n \n-mod comparisons;\n+mod elements;\n+mod eq;\n mod fmt;\n mod iter;\n mod lane_count;\n mod masks;\n-mod math;\n mod ops;\n-mod round;\n+mod ord;\n mod select;\n mod vector;\n mod vendor;\n@@ -25,8 +22,11 @@ mod vendor;\n pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n+    pub use crate::core_simd::elements::*;\n+    pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;\n+    pub use crate::core_simd::ord::*;\n     pub use crate::core_simd::swizzle::*;\n     pub use crate::core_simd::vector::*;\n }"}, {"sha": "5a077a469d8390b427bfd8f69567a0b960d072a9", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -1,4 +1,4 @@\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SimdElement, SimdPartialEq, SupportedLaneCount};\n use core::ops::{Add, Mul};\n use core::ops::{BitAnd, BitOr, BitXor};\n use core::ops::{Div, Rem, Sub};\n@@ -33,6 +33,7 @@ where\n \n macro_rules! unsafe_base {\n     ($lhs:ident, $rhs:ident, {$simd_call:ident}, $($_:tt)*) => {\n+        // Safety: $lhs and $rhs are vectors\n         unsafe { $crate::simd::intrinsics::$simd_call($lhs, $rhs) }\n     };\n }\n@@ -48,6 +49,8 @@ macro_rules! unsafe_base {\n // cg_clif defaults to this, and scalar MIR shifts also default to wrapping\n macro_rules! wrap_bitshift {\n     ($lhs:ident, $rhs:ident, {$simd_call:ident}, $int:ident) => {\n+        #[allow(clippy::suspicious_arithmetic_impl)]\n+        // Safety: $lhs and the bitand result are vectors\n         unsafe {\n             $crate::simd::intrinsics::$simd_call(\n                 $lhs,\n@@ -74,22 +77,23 @@ macro_rules! int_divrem_guard {\n             $simd_call:ident\n         },\n         $int:ident ) => {\n-        if $rhs.lanes_eq(Simd::splat(0)).any() {\n+        if $rhs.simd_eq(Simd::splat(0 as _)).any() {\n             panic!($zero);\n         } else {\n             // Prevent otherwise-UB overflow on the MIN / -1 case.\n             let rhs = if <$int>::MIN != 0 {\n                 // This should, at worst, optimize to a few branchless logical ops\n                 // Ideally, this entire conditional should evaporate\n                 // Fire LLVM and implement those manually if it doesn't get the hint\n-                ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n+                ($lhs.simd_eq(Simd::splat(<$int>::MIN))\n                 // type inference can break here, so cut an SInt to size\n-                & $rhs.lanes_eq(Simd::splat(-1i64 as _)))\n-                .select(Simd::splat(1), $rhs)\n+                & $rhs.simd_eq(Simd::splat(-1i64 as _)))\n+                .select(Simd::splat(1 as _), $rhs)\n             } else {\n                 // Nice base case to make it easy to const-fold away the other branch.\n                 $rhs\n             };\n+            // Safety: $lhs and rhs are vectors\n             unsafe { $crate::simd::intrinsics::$simd_call($lhs, rhs) }\n         }\n     };"}, {"sha": "4ad02215034be3ddd3bb9d95396052d5edfbf9a2", "filename": "library/portable-simd/crates/core_simd/src/ops/unary.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -14,6 +14,7 @@ macro_rules! neg {\n             #[inline]\n             #[must_use = \"operator returns a new vector without mutating the input\"]\n             fn neg(self) -> Self::Output {\n+                // Safety: `self` is a signed vector\n                 unsafe { intrinsics::simd_neg(self) }\n             }\n         })*"}, {"sha": "9a87bc2e34460628597d227af8350f136bc39632", "filename": "library/portable-simd/crates/core_simd/src/ord.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -0,0 +1,213 @@\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Parallel `PartialOrd`.\n+pub trait SimdPartialOrd: SimdPartialEq {\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_lt(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_le(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_gt(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_ge(self, other: Self) -> Self::Mask;\n+}\n+\n+/// Parallel `Ord`.\n+pub trait SimdOrd: SimdPartialOrd {\n+    /// Returns the lane-wise maximum with `other`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_max(self, other: Self) -> Self;\n+\n+    /// Returns the lane-wise minimum with `other`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_min(self, other: Self) -> Self;\n+\n+    /// Restrict each lane to a certain interval.\n+    ///\n+    /// For each lane, returns `max` if `self` is greater than `max`, and `min` if `self` is\n+    /// less than `min`. Otherwise returns `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `min > max` on any lane.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self;\n+}\n+\n+macro_rules! impl_integer {\n+    { $($integer:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialOrd for Simd<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_lt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_le(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_gt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_ge(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+            }\n+        }\n+\n+        impl<const LANES: usize> SimdOrd for Simd<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                self.simd_lt(other).select(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                self.simd_gt(other).select(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                self.simd_max(min).simd_min(max)\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_integer! { u8, u16, u32, u64, usize, i8, i16, i32, i64, isize }\n+\n+macro_rules! impl_float {\n+    { $($float:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialOrd for Simd<$float, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_lt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_le(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_gt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_ge(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_float! { f32, f64 }\n+\n+macro_rules! impl_mask {\n+    { $($integer:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialOrd for Mask<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_lt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_lt(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_le(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_le(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_gt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_gt(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_ge(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_ge(self.to_int(), other.to_int())) }\n+            }\n+        }\n+\n+        impl<const LANES: usize> SimdOrd for Mask<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                self.simd_gt(other).select_mask(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                self.simd_lt(other).select_mask(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                self.simd_max(min).simd_min(max)\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_mask! { i8, i16, i32, i64, isize }"}, {"sha": "3177fd167fc44bcf2ad168503d1b6d7fd96190ef", "filename": "library/portable-simd/crates/core_simd/src/reduction.rs", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=246f66a905c2815f2c9b9c3d6b1e0649f3360ef8", "patch": "@@ -1,153 +0,0 @@\n-use crate::simd::intrinsics::{\n-    simd_reduce_add_ordered, simd_reduce_and, simd_reduce_max, simd_reduce_min,\n-    simd_reduce_mul_ordered, simd_reduce_or, simd_reduce_xor,\n-};\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n-use core::ops::{BitAnd, BitOr, BitXor};\n-\n-macro_rules! impl_integer_reductions {\n-    { $scalar:ty } => {\n-        impl<const LANES: usize> Simd<$scalar, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n-            #[inline]\n-            pub fn reduce_sum(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_add_ordered(self, 0) }\n-            }\n-\n-            /// Reducing wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n-            #[inline]\n-            pub fn reduce_product(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_mul_ordered(self, 1) }\n-            }\n-\n-            /// Reducing maximum.  Returns the maximum lane in the vector.\n-            #[inline]\n-            pub fn reduce_max(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_max(self) }\n-            }\n-\n-            /// Reducing minimum.  Returns the minimum lane in the vector.\n-            #[inline]\n-            pub fn reduce_min(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_min(self) }\n-            }\n-        }\n-    }\n-}\n-\n-impl_integer_reductions! { i8 }\n-impl_integer_reductions! { i16 }\n-impl_integer_reductions! { i32 }\n-impl_integer_reductions! { i64 }\n-impl_integer_reductions! { isize }\n-impl_integer_reductions! { u8 }\n-impl_integer_reductions! { u16 }\n-impl_integer_reductions! { u32 }\n-impl_integer_reductions! { u64 }\n-impl_integer_reductions! { usize }\n-\n-macro_rules! impl_float_reductions {\n-    { $scalar:ty } => {\n-        impl<const LANES: usize> Simd<$scalar, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-\n-            /// Reducing add.  Returns the sum of the lanes of the vector.\n-            #[inline]\n-            pub fn reduce_sum(self) -> $scalar {\n-                // LLVM sum is inaccurate on i586\n-                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_array().iter().sum()\n-                } else {\n-                    // Safety: `self` is a float vector\n-                    unsafe { simd_reduce_add_ordered(self, 0.) }\n-                }\n-            }\n-\n-            /// Reducing multiply.  Returns the product of the lanes of the vector.\n-            #[inline]\n-            pub fn reduce_product(self) -> $scalar {\n-                // LLVM product is inaccurate on i586\n-                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_array().iter().product()\n-                } else {\n-                    // Safety: `self` is a float vector\n-                    unsafe { simd_reduce_mul_ordered(self, 1.) }\n-                }\n-            }\n-\n-            /// Reducing maximum.  Returns the maximum lane in the vector.\n-            ///\n-            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n-            #[inline]\n-            pub fn reduce_max(self) -> $scalar {\n-                // Safety: `self` is a float vector\n-                unsafe { simd_reduce_max(self) }\n-            }\n-\n-            /// Reducing minimum.  Returns the minimum lane in the vector.\n-            ///\n-            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n-            #[inline]\n-            pub fn reduce_min(self) -> $scalar {\n-                // Safety: `self` is a float vector\n-                unsafe { simd_reduce_min(self) }\n-            }\n-        }\n-    }\n-}\n-\n-impl_float_reductions! { f32 }\n-impl_float_reductions! { f64 }\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitAnd<Self, Output = Self>,\n-    T: SimdElement + BitAnd<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_and(self) -> T {\n-        unsafe { simd_reduce_and(self) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitOr<Self, Output = Self>,\n-    T: SimdElement + BitOr<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_or(self) -> T {\n-        unsafe { simd_reduce_or(self) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitXor<Self, Output = Self>,\n-    T: SimdElement + BitXor<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_xor(self) -> T {\n-        unsafe { simd_reduce_xor(self) }\n-    }\n-}"}, {"sha": "556bc2cc1feee8a114253cdb99d464a5438b3bba", "filename": "library/portable-simd/crates/core_simd/src/round.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246f66a905c2815f2c9b9c3d6b1e0649f3360ef8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs?ref=246f66a905c2815f2c9b9c3d6b1e0649f3360ef8", "patch": "@@ -1,40 +0,0 @@\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n-use core::convert::FloatToInt;\n-\n-macro_rules! implement {\n-    {\n-        $type:ty\n-    } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Rounds toward zero and converts to the same-width integer type, assuming that\n-            /// the value is finite and fits in that type.\n-            ///\n-            /// # Safety\n-            /// The value must:\n-            ///\n-            /// * Not be NaN\n-            /// * Not be infinite\n-            /// * Be representable in the return type, after truncating off its fractional part\n-            ///\n-            /// If these requirements are infeasible or costly, consider using the safe function [cast],\n-            /// which saturates on conversion.\n-            ///\n-            /// [cast]: Simd::cast\n-            #[inline]\n-            pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n-            where\n-                $type: FloatToInt<I>,\n-                I: SimdElement,\n-            {\n-                unsafe { intrinsics::simd_cast(self) }\n-            }\n-        }\n-    }\n-}\n-\n-implement! { f32 }\n-implement! { f64 }"}, {"sha": "22999d24950f8d866e90c9a15a7ac3c4bc5f03ee", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -1,44 +1,46 @@\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n \n-/// Constructs a new vector by selecting values from the lanes of the source vector or vectors to use.\n+/// Constructs a new SIMD vector by copying elements from selected lanes in other vectors.\n ///\n-/// When swizzling one vector, the indices of the result vector are indicated by a `const` array\n-/// of `usize`, like [`Swizzle`].\n-/// When swizzling two vectors, the indices are indicated by a `const` array of [`Which`], like\n-/// [`Swizzle2`].\n+/// When swizzling one vector, lanes are selected by a `const` array of `usize`,\n+/// like [`Swizzle`].\n+///\n+/// When swizzling two vectors, lanes are selected by a `const` array of [`Which`],\n+/// like [`Swizzle2`].\n ///\n /// # Examples\n-/// ## One source vector\n+///\n+/// With a single SIMD vector, the const array specifies lane indices in that vector:\n /// ```\n /// # #![feature(portable_simd)]\n-/// # use core::simd::{Simd, simd_swizzle};\n-/// let v = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n+/// # use core::simd::{u32x2, u32x4, simd_swizzle};\n+/// let v = u32x4::from_array([10, 11, 12, 13]);\n ///\n /// // Keeping the same size\n-/// let r = simd_swizzle!(v, [3, 0, 1, 2]);\n-/// assert_eq!(r.to_array(), [3., 0., 1., 2.]);\n+/// let r: u32x4 = simd_swizzle!(v, [3, 0, 1, 2]);\n+/// assert_eq!(r.to_array(), [13, 10, 11, 12]);\n ///\n /// // Changing the number of lanes\n-/// let r = simd_swizzle!(v, [3, 1]);\n-/// assert_eq!(r.to_array(), [3., 1.]);\n+/// let r: u32x2 = simd_swizzle!(v, [3, 1]);\n+/// assert_eq!(r.to_array(), [13, 11]);\n /// ```\n ///\n-/// ## Two source vectors\n+/// With two input SIMD vectors, the const array uses `Which` to specify the source of each index:\n /// ```\n /// # #![feature(portable_simd)]\n-/// # use core::simd::{Simd, simd_swizzle, Which};\n-/// use Which::*;\n-/// let a = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n-/// let b = Simd::<f32, 4>::from_array([4., 5., 6., 7.]);\n+/// # use core::simd::{u32x2, u32x4, simd_swizzle, Which};\n+/// use Which::{First, Second};\n+/// let a = u32x4::from_array([0, 1, 2, 3]);\n+/// let b = u32x4::from_array([4, 5, 6, 7]);\n ///\n /// // Keeping the same size\n-/// let r = simd_swizzle!(a, b, [First(0), First(1), Second(2), Second(3)]);\n-/// assert_eq!(r.to_array(), [0., 1., 6., 7.]);\n+/// let r: u32x4 = simd_swizzle!(a, b, [First(0), First(1), Second(2), Second(3)]);\n+/// assert_eq!(r.to_array(), [0, 1, 6, 7]);\n ///\n /// // Changing the number of lanes\n-/// let r = simd_swizzle!(a, b, [First(0), Second(0)]);\n-/// assert_eq!(r.to_array(), [0., 4.]);\n+/// let r: u32x2 = simd_swizzle!(a, b, [First(0), Second(0)]);\n+/// assert_eq!(r.to_array(), [0, 4]);\n /// ```\n #[allow(unused_macros)]\n pub macro simd_swizzle {\n@@ -68,12 +70,14 @@ pub macro simd_swizzle {\n     }\n }\n \n-/// An index into one of two vectors.\n+/// Specifies a lane index into one of two SIMD vectors.\n+///\n+/// This is an input type for [Swizzle2] and helper macros like [simd_swizzle].\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum Which {\n-    /// Indexes the first vector.\n+    /// Index of a lane in the first input SIMD vector.\n     First(usize),\n-    /// Indexes the second vector.\n+    /// Index of a lane in the second input SIMD vector.\n     Second(usize),\n }\n "}, {"sha": "78f56402eba40717f748b62525b04ee609c0f8fa", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 139, "deletions": 18, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -9,8 +9,9 @@ pub use uint::*;\n // Vectors of pointers are not for public use at the current time.\n pub(crate) mod ptr;\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, MaskElement, SimdPartialOrd, SupportedLaneCount, Swizzle,\n+};\n \n /// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n ///\n@@ -99,17 +100,50 @@ where\n     /// Number of lanes in this vector.\n     pub const LANES: usize = LANES;\n \n-    /// Get the number of lanes in this vector.\n+    /// Returns the number of lanes in this SIMD vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::u32x4;\n+    /// let v = u32x4::splat(0);\n+    /// assert_eq!(v.lanes(), 4);\n+    /// ```\n     pub const fn lanes(&self) -> usize {\n         LANES\n     }\n \n-    /// Construct a SIMD vector by setting all lanes to the given value.\n-    pub const fn splat(value: T) -> Self {\n-        Self([value; LANES])\n+    /// Constructs a new SIMD vector with all lanes set to the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::u32x4;\n+    /// let v = u32x4::splat(8);\n+    /// assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n+    /// ```\n+    pub fn splat(value: T) -> Self {\n+        // This is preferred over `[value; LANES]`, since it's explicitly a splat:\n+        // https://github.com/rust-lang/rust/issues/97804\n+        struct Splat;\n+        impl<const LANES: usize> Swizzle<1, LANES> for Splat {\n+            const INDEX: [usize; LANES] = [0; LANES];\n+        }\n+        Splat::swizzle(Simd::<T, 1>::from([value]))\n     }\n \n     /// Returns an array reference containing the entire SIMD vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::{Simd, u64x4};\n+    /// let v: u64x4 = Simd::from_array([0, 1, 2, 3]);\n+    /// assert_eq!(v.as_array(), &[0, 1, 2, 3]);\n+    /// ```\n     pub const fn as_array(&self) -> &[T; LANES] {\n         &self.0\n     }\n@@ -129,9 +163,21 @@ where\n         self.0\n     }\n \n-    /// Converts a slice to a SIMD vector containing `slice[..LANES]`\n+    /// Converts a slice to a SIMD vector containing `slice[..LANES]`.\n+    ///\n     /// # Panics\n-    /// `from_slice` will panic if the slice's `len` is less than the vector's `Simd::LANES`.\n+    ///\n+    /// Panics if the slice's length is less than the vector's `Simd::LANES`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::u32x4;\n+    /// let source = vec![1, 2, 3, 4, 5, 6];\n+    /// let v = u32x4::from_slice(&source);\n+    /// assert_eq!(v.as_array(), &[1, 2, 3, 4]);\n+    /// ```\n     #[must_use]\n     pub const fn from_slice(slice: &[T]) -> Self {\n         assert!(slice.len() >= LANES, \"slice length must be at least the number of lanes\");\n@@ -145,6 +191,7 @@ where\n     }\n \n     /// Performs lanewise conversion of a SIMD vector's elements to another SIMD-valid type.\n+    ///\n     /// This follows the semantics of Rust's `as` conversion for casting\n     /// integers to unsigned integers (interpreting as the other type, so `-1` to `MAX`),\n     /// and from floats to integers (truncating, or saturating at the limits) for each lane,\n@@ -169,10 +216,35 @@ where\n     #[must_use]\n     #[inline]\n     pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n-        // Safety: The input argument is a vector of a known SIMD type.\n+        // Safety: The input argument is a vector of a valid SIMD element type.\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n+    /// Rounds toward zero and converts to the same-width integer type, assuming that\n+    /// the value is finite and fits in that type.\n+    ///\n+    /// # Safety\n+    /// The value must:\n+    ///\n+    /// * Not be NaN\n+    /// * Not be infinite\n+    /// * Be representable in the return type, after truncating off its fractional part\n+    ///\n+    /// If these requirements are infeasible or costly, consider using the safe function [cast],\n+    /// which saturates on conversion.\n+    ///\n+    /// [cast]: Simd::cast\n+    #[inline]\n+    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n+    where\n+        T: core::convert::FloatToInt<I>,\n+        I: SimdElement,\n+    {\n+        // Safety: `self` is a vector, and `FloatToInt` ensures the type can be casted to\n+        // an integer.\n+        unsafe { intrinsics::simd_cast(self) }\n+    }\n+\n     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n     /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n     ///\n@@ -239,7 +311,7 @@ where\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n+        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n         // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n@@ -256,13 +328,15 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # use core::simd::{Simd, Mask};\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdPartialOrd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n     /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n     /// // If this mask was used to gather, it would be unsound. Let's fix that.\n-    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n+    /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n     /// // We have masked the OOB lane, so it's safe to gather now.\n     /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n@@ -313,7 +387,9 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # use core::simd::{Simd, Mask};\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n@@ -329,7 +405,7 @@ where\n         enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n+        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n         // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n@@ -347,13 +423,15 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # use core::simd::{Simd, Mask};\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdPartialOrd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n     /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n-    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n+    /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n     /// // We have masked the OOB lane, so it's safe to scatter now.\n     /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n@@ -425,8 +503,27 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        // TODO use SIMD equality\n-        self.to_array() == other.to_array()\n+        // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n+        let mask = unsafe {\n+            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_eq(*self, *other);\n+            Mask::from_int_unchecked(tfvec)\n+        };\n+\n+        // Two vectors are equal if all lanes tested true for vertical equality.\n+        mask.all()\n+    }\n+\n+    #[allow(clippy::partialeq_ne_impl)]\n+    #[inline]\n+    fn ne(&self, other: &Self) -> bool {\n+        // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n+        let mask = unsafe {\n+            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_ne(*self, *other);\n+            Mask::from_int_unchecked(tfvec)\n+        };\n+\n+        // Two vectors are non-equal if any lane tested true for vertical non-equality.\n+        mask.any()\n     }\n }\n \n@@ -561,61 +658,85 @@ pub unsafe trait SimdElement: Sealed + Copy {\n }\n \n impl Sealed for u8 {}\n+\n+// Safety: u8 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for u8 {\n     type Mask = i8;\n }\n \n impl Sealed for u16 {}\n+\n+// Safety: u16 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for u16 {\n     type Mask = i16;\n }\n \n impl Sealed for u32 {}\n+\n+// Safety: u32 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for u32 {\n     type Mask = i32;\n }\n \n impl Sealed for u64 {}\n+\n+// Safety: u64 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for u64 {\n     type Mask = i64;\n }\n \n impl Sealed for usize {}\n+\n+// Safety: usize is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for usize {\n     type Mask = isize;\n }\n \n impl Sealed for i8 {}\n+\n+// Safety: i8 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for i8 {\n     type Mask = i8;\n }\n \n impl Sealed for i16 {}\n+\n+// Safety: i16 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for i16 {\n     type Mask = i16;\n }\n \n impl Sealed for i32 {}\n+\n+// Safety: i32 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for i32 {\n     type Mask = i32;\n }\n \n impl Sealed for i64 {}\n+\n+// Safety: i64 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for i64 {\n     type Mask = i64;\n }\n \n impl Sealed for isize {}\n+\n+// Safety: isize is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for isize {\n     type Mask = isize;\n }\n \n impl Sealed for f32 {}\n+\n+// Safety: f32 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for f32 {\n     type Mask = i32;\n }\n \n impl Sealed for f64 {}\n+\n+// Safety: f64 is a valid SIMD element type, and is supported by this API\n unsafe impl SimdElement for f64 {\n     type Mask = i64;\n }"}, {"sha": "f836c99b1e2dc41564f0e85ad648f5ad2d476c04", "filename": "library/portable-simd/crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 8, "deletions": 183, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -1,199 +1,24 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, Simd, SupportedLaneCount};\n+use crate::simd::Simd;\n \n-/// Implements inherent methods for a float vector containing multiple\n-/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n-/// representation.\n-macro_rules! impl_float_vector {\n-    { $type:ty, $bits_ty:ty, $mask_ty:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Raw transmutation to an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n-                unsafe { core::mem::transmute_copy(&self) }\n-            }\n-\n-            /// Raw transmutation from an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n-                unsafe { core::mem::transmute_copy(&bits) }\n-            }\n-\n-            /// Produces a vector where every lane has the absolute value of the\n-            /// equivalently-indexed lane in `self`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn abs(self) -> Self {\n-                unsafe { intrinsics::simd_fabs(self) }\n-            }\n-\n-            /// Takes the reciprocal (inverse) of each lane, `1/x`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn recip(self) -> Self {\n-                Self::splat(1.0) / self\n-            }\n-\n-            /// Converts each lane from radians to degrees.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_degrees(self) -> Self {\n-                // to_degrees uses a special constant for better precision, so extract that constant\n-                self * Self::splat(<$type>::to_degrees(1.))\n-            }\n-\n-            /// Converts each lane from degrees to radians.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_radians(self) -> Self {\n-                self * Self::splat(<$type>::to_radians(1.))\n-            }\n-\n-            /// Returns true for each lane if it has a positive sign, including\n-            /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n-                !self.is_sign_negative()\n-            }\n-\n-            /// Returns true for each lane if it has a negative sign, including\n-            /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n-                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n-                sign_bits.lanes_gt(Simd::splat(0))\n-            }\n-\n-            /// Returns true for each lane if its value is `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n-                self.lanes_ne(self)\n-            }\n-\n-            /// Returns true for each lane if its value is positive infinity or negative infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n-            }\n-\n-            /// Returns true for each lane if its value is neither infinite nor `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n-            }\n-\n-            /// Returns true for each lane if its value is subnormal.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n-            }\n-\n-            /// Returns true for each lane if its value is neither zero, infinite,\n-            /// subnormal, nor `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n-                !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n-            }\n-\n-            /// Replaces each lane with a number that represents its sign.\n-            ///\n-            /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n-            /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n-            /// * `NAN` if the number is `NAN`\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn signum(self) -> Self {\n-                self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n-            }\n-\n-            /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n-            ///\n-            /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn copysign(self, sign: Self) -> Self {\n-                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n-                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n-                Self::from_bits(sign_bit | magnitude)\n-            }\n-\n-            /// Returns the minimum of each lane.\n-            ///\n-            /// If one of the values is `NAN`, then the other value is returned.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn min(self, other: Self) -> Self {\n-                unsafe { intrinsics::simd_fmin(self, other) }\n-            }\n-\n-            /// Returns the maximum of each lane.\n-            ///\n-            /// If one of the values is `NAN`, then the other value is returned.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn max(self, other: Self) -> Self {\n-                unsafe { intrinsics::simd_fmax(self, other) }\n-            }\n-\n-            /// Restrict each lane to a certain interval unless it is NaN.\n-            ///\n-            /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n-            /// greater than `max`, and the corresponding lane in `min` if the lane is less\n-            /// than `min`.  Otherwise returns the lane in `self`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn clamp(self, min: Self, max: Self) -> Self {\n-                assert!(\n-                    min.lanes_le(max).all(),\n-                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n-                );\n-                let mut x = self;\n-                x = x.lanes_lt(min).select(min, x);\n-                x = x.lanes_gt(max).select(max, x);\n-                x\n-            }\n-        }\n-    };\n-}\n-\n-impl_float_vector! { f32, u32, i32 }\n-impl_float_vector! { f64, u64, i64 }\n-\n-/// Vector of two `f32` values\n+/// A 64-bit SIMD vector with two elements of type `f32`.\n pub type f32x2 = Simd<f32, 2>;\n \n-/// Vector of four `f32` values\n+/// A 128-bit SIMD vector with four elements of type `f32`.\n pub type f32x4 = Simd<f32, 4>;\n \n-/// Vector of eight `f32` values\n+/// A 256-bit SIMD vector with eight elements of type `f32`.\n pub type f32x8 = Simd<f32, 8>;\n \n-/// Vector of 16 `f32` values\n+/// A 512-bit SIMD vector with 16 elements of type `f32`.\n pub type f32x16 = Simd<f32, 16>;\n \n-/// Vector of two `f64` values\n+/// A 128-bit SIMD vector with two elements of type `f64`.\n pub type f64x2 = Simd<f64, 2>;\n \n-/// Vector of four `f64` values\n+/// A 256-bit SIMD vector with four elements of type `f64`.\n pub type f64x4 = Simd<f64, 4>;\n \n-/// Vector of eight `f64` values\n+/// A 512-bit SIMD vector with eight elements of type `f64`.\n pub type f64x8 = Simd<f64, 8>;"}, {"sha": "20e56c7dc6443bdca6b8922dc3659e4f554c665e", "filename": "library/portable-simd/crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 22, "deletions": 62, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -1,103 +1,63 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::{LaneCount, Mask, Simd, SupportedLaneCount};\n-\n-/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_integer_vector {\n-    { $type:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns true for each positive lane and false if it is zero or negative.\n-            #[inline]\n-            pub fn is_positive(self) -> Mask<$type, LANES> {\n-                self.lanes_gt(Self::splat(0))\n-            }\n-\n-            /// Returns true for each negative lane and false if it is zero or positive.\n-            #[inline]\n-            pub fn is_negative(self) -> Mask<$type, LANES> {\n-                self.lanes_lt(Self::splat(0))\n-            }\n-\n-            /// Returns numbers representing the sign of each lane.\n-            /// * `0` if the number is zero\n-            /// * `1` if the number is positive\n-            /// * `-1` if the number is negative\n-            #[inline]\n-            pub fn signum(self) -> Self {\n-                self.is_positive().select(\n-                    Self::splat(1),\n-                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl_integer_vector! { isize }\n-impl_integer_vector! { i16 }\n-impl_integer_vector! { i32 }\n-impl_integer_vector! { i64 }\n-impl_integer_vector! { i8 }\n-\n-/// Vector of two `isize` values\n+use crate::simd::Simd;\n+\n+/// A SIMD vector with two elements of type `isize`.\n pub type isizex2 = Simd<isize, 2>;\n \n-/// Vector of four `isize` values\n+/// A SIMD vector with four elements of type `isize`.\n pub type isizex4 = Simd<isize, 4>;\n \n-/// Vector of eight `isize` values\n+/// A SIMD vector with eight elements of type `isize`.\n pub type isizex8 = Simd<isize, 8>;\n \n-/// Vector of two `i16` values\n+/// A 32-bit SIMD vector with two elements of type `i16`.\n pub type i16x2 = Simd<i16, 2>;\n \n-/// Vector of four `i16` values\n+/// A 64-bit SIMD vector with four elements of type `i16`.\n pub type i16x4 = Simd<i16, 4>;\n \n-/// Vector of eight `i16` values\n+/// A 128-bit SIMD vector with eight elements of type `i16`.\n pub type i16x8 = Simd<i16, 8>;\n \n-/// Vector of 16 `i16` values\n+/// A 256-bit SIMD vector with 16 elements of type `i16`.\n pub type i16x16 = Simd<i16, 16>;\n \n-/// Vector of 32 `i16` values\n+/// A 512-bit SIMD vector with 32 elements of type `i16`.\n pub type i16x32 = Simd<i16, 32>;\n \n-/// Vector of two `i32` values\n+/// A 64-bit SIMD vector with two elements of type `i32`.\n pub type i32x2 = Simd<i32, 2>;\n \n-/// Vector of four `i32` values\n+/// A 128-bit SIMD vector with four elements of type `i32`.\n pub type i32x4 = Simd<i32, 4>;\n \n-/// Vector of eight `i32` values\n+/// A 256-bit SIMD vector with eight elements of type `i32`.\n pub type i32x8 = Simd<i32, 8>;\n \n-/// Vector of 16 `i32` values\n+/// A 512-bit SIMD vector with 16 elements of type `i32`.\n pub type i32x16 = Simd<i32, 16>;\n \n-/// Vector of two `i64` values\n+/// A 128-bit SIMD vector with two elements of type `i64`.\n pub type i64x2 = Simd<i64, 2>;\n \n-/// Vector of four `i64` values\n+/// A 256-bit SIMD vector with four elements of type `i64`.\n pub type i64x4 = Simd<i64, 4>;\n \n-/// Vector of eight `i64` values\n+/// A 512-bit SIMD vector with eight elements of type `i64`.\n pub type i64x8 = Simd<i64, 8>;\n \n-/// Vector of four `i8` values\n+/// A 32-bit SIMD vector with four elements of type `i8`.\n pub type i8x4 = Simd<i8, 4>;\n \n-/// Vector of eight `i8` values\n+/// A 64-bit SIMD vector with eight elements of type `i8`.\n pub type i8x8 = Simd<i8, 8>;\n \n-/// Vector of 16 `i8` values\n+/// A 128-bit SIMD vector with 16 elements of type `i8`.\n pub type i8x16 = Simd<i8, 16>;\n \n-/// Vector of 32 `i8` values\n+/// A 256-bit SIMD vector with 32 elements of type `i8`.\n pub type i8x32 = Simd<i8, 32>;\n \n-/// Vector of 64 `i8` values\n+/// A 512-bit SIMD vector with 64 elements of type `i8`.\n pub type i8x64 = Simd<i8, 64>;"}, {"sha": "b4a69c44363f1d5a0d9297ccc06504f1ea65ac78", "filename": "library/portable-simd/crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -2,62 +2,62 @@\n \n use crate::simd::Simd;\n \n-/// Vector of two `usize` values\n+/// A SIMD vector with two elements of type `usize`.\n pub type usizex2 = Simd<usize, 2>;\n \n-/// Vector of four `usize` values\n+/// A SIMD vector with four elements of type `usize`.\n pub type usizex4 = Simd<usize, 4>;\n \n-/// Vector of eight `usize` values\n+/// A SIMD vector with eight elements of type `usize`.\n pub type usizex8 = Simd<usize, 8>;\n \n-/// Vector of two `u16` values\n+/// A 32-bit SIMD vector with two elements of type `u16`.\n pub type u16x2 = Simd<u16, 2>;\n \n-/// Vector of four `u16` values\n+/// A 64-bit SIMD vector with four elements of type `u16`.\n pub type u16x4 = Simd<u16, 4>;\n \n-/// Vector of eight `u16` values\n+/// A 128-bit SIMD vector with eight elements of type `u16`.\n pub type u16x8 = Simd<u16, 8>;\n \n-/// Vector of 16 `u16` values\n+/// A 256-bit SIMD vector with 16 elements of type `u16`.\n pub type u16x16 = Simd<u16, 16>;\n \n-/// Vector of 32 `u16` values\n+/// A 512-bit SIMD vector with 32 elements of type `u16`.\n pub type u16x32 = Simd<u16, 32>;\n \n-/// Vector of two `u32` values\n+/// A 64-bit SIMD vector with two elements of type `u32`.\n pub type u32x2 = Simd<u32, 2>;\n \n-/// Vector of four `u32` values\n+/// A 128-bit SIMD vector with four elements of type `u32`.\n pub type u32x4 = Simd<u32, 4>;\n \n-/// Vector of eight `u32` values\n+/// A 256-bit SIMD vector with eight elements of type `u32`.\n pub type u32x8 = Simd<u32, 8>;\n \n-/// Vector of 16 `u32` values\n+/// A 512-bit SIMD vector with 16 elements of type `u32`.\n pub type u32x16 = Simd<u32, 16>;\n \n-/// Vector of two `u64` values\n+/// A 128-bit SIMD vector with two elements of type `u64`.\n pub type u64x2 = Simd<u64, 2>;\n \n-/// Vector of four `u64` values\n+/// A 256-bit SIMD vector with four elements of type `u64`.\n pub type u64x4 = Simd<u64, 4>;\n \n-/// Vector of eight `u64` values\n+/// A 512-bit SIMD vector with eight elements of type `u64`.\n pub type u64x8 = Simd<u64, 8>;\n \n-/// Vector of four `u8` values\n+/// A 32-bit SIMD vector with four elements of type `u8`.\n pub type u8x4 = Simd<u8, 4>;\n \n-/// Vector of eight `u8` values\n+/// A 64-bit SIMD vector with eight elements of type `u8`.\n pub type u8x8 = Simd<u8, 8>;\n \n-/// Vector of 16 `u8` values\n+/// A 128-bit SIMD vector with 16 elements of type `u8`.\n pub type u8x16 = Simd<u8, 16>;\n \n-/// Vector of 32 `u8` values\n+/// A 256-bit SIMD vector with 32 elements of type `u8`.\n pub type u8x32 = Simd<u8, 32>;\n \n-/// Vector of 64 `u8` values\n+/// A 512-bit SIMD vector with 64 elements of type `u8`.\n pub type u8x64 = Simd<u8, 64>;"}, {"sha": "f6c5d74fbbcc62ffcd2f044b33b9ed594e31abbd", "filename": "library/portable-simd/crates/core_simd/tests/i16_ops.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -1,32 +1,5 @@\n #![feature(portable_simd)]\n-use core_simd::i16x2;\n \n #[macro_use]\n mod ops_macros;\n impl_signed_tests! { i16 }\n-\n-#[test]\n-fn max_is_not_lexicographic() {\n-    let a = i16x2::splat(10);\n-    let b = i16x2::from_array([-4, 12]);\n-    assert_eq!(a.max(b), i16x2::from_array([10, 12]));\n-}\n-\n-#[test]\n-fn min_is_not_lexicographic() {\n-    let a = i16x2::splat(10);\n-    let b = i16x2::from_array([12, -4]);\n-    assert_eq!(a.min(b), i16x2::from_array([10, -4]));\n-}\n-\n-#[test]\n-fn clamp_is_not_lexicographic() {\n-    let a = i16x2::splat(10);\n-    let lo = i16x2::from_array([-12, -4]);\n-    let up = i16x2::from_array([-4, 12]);\n-    assert_eq!(a.clamp(lo, up), i16x2::from_array([-4, 10]));\n-\n-    let x = i16x2::from_array([1, 10]);\n-    let y = x.clamp(i16x2::splat(0), i16x2::splat(9));\n-    assert_eq!(y, i16x2::from_array([1, 9]));\n-}"}, {"sha": "673d0db93fee5c65544734858431a55ebf8c78a1", "filename": "library/portable-simd/crates/core_simd/tests/masks.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -80,6 +80,62 @@ macro_rules! test_mask_api {\n                 assert_eq!(bitmask, 0b1000001101001001);\n                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n+\n+            #[test]\n+            fn roundtrip_bitmask_conversion_short() {\n+                use core_simd::ToBitMask;\n+\n+                let values = [\n+                    false, false, false, true,\n+                ];\n+                let mask = core_simd::Mask::<$type, 4>::from_array(values);\n+                let bitmask = mask.to_bitmask();\n+                assert_eq!(bitmask, 0b1000);\n+                assert_eq!(core_simd::Mask::<$type, 4>::from_bitmask(bitmask), mask);\n+\n+                let values = [true, false];\n+                let mask = core_simd::Mask::<$type, 2>::from_array(values);\n+                let bitmask = mask.to_bitmask();\n+                assert_eq!(bitmask, 0b01);\n+                assert_eq!(core_simd::Mask::<$type, 2>::from_bitmask(bitmask), mask);\n+            }\n+\n+            #[test]\n+            fn cast() {\n+                fn cast_impl<T: core_simd::MaskElement>()\n+                where\n+                    core_simd::Mask<$type, 8>: Into<core_simd::Mask<T, 8>>,\n+                {\n+                    let values = [true, false, false, true, false, false, true, false];\n+                    let mask = core_simd::Mask::<$type, 8>::from_array(values);\n+\n+                    let cast_mask = mask.cast::<T>();\n+                    assert_eq!(values, cast_mask.to_array());\n+\n+                    let into_mask: core_simd::Mask<T, 8> = mask.into();\n+                    assert_eq!(values, into_mask.to_array());\n+                }\n+\n+                cast_impl::<i8>();\n+                cast_impl::<i16>();\n+                cast_impl::<i32>();\n+                cast_impl::<i64>();\n+                cast_impl::<isize>();\n+            }\n+\n+            #[cfg(feature = \"generic_const_exprs\")]\n+            #[test]\n+            fn roundtrip_bitmask_array_conversion() {\n+                use core_simd::ToBitMaskArray;\n+                let values = [\n+                    true, false, false, true, false, false, true, false,\n+                    true, true, false, false, false, false, false, true,\n+                ];\n+                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let bitmask = mask.to_bitmask_array();\n+                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask_array(bitmask), mask);\n+            }\n         }\n     }\n }"}, {"sha": "f759394d0758211d61abdb9dde5d1adbe150801e", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -172,6 +172,7 @@ macro_rules! impl_common_integer_tests {\n macro_rules! impl_signed_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n+            use core_simd::simd::SimdInt;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -222,34 +223,37 @@ macro_rules! impl_signed_tests {\n                     assert_eq!(a % b, Vector::<LANES>::splat(0));\n                 }\n \n-                fn min<const LANES: usize>() {\n+                fn simd_min<const LANES: usize>() {\n+                    use core_simd::simd::SimdOrd;\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.min(b), a);\n+                    assert_eq!(a.simd_min(b), a);\n                     let a = Vector::<LANES>::splat(Scalar::MAX);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.min(b), b);\n+                    assert_eq!(a.simd_min(b), b);\n                 }\n \n-                fn max<const LANES: usize>() {\n+                fn simd_max<const LANES: usize>() {\n+                    use core_simd::simd::SimdOrd;\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.max(b), b);\n+                    assert_eq!(a.simd_max(b), b);\n                     let a = Vector::<LANES>::splat(Scalar::MAX);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.max(b), a);\n+                    assert_eq!(a.simd_max(b), a);\n                 }\n \n-                fn clamp<const LANES: usize>() {\n+                fn simd_clamp<const LANES: usize>() {\n+                    use core_simd::simd::SimdOrd;\n                     let min = Vector::<LANES>::splat(Scalar::MIN);\n                     let max = Vector::<LANES>::splat(Scalar::MAX);\n                     let zero = Vector::<LANES>::splat(0);\n                     let one = Vector::<LANES>::splat(1);\n                     let negone = Vector::<LANES>::splat(-1);\n-                    assert_eq!(zero.clamp(min, max), zero);\n-                    assert_eq!(zero.clamp(min, one), zero);\n-                    assert_eq!(zero.clamp(one, max), one);\n-                    assert_eq!(zero.clamp(min, negone), negone);\n+                    assert_eq!(zero.simd_clamp(min, max), zero);\n+                    assert_eq!(zero.simd_clamp(min, one), zero);\n+                    assert_eq!(zero.simd_clamp(one, max), one);\n+                    assert_eq!(zero.simd_clamp(min, negone), negone);\n                 }\n             }\n \n@@ -309,6 +313,7 @@ macro_rules! impl_signed_tests {\n macro_rules! impl_unsigned_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n+            use core_simd::simd::SimdUint;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -343,6 +348,7 @@ macro_rules! impl_unsigned_tests {\n macro_rules! impl_float_tests {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n+            use core_simd::SimdFloat;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -458,10 +464,10 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n-                fn min<const LANES: usize>() {\n+                fn simd_min<const LANES: usize>() {\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n-                        &Vector::<LANES>::min,\n+                        &Vector::<LANES>::simd_min,\n                         &Scalar::min,\n                         // Reject the case where both values are zero with different signs\n                         &|a, b| {\n@@ -477,14 +483,14 @@ macro_rules! impl_float_tests {\n                     // Special case where both values are zero\n                     let p_zero = Vector::<LANES>::splat(0.);\n                     let n_zero = Vector::<LANES>::splat(-0.);\n-                    assert!(p_zero.min(n_zero).to_array().iter().all(|x| *x == 0.));\n-                    assert!(n_zero.min(p_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(p_zero.simd_min(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.simd_min(p_zero).to_array().iter().all(|x| *x == 0.));\n                 }\n \n-                fn max<const LANES: usize>() {\n+                fn simd_max<const LANES: usize>() {\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n-                        &Vector::<LANES>::max,\n+                        &Vector::<LANES>::simd_max,\n                         &Scalar::max,\n                         // Reject the case where both values are zero with different signs\n                         &|a, b| {\n@@ -500,11 +506,11 @@ macro_rules! impl_float_tests {\n                     // Special case where both values are zero\n                     let p_zero = Vector::<LANES>::splat(0.);\n                     let n_zero = Vector::<LANES>::splat(-0.);\n-                    assert!(p_zero.max(n_zero).to_array().iter().all(|x| *x == 0.));\n-                    assert!(n_zero.max(p_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(p_zero.simd_max(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.simd_max(p_zero).to_array().iter().all(|x| *x == 0.));\n                 }\n \n-                fn clamp<const LANES: usize>() {\n+                fn simd_clamp<const LANES: usize>() {\n                     test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n                         for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n                             if max < min {\n@@ -522,7 +528,7 @@ macro_rules! impl_float_tests {\n                         for i in 0..LANES {\n                             result_scalar[i] = value[i].clamp(min[i], max[i]);\n                         }\n-                        let result_vector = Vector::from_array(value).clamp(min.into(), max.into()).to_array();\n+                        let result_vector = Vector::from_array(value).simd_clamp(min.into(), max.into()).to_array();\n                         test_helpers::prop_assert_biteq!(result_scalar, result_vector);\n                         Ok(())\n                     })"}, {"sha": "484fd5bf47d1b6fb365e11dbb67017d3209a555c", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -59,7 +59,7 @@ macro_rules! float_rounding_test {\n                     const MAX_REPRESENTABLE_VALUE: Scalar =\n                         (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n \n-                    let mut runner = proptest::test_runner::TestRunner::default();\n+                    let mut runner = test_helpers::make_runner();\n                     runner.run(\n                         &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n                         |x| {"}, {"sha": "141bee18a9a40a81ac4943167b260ee47ecbd7ea", "filename": "library/portable-simd/crates/test_helpers/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14404a028943f9d59c881a32b09dd5cae909498/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=a14404a028943f9d59c881a32b09dd5cae909498", "patch": "@@ -78,11 +78,11 @@ impl<T: core::fmt::Debug + DefaultStrategy, const LANES: usize> DefaultStrategy\n }\n \n #[cfg(not(miri))]\n-fn make_runner() -> proptest::test_runner::TestRunner {\n+pub fn make_runner() -> proptest::test_runner::TestRunner {\n     Default::default()\n }\n #[cfg(miri)]\n-fn make_runner() -> proptest::test_runner::TestRunner {\n+pub fn make_runner() -> proptest::test_runner::TestRunner {\n     // Only run a few tests on Miri\n     proptest::test_runner::TestRunner::new(proptest::test_runner::Config::with_cases(4))\n }"}]}