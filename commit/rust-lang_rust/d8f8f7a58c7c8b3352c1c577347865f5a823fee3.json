{"sha": "d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZjhmN2E1OGM3YzhiMzM1MmMxYzU3NzM0Nzg2NWY1YTgyM2ZlZTM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-17T09:08:53Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-17T22:33:29Z"}, "message": "Revise std::thread semantics\n\nThis commit makes several changes to `std::thread` in preparation for\nfinal stabilization:\n\n* It removes the ability to handle panics from `scoped` children; see\n  #20807 for discussion\n\n* It adds a `JoinHandle` structure, now returned from `spawn`, which\n  makes it possible to join on children that do not share data from\n  their parent's stack. The child is automatically detached when the\n  handle is dropped, and the handle cannot be copied due to Posix\n  semantics.\n\n* It moves all static methods from `std::thread::Thread` to free\n  functions in `std::thread`. This was done in part because, due to the\n  above changes, there are effectively no direct `Thread` constructors,\n  and the static methods have tended to feel a bit awkward.\n\n* Adds an `io::Result` around the `Builder` methods `scoped` and\n  `spawn`, making it possible to handle OS errors when creating\n  threads. The convenience free functions entail an unwrap.\n\n* Stabilizes the entire module. Despite the fact that the API is\n  changing somewhat here, this is part of a long period of baking and\n  the changes are addressing all known issues prior to alpha2. If\n  absolutely necessary, further breaking changes can be made prior to beta.\n\nCloses #20807\n\n[breaking-change]", "tree": {"sha": "efd8e56d2dd11d926862d357feae6f14f8161f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efd8e56d2dd11d926862d357feae6f14f8161f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "html_url": "https://github.com/rust-lang/rust/commit/d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4e7aa28566d062514a7a1f5534d76b9d82f524a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e7aa28566d062514a7a1f5534d76b9d82f524a", "html_url": "https://github.com/rust-lang/rust/commit/e4e7aa28566d062514a7a1f5534d76b9d82f524a"}], "stats": {"total": 386, "additions": 273, "deletions": 113}, "files": [{"sha": "82c52471d109719ef99d0e5aab5a6fa4103a434f", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use io;\n use boxed::Box;\n use cmp;\n use mem;\n@@ -191,7 +192,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     let mut native: libc::pthread_t = mem::zeroed();\n     let mut attr: libc::pthread_attr_t = mem::zeroed();\n     assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -226,9 +227,10 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     if ret != 0 {\n         // be sure to not leak the closure\n         let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n-        panic!(\"failed to spawn native thread: {}\", ret);\n+        Err(io::Error::from_os_error(ret))\n+    } else {\n+        Ok(native)\n     }\n-    native\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]"}, {"sha": "d7f86e1842eea67fed89a1408847e0a3c9421d96", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "patch": "@@ -10,6 +10,7 @@\n \n use boxed::Box;\n use cmp;\n+use io;\n use mem;\n use ptr;\n use libc;\n@@ -42,7 +43,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     let arg: *mut libc::c_void = mem::transmute(box p);\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n@@ -60,9 +61,10 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     if ret as uint == 0 {\n         // be sure to not leak the closure\n         let _p: Box<Thunk> = mem::transmute(arg);\n-        panic!(\"failed to spawn native thread: {:?}\", ret);\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(ret)\n     }\n-    return ret;\n }\n \n pub unsafe fn set_name(_name: &str) {"}, {"sha": "4f667114d38151eb4a47e20d601e7ea0e713e801", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 263, "deletions": 107, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8f8f7a58c7c8b3352c1c577347865f5a823fee3/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=d8f8f7a58c7c8b3352c1c577347865f5a823fee3", "patch": "@@ -58,16 +58,16 @@\n //! ```rust\n //! use std::thread::Thread;\n //!\n-//! let thread = Thread::spawn(move || {\n+//! Thread::spawn(move || {\n //!     println!(\"Hello, World!\");\n //!     // some computation here\n //! });\n //! ```\n //!\n-//! The spawned thread is \"detached\" from the current thread, meaning that it\n-//! can outlive the thread that spawned it. (Note, however, that when the main\n-//! thread terminates all detached threads are terminated as well.) The returned\n-//! `Thread` handle can be used for low-level synchronization as described below.\n+//! In this example, the spawned thread is \"detached\" from the current\n+//! thread, meaning that it can outlive the thread that spawned\n+//! it. (Note, however, that when the main thread terminates all\n+//! detached threads are terminated as well.)\n //!\n //! ## Scoped threads\n //!\n@@ -86,13 +86,13 @@\n //! let result = guard.join();\n //! ```\n //!\n-//! The `scoped` function doesn't return a `Thread` directly; instead, it\n-//! returns a *join guard* from which a `Thread` can be extracted. The join\n-//! guard is an RAII-style guard that will automatically join the child thread\n-//! (block until it terminates) when it is dropped. You can join the child\n-//! thread in advance by calling the `join` method on the guard, which will also\n-//! return the result produced by the thread.  A handle to the thread itself is\n-//! available via the `thread` method on the join guard.\n+//! The `scoped` function doesn't return a `Thread` directly; instead,\n+//! it returns a *join guard*. The join guard is an RAII-style guard\n+//! that will automatically join the child thread (block until it\n+//! terminates) when it is dropped. You can join the child thread in\n+//! advance by calling the `join` method on the guard, which will also\n+//! return the result produced by the thread.  A handle to the thread\n+//! itself is available via the `thread` method on the join guard.\n //!\n //! (Note: eventually, the `scoped` constructor will allow the parent and child\n //! threads to data that lives on the parent thread's stack, but some language\n@@ -151,6 +151,8 @@ use any::Any;\n use boxed::Box;\n use cell::UnsafeCell;\n use clone::Clone;\n+use fmt;\n+use io;\n use marker::{Send, Sync};\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n@@ -224,49 +226,58 @@ impl Builder {\n         self\n     }\n \n-    /// Spawn a new detached thread, and return a handle to it.\n+    /// Spawn a new thread, and return a join handle for it.\n     ///\n-    /// See `Thead::spawn` and the module doc for more details.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n-        unsafe { imp::detach(native) };\n-        thread\n+    /// The child thread may outlive the parent (unless the parent thread\n+    /// is the main thread; the whole process is terminated when the main\n+    /// thread finishes.) The join handle can be used to block on\n+    /// termination of the child thread, including recovering its panics.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the `spawn` free function, this method yields an\n+    /// `io::Result` to capture any failure to create the thread at\n+    /// the OS level.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where\n+        F: FnOnce(), F: Send + 'static\n+    {\n+        self.spawn_inner(Thunk::new(f)).map(|i| JoinHandle(i))\n     }\n \n     /// Spawn a new child thread that must be joined within a given\n     /// scope, and return a `JoinGuard`.\n     ///\n-    /// See `Thead::scoped` and the module doc for more details.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n+    /// The join guard can be used to explicitly join the child thread (via\n+    /// `join`), returning `Result<T>`, or it will implicitly join the child\n+    /// upon being dropped. Because the child thread may refer to data on the\n+    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+    /// it *must* be joined before the relevant stack frame is popped. See the\n+    /// module documentation for additional details.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the `scoped` free function, this method yields an\n+    /// `io::Result` to capture any failure to create the thread at\n+    /// the OS level.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n-        let their_packet = Packet(my_packet.0.clone());\n-        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(move |ret| unsafe {\n-            *their_packet.0.get() = Some(ret);\n-        }));\n-\n-        JoinGuard {\n-            native: native,\n-            joined: false,\n-            packet: my_packet,\n-            thread: thread,\n-        }\n+        self.spawn_inner(Thunk::new(f)).map(JoinGuard)\n     }\n \n-    fn spawn_inner<T: Send>(self, f: Thunk<(), T>, finish: Thunk<Result<T>, ()>)\n-                      -> (imp::rust_thread, Thread)\n-    {\n+    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> io::Result<JoinInner<T>> {\n         let Builder { name, stack_size, stdout, stderr } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n+\n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();\n \n+        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n+        let their_packet = Packet(my_packet.0.clone());\n+\n         // Spawning a new OS thread guarantees that __morestack will never get\n         // triggered, but we must manually set up the actual stack bounds once\n         // this function starts executing. This raises the lower limit by a bit\n@@ -316,17 +327,120 @@ impl Builder {\n                     unwind::try(move || *ptr = Some(f.invoke(())))\n                 }\n             };\n-            finish.invoke(match (output, try_result) {\n-                (Some(data), Ok(_)) => Ok(data),\n-                (None, Err(cause)) => Err(cause),\n-                _ => unreachable!()\n-            });\n+            unsafe {\n+                *their_packet.0.get() = Some(match (output, try_result) {\n+                    (Some(data), Ok(_)) => Ok(data),\n+                    (None, Err(cause)) => Err(cause),\n+                    _ => unreachable!()\n+                });\n+            }\n         };\n \n-        (unsafe { imp::create(stack_size, Thunk::new(main)) }, my_thread)\n+        Ok(JoinInner {\n+            native: try!(unsafe { imp::create(stack_size, Thunk::new(main)) }),\n+            thread: my_thread,\n+            packet: my_packet,\n+            joined: false,\n+        })\n+    }\n+}\n+\n+/// Spawn a new, returning a join handle for it.\n+///\n+/// The child thread may outlive the parent (unless the parent thread\n+/// is the main thread; the whole process is terminated when the main\n+/// thread finishes.) The join handle can be used to block on\n+/// termination of the child thread, including recovering its panics.\n+///\n+/// # Panics\n+///\n+/// Panicks if the OS fails to create a thread; use `Builder::spawn`\n+/// to recover from such errors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n+    Builder::new().spawn(f).unwrap()\n+}\n+\n+/// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n+///\n+/// The join guard can be used to explicitly join the child thread (via\n+/// `join`), returning `Result<T>`, or it will implicitly join the child\n+/// upon being dropped. Because the child thread may refer to data on the\n+/// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+/// it *must* be joined before the relevant stack frame is popped. See the\n+/// module documentation for additional details.\n+///\n+/// # Panics\n+///\n+/// Panicks if the OS fails to create a thread; use `Builder::scoped`\n+/// to recover from such errors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n+    T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n+{\n+    Builder::new().scoped(f).unwrap()\n+}\n+\n+/// Gets a handle to the thread that invokes it.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn current() -> Thread {\n+    thread_info::current_thread()\n+}\n+\n+/// Cooperatively give up a timeslice to the OS scheduler.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn yield_now() {\n+    unsafe { imp::yield_now() }\n+}\n+\n+/// Determines whether the current thread is unwinding because of panic.\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn panicking() -> bool {\n+    unwind::panicking()\n+}\n+\n+/// Block unless or until the current thread's token is made available (may wake spuriously).\n+///\n+/// See the module doc for more detail.\n+//\n+// The implementation currently uses the trivial strategy of a Mutex+Condvar\n+// with wakeup flag, which does not actually allow spurious wakeups. In the\n+// future, this will be implemented in a more efficient way, perhaps along the lines of\n+//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+// or futuxes, and in either case may allow spurious wakeups.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn park() {\n+    let thread = Thread::current();\n+    let mut guard = thread.inner.lock.lock().unwrap();\n+    while !*guard {\n+        guard = thread.inner.cvar.wait(guard).unwrap();\n     }\n+    *guard = false;\n }\n \n+/// Block unless or until the current thread's token is made available or\n+/// the specified duration has been reached (may wake spuriously).\n+///\n+/// The semantics of this function are equivalent to `park()` except that the\n+/// thread will be blocked for roughly no longer than dur. This method\n+/// should not be used for precise timing due to anomalies such as\n+/// preemption or platform differences that may not cause the maximum\n+/// amount of time waited to be precisely dur\n+///\n+/// See the module doc for more detail.\n+#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n+pub fn park_timeout(dur: Duration) {\n+    let thread = Thread::current();\n+    let mut guard = thread.inner.lock.lock().unwrap();\n+    if !*guard {\n+        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n+        guard = g;\n+    }\n+    *guard = false;\n+}\n+\n+/// The internal representation of a `Thread` handle\n struct Inner {\n     name: Option<String>,\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n@@ -354,62 +468,48 @@ impl Thread {\n         }\n     }\n \n-    /// Spawn a new detached thread, returning a handle to it.\n-    ///\n-    /// The child thread may outlive the parent (unless the parent thread is the\n-    /// main thread; the whole process is terminated when the main thread\n-    /// finishes.) The thread handle can be used for low-level\n-    /// synchronization. See the module documentation for additional details.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        Builder::new().spawn(f)\n+        Builder::new().spawn(f).unwrap().thread().clone()\n     }\n \n-    /// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n-    ///\n-    /// The join guard can be used to explicitly join the child thread (via\n-    /// `join`), returning `Result<T>`, or it will implicitly join the child\n-    /// upon being dropped. Because the child thread may refer to data on the\n-    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n-    /// it *must* be joined before the relevant stack frame is popped. See the\n-    /// module documentation for additional details.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        Builder::new().scoped(f)\n+        Builder::new().scoped(f).unwrap()\n     }\n \n-    /// Gets a handle to the thread that invokes it.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n-    /// Cooperatively give up a timeslice to the OS scheduler.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n-    /// Determines whether the current thread is unwinding because of panic.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n \n-    /// Block unless or until the current thread's token is made available (may wake spuriously).\n-    ///\n-    /// See the module doc for more detail.\n-    //\n-    // The implementation currently uses the trivial strategy of a Mutex+Condvar\n-    // with wakeup flag, which does not actually allow spurious wakeups. In the\n-    // future, this will be implemented in a more efficient way, perhaps along the lines of\n-    //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n-    // or futuxes, and in either case may allow spurious wakeups.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park() {\n         let thread = Thread::current();\n@@ -420,16 +520,8 @@ impl Thread {\n         *guard = false;\n     }\n \n-    /// Block unless or until the current thread's token is made available or\n-    /// the specified duration has been reached (may wake spuriously).\n-    ///\n-    /// The semantics of this function are equivalent to `park()` except that the\n-    /// thread will be blocked for roughly no longer than dur. This method\n-    /// should not be used for precise timing due to anomalies such as\n-    /// preemption or platform differences that may not cause the maximum\n-    /// amount of time waited to be precisely dur\n-    ///\n-    /// See the module doc for more detail.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park_timeout(dur: Duration) {\n         let thread = Thread::current();\n@@ -444,7 +536,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -460,6 +552,13 @@ impl Thread {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Thread {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.name(), f)\n+    }\n+}\n+\n // a hack to get around privacy restrictions\n impl thread_info::NewThread for Thread {\n     fn new(name: Option<String>) -> Thread { Thread::new(name) }\n@@ -476,61 +575,118 @@ struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n unsafe impl<T:'static+Send> Send for Packet<T> {}\n unsafe impl<T> Sync for Packet<T> {}\n \n-/// An RAII-style guard that will block until thread termination when dropped.\n-///\n-/// The type `T` is the return type for the thread's main function.\n-#[must_use]\n-#[unstable(feature = \"std_misc\",\n-           reason = \"may change with specifics of new Send semantics\")]\n-pub struct JoinGuard<'a, T: 'a> {\n+/// Inner representation for JoinHandle and JoinGuard\n+struct JoinInner<T> {\n     native: imp::rust_thread,\n     thread: Thread,\n-    joined: bool,\n     packet: Packet<T>,\n+    joined: bool,\n }\n \n+impl<T> JoinInner<T> {\n+    fn join(&mut self) -> Result<T> {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        unsafe {\n+            (*self.packet.0.get()).take().unwrap()\n+        }\n+    }\n+}\n+\n+/// An owned permission to join on a thread (block on its termination).\n+///\n+/// Unlike a `JoinGuard`, a `JoinHandle` *detaches* the child thread\n+/// when it is dropped, rather than automatically joining on drop.\n+///\n+/// Due to platform restrictions, it is not possible to `Clone` this\n+/// handle: the ability to join a child thread is a uniquely-owned\n+/// permission.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct JoinHandle(JoinInner<()>);\n+\n+impl JoinHandle {\n+    /// Extract a handle to the underlying thread\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn thread(&self) -> &Thread {\n+        &self.0.thread\n+    }\n+\n+    /// Wait for the associated thread to finish.\n+    ///\n+    /// If the child thread panics, `Err` is returned with the parameter given\n+    /// to `panic`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn join(mut self) -> Result<()> {\n+        self.0.join()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Drop for JoinHandle {\n+    fn drop(&mut self) {\n+        if !self.0.joined {\n+            unsafe { imp::detach(self.0.native) }\n+        }\n+    }\n+}\n+\n+/// An RAII-style guard that will block until thread termination when dropped.\n+///\n+/// The type `T` is the return type for the thread's main function.\n+///\n+/// Joining on drop is necessary to ensure memory safety when stack\n+/// data is shared between a parent and child thread.\n+///\n+/// Due to platform restrictions, it is not possible to `Clone` this\n+/// handle: the ability to join a child thread is a uniquely-owned\n+/// permission.\n+#[must_use]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct JoinGuard<'a, T: 'a>(JoinInner<T>);\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<'a, T: Send + 'a> Sync for JoinGuard<'a, T> {}\n \n impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n-        &self.thread\n+        &self.0.thread\n     }\n \n     /// Wait for the associated thread to finish, returning the result of the thread's\n     /// calculation.\n     ///\n-    /// If the child thread panics, `Err` is returned with the parameter given\n-    /// to `panic`.\n+    /// # Panics\n+    ///\n+    /// Panics on the child thread are propagated by panicking the parent.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join(mut self) -> Result<T> {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        unsafe {\n-            (*self.packet.0.get()).take().unwrap()\n+    pub fn join(mut self) -> T {\n+        match self.0.join() {\n+            Ok(res) => res,\n+            Err(_) => panic!(\"child thread {:?} panicked\", self.thread()),\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure whether this API imposes limitations elsewhere\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use spawn instead\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn detach(mut self) {\n-        unsafe { imp::detach(self.native) };\n-        self.joined = true; // avoid joining in the destructor\n+        unsafe { imp::detach(self.0.native) };\n+        self.0.joined = true; // avoid joining in the destructor\n     }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n+        if !self.0.joined {\n+            unsafe { imp::join(self.0.native) };\n         }\n     }\n }"}]}