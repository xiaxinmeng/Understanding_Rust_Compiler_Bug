{"sha": "7932b719ec2b65acfa8c3e74aad29346d47ee992", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MzJiNzE5ZWMyYjY1YWNmYThjM2U3NGFhZDI5MzQ2ZDQ3ZWU5OTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-26T10:31:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-26T10:31:06Z"}, "message": "auto merge of #14397 : nick29581/rust/coerce, r=pnkfelix\n\nDST coercions and DST fields in structs\r\n\r\nThe commits are not quite stand alone, I should probably squash them together before landing. In particular if you review the individual commits, then you'll see some scrappy stuff that gets fixed in later commits. But reading the commits in order might be easier to get an overall idea of what is going on.\r\n\r\nThe first commit includes putting back time zone into our time library - @pcwalton removed that as part of his de-~str'ing, but I had already converted it to use StrBuf, so we may as well leave it in. Update: no longer, this is removed in a later commit.", "tree": {"sha": "a2326fb40572a4484189cd92e1cce26e616ad959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2326fb40572a4484189cd92e1cce26e616ad959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7932b719ec2b65acfa8c3e74aad29346d47ee992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7932b719ec2b65acfa8c3e74aad29346d47ee992", "html_url": "https://github.com/rust-lang/rust/commit/7932b719ec2b65acfa8c3e74aad29346d47ee992", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7932b719ec2b65acfa8c3e74aad29346d47ee992/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cad4089ba0dc46248da2459af904e38243f294d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cad4089ba0dc46248da2459af904e38243f294d", "html_url": "https://github.com/rust-lang/rust/commit/1cad4089ba0dc46248da2459af904e38243f294d"}, {"sha": "08364a4cacdcd6f161e0fb0ab573ae825e22447b", "url": "https://api.github.com/repos/rust-lang/rust/commits/08364a4cacdcd6f161e0fb0ab573ae825e22447b", "html_url": "https://github.com/rust-lang/rust/commit/08364a4cacdcd6f161e0fb0ab573ae825e22447b"}], "stats": {"total": 6596, "additions": 4276, "deletions": 2320}, "files": [{"sha": "38216fa5b59b14002e87b2b6dad33c19e96e21cc", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -12,6 +12,7 @@\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n //                and `nonnull`\n \n+use core::ptr::RawPtr;\n #[cfg(not(test))] use core::raw;\n #[cfg(not(test))] use util;\n \n@@ -69,6 +70,11 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n /// the value returned by `usable_size` for the requested size.\n #[inline]\n pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n+    // FIXME(14395) This is only required for DST ~[T], it should be removed once\n+    // we fix that representation to not use null pointers.\n+    if ptr.is_null() {\n+        return;\n+    }\n     imp::deallocate(ptr, size, align)\n }\n "}, {"sha": "d13767077c7ac7fbdd90e1a6d464db539340cc7a", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -2557,7 +2557,7 @@ mod tests {\n     }\n \n     fn rng() -> rand::IsaacRng {\n-        let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::SeedableRng::from_seed(seed)\n     }\n "}, {"sha": "418bb147d204a5e2ec15c0ae2bd5d1f750f3155e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1088,7 +1088,8 @@ mod tests {\n         let n = list_from([1i,2,3]);\n         spawn(proc() {\n             check_links(&n);\n-            assert_eq!(&[&1,&2,&3], n.iter().collect::<Vec<&int>>().as_slice());\n+            let a: &[_] = &[&1,&2,&3];\n+            assert_eq!(a, n.iter().collect::<Vec<&int>>().as_slice());\n         });\n     }\n "}, {"sha": "ef26452a52902e8fd22d0d53edccb4af161c26ac", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -346,7 +346,8 @@ mod tests {\n         assert_eq!(hasher.hash(&'a'), 97);\n \n         assert_eq!(hasher.hash(&(\"a\")), 97 + 0xFF);\n-        assert_eq!(hasher.hash(& &[1u8, 2u8, 3u8]), 9);\n+        let cs: &[u8] = &[1u8, 2u8, 3u8];\n+        assert_eq!(hasher.hash(& cs), 9);\n \n         unsafe {\n             let ptr: *const int = mem::transmute(5i);"}, {"sha": "f3798e5f9e0094ad6dd1df5f29947d3a36706596", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -495,8 +495,8 @@ mod tests {\n         assert!(s != t && t != u);\n         assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n \n-        let v = (&[1u8], &[0u8, 0], &[0u8]);\n-        let w = (&[1u8, 0, 0, 0], &[], &[]);\n+        let v: (&[u8], &[u8], &[u8]) = (&[1u8], &[0u8, 0], &[0u8]);\n+        let w: (&[u8], &[u8], &[u8]) = (&[1u8, 0, 0, 0], &[], &[]);\n \n         assert!(v != w);\n         assert!(hash(&v) != hash(&w));"}, {"sha": "2f0fbfadb17f3c0b9a3243156e8958b216db43c3", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -243,7 +243,8 @@ impl<T> RingBuf<T> {\n     /// buf.push(5i);\n     /// buf.push(3);\n     /// buf.push(4);\n-    /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), &[&5, &3, &4]);\n+    /// let b: &[_] = &[&5, &3, &4];\n+    /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n@@ -263,7 +264,8 @@ impl<T> RingBuf<T> {\n     /// for num in buf.mut_iter() {\n     ///     *num = *num - 2;\n     /// }\n-    /// assert_eq!(buf.mut_iter().collect::<Vec<&mut int>>().as_slice(), &[&mut 3, &mut 1, &mut 2]);\n+    /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n+    /// assert_eq!(buf.mut_iter().collect::<Vec<&mut int>>().as_slice(), b);\n     /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n@@ -865,12 +867,18 @@ mod tests {\n         for i in range(0i, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&0,&1,&2,&3,&4]);\n+        {\n+            let b: &[_] = &[&0,&1,&2,&3,&4];\n+            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+        }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&8,&7,&6,&0,&1,&2,&3,&4]);\n+        {\n+            let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n+            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+        }\n \n         let mut it = d.iter();\n         let mut len = d.len();\n@@ -890,12 +898,16 @@ mod tests {\n         for i in range(0i, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n+        {\n+            let b: &[_] = &[&4,&3,&2,&1,&0];\n+            assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+        }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n+        let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n     }\n \n     #[test]"}, {"sha": "71b9673d2792996f92ccb5c173e16108279d9985", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 143, "deletions": 76, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -638,11 +638,13 @@ pub trait MutableOrdSlice<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = &mut [0i, 1, 2];\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n     /// v.next_permutation();\n-    /// assert_eq!(v, &mut [0i, 2, 1]);\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n     /// v.next_permutation();\n-    /// assert_eq!(v, &mut [1i, 0, 2]);\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n     /// ```\n     fn next_permutation(self) -> bool;\n \n@@ -654,11 +656,13 @@ pub trait MutableOrdSlice<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = &mut [1i, 0, 2];\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n     /// v.prev_permutation();\n-    /// assert_eq!(v, &mut [0i, 2, 1]);\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n     /// v.prev_permutation();\n-    /// assert_eq!(v, &mut [0i, 1, 2]);\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n     /// ```\n     fn prev_permutation(self) -> bool;\n }\n@@ -845,9 +849,11 @@ mod tests {\n     #[test]\n     fn test_tail() {\n         let mut a = vec![11i];\n-        assert_eq!(a.tail(), &[]);\n+        let b: &[int] = &[];\n+        assert_eq!(a.tail(), b);\n         a = vec![11i, 12];\n-        assert_eq!(a.tail(), &[12]);\n+        let b: &[int] = &[12];\n+        assert_eq!(a.tail(), b);\n     }\n \n     #[test]\n@@ -860,9 +866,11 @@ mod tests {\n     #[test]\n     fn test_tailn() {\n         let mut a = vec![11i, 12, 13];\n-        assert_eq!(a.tailn(0), &[11, 12, 13]);\n+        let b: &[int] = &[11, 12, 13];\n+        assert_eq!(a.tailn(0), b);\n         a = vec![11i, 12, 13];\n-        assert_eq!(a.tailn(2), &[13]);\n+        let b: &[int] = &[13];\n+        assert_eq!(a.tailn(2), b);\n     }\n \n     #[test]\n@@ -875,9 +883,11 @@ mod tests {\n     #[test]\n     fn test_init() {\n         let mut a = vec![11i];\n-        assert_eq!(a.init(), &[]);\n+        let b: &[int] = &[];\n+        assert_eq!(a.init(), b);\n         a = vec![11i, 12];\n-        assert_eq!(a.init(), &[11]);\n+        let b: &[int] = &[11];\n+        assert_eq!(a.init(), b);\n     }\n \n     #[test]\n@@ -890,9 +900,11 @@ mod tests {\n     #[test]\n     fn test_initn() {\n         let mut a = vec![11i, 12, 13];\n-        assert_eq!(a.as_slice().initn(0), &[11, 12, 13]);\n+        let b: &[int] = &[11, 12, 13];\n+        assert_eq!(a.as_slice().initn(0), b);\n         a = vec![11i, 12, 13];\n-        assert_eq!(a.as_slice().initn(2), &[11]);\n+        let b: &[int] = &[11];\n+        assert_eq!(a.as_slice().initn(2), b);\n     }\n \n     #[test]\n@@ -945,18 +957,22 @@ mod tests {\n \n     #[test]\n     fn test_slice_from() {\n-        let vec = &[1i, 2, 3, 4];\n+        let vec: &[int] = &[1, 2, 3, 4];\n         assert_eq!(vec.slice_from(0), vec);\n-        assert_eq!(vec.slice_from(2), &[3, 4]);\n-        assert_eq!(vec.slice_from(4), &[]);\n+        let b: &[int] = &[3, 4];\n+        assert_eq!(vec.slice_from(2), b);\n+        let b: &[int] = &[];\n+        assert_eq!(vec.slice_from(4), b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n-        let vec = &[1i, 2, 3, 4];\n+        let vec: &[int] = &[1, 2, 3, 4];\n         assert_eq!(vec.slice_to(4), vec);\n-        assert_eq!(vec.slice_to(2), &[1, 2]);\n-        assert_eq!(vec.slice_to(0), &[]);\n+        let b: &[int] = &[1, 2];\n+        assert_eq!(vec.slice_to(2), b);\n+        let b: &[int] = &[];\n+        assert_eq!(vec.slice_to(0), b);\n     }\n \n \n@@ -1210,51 +1226,62 @@ mod tests {\n         let v : &mut[int] = &mut[1i, 2, 3, 4, 5];\n         assert!(v.prev_permutation() == false);\n         assert!(v.next_permutation());\n-        assert_eq!(v, &mut[1, 2, 3, 5, 4]);\n+        let b: &mut[int] = &mut[1, 2, 3, 5, 4];\n+        assert!(v == b);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[1, 2, 3, 4, 5]);\n+        let b: &mut[int] = &mut[1, 2, 3, 4, 5];\n+        assert!(v == b);\n         assert!(v.next_permutation());\n         assert!(v.next_permutation());\n-        assert_eq!(v, &mut[1, 2, 4, 3, 5]);\n+        let b: &mut[int] = &mut[1, 2, 4, 3, 5];\n+        assert!(v == b);\n         assert!(v.next_permutation());\n-        assert_eq!(v, &mut[1, 2, 4, 5, 3]);\n+        let b: &mut[int] = &mut[1, 2, 4, 5, 3];\n+        assert!(v == b);\n \n         let v : &mut[int] = &mut[1i, 0, 0, 0];\n         assert!(v.next_permutation() == false);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[0, 1, 0, 0]);\n+        let b: &mut[int] = &mut[0, 1, 0, 0];\n+        assert!(v == b);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[0, 0, 1, 0]);\n+        let b: &mut[int] = &mut[0, 0, 1, 0];\n+        assert!(v == b);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[0, 0, 0, 1]);\n+        let b: &mut[int] = &mut[0, 0, 0, 1];\n+        assert!(v == b);\n         assert!(v.prev_permutation() == false);\n     }\n \n     #[test]\n     fn test_lexicographic_permutations_empty_and_short() {\n         let empty : &mut[int] = &mut[];\n         assert!(empty.next_permutation() == false);\n-        assert_eq!(empty, &mut[]);\n+        let b: &mut[int] = &mut[];\n+        assert!(empty == b);\n         assert!(empty.prev_permutation() == false);\n-        assert_eq!(empty, &mut[]);\n+        assert!(empty == b);\n \n         let one_elem : &mut[int] = &mut[4i];\n         assert!(one_elem.prev_permutation() == false);\n-        assert_eq!(one_elem, &mut[4]);\n+        let b: &mut[int] = &mut[4];\n+        assert!(one_elem == b);\n         assert!(one_elem.next_permutation() == false);\n-        assert_eq!(one_elem, &mut[4]);\n+        assert!(one_elem == b);\n \n         let two_elem : &mut[int] = &mut[1i, 2];\n         assert!(two_elem.prev_permutation() == false);\n-        assert_eq!(two_elem, &mut[1, 2]);\n+        let b : &mut[int] = &mut[1, 2];\n+        let c : &mut[int] = &mut[2, 1];\n+        assert!(two_elem == b);\n         assert!(two_elem.next_permutation());\n-        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem == c);\n         assert!(two_elem.next_permutation() == false);\n-        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem == c);\n         assert!(two_elem.prev_permutation());\n-        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem == b);\n         assert!(two_elem.prev_permutation() == false);\n-        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem == b);\n     }\n \n     #[test]\n@@ -1408,7 +1435,10 @@ mod tests {\n         assert_eq!(v.concat_vec(), vec![]);\n         assert_eq!([vec![1i], vec![2i,3i]].concat_vec(), vec![1, 2, 3]);\n \n-        assert_eq!([&[1i], &[2i,3i]].concat_vec(), vec![1, 2, 3]);\n+        let v: [&[int], ..2] = [&[1], &[2, 3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -1418,8 +1448,10 @@ mod tests {\n         assert_eq!([vec![1i], vec![2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n         assert_eq!([vec![1i], vec![2i], vec![3i]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n \n-        assert_eq!([&[1i], &[2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([&[1i], &[2i], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        let v: [&[int], ..2] = [&[1], &[2, 3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -1577,11 +1609,16 @@ mod tests {\n \n     #[test]\n     fn test_total_ord() {\n-        [1i, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n-        [1i, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n-        [1i, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n-        [1i, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n-        [2i, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n+        let c: &[int] = &[1, 2, 3];\n+        [1, 2, 3, 4].cmp(& c) == Greater;\n+        let c: &[int] = &[1, 2, 3, 4];\n+        [1, 2, 3].cmp(& c) == Less;\n+        let c: &[int] = &[1, 2, 3, 6];\n+        [1, 2, 3, 4].cmp(& c) == Equal;\n+        let c: &[int] = &[1, 2, 3, 4, 5, 6];\n+        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& c) == Less;\n+        let c: &[int] = &[1, 2, 3, 4];\n+        [2, 2].cmp(& c) == Greater;\n     }\n \n     #[test]\n@@ -1705,74 +1742,95 @@ mod tests {\n     fn test_splitator() {\n         let xs = &[1i,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[1], &[3], &[5]];\n         assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1], &[3], &[5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n         assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n         assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4], &[]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n         assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[], &[], &[], &[], &[]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1], &[3,4,5]];\n         assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1], &[3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n         assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[], &[], &[4,5]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[5], &[3], &[1]];\n         assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[5], &[3], &[1]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n         assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[2,3,4,5], &[]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n         assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[1,2,3,4]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[5], &[1,2,3]];\n         assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[5], &[1,2,3]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n         assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[], &[], &[1,2]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), &[&[1,2], &[2,3], &[3,4]]);\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3], &[2,3,4]]);\n+        let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n+        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), wins);\n+        let wins: &[&[int]] = &[&[1i,2,3], &[2,3,4]];\n+        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -1787,16 +1845,23 @@ mod tests {\n     fn test_chunksator() {\n         let v = &[1i,2,3,4,5];\n \n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2], &[3,4], &[5]]);\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3], &[4,5]]);\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3,4,5]]);\n+        let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n+        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n+        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        let chunks: &[&[int]] = &[&[1i,2,3,4,5]];\n+        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), chunks);\n \n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), &[&[5i], &[3,4], &[1,2]]);\n+        let chunks: &[&[int]] = &[&[5i], &[3,4], &[1,2]];\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n-        assert_eq!(it.idx(0).unwrap(), &[1,2]);\n-        assert_eq!(it.idx(1).unwrap(), &[3,4]);\n-        assert_eq!(it.idx(2).unwrap(), &[5]);\n+        let chunk: &[int] = &[1,2];\n+        assert_eq!(it.idx(0).unwrap(), chunk);\n+        let chunk: &[int] = &[3,4];\n+        assert_eq!(it.idx(1).unwrap(), chunk);\n+        let chunk: &[int] = &[5];\n+        assert_eq!(it.idx(2).unwrap(), chunk);\n         assert_eq!(it.idx(3), None);\n     }\n \n@@ -1864,10 +1929,12 @@ mod tests {\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\".to_string());\n-        test_show_vec!(&mut[1i], \"[1]\".to_string());\n-        test_show_vec!(&mut[1i, 2, 3], \"[1, 2, 3]\".to_string());\n-        test_show_vec!(&mut[&mut[], &mut[1u], &mut[1u, 1u]],\n-                       \"[[], [1], [1, 1]]\".to_string());\n+        let v: &mut[int] = &mut[1];\n+        test_show_vec!(v, \"[1]\".to_string());\n+        let v: &mut[int] = &mut[1, 2, 3];\n+        test_show_vec!(v, \"[1, 2, 3]\".to_string());\n+        let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n+        test_show_vec!(v, \"[[], [1], [1, 1]]\".to_string());\n     }\n \n     #[test]"}, {"sha": "3f9a179872e147725f6a9c4687a8197a8d899245", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1265,38 +1265,44 @@ mod tests {\n     fn test_trim_left_chars() {\n         let v: &[char] = &[];\n         assert_eq!(\" *** foo *** \".trim_left_chars(v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(&['*', ' ']), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n+        let chars: &[char] = &['*', ' '];\n+        assert_eq!(\" *** foo *** \".trim_left_chars(chars), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(chars), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(chars), \"foo *** \");\n \n         assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n-        assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\");\n+        let chars: &[char] = &['1', '2'];\n+        assert_eq!(\"12foo1bar12\".trim_left_chars(chars), \"foo1bar12\");\n         assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n         let v: &[char] = &[];\n         assert_eq!(\" *** foo *** \".trim_right_chars(v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_right_chars(&['*', ' ']), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(&['*', ' ']), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(&['*', ' ']), \" *** foo\");\n+        let chars: &[char] = &['*', ' '];\n+        assert_eq!(\" *** foo *** \".trim_right_chars(chars), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(chars), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(chars), \" *** foo\");\n \n         assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\");\n+        let chars: &[char] = &['1', '2'];\n+        assert_eq!(\"12foo1bar12\".trim_right_chars(chars), \"12foo1bar\");\n         assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n         let v: &[char] = &[];\n         assert_eq!(\" *** foo *** \".trim_chars(v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_chars(&['*', ' ']), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(&['*', ' ']), \"\");\n-        assert_eq!(\"foo\".trim_chars(&['*', ' ']), \"foo\");\n+        let chars: &[char] = &['*', ' '];\n+        assert_eq!(\" *** foo *** \".trim_chars(chars), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(chars), \"\");\n+        assert_eq!(\"foo\".trim_chars(chars), \"foo\");\n \n         assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\");\n+        let chars: &[char] = &['1', '2'];\n+        assert_eq!(\"12foo1bar12\".trim_chars(chars), \"foo1bar\");\n         assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\");\n     }\n \n@@ -1443,7 +1449,8 @@ mod tests {\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n             109\n         ];\n-        assert_eq!(\"\".as_bytes(), &[]);\n+        let b: &[u8] = &[];\n+        assert_eq!(\"\".as_bytes(), b);\n         assert_eq!(\"abc\".as_bytes(), b\"abc\");\n         assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v.as_slice());\n     }\n@@ -1542,19 +1549,23 @@ mod tests {\n     #[test]\n     fn test_truncate_utf16_at_nul() {\n         let v = [];\n-        assert_eq!(truncate_utf16_at_nul(v), &[]);\n+        let b: &[u16] = &[];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), &[]);\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [1, 0, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), &[1]);\n+        let b: &[u16] = &[1];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [1, 2, 0];\n-        assert_eq!(truncate_utf16_at_nul(v), &[1, 2]);\n+        let b: &[u16] = &[1, 2];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), &[1, 2, 3]);\n+        let b: &[u16] = &[1, 2, 3];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n     }\n \n     #[test]\n@@ -1960,7 +1971,7 @@ mod tests {\n         use std::iter::order;\n         // official Unicode test data\n         // from http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n-        let test_same = [\n+        let test_same: [(_, &[_]), .. 325] = [\n             (\"\\u0020\\u0020\", &[\"\\u0020\", \"\\u0020\"]), (\"\\u0020\\u0308\\u0020\", &[\"\\u0020\\u0308\",\n             \"\\u0020\"]), (\"\\u0020\\u000D\", &[\"\\u0020\", \"\\u000D\"]), (\"\\u0020\\u0308\\u000D\",\n             &[\"\\u0020\\u0308\", \"\\u000D\"]), (\"\\u0020\\u000A\", &[\"\\u0020\", \"\\u000A\"]),\n@@ -2169,7 +2180,7 @@ mod tests {\n             (\"\\u0646\\u200D\\u0020\", &[\"\\u0646\\u200D\", \"\\u0020\"]),\n         ];\n \n-        let test_diff = [\n+        let test_diff: [(_, &[_], &[_]), .. 23] = [\n             (\"\\u0020\\u0903\", &[\"\\u0020\\u0903\"], &[\"\\u0020\", \"\\u0903\"]), (\"\\u0020\\u0308\\u0903\",\n             &[\"\\u0020\\u0308\\u0903\"], &[\"\\u0020\\u0308\", \"\\u0903\"]), (\"\\u000D\\u0308\\u0903\",\n             &[\"\\u000D\", \"\\u0308\\u0903\"], &[\"\\u000D\", \"\\u0308\", \"\\u0903\"]), (\"\\u000A\\u0308\\u0903\",\n@@ -2218,9 +2229,11 @@ mod tests {\n         // test the indices iterators\n         let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n         let gr_inds = s.grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-        assert_eq!(gr_inds.as_slice(), &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")]);\n+        let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+        assert_eq!(gr_inds.as_slice(), b);\n         let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(uint, &str)>>();\n-        assert_eq!(gr_inds.as_slice(), &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")]);\n+        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")];\n+        assert_eq!(gr_inds.as_slice(), b);\n         let mut gr_inds = s.grapheme_indices(true);\n         let e1 = gr_inds.size_hint();\n         assert_eq!(e1, (1, Some(13)));\n@@ -2232,7 +2245,8 @@ mod tests {\n         // make sure the reverse iterator does the right thing with \"\\n\" at beginning of string\n         let s = \"\\n\\r\\n\\r\";\n         let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n-        assert_eq!(gr.as_slice(), &[\"\\r\", \"\\r\\n\", \"\\n\"]);\n+        let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n+        assert_eq!(gr.as_slice(), b);\n     }\n \n     #[test]\n@@ -2494,7 +2508,8 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').count();\n \n-        b.iter(|| assert_eq!(s.split(&[' ']).count(), len));\n+        let c: &[char] = &[' '];\n+        b.iter(|| assert_eq!(s.split(c).count(), len));\n     }\n \n     #[bench]"}, {"sha": "05d91a7504150589d80b4e26bc0f8f58e88b94ff", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -531,7 +531,8 @@ impl String {\n     ///\n     /// ```\n     /// let s = String::from_str(\"hello\");\n-    /// assert_eq!(s.as_bytes(), &[104, 101, 108, 108, 111]);\n+    /// let b: &[_] = &[104, 101, 108, 108, 111];\n+    /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n@@ -552,7 +553,8 @@ impl String {\n     ///     bytes[1] = 51;\n     ///     bytes[4] = 48;\n     /// }\n-    /// assert_eq!(s.as_bytes(), &[104, 51, 108, 108, 48]);\n+    /// let b: &[_] = &[104, 51, 108, 108, 48];\n+    /// assert_eq!(s.as_bytes(), b);\n     /// assert_eq!(s.as_slice(), \"h3ll0\")\n     /// ```\n     #[inline]"}, {"sha": "8e5ffbd1686605a55612d08d35fec4dcc42b41ab", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1853,7 +1853,8 @@ mod test_treemap {\n         check_equal(ctrl.as_slice(), &map);\n         assert!(map.find(&5).is_none());\n \n-        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n+        let seed: &[_] = &[42];\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n \n         for _ in range(0u, 3) {\n             for _ in range(0u, 90) {"}, {"sha": "b90c6daf9ebaec834c67af7459d7ae368af07f94", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -112,12 +112,13 @@ impl Ordering {\n     /// assert_eq!(Greater.reverse(), Less);\n     ///\n     ///\n-    /// let mut data = &mut [2u, 10, 5, 8];\n+    /// let mut data: &mut [_] = &mut [2u, 10, 5, 8];\n     ///\n     /// // sort the array from largest to smallest.\n     /// data.sort_by(|a, b| a.cmp(b).reverse());\n     ///\n-    /// assert_eq!(data, &mut [10u, 8, 5, 2]);\n+    /// let b: &mut [_] = &mut [10u, 8, 5, 2];\n+    /// assert!(data == b);\n     /// ```\n     #[inline]\n     #[experimental]"}, {"sha": "4ecc1b8f45fc09f0db753a96ae41894b589084ed", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -93,6 +93,8 @@ pub trait TyVisitor {\n     fn visit_char(&mut self) -> bool;\n \n     fn visit_estr_slice(&mut self) -> bool;\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;\n \n     fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n@@ -101,8 +103,13 @@ pub trait TyVisitor {\n     fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *const TyDesc) -> bool;\n+    #[cfg(not(stage0))]\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n+                        inner: *const TyDesc) -> bool;\n \n     fn visit_enter_rec(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;"}, {"sha": "f0c39766ebb300548b5d5798d8c331d5e7f777c1", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -174,7 +174,7 @@ pub unsafe fn overwrite<T>(dst: *mut T, src: T) {\n \n /// Deprecated, use `overwrite` instead\n #[inline]\n-#[deprecated = \"use ptr::write\"]\n+#[deprecated = \"this function has been renamed to overwrite()\"]\n pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n     ptr::write(dst, src)\n }"}, {"sha": "7773e03416e9e61bfda18d4dab35963421c81f00", "filename": "src/libcore/option.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -221,8 +221,14 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n-            Some(ref mut x) => slice::mut_ref_slice(x),\n-            None => &mut []\n+            Some(ref mut x) => {\n+                let result: &mut [T] = slice::mut_ref_slice(x);\n+                result\n+            }\n+            None => {\n+                let result: &mut [T] = &mut [];\n+                result\n+            }\n         }\n     }\n \n@@ -524,7 +530,10 @@ impl<T> Slice<T> for Option<T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n-            None => &[]\n+            None => {\n+                let result: &[_] = &[];\n+                result\n+            }\n         }\n     }\n }"}, {"sha": "5daa693c77400267221036f4dbf2faf0a0029b13", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -51,10 +51,16 @@ pub struct Procedure {\n ///\n /// This struct does not have a `Repr` implementation\n /// because there is no way to refer to all trait objects generically.\n+#[cfg(stage0)]\n pub struct TraitObject {\n     pub vtable: *mut (),\n     pub data: *mut (),\n }\n+#[cfg(not(stage0))]\n+pub struct TraitObject {\n+    pub data: *mut (),\n+    pub vtable: *mut (),\n+}\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values."}, {"sha": "475c2e94ec778a47f220e7ac78364eba3cbc4ec4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1623,7 +1623,6 @@ pub mod bytes {\n \n \n \n-\n //\n // Boilerplate traits\n //\n@@ -1649,6 +1648,27 @@ impl<'a,T:PartialEq, V: Slice<T>> Equiv<V> for &'a [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n+    fn eq(&self, other: & &'a mut [T]) -> bool {\n+        self.len() == other.len() &&\n+        order::eq(self.iter(), other.iter())\n+    }\n+    fn ne(&self, other: & &'a mut [T]) -> bool {\n+        self.len() != other.len() ||\n+        order::ne(self.iter(), other.iter())\n+    }\n+}\n+\n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:Eq> Eq for &'a mut [T] {}\n+\n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:PartialEq, V: Slice<T>> Equiv<V> for &'a mut [T] {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n+\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Ord> Ord for &'a [T] {\n     fn cmp(&self, other: & &'a [T]) -> Ordering {"}, {"sha": "5cbeda94d0f8607d95c8c48300c0636ebb99d2d7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -918,8 +918,8 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n ///\n /// // \"ab\\0d\"\n /// v[2] = 0;\n-/// assert_eq!(str::truncate_utf16_at_nul(v),\n-///            &['a' as u16, 'b' as u16]);\n+/// let b: &[_] = &['a' as u16, 'b' as u16];\n+/// assert_eq!(str::truncate_utf16_at_nul(v), b);\n /// ```\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n@@ -1439,7 +1439,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n     /// ```\n     fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n@@ -1454,7 +1455,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n     /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n     /// ```\n     fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n@@ -1469,7 +1471,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n     /// ```\n     fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n@@ -1620,7 +1623,8 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n     ///\n     /// // neither are found\n-    /// assert_eq!(s.find(&['1', '2']), None);\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.find(x), None);\n     /// ```\n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n \n@@ -1644,7 +1648,8 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n     ///\n     /// // searches for an occurrence of either `1` or `2`, but neither are found\n-    /// assert_eq!(s.rfind(&['1', '2']), None);\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.rfind(x), None);\n     /// ```\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n "}, {"sha": "99ac7cfed027f744708c0f69a404710170d2a70b", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -368,7 +368,7 @@ fn test_collect() {\n \n #[test]\n fn test_all() {\n-    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    let v: Box<[int]> = box [1i, 2, 3, 4, 5];\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n@@ -377,7 +377,7 @@ fn test_all() {\n \n #[test]\n fn test_any() {\n-    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    let v: Box<[int]> = box [1i, 2, 3, 4, 5];\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));"}, {"sha": "b89ea4d373ddc9b1bea52cb56373fb2a4ccc62ff", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -193,6 +193,8 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self, n: uint,\n                         sz: uint,\n                         align: uint) -> bool {\n@@ -237,6 +239,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align(align);\n@@ -246,6 +249,16 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         self.bump(sz);\n         true\n     }\n+    #[cfg(not(stage0))]\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n+                        inner: *const TyDesc) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_evec_fixed(n, sz, align, inner) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n \n     fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);"}, {"sha": "20f96d24a5f5f14939b727db61b0f8962039504c", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -275,6 +275,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     // Type no longer exists, vestigial function.\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { fail!(); }\n \n@@ -328,6 +330,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n                         _: uint, inner: *const TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n@@ -336,6 +340,16 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n+                        inner: *const TyDesc) -> bool {\n+        let assumed_size = if sz == 0 { n } else { sz };\n+        self.get::<()>(|this, b| {\n+            this.write_vec_range(b, assumed_size, inner)\n+        })\n+    }\n+\n+\n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         try!(self, self.writer.write([b'{']));"}, {"sha": "296615e15ffa065cc1081035dfbff1e806a4697c", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -112,7 +112,7 @@ impl Context {\n                 // the stack limit to 0 to make morestack never fail\n                 None => stack::record_rust_managed_stack_bounds(0, uint::MAX),\n             }\n-            rust_swap_registers(out_regs, in_regs)\n+            rust_swap_registers(out_regs, in_regs);\n         }\n     }\n }"}, {"sha": "ba45d2b2e73ff2c569dc240c3b97a96ad41b1907", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1449,8 +1449,8 @@ mod biguint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let data: Vec<BigUint> = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n-            .iter().map(|v| BigUint::from_slice(*v)).collect();\n+        let data: [&[_], ..7] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ];\n+        let data: Vec<BigUint> = data.iter().map(|v| BigUint::from_slice(*v)).collect();\n         for (i, ni) in data.iter().enumerate() {\n             for (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n                 let j = j0 + i;\n@@ -2311,7 +2311,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n+        let vs: [&[BigDigit], ..4] = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n         let mut nums = Vec::new();\n         for s in vs.iter().rev() {\n             nums.push(BigInt::from_slice(Minus, *s));"}, {"sha": "0f7cda42a8a0ccf0237a93831ad825895870ec46", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -13,7 +13,6 @@\n use core::prelude::*;\n use core::iter::{range_step, Repeat};\n use core::slice::raw;\n-use core::mem;\n \n use {Rng, SeedableRng, Rand};\n \n@@ -46,6 +45,7 @@ static EMPTY: IsaacRng = IsaacRng {\n };\n \n impl IsaacRng {\n+\n     /// Create an ISAAC random number generator using the default\n     /// fixed seed.\n     pub fn new_unseeded() -> IsaacRng {\n@@ -225,7 +225,7 @@ impl Rand for IsaacRng {\n             let ptr = ret.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8,\n-                                  mem::size_of_val(&ret.rsl), |slice| {\n+                                  (RAND_SIZE*4) as uint, |slice| {\n                 other.fill_bytes(slice);\n             })\n         }\n@@ -456,7 +456,7 @@ impl Rand for Isaac64Rng {\n             let ptr = ret.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8,\n-                                  mem::size_of_val(&ret.rsl), |slice| {\n+                                  (RAND_SIZE_64*8) as uint, |slice| {\n                 other.fill_bytes(slice);\n             })\n         }\n@@ -497,15 +497,15 @@ mod test {\n \n     #[test]\n     fn test_rng_32_seeded() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -537,15 +537,15 @@ mod test {\n \n     #[test]\n     fn test_rng_32_true_values() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = Vec::from_fn(10, |_| ra.next_u32());\n         assert_eq!(v,\n                    vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n                         4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n \n-        let seed = &[12345, 67890, 54321, 9876];\n+        let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u32(); }\n@@ -557,7 +557,7 @@ mod test {\n     }\n     #[test]\n     fn test_rng_64_true_values() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = Vec::from_fn(10, |_| ra.next_u64());\n@@ -567,7 +567,7 @@ mod test {\n                         4469761996653280935, 15552757044682284409, 6860251611068737823,\n                         13722198873481261842));\n \n-        let seed = &[12345, 67890, 54321, 9876];\n+        let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u64(); }"}, {"sha": "5f460225d39a933fe033ab87fe7287c14ad333ed", "filename": "src/librand/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -309,7 +309,8 @@ pub trait SeedableRng<Seed>: Rng {\n     /// ```rust\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n-    /// let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    /// let seed: &[_] = &[1, 2, 3, 4];\n+    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n     /// println!(\"{}\", rng.gen::<f64>());\n     /// rng.reseed([5, 6, 7, 8]);\n     /// println!(\"{}\", rng.gen::<f64>());\n@@ -323,7 +324,8 @@ pub trait SeedableRng<Seed>: Rng {\n     /// ```rust\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n-    /// let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    /// let seed: &[_] = &[1, 2, 3, 4];\n+    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n     /// println!(\"{}\", rng.gen::<f64>());\n     /// ```\n     fn from_seed(seed: Seed) -> Self;"}, {"sha": "443bf4d34ffa159918db047a6c07bca7fb54a980", "filename": "src/librbml/io.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -96,7 +96,8 @@ impl Writer for SeekableMemWriter {\n             let (left, right) = if cap <= buf.len() {\n                 (buf.slice_to(cap), buf.slice_from(cap))\n             } else {\n-                (buf, &[])\n+                let result: (_, &[_]) = (buf, &[]);\n+                result\n             };\n \n             // Do the necessary writes\n@@ -142,24 +143,29 @@ mod tests {\n         writer.write([1, 2, 3]).unwrap();\n         writer.write([4, 5, 6, 7]).unwrap();\n         assert_eq!(writer.tell(), Ok(8));\n-        assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(0, io::SeekSet).unwrap();\n         assert_eq!(writer.tell(), Ok(0));\n         writer.write([3, 4]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(1, io::SeekCur).unwrap();\n         writer.write([0, 1]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 7]);\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(-1, io::SeekEnd).unwrap();\n         writer.write([1, 2]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(1, io::SeekEnd).unwrap();\n         writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n+        assert_eq!(writer.get_ref(), b);\n     }\n \n     #[test]"}, {"sha": "77e73c46c402cf2f6ac23962b2dc4d80124759be", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -34,7 +34,6 @@ register_diagnostics!(\n     E0015,\n     E0016,\n     E0017,\n-    E0018,\n     E0019,\n     E0020,\n     E0021,\n@@ -53,7 +52,6 @@ register_diagnostics!(\n     E0034,\n     E0035,\n     E0036,\n-    E0037,\n     E0038,\n     E0039,\n     E0040,\n@@ -80,8 +78,6 @@ register_diagnostics!(\n     E0061,\n     E0062,\n     E0063,\n-    E0064,\n-    E0065,\n     E0066,\n     E0067,\n     E0068,\n@@ -127,8 +123,6 @@ register_diagnostics!(\n     E0108,\n     E0109,\n     E0110,\n-    E0111,\n-    E0112,\n     E0113,\n     E0114,\n     E0115,"}, {"sha": "5f26a966f97e7e556258ff929e904ec63d567b24", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -477,13 +477,14 @@ fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n \n     box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprVstore(box(GC) ast::Expr {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprVec(cx.testfns.iter().map(|test| {\n-                mk_test_desc_and_fn_rec(cx, test)\n+        node: ast::ExprAddrOf(ast::MutImmutable,\n+            box(GC) ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::ExprVec(cx.testfns.iter().map(|test| {\n+                    mk_test_desc_and_fn_rec(cx, test)\n             }).collect()),\n             span: DUMMY_SP,\n-        }, ast::ExprVstoreSlice),\n+        }),\n         span: DUMMY_SP,\n     }\n }"}, {"sha": "214401b17a1bb52956d747f68183054b9dcfa245", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1240,18 +1240,8 @@ impl LintPass for UnnecessaryAllocation {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        // Warn if string and vector literals with sigils, or boxing expressions,\n-        // are immediately borrowed.\n+        // Warn if boxing expressions are immediately borrowed.\n         let allocation = match e.node {\n-            ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n-                match e2.node {\n-                    ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-                        VectorAllocation\n-                    }\n-                    ast::ExprVec(..) => VectorAllocation,\n-                    _ => return\n-                }\n-            }\n             ast::ExprUnary(ast::UnUniq, _) |\n             ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n \n@@ -1261,19 +1251,19 @@ impl LintPass for UnnecessaryAllocation {\n         match cx.tcx.adjustments.borrow().find(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n+                    ty::AutoDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n                         match (allocation, autoref) {\n-                            (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n+                            (VectorAllocation, &Some(ty::AutoPtr(_, _, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, the sigil can be removed\");\n                             }\n                             (BoxAllocation,\n-                             Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n+                             &Some(ty::AutoPtr(_, ast::MutImmutable, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use & instead\");\n                             }\n                             (BoxAllocation,\n-                             Some(ty::AutoPtr(_, ast::MutMutable))) => {\n+                             &Some(ty::AutoPtr(_, ast::MutMutable, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use &mut instead\");\n                             }\n@@ -1566,6 +1556,9 @@ declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n               \"detects enums with widely varying variant sizes\")\n \n+declare_lint!(pub TRANSMUTE_FAT_PTR, Allow,\n+              \"detects transmutes of fat pointers\")\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n pub struct HardwiredLints;"}, {"sha": "2ef5675caa1779ed9c9ff953d0488f63d09a827b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -377,9 +377,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n       'V' => {\n-        let mt = parse_mt(st, |x,y| conv(x,y));\n+        let t = parse_ty(st, |x,y| conv(x,y));\n         let sz = parse_size(st);\n-        return ty::mk_vec(st.tcx, mt, sz);\n+        return ty::mk_vec(st.tcx, t, sz);\n       }\n       'v' => {\n         return ty::mk_str(st.tcx);"}, {"sha": "84ee49c207b0f5e6f6a55b35b9459c1a9c0fddcb", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -254,9 +254,9 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_vec(mt, sz) => {\n+        ty::ty_vec(t, sz) => {\n             mywrite!(w, \"V\");\n-            enc_mt(w, cx, mt);\n+            enc_ty(w, cx, t);\n             mywrite!(w, \"/\");\n             match sz {\n                 Some(n) => mywrite!(w, \"{}|\", n),\n@@ -292,6 +292,9 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n+        ty::ty_open(_) => {\n+            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n+        }\n     }\n }\n "}, {"sha": "6a8ee2675425f37edd7c39dd7777f918b948c5f9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 220, "deletions": 60, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -495,25 +495,7 @@ impl tr for def::Def {\n }\n \n // ______________________________________________________________________\n-// Encoding and decoding of adjustment information\n-\n-impl tr for ty::AutoDerefRef {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n-        ty::AutoDerefRef {\n-            autoderefs: self.autoderefs,\n-            autoref: match self.autoref {\n-                Some(ref autoref) => Some(autoref.tr(xcx)),\n-                None => None\n-            }\n-        }\n-    }\n-}\n-\n-impl tr for ty::AutoRef {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n-        self.map_region(|r| r.tr(xcx))\n-    }\n-}\n+// Encoding and decoding of ancillary information\n \n impl tr for ty::Region {\n     fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::Region {\n@@ -961,6 +943,9 @@ trait rbml_writer_helpers {\n                      pty: ty::Polytype);\n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n+    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef);\n+    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef);\n+    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind);\n }\n \n impl<'a> rbml_writer_helpers for Encoder<'a> {\n@@ -1035,16 +1020,91 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n \n                 ty::AutoDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| auto_deref_ref.encode(this))\n+                        this.emit_enum_variant_arg(0,\n+                            |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n+                    })\n+                }\n+            }\n+        });\n+    }\n+\n+    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef) {\n+        use serialize::Encoder;\n+\n+        self.emit_enum(\"AutoRef\", |this| {\n+            match autoref {\n+                &ty::AutoPtr(r, m, None) => {\n+                    this.emit_enum_variant(\"AutoPtr\", 0, 3, |this| {\n+                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(2,\n+                            |this| this.emit_option(|this| this.emit_option_none()))\n                     })\n                 }\n+                &ty::AutoPtr(r, m, Some(box ref a)) => {\n+                    this.emit_enum_variant(\"AutoPtr\", 0, 3, |this| {\n+                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(2, |this| this.emit_option(\n+                            |this| this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a)))))\n+                    })\n+                }\n+                &ty::AutoUnsize(ref uk) => {\n+                    this.emit_enum_variant(\"AutoUnsize\", 1, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n+                    })\n+                }\n+                &ty::AutoUnsizeUniq(ref uk) => {\n+                    this.emit_enum_variant(\"AutoUnsizeUniq\", 2, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n+                    })\n+                }\n+                &ty::AutoUnsafe(m) => {\n+                    this.emit_enum_variant(\"AutoUnsafe\", 3, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| m.encode(this))\n+                    })\n+                }\n+            }\n+        });\n+    }\n+\n+    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef) {\n+        use serialize::Encoder;\n+\n+        self.emit_struct(\"AutoDerefRef\", 2, |this| {\n+            this.emit_struct_field(\"autoderefs\", 0, |this| auto_deref_ref.autoderefs.encode(this));\n+            this.emit_struct_field(\"autoref\", 1, |this| {\n+                this.emit_option(|this| {\n+                    match auto_deref_ref.autoref {\n+                        None => this.emit_option_none(),\n+                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n+                    }\n+                })\n+            })\n+        });\n+    }\n+\n+    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind) {\n+        use serialize::Encoder;\n \n-                ty::AutoObject(store, b, def_id, ref substs) => {\n-                    this.emit_enum_variant(\"AutoObject\", 2, 4, |this| {\n-                        this.emit_enum_variant_arg(0, |this| store.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| b.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(3, |this| Ok(this.emit_substs(ecx, substs)))\n+        self.emit_enum(\"UnsizeKind\", |this| {\n+            match *uk {\n+                ty::UnsizeLength(len) => {\n+                    this.emit_enum_variant(\"UnsizeLength\", 0, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| len.encode(this))\n+                    })\n+                }\n+                ty::UnsizeStruct(box ref uk, idx) => {\n+                    this.emit_enum_variant(\"UnsizeStruct\", 1, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)));\n+                        this.emit_enum_variant_arg(1, |this| idx.encode(this))\n+                    })\n+                }\n+                ty::UnsizeVtable(b, def_id, ref substs) => {\n+                    this.emit_enum_variant(\"UnsizeVtable\", 2, 3, |this| {\n+                        this.emit_enum_variant_arg(0, |this| b.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| def_id.encode(this));\n+                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n                 }\n             }\n@@ -1227,9 +1287,30 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &adj in tcx.adjustments.borrow().find(&id).iter() {\n-        match *adj {\n-            ty::AutoDerefRef(adj) => {\n+    for &adjustment in tcx.adjustments.borrow().find(&id).iter() {\n+        match *adjustment {\n+            _ if ty::adjust_is_object(adjustment) => {\n+                let method_call = MethodCall::autoobject(id);\n+                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n+                        })\n+                    })\n+                }\n+\n+                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n+                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n+                        })\n+                    })\n+                }\n+            }\n+            ty::AutoDerefRef(ref adj) => {\n+                assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n                     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n@@ -1253,33 +1334,15 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     }\n                 }\n             }\n-            ty::AutoObject(..) => {\n-                let method_call = MethodCall::autoobject(id);\n-                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n-                        })\n-                    })\n-                }\n-\n-                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n-                        })\n-                    })\n-                }\n+            _ => {\n+                assert!(!ty::adjust_is_object(adjustment));\n             }\n-            _ => {}\n         }\n \n         rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_auto_adjustment(ecx, adj);\n+                rbml_w.emit_auto_adjustment(ecx, adjustment);\n             })\n         })\n     }\n@@ -1321,6 +1384,9 @@ trait rbml_decoder_decoder_helpers {\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n                             -> ty::UnboxedClosure;\n+    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef;\n+    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef;\n+    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind;\n     fn convert_def_id(&mut self,\n                       xcx: &ExtendedDecodeContext,\n                       source: DefIdSource,\n@@ -1460,34 +1526,128 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n         self.read_enum(\"AutoAdjustment\", |this| {\n-            let variants = [\"AutoAddEnv\", \"AutoDerefRef\", \"AutoObject\"];\n+            let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty:: AutoAddEnv(store.tr(xcx))\n+                        ty::AutoAddEnv(store.tr(xcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_auto_deref_ref(xcx))).unwrap();\n+\n+                        ty::AutoDerefRef(auto_deref_ref)\n+                    }\n+                    _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n+\n+    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n+        self.read_struct(\"AutoDerefRef\", 2, |this| {\n+            Ok(ty::AutoDerefRef {\n+                autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n+                    Decodable::decode(this)\n+                }).unwrap(),\n+                autoref: this.read_struct_field(\"autoref\", 1, |this| {\n+                    this.read_option(|this, b| {\n+                        if b {\n+                            Ok(Some(this.read_autoref(xcx)))\n+                        } else {\n+                            Ok(None)\n+                        }\n+                    })\n+                }).unwrap(),\n+            })\n+        }).unwrap()\n+    }\n+\n+    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n+        self.read_enum(\"AutoRef\", |this| {\n+            let variants = [\"AutoPtr\",\n+                            \"AutoUnsize\",\n+                            \"AutoUnsizeUniq\",\n+                            \"AutoUnsafe\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                Ok(match i {\n+                    0 => {\n+                        let r: ty::Region =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+                        let m: ast::Mutability =\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                        let a: Option<Box<ty::AutoRef>> =\n+                            this.read_enum_variant_arg(2, |this| this.read_option(|this, b| {\n+                                if b {\n+                                    Ok(Some(box this.read_autoref(xcx)))\n+                                } else {\n+                                    Ok(None)\n+                                }\n+                            })).unwrap();\n+\n+                        ty::AutoPtr(r.tr(xcx), m, a)\n+                    }\n+                    1 => {\n+                        let uk: ty::UnsizeKind =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n \n-                        ty::AutoDerefRef(auto_deref_ref.tr(xcx))\n+                        ty::AutoUnsize(uk)\n                     }\n                     2 => {\n-                        let store: ty::TraitStore =\n+                        let uk: ty::UnsizeKind =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+\n+                        ty::AutoUnsizeUniq(uk)\n+                    }\n+                    3 => {\n+                        let m: ast::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-                        let b: ty::BuiltinBounds =\n+\n+                        ty::AutoUnsafe(m)\n+                    }\n+                    _ => fail!(\"bad enum variant for ty::AutoRef\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n+\n+    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind {\n+        self.read_enum(\"UnsizeKind\", |this| {\n+            let variants = [\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                Ok(match i {\n+                    0 => {\n+                        let len: uint =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+\n+                        ty::UnsizeLength(len)\n+                    }\n+                    1 => {\n+                        let uk: ty::UnsizeKind =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                        let idx: uint =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+\n+                        ty::UnsizeStruct(box uk, idx)\n+                    }\n+                    2 => {\n+                        let b: ty::BuiltinBounds =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n                         let def_id: ast::DefId =\n-                            this.read_enum_variant_arg(2, |this| Decodable::decode(this)).unwrap();\n-                        let substs = this.read_enum_variant_arg(3, |this| Ok(this.read_substs(xcx)))\n-                                    .unwrap();\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                        let substs = this.read_enum_variant_arg(2,\n+                            |this| Ok(this.read_substs(xcx))).unwrap();\n \n-                        ty::AutoObject(store.tr(xcx), b, def_id.tr(xcx), substs)\n+                        ty::UnsizeVtable(b, def_id.tr(xcx), substs)\n                     }\n-                    _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n+                    _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n             })\n         }).unwrap()"}, {"sha": "230786924d7c4139352550f9c053e1950a493ac2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -428,16 +428,15 @@ impl<'a> BorrowckCtxt<'a> {\n                                adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n         let r = match *adj {\n-            ty::AutoAddEnv(..) | ty::AutoObject(..) => {\n-                // no autoderefs\n-                self.mc().cat_expr_unadjusted(expr)\n-            }\n-\n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, ..}) => {\n                 self.mc().cat_expr_autoderefd(expr, autoderefs)\n             }\n+            ty::AutoAddEnv(..) => {\n+                // no autoderefs\n+                self.mc().cat_expr_unadjusted(expr)\n+            }\n         };\n \n         match r {"}, {"sha": "0d77b01d9706dc22db8f99aba6fc80a504f88b4a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -465,7 +465,6 @@ impl<'a> CFGBuilder<'a> {\n             ast::ExprCast(e, _) |\n             ast::ExprUnary(_, e) |\n             ast::ExprParen(e) |\n-            ast::ExprVstore(e, _) |\n             ast::ExprField(e, _, _) => {\n                 self.straightline(expr, pred, [e])\n             }"}, {"sha": "629aba8092c27b45ad795b2c7f52084c62fee73b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -62,7 +62,7 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     fn is_str(e: &Expr) -> bool {\n         match e.node {\n-            ExprVstore(expr, ExprVstoreUniq) => {\n+            ExprBox(_, expr) => {\n                 match expr.node {\n                     ExprLit(lit) => ast_util::lit_is_str(lit),\n                     _ => false,\n@@ -169,8 +169,6 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                 None => {}\n             }\n           }\n-          ExprVstore(_, ExprVstoreMutSlice) |\n-          ExprVstore(_, ExprVstoreSlice) |\n           ExprVec(_) |\n           ExprAddrOf(MutImmutable, _) |\n           ExprParen(..) |\n@@ -179,13 +177,14 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprTup(..) |\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n-          ExprAddrOf(..) => {\n-              span_err!(v.tcx.sess, e.span, E0017,\n-                  \"references in constants may only refer to immutable values\");\n-          },\n-          ExprVstore(_, ExprVstoreUniq) => {\n-              span_err!(v.tcx.sess, e.span, E0018,\n-                  \"cannot allocate vectors in constant expressions\");\n+          ExprAddrOf(_, inner) => {\n+                match inner.node {\n+                    // Mutable slices are allowed.\n+                    ExprVec(_) => {}\n+                    _ => span_err!(v.tcx.sess, e.span, E0017,\n+                                   \"references in constants may only refer to immutable values\")\n+\n+                }\n           },\n \n           _ => {"}, {"sha": "042a5b8f60aaf80a1e4be1400065cd5f815c63a0", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -107,21 +107,19 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n \n         match e.node {\n             ast::ExprField(..) | ast::ExprVec(..) |\n-            ast::ExprBlock(..) | ast::ExprTup(..) |\n-            ast::ExprVstore(_, ast::ExprVstoreSlice) => {\n+            ast::ExprBlock(..) | ast::ExprTup(..)  => {\n                 visit::walk_expr(self, e, is_const);\n             }\n-            ast::ExprVstore(_, ast::ExprVstoreMutSlice) => {\n+            ast::ExprAddrOf(ast::MutMutable, _) => {\n                 span_err!(self.tcx.sess, e.span, E0020,\n                     \"static items are not allowed to have mutable slices\");\n-           },\n+            },\n             ast::ExprUnary(ast::UnBox, _) => {\n                 span_err!(self.tcx.sess, e.span, E0021,\n                     \"static items are not allowed to have managed pointers\");\n             }\n             ast::ExprBox(..) |\n-            ast::ExprUnary(ast::UnUniq, _) |\n-            ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n+            ast::ExprUnary(ast::UnUniq, _) => {\n                 span_err!(self.tcx.sess, e.span, E0022,\n                     \"static items are not allowed to have custom pointers\");\n             }"}, {"sha": "03a7021b70d0b57a94622ed8abf7f01274517149", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -206,14 +206,6 @@ impl<'a> ConstEvalVisitor<'a> {\n             ast::ExprVec(ref es) =>\n                 join_all(es.iter().map(|e| self.classify(&**e))),\n \n-            ast::ExprVstore(ref e, vstore) => {\n-                match vstore {\n-                    ast::ExprVstoreSlice => self.classify(&**e),\n-                    ast::ExprVstoreUniq |\n-                    ast::ExprVstoreMutSlice => non_const\n-                }\n-            }\n-\n             ast::ExprStruct(_, ref fs, None) => {\n                 let cs = fs.iter().map(|f| self.classify(&*f.expr));\n                 join_all(cs)\n@@ -554,8 +546,6 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           }\n       }\n       ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n-      // If we have a vstore, just keep going; it has to be a string\n-      ExprVstore(ref e, _) => eval_const_expr_partial(tcx, &**e),\n       ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n       ExprBlock(ref block) => {\n         match block.expr {"}, {"sha": "d72eeaef8416e1cdf65a36ee1f34f8c7c5ce1ffb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -474,10 +474,6 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 self.walk_captures(expr)\n             }\n \n-            ast::ExprVstore(ref base, _) => {\n-                self.consume_expr(&**base);\n-            }\n-\n             ast::ExprBox(ref place, ref base) => {\n                 self.consume_expr(&**place);\n                 self.consume_expr(&**base);\n@@ -672,11 +668,10 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoAddEnv(..) |\n-                    ty::AutoObject(..) => {\n-                        // Creating an object or closure consumes the\n-                        // input and stores it into the resulting rvalue.\n-                        debug!(\"walk_adjustment(AutoAddEnv|AutoObject)\");\n+                    ty::AutoAddEnv(..) => {\n+                        // Creating a closure consumes the input and stores it\n+                        // into the resulting rvalue.\n+                        debug!(\"walk_adjustment(AutoAddEnv)\");\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n@@ -735,42 +730,39 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_autoref(&mut self,\n                     expr: &ast::Expr,\n                     autoref: &ty::AutoRef,\n-                    autoderefs: uint) {\n-        debug!(\"walk_autoref expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n+                    n: uint) {\n+        debug!(\"walk_autoref expr={}\", expr.repr(self.tcx()));\n \n-        let cmt_derefd = return_if_err!(\n-            self.mc.cat_expr_autoderefd(expr, autoderefs));\n+        // Match for unique trait coercions first, since we don't need the\n+        // call to cat_expr_autoderefd.\n+        match *autoref {\n+            ty::AutoUnsizeUniq(ty::UnsizeVtable(..)) |\n+            ty::AutoUnsize(ty::UnsizeVtable(..)) => {\n+                assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n+                                         AutoRefs, found: {}\", n));\n+                let cmt_unadjusted =\n+                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                return;\n+            }\n+            _ => {}\n+        }\n \n-        debug!(\"walk_autoref: cmt_derefd={}\", cmt_derefd.repr(self.tcx()));\n+        let cmt_derefd = return_if_err!(\n+            self.mc.cat_expr_autoderefd(expr, n));\n+        debug!(\"walk_adjustment: cmt_derefd={}\",\n+               cmt_derefd.repr(self.tcx()));\n \n         match *autoref {\n-            ty::AutoPtr(r, m) => {\n+            ty::AutoPtr(r, m, _) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_derefd,\n                                      r,\n                                      ty::BorrowKind::from_mutbl(m),\n-                                     AutoRef)\n-            }\n-            ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-                let cmt_index = self.mc.cat_index(expr, cmt_derefd, autoderefs+1);\n-                self.delegate.borrow(expr.id,\n-                                     expr.span,\n-                                     cmt_index,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m),\n-                                     AutoRef)\n-            }\n-            ty::AutoBorrowObj(r, m) => {\n-                let cmt_deref = self.mc.cat_deref_obj(expr, cmt_derefd);\n-                self.delegate.borrow(expr.id,\n-                                     expr.span,\n-                                     cmt_deref,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m),\n-                                     AutoRef)\n+                                     AutoRef);\n             }\n-            ty::AutoUnsafe(_) => {}\n+            ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) | ty::AutoUnsafe(_) => {}\n         }\n     }\n "}, {"sha": "639f89dc3cceddbfef8d0551915dabf9e3a63cb3", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -92,7 +92,7 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n         }\n     }\n \n-    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t) {\n+    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t, id: ast::NodeId) {\n         if type_size_is_affected_by_type_parameters(self.tcx, from) {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute from a type that contains type parameters\");\n@@ -106,6 +106,7 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n             span: span,\n             from: from,\n             to: to,\n+            id: id,\n         };\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n@@ -123,7 +124,7 @@ impl<'a> Visitor<()> for IntrinsicCheckingVisitor<'a> {\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n                                 let from = *bare_fn_ty.sig.inputs.get(0);\n                                 let to = bare_fn_ty.sig.output;\n-                                self.check_transmute(expr.span, from, to);\n+                                self.check_transmute(expr.span, from, to, expr.id);\n                             }\n                             _ => {\n                                 self.tcx"}, {"sha": "b96a75cba94800cd136e98b96d5ccc97e0d5cb1e", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -405,14 +405,27 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                            \"repeated element will be copied\");\n             }\n         }\n+        ExprAssign(ref lhs, _) |\n+        ExprAssignOp(_, ref lhs, _) => {\n+            let lhs_ty = ty::expr_ty(cx.tcx, &**lhs);\n+            if !ty::type_is_sized(cx.tcx, lhs_ty) {\n+                cx.tcx.sess.span_err(lhs.span, \"dynamically sized type on lhs of assignment\");\n+            }\n+        }\n+        ExprStruct(..) => {\n+            let e_ty = ty::expr_ty(cx.tcx, e);\n+            if !ty::type_is_sized(cx.tcx, e_ty) {\n+                cx.tcx.sess.span_err(e.span, \"trying to initialise a dynamically sized struct\");\n+            }\n+        }\n         _ => {}\n     }\n \n     // Search for auto-adjustments to find trait coercions.\n     match cx.tcx.adjustments.borrow().find(&e.id) {\n         Some(adjustment) => {\n-            match *adjustment {\n-                ty::AutoObject(..) => {\n+            match adjustment {\n+                adj if ty::adjust_is_object(adj) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n                     let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n                     let method_call = MethodCall {\n@@ -425,8 +438,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                                      e.span,\n                                      method_call);\n                 }\n-                ty::AutoAddEnv(..) |\n-                ty::AutoDerefRef(..) => {}\n+                _ => {}\n             }\n         }\n         None => {}"}, {"sha": "38288bf301161b735c4be0c7c05d0e82af12cd0e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -511,7 +511,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n \n       // otherwise, live nodes are not required:\n-      ExprIndex(..) | ExprField(..) | ExprVstore(..) | ExprVec(..) |\n+      ExprIndex(..) | ExprField(..) | ExprVec(..) |\n       ExprCall(..) | ExprMethodCall(..) | ExprTup(..) |\n       ExprBinary(..) | ExprAddrOf(..) |\n       ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n@@ -1119,10 +1119,6 @@ impl<'a> Liveness<'a> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ExprVstore(ref expr, _) => {\n-            self.propagate_through_expr(&**expr, succ)\n-          }\n-\n           ExprVec(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n@@ -1449,8 +1445,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       // no correctness conditions related to liveness\n       ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n       ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n-      ExprVstore(..) | ExprVec(..) | ExprTup(..) |\n-      ExprBinary(..) |\n+      ExprVec(..) | ExprTup(..) | ExprBinary(..) |\n       ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |"}, {"sha": "2d052feb6720f03974dca1234145901767315217", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -205,7 +205,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::ty_vec(_, Some(_)) => {\n+        ty::ty_vec(_, _) | ty::ty_str => {\n             Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n@@ -214,11 +214,12 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n }\n \n pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n+    debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n     match opt_deref_kind(t) {\n       Some(k) => k,\n       None => {\n         tcx.sess.bug(\n-            format!(\"deref_cat() invoked on non-derefable type {}\",\n+            format!(\"deref_kind() invoked on non-derefable type {}\",\n                     ty_to_string(tcx, t)).as_slice());\n       }\n     }\n@@ -411,13 +412,6 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoObject(..) => {\n-                        // Implicitly cast a concrete object to trait object.\n-                        // Result is an rvalue.\n-                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n-                    }\n-\n                     ty::AutoAddEnv(..) => {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n@@ -485,7 +479,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                 }\n                 None => {\n                     let base_cmt = if_ok!(self.cat_expr(&**base));\n-                    Ok(self.cat_index(expr, base_cmt, 0))\n+                    Ok(self.cat_index(expr, base_cmt))\n                 }\n             }\n           }\n@@ -504,7 +498,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           ast::ExprFnBlock(..) | ast::ExprProc(..) |\n           ast::ExprUnboxedFn(..) | ast::ExprRet(..) |\n           ast::ExprUnary(..) |\n-          ast::ExprMethodCall(..) | ast::ExprCast(..) | ast::ExprVstore(..) |\n+          ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n@@ -703,7 +697,10 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                            -> cmt {\n         match self.typer.temporary_scope(id) {\n             Some(scope) => {\n-                self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n+                match ty::get(expr_ty).sty {\n+                    ty::ty_vec(_, Some(0)) => self.cat_rvalue(id, span, ty::ReStatic, expr_ty),\n+                    _ => self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n+                }\n             }\n             None => {\n                 self.cat_rvalue(id, span, ty::ReStatic, expr_ty)\n@@ -751,10 +748,11 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                              implicit: bool)\n                              -> cmt {\n         let adjustment = match self.typer.adjustments().borrow().find(&node.id()) {\n-            Some(&ty::AutoObject(..)) => typeck::AutoObject,\n+            Some(adj) if ty::adjust_is_object(adj) => typeck::AutoObject,\n             _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n             _ => typeck::NoAdjustment\n         };\n+\n         let method_call = typeck::MethodCall {\n             expr_id: node.id(),\n             adjustment: adjustment\n@@ -820,13 +818,9 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n-                                 mut base_cmt: cmt,\n-                                 derefs: uint)\n+                                 mut base_cmt: cmt)\n                                  -> cmt {\n-        //! Creates a cmt for an indexing operation (`[]`); this\n-        //! indexing operation may occurs as part of an\n-        //! AutoBorrowVec, which when converting a `~[]` to an `&[]`\n-        //! effectively takes the address of the 0th element.\n+        //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n         //! immediately obvious: for anything other than a fixed-length\n@@ -839,20 +833,9 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         //! cmt containing both this deref and the indexing,\n         //! presuming that `base_cmt` is not of fixed-length type.\n         //!\n-        //! In the event that a deref is needed, the \"deref count\"\n-        //! is taken from the parameter `derefs`. See the comment\n-        //! on the def'n of `root_map_key` in borrowck/mod.rs\n-        //! for more details about deref counts; the summary is\n-        //! that `derefs` should be 0 for an explicit indexing\n-        //! operation and N+1 for an indexing that is part of\n-        //! an auto-adjustment, where N is the number of autoderefs\n-        //! in that adjustment.\n-        //!\n         //! # Parameters\n         //! - `elt`: the AST node being indexed\n         //! - `base_cmt`: the cmt of `elt`\n-        //! - `derefs`: the deref number to be used for\n-        //!   the implicit index deref, if any (see above)\n \n         let method_call = typeck::MethodCall::expr(elt.id());\n         let method_ty = self.typer.node_method_ty(method_call);\n@@ -865,7 +848,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }\n             None => {\n                 match ty::array_element_ty(base_cmt.ty) {\n-                    Some(ref mt) => mt.ty,\n+                    Some(ty) => ty,\n                     None => {\n                         self.tcx().sess.span_bug(\n                             elt.span(),\n@@ -876,30 +859,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }\n         };\n \n-        return match deref_kind(self.tcx(), base_cmt.ty) {\n-          deref_ptr(ptr) => {\n-            // for unique ptrs, we inherit mutability from the\n-            // owning reference.\n-            let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n-\n-            // the deref is explicit in the resulting cmt\n-            let deref_cmt = Rc::new(cmt_ {\n-                id:elt.id(),\n-                span:elt.span(),\n-                cat:cat_deref(base_cmt.clone(), derefs, ptr),\n-                mutbl:m,\n-                ty:element_ty\n-            });\n-\n-            interior(elt, deref_cmt, base_cmt.ty, m.inherit(), element_ty)\n-          }\n-\n-          deref_interior(_) => {\n-            // fixed-length vectors have no deref\n-            let m = base_cmt.mutbl.inherit();\n-            interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty)\n-          }\n-        };\n+        let m = base_cmt.mutbl.inherit();\n+        return interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty);\n \n         fn interior<N: ast_node>(elt: &N,\n                                  of_cmt: cmt,\n@@ -917,6 +878,37 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         }\n     }\n \n+    // Takes either a vec or a reference to a vec and returns the cmt for the\n+    // underlying vec.\n+    fn deref_vec<N:ast_node>(&self,\n+                             elt: &N,\n+                             base_cmt: cmt)\n+                             -> cmt {\n+        match deref_kind(self.tcx(), base_cmt.ty) {\n+            deref_ptr(ptr) => {\n+                // for unique ptrs, we inherit mutability from the\n+                // owning reference.\n+                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n+\n+                // the deref is explicit in the resulting cmt\n+                Rc::new(cmt_ {\n+                    id:elt.id(),\n+                    span:elt.span(),\n+                    cat:cat_deref(base_cmt.clone(), 0, ptr),\n+                    mutbl:m,\n+                    ty: match ty::deref(base_cmt.ty, false) {\n+                        Some(mt) => mt.ty,\n+                        None => self.tcx().sess.bug(\"Found non-derefable type\")\n+                    }\n+                })\n+            }\n+\n+            deref_interior(_) => {\n+                base_cmt\n+            }\n+        }\n+    }\n+\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt,\n                              slice_pat: &ast::Pat)\n@@ -935,7 +927,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n-        let cmt_slice = self.cat_index(slice_pat, vec_cmt, 0);\n+        let cmt_slice = self.cat_index(slice_pat, self.deref_vec(slice_pat, vec_cmt));\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         fn vec_slice_info(tcx: &ty::ctxt,\n@@ -951,7 +943,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n             match ty::get(slice_ty).sty {\n                 ty::ty_rptr(r, ref mt) => match ty::get(mt.ty).sty {\n-                    ty::ty_vec(slice_mt, None) => (slice_mt.mutbl, r),\n+                    ty::ty_vec(_, None) => (mt.mutbl, r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n \n@@ -1143,7 +1135,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatVec(ref before, slice, ref after) => {\n-              let elt_cmt = self.cat_index(pat, cmt, 0);\n+              let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n                   if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,\n                                           |x,y,z| op(x,y,z)));"}, {"sha": "1a884eaea2132276e5021199296231673815c02b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -740,10 +740,6 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                         visitor, &*field.expr, blk_id);\n                 }\n             }\n-            ast::ExprVstore(ref subexpr, _) => {\n-                visitor.region_maps.record_rvalue_scope(subexpr.id, blk_id);\n-                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n-            }\n             ast::ExprVec(ref subexprs) |\n             ast::ExprTup(ref subexprs) => {\n                 for subexpr in subexprs.iter() {"}, {"sha": "ccc4dbb21e019df9609baa663d45e5c5a4f308b7", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -403,7 +403,7 @@ impl<T> VecPerParamSpace<T> {\n         self.content.slice(start, limit)\n     }\n \n-    fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n+    pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n         let (start, limit) = self.limits(space);\n         self.content.mut_slice(start, limit)\n     }"}, {"sha": "28f396c8bf795821c6d1bbc05b90be058826621e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -280,7 +280,7 @@ fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     match *o {\n         lit(lit_expr) => {\n             let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-            let (llval, _) = consts::const_expr(ccx, &*lit_expr, true);\n+            let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n             let lit_datum = immediate_rvalue(llval, lit_ty);\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));\n@@ -289,8 +289,8 @@ fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             return adt::trans_case(bcx, &**repr, disr_val);\n         }\n         range(ref l1, ref l2) => {\n-            let (l1, _) = consts::const_expr(ccx, &**l1, true);\n-            let (l2, _) = consts::const_expr(ccx, &**l2, true);\n+            let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n+            let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n             return range_result(Result::new(bcx, l1), Result::new(bcx, l2));\n         }\n         vec_len(n, vec_len_eq, _) => {\n@@ -692,7 +692,7 @@ fn extract_vec_elems<'a>(\n     let vec_datum = match_datum(bcx, val, pat_id);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let vec_ty = node_id_type(bcx, pat_id);\n-    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n+    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n \n     let mut elems = Vec::from_fn(elem_count, |i| {\n         match slice {\n@@ -863,7 +863,7 @@ fn compare_values<'a>(\n     match ty::get(rhs_t).sty {\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n-            ty::ty_vec(mt, _) => match ty::get(mt.ty).sty {\n+            ty::ty_vec(ty, _) => match ty::get(ty).sty {\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n                     // which calls memcmp()."}, {"sha": "f3f4a88fdee4fa9c32106499091758c91a3d42f1", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -127,8 +127,11 @@ pub enum Repr {\n \n /// For structs, and struct-like parts of anything fancier.\n pub struct Struct {\n+    // If the struct is DST, then the size and alignment do not take into\n+    // account the unsized fields of the struct.\n     pub size: u64,\n     pub align: u64,\n+    pub sized: bool,\n     pub packed: bool,\n     pub fields: Vec<ty::t>\n }\n@@ -265,7 +268,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 mk_struct(cx, ftys.as_slice(), false)\n             }).collect(), dtor);\n         }\n-        _ => cx.sess().bug(\"adt::represent_type called on non-ADT type\")\n+        _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n+                           ty_to_string(cx.tcx(), t)).as_slice())\n     }\n }\n \n@@ -286,6 +290,7 @@ impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n+\n     fn find_ptr(&self) -> Option<PointerField> {\n         use back::abi::{fn_field_code, slice_elt_base, trt_field_box};\n \n@@ -305,8 +310,7 @@ impl Case {\n \n                 // Box<T> could either be a thin or fat pointer depending on T\n                 ty::ty_uniq(t) => match ty::get(t).sty {\n-                    // Box<[T]>/Box<str> might be FatPointer in a post DST world\n-                    ty::ty_vec(_, None) | ty::ty_str => continue,\n+                    ty::ty_vec(_, None) => return Some(FatPointer(i, slice_elt_base)),\n \n                     // Box<Trait> is a pair of pointers: the actual object and a vtable\n                     ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n@@ -326,7 +330,6 @@ impl Case {\n \n                 // Anything else is not a pointer\n                 _ => continue\n-\n             }\n         }\n \n@@ -344,13 +347,28 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n }\n \n fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n-    let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n-    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n-    Struct {\n-        size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n-        align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n-        packed: packed,\n-        fields: Vec::from_slice(tys),\n+    if tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty)) {\n+        let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n+        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+        Struct {\n+            size: machine::llsize_of_alloc(cx, llty_rec),\n+            align: machine::llalign_of_min(cx, llty_rec),\n+            sized: true,\n+            packed: packed,\n+            fields: Vec::from_slice(tys),\n+        }\n+    } else {\n+        // Ignore any dynamically sized fields.\n+        let lltys = tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n+            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n+        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+        Struct {\n+            size: machine::llsize_of_alloc(cx, llty_rec),\n+            align: machine::llalign_of_min(cx, llty_rec),\n+            sized: false,\n+            packed: packed,\n+            fields: Vec::from_slice(tys),\n+        }\n     }\n }\n \n@@ -455,31 +473,38 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n  * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n pub fn type_of(cx: &CrateContext, r: &Repr) -> Type {\n-    generic_type_of(cx, r, None, false)\n+    generic_type_of(cx, r, None, false, false)\n }\n-pub fn sizing_type_of(cx: &CrateContext, r: &Repr) -> Type {\n-    generic_type_of(cx, r, None, true)\n+// Pass dst=true if the type you are passing is a DST. Yes, we could figure\n+// this out, but if you call this on an unsized type without realising it, you\n+// are going to get the wrong type (it will not include the unsized parts of it).\n+pub fn sizing_type_of(cx: &CrateContext, r: &Repr, dst: bool) -> Type {\n+    generic_type_of(cx, r, None, true, dst)\n }\n pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n-    generic_type_of(cx, r, Some(name), false)\n+    generic_type_of(cx, r, Some(name), false, false)\n }\n pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n+            llty.set_struct_body(struct_llfields(cx, st, false, false).as_slice(),\n                                  st.packed)\n     }\n }\n \n-fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n+fn generic_type_of(cx: &CrateContext,\n+                   r: &Repr,\n+                   name: Option<&str>,\n+                   sizing: bool,\n+                   dst: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).as_slice(),\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -531,9 +556,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n     }\n }\n \n-fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n+fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n-        st.fields.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+        st.fields.iter().filter(|&ty| !dst || ty::type_is_sized(cx.tcx(), *ty))\n+            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()\n     }\n@@ -946,7 +972,7 @@ fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n     for &ty in st.fields.iter() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         if !st.packed {\n-            let type_align = machine::llalign_of_min(ccx, llty) as u64;\n+            let type_align = type_of::align_of(ccx, ty) as u64;\n             offset = roundup(offset, type_align);\n         }\n         offsets.push(offset);\n@@ -990,7 +1016,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         offset += machine::llsize_of_alloc(ccx, val_ty(val)) as u64;\n     }\n \n-    assert!(offset <= st.size);\n+    assert!(st.sized && offset <= st.size);\n     if offset != st.size {\n         cfields.push(padding(ccx, st.size - offset));\n     }"}, {"sha": "8968c8cc2599f5d443b7af554c50bc964d693b4a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -65,7 +65,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::intrinsic;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n+use middle::trans::machine::{llsize_of, llsize_of_real};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -364,20 +364,19 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n // a given type, but with a potentially dynamic size.\n \n pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n-                          ptr_ty: ty::t,\n+                          llty_ptr: Type,\n+                          info_ty: ty::t,\n                           size: ValueRef,\n                           align: ValueRef)\n                           -> Result<'a> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n-    let ccx = bcx.ccx();\n \n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n-        require_alloc_fn(bcx, ptr_ty, ExchangeMallocFnLangItem),\n+        require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n         [size, align],\n         None);\n \n-    let llty_ptr = type_of::type_of(ccx, ptr_ty);\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n@@ -395,7 +394,7 @@ pub fn malloc_raw_dyn_managed<'a>(\n     // Grab the TypeRef type of box_ptr_ty.\n     let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n     let llty = type_of(ccx, box_ptr_ty);\n-    let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n+    let llalign = C_uint(ccx, type_of::align_of(ccx, box_ptr_ty) as uint);\n \n     // Allocate space:\n     let drop_glue = glue::get_drop_glue(ccx, t);\n@@ -711,34 +710,53 @@ pub fn iter_structural_ty<'r,\n         return cx;\n     }\n \n+    let (data_ptr, info) = if ty::type_is_sized(cx.tcx(), t) {\n+        (av, None)\n+    } else {\n+        let data = GEPi(cx, av, [0, abi::slice_elt_base]);\n+        let info = GEPi(cx, av, [0, abi::slice_elt_len]);\n+        (Load(cx, data), Some(Load(cx, info)))\n+    };\n+\n     let mut cx = cx;\n     match ty::get(t).sty {\n       ty::ty_struct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n-                  let llfld_a = adt::trans_field_ptr(cx, &*repr, av, discr, i);\n-                  cx = f(cx, llfld_a, field_ty.mt.ty);\n+                  let field_ty = field_ty.mt.ty;\n+                  let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n+\n+                  let val = if ty::type_is_sized(cx.tcx(), field_ty) {\n+                      llfld_a\n+                  } else {\n+                      let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n+                      let scratch = datum::rvalue_scratch_datum(cx, boxed_ty, \"__fat_ptr_iter\");\n+                      Store(cx, llfld_a, GEPi(cx, scratch.val, [0, abi::slice_elt_base]));\n+                      Store(cx, info.unwrap(), GEPi(cx, scratch.val, [0, abi::slice_elt_len]));\n+                      scratch.val\n+                  };\n+                  cx = f(cx, val, field_ty);\n               }\n           })\n       }\n       ty::ty_unboxed_closure(def_id, _) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n           for (i, upvar) in upvars.iter().enumerate() {\n-              let llupvar = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n+              let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n           }\n       }\n       ty::ty_vec(_, Some(n)) => {\n+        let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n-        let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {\n-              let llfld_a = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n+              let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n@@ -782,7 +800,7 @@ pub fn iter_structural_ty<'r,\n                       let variant_cx =\n                           iter_variant(variant_cx,\n                                        &*repr,\n-                                       av,\n+                                       data_ptr,\n                                        &**variant,\n                                        substs,\n                                        |x,y,z| f(x,y,z));\n@@ -956,14 +974,23 @@ pub fn invoke<'a>(\n               llfn: ValueRef,\n               llargs: Vec<ValueRef> ,\n               fn_ty: ty::t,\n-              call_info: Option<NodeInfo>)\n+              call_info: Option<NodeInfo>,\n+              // FIXME(15064) is_lang_item is a horrible hack, please remove it\n+              // at the soonest opportunity.\n+              is_lang_item: bool)\n               -> (ValueRef, &'a Block<'a>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    let attributes = get_fn_llvm_attributes(bcx.ccx(), fn_ty);\n+    // FIXME(15064) Lang item methods may (in the reflect case) not have proper\n+    // types, so doing an attribute lookup will fail.\n+    let attributes = if is_lang_item {\n+        llvm::AttrBuilder::new()\n+    } else {\n+        get_fn_llvm_attributes(bcx.ccx(), fn_ty)\n+    };\n \n     match bcx.opt_node_id {\n         None => {\n@@ -1150,7 +1177,7 @@ pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     if ty::type_is_structural(t) {\n         let llty = type_of::type_of(ccx, t);\n         let llsz = llsize_of(ccx, llty);\n-        let llalign = llalign_of_min(ccx, llty);\n+        let llalign = type_of::align_of(ccx, t);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n     } else {\n         store_ty(bcx, Load(bcx, src), dst, t);\n@@ -1161,20 +1188,20 @@ pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n-    let ccx = cx.ccx();\n-    let llty = type_of::type_of(ccx, t);\n-    memzero(&B(bcx), llptr, llty);\n+    memzero(&B(bcx), llptr, t);\n }\n \n // Always use this function instead of storing a zero constant to the memory\n // in question. If you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n+fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n+    let llty = type_of::type_of(ccx, ty);\n+\n     let intrinsic_key = match ccx.sess().targ_cfg.arch {\n         X86 | Arm | Mips | Mipsel => \"llvm.memset.p0i8.i32\",\n         X86_64 => \"llvm.memset.p0i8.i64\"\n@@ -1183,8 +1210,8 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n     let llzeroval = C_u8(ccx, 0);\n-    let size = machine::llsize_of(ccx, ty);\n-    let align = C_i32(ccx, llalign_of_min(ccx, ty) as i32);\n+    let size = machine::llsize_of(ccx, llty);\n+    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], None);\n }\n@@ -1215,13 +1242,14 @@ pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca_zeroed(cx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+    let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n-            return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n+            return llvm::LLVMGetUndef(llty.ptr_to().to_ref());\n         }\n     }\n-    let p = alloca_no_lifetime(cx, ty, name);\n+    let p = alloca_no_lifetime(cx, llty, name);\n     let b = cx.fcx.ccx.builder();\n     b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n     memzero(&b, p, ty);\n@@ -1640,7 +1668,8 @@ fn copy_unboxed_closure_args_to_allocas<'a>(\n     for j in range(0, args.len()) {\n         let tuple_element_type = untupled_arg_types[j];\n         let tuple_element_datum =\n-            tuple_datum.get_element(tuple_element_type,\n+            tuple_datum.get_element(bcx,\n+                                    tuple_element_type,\n                                     |llval| GEPi(bcx, llval, [0, j]));\n         let tuple_element_datum = tuple_element_datum.to_expr_datum();\n         let tuple_element_datum =\n@@ -2302,9 +2331,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         match ty::get(ret_ty).sty {\n             // `~` pointer return values never alias because ownership\n             // is transferred\n-            ty::ty_uniq(it) if match ty::get(it).sty {\n-                ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n-            } => {}\n+            ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n             ty::ty_uniq(_) => {\n                 attrs.ret(llvm::NoAliasAttribute);\n             }\n@@ -2315,9 +2342,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         match ty::get(ret_ty).sty {\n             // These are not really pointers but pairs, (pointer, len)\n             ty::ty_uniq(it) |\n-            ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n-                ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n-            } => {}\n+            ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n             ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n                 let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n                 attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n@@ -2584,7 +2609,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, inlineable) = consts::const_expr(ccx, &**expr, is_local);\n+                    let (v, inlineable, _) = consts::const_expr(ccx, &**expr, is_local);\n                     ccx.const_values.borrow_mut().insert(id, v);\n                     let mut inlineable = inlineable;\n "}, {"sha": "7566cfbac56c4a6268187649e354150d446f1c9a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -51,6 +51,7 @@ use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n+use util::ppaux::ty_to_string;\n \n use std::gc::Gc;\n use syntax::abi as synabi;\n@@ -853,7 +854,8 @@ pub fn trans_call_inner<'a>(\n                                       llfn,\n                                       llargs,\n                                       callee_ty,\n-                                      call_info);\n+                                      call_info,\n+                                      dest.is_none());\n         bcx = b;\n         llresult = llret;\n \n@@ -968,6 +970,7 @@ fn trans_args_under_call_abi<'a>(\n             let repr_ptr = &*repr;\n             for i in range(0, field_types.len()) {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n+                    bcx,\n                     *field_types.get(i),\n                     |srcval| {\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n@@ -1194,6 +1197,8 @@ pub fn trans_arg_datum<'a>(\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n             debug!(\"casting actual type ({}) to match formal ({})\",\n                    bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n+            debug!(\"Rust types: {}; {}\", ty_to_string(bcx.tcx(), arg_datum_ty),\n+                                         ty_to_string(bcx.tcx(), formal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }"}, {"sha": "05528d2b3d88e60876ff07de8f1d48cbe06e05bc", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -65,14 +65,18 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     use middle::trans::machine::llsize_of_alloc;\n     use middle::trans::type_of::sizing_type_of;\n+\n     let tcx = ccx.tcx();\n     let simple = ty::type_is_scalar(ty) || ty::type_is_boxed(ty) ||\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) || ty::type_is_bot(ty) ||\n         ty::type_is_simd(tcx, ty);\n-    if simple && !ty::type_is_trait(ty) {\n+    if simple && !ty::type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n+    if !ty::type_is_sized(tcx, ty) {\n+        return false;\n+    }\n     match ty::get(ty).sty {\n         ty::ty_bot => true,\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |"}, {"sha": "b3798c9f84dd41ab6d2625f1b0864302e95b33dc", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 97, "deletions": 99, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -11,11 +11,9 @@\n \n use back::abi;\n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True,\n-    False};\n+use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True, False};\n use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n     RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n-\n use metadata::csearch;\n use middle::const_eval;\n use middle::def;\n@@ -98,12 +96,17 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n+// Helper function because we don't have tuple-swizzling.\n+fn first_two<R, S, T>((a, b, _): (R, S, T)) -> (R, S) {\n+    (a, b)\n+}\n+\n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n              es: &[Gc<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, &**e, is_local)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| first_two(const_expr(cx, &**e, is_local))));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs.as_slice(), false)\n@@ -113,13 +116,14 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n-pub fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n+pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n-        llvm::LLVMSetGlobalConstant(gv, True);\n+        llvm::LLVMSetGlobalConstant(gv,\n+                                    if mutbl == ast::MutImmutable {True} else {False});\n         SetLinkage(gv, PrivateLinkage);\n         gv\n     }\n@@ -131,7 +135,6 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n         None => v\n     };\n     unsafe {\n-        assert_eq!(llvm::LLVMIsGlobalConstant(v), True);\n         llvm::LLVMGetInitializer(v)\n     }\n }\n@@ -146,25 +149,25 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(t, explicit) {\n         Some(ref mt) => {\n-            assert!(mt.mutbl != ast::MutMutable);\n-            let dv = match ty::get(t).sty {\n+            match ty::get(t).sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n-                    match ty::get(mt.ty).sty {\n-                        ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {\n-                            cx.sess().bug(\"unexpected unsized type\")\n-                        }\n-                        _ => const_deref_ptr(cx, v),\n+                    if ty::type_is_sized(cx.tcx(), mt.ty) {\n+                        (const_deref_ptr(cx, v), mt.ty)\n+                    } else {\n+                        // Derefing a fat pointer does not change the representation,\n+                        // just the type to ty_open.\n+                        (v, ty::mk_open(cx.tcx(), mt.ty))\n                     }\n                 }\n                 ty::ty_enum(..) | ty::ty_struct(..) => {\n-                    const_deref_newtype(cx, v, t)\n+                    assert!(mt.mutbl != ast::MutMutable);\n+                    (const_deref_newtype(cx, v, t), mt.ty)\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n                                           ty_to_string(cx.tcx(), t)).as_slice())\n                 }\n-            };\n-            (dv, mt.ty)\n+            }\n         }\n         None => {\n             cx.sess().bug(format!(\"can't dereference const of type {}\",\n@@ -193,12 +196,12 @@ pub fn get_const_val(cx: &CrateContext,\n      !cx.non_inlineable_statics.borrow().contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool) {\n+pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool, ty::t) {\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n+    let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n     let opt_adj = cx.tcx.adjustments.borrow().find_copy(&e.id);\n     match opt_adj {\n         None => { }\n@@ -219,51 +222,64 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                 format!(\"unexpected static function: {:?}\",\n                                         store).as_slice())\n                 }\n-                ty::AutoObject(..) => {\n-                    cx.sess()\n-                      .span_unimpl(e.span,\n-                                   \"unimplemented const coercion to trait \\\n-                                    object\");\n-                }\n                 ty::AutoDerefRef(ref adj) => {\n                     let mut ty = ety;\n-                    let mut maybe_ptr = None;\n-                    for _ in range(0, adj.autoderefs) {\n+                    // Save the last autoderef in case we can avoid it.\n+                    for _ in range(0, adj.autoderefs-1) {\n                         let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                        maybe_ptr = Some(llconst);\n                         llconst = dv;\n                         ty = dt;\n                     }\n \n                     match adj.autoref {\n-                        None => { }\n+                        None => {\n+                            let (dv, dt) = const_deref(cx, llconst, ty, false);\n+                            llconst = dv;\n+\n+                            // If we derefed a fat pointer then we will have an\n+                            // open type here. So we need to update the type with\n+                            // the one returned from const_deref.\n+                            ety_adjusted = dt;\n+                        }\n                         Some(ref autoref) => {\n-                            // Don't copy data to do a deref+ref.\n-                            let llptr = match maybe_ptr {\n-                                Some(ptr) => ptr,\n-                                None => {\n-                                    inlineable = false;\n-                                    const_addr_of(cx, llconst)\n-                                }\n-                            };\n                             match *autoref {\n-                                ty::AutoUnsafe(m) |\n-                                ty::AutoPtr(ty::ReStatic, m) => {\n-                                    assert!(m != ast::MutMutable);\n-                                    llconst = llptr;\n+                                ty::AutoUnsafe(_) |\n+                                ty::AutoPtr(ty::ReStatic, _, None) => {\n+                                    // Don't copy data to do a deref+ref\n+                                    // (i.e., skip the last auto-deref).\n+                                    if adj.autoderefs == 0 {\n+                                        inlineable = false;\n+                                        llconst = const_addr_of(cx, llconst, ast::MutImmutable);\n+                                    }\n                                 }\n-                                ty::AutoBorrowVec(ty::ReStatic, m) => {\n-                                    assert!(m != ast::MutMutable);\n-                                    assert_eq!(abi::slice_elt_base, 0);\n-                                    assert_eq!(abi::slice_elt_len, 1);\n+                                ty::AutoPtr(ty::ReStatic, _, Some(box ty::AutoUnsize(..))) => {\n+                                    if adj.autoderefs > 0 {\n+                                        // Seeing as we are deref'ing here and take a reference\n+                                        // again to make the pointer part of the far pointer below,\n+                                        // we just skip the whole thing. We still need the type\n+                                        // though. This works even if we don't need to deref\n+                                        // because of byref semantics. Note that this is not just\n+                                        // an optimisation, it is necessary for mutable vectors to\n+                                        // work properly.\n+                                        let (_, dt) = const_deref(cx, llconst, ty, false);\n+                                        ty = dt;\n+                                    }\n+\n                                     match ty::get(ty).sty {\n-                                        ty::ty_vec(_, Some(len)) => {\n+                                        ty::ty_vec(unit_ty, Some(len)) => {\n+                                            inlineable = false;\n+                                            let llunitty = type_of::type_of(cx, unit_ty);\n+                                            let llptr = const_ptrcast(cx, llconst, llunitty);\n+                                            assert_eq!(abi::slice_elt_base, 0);\n+                                            assert_eq!(abi::slice_elt_len, 1);\n                                             llconst = C_struct(cx, [\n                                                 llptr,\n                                                 C_uint(cx, len)\n                                             ], false);\n                                         }\n-                                        _ => {}\n+                                        _ => cx.sess().span_bug(e.span,\n+                                            format!(\"unimplemented type in const unsize: {}\",\n+                                                    ty_to_string(cx.tcx(), ty)).as_slice())\n                                     }\n                                 }\n                                 _ => {\n@@ -294,15 +310,15 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n                          csize, tsize).as_slice());\n     }\n-    (llconst, inlineable)\n+    (llconst, inlineable, ety_adjusted)\n }\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n     let map_list = |exprs: &[Gc<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e, is_local))\n+        exprs.iter().map(|e| first_two(const_expr(cx, &**e, is_local)))\n              .fold((Vec::new(), true),\n                    |(l, all_inlineable), (val, inlineable)| {\n                 (l.append_one(val), all_inlineable && inlineable)\n@@ -315,8 +331,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (consts::const_lit(cx, e, (**lit).clone()), true)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n-            let (te1, _) = const_expr(cx, &**e1, is_local);\n-            let (te2, _) = const_expr(cx, &**e2, is_local);\n+            let (te1, _, _) = const_expr(cx, &**e1, is_local);\n+            let (te2, _, _) = const_expr(cx, &**e2, is_local);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n@@ -397,7 +413,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }, true)\n           },\n           ast::ExprUnary(u, ref e) => {\n-            let (te, _) = const_expr(cx, &**e, is_local);\n+            let (te, _, _) = const_expr(cx, &**e, is_local);\n             let ty = ty::expr_ty(cx.tcx(), &**e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n@@ -413,18 +429,16 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(ref base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n+              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n               let brepr = adt::represent_type(cx, bt);\n-              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n-              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n+              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -433,16 +447,29 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               };\n               let (arr, len) = match ty::get(bt).sty {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                  ty::ty_open(ty) => match ty::get(ty).sty {\n                       ty::ty_vec(_, None) | ty::ty_str => {\n                           let e1 = const_get_elt(cx, bv, [0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n-                                              \"index-expr base must be a vector or string type\")\n+                                              format!(\"index-expr base must be a vector \\\n+                                                       or string type, found {}\",\n+                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n+                  },\n+                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                      ty::ty_vec(_, Some(u)) => {\n+                          (const_deref_ptr(cx, bv), C_uint(cx, u))\n+                      },\n+                      _ => cx.sess().span_bug(base.span,\n+                                              format!(\"index-expr base must be a vector \\\n+                                                       or string type, found {}\",\n+                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n                   },\n                   _ => cx.sess().span_bug(base.span,\n-                                          \"index-expr base must be a vector or string type\")\n+                                          format!(\"index-expr base must be a vector \\\n+                                                   or string type, found {}\",\n+                                                  ty_to_string(cx.tcx(), bt)).as_slice())\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -467,10 +494,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n           ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let basety = ty::expr_ty(cx.tcx(), &**base);\n-            let (v, inlineable) = const_expr(cx, &**base, is_local);\n-            return (match (expr::cast_type_kind(basety),\n-                           expr::cast_type_kind(ety)) {\n+            let (v, inlineable, basety) = const_expr(cx, &**base, is_local);\n+            return (match (expr::cast_type_kind(cx.tcx(), basety),\n+                           expr::cast_type_kind(cx.tcx(), ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n@@ -494,7 +520,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, &*repr, v);\n                 let iv = C_integral(cx.int_type, discr, false);\n-                let ety_cast = expr::cast_type_kind(ety);\n+                let ety_cast = expr::cast_type_kind(cx.tcx(), ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n                         let s = ty::type_is_signed(ety) as Bool;\n@@ -516,9 +542,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n             }, inlineable)\n           }\n-          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n-              let (e, _) = const_expr(cx, &**sub, is_local);\n-              (const_addr_of(cx, e), false)\n+          ast::ExprAddrOf(mutbl, ref sub) => {\n+              let (e, _, _) = const_expr(cx, &**sub, is_local);\n+              (const_addr_of(cx, e, mutbl), false)\n           }\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -540,10 +566,10 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr, is_local),\n+                          Some(ref f) => first_two(const_expr(cx, &*f.expr, is_local)),\n                           None => {\n                               match base_val {\n-                                Some((bv, inlineable)) => {\n+                                Some((bv, inlineable, _)) => {\n                                     (adt::const_get_field(cx, &*repr, bv, discr, ix),\n                                      inlineable)\n                                 }\n@@ -563,34 +589,6 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                                is_local);\n             (v, inlineable)\n           }\n-          ast::ExprVstore(ref sub, store @ ast::ExprVstoreSlice) |\n-          ast::ExprVstore(ref sub, store @ ast::ExprVstoreMutSlice) => {\n-            match sub.node {\n-              ast::ExprLit(ref lit) => {\n-                match lit.node {\n-                    ast::LitStr(..) => { const_expr(cx, &**sub, is_local) }\n-                    _ => { cx.sess().span_bug(e.span, \"bad const-slice lit\") }\n-                }\n-              }\n-              ast::ExprVec(ref es) => {\n-                let (cv, llunitty, _) = const_vec(cx,\n-                                                  e,\n-                                                  es.as_slice(),\n-                                                  is_local);\n-                let llty = val_ty(cv);\n-                let gv = \"const\".with_c_str(|name| {\n-                    llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n-                });\n-                llvm::LLVMSetInitializer(gv, cv);\n-                llvm::LLVMSetGlobalConstant(gv,\n-                      if store == ast::ExprVstoreMutSlice { False } else { True });\n-                SetLinkage(gv, PrivateLinkage);\n-                let p = const_ptrcast(cx, gv, llunitty);\n-                (C_struct(cx, [p, C_uint(cx, es.len())], false), false)\n-              }\n-              _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n-            }\n-          }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n             let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n@@ -669,10 +667,10 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => { const_expr(cx, &**e, is_local) }\n+          ast::ExprParen(ref e) => first_two(const_expr(cx, &**e, is_local)),\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr, is_local),\n+                Some(ref expr) => first_two(const_expr(cx, &**expr, is_local)),\n                 None => (C_nil(cx), true)\n             }\n           }"}, {"sha": "9ec52341348170f3a6e5cc5f07c3744444bea46e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -497,7 +497,7 @@ pub fn trans_fail<'a>(\n     let filename = C_str_slice(ccx, filename);\n     let line = C_int(ccx, loc.line as int);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const);\n+    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -525,7 +525,7 @@ pub fn trans_fail_bounds_check<'a>(\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_int(ccx, loc.line as int);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::const_addr_of(ccx, file_line_const);\n+    let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(sp), \"\", FailBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "2882eaf10be2f0977f6ceb45cdc6ccf4186dec0e", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -15,6 +15,7 @@\n \n use llvm::ValueRef;\n use middle::trans::base::*;\n+use middle::trans::build::Load;\n use middle::trans::common::*;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n@@ -119,10 +120,10 @@ pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n      * does not dominate the end of `scope`.\n      */\n \n-    let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = if zero {\n-        alloca_zeroed(bcx, llty, name)\n+        alloca_zeroed(bcx, ty, name)\n     } else {\n+        let llty = type_of::type_of(bcx.ccx(), ty);\n         alloca(bcx, llty, name)\n     };\n \n@@ -450,6 +451,8 @@ impl Datum<Expr> {\n                                name: &str,\n                                expr_id: ast::NodeId)\n                                -> DatumBlock<'a, Lvalue> {\n+        assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n+                \"Trying to convert unsized value to lval\");\n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n             |r| {\n@@ -504,12 +507,28 @@ impl Datum<Lvalue> {\n         self.val\n     }\n \n-    pub fn get_element(&self,\n-                       ty: ty::t,\n-                       gep: |ValueRef| -> ValueRef)\n-                       -> Datum<Lvalue> {\n+    // Extracts a component of a compound data structure (e.g., a field from a\n+    // struct). Note that if self is an opened, unsized type then the returned\n+    // datum may also be unsized _without the size information_. It is the\n+    // callers responsibility to package the result in some way to make a valid\n+    // datum in that case (e.g., by making a fat pointer or opened pair).\n+    pub fn get_element<'a>(&self,\n+                           bcx: &'a Block<'a>,\n+                           ty: ty::t,\n+                           gep: |ValueRef| -> ValueRef)\n+                           -> Datum<Lvalue> {\n+        let val = match ty::get(self.ty).sty {\n+            _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n+            ty::ty_open(_) => {\n+                let base = Load(bcx, expr::get_dataptr(bcx, self.val));\n+                gep(base)\n+            }\n+            _ => bcx.tcx().sess.bug(\n+                format!(\"Unexpected unsized type in get_element: {}\",\n+                        bcx.ty_to_string(self.ty)).as_slice())\n+        };\n         Datum {\n-            val: gep(self.val),\n+            val: val,\n             kind: Lvalue,\n             ty: ty,\n         }"}, {"sha": "566f71220b05f50613d7bcc77dd931fd2501dbb7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 41, "deletions": 153, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -56,10 +56,11 @@ This file consists of three conceptual sections:\n ## Recursive Types\n \n Some kinds of types, such as structs and enums can be recursive. That means that\n-the type definition of some type X refers to some other type which in turn (transitively)\n-refers to X. This introduces cycles into the type referral graph. A naive algorithm doing\n-an on-demand, depth-first traversal of this graph when describing types, can get trapped\n-in an endless loop when it reaches such a cycle.\n+the type definition of some type X refers to some other type which in turn\n+(transitively) refers to X. This introduces cycles into the type referral graph.\n+A naive algorithm doing an on-demand, depth-first traversal of this graph when\n+describing types, can get trapped in an endless loop when it reaches such a\n+cycle.\n \n For example, the following simple type for a singly-linked list...\n \n@@ -402,7 +403,7 @@ impl TypeMap {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n-            ty::ty_vec(ty::mt { ty: inner_type, .. }, optional_length) => {\n+            ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n                         unique_type_id.push_str(format!(\"[{}]\", len).as_slice());\n@@ -595,18 +596,6 @@ impl TypeMap {\n         UniqueTypeId(interner_key)\n     }\n \n-    fn get_unique_type_id_of_heap_vec_box(&mut self,\n-                                          cx: &CrateContext,\n-                                          element_type: ty::t)\n-                                       -> UniqueTypeId {\n-        let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n-        let heap_vec_box_type_id = format!(\"{{HEAP_VEC_BOX<{}>}}\",\n-                                           self.get_unique_type_id_as_string(element_type_id)\n-                                               .as_slice());\n-        let interner_key = self.unique_id_interner.intern(Rc::new(heap_vec_box_type_id));\n-        UniqueTypeId(interner_key)\n-    }\n-\n     fn get_unique_type_id_of_gc_box(&mut self,\n                                     cx: &CrateContext,\n                                     element_type: ty::t)\n@@ -2718,81 +2707,6 @@ fn fixed_vec_metadata(cx: &CrateContext,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn heap_vec_metadata(cx: &CrateContext,\n-                     vec_pointer_type: ty::t,\n-                     element_type: ty::t,\n-                     unique_type_id: UniqueTypeId,\n-                     span: Span)\n-                  -> MetadataCreationResult {\n-    let element_type_metadata = type_metadata(cx, element_type, span);\n-    let element_llvm_type = type_of::type_of(cx, element_type);\n-    let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n-\n-    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n-\n-    let vecbox_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_pointer_type_name = compute_debuginfo_type_name(cx,\n-                                                            vec_pointer_type,\n-                                                            true);\n-    let vec_pointer_type_name = vec_pointer_type_name.as_slice();\n-\n-    let member_llvm_types = vecbox_llvm_type.field_types();\n-\n-    let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n-    let array_type_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(\n-            DIB(cx),\n-            bytes_to_bits(element_size),\n-            bytes_to_bits(element_align),\n-            element_type_metadata,\n-            create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n-    };\n-\n-    let member_descriptions = [\n-        MemberDescription {\n-            name: \"fill\".to_string(),\n-            llvm_type: *member_llvm_types.get(0),\n-            type_metadata: int_type_metadata,\n-            offset: ComputedMemberOffset,\n-        },\n-        MemberDescription {\n-            name: \"alloc\".to_string(),\n-            llvm_type: *member_llvm_types.get(1),\n-            type_metadata: int_type_metadata,\n-            offset: ComputedMemberOffset,\n-        },\n-        MemberDescription {\n-            name: \"elements\".to_string(),\n-            llvm_type: *member_llvm_types.get(2),\n-            type_metadata: array_type_metadata,\n-            offset: ComputedMemberOffset,\n-        }\n-    ];\n-\n-    assert!(member_descriptions.len() == member_llvm_types.len());\n-\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n-\n-    let vec_box_unique_id = debug_context(cx).type_map\n-                                             .borrow_mut()\n-                                             .get_unique_type_id_of_heap_vec_box(cx,\n-                                                                                 element_type);\n-\n-    let vecbox_metadata = composite_type_metadata(cx,\n-                                                  vecbox_llvm_type,\n-                                                  vec_pointer_type_name,\n-                                                  vec_box_unique_id,\n-                                                  member_descriptions,\n-                                                  UNKNOWN_SCOPE_METADATA,\n-                                                  file_metadata,\n-                                                  span);\n-\n-    MetadataCreationResult::new(pointer_type_metadata(cx,\n-                                                      vec_pointer_type,\n-                                                      vecbox_metadata), false)\n-}\n-\n fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n@@ -2885,47 +2799,42 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         false);\n }\n \n+// FIXME(1563) This is all a bit of a hack because 'trait pointer' is an ill-\n+// defined concept. For the case of an actual trait pointer (i.e., Box<Trait>,\n+// &Trait), trait_object_type should be the whole thing (e.g, Box<Trait>) and\n+// trait_type should be the actual trait (e.g., Trait). Where the trait is part\n+// of a DST struct, there is no trait_object_type and the results of this\n+// function will be a little bit weird.\n fn trait_pointer_metadata(cx: &CrateContext,\n-                          // trait_pointer_type must be the type of the fat\n-                          // pointer to the concrete trait object\n-                          trait_pointer_type: ty::t,\n+                          trait_type: ty::t,\n+                          trait_object_type: Option<ty::t>,\n                           unique_type_id: UniqueTypeId)\n                        -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n-    let trait_object_type = match ty::get(trait_pointer_type).sty {\n-        ty::ty_uniq(pointee_type) => pointee_type,\n-        ty::ty_rptr(_, ty::mt { ty, .. }) => ty,\n-        _ => {\n-            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_pointer_type);\n-            cx.sess().bug(format!(\"debuginfo: Unexpected trait-pointer type in \\\n-                                   trait_pointer_metadata(): {}\",\n-                                   pp_type_name.as_slice()).as_slice());\n-        }\n-    };\n-\n-    let def_id = match ty::get(trait_object_type).sty {\n+    let def_id = match ty::get(trait_type).sty {\n         ty::ty_trait(box ty::TyTrait { def_id, .. }) => def_id,\n         _ => {\n-            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_object_type);\n+            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n                                    pp_type_name.as_slice()).as_slice());\n         }\n     };\n \n-    let trait_pointer_type_name =\n-        compute_debuginfo_type_name(cx, trait_pointer_type, false);\n+    let trait_object_type = trait_object_type.unwrap_or(trait_type);\n+    let trait_type_name =\n+        compute_debuginfo_type_name(cx, trait_object_type, false);\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let trait_pointer_llvm_type = type_of::type_of(cx, trait_pointer_type);\n+    let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n \n     composite_type_metadata(cx,\n-                            trait_pointer_llvm_type,\n-                            trait_pointer_type_name.as_slice(),\n+                            trait_llvm_type,\n+                            trait_type_name.as_slice(),\n                             unique_type_id,\n                             [],\n                             containing_scope,\n@@ -2989,54 +2898,32 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_box(pointee_type) => {\n             at_box_metadata(cx, t, pointee_type, unique_type_id)\n         }\n-        ty::ty_vec(ref mt, Some(len)) => {\n-            fixed_vec_metadata(cx, unique_type_id, mt.ty, len, usage_site_span)\n+        ty::ty_vec(typ, Some(len)) => {\n+            fixed_vec_metadata(cx, unique_type_id, typ, len, usage_site_span)\n         }\n-        ty::ty_uniq(pointee_type) => {\n-            match ty::get(pointee_type).sty {\n-                ty::ty_vec(ref mt, None) => {\n-                    heap_vec_metadata(cx, pointee_type, mt.ty, unique_type_id, usage_site_span)\n-                }\n-                ty::ty_str => {\n-                    let i8_t = ty::mk_i8();\n-                    heap_vec_metadata(cx, pointee_type, i8_t, unique_type_id, usage_site_span)\n-                }\n-                ty::ty_trait(..) => {\n-                    MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, unique_type_id),\n-                        false)\n-                }\n-                _ => {\n-                    let pointee_metadata = type_metadata(cx,\n-                                                         pointee_type,\n-                                                         usage_site_span);\n-                    match debug_context(cx).type_map\n-                                           .borrow()\n-                                           .find_metadata_for_unique_id(unique_type_id) {\n-                        Some(metadata) => return metadata,\n-                        None => { /* proceed normally */ }\n-                    };\n-\n-                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n-                                                false)\n-                }\n-            }\n+        // FIXME Can we do better than this for unsized vec/str fields?\n+        ty::ty_vec(typ, None) => fixed_vec_metadata(cx, unique_type_id, typ, 0, usage_site_span),\n+        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, ty::mk_i8(), 0, usage_site_span),\n+        ty::ty_trait(..) => {\n+            MetadataCreationResult::new(\n+                        trait_pointer_metadata(cx, t, None, unique_type_id),\n+            false)\n         }\n-        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-            match ty::get(mt.ty).sty {\n-                ty::ty_vec(ref mt, None) => {\n-                    vec_slice_metadata(cx, t, mt.ty, unique_type_id, usage_site_span)\n+        ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+            match ty::get(ty).sty {\n+                ty::ty_vec(typ, None) => {\n+                    vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n                     vec_slice_metadata(cx, t, ty::mk_u8(), unique_type_id, usage_site_span)\n                 }\n                 ty::ty_trait(..) => {\n                     MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, unique_type_id),\n+                        trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                         false)\n                 }\n                 _ => {\n-                    let pointee = type_metadata(cx, mt.ty, usage_site_span);\n+                    let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n \n                     match debug_context(cx).type_map\n                                            .borrow()\n@@ -3045,7 +2932,8 @@ fn type_metadata(cx: &CrateContext,\n                         None => { /* proceed normally */ }\n                     };\n \n-                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee), false)\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n+                                                false)\n                 }\n             }\n         }\n@@ -3544,7 +3432,6 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprAgain(_) |\n             ast::ExprPath(_)  => {}\n \n-            ast::ExprVstore(ref sub_exp, _)   |\n             ast::ExprCast(ref sub_exp, _)     |\n             ast::ExprAddrOf(_, ref sub_exp)  |\n             ast::ExprField(ref sub_exp, _, _) |\n@@ -3820,7 +3707,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n-        ty::ty_vec(ty::mt { ty: inner_type, .. }, optional_length) => {\n+        ty::ty_vec(inner_type, optional_length) => {\n             output.push_char('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n \n@@ -3933,6 +3820,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n         }\n         ty::ty_err      |\n         ty::ty_infer(_) |\n+        ty::ty_open(_) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).as_slice());"}, {"sha": "c49bb7f4e6b9d0197f9a9a3fcd7b9f7c5be07c9a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 394, "deletions": 136, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -40,6 +40,7 @@ use metadata::csearch;\n use middle::def;\n use middle::lang_items::MallocFnLangItem;\n use middle::mem_categorization::Typer;\n+use middle::subst;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -62,15 +63,15 @@ use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n-use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef};\n+use middle::ty::{AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AutoPtr};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n-use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n use syntax::ast;\n@@ -160,6 +161,14 @@ pub fn trans<'a>(bcx: &'a Block<'a>,\n     return DatumBlock::new(bcx, datum);\n }\n \n+pub fn get_len(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+    GEPi(bcx, fat_ptr, [0u, abi::slice_elt_len])\n+}\n+\n+pub fn get_dataptr(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+    GEPi(bcx, fat_ptr, [0u, abi::slice_elt_base])\n+}\n+\n fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                          expr: &ast::Expr,\n                          datum: Datum<Expr>)\n@@ -184,71 +193,289 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n         AutoDerefRef(ref adj) => {\n-            if adj.autoderefs > 0 {\n+            let (autoderefs, use_autoref) = match adj.autoref {\n+                // Extracting a value from a box counts as a deref, but if we are\n+                // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing\n+                // a deref (and wouldn't if we could treat Box like a normal struct).\n+                Some(ty::AutoUnsizeUniq(..)) => (adj.autoderefs - 1, true),\n+                // We are a bit paranoid about adjustments and thus might have a re-\n+                // borrow here which merely derefs and then refs again (it might have\n+                // a different region or mutability, but we don't care here. It might\n+                // also be just in case we need to unsize. But if there are no nested\n+                // adjustments then it should be a no-op).\n+                Some(ty::AutoPtr(_, _, None)) if adj.autoderefs == 1 => {\n+                    match ty::get(datum.ty).sty {\n+                        // Don't skip a conversion from Box<T> to &T, etc.\n+                        ty::ty_rptr(..) => {\n+                            let method_call = MethodCall::autoderef(expr.id, adj.autoderefs-1);\n+                            let method = bcx.tcx().method_map.borrow().find(&method_call).is_some();\n+                            if method {\n+                                // Don't skip an overloaded deref.\n+                                (adj.autoderefs, true)\n+                            } else {\n+                                (adj.autoderefs - 1, false)\n+                            }\n+                        }\n+                        _ => (adj.autoderefs, true),\n+                    }\n+                }\n+                _ => (adj.autoderefs, true)\n+            };\n+\n+            if autoderefs > 0 {\n+                // Schedule cleanup.\n+                let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"auto_deref\", expr.id));\n                 datum = unpack_datum!(\n-                    bcx, deref_multiple(bcx, expr, datum, adj.autoderefs));\n+                    bcx, deref_multiple(bcx, expr, lval.to_expr_datum(), autoderefs));\n             }\n \n-            datum = match adj.autoref {\n-                None => {\n-                    datum\n-                }\n-                Some(AutoUnsafe(..)) | // region + unsafe ptrs have same repr\n-                Some(AutoPtr(..)) => {\n-                    unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n-                }\n-                Some(AutoBorrowVec(..)) => {\n-                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n-                }\n-                Some(AutoBorrowVecRef(..)) => {\n-                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n+            // (You might think there is a more elegant way to do this than a\n+            // use_autoref bool, but then you remember that the borrow checker exists).\n+            match (use_autoref, &adj.autoref) {\n+                (true, &Some(ref a)) => {\n+                    datum = unpack_datum!(bcx, apply_autoref(a,\n+                                                             bcx,\n+                                                             expr,\n+                                                             datum));\n                 }\n-                Some(AutoBorrowObj(..)) => {\n-                    unpack_datum!(bcx, auto_borrow_obj(bcx, expr, datum))\n+                _ => {}\n+            }\n+        }\n+    }\n+    debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n+    return DatumBlock::new(bcx, datum);\n+\n+    fn apply_autoref<'a>(autoref: &ty::AutoRef,\n+                         bcx: &'a Block<'a>,\n+                         expr: &ast::Expr,\n+                         datum: Datum<Expr>)\n+                         -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+        let mut datum = datum;\n+\n+        let datum = match autoref {\n+            &AutoUnsafe(..) => {\n+                debug!(\"  AutoUnsafe\");\n+                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n+            }\n+            &AutoPtr(_, _, ref a) => {\n+                debug!(\"  AutoPtr\");\n+                match a {\n+                    &Some(box ref a) => datum = unpack_datum!(bcx,\n+                                                              apply_autoref(a, bcx, expr, datum)),\n+                    _ => {}\n                 }\n-            };\n+                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n+            }\n+            &ty::AutoUnsize(ref k) => {\n+                debug!(\"  AutoUnsize\");\n+                unpack_datum!(bcx, unsize_expr(bcx, expr, datum, k))\n+            }\n+\n+            &ty::AutoUnsizeUniq(ty::UnsizeLength(len)) => {\n+                debug!(\"  AutoUnsizeUniq(UnsizeLength)\");\n+                unpack_datum!(bcx, unsize_unique_vec(bcx, expr, datum, len))\n+            }\n+            &ty::AutoUnsizeUniq(ref k) => {\n+                debug!(\"  AutoUnsizeUniq\");\n+                unpack_datum!(bcx, unsize_unique_expr(bcx, expr, datum, k))\n+            }\n+        };\n+\n+        DatumBlock::new(bcx, datum)\n+    }\n+\n+    fn ref_ptr<'a>(bcx: &'a Block<'a>,\n+                   expr: &ast::Expr,\n+                   datum: Datum<Expr>)\n+                   -> DatumBlock<'a, Expr> {\n+        if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n+            debug!(\"Taking address of unsized type {}\",\n+                   bcx.ty_to_string(datum.ty));\n+            ref_fat_ptr(bcx, expr, datum)\n+        } else {\n+            debug!(\"Taking address of sized type {}\",\n+                   bcx.ty_to_string(datum.ty));\n+            auto_ref(bcx, datum, expr)\n         }\n-        AutoObject(..) => {\n-            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n-            let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n-            bcx = meth::trans_trait_cast(\n-                bcx, datum, expr.id, SaveIn(scratch.val));\n-            datum = scratch.to_expr_datum();\n+    }\n+\n+    // Retrieve the information we are losing (making dynamic) in an unsizing\n+    // adjustment.\n+    // When making a dtor, we need to do different things depending on the\n+    // ownership of the object.. mk_ty is a function for turning unsized_type\n+    // into a type to be destructed. If we want to end up with a Box pointer,\n+    // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n+    // borrowed reference then it should be T -> &T.\n+    fn unsized_info<'a>(bcx: &'a Block<'a>,\n+                        kind: &ty::UnsizeKind,\n+                        id: ast::NodeId,\n+                        unsized_ty: ty::t,\n+                        mk_ty: |ty::t| -> ty::t) -> ValueRef {\n+        match kind {\n+            &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n+            &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n+                ty::ty_struct(_, ref substs) => {\n+                    let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                    // The dtor for a field treats it like a value, so mk_ty\n+                    // should just be the identity function.\n+                    unsized_info(bcx, k, id, ty_substs[tp_index], |t| t)\n+                }\n+                _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n+                                          bcx.ty_to_string(unsized_ty)).as_slice())\n+            },\n+            &ty::UnsizeVtable(..) =>\n+                PointerCast(bcx,\n+                            meth::vtable_ptr(bcx, id, mk_ty(unsized_ty)),\n+                            Type::vtable_ptr(bcx.ccx()))\n         }\n     }\n-    debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n-    return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_slice<'a>(\n-                  bcx: &'a Block<'a>,\n-                  expr: &ast::Expr,\n-                  datum: Datum<Expr>)\n-                  -> DatumBlock<'a, Expr> {\n-        // This is not the most efficient thing possible; since slices\n-        // are two words it'd be better if this were compiled in\n-        // 'dest' mode, but I can't find a nice way to structure the\n-        // code and keep it DRY that accommodates that use case at the\n-        // moment.\n+    fn unsize_expr<'a>(bcx: &'a Block<'a>,\n+                       expr: &ast::Expr,\n+                       datum: Datum<Expr>,\n+                       k: &ty::UnsizeKind)\n+                       -> DatumBlock<'a, Expr> {\n+        let tcx = bcx.tcx();\n+        let datum_ty = datum.ty;\n+        let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n+        let dest_ty = ty::mk_open(tcx, unsized_ty);\n+        // Closures for extracting and manipulating the data and payload parts of\n+        // the fat pointer.\n+        let base = match k {\n+            &ty::UnsizeStruct(..) =>\n+                |bcx, val| PointerCast(bcx,\n+                                       val,\n+                                       type_of::type_of(bcx.ccx(), unsized_ty).ptr_to()),\n+            &ty::UnsizeLength(..) =>\n+                |bcx, val| GEPi(bcx, val, [0u, 0u]),\n+            &ty::UnsizeVtable(..) =>\n+                |_bcx, val| PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n+        };\n+        let info = |bcx, _val| unsized_info(bcx,\n+                                            k,\n+                                            expr.id,\n+                                            ty::deref_or_dont(datum_ty),\n+                                            |t| ty::mk_rptr(tcx,\n+                                                            ty::ReStatic,\n+                                                            ty::mt{\n+                                                                ty: t,\n+                                                                mutbl: ast::MutImmutable\n+                                                            }));\n+        into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n+    }\n \n+    fn ref_fat_ptr<'a>(bcx: &'a Block<'a>,\n+                       expr: &ast::Expr,\n+                       datum: Datum<Expr>)\n+                       -> DatumBlock<'a, Expr> {\n+        let tcx = bcx.tcx();\n+        let dest_ty = ty::close_type(tcx, datum.ty);\n+        let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n+        let len = |bcx, val| Load(bcx, get_len(bcx, val));\n+        into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n+    }\n+\n+    fn into_fat_ptr<'a>(bcx: &'a Block<'a>,\n+                        expr: &ast::Expr,\n+                        datum: Datum<Expr>,\n+                        dest_ty: ty::t,\n+                        base: |&'a Block<'a>, ValueRef| -> ValueRef,\n+                        info: |&'a Block<'a>, ValueRef| -> ValueRef)\n+                        -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+\n+        // Arrange cleanup\n+        let lval = unpack_datum!(bcx,\n+                                 datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n+        let base = base(bcx, lval.val);\n+        let info = info(bcx, lval.val);\n+\n+        let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n+        Store(bcx, base, get_dataptr(bcx, scratch.val));\n+        Store(bcx, info, get_len(bcx, scratch.val));\n+\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n+    }\n+\n+    fn unsize_unique_vec<'a>(bcx: &'a Block<'a>,\n+                             expr: &ast::Expr,\n+                             datum: Datum<Expr>,\n+                             len: uint)\n+                             -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+        let tcx = bcx.tcx();\n+\n+        let datum_ty = datum.ty;\n+        // Arrange cleanup\n+        let lval = unpack_datum!(bcx,\n+                                 datum.to_lvalue_datum(bcx, \"unsize_unique_vec\", expr.id));\n+\n+        let ll_len = C_uint(bcx.ccx(), len);\n+        let unit_ty = ty::sequence_element_type(tcx, ty::type_content(datum_ty));\n+        let vec_ty = ty::mk_uniq(tcx, ty::mk_vec(tcx, unit_ty, None));\n+        let scratch = rvalue_scratch_datum(bcx, vec_ty, \"__unsize_unique\");\n+\n+        if len == 0 {\n+            Store(bcx,\n+                  C_null(type_of::type_of(bcx.ccx(), unit_ty).ptr_to()),\n+                  get_dataptr(bcx, scratch.val));\n+        } else {\n+            // Box<[(), ..n]> will not allocate, but ~[()] expects an\n+            // allocation of n bytes, so we must allocate here (yuck).\n+            let llty = type_of::type_of(bcx.ccx(), unit_ty);\n+            if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n+                let ptr_unit_ty = type_of::type_of(bcx.ccx(), unit_ty).ptr_to();\n+                let align = C_uint(bcx.ccx(), 8);\n+                let alloc_result = malloc_raw_dyn(bcx, ptr_unit_ty, vec_ty, ll_len, align);\n+                bcx = alloc_result.bcx;\n+                let base = get_dataptr(bcx, scratch.val);\n+                Store(bcx, alloc_result.val, base);\n+            } else {\n+                let base = get_dataptr(bcx, scratch.val);\n+                let base = PointerCast(bcx,\n+                                       base,\n+                                       type_of::type_of(bcx.ccx(), datum_ty).ptr_to());\n+                bcx = lval.store_to(bcx, base);\n+            }\n+        }\n+\n+        Store(bcx, ll_len, get_len(bcx, scratch.val));\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n+    }\n+\n+    fn unsize_unique_expr<'a>(bcx: &'a Block<'a>,\n+                              expr: &ast::Expr,\n+                              datum: Datum<Expr>,\n+                              k: &ty::UnsizeKind)\n+                              -> DatumBlock<'a, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n-        let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n \n-        // Arrange cleanup, if not already done. This is needed in\n-        // case we are auto-slicing an owned vector or some such.\n-        let datum = unpack_datum!(\n-            bcx, datum.to_lvalue_datum(bcx, \"auto_slice\", expr.id));\n+        let datum_ty = datum.ty;\n+        let unboxed_ty = match ty::get(datum_ty).sty {\n+            ty::ty_uniq(t) => t,\n+            _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n+                                        bcx.ty_to_string(datum_ty)).as_slice())\n+        };\n+        let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n+\n+        let lval = unpack_datum!(bcx,\n+                                 datum.to_lvalue_datum(bcx, \"unsize_unique_expr\", expr.id));\n+\n+        let scratch = rvalue_scratch_datum(bcx, result_ty, \"__uniq_fat_ptr\");\n+        let llbox_ty = type_of::type_of(bcx.ccx(), datum_ty);\n+        let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n+        bcx = lval.store_to(bcx, base);\n \n-        let (base, len) = datum.get_vec_base_and_len(bcx);\n+        let info = unsized_info(bcx, k, expr.id, unboxed_ty, |t| ty::mk_uniq(tcx, t));\n+        Store(bcx, info, get_len(bcx, scratch.val));\n \n-        // this type may have a different region/mutability than the\n-        // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_slice(tcx, ty::ReStatic,\n-                                    ty::mt { ty: unit_ty, mutbl: ast::MutImmutable });\n+        let scratch = unpack_datum!(bcx,\n+                                    scratch.to_expr_datum().to_lvalue_datum(bcx,\n+                                                                            \"fresh_uniq_fat_ptr\",\n+                                                                            expr.id));\n \n-        let scratch = rvalue_scratch_datum(bcx, slice_ty, \"__adjust\");\n-        Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-        Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n@@ -267,32 +494,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let def = ty::resolve_expr(bcx.tcx(), expr);\n         closure::make_closure_from_bare_fn(bcx, closure_ty, def, fn_ptr)\n     }\n-\n-    fn auto_slice_and_ref<'a>(\n-                          bcx: &'a Block<'a>,\n-                          expr: &ast::Expr,\n-                          datum: Datum<Expr>)\n-                          -> DatumBlock<'a, Expr> {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n-        auto_ref(bcx, datum, expr)\n-    }\n-\n-    fn auto_borrow_obj<'a>(mut bcx: &'a Block<'a>,\n-                           expr: &ast::Expr,\n-                           source_datum: Datum<Expr>)\n-                           -> DatumBlock<'a, Expr> {\n-        let tcx = bcx.tcx();\n-        let target_obj_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"auto_borrow_obj(target={})\", target_obj_ty.repr(tcx));\n-\n-        // Arrange cleanup, if not already done. This is needed in\n-        // case we are auto-borrowing a Box<Trait> to &Trait\n-        let datum = unpack_datum!(\n-            bcx, source_datum.to_lvalue_datum(bcx, \"autoborrowobj\", expr.id));\n-        let mut datum = datum.to_expr_datum();\n-        datum.ty = target_obj_ty;\n-        DatumBlock::new(bcx, datum)\n-    }\n }\n \n pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n@@ -398,27 +599,39 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprIndex(ref base, ref idx) => {\n             trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n-        ast::ExprVstore(ref contents, ast::ExprVstoreUniq) => {\n-            fcx.push_ast_cleanup_scope(contents.id);\n-            let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_vstore(bcx, expr, &**contents));\n-            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n-            DatumBlock::new(bcx, datum)\n-        }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, &**contents);\n             match ty::get(box_ty).sty {\n                 ty::ty_uniq(..) => {\n-                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                    let is_vec = match contents.node {\n+                        ast::ExprRepeat(..) | ast::ExprVec(..) => true,\n+                        ast::ExprLit(lit) => match lit.node {\n+                            ast::LitStr(..) => true,\n+                            _ => false\n+                        },\n+                        _ => false\n+                    };\n+\n+                    if is_vec {\n+                        // Special case for owned vectors.\n+                        fcx.push_ast_cleanup_scope(contents.id);\n+                        let datum = unpack_datum!(\n+                            bcx, tvec::trans_uniq_vec(bcx, expr, &**contents));\n+                        bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n+                        DatumBlock::new(bcx, datum)\n+                    } else {\n+                        trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                    }\n                 }\n                 ty::ty_box(..) => {\n                     trans_managed_expr(bcx, box_ty, &**contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n                                          \"expected unique or managed box\")\n             }\n+\n         }\n         ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, (**lit).clone()),\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -428,7 +641,19 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             trans_unary(bcx, expr, op, &**x)\n         }\n         ast::ExprAddrOf(_, ref x) => {\n-            trans_addr_of(bcx, expr, &**x)\n+            match x.node {\n+                ast::ExprRepeat(..) | ast::ExprVec(..) => {\n+                    // Special case for slices.\n+                    fcx.push_ast_cleanup_scope(x.id);\n+                    let datum = unpack_datum!(\n+                        bcx, tvec::trans_slice_vec(bcx, expr, &**x));\n+                    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, x.id);\n+                    DatumBlock::new(bcx, datum)\n+                }\n+                _ => {\n+                    trans_addr_of(bcx, expr, &**x)\n+                }\n+            }\n         }\n         ast::ExprCast(ref val, _) => {\n             // Datum output mode means this is a scalar cast:\n@@ -454,14 +679,27 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n-    let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n-    with_field_tys(bcx.tcx(), base_datum.ty, None, |discr, field_tys| {\n-            let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n-            let d = base_datum.get_element(\n-                field_tys[ix].mt.ty,\n-                |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n+    let bare_ty = ty::unopen_type(base_datum.ty);\n+    let repr = adt::represent_type(bcx.ccx(), bare_ty);\n+    with_field_tys(bcx.tcx(), bare_ty, None, |discr, field_tys| {\n+        let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n+        let d = base_datum.get_element(\n+            bcx,\n+            field_tys[ix].mt.ty,\n+            |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n+\n+        if ty::type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n-        })\n+        } else {\n+            let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n+            Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n+            let info = Load(bcx, get_len(bcx, base_datum.val));\n+            Store(bcx, info, get_len(bcx, scratch.val));\n+\n+            DatumBlock::new(bcx, scratch.to_expr_datum())\n+\n+        }\n+    })\n }\n \n fn trans_index<'a>(bcx: &'a Block<'a>,\n@@ -727,7 +965,6 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n-    let fcx = bcx.fcx;\n \n     match expr.node {\n         ast::ExprParen(ref e) => {\n@@ -772,14 +1009,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprVstore(ref contents, ast::ExprVstoreSlice) |\n-        ast::ExprVstore(ref contents, ast::ExprVstoreMutSlice) => {\n-            fcx.push_ast_cleanup_scope(contents.id);\n-            bcx = tvec::trans_slice_vstore(bcx, expr, &**contents, dest);\n-            fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id)\n-        }\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n-            tvec::trans_fixed_vstore(bcx, expr, expr, dest)\n+            tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n         ast::ExprFnBlock(_, ref decl, ref body) |\n         ast::ExprProc(ref decl, ref body) => {\n@@ -1146,7 +1377,8 @@ pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n                 for &(i, t) in base.fields.iter() {\n                     let datum = base_datum.get_element(\n-                            t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                    assert!(ty::type_is_sized(bcx.tcx(), datum.ty));\n                     let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n@@ -1253,13 +1485,12 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n                         -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n+    assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n-    let align = C_uint(bcx.ccx(), llalign_of_min(bcx.ccx(), llty) as uint);\n-    // We need to a make a pointer type because box_ty is ty_bot\n-    // if content_ty is, e.g. box fail!().\n-    let real_box_ty = ty::mk_uniq(bcx.tcx(), contents_ty);\n-    let Result { bcx, val } = malloc_raw_dyn(bcx, real_box_ty, size, align);\n+    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty) as uint);\n+    let llty_ptr = llty.ptr_to();\n+    let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n     // Unique boxes do not allocate for zero-size types. The standard library\n     // may assume that `free` is never called on the pointer returned for\n     // `Box<ZeroSizeType>`.\n@@ -1303,8 +1534,28 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n-    let ty = expr_ty(bcx, expr);\n-    return immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock();\n+    match ty::get(sub_datum.ty).sty {\n+        ty::ty_open(_) => {\n+            // Opened DST value, close to a fat pointer\n+            debug!(\"Closing fat pointer {}\", bcx.ty_to_string(sub_datum.ty));\n+\n+            let scratch = rvalue_scratch_datum(bcx,\n+                                               ty::close_type(bcx.tcx(), sub_datum.ty),\n+                                               \"fat_addr_of\");\n+            let base = Load(bcx, get_dataptr(bcx, sub_datum.val));\n+            Store(bcx, base, get_dataptr(bcx, scratch.val));\n+\n+            let len = Load(bcx, get_len(bcx, sub_datum.val));\n+            Store(bcx, len, get_len(bcx, scratch.val));\n+\n+            DatumBlock::new(bcx, scratch.to_expr_datum())\n+        }\n+        _ => {\n+            // Sized value, ref to a thin pointer\n+            let ty = expr_ty(bcx, expr);\n+            immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n+        }\n+    }\n }\n \n // Important to get types for both lhs and rhs, because one might be _|_\n@@ -1592,15 +1843,18 @@ pub enum cast_kind {\n     cast_other,\n }\n \n-pub fn cast_type_kind(t: ty::t) -> cast_kind {\n+pub fn cast_type_kind(tcx: &ty::ctxt, t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n         ty::ty_ptr(..)     => cast_pointer,\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty{\n-            ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => cast_other,\n-            _ => cast_pointer,\n-        },\n+        ty::ty_rptr(_, mt) => {\n+            if ty::type_is_sized(tcx, mt.ty) {\n+                cast_pointer\n+            } else {\n+                cast_other\n+            }\n+        }\n         ty::ty_bare_fn(..) => cast_pointer,\n         ty::ty_int(..)     => cast_integral,\n         ty::ty_uint(..)    => cast_integral,\n@@ -1620,8 +1874,8 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n \n     let t_in = expr_ty(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n-    let k_in = cast_type_kind(t_in);\n-    let k_out = cast_type_kind(t_out);\n+    let k_in = cast_type_kind(bcx.tcx(), t_in);\n+    let k_out = cast_type_kind(bcx.tcx(), t_out);\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n     let ll_t_in = type_of::arg_type_of(ccx, t_in);\n     let ll_t_out = type_of::arg_type_of(ccx, t_out);\n@@ -1809,10 +2063,14 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n-            match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..)\n-                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected unsized box\"),\n-                _ => deref_owned_pointer(bcx, expr, datum, content_ty),\n+            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+                deref_owned_pointer(bcx, expr, datum, content_ty)\n+            } else {\n+                // A fat pointer and an opened DST value have the same represenation\n+                // just different types.\n+                DatumBlock::new(bcx, Datum::new(datum.val,\n+                                                ty::mk_open(bcx.tcx(), content_ty),\n+                                                datum.kind))\n             }\n         }\n \n@@ -1827,21 +2085,21 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n-            match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..)\n-                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected unsized reference\"),\n-                _ => {\n-                    assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n-\n-                    let ptr = datum.to_llscalarish(bcx);\n-\n-                    // Always generate an lvalue datum, even if datum.mode is\n-                    // an rvalue.  This is because datum.mode is only an\n-                    // rvalue for non-owning pointers like &T or *T, in which\n-                    // case cleanup *is* scheduled elsewhere, by the true\n-                    // owner (or, in the case of *T, by the user).\n-                    DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n-                }\n+            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+                let ptr = datum.to_llscalarish(bcx);\n+\n+                // Always generate an lvalue datum, even if datum.mode is\n+                // an rvalue.  This is because datum.mode is only an\n+                // rvalue for non-owning pointers like &T or *T, in which\n+                // case cleanup *is* scheduled elsewhere, by the true\n+                // owner (or, in the case of *T, by the user).\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n+            } else {\n+                // A fat pointer and an opened DST value have the same represenation\n+                // just different types.\n+                DatumBlock::new(bcx, Datum::new(datum.val,\n+                                                ty::mk_open(bcx.tcx(), content_ty),\n+                                                datum.kind))\n             }\n         }\n "}, {"sha": "56841cd4044b626d297a7197e5911ebed55bb14b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 201, "deletions": 45, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -19,19 +19,21 @@ use llvm::{ValueRef, True, get_param};\n use llvm;\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n+use middle::trans::datum;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n use middle::trans::type_::Type;\n-use middle::trans::type_of::{type_of, sizing_type_of};\n+use middle::trans::type_of::{type_of, sizing_type_of, align_of};\n use middle::ty;\n use util::ppaux::ty_to_short_str;\n use util::ppaux;\n@@ -51,24 +53,33 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n         Some(expr::Ignore)).bcx\n }\n \n-fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n-                               align: u64) -> &'a Block<'a> {\n+fn trans_exchange_free_internal<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n+                               align: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p(ccx)), C_uint(ccx, size as uint), C_uint(ccx, align as uint)],\n+        [PointerCast(cx, v, Type::i8p(ccx)), size, align],\n         Some(expr::Ignore)).bcx\n }\n \n+pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n+                               align: u64) -> &'a Block<'a> {\n+    trans_exchange_free_internal(cx,\n+                                 v,\n+                                 C_uint(cx.ccx(), size as uint),\n+                                 C_uint(cx.ccx(), align as uint))\n+}\n+\n pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n                                   content_ty: ty::t) -> &'a Block<'a> {\n+    assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n     // `Box<ZeroSizeType>` does not allocate.\n     if content_size != 0 {\n-        let content_align = llalign_of_min(bcx.ccx(), sizing_type);\n+        let content_align = align_of(bcx.ccx(), content_ty);\n         trans_exchange_free(bcx, ptr, content_size, content_align)\n     } else {\n         bcx\n@@ -91,25 +102,26 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n \n pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n     let tcx = ccx.tcx();\n+    // Even if there is no dtor for t, there might be one deeper down and we\n+    // might need to pass in the vtable ptr.\n+    if !ty::type_is_sized(tcx, t) {\n+        return t\n+    }\n     if !ty::type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n     }\n     match ty::get(t).sty {\n         ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n             ty::mk_box(tcx, ty::mk_i8()),\n \n-        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n-            match ty::get(typ).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => t,\n-                _ => {\n-                    let llty = sizing_type_of(ccx, typ);\n-                    // `Box<ZeroSizeType>` does not allocate.\n-                    if llsize_of_alloc(ccx, llty) == 0 {\n-                        ty::mk_i8()\n-                    } else {\n-                        ty::mk_uniq(tcx, ty::mk_i8())\n-                    }\n-                }\n+        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ)\n+                         && ty::type_is_sized(tcx, typ) => {\n+            let llty = sizing_type_of(ccx, typ);\n+            // `Box<ZeroSizeType>` does not allocate.\n+            if llsize_of_alloc(ccx, llty) == 0 {\n+                ty::mk_i8()\n+            } else {\n+                ty::mk_uniq(tcx, ty::mk_i8())\n             }\n         }\n         _ => t\n@@ -120,8 +132,8 @@ pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n-    let ccx = bcx.ccx();\n     if ty::type_needs_drop(bcx.tcx(), t) {\n+        let ccx = bcx.ccx();\n         let glue = get_drop_glue(ccx, t);\n         let glue_type = get_drop_glue_type(ccx, t);\n         let ptr = if glue_type != t {\n@@ -143,13 +155,21 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n }\n \n pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n+    debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n+    debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     match ccx.drop_glues.borrow().find(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n \n-    let llfnty = Type::glue_fn(ccx, type_of(ccx, t).ptr_to());\n+    let llty = if ty::type_is_sized(ccx.tcx(), t) {\n+        type_of(ccx, t).ptr_to()\n+    } else {\n+        type_of(ccx, ty::mk_uniq(ccx.tcx(), t)).ptr_to()\n+    };\n+\n+    let llfnty = Type::glue_fn(ccx, llty);\n     let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n     ccx.drop_glues.borrow_mut().insert(t, glue);\n@@ -212,7 +232,13 @@ fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n                               substs: &subst::Substs)\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, v0));\n+    let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n+        v0\n+    } else {\n+        let llval = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+        Load(bcx, llval)\n+    };\n+    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n     with_cond(bcx, load_ty(bcx, drop_flag.val, ty::mk_bool()), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n@@ -231,13 +257,31 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t,\n                                  class_did, substs);\n \n-    // The second argument is the \"self\" argument for drop\n+    // The first argument is the \"self\" argument for drop\n     let params = unsafe {\n         let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n         ty.element_type().func_params()\n     };\n \n-    adt::fold_variants(bcx, &*repr, v0, |variant_cx, st, value| {\n+    let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n+    let self_ty = match ty::get(fty).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            assert!(f.sig.inputs.len() == 1);\n+            f.sig.inputs[0]\n+        }\n+        _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n+                                    bcx.ty_to_string(fty)).as_slice())\n+    };\n+\n+    let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n+        (v0, None)\n+    } else {\n+        let data = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+        let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n+        (Load(bcx, data), Some(Load(bcx, info)))\n+    };\n+\n+    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, st, value| {\n         // Be sure to put all of the fields into a scope so we can use an invoke\n         // instruction to call the user destructor but still call the field\n         // destructors if the user destructor fails.\n@@ -246,27 +290,107 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the environment (self).\n         assert_eq!(params.len(), 1);\n-        let self_arg = PointerCast(variant_cx, value, *params.get(0));\n+        let self_arg = if ty::type_is_fat_ptr(bcx.tcx(), self_ty) {\n+            // The dtor expects a fat pointer, so make one, even if we have to fake it.\n+            let boxed_ty = ty::mk_open(bcx.tcx(), t);\n+            let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n+            Store(bcx, value, GEPi(bcx, scratch.val, [0, abi::slice_elt_base]));\n+            Store(bcx,\n+                  // If we just had a thin pointer, make a fat pointer by sticking\n+                  // null where we put the unsizing info. This works because t\n+                  // is a sized type, so we will only unpack the fat pointer, never\n+                  // use the fake info.\n+                  info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n+                  GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n+            PointerCast(variant_cx, scratch.val, *params.get(0))\n+        } else {\n+            PointerCast(variant_cx, value, *params.get(0))\n+        };\n         let args = vec!(self_arg);\n \n         // Add all the fields as a value which needs to be cleaned at the end of\n         // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n         // the order in which fields get dropped.\n         for (i, ty) in st.fields.iter().enumerate().rev() {\n             let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n+\n+            let val = if ty::type_is_sized(bcx.tcx(), *ty) {\n+                llfld_a\n+            } else {\n+                let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n+                let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_field\");\n+                Store(bcx, llfld_a, GEPi(bcx, scratch.val, [0, abi::slice_elt_base]));\n+                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n+                scratch.val\n+            };\n             variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n-                                             llfld_a, *ty);\n+                                             val, *ty);\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n                                      [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None, false);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n     })\n }\n \n+fn size_and_align_of_dst<'a>(bcx: &'a Block<'a>, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n+    debug!(\"calculate size of DST: {}; with lost info: {}\",\n+           bcx.ty_to_string(t), bcx.val_to_string(info));\n+    if ty::type_is_sized(bcx.tcx(), t) {\n+        let sizing_type = sizing_type_of(bcx.ccx(), t);\n+        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type) as uint);\n+        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t) as uint);\n+        return (size, align);\n+    }\n+    match ty::get(t).sty {\n+        ty::ty_struct(id, ref substs) => {\n+            let ccx = bcx.ccx();\n+            // First get the size of all statically known fields.\n+            // Don't use type_of::sizing_type_of because that expects t to be sized.\n+            assert!(!ty::type_is_simd(bcx.tcx(), t));\n+            let repr = adt::represent_type(ccx, t);\n+            let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n+            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type) as uint);\n+            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type) as uint);\n+\n+            // Recurse to get the size of the dynamically sized field (must be\n+            // the last field).\n+            let fields = ty::struct_fields(bcx.tcx(), id, substs);\n+            let last_field = fields[fields.len()-1];\n+            let field_ty = last_field.mt.ty;\n+            let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n+\n+            // Return the sum of sizes and max of aligns.\n+            let size = Add(bcx, sized_size, unsized_size);\n+            let align = Select(bcx,\n+                               ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n+                               sized_align,\n+                               unsized_align);\n+            (size, align)\n+        }\n+        ty::ty_trait(..) => {\n+            // info points to the vtable and the second entry in the vtable is the\n+            // dynamic size of the object.\n+            let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n+            let size_ptr = GEPi(bcx, info, [1u]);\n+            let align_ptr = GEPi(bcx, info, [2u]);\n+            (Load(bcx, size_ptr), Load(bcx, align_ptr))\n+        }\n+        ty::ty_vec(unit_ty, None) => {\n+            // The info in this case is the length of the vec, so the size is that\n+            // times the unit size.\n+            let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n+            let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size as uint)), C_uint(bcx.ccx(), 8))\n+        }\n+        _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n+                                    bcx.ty_to_string(t)).as_slice())\n+    }\n+}\n+\n fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n@@ -276,29 +400,18 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n         }\n         ty::ty_uniq(content_ty) => {\n             match ty::get(content_ty).sty {\n-                ty::ty_vec(mt, None) => {\n-                    let llbox = Load(bcx, v0);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, mt.ty);\n-                        // FIXME: #13994: the old `Box<[T]>` will not support sized deallocation\n-                        trans_exchange_free(bcx, llbox, 0, 8)\n-                    })\n+                ty::ty_vec(ty, None) => {\n+                    tvec::make_drop_glue_unboxed(bcx, v0, ty)\n                 }\n                 ty::ty_str => {\n-                    let llbox = Load(bcx, v0);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n-                        let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n-                        // FIXME: #13994: the old `Box<str>` will not support sized deallocation\n-                        trans_exchange_free(bcx, llbox, 0, 8)\n-                    })\n+                    let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+                    tvec::make_drop_glue_unboxed(bcx, v0, unit_ty)\n                 }\n                 ty::ty_trait(..) => {\n                     let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n                     // Only drop the value when it is non-null\n-                    with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n+                    let concrete_ptr = Load(bcx, lluniquevalue);\n+                    with_cond(bcx, IsNotNull(bcx, concrete_ptr), |bcx| {\n                         let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n                         let dtor = Load(bcx, dtor_ptr);\n                         Call(bcx,\n@@ -308,8 +421,22 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                         bcx\n                     })\n                 }\n+                ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), content_ty) => {\n+                    let llval = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+                    let llbox = Load(bcx, llval);\n+                    let not_null = IsNotNull(bcx, llbox);\n+                    with_cond(bcx, not_null, |bcx| {\n+                        let bcx = drop_ty(bcx, v0, content_ty);\n+                        let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n+                        let info = Load(bcx, info);\n+                        let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+                        trans_exchange_free_internal(bcx, llbox, llsize, llalign)\n+                    })\n+                }\n                 _ => {\n-                    let llbox = Load(bcx, v0);\n+                    assert!(ty::type_is_sized(bcx.tcx(), content_ty));\n+                    let llval = v0;\n+                    let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty);\n@@ -322,7 +449,21 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             let tcx = bcx.tcx();\n             match ty::ty_dtor(tcx, did) {\n                 ty::TraitDtor(dtor, true) => {\n-                    trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                    // FIXME(16758) Since the struct is unsized, it is hard to\n+                    // find the drop flag (which is at the end of the struct).\n+                    // Lets just ignore the flag and pretend everything will be\n+                    // OK.\n+                    if ty::type_is_sized(bcx.tcx(), t) {\n+                        trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                    } else {\n+                        // Give the user a heads up that we are doing something\n+                        // stupid and dangerous.\n+                        bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n+                                                 because the struct is unsized. See issue\\\n+                                                 #16758\",\n+                                                bcx.ty_to_string(t)).as_slice());\n+                        trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                    }\n                 }\n                 ty::TraitDtor(dtor, false) => {\n                     trans_struct_drop(bcx, t, v0, dtor, did, substs)\n@@ -350,7 +491,23 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 trans_exchange_free(bcx, env, 0, 8)\n             })\n         }\n+        ty::ty_trait(..) => {\n+            // No need to do a null check here (as opposed to the Box<trait case\n+            // above), because this happens for a trait field in an unsized\n+            // struct. If anything is null, it is the whole struct and we won't\n+            // get here.\n+            let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n+            let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+            let dtor = Load(bcx, dtor_ptr);\n+            Call(bcx,\n+                 dtor,\n+                 [PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n+                 None);\n+            bcx\n+        }\n+        ty::ty_vec(ty, None) => tvec::make_drop_glue_unboxed(bcx, v0, ty),\n         _ => {\n+            assert!(ty::type_is_sized(bcx.tcx(), t));\n             if ty::type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n                 iter_structural_ty(bcx, v0, t, drop_ty)\n@@ -449,7 +606,6 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         ccx,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n-    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_string(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;"}, {"sha": "7d8e4679ae302d2ff4f3e412c93d92a89dfc9c82", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -119,6 +119,17 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                             \"s\"\n                         }).as_slice());\n         }\n+        if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n+           ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n+            ccx.sess()\n+               .add_lint(::lint::builtin::TRANSMUTE_FAT_PTR,\n+                         transmute_restriction.id,\n+                         transmute_restriction.span,\n+                         format!(\"Transmuting fat pointer types; {} to {}.\\\n+                                  Beware of relying on the compiler's representation\",\n+                                 ty_to_string(ccx.tcx(), transmute_restriction.from),\n+                                 ty_to_string(ccx.tcx(), transmute_restriction.to)));\n+        }\n     }\n     ccx.sess().abort_if_errors();\n }\n@@ -227,8 +238,7 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n         }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint)\n+            C_uint(ccx, type_of::align_of(ccx, tp_ty) as uint)\n         }\n         (_, \"pref_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -542,7 +552,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n                   tp_ty: ty::t, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n+    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n     let name = if allow_overlap {\n@@ -571,7 +581,7 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n                     dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n+    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n         \"llvm.memset.p0i8.i32\""}, {"sha": "83bdcc9dead6473d6120dd07d6982a5ac914e239", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -25,6 +25,7 @@ use middle::trans::datum::*;\n use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n+use middle::trans::machine;\n use middle::trans::monomorphize;\n use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n@@ -40,6 +41,9 @@ use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n use syntax::ast_util::PostExpansionMethod;\n \n+// drop_glue pointer, size, align.\n+static VTABLE_OFFSET: uint = 3;\n+\n /**\n The main \"translation\" pass for methods.  Generates code\n for non-monomorphized methods only.  Other methods will\n@@ -450,7 +454,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n                                     GEPi(bcx, llpair,\n                                          [0u, abi::trt_field_vtable]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -580,9 +584,15 @@ fn get_vtable(bcx: &Block,\n         }\n     });\n \n+    let size_ty = sizing_type_of(ccx, self_ty);\n+    let size = machine::llsize_of_alloc(ccx, size_ty);\n+    let ll_size = C_uint(ccx, size as uint);\n+    let align = align_of(ccx, self_ty);\n+    let ll_align = C_uint(ccx, align as uint);\n+\n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n-    let vtable = make_vtable(ccx, drop_glue, methods);\n+    let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n \n     ccx.vtables.borrow_mut().insert(hash_id, vtable);\n     vtable\n@@ -591,11 +601,14 @@ fn get_vtable(bcx: &Block,\n /// Helper function to declare and initialize the vtable.\n pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n                                           drop_glue: ValueRef,\n+                                          size: ValueRef,\n+                                          align: ValueRef,\n                                           ptrs: I)\n                                           -> ValueRef {\n     let _icx = push_ctxt(\"meth::make_vtable\");\n \n-    let components: Vec<_> = Some(drop_glue).move_iter().chain(ptrs).collect();\n+    let head = vec![drop_glue, size, align];\n+    let components: Vec<_> = head.move_iter().chain(ptrs).collect();\n \n     unsafe {\n         let tbl = C_struct(ccx, components.as_slice(), false);\n@@ -666,6 +679,26 @@ fn emit_vtable_methods(bcx: &Block,\n     }).collect()\n }\n \n+pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n+                      id: ast::NodeId,\n+                      self_ty: ty::t) -> ValueRef {\n+    let ccx = bcx.ccx();\n+    let origins = {\n+        let vtable_map = ccx.tcx.vtable_map.borrow();\n+        // This trait cast might be because of implicit coercion\n+        let adjs = ccx.tcx.adjustments.borrow();\n+        let adjust = adjs.find(&id);\n+        let method_call = if adjust.is_some() && ty::adjust_is_object(adjust.unwrap()) {\n+            MethodCall::autoobject(id)\n+        } else {\n+            MethodCall::expr(id)\n+        };\n+        let vres = vtable_map.get(&method_call).get_self().unwrap();\n+        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n+    };\n+    get_vtable(bcx, self_ty, origins)\n+}\n+\n pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n                             datum: Datum<Expr>,\n                             id: ast::NodeId,\n@@ -688,27 +721,16 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n         SaveIn(dest) => dest\n     };\n \n-    let ccx = bcx.ccx();\n     let v_ty = datum.ty;\n-    let llbox_ty = type_of(bcx.ccx(), datum.ty);\n+    let llbox_ty = type_of(bcx.ccx(), v_ty);\n \n     // Store the pointer into the first half of pair.\n-    let mut llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n-    llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n+    let llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n+    let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let origins = {\n-        let vtable_map = ccx.tcx.vtable_map.borrow();\n-        // This trait cast might be because of implicit coercion\n-        let method_call = match ccx.tcx.adjustments.borrow().find(&id) {\n-            Some(&ty::AutoObject(..)) => MethodCall::autoobject(id),\n-            _ => MethodCall::expr(id)\n-        };\n-        let vres = vtable_map.get(&method_call).get_self().unwrap();\n-        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n-    };\n-    let vtable = get_vtable(bcx, v_ty, origins);\n+    let vtable = vtable_ptr(bcx, id, v_ty);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "11c641f2d75a245b8eda0762145972cf24850405", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn c_size_and_align(&mut self, t: ty::t) -> Vec<ValueRef> {\n         let tr = type_of(self.bcx.ccx(), t);\n         let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n-        let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n+        let a = align_of(self.bcx.ccx(), t);\n         return vec!(self.c_uint(s as uint),\n              self.c_uint(a as uint));\n     }\n@@ -94,6 +94,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n             ty::MethodTraitItem(ref method) => (*method).clone(),\n         };\n         let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n+        debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_string(tcx, mth_ty));\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -149,13 +150,24 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           ty::ty_float(ast::TyF32) => self.leaf(\"f32\"),\n           ty::ty_float(ast::TyF64) => self.leaf(\"f64\"),\n \n+          ty::ty_open(_) | ty::ty_str | ty::ty_vec(_, None) | ty::ty_trait(..) => {\n+              // Unfortunately we can't do anything here because at runtime we\n+              // pass around the value by pointer (*u8). But unsized pointers are\n+              // fat and so we can't just cast them to *u8 and back. So we have\n+              // to work with the pointer directly (see ty_rptr/ty_uniq).\n+              fail!(\"Can't reflect unsized type\")\n+          }\n+          // FIXME(15049) Reflection for unsized structs.\n+          ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), t) => {\n+              fail!(\"Can't reflect unsized type\")\n+          }\n+\n           // Should rename to vec_*.\n-          ty::ty_vec(ref mt, Some(sz)) => {\n-              let extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n-              let extra = extra.append(self.c_mt(mt).as_slice());\n+          ty::ty_vec(ty, Some(sz)) => {\n+              let mut extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n+              extra.push(self.c_tydesc(ty));\n               self.visit(\"evec_fixed\", extra.as_slice())\n           }\n-          ty::ty_vec(..) | ty::ty_str | ty::ty_trait(..) => fail!(\"unexpected unsized type\"),\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n@@ -164,21 +176,25 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               });\n               self.visit(\"box\", extra.as_slice())\n           }\n+          ty::ty_ptr(ref mt) => {\n+              let extra = self.c_mt(mt);\n+              self.visit(\"ptr\", extra.as_slice())\n+          }\n           ty::ty_uniq(typ) => {\n               match ty::get(typ).sty {\n-                  ty::ty_vec(ref mt, None) => {\n-                      let extra = Vec::new();\n-                      let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(\"evec_uniq\", extra.as_slice())\n-                  }\n-                  ty::ty_str => self.visit(\"estr_uniq\", &[]),\n                   ty::ty_trait(..) => {\n                       let extra = [\n                           self.c_slice(token::intern_and_get_ident(\n                                   ty_to_string(tcx, t).as_slice()))\n                       ];\n                       self.visit(\"trait\", extra);\n                   }\n+                  // FIXME(15049) allow reflection of Box<[T]>. You'll need to\n+                  // restore visit_evec_uniq.\n+                  ty::ty_vec(_, None) => {\n+                      fail!(\"Box<[T]> theoretically doesn't exist, so don't try to reflect it\")\n+                  }\n+                  ty::ty_str => fail!(\"Can't reflect Box<str> which shouldn't be used anyway\"),\n                   _ => {\n                       let extra = self.c_mt(&ty::mt {\n                           ty: typ,\n@@ -188,17 +204,11 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                   }\n               }\n           }\n-          ty::ty_ptr(ref mt) => {\n-              let extra = self.c_mt(mt);\n-              self.visit(\"ptr\", extra.as_slice())\n-          }\n           ty::ty_rptr(_, ref mt) => {\n               match ty::get(mt.ty).sty {\n-                  ty::ty_vec(ref mt, None) => {\n-                      let (name, extra) = (\"slice\".to_string(), Vec::new());\n-                      let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(format!(\"evec_{}\", name).as_slice(),\n-                                 extra.as_slice())\n+                  ty::ty_vec(ty, None) => {\n+                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n+                      self.visit(\"evec_slice\", extra.as_slice())\n                   }\n                   ty::ty_str => self.visit(\"estr_slice\", &[]),\n                   ty::ty_trait(..) => {\n@@ -267,12 +277,18 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                       special_idents::unnamed_field.name;\n               }\n \n+              // This and the type_is_sized check on individual field types are\n+              // because we cannot reflect unsized types (see note above). We\n+              // just pretend the unsized field does not exist and print nothing.\n+              // This is sub-optimal.\n+              let len = fields.len();\n+\n               let extra = (vec!(\n                   self.c_slice(\n                       token::intern_and_get_ident(ty_to_string(tcx,\n                                                             t).as_slice())),\n                   self.c_bool(named_fields),\n-                  self.c_uint(fields.len())\n+                  self.c_uint(len)\n               )).append(self.c_size_and_align(t).as_slice());\n               self.bracketed(\"class\", extra.as_slice(), |this| {\n                   for (i, field) in fields.iter().enumerate() {"}, {"sha": "94ca520c533f9348e8c05e6944a3dea95bccf83e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 132, "deletions": 123, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -25,7 +25,7 @@ use middle::trans::datum::*;\n use middle::trans::expr::{Dest, Ignore, SaveIn};\n use middle::trans::expr;\n use middle::trans::glue;\n-use middle::trans::machine::{llsize_of, nonzero_llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n@@ -34,14 +34,14 @@ use util::ppaux::ty_to_string;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-pub fn get_fill(bcx: &Block, vptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::get_fill\");\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n+fn get_len(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+    let _icx = push_ctxt(\"tvec::get_lenl\");\n+    Load(bcx, expr::get_len(bcx, vptr))\n }\n \n-pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n-    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n+    Load(bcx, expr::get_dataptr(bcx, vptr))\n }\n \n pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n@@ -56,13 +56,24 @@ pub fn make_drop_glue_unboxed<'a>(\n                               vptr: ValueRef,\n                               unit_ty: ty::t)\n                               -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n-    let tcx = bcx.tcx();\n-    if ty::type_needs_drop(tcx, unit_ty) {\n-        let fill = get_fill(bcx, vptr);\n+    let not_null = IsNotNull(bcx, vptr);\n+    with_cond(bcx, not_null, |bcx| {\n+        let tcx = bcx.tcx();\n+        let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n+\n+        let len = get_len(bcx, vptr);\n         let dataptr = get_dataptr(bcx, vptr);\n-        iter_vec_raw(bcx, dataptr, unit_ty, fill, glue::drop_ty)\n-    } else { bcx }\n+        let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n+            iter_vec_raw(bcx, dataptr, unit_ty, len, glue::drop_ty)\n+        } else {\n+            bcx\n+        };\n+\n+        let not_null = IsNotNull(bcx, dataptr);\n+        with_cond(bcx, not_null, |bcx| {\n+            glue::trans_exchange_free(bcx, dataptr, 0, 8)\n+        })\n+    })\n }\n \n pub struct VecTypes {\n@@ -85,8 +96,7 @@ impl VecTypes {\n \n pub fn trans_fixed_vstore<'a>(\n                           bcx: &'a Block<'a>,\n-                          vstore_expr: &ast::Expr,\n-                          content_expr: &ast::Expr,\n+                          expr: &ast::Expr,\n                           dest: expr::Dest)\n                           -> &'a Block<'a> {\n     //!\n@@ -96,50 +106,53 @@ pub fn trans_fixed_vstore<'a>(\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n-           bcx.expr_to_string(vstore_expr), dest.to_string(bcx.ccx()));\n+    debug!(\"trans_fixed_vstore(expr={}, dest={:?})\",\n+           bcx.expr_to_string(expr), dest.to_string(bcx.ccx()));\n \n-    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let vt = vec_types_from_expr(bcx, expr);\n \n     return match dest {\n-        Ignore => write_content(bcx, &vt, vstore_expr, content_expr, dest),\n+        Ignore => write_content(bcx, &vt, expr, expr, dest),\n         SaveIn(lldest) => {\n             // lldest will have type *[T x N], but we want the type *T,\n             // so use GEP to convert:\n             let lldest = GEPi(bcx, lldest, [0, 0]);\n-            write_content(bcx, &vt, vstore_expr, content_expr, SaveIn(lldest))\n+            write_content(bcx, &vt, expr, expr, SaveIn(lldest))\n         }\n     };\n }\n \n-pub fn trans_slice_vstore<'a>(\n-                          bcx: &'a Block<'a>,\n-                          vstore_expr: &ast::Expr,\n-                          content_expr: &ast::Expr,\n-                          dest: expr::Dest)\n-                          -> &'a Block<'a> {\n+pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n+                           slice_expr: &ast::Expr,\n+                           content_expr: &ast::Expr)\n+                           -> DatumBlock<'a, Expr> {\n     /*!\n      * &[...] allocates memory on the stack and writes the values into it,\n-     * returning a slice (pair of ptr, len).  &\"...\" is similar except that\n-     * the memory can be statically allocated.\n+     * returning the vector (the caller must make the reference).  \"...\" is\n+     * similar except that the memory can be statically allocated and we return\n+     * a reference (strings are always by-ref).\n      */\n \n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let mut bcx = bcx;\n \n-    debug!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n-           bcx.expr_to_string(vstore_expr), dest.to_string(ccx));\n+    debug!(\"trans_slice_vec(slice_expr={})\",\n+           bcx.expr_to_string(slice_expr));\n \n-    // Handle the &\"...\" case:\n+    let vec_ty = node_id_type(bcx, slice_expr.id);\n+\n+    // Handle the \"...\" case (returns a slice since strings are always unsized):\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n-                    return trans_lit_str(bcx,\n-                                         content_expr,\n-                                         s.clone(),\n-                                         dest)\n+                    let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n+                    bcx = trans_lit_str(bcx,\n+                                        content_expr,\n+                                        s.clone(),\n+                                        SaveIn(scratch.val));\n+                    return DatumBlock::new(bcx, scratch.to_expr_datum());\n                 }\n                 _ => {}\n             }\n@@ -148,46 +161,39 @@ pub fn trans_slice_vstore<'a>(\n     }\n \n     // Handle the &[...] case:\n-    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"vt={}, count={:?}\", vt.to_string(ccx), count);\n-\n+    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n     let llcount = C_uint(ccx, count);\n-    let llfixed;\n-    if count == 0 {\n+\n+    let fixed_ty = ty::mk_vec(bcx.tcx(),\n+                              vt.unit_ty,\n+                              Some(count));\n+    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n+\n+    let llfixed = if count == 0 {\n         // Just create a zero-sized alloca to preserve\n         // the non-null invariant of the inner slice ptr\n-        llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+        let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+        BitCast(bcx, llfixed, llfixed_ty)\n     } else {\n         // Make a fixed-length backing array and allocate it on the stack.\n-        llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+        let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n         // Arrange for the backing array to be cleaned up.\n-        let fixed_ty = ty::mk_vec(bcx.tcx(),\n-                                  ty::mt {ty: vt.unit_ty,\n-                                          mutbl: ast::MutMutable},\n-                                  Some(count));\n-        let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n         let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n         let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n         fcx.schedule_lifetime_end(cleanup_scope, llfixed_casted);\n         fcx.schedule_drop_mem(cleanup_scope, llfixed_casted, fixed_ty);\n \n         // Generate the content into the backing array.\n-        bcx = write_content(bcx, &vt, vstore_expr,\n+        bcx = write_content(bcx, &vt, slice_expr,\n                             content_expr, SaveIn(llfixed));\n-    }\n \n-    // Finally, create the slice pair itself.\n-    match dest {\n-        Ignore => {}\n-        SaveIn(lldest) => {\n-            Store(bcx, llfixed, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-            Store(bcx, llcount, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n-        }\n-    }\n+        llfixed_casted\n+    };\n \n-    return bcx;\n+    immediate_rvalue_bcx(bcx, llfixed, vec_ty).to_expr_datumblock()\n }\n \n pub fn trans_lit_str<'a>(\n@@ -198,7 +204,7 @@ pub fn trans_lit_str<'a>(\n                      -> &'a Block<'a> {\n     /*!\n      * Literal strings translate to slices into static memory.  This is\n-     * different from trans_slice_vstore() above because it does need to copy\n+     * different from trans_slice_vstore() above because it doesn't need to copy\n      * the content anywhere.\n      */\n \n@@ -214,27 +220,24 @@ pub fn trans_lit_str<'a>(\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p(bcx.ccx()).to_ref());\n-                Store(bcx, llcstr,\n-                      GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-                Store(bcx, llbytes,\n-                      GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+                Store(bcx, llcstr, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n+                Store(bcx, llbytes, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n                 bcx\n             }\n         }\n     }\n }\n \n-\n-pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n-                             vstore_expr: &ast::Expr,\n-                             content_expr: &ast::Expr)\n-                             -> DatumBlock<'a, Expr> {\n+pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n+                          uniq_expr: &ast::Expr,\n+                          content_expr: &ast::Expr)\n+                          -> DatumBlock<'a, Expr> {\n     /*!\n-     * ~[...] and \"...\".to_string() allocate boxes in the exchange heap and write\n+     * Box<[...]> and \"...\".to_string() allocate boxes in the exchange heap and write\n      * the array elements into them.\n      */\n \n-    debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_string(vstore_expr));\n+    debug!(\"trans_uniq_vec(uniq_expr={})\", bcx.expr_to_string(uniq_expr));\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n@@ -267,45 +270,50 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n         _ => {}\n     }\n \n-    let vec_ty = node_id_type(bcx, vstore_expr.id);\n-    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n+    let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n+    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n+    let vec_ty = node_id_type(bcx, uniq_expr.id);\n \n-    let llunitty = type_of::type_of(ccx, vt.unit_ty);\n-    let unit_sz = nonzero_llsize_of(ccx, llunitty);\n-\n-    let fill = Mul(bcx, C_uint(ccx, count), unit_sz);\n-    let alloc = if count < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n-    else { fill };\n-\n-    let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n-\n-    // ~[T] is not going to be changed to support alignment, since it's obsolete.\n+    let unit_sz = nonzero_llsize_of(ccx, type_of::type_of(ccx, vt.unit_ty));\n+    let llcount = if count < 4u {\n+        C_int(ccx, 4)\n+    } else {\n+        C_uint(ccx, count)\n+    };\n+    let alloc = Mul(bcx, llcount, unit_sz);\n+    let llty_ptr = type_of::type_of(ccx, vt.unit_ty).ptr_to();\n     let align = C_uint(ccx, 8);\n-    let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vec_ty, vecsize, align);\n-    Store(bcx, fill, GEPi(bcx, val, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n+    let Result { bcx: bcx, val: dataptr } = malloc_raw_dyn(bcx,\n+                                                           llty_ptr,\n+                                                           vec_ty,\n+                                                           alloc,\n+                                                           align);\n \n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-\n-    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation, this is a placeholder\n-    let content_ty = vt.unit_ty;\n+    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation,\n+    // this is a placeholder\n     fcx.schedule_free_value(cleanup::CustomScope(temp_scope),\n-                            val, cleanup::HeapExchange, content_ty);\n-\n-    let dataptr = get_dataptr(bcx, val);\n+                            dataptr, cleanup::HeapExchange, vt.unit_ty);\n \n-    debug!(\"alloc_uniq_vec() returned val={}, dataptr={}\",\n-           bcx.val_to_string(val), bcx.val_to_string(dataptr));\n+        debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n+               bcx.val_to_string(dataptr), count);\n \n-    let bcx = write_content(bcx, &vt, vstore_expr,\n-                            content_expr, SaveIn(dataptr));\n+        let bcx = write_content(bcx, &vt, uniq_expr,\n+                                content_expr, SaveIn(dataptr));\n \n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    immediate_rvalue_bcx(bcx, val, vec_ty).to_expr_datumblock()\n+    if ty::type_is_sized(bcx.tcx(), vec_ty) {\n+        immediate_rvalue_bcx(bcx, dataptr, vec_ty).to_expr_datumblock()\n+    } else {\n+        let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n+        Store(bcx, dataptr, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n+        Store(bcx, llcount, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n+    }\n }\n \n pub fn write_content<'a>(\n@@ -451,21 +459,27 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_fixed_base_and_byte_len(bcx: &Block,\n-                                   llval: ValueRef,\n-                                   unit_ty: ty::t,\n-                                   vec_length: uint)\n-                                   -> (ValueRef, ValueRef) {\n+pub fn get_fixed_base_and_len(bcx: &Block,\n+                              llval: ValueRef,\n+                              vec_length: uint)\n+                              -> (ValueRef, ValueRef) {\n     /*!\n      * Converts a fixed-length vector into the slice pair.\n      * The vector should be stored in `llval` which should be by ref.\n      */\n \n     let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, unit_ty);\n \n-    let base = GEPi(bcx, llval, [0u, 0u]);\n-    let len = Mul(bcx, C_uint(ccx, vec_length), vt.llunit_size);\n+    let base = expr::get_dataptr(bcx, llval);\n+    let len = C_uint(ccx, vec_length);\n+    (base, len)\n+}\n+\n+fn get_slice_base_and_len(bcx: &Block,\n+                          llval: ValueRef)\n+                          -> (ValueRef, ValueRef) {\n+    let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n+    let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n     (base, len)\n }\n \n@@ -484,27 +498,20 @@ pub fn get_base_and_len(bcx: &Block,\n     let ccx = bcx.ccx();\n \n     match ty::get(vec_ty).sty {\n-        ty::ty_vec(_, Some(n)) => {\n-            let base = GEPi(bcx, llval, [0u, 0u]);\n-            (base, C_uint(ccx, n))\n-        }\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-            ty::ty_vec(_, None) | ty::ty_str => {\n-                assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n-                let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-                let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n-                (base, count)\n-            }\n-            _ => ccx.sess().bug(\"unexpected type (ty_rptr) in get_base_and_len\"),\n+        ty::ty_vec(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n+        ty::ty_open(ty) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n+            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\")\n         },\n-        ty::ty_uniq(t) => match ty::get(t).sty {\n-            ty::ty_vec(_, None) | ty::ty_str => {\n-                assert!(type_is_immediate(bcx.ccx(), vec_ty));\n-                let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n-                let body = Load(bcx, llval);\n-                (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n+\n+        // Only used for pattern matching.\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n+            ty::ty_vec(_, Some(n)) => {\n+                let base = GEPi(bcx, Load(bcx, llval), [0u, 0u]);\n+                (base, C_uint(ccx, n))\n             }\n-            _ => ccx.sess().bug(\"unexpected type (ty_uniq) in get_base_and_len\"),\n+            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n         },\n         _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n     }\n@@ -576,13 +583,15 @@ pub fn iter_vec_raw<'r,\n                     bcx: &'b Block<'b>,\n                     data_ptr: ValueRef,\n                     unit_ty: ty::t,\n-                    fill: ValueRef,\n+                    len: ValueRef,\n                     f: iter_vec_block<'r,'b>)\n                     -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n     let fcx = bcx.fcx;\n \n     let vt = vec_types(bcx, unit_ty);\n+    let fill = Mul(bcx, len, vt.llunit_size);\n+\n     if vt.llunit_alloc_size == 0 {\n         // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n         iter_vec_loop(bcx, data_ptr, &vt, fill, f)"}, {"sha": "017d61137e4b0d0bcbcb59e79facd5071301613e", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -215,7 +215,7 @@ impl Type {\n \n     pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(ccx,\n-            [Type::int(ccx), Type::int(ccx), Type::array(ty, 0)],\n+            [Type::array(ty, 0), Type::int(ccx)],\n         false)\n     }\n \n@@ -231,9 +231,16 @@ impl Type {\n         ], false)\n     }\n \n+    pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n+        Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n+    }\n+\n     pub fn opaque_trait(ccx: &CrateContext) -> Type {\n-        let vtable = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to();\n-        Type::struct_(ccx, [vtable, Type::i8p(ccx)], false)\n+        Type::struct_(ccx, [Type::opaque_trait_data(ccx).ptr_to(), Type::vtable_ptr(ccx)], false)\n+    }\n+\n+    pub fn opaque_trait_data(ccx: &CrateContext) -> Type {\n+        Type::i8(ccx)\n     }\n \n     pub fn kind(&self) -> TypeKind {"}, {"sha": "83c792ecf8782b43c4ad0ad89f7d4d63812dbbd1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 87, "deletions": 45, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -14,7 +14,9 @@ use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::foreign;\n+use middle::trans::machine;\n use middle::ty;\n+use util::ppaux;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -160,6 +162,11 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let llsizingty = match ty::get(t).sty {\n+        _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n+            cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n+                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+        }\n+\n         ty::ty_nil | ty::ty_bot => Type::nil(cx),\n         ty::ty_bool => Type::bool(cx),\n         ty::ty_char => Type::char(cx),\n@@ -169,32 +176,24 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_box(..) |\n         ty::ty_ptr(..) => Type::i8p(cx),\n-        ty::ty_uniq(ty) => {\n-            match ty::get(ty).sty {\n-                ty::ty_trait(..) => Type::opaque_trait(cx),\n-                _ => Type::i8p(cx),\n-            }\n-        }\n-        ty::ty_rptr(_, mt) => {\n-            match ty::get(mt.ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str => {\n-                    Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n-                }\n-                ty::ty_trait(..) => Type::opaque_trait(cx),\n-                _ => Type::i8p(cx),\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+            if ty::type_is_sized(cx.tcx(), ty) {\n+                Type::i8p(cx)\n+            } else {\n+                Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n             }\n         }\n \n         ty::ty_bare_fn(..) => Type::i8p(cx),\n         ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n \n-        ty::ty_vec(mt, Some(size)) => {\n-            Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n+        ty::ty_vec(ty, Some(size)) => {\n+            Type::array(&sizing_type_of(cx, ty), size as u64)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, &*repr)\n+            adt::sizing_type_of(cx, &*repr, false)\n         }\n \n         ty::ty_struct(..) => {\n@@ -204,15 +203,19 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, &*repr)\n+                adt::sizing_type_of(cx, &*repr, false)\n             }\n         }\n \n-        ty::ty_infer(..) | ty::ty_param(..) |\n-        ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {\n-            cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n-                                  ty::get(t).sty).as_slice())\n+        ty::ty_open(_) => {\n+            Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n+        }\n+\n+        ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n+            cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n+                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n+        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => fail!(\"unreachable\")\n     };\n \n     cx.llsizingtypes.borrow_mut().insert(t, llsizingty);\n@@ -229,13 +232,30 @@ pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n+    fn type_of_unsize_info(cx: &CrateContext, t: ty::t) -> Type {\n+        // It is possible to end up here with a sized type. This happens with a\n+        // struct which might be unsized, but is monomorphised to a sized type.\n+        // In this case we'll fake a fat pointer with no unsize info (we use 0).\n+        // However, its still a fat pointer, so we need some type use.\n+        if ty::type_is_sized(cx.tcx(), t) {\n+            return Type::i8p(cx);\n+        }\n+\n+        match ty::get(ty::unsized_part_of_type(cx.tcx(), t)).sty {\n+            ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n+            ty::ty_trait(_) => Type::vtable_ptr(cx),\n+            _ => fail!(\"Unexpected type returned from unsized_part_of_type : {}\",\n+                       t.repr(cx.tcx()))\n+        }\n+    }\n+\n     // Check the cache.\n     match cx.lltypes.borrow().find(&t) {\n         Some(&llty) => return llty,\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t);\n+    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), ty::get(t).sty);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -283,35 +303,37 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }\n-      ty::ty_uniq(typ) => {\n-          match ty::get(typ).sty {\n-              ty::ty_vec(mt, None) => Type::vec(cx, &type_of(cx, mt.ty)).ptr_to(),\n-              ty::ty_str => Type::vec(cx, &Type::i8(cx)).ptr_to(),\n-              ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ => type_of(cx, typ).ptr_to(),\n-          }\n-      }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n-      ty::ty_rptr(_, ref mt) => {\n-          match ty::get(mt.ty).sty {\n-              ty::ty_vec(mt, None) => {\n-                  let p_ty = type_of(cx, mt.ty).ptr_to();\n-                  let u_ty = Type::uint_from_ty(cx, ast::TyU);\n-                  Type::struct_(cx, [p_ty, u_ty], false)\n-              }\n+\n+      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+          match ty::get(ty).sty {\n               ty::ty_str => {\n-                  // This means we get a nicer name in the output\n+                  // This means we get a nicer name in the output (str is always\n+                  // unsized).\n                   cx.tn.find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ => type_of(cx, mt.ty).ptr_to(),\n+              _ if !ty::type_is_sized(cx.tcx(), ty) => {\n+                  let p_ty = type_of(cx, ty).ptr_to();\n+                  Type::struct_(cx, [p_ty, type_of_unsize_info(cx, ty)], false)\n+              }\n+              _ => type_of(cx, ty).ptr_to(),\n           }\n       }\n \n-      ty::ty_vec(ref mt, Some(n)) => {\n-          Type::array(&type_of(cx, mt.ty), n as u64)\n+      ty::ty_vec(ty, Some(n)) => {\n+          Type::array(&type_of(cx, ty), n as u64)\n+      }\n+      ty::ty_vec(ty, None) => {\n+          type_of(cx, ty)\n+      }\n+\n+      ty::ty_trait(..) => {\n+          Type::opaque_trait_data(cx)\n       }\n \n+      ty::ty_str => Type::i8(cx),\n+\n       ty::ty_bare_fn(_) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n       }\n@@ -339,12 +361,27 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           }\n       }\n \n-      ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unsized ty_vec\"),\n-      ty::ty_str => cx.sess().bug(\"type_of with unsized (bare) ty_str\"),\n-      ty::ty_trait(..) => cx.sess().bug(\"type_of with unsized ty_trait\"),\n+      ty::ty_open(t) => match ty::get(t).sty {\n+          ty::ty_struct(..) => {\n+              let p_ty = type_of(cx, t).ptr_to();\n+              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+          }\n+          ty::ty_vec(ty, None) => {\n+              let p_ty = type_of(cx, ty).ptr_to();\n+              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+          }\n+          ty::ty_str => {\n+              let p_ty = Type::i8p(cx);\n+              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+          }\n+          ty::ty_trait(..) => Type::opaque_trait(cx),\n+          _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n+                                     ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+      },\n+\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n-      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")\n+      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\",\n@@ -367,6 +404,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     return llty;\n }\n \n+pub fn align_of(cx: &CrateContext, t: ty::t) -> u64 {\n+    let llty = sizing_type_of(cx, t);\n+    machine::llalign_of_min(cx, llty)\n+}\n+\n // Want refinements! (Or case classes, I guess\n pub enum named_ty {\n     a_struct,"}, {"sha": "2d3096d13eae078a08be9637beafc8ed3743f96e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 304, "deletions": 182, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -263,37 +263,138 @@ pub enum Variance {\n #[deriving(Clone)]\n pub enum AutoAdjustment {\n     AutoAddEnv(ty::TraitStore),\n-    AutoDerefRef(AutoDerefRef),\n-    AutoObject(ty::TraitStore,\n-               ty::BuiltinBounds,\n-               ast::DefId, /* Trait ID */\n-               subst::Substs /* Trait substitutions */)\n+    AutoDerefRef(AutoDerefRef)\n }\n \n-#[deriving(Clone, Decodable, Encodable)]\n+#[deriving(Clone, PartialEq)]\n+pub enum UnsizeKind {\n+    // [T, ..n] -> [T], the uint field is n.\n+    UnsizeLength(uint),\n+    // An unsize coercion applied to the tail field of a struct.\n+    // The uint is the index of the type parameter which is unsized.\n+    UnsizeStruct(Box<UnsizeKind>, uint),\n+    UnsizeVtable(ty::BuiltinBounds,\n+                 ast::DefId, /* Trait ID */\n+                 subst::Substs /* Trait substitutions */)\n+}\n+\n+#[deriving(Clone)]\n pub struct AutoDerefRef {\n     pub autoderefs: uint,\n     pub autoref: Option<AutoRef>\n }\n \n-#[deriving(Clone, Decodable, Encodable, PartialEq, Show)]\n+#[deriving(Clone, PartialEq)]\n pub enum AutoRef {\n     /// Convert from T to &T\n-    AutoPtr(Region, ast::Mutability),\n+    /// The third field allows us to wrap other AutoRef adjustments.\n+    AutoPtr(Region, ast::Mutability, Option<Box<AutoRef>>),\n \n-    /// Convert from ~[]/&[] to &[] or str\n-    AutoBorrowVec(Region, ast::Mutability),\n+    /// Convert [T, ..n] to [T] (or similar, depending on the kind)\n+    AutoUnsize(UnsizeKind),\n \n-    /// Convert from ~[]/&[] to &&[] or str\n-    AutoBorrowVecRef(Region, ast::Mutability),\n+    /// Convert Box<[T, ..n]> to Box<[T]> or something similar in a Box.\n+    /// With DST and Box a library type, this should be replaced by UnsizeStruct.\n+    AutoUnsizeUniq(UnsizeKind),\n \n     /// Convert from T to *T\n+    /// Value to thin pointer\n     AutoUnsafe(ast::Mutability),\n+}\n+\n+// Ugly little helper function. The first bool in the returned tuple is true if\n+// there is an 'unsize to trait object' adjustment at the bottom of the\n+// adjustment. If that is surrounded by an AutoPtr, then we also return the\n+// region of the AutoPtr (in the third argument). The second bool is true if the\n+// adjustment is unique.\n+fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n+    fn unsize_kind_is_object(k: &UnsizeKind) -> bool {\n+        match k {\n+            &UnsizeVtable(..) => true,\n+            &UnsizeStruct(box ref k, _) => unsize_kind_is_object(k),\n+            _ => false\n+        }\n+    }\n+\n+    match autoref {\n+        &AutoUnsize(ref k) => (unsize_kind_is_object(k), false, None),\n+        &AutoUnsizeUniq(ref k) => (unsize_kind_is_object(k), true, None),\n+        &AutoPtr(adj_r, _, Some(box ref autoref)) => {\n+            let (b, u, r) = autoref_object_region(autoref);\n+            if r.is_some() || u {\n+                (b, u, r)\n+            } else {\n+                (b, u, Some(adj_r))\n+            }\n+        }\n+        _ => (false, false, None)\n+    }\n+}\n+\n+// If the adjustment introduces a borrowed reference to a trait object, then\n+// returns the region of the borrowed reference.\n+pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n+    match adj {\n+        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+            let (b, _, r) = autoref_object_region(autoref);\n+            if b {\n+                r\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+\n+// Returns true if there is a trait cast at the bottom of the adjustment.\n+pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n+    match adj {\n+        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+            let (b, _, _) = autoref_object_region(autoref);\n+            b\n+        }\n+        _ => false\n+    }\n+}\n+\n+// If possible, returns the type expected from the given adjustment. This is not\n+// possible if the adjustment depends on the type of the adjusted expression.\n+pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n+    fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<t> {\n+        match autoref {\n+            &AutoUnsize(ref k) => match k {\n+                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some(mk_trait(cx, def_id, substs.clone(), bounds))\n+                }\n+                _ => None\n+            },\n+            &AutoUnsizeUniq(ref k) => match k {\n+                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some(mk_uniq(cx, mk_trait(cx, def_id, substs.clone(), bounds)))\n+                }\n+                _ => None\n+            },\n+            &AutoPtr(r, m, Some(box ref autoref)) => {\n+                match type_of_autoref(cx, autoref) {\n+                    Some(t) => Some(mk_rptr(cx, r, mt {mutbl: m, ty: t})),\n+                    None => None\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n \n-    /// Convert from Box<Trait>/&Trait to &Trait\n-    AutoBorrowObj(Region, ast::Mutability),\n+    match adj {\n+        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+            type_of_autoref(cx, autoref)\n+        }\n+        _ => None\n+    }\n }\n \n+\n+\n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions.\n pub struct TransmuteRestriction {\n@@ -303,6 +404,8 @@ pub struct TransmuteRestriction {\n     pub from: t,\n     /// The type being transmuted to.\n     pub to: t,\n+    /// NodeIf of the transmute intrinsic.\n+    pub id: ast::NodeId,\n }\n \n /// The data structure to keep track of all the information that typechecker\n@@ -802,7 +905,7 @@ pub enum sty {\n     ty_box(t),\n     ty_uniq(t),\n     ty_str,\n-    ty_vec(mt, Option<uint>),  // Second field is length.\n+    ty_vec(t, Option<uint>), // Second field is length.\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n@@ -813,6 +916,12 @@ pub enum sty {\n     ty_tup(Vec<t>),\n \n     ty_param(ParamTy), // type parameter\n+    ty_open(t),  // A deref'ed fat pointer, i.e., a dynamically sized value\n+                 // and its size. Only ever used in trans. It is not necessary\n+                 // earlier since we don't need to distinguish a DST with its\n+                 // size (e.g., in a deref) vs a DST with the size elsewhere (\n+                 // e.g., in a field).\n+\n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n@@ -1377,10 +1486,10 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_trait(box ty::TyTrait { ref substs, .. }) => {\n           flags |= sflags(substs);\n       }\n-      &ty_box(tt) | &ty_uniq(tt) => {\n+      &ty_box(tt) | &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n         flags |= get(tt).flags\n       }\n-      &ty_ptr(ref m) | &ty_vec(ref m, _) => {\n+      &ty_ptr(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1558,14 +1667,14 @@ pub fn mk_nil_ptr(cx: &ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: &ctxt, tm: mt, sz: Option<uint>) -> t {\n-    mk_t(cx, ty_vec(tm, sz))\n+pub fn mk_vec(cx: &ctxt, t: t, sz: Option<uint>) -> t {\n+    mk_t(cx, ty_vec(t, sz))\n }\n \n pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n     mk_rptr(cx, r,\n             mt {\n-                ty: mk_vec(cx, tm, None),\n+                ty: mk_vec(cx, tm.ty, None),\n                 mutbl: tm.mutbl\n             })\n }\n@@ -1643,6 +1752,8 @@ pub fn mk_param_from_def(cx: &ctxt, def: &TypeParameterDef) -> t {\n     mk_param(cx, def.space, def.index, def.def_id)\n }\n \n+pub fn mk_open(cx: &ctxt, t: t) -> t { mk_t(cx, ty_open(t)) }\n+\n pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1653,10 +1764,9 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(..) |\n-        ty_err => {}\n-        ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n-        ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_vec(ref tm, _) => {\n+        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_, _) | ty_err => {}\n+        ty_box(ty) | ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n+        ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -1775,14 +1885,11 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n \n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n-        ty_vec(mt, _) => mt.ty,\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_box(t) | ty_uniq(t) => match get(t).sty {\n-            ty_vec(mt, None) => mt.ty,\n-            ty_str => mk_mach_uint(ast::TyU8),\n-            _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n-        },\n-        _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n+        ty_vec(ty, _) => ty,\n+        ty_str => mk_mach_uint(ast::TyU8),\n+        ty_open(ty) => sequence_element_type(cx, ty),\n+        _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                 ty_to_string(cx, ty)).as_slice()),\n     }\n }\n \n@@ -1815,12 +1922,7 @@ pub fn type_is_boxed(ty: t) -> bool {\n \n pub fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_rptr(_, mt) => match get(mt.ty).sty {\n-            // FIXME(nrc, DST) slices weren't regarded as rptrs, so we preserve this\n-            // odd behaviour for now. (But ~[] were unique. I have no idea why).\n-            ty_vec(_, None) | ty_str | ty_trait(..) => false,\n-            _ => true\n-        },\n+        ty_rptr(..) => true,\n         _ => false\n     }\n }\n@@ -1842,6 +1944,13 @@ pub fn type_is_unique(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_rptr(_, mt{ty, ..}) | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n+        _ => false,\n+    }\n+}\n+\n /*\n  A scalar type is one that denotes an atomic datum, with no sub-components.\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n@@ -2233,7 +2342,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             // Scalar and unique types are sendable, and durable\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(_) | ty::ty_char | ty_str => {\n+            ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n             }\n \n@@ -2268,10 +2377,15 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_vec(mt, _) => {\n-                tc_mt(cx, mt, cache)\n+            ty_vec(t, Some(_)) => {\n+                tc_ty(cx, t, cache)\n             }\n \n+            ty_vec(t, None) => {\n+                tc_ty(cx, t, cache) | TC::Nonsized\n+            }\n+            ty_str => TC::Nonsized,\n+\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n@@ -2371,14 +2485,20 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 kind_bounds_to_contents(cx,\n                                         tp_def.bounds.builtin_bounds,\n                                         tp_def.bounds.trait_bounds.as_slice())\n-            }\n+           }\n \n             ty_infer(_) => {\n                 // This occurs during coherence, but shouldn't occur at other\n                 // times.\n                 TC::All\n             }\n \n+            ty_open(t) => {\n+                let result = tc_ty(cx, t, cache);\n+                assert!(!result.is_sized(cx))\n+                result.unsafe_pointer() | TC::Nonsized\n+            }\n+\n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n             }\n@@ -2540,7 +2660,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             // normal vectors, since they don't necessarily have the\n             // possibility to have length zero.\n             ty_vec(_, Some(0)) => false, // don't need no contents\n-            ty_vec(mt, Some(_)) => type_requires(cx, seen, r_ty, mt.ty),\n+            ty_vec(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n \n             ty_nil |\n             ty_bot |\n@@ -2558,7 +2678,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_vec(_, None) => {\n                 false\n             }\n-            ty_box(typ) | ty_uniq(typ) => {\n+            ty_box(typ) | ty_uniq(typ) | ty_open(typ) => {\n                 type_requires(cx, seen, r_ty, typ)\n             }\n             ty_rptr(_, ref mt) => {\n@@ -2681,8 +2801,8 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n-            ty_vec(mt, Some(_)) => {\n-                type_structurally_recursive(cx, sp, seen, mt.ty)\n+            ty_vec(ty, Some(_)) => {\n+                type_structurally_recursive(cx, sp, seen, ty)\n             }\n \n             // Push struct and enum def-ids onto `seen` before recursing.\n@@ -2801,11 +2921,40 @@ pub fn type_is_machine(ty: t) -> bool {\n }\n \n // Is the type's representation size known at compile time?\n-#[allow(dead_code)] // leaving in for DST\n-pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n+pub fn type_is_sized(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).is_sized(cx)\n }\n \n+pub fn lltype_is_sized(cx: &ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_open(_) => true,\n+        _ => type_contents(cx, ty).is_sized(cx)\n+    }\n+}\n+\n+// Return the smallest part of t which is unsized. Fails if t is sized.\n+// 'Smallest' here means component of the static representation of the type; not\n+// the size of an object at runtime.\n+pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n+    match get(ty).sty {\n+        ty_str | ty_trait(..) | ty_vec(..) => ty,\n+        ty_struct(_, ref substs) => {\n+            // Exactly one of the type parameters must be unsized.\n+            for tp in substs.types.get_slice(subst::TypeSpace).iter() {\n+                if !type_is_sized(cx, *tp) {\n+                    return unsized_part_of_type(cx, *tp);\n+                }\n+            }\n+            fail!(\"Unsized struct type with no unsized type params? {}\", ty_to_string(cx, ty));\n+        }\n+        _ => {\n+            assert!(type_is_sized(cx, ty),\n+                    \"unsized_part_of_type failed even though ty is unsized\");\n+            fail!(\"called unsized_part_of_type with sized ty\");\n+        }\n+    }\n+}\n+\n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n@@ -2828,49 +2977,68 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     match get(t).sty {\n-        ty_box(typ) | ty_uniq(typ) => match get(typ).sty {\n-            // Don't deref ~[] etc., might need to generalise this to all DST.\n-            ty_vec(_, None) | ty_str | ty_trait(..) => None,\n-            _ => Some(mt {\n-                ty: typ,\n+        ty_box(ty) | ty_uniq(ty) => {\n+            Some(mt {\n+                ty: ty,\n                 mutbl: ast::MutImmutable,\n-            }),\n-        },\n-        ty_rptr(_, mt) => match get(mt.ty).sty {\n-            // Don't deref &[], might need to generalise this to all DST.\n-            ty_vec(_, None) | ty_str | ty_trait(..) => None,\n-            _ => Some(mt),\n+            })\n         },\n+        ty_rptr(_, mt) => Some(mt),\n         ty_ptr(mt) if explicit => Some(mt),\n         _ => None\n     }\n }\n \n-// Returns the type of t[i]\n-pub fn index(t: t) -> Option<mt> {\n+pub fn deref_or_dont(t: t) -> t {\n     match get(t).sty {\n-        ty_vec(mt, Some(_)) => Some(mt),\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_box(t) | ty_uniq(t) => match get(t).sty {\n-            ty_vec(mt, None) => Some(mt),\n-            _ => None,\n+        ty_box(ty) | ty_uniq(ty) => {\n+            ty\n         },\n+        ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n+        _ => t\n+    }\n+}\n+\n+pub fn close_type(cx: &ctxt, t: t) -> t {\n+    match get(t).sty {\n+        ty_open(t) => mk_rptr(cx, ReStatic, mt {ty: t, mutbl:ast::MutImmutable}),\n+        _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n+                                 ty_to_string(cx, t)).as_slice())\n+    }\n+}\n+\n+pub fn type_content(t: t) -> t {\n+    match get(t).sty {\n+        ty_box(ty) | ty_uniq(ty) => ty,\n+        ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n+        _ => t\n+    }\n+\n+}\n+\n+// Extract the unsized type in an open type (or just return t if it is not open).\n+pub fn unopen_type(t: t) -> t {\n+    match get(t).sty {\n+        ty_open(t) => t,\n+        _ => t\n+    }\n+}\n+\n+// Returns the type of t[i]\n+pub fn index(ty: t) -> Option<t> {\n+    match get(ty).sty {\n+        ty_vec(t, _) => Some(t),\n         _ => None\n     }\n }\n \n // Returns the type of elements contained within an 'array-like' type.\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n-pub fn array_element_ty(t: t) -> Option<mt> {\n+pub fn array_element_ty(t: t) -> Option<t> {\n     match get(t).sty {\n-        ty_vec(mt, Some(_)) => Some(mt),\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_box(t) | ty_uniq(t) => match get(t).sty {\n-            ty_vec(mt, None) => Some(mt),\n-            ty_str => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n-            _ => None,\n-        },\n+        ty_vec(t, _) => Some(t),\n+        ty_str => Some(mk_u8()),\n         _ => None\n     }\n }\n@@ -3153,126 +3321,83 @@ pub fn adjust_ty(cx: &ctxt,\n \n                     match adj.autoref {\n                         None => adjusted_ty,\n-                        Some(ref autoref) => {\n-                            match *autoref {\n-                                AutoPtr(r, m) => {\n-                                    mk_rptr(cx, r, mt {\n-                                        ty: adjusted_ty,\n-                                        mutbl: m\n-                                    })\n-                                }\n-\n-                                AutoBorrowVec(r, m) => {\n-                                    borrow_vec(cx, span, r, m, adjusted_ty)\n-                                }\n-\n-                                AutoBorrowVecRef(r, m) => {\n-                                    adjusted_ty = borrow_vec(cx,\n-                                                             span,\n-                                                             r,\n-                                                             m,\n-                                                             adjusted_ty);\n-                                    mk_rptr(cx, r, mt {\n-                                        ty: adjusted_ty,\n-                                        mutbl: ast::MutImmutable\n-                                    })\n-                                }\n-\n-                                AutoUnsafe(m) => {\n-                                    mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n-                                }\n-\n-                                AutoBorrowObj(r, m) => {\n-                                    borrow_obj(cx, span, r, m, adjusted_ty)\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                AutoObject(store, bounds, def_id, ref substs) => {\n-\n-                    let tr = mk_trait(cx, def_id, substs.clone(), bounds);\n-                    match store {\n-                        UniqTraitStore => {\n-                            mk_uniq(cx, tr)\n-                        }\n-                        RegionTraitStore(r, m) => {\n-                            mk_rptr(cx, r, mt {\n-                                ty: tr,\n-                                mutbl: m\n-                            })\n-                        }\n+                        Some(ref autoref) => adjust_for_autoref(cx, span, adjusted_ty, autoref)\n                     }\n                 }\n             }\n         }\n         None => unadjusted_ty\n     };\n \n-    fn borrow_vec(cx: &ctxt,\n-                  span: Span,\n-                  r: Region,\n-                  m: ast::Mutability,\n-                  ty: ty::t) -> ty::t {\n-        match get(ty).sty {\n-            ty_uniq(t) | ty_ptr(mt{ty: t, ..}) |\n-            ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n-                ty::ty_vec(mt, None) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n-                ty::ty_str => ty::mk_str_slice(cx, r, m),\n-                _ => {\n-                    cx.sess.span_bug(\n-                        span,\n-                        format!(\"borrow-vec associated with bad sty: {:?}\",\n-                                get(ty).sty).as_slice());\n-                }\n-            },\n-            ty_vec(mt, Some(_)) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n+    fn adjust_for_autoref(cx: &ctxt,\n+                          span: Span,\n+                          ty: ty::t,\n+                          autoref: &AutoRef) -> ty::t{\n+        match *autoref {\n+            AutoPtr(r, m, ref a) => {\n+                let adjusted_ty = match a {\n+                    &Some(box ref a) => adjust_for_autoref(cx, span, ty, a),\n+                    &None => ty\n+                };\n+                mk_rptr(cx, r, mt {\n+                    ty: adjusted_ty,\n+                    mutbl: m\n+                })\n+            }\n \n-            ref s => {\n-                cx.sess.span_bug(\n-                    span,\n-                    format!(\"borrow-vec associated with bad sty: {:?}\",\n-                            s).as_slice());\n+            AutoUnsafe(m) => {\n+                mk_ptr(cx, mt {ty: ty, mutbl: m})\n             }\n+\n+            AutoUnsize(ref k) => unsize_ty(cx, ty, k, span),\n+            AutoUnsizeUniq(ref k) => ty::mk_uniq(cx, unsize_ty(cx, ty, k, span)),\n         }\n     }\n+}\n \n-    fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n-                  m: ast::Mutability, ty: ty::t) -> ty::t {\n-        match get(ty).sty {\n-            ty_uniq(t) | ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n-                ty_trait(box ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n-                    mk_rptr(cx, r, mt {\n-                        ty: ty::mk_trait(cx, def_id, substs.clone(), bounds),\n-                        mutbl: m\n-                    })\n-                }\n-                _ => {\n-                    cx.sess.span_bug(\n-                        span,\n-                        format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n-                                get(ty).sty).as_slice());\n-                }\n-            },\n-            ref s => {\n-                cx.sess.span_bug(\n-                    span,\n-                    format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n-                            s).as_slice());\n+// Take a sized type and a sizing adjustment and produce an unsized version of\n+// the type.\n+pub fn unsize_ty(cx: &ctxt,\n+                 ty: ty::t,\n+                 kind: &UnsizeKind,\n+                 span: Span)\n+                 -> ty::t {\n+    match kind {\n+        &UnsizeLength(len) => match get(ty).sty {\n+            ty_vec(t, Some(n)) => {\n+                assert!(len == n);\n+                mk_vec(cx, t, None)\n+            }\n+            _ => cx.sess.span_bug(span,\n+                                  format!(\"UnsizeLength with bad sty: {}\",\n+                                          ty_to_string(cx, ty)).as_slice())\n+        },\n+        &UnsizeStruct(box ref k, tp_index) => match get(ty).sty {\n+            ty_struct(did, ref substs) => {\n+                let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                let new_ty = unsize_ty(cx, ty_substs[tp_index], k, span);\n+                let mut unsized_substs = substs.clone();\n+                unsized_substs.types.get_mut_slice(subst::TypeSpace)[tp_index] = new_ty;\n+                mk_struct(cx, did, unsized_substs)\n             }\n+            _ => cx.sess.span_bug(span,\n+                                  format!(\"UnsizeStruct with bad sty: {}\",\n+                                          ty_to_string(cx, ty)).as_slice())\n+        },\n+        &UnsizeVtable(bounds, def_id, ref substs) => {\n+            mk_trait(cx, def_id, substs.clone(), bounds)\n         }\n     }\n }\n \n impl AutoRef {\n     pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n         match *self {\n-            ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n-            ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n-            ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(f(r), m),\n+            ty::AutoPtr(r, m, None) => ty::AutoPtr(f(r), m, None),\n+            ty::AutoPtr(r, m, Some(ref a)) => ty::AutoPtr(f(r), m, Some(box a.map_region(f))),\n+            ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n+            ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n             ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n-            ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(f(r), m),\n         }\n     }\n }\n@@ -3423,8 +3548,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnboxedFn(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n-        ast::ExprVstore(_, ast::ExprVstoreSlice) |\n-        ast::ExprVstore(_, ast::ExprVstoreMutSlice) |\n         ast::ExprVec(..) => {\n             RvalueDpsExpr\n         }\n@@ -3474,8 +3597,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprLit(_) | // Note: LitStr is carved out above\n         ast::ExprUnary(..) |\n         ast::ExprAddrOf(..) |\n-        ast::ExprBinary(..) |\n-        ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n+        ast::ExprBinary(..) => {\n             RvalueDatumExpr\n         }\n \n@@ -3580,6 +3702,7 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n             }\n         }\n         ty_err => \"type error\".to_string(),\n+        ty_open(_) => \"opened DST\".to_string(),\n     }\n }\n \n@@ -4941,15 +5064,12 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_uniq(_) => {\n                 byte!(10);\n             }\n-            ty_vec(m, Some(n)) => {\n+            ty_vec(_, Some(n)) => {\n                 byte!(11);\n-                mt(&mut state, m);\n                 n.hash(&mut state);\n-                1u8.hash(&mut state);\n             }\n-            ty_vec(m, None) => {\n+            ty_vec(_, None) => {\n                 byte!(11);\n-                mt(&mut state, m);\n                 0u8.hash(&mut state);\n             }\n             ty_ptr(m) => {\n@@ -4998,6 +5118,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                 hash!(p.idx);\n                 did(&mut state, p.def_id);\n             }\n+            ty_open(_) => byte!(22),\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n             ty_unboxed_closure(d, r) => {\n@@ -5220,6 +5341,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_tup(_) |\n             ty_param(_) |\n             ty_infer(_) |\n+            ty_open(_) |\n             ty_err => {}\n         }\n     })"}, {"sha": "2bfbc67bbeb0f93fd87acc8f301640ccc446462c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -273,6 +273,18 @@ impl TypeFoldable for ty::Generics {\n     }\n }\n \n+impl TypeFoldable for ty::UnsizeKind {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::UnsizeKind {\n+        match *self {\n+            ty::UnsizeLength(len) => ty::UnsizeLength(len),\n+            ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n+            ty::UnsizeVtable(bounds, def_id, ref substs) => {\n+                ty::UnsizeVtable(bounds.fold_with(folder), def_id, substs.fold_with(folder))\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n@@ -360,8 +372,11 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_ptr(ref tm) => {\n             ty::ty_ptr(tm.fold_with(this))\n         }\n-        ty::ty_vec(ref tm, sz) => {\n-            ty::ty_vec(tm.fold_with(this), sz)\n+        ty::ty_vec(typ, sz) => {\n+            ty::ty_vec(typ.fold_with(this), sz)\n+        }\n+        ty::ty_open(typ) => {\n+            ty::ty_open(typ.fold_with(this))\n         }\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, substs.fold_with(this))\n@@ -420,11 +435,13 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n                                         -> ty::AutoRef\n {\n     match *autoref {\n-        ty::AutoPtr(r, m) => ty::AutoPtr(r.fold_with(this), m),\n-        ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(r.fold_with(this), m),\n-        ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(r.fold_with(this), m),\n+        ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n+        ty::AutoPtr(r, m, Some(ref a)) => {\n+            ty::AutoPtr(this.fold_region(r), m, Some(box super_fold_autoref(this, &**a)))\n+        }\n         ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n-        ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(r.fold_with(this), m),\n+        ty::AutoUnsize(ref k) => ty::AutoUnsize(k.fold_with(this)),\n+        ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.fold_with(this)),\n     }\n }\n "}, {"sha": "08e78b35e4d58c83dda4289d36a92756a90dc7e0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 42, "deletions": 76, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -398,10 +398,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                             Some(ty::mk_mach_float(ft))\n                         }\n                         ast::TyStr => {\n-                            span_err!(tcx.sess, ast_ty.span, E0037,\n-                                      \"bare `str` is not a type\");\n-                            // return /something/ so they can at least get more errors\n-                            Some(ty::mk_uniq(tcx, ty::mk_str(tcx)))\n+                            Some(ty::mk_str(tcx))\n                         }\n                     }\n                 }\n@@ -462,21 +459,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                                rscope,\n                                                &mt,\n                                                Uniq,\n-                                               |typ| {\n-                            match ty::get(typ).sty {\n-                                ty::ty_str => {\n-                                    span_err!(this.tcx().sess, path.span, E0111,\n-                                              \"`Box<str>` is not a type\");\n-                                    ty::mk_err()\n-                                }\n-                                ty::ty_vec(_, None) => {\n-                                        span_err!(this.tcx().sess, path.span, E0112,\n-                                                  \"`Box<[T]>` is not a type\");\n-                                    ty::mk_err()\n-                                }\n-                                _ => ty::mk_uniq(this.tcx(), typ),\n-                            }\n-                        }))\n+                                               |typ| ty::mk_uniq(this.tcx(), typ)));\n                     }\n                     span_err!(this.tcx().sess, path.span, E0113,\n                               \"not enough type parameters supplied to `Box<T>`\");\n@@ -537,12 +520,6 @@ enum PointerTy {\n     Uniq\n }\n \n-fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n-                                            rscope: &RS,\n-                                            ty: &ast::Ty) -> ty::mt {\n-    ty::mt {ty: ast_ty_to_ty(this, rscope, ty), mutbl: ast::MutImmutable}\n-}\n-\n pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                                       RS:RegionScope>(\n                                       this: &AC,\n@@ -601,11 +578,8 @@ fn mk_pointer<AC:AstConv,\n \n     match a_seq_ty.ty.node {\n         ast::TyVec(ref ty) => {\n-            let mut mt = ast_ty_to_mt(this, rscope, &**ty);\n-            if a_seq_ty.mutbl == ast::MutMutable {\n-                mt.mutbl = ast::MutMutable;\n-            }\n-            return constr(ty::mk_vec(tcx, mt, None));\n+            let ty = ast_ty_to_ty(this, rscope, &**ty);\n+            return constr(ty::mk_vec(tcx, ty, None));\n         }\n         ast::TyUnboxedFn(ref unboxed_function) => {\n             let ty::TraitRef {\n@@ -662,37 +636,33 @@ fn mk_pointer<AC:AstConv,\n                 Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(\n                         this, rscope, trait_def_id, None, path);\n-                    let trait_store = match ptr_ty {\n-                        Uniq => ty::UniqTraitStore,\n-                        RPtr(r) => {\n-                            ty::RegionTraitStore(r, a_seq_ty.mutbl)\n-                        }\n-                        _ => {\n-                            tcx.sess.span_err(\n-                                path.span,\n-                                \"~trait or &trait are the only supported \\\n-                                 forms of casting-to-trait\");\n-                            return ty::mk_err();\n-                        }\n+                    let static_region = match ptr_ty {\n+                        RPtr(r) if r == ty::ReStatic => true,\n+                        _ => false\n                     };\n                     let bounds = conv_builtin_bounds(this.tcx(),\n                                                      path.span,\n                                                      bounds,\n-                                                     trait_store);\n+                                                     static_region);\n                     let tr = ty::mk_trait(tcx,\n                                           result.def_id,\n                                           result.substs.clone(),\n                                           bounds);\n-                    // We could just match on ptr_ty, but we need to pass a trait\n-                    // store to conv_builtin_bounds, so mathc twice for now.\n-                    return match trait_store {\n-                        ty::UniqTraitStore => {\n+                    return match ptr_ty {\n+                        Uniq => {\n                             return ty::mk_uniq(tcx, tr);\n                         }\n-                        ty::RegionTraitStore(r, m) => {\n-                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: m, ty: tr});\n+                        RPtr(r) => {\n+                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_ty.mutbl, ty: tr});\n                         }\n-                    }\n+                        _ => {\n+                            tcx.sess.span_err(\n+                                path.span,\n+                                \"~trait or &trait are the only supported \\\n+                                 forms of casting-to-trait\");\n+                            return ty::mk_err();\n+                        }\n+                    };\n                 }\n                 _ => {}\n             }\n@@ -738,10 +708,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                            |ty| ty::mk_uniq(tcx, ty))\n             }\n             ast::TyVec(ty) => {\n-                tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n-                // return /something/ so they can at least get more errors\n-                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty), None);\n-                ty::mk_uniq(tcx, vec_ty)\n+                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty), None)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n@@ -777,15 +744,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 let bound_region = opt_ast_region_to_region(this, rscope,\n                                                             ast_ty.span, region);\n \n-                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n-\n                 // Use corresponding trait store to figure out default bounds\n                 // if none were specified.\n                 let bounds = conv_builtin_bounds(this.tcx(),\n                                                  ast_ty.span,\n                                                  &f.bounds,\n-                                                 store);\n+                                                 bound_region == ty::ReStatic);\n \n+                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n                 let fn_decl = ty_of_closure(this,\n                                             ast_ty.id,\n                                             f.fn_style,\n@@ -803,7 +769,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 let bounds = conv_builtin_bounds(this.tcx(),\n                                                  ast_ty.span,\n                                                  &f.bounds,\n-                                                 ty::UniqTraitStore);\n+                                                 false);\n \n                 let fn_decl = ty_of_closure(this,\n                                             ast_ty.id,\n@@ -841,15 +807,17 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     _ => { },\n                 }\n                 match a_def {\n-                    def::DefTrait(_) => {\n-                        let path_str = path_to_string(path);\n-                        tcx.sess.span_err(\n-                            ast_ty.span,\n-                            format!(\"reference to trait `{name}` where a \\\n-                                     type is expected; try `Box<{name}>` or \\\n-                                     `&{name}`\",\n-                                    name=path_str).as_slice());\n-                        ty::mk_err()\n+                    def::DefTrait(trait_def_id) => {\n+                    let result = ast_path_to_trait_ref(\n+                        this, rscope, trait_def_id, None, path);\n+                    let bounds = conv_builtin_bounds(this.tcx(),\n+                                                     path.span,\n+                                                     bounds,\n+                                                     false);\n+                    ty::mk_trait(tcx,\n+                                 result.def_id,\n+                                 result.substs.clone(),\n+                                 bounds)\n                     }\n                     def::DefTy(did) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n@@ -887,10 +855,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -1211,7 +1179,7 @@ pub fn ty_of_closure<AC:AstConv>(\n fn conv_builtin_bounds(tcx: &ty::ctxt,\n                        span: Span,\n                        ast_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n-                       store: ty::TraitStore)\n+                       static_region: bool)\n                        -> ty::BuiltinBounds {\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`\n     //! struct. Reports an error if any of the bounds that appear\n@@ -1224,8 +1192,8 @@ fn conv_builtin_bounds(tcx: &ty::ctxt,\n     //! override this with an empty bounds list, e.g. \"Box<fn:()>\" or\n     //! \"Box<Trait:>\".\n \n-    match (ast_bounds, store) {\n-        (&Some(ref bound_vec), _) => {\n+    match ast_bounds {\n+        &Some(ref bound_vec) => {\n             let mut builtin_bounds = ty::empty_builtin_bounds();\n             for ast_bound in bound_vec.iter() {\n                 match *ast_bound {\n@@ -1265,12 +1233,10 @@ fn conv_builtin_bounds(tcx: &ty::ctxt,\n             builtin_bounds\n         },\n         // &'static Trait is sugar for &'static Trait:'static.\n-        (&None, ty::RegionTraitStore(ty::ReStatic, _)) => {\n+        &None if static_region => {\n             let mut set = ty::empty_builtin_bounds(); set.add(ty::BoundStatic); set\n         }\n-        // No bounds are automatically applied for &'r Trait or ~Trait\n-        (&None, ty::RegionTraitStore(..)) |\n-        (&None, ty::UniqTraitStore) => ty::empty_builtin_bounds(),\n+        &None => ty::empty_builtin_bounds(),\n     }\n }\n "}, {"sha": "77e5fbae6ee1cf53d108413029ae25642490f4f0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -658,26 +658,26 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         let (elt_type, region_var, mutbl, fixed) = match *structure_of(fcx,\n                                                                 pat.span,\n                                                                 expected) {\n-          ty::ty_vec(mt, Some(fixed)) =>\n-            (mt.ty, default_region_var, ast::MutImmutable, Some(fixed)),\n+          ty::ty_vec(ty, Some(fixed)) =>\n+            (ty, default_region_var, ast::MutImmutable, Some(fixed)),\n           ty::ty_uniq(t) => match ty::get(t).sty {\n-              ty::ty_vec(mt, None) => {\n+              ty::ty_vec(ty, None) => {\n                   fcx.type_error_message(pat.span,\n                                          |_| {\n                                             \"unique vector patterns are no \\\n                                              longer supported\".to_string()\n                                          },\n                                          expected,\n                                          None);\n-                  (mt.ty, default_region_var, ast::MutImmutable, None)\n+                  (ty, default_region_var, ast::MutImmutable, None)\n               }\n               _ => {\n                   check_err(\"a vector pattern\".to_string());\n                   return;\n               }\n           },\n           ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n-              ty::ty_vec(mt, None) => (mt.ty, r, mt.mutbl, None),\n+              ty::ty_vec(ty, None) => (ty, r, mt.mutbl, None),\n               _ => {\n                   check_err(\"a vector pattern\".to_string());\n                   return;"}, {"sha": "1b10b30b3358ee1194d0d90e10cbdf9c5eba4a62", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -77,3 +77,17 @@ pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n       }\n     }\n }\n+\n+pub fn coerce_with_fn(fcx: &FnCtxt,\n+                      sp: Span,\n+                      expected: ty::t,\n+                      expr: &ast::Expr,\n+                      handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n+    let expr_ty = fcx.expr_ty(expr);\n+    match fcx.mk_assignty(expr, expr_ty, expected) {\n+      result::Ok(()) => { /* ok */ }\n+      result::Err(ref err) => {\n+        handle_err(sp, expected, expr_ty, err);\n+      }\n+    }\n+}"}, {"sha": "6bb17c90da2694350428356402e206e920d1da0b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 95, "deletions": 71, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -356,23 +356,14 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n \n-        let (self_ty, autoderefs, result) =\n+        let (_, _, result) =\n             check::autoderef(\n                 self.fcx, span, self_ty, self_expr_id, PreferMutLvalue,\n                 |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n \n         match result {\n             Some(Some(result)) => Some(result),\n-            _ => {\n-                if self.is_overloaded_deref() {\n-                    // If we are searching for an overloaded deref, no\n-                    // need to try coercing a `~[T]` to an `&[T]` and\n-                    // searching for an overloaded deref on *that*.\n-                    None\n-                } else {\n-                    self.search_for_autosliced_method(self_ty, autoderefs)\n-                }\n-            }\n+            _ => None\n         }\n     }\n \n@@ -408,6 +399,16 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n+        // If we are searching for an overloaded deref, no\n+        // need to try coercing a `~[T]` to an `&[T]` and\n+        // searching for an overloaded deref on *that*.\n+        if !self.is_overloaded_deref() {\n+            match self.search_for_autofatptrd_method(self_ty, autoderefs) {\n+                Some(result) => return Some(Some(result)),\n+                None => {}\n+            }\n+        }\n+\n         // Don't autoderef if we aren't supposed to.\n         if self.autoderef_receiver == DontAutoderefReceiver {\n             Some(None)\n@@ -441,13 +442,10 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n-                ty_uniq(ty) | ty_rptr(_, mt {ty, ..}) => match get(ty).sty{\n-                    ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n-                        self.push_inherent_candidates_from_object(def_id, substs);\n-                        self.push_inherent_impl_candidates_for_type(def_id);\n-                    }\n-                    _ => {}\n-                },\n+                ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n+                    self.push_inherent_candidates_from_object(def_id, substs);\n+                    self.push_inherent_impl_candidates_for_type(def_id);\n+                }\n                 ty_enum(did, _) |\n                 ty_struct(did, _) |\n                 ty_unboxed_closure(did, _) => {\n@@ -830,23 +828,22 @@ impl<'a> LookupContext<'a> {\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n                                     -> Option<MethodCallee> {\n-        let (self_ty, auto_deref_ref) =\n-            self.consider_reborrow(self_ty, autoderefs);\n-\n         // Hacky. For overloaded derefs, there may be an adjustment\n         // added to the expression from the outside context, so we do not store\n         // an explicit adjustment, but rather we hardwire the single deref\n         // that occurs in trans and mem_categorization.\n-        let adjustment = match self.self_expr {\n-            Some(expr) => Some((expr.id, ty::AutoDerefRef(auto_deref_ref))),\n-            None => return None\n-        };\n+        if self.self_expr.is_none() {\n+            return None;\n+        }\n+\n+        let (self_ty, auto_deref_ref) = self.consider_reborrow(self_ty, autoderefs);\n+        let adjustment = Some((self.self_expr.unwrap().id, ty::AutoDerefRef(auto_deref_ref)));\n \n         match self.search_for_method(self_ty) {\n             None => None,\n             Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {:?} for {}\", adjustment, self.ty_to_string( self_ty));\n+                       adjustment {:?} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n                         self.fcx.write_adjustment(self_expr_id, adj);\n@@ -890,16 +887,10 @@ impl<'a> LookupContext<'a> {\n             ty::ty_rptr(_, self_mt) => {\n                 let region =\n                     self.infcx().next_region_var(infer::Autoref(self.span));\n-                let (extra_derefs, auto) = match ty::get(self_mt.ty).sty {\n-                    ty::ty_vec(_, None) => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n-                    ty::ty_str => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n-                    ty::ty_trait(..) => (0, ty::AutoBorrowObj(region, self_mt.mutbl)),\n-                    _ => (1, ty::AutoPtr(region, self_mt.mutbl)),\n-                };\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef {\n-                     autoderefs: autoderefs + extra_derefs,\n-                     autoref: Some(auto)})\n+                     autoderefs: autoderefs + 1,\n+                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl, None))})\n             }\n             _ => {\n                 (self_ty,\n@@ -920,26 +911,30 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn auto_slice_vec(&self, mt: ty::mt, autoderefs: uint) -> Option<MethodCallee> {\n+    // Takes an [T] - an unwrapped DST pointer (either ~ or &)\n+    // [T] to &[T] or &&[T] (note that we started with a &[T] or ~[T] which has\n+    // been implicitly derefed).\n+    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n         let tcx = self.tcx();\n-        debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, mt.ty));\n+        debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n         // First try to borrow to a slice\n         let entry = self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n+            |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable, MutMutable],\n             |m,r| ty::mk_slice(tcx, r,\n-                               ty::mt {ty:mt.ty, mutbl:m}));\n+                               ty::mt {ty:ty, mutbl:m}));\n \n         if entry.is_some() {\n             return entry;\n         }\n \n         // Then try to borrow to a slice *and* borrow a pointer.\n         self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n-            |m,r| {\n+            |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |m, r| {\n                 let slice_ty = ty::mk_slice(tcx, r,\n-                                            ty::mt {ty:mt.ty, mutbl:m});\n+                                            ty::mt {ty:ty, mutbl:m});\n                 // NB: we do not try to autoref to a mutable\n                 // pointer. That would be creating a pointer\n                 // to a temporary pointer (the borrowed\n@@ -949,29 +944,67 @@ impl<'a> LookupContext<'a> {\n             })\n     }\n \n+    // [T, ..len] -> [T] or &[T] or &&[T]\n+    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodCallee> {\n+        let tcx = self.tcx();\n+        debug!(\"auto_unsize_vec {}\", ppaux::ty_to_string(tcx, ty));\n+\n+        // First try to borrow to an unsized vec.\n+        let entry = self.search_for_some_kind_of_autorefd_method(\n+            |_r, _m| AutoUnsize(ty::UnsizeLength(len)),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |_m, _r| ty::mk_vec(tcx, ty, None));\n+\n+        if entry.is_some() {\n+            return entry;\n+        }\n+\n+        // Then try to borrow to a slice.\n+        let entry = self.search_for_some_kind_of_autorefd_method(\n+            |r, m| AutoPtr(r, m, Some(box AutoUnsize(ty::UnsizeLength(len)))),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |m, r|  ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m}));\n+\n+        if entry.is_some() {\n+            return entry;\n+        }\n+\n+        // Then try to borrow to a slice *and* borrow a pointer.\n+        self.search_for_some_kind_of_autorefd_method(\n+            |r, m| AutoPtr(r, m,\n+                           Some(box AutoPtr(r, m,\n+                                            Some(box AutoUnsize(ty::UnsizeLength(len)))))),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |m, r| {\n+                let slice_ty = ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m});\n+                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n+            })\n+    }\n \n     fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodCallee> {\n         let tcx = self.tcx();\n         debug!(\"auto_slice_str\");\n \n         let entry = self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVec, autoderefs, [MutImmutable],\n-            |_m,r| ty::mk_str_slice(tcx, r, MutImmutable));\n+            |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable],\n+            |_m, r| ty::mk_str_slice(tcx, r, MutImmutable));\n \n         if entry.is_some() {\n             return entry;\n         }\n \n         self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVecRef, autoderefs, [MutImmutable],\n-            |m,r| {\n+            |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n+            autoderefs, [MutImmutable],\n+            |m, r| {\n                 let slice_ty = ty::mk_str_slice(tcx, r, m);\n                 ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n             })\n     }\n \n     // Coerce Box/&Trait instances to &Trait.\n     fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+        debug!(\"auto_slice_trait\");\n         match ty::get(ty).sty {\n             ty_trait(box ty::TyTrait {\n                     def_id: trt_did,\n@@ -980,7 +1013,8 @@ impl<'a> LookupContext<'a> {\n                     .. }) => {\n                 let tcx = self.tcx();\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n+                    |r, m| AutoPtr(r, m, None),\n+                    autoderefs, [MutImmutable, MutMutable],\n                     |m, r| {\n                         let tr = ty::mk_trait(tcx, trt_did, trt_substs.clone(), b);\n                         ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: m })\n@@ -990,31 +1024,24 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn search_for_autosliced_method(&self,\n-                                    self_ty: ty::t,\n-                                    autoderefs: uint)\n-                                    -> Option<MethodCallee> {\n+    fn search_for_autofatptrd_method(&self,\n+                                     self_ty: ty::t,\n+                                     autoderefs: uint)\n+                                     -> Option<MethodCallee> {\n         /*!\n          * Searches for a candidate by converting things like\n          * `~[]` to `&[]`.\n          */\n \n-        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_string(self.tcx(), self_ty));\n+        let tcx = self.tcx();\n+        debug!(\"search_for_autofatptrd_method {}\", ppaux::ty_to_string(tcx, self_ty));\n \n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-                ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n-                ty_trait(..) => self.auto_slice_trait(mt.ty, autoderefs),\n-                _ => None\n-            },\n-            ty_uniq(t) => match ty::get(t).sty {\n-                ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n-                ty_str => self.auto_slice_str(autoderefs),\n-                ty_trait(..) => self.auto_slice_trait(t, autoderefs),\n-                _ => None\n-            },\n-            ty_vec(mt, Some(_)) => self.auto_slice_vec(mt, autoderefs),\n+            ty_vec(ty, Some(len)) => self.auto_unsize_vec(ty, autoderefs, len),\n+            ty_vec(ty, None) => self.auto_slice_vec(ty, autoderefs),\n+            ty_str => self.auto_slice_str(autoderefs),\n+            ty_trait(..) => self.auto_slice_trait(self_ty, autoderefs),\n \n             ty_closure(..) => {\n                 // This case should probably be handled similarly to\n@@ -1042,10 +1069,10 @@ impl<'a> LookupContext<'a> {\n             ty_param(..) | ty_nil | ty_bot | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n-            ty_unboxed_closure(..) | ty_tup(..) |\n+            ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |\n             ty_str | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoPtr, autoderefs, [MutImmutable, MutMutable],\n+                    |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n@@ -1073,8 +1100,8 @@ impl<'a> LookupContext<'a> {\n             Some(expr) => Some(expr.id),\n             None => {\n                 assert_eq!(autoderefs, 0);\n-                assert_eq!(kind(ty::ReEmpty, ast::MutImmutable),\n-                           ty::AutoPtr(ty::ReEmpty, ast::MutImmutable));\n+                assert!(kind(ty::ReEmpty, ast::MutImmutable) ==\n+                        ty::AutoPtr(ty::ReEmpty, ast::MutImmutable, None));\n                 None\n             }\n         };\n@@ -1442,17 +1469,15 @@ impl<'a> LookupContext<'a> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         match ty::get(mt.ty).sty {\n-                            ty::ty_vec(_, None) | ty::ty_str => false,\n                             ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n                                 mutability_matches(mt.mutbl, m) &&\n                                 rcvr_matches_object(self_did, candidate)\n                             }\n                             _ => mutability_matches(mt.mutbl, m) &&\n-                                 rcvr_matches_ty(self.fcx, mt.ty, candidate),\n+                                 rcvr_matches_ty(self.fcx, mt.ty, candidate)\n                         }\n                     }\n \n-\n                     _ => false\n                 }\n             }\n@@ -1462,7 +1487,6 @@ impl<'a> LookupContext<'a> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n                         match ty::get(typ).sty {\n-                            ty::ty_vec(_, None) | ty::ty_str => false,\n                             ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n                                 rcvr_matches_object(self_did, candidate)\n                             }"}, {"sha": "02464e17bac84e41963d20e80538b7f0366d9b97", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 175, "deletions": 209, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -560,21 +560,6 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n \n     check_block_with_expected(&fcx, body, ExpectHasType(ret_ty));\n \n-    // We unify the tail expr's type with the\n-    // function result type, if there is a tail expr.\n-    match body.expr {\n-        Some(ref tail_expr) => {\n-            // Special case: we print a special error if there appears\n-            // to be do-block/for-loop confusion\n-            demand::suptype_with_fn(&fcx, tail_expr.span, false,\n-                fcx.ret_ty, fcx.expr_ty(&**tail_expr),\n-                |sp, e, a, s| {\n-                    fcx.report_mismatched_return_types(sp, e, a, s);\n-                });\n-        }\n-        None => {}\n-    }\n-\n     for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n         fcx.write_ty(input.id, *arg);\n     }\n@@ -1164,7 +1149,7 @@ fn check_cast(fcx: &FnCtxt,\n     if ty::type_is_scalar(t_1) {\n         // Supply the type as a hint so as to influence integer\n         // literals and other things that might care.\n-        check_expr_with_hint(fcx, e, t_1)\n+        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1))\n     } else {\n         check_expr(fcx, e)\n     }\n@@ -2048,7 +2033,6 @@ fn check_argument_types(fcx: &FnCtxt,\n                 }\n \n                 check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n-\n             }\n         }\n     }\n@@ -2436,8 +2420,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // The tightest thing we can say is \"must unify with\n                 // else branch\". Note that in the case of a \"has type\"\n                 // constraint, this limitation does not hold.\n-                let expected = expected.only_has_type();\n \n+                // If the expected type is just a type variable, then don't use\n+                // an expected type. Otherwise, we might write parts of the type\n+                // when checking the 'then' block which are incompatible with the\n+                // 'else' branch.\n+                let expected = match expected.only_has_type() {\n+                    ExpectHasType(ety) => {\n+                        match infer::resolve_type(fcx.infcx(), Some(sp), ety, force_tvar) {\n+                            Ok(rty) if !ty::type_is_ty_var(rty) => ExpectHasType(rty),\n+                            _ => NoExpectation\n+                        }\n+                    }\n+                    _ => NoExpectation\n+                };\n                 check_block_with_expected(fcx, then_blk, expected);\n                 let then_ty = fcx.node_ty(then_blk.id);\n                 check_expr_with_expectation(fcx, &**else_expr, expected);\n@@ -3070,96 +3066,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, ty::t);\n \n-    fn check_fn_for_vec_elements_expected(fcx: &FnCtxt,\n-                                          expected: Expectation)\n-                                         -> (ExprCheckerWithTy, ty::t) {\n-        let tcx = fcx.ccx.tcx;\n-        let (coerce, t) = match expected {\n-            // If we're given an expected type, we can try to coerce to it\n-            ExpectHasType(t) if ty::type_is_vec(t) => (true, ty::sequence_element_type(tcx, t)),\n-            // Otherwise we just leave the type to be resolved later\n-            _ => (false, fcx.infcx().next_ty_var())\n-        };\n-        if coerce {\n-            (check_expr_coercable_to_type, t)\n-        } else {\n-            (check_expr_has_type, t)\n-        }\n-    }\n-\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n-        ast::ExprVstore(ev, vst) => {\n-            let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n-            let typ = match ev.node {\n-                ast::ExprVec(ref args) => {\n-                    let mutability = match vst {\n-                        ast::ExprVstoreMutSlice => ast::MutMutable,\n-                        _ => ast::MutImmutable,\n-                    };\n-                    let mut any_error = false;\n-                    let mut any_bot = false;\n-                    for e in args.iter() {\n-                        check(fcx, &**e, t);\n-                        let arg_t = fcx.expr_ty(&**e);\n-                        if ty::type_is_error(arg_t) {\n-                            any_error = true;\n-                        }\n-                        else if ty::type_is_bot(arg_t) {\n-                            any_bot = true;\n-                        }\n-                    }\n-                    if any_error {\n-                        ty::mk_err()\n-                    } else if any_bot {\n-                        ty::mk_bot()\n-                    } else {\n-                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n-                            ty::mt{ ty: ty::mk_vec(tcx,\n-                                                   ty::mt {ty: t, mutbl: mutability},\n-                                                   None),\n-                                                   mutbl: mutability })\n-                    }\n-                }\n-                ast::ExprRepeat(ref element, ref count_expr) => {\n-                    check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n-                    let _ = ty::eval_repeat_count(fcx, &**count_expr);\n-                    let mutability = match vst {\n-                        ast::ExprVstoreMutSlice => ast::MutMutable,\n-                        _ => ast::MutImmutable,\n-                    };\n-                    check(fcx, &**element, t);\n-                    let arg_t = fcx.expr_ty(&**element);\n-                    if ty::type_is_error(arg_t) {\n-                        ty::mk_err()\n-                    } else if ty::type_is_bot(arg_t) {\n-                        ty::mk_bot()\n-                    } else {\n-                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n-                            ty::mt{ ty: ty::mk_vec(tcx,\n-                                                   ty::mt {ty: t, mutbl: mutability},\n-                                                   None),\n-                                                   mutbl: mutability})\n-                    }\n-                }\n-                ast::ExprLit(_) => {\n-                    if vst == ast::ExprVstoreSlice {\n-                        span_err!(tcx.sess, expr.span, E0064,\n-                            \"`&\\\"string\\\"` has been removed; use `\\\"string\\\"` instead\");\n-                    } else {\n-                        span_err!(tcx.sess, expr.span, E0065,\n-                            \"`box \\\"string\\\"` has been removed; use \\\n-                             `\\\"string\\\".to_string()` instead\");\n-                    }\n-                    ty::mk_err()\n-                }\n-                _ => tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\"),\n-            };\n-            fcx.write_ty(ev.id, typ);\n-            fcx.write_ty(id, typ);\n-        }\n-\n       ast::ExprBox(ref place, ref subexpr) => {\n           check_expr(fcx, &**place);\n           check_expr(fcx, &**subexpr);\n@@ -3230,7 +3139,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let expected = expected.only_has_type();\n         let expected_inner = expected.map(fcx, |sty| {\n             match unop {\n                 ast::UnBox | ast::UnUniq => match *sty {\n@@ -3337,30 +3245,38 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                     hint,\n                                                     lvalue_pref);\n \n-        // Note: at this point, we cannot say what the best lifetime\n-        // is to use for resulting pointer.  We want to use the\n-        // shortest lifetime possible so as to avoid spurious borrowck\n-        // errors.  Moreover, the longest lifetime will depend on the\n-        // precise details of the value whose address is being taken\n-        // (and how long it is valid), which we don't know yet until type\n-        // inference is complete.\n-        //\n-        // Therefore, here we simply generate a region variable.  The\n-        // region inferencer will then select the ultimate value.\n-        // Finally, borrowck is charged with guaranteeing that the\n-        // value whose address was taken can actually be made to live\n-        // as long as it needs to live.\n-        let region = fcx.infcx().next_region_var(\n-            infer::AddrOfRegion(expr.span));\n-\n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n             ty::mk_err()\n         } else if ty::type_is_bot(tm.ty) {\n             ty::mk_bot()\n         }\n         else {\n-            ty::mk_rptr(tcx, region, tm)\n+            // Note: at this point, we cannot say what the best lifetime\n+            // is to use for resulting pointer.  We want to use the\n+            // shortest lifetime possible so as to avoid spurious borrowck\n+            // errors.  Moreover, the longest lifetime will depend on the\n+            // precise details of the value whose address is being taken\n+            // (and how long it is valid), which we don't know yet until type\n+            // inference is complete.\n+            //\n+            // Therefore, here we simply generate a region variable.  The\n+            // region inferencer will then select the ultimate value.\n+            // Finally, borrowck is charged with guaranteeing that the\n+            // value whose address was taken can actually be made to live\n+            // as long as it needs to live.\n+            match oprnd.node {\n+                // String literals are already, implicitly converted to slices.\n+                //ast::ExprLit(lit) if ast_util::lit_is_str(lit) => fcx.expr_ty(oprnd),\n+                // Empty slices live in static memory.\n+                ast::ExprVec(ref elements) if elements.len() == 0 => {\n+                    ty::mk_rptr(tcx, ty::ReStatic, tm)\n+                }\n+                _ => {\n+                    let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n+                    ty::mk_rptr(tcx, region, tm)\n+                }\n+            }\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -3393,7 +3309,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n           },\n           Some(ref e) => {\n-              check_expr_has_type(fcx, &**e, ret_ty);\n+              check_expr_coercable_to_type(fcx, &**e, ret_ty);\n           }\n         }\n         fcx.write_bot(id);\n@@ -3547,29 +3463,66 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_cast(fcx, &**e, &**t, id, expr.span);\n       }\n       ast::ExprVec(ref args) => {\n-        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n-        for e in args.iter() {\n-            check(fcx, &**e, t);\n-        }\n-        let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n-                             Some(args.len()));\n+        let uty = match expected {\n+            ExpectHasType(uty) => {\n+                match ty::get(uty).sty {\n+                        ty::ty_vec(ty, _) => Some(ty),\n+                        _ => None\n+                }\n+            }\n+            _ => None\n+        };\n+\n+        let typ = match uty {\n+            Some(uty) => {\n+                for e in args.iter() {\n+                    check_expr_coercable_to_type(fcx, &**e, uty);\n+                }\n+                uty\n+            }\n+            None => {\n+                let t: ty::t = fcx.infcx().next_ty_var();\n+                for e in args.iter() {\n+                    check_expr_has_type(fcx, &**e, t);\n+                }\n+                t\n+            }\n+        };\n+        let typ = ty::mk_vec(tcx, typ, Some(args.len()));\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, &**count_expr);\n-        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n-        check(fcx, &**element, t);\n-        let element_ty = fcx.expr_ty(&**element);\n+\n+        let uty = match expected {\n+            ExpectHasType(uty) => {\n+                match ty::get(uty).sty {\n+                        ty::ty_vec(ty, _) => Some(ty),\n+                        _ => None\n+                }\n+            }\n+            _ => None\n+        };\n+\n+        let (element_ty, t) = match uty {\n+            Some(uty) => {\n+                check_expr_coercable_to_type(fcx, &**element, uty);\n+                (uty, uty)\n+            }\n+            None => {\n+                let t: ty::t = fcx.infcx().next_ty_var();\n+                check_expr_has_type(fcx, &**element, t);\n+                (fcx.expr_ty(&**element), t)\n+            }\n+        };\n+\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(element_ty) {\n+        } else if ty::type_is_bot(element_ty) {\n             fcx.write_bot(id);\n-        }\n-        else {\n-            let t = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n-                               Some(count));\n+        } else {\n+            let t = ty::mk_vec(tcx, t, Some(count));\n             fcx.write_ty(id, t);\n         }\n       }\n@@ -3585,12 +3538,17 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let mut err_field = false;\n \n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n-            let opt_hint = match flds {\n-                Some(ref fs) if i < fs.len() => ExpectHasType(*fs.get(i)),\n-                _ => NoExpectation\n+            let t = match flds {\n+                Some(ref fs) if i < fs.len() => {\n+                    let ety = *fs.get(i);\n+                    check_expr_coercable_to_type(fcx, &**e, ety);\n+                    ety\n+                }\n+                _ => {\n+                    check_expr_with_expectation(fcx, &**e, NoExpectation);\n+                    fcx.expr_ty(&**e)\n+                }\n             };\n-            check_expr_with_expectation(fcx, &**e, opt_hint);\n-            let t = fcx.expr_ty(&**e);\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n@@ -3702,9 +3660,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n-                  Some(mt) => {\n+                  Some(ty) => {\n                       check_expr_has_type(fcx, &**idx, ty::mk_uint());\n-                      fcx.write_ty(id, mt.ty);\n+                      fcx.write_ty(id, ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n@@ -3967,34 +3925,42 @@ fn check_block_with_expected(fcx: &FnCtxt,\n         }\n         match blk.expr {\n             None => if any_err {\n-                fcx.write_error(blk.id);\n-            }\n-            else if any_bot {\n-                fcx.write_bot(blk.id);\n-            }\n-            else  {\n-                fcx.write_nil(blk.id);\n-            },\n-          Some(e) => {\n-            if any_bot && !warned {\n-                fcx.ccx\n-                   .tcx\n-                   .sess\n-                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                             e.id,\n-                             e.span,\n-                             \"unreachable expression\".to_string());\n+                    fcx.write_error(blk.id);\n+                }\n+                else if any_bot {\n+                    fcx.write_bot(blk.id);\n+                }\n+                else  {\n+                    fcx.write_nil(blk.id);\n+                },\n+            Some(e) => {\n+                if any_bot && !warned {\n+                    fcx.ccx\n+                       .tcx\n+                       .sess\n+                       .add_lint(lint::builtin::UNREACHABLE_CODE,\n+                                 e.id,\n+                                 e.span,\n+                                 \"unreachable expression\".to_string());\n+                }\n+                let ety = match expected {\n+                    ExpectHasType(ety) => {\n+                        check_expr_coercable_to_type(fcx, &*e, ety);\n+                        ety\n+                    }\n+                    _ => {\n+                        check_expr_with_expectation(fcx, &*e, expected);\n+                        fcx.expr_ty(&*e)\n+                    }\n+                };\n+\n+                fcx.write_ty(blk.id, ety);\n+                if any_err {\n+                    fcx.write_error(blk.id);\n+                } else if any_bot {\n+                    fcx.write_bot(blk.id);\n+                }\n             }\n-            check_expr_with_expectation(fcx, &*e, expected);\n-              let ety = fcx.expr_ty(&*e);\n-              fcx.write_ty(blk.id, ety);\n-              if any_err {\n-                  fcx.write_error(blk.id);\n-              }\n-              else if any_bot {\n-                  fcx.write_bot(blk.id);\n-              }\n-          }\n         };\n     });\n \n@@ -4040,9 +4006,8 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n     // emit a error.\n     GatherLocalsVisitor { fcx: fcx }.visit_expr(e, ());\n \n-    check_expr(fcx, e);\n-    let cty = fcx.expr_ty(e);\n-    demand::suptype(fcx, e.span, declty, cty);\n+    check_expr_with_hint(fcx, e, declty);\n+    demand::coerce(fcx, e.span, declty, e);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n@@ -4132,6 +4097,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n+\n pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                                  vs: &[ast::P<ast::Variant>]) {\n     for &v in vs.iter() {\n@@ -4747,39 +4713,39 @@ pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_uint(typ_s);\n }\n \n-pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n-                             e: &ast::Expr,\n-                             v: ast::ExprVstore,\n-                             mk_inner: || -> ty::mt)\n-                             -> ty::t {\n-    match v {\n-        ast::ExprVstoreUniq => ty::mk_uniq(fcx.ccx.tcx, mk_inner().ty),\n-        ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n-            match e.node {\n-                ast::ExprLit(..) => {\n-                    // string literals and *empty slices* live in static memory\n-                    ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner())\n-                }\n-                ast::ExprVec(ref elements) if elements.len() == 0 => {\n-                    // string literals and *empty slices* live in static memory\n-                    ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner())\n-                }\n-                ast::ExprRepeat(..) |\n-                ast::ExprVec(..) => {\n-                    // vector literals are temporaries on the stack\n-                    match fcx.tcx().region_maps.temporary_scope(e.id) {\n-                        Some(scope) => ty::mk_rptr(fcx.ccx.tcx, ty::ReScope(scope), mk_inner()),\n-                        None => ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner()),\n-                    }\n-                }\n-                _ => {\n-                    fcx.ccx.tcx.sess.span_bug(e.span,\n-                                              \"vstore with unexpected \\\n-                                               contents\")\n-                }\n-            }\n-        }\n-    }\n+pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_scalar(typ_s);\n+}\n+\n+pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_char(typ_s);\n+}\n+\n+pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_bare_fn(typ_s);\n+}\n+\n+pub fn type_is_floating_point(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_floating_point(typ_s);\n+}\n+\n+pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_unsafe_ptr(typ_s);\n+}\n+\n+pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_region_ptr(typ_s);\n+}\n+\n+pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n // Returns true if b contains a break that can exit from b"}, {"sha": "4f77c89e86c1d5bbaea919ccf2fdd8646a1c93a6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -413,40 +413,43 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n-            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n+            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n-                for autoref in opt_autoref.iter() {\n-                    link_autoref(rcx, expr, autoderefs, autoref);\n-\n-                    // Require that the resulting region encompasses\n-                    // the current node.\n-                    //\n-                    // FIXME(#6268) remove to support nested method calls\n-                    constrain_regions_in_type_of_node(\n-                        rcx, expr.id, ty::ReScope(expr.id),\n-                        infer::AutoBorrow(expr.span));\n+                match ty::adjusted_object_region(adjustment) {\n+                    Some(trait_region) => {\n+                        // Determine if we are casting `expr` to a trait\n+                        // instance.  If so, we have to be sure that the type of\n+                        // the source obeys the trait's region bound.\n+                        //\n+                        // Note: there is a subtle point here concerning type\n+                        // parameters.  It is possible that the type of `source`\n+                        // contains type parameters, which in turn may contain\n+                        // regions that are not visible to us (only the caller\n+                        // knows about them).  The kind checker is ultimately\n+                        // responsible for guaranteeing region safety in that\n+                        // particular case.  There is an extensive comment on the\n+                        // function check_cast_for_escaping_regions() in kind.rs\n+                        // explaining how it goes about doing that.\n+\n+                        constrain_regions_in_type(rcx, trait_region,\n+                                                  infer::RelateObjectBound(expr.span), expr_ty);\n+                    }\n+                    None => {\n+                        for autoref in opt_autoref.iter() {\n+                            link_autoref(rcx, expr, autoderefs, autoref);\n+\n+                            // Require that the resulting region encompasses\n+                            // the current node.\n+                            //\n+                            // FIXME(#6268) remove to support nested method calls\n+                            constrain_regions_in_type_of_node(\n+                                rcx, expr.id, ty::ReScope(expr.id),\n+                                infer::AutoBorrow(expr.span));\n+                        }\n+                    }\n                 }\n             }\n-            ty::AutoObject(ty::RegionTraitStore(trait_region, _), _, _, _) => {\n-                // Determine if we are casting `expr` to a trait\n-                // instance.  If so, we have to be sure that the type of\n-                // the source obeys the trait's region bound.\n-                //\n-                // Note: there is a subtle point here concerning type\n-                // parameters.  It is possible that the type of `source`\n-                // contains type parameters, which in turn may contain\n-                // regions that are not visible to us (only the caller\n-                // knows about them).  The kind checker is ultimately\n-                // responsible for guaranteeing region safety in that\n-                // particular case.  There is an extensive comment on the\n-                // function check_cast_for_escaping_regions() in kind.rs\n-                // explaining how it goes about doing that.\n-\n-                let source_ty = rcx.resolve_node_type(expr.id);\n-                constrain_regions_in_type(rcx, trait_region,\n-                                            infer::RelateObjectBound(expr.span), source_ty);\n-            }\n             _ => {}\n         }\n     }\n@@ -1176,24 +1179,12 @@ fn link_autoref(rcx: &Rcx,\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n-        ty::AutoPtr(r, m) => {\n-            link_region(rcx, expr.span, r,\n-                        ty::BorrowKind::from_mutbl(m), expr_cmt);\n-        }\n-\n-        ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-            let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n-            link_region(rcx, expr.span, r,\n-                        ty::BorrowKind::from_mutbl(m), cmt_index);\n-        }\n-\n-        ty::AutoBorrowObj(r, m) => {\n-            let cmt_deref = mc.cat_deref_obj(expr, expr_cmt);\n+        ty::AutoPtr(r, m, _) => {\n             link_region(rcx, expr.span, r,\n-                        ty::BorrowKind::from_mutbl(m), cmt_deref);\n+                ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(_) => {}\n+        ty::AutoUnsafe(_) | ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n     }\n }\n "}, {"sha": "530f8dd4b9ef66435e105e5251126eb70abd055e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 149, "deletions": 104, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty;\n-use middle::ty::{AutoAddEnv, AutoDerefRef, AutoObject, ParamTy};\n+use middle::ty::{AutoDerefRef, ParamTy};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n@@ -388,7 +388,6 @@ fn search_for_vtable(vcx: &VtableContext,\n                      trait_ref: Rc<ty::TraitRef>,\n                      is_early: bool)\n                      -> Option<vtable_origin> {\n-    debug!(\"nrc - search_for_vtable\");\n     let tcx = vcx.tcx();\n \n     // First, check to see whether this is a call to the `call` method of an\n@@ -630,14 +629,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n-    let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t, key: MethodCall| {\n-      // Look up vtables for the type we're casting to,\n-      // passing in the source and target type.  The source\n-      // must be a pointer type suitable to the object sigil,\n-      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-      // Bounds of type's contents are not checked here, but in kind.rs.\n-      let src_ty = structurally_resolved_type(fcx, ex.span,\n-                                              fcx.expr_ty(src));\n+    let check_object_cast = |src_ty: ty::t, target_ty: ty::t| {\n+      // Check that a cast is of correct types.\n       match (&ty::get(target_ty).sty, &ty::get(src_ty).sty) {\n           (&ty::ty_rptr(_, ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n             if !mutability_allowed(mt.mutbl, mutbl) => {\n@@ -648,74 +641,14 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   _ => {}\n               }\n           }\n-\n-          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |\n-          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(box ty::TyTrait {\n-                      def_id: target_def_id, substs: ref target_substs, ..\n-                  }) => {\n-                      debug!(\"nrc correct path\");\n-                      let typ = match &ty::get(src_ty).sty {\n-                          &ty::ty_uniq(typ) => typ,\n-                          &ty::ty_rptr(_, mt) => mt.ty,\n-                          _ => fail!(\"shouldn't get here\"),\n-                      };\n-\n-                      let vcx = fcx.vtable_context();\n-\n-                      // Take the type parameters from the object\n-                      // type, but set the Self type (which is\n-                      // unknown, for the object type) to be the type\n-                      // we are casting from.\n-                      let mut target_types = target_substs.types.clone();\n-                      assert!(target_types.get_self().is_none());\n-                      target_types.push(subst::SelfSpace, typ);\n-\n-                      let target_trait_ref = Rc::new(ty::TraitRef {\n-                          def_id: target_def_id,\n-                          substs: subst::Substs {\n-                              regions: target_substs.regions.clone(),\n-                              types: target_types\n-                          }\n-                      });\n-\n-                      let param_bounds = ty::ParamBounds {\n-                          builtin_bounds: ty::empty_builtin_bounds(),\n-                          trait_bounds: vec!(target_trait_ref)\n-                      };\n-                      let vtables =\n-                            lookup_vtables_for_param(&vcx,\n-                                                     ex.span,\n-                                                     None,\n-                                                     &param_bounds,\n-                                                     typ,\n-                                                     is_early);\n-\n-                      if !is_early {\n-                          let mut r = VecPerParamSpace::empty();\n-                          r.push(subst::SelfSpace, vtables);\n-                          insert_vtables(fcx, key, r);\n-                      }\n-\n-                      // Now, if this is &trait, we need to link the\n-                      // regions.\n-                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {\n-                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {\n-                              debug!(\"nrc - make subr\");\n-                              infer::mk_subr(fcx.infcx(),\n-                                             false,\n-                                             infer::RelateObjectBound(ex.span),\n-                                             rb,\n-                                             ra);\n-                          }\n-                          _ => {}\n-                      }\n-                  }\n-                  _ => {}\n-              }\n+          (&ty::ty_uniq(..), &ty::ty_uniq(..) ) => {}\n+          (&ty::ty_rptr(r_t, _), &ty::ty_rptr(r_s, _)) => {\n+              infer::mk_subr(fcx.infcx(),\n+                             false,\n+                             infer::RelateObjectBound(ex.span),\n+                             r_t,\n+                             r_s);\n           }\n-\n           (&ty::ty_uniq(ty), _) => {\n               match ty::get(ty).sty {\n                   ty::ty_trait(..) => {\n@@ -737,7 +670,55 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   _ => {}\n               }\n           }\n+          _ => {}\n+      }\n+    };\n+    let resolve_object_cast = |src_ty: ty::t, target_ty: ty::t, key: MethodCall| {\n+      // Look up vtables for the type we're casting to,\n+      // passing in the source and target type.  The source\n+      // must be a pointer type suitable to the object sigil,\n+      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n+      // Bounds of type's contents are not checked here, but in kind.rs.\n+      match ty::get(target_ty).sty {\n+          ty::ty_trait(box ty::TyTrait {\n+              def_id: target_def_id, substs: ref target_substs, ..\n+          }) => {\n+              let vcx = fcx.vtable_context();\n+\n+              // Take the type parameters from the object\n+              // type, but set the Self type (which is\n+              // unknown, for the object type) to be the type\n+              // we are casting from.\n+              let mut target_types = target_substs.types.clone();\n+              assert!(target_types.get_self().is_none());\n+              target_types.push(subst::SelfSpace, src_ty);\n+\n+              let target_trait_ref = Rc::new(ty::TraitRef {\n+                  def_id: target_def_id,\n+                  substs: subst::Substs {\n+                      regions: target_substs.regions.clone(),\n+                      types: target_types\n+                  }\n+              });\n+\n+              let param_bounds = ty::ParamBounds {\n+                  builtin_bounds: ty::empty_builtin_bounds(),\n+                  trait_bounds: vec!(target_trait_ref)\n+              };\n+              let vtables =\n+                    lookup_vtables_for_param(&vcx,\n+                                             ex.span,\n+                                             None,\n+                                             &param_bounds,\n+                                             src_ty,\n+                                             is_early);\n \n+              if !is_early {\n+                  let mut r = VecPerParamSpace::empty();\n+                  r.push(subst::SelfSpace, vtables);\n+                  insert_vtables(fcx, key, r);\n+              }\n+          }\n           _ => {}\n       }\n     };\n@@ -792,8 +773,16 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprCast(ref src, _) => {\n           debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n-          let key = MethodCall::expr(ex.id);\n-          resolve_object_cast(&**src, target_ty, key);\n+          let src_ty = structurally_resolved_type(fcx, ex.span,\n+                                                  fcx.expr_ty(&**src));\n+          check_object_cast(src_ty, target_ty);\n+          match (ty::deref(src_ty, false), ty::deref(target_ty, false)) {\n+              (Some(s), Some(t)) => {\n+                  let key = MethodCall::expr(ex.id);\n+                  resolve_object_cast(s.ty, t.ty, key)\n+              }\n+              _ => {}\n+          }\n       }\n       _ => ()\n     }\n@@ -802,7 +791,25 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     match fcx.inh.adjustments.borrow().find(&ex.id) {\n         Some(adjustment) => {\n             match *adjustment {\n-                AutoDerefRef(adj) => {\n+                _ if ty::adjust_is_object(adjustment) => {\n+                    let src_ty = structurally_resolved_type(fcx, ex.span,\n+                                                            fcx.expr_ty(ex));\n+                    match ty::type_of_adjust(fcx.tcx(), adjustment) {\n+                        Some(target_ty) => {\n+                            check_object_cast(src_ty, target_ty)\n+                        }\n+                        None => {}\n+                    }\n+\n+                    match trait_cast_types(fcx, adjustment, src_ty, ex.span) {\n+                        Some((s, t)) => {\n+                            let key = MethodCall::autoobject(ex.id);\n+                            resolve_object_cast(s, t, key)\n+                        }\n+                        None => fail!(\"Couldn't extract types from adjustment\")\n+                    }\n+                }\n+                AutoDerefRef(ref adj) => {\n                     for autoderef in range(0, adj.autoderefs) {\n                         let method_call = MethodCall::autoderef(ex.id, autoderef);\n                         match fcx.inh.method_map.borrow().find(&method_call) {\n@@ -823,34 +830,72 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         }\n                     }\n                 }\n-                AutoObject(store,\n-                           bounds,\n-                           def_id,\n-                           ref substs) => {\n-                    debug!(\"doing trait adjustment for expr {} {} \\\n-                            (early? {})\",\n-                           ex.id,\n-                           ex.repr(fcx.tcx()),\n-                           is_early);\n-\n-                    let trait_ty = ty::mk_trait(cx.tcx,\n-                                                def_id,\n-                                                substs.clone(),\n-                                                bounds);\n-                    let object_ty = match store {\n-                        ty::UniqTraitStore => ty::mk_uniq(cx.tcx, trait_ty),\n-                        ty::RegionTraitStore(r, m) => {\n-                            ty::mk_rptr(cx.tcx, r, ty::mt {ty: trait_ty, mutbl: m})\n-                        }\n-                    };\n+                _ => {}\n+            }\n+        }\n+        None => {}\n+    }\n+}\n \n-                    let key = MethodCall::autoobject(ex.id);\n-                    resolve_object_cast(ex, object_ty, key);\n+// When we coerce (possibly implicitly) from a concrete type to a trait type, this\n+// function returns the concrete type and trait. This might happen arbitrarily\n+// deep in the adjustment. This function will fail if the adjustment does not\n+// match the source type.\n+// This function will always return types if ty::adjust_is_object is true for the\n+// adjustment\n+fn trait_cast_types(fcx: &FnCtxt,\n+                    adj: &ty::AutoAdjustment,\n+                    src_ty: ty::t,\n+                    sp: Span)\n+                    -> Option<(ty::t, ty::t)> {\n+    fn trait_cast_types_autoref(fcx: &FnCtxt,\n+                                autoref: &ty::AutoRef,\n+                                src_ty: ty::t,\n+                                sp: Span)\n+                                -> Option<(ty::t, ty::t)> {\n+        fn trait_cast_types_unsize(fcx: &FnCtxt,\n+                                   k: &ty::UnsizeKind,\n+                                   src_ty: ty::t,\n+                                   sp: Span)\n+                                   -> Option<(ty::t, ty::t)> {\n+            match k {\n+                &ty::UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some((src_ty, ty::mk_trait(fcx.tcx(), def_id, substs.clone(), bounds)))\n                 }\n-                AutoAddEnv(..) => {}\n+                &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(src_ty).sty {\n+                    ty::ty_struct(_, ref substs) => {\n+                        let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                        let field_ty = structurally_resolved_type(fcx, sp, ty_substs[tp_index]);\n+                        trait_cast_types_unsize(fcx, k, field_ty, sp)\n+                    }\n+                    _ => fail!(\"Failed to find a ty_struct to correspond with \\\n+                                UnsizeStruct whilst walking adjustment. Found {}\",\n+                                ppaux::ty_to_string(fcx.tcx(), src_ty))\n+                },\n+                _ => None\n             }\n         }\n-        None => {}\n+\n+        match autoref {\n+            &ty::AutoUnsize(ref k) |\n+            &ty::AutoUnsizeUniq(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n+            &ty::AutoPtr(_, _, Some(box ref autoref)) => {\n+                trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    match adj {\n+        &ty::AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), autoderefs}) => {\n+            let mut derefed_type = src_ty;\n+            for _ in range(0, autoderefs) {\n+                derefed_type = ty::deref(derefed_type, false).unwrap().ty;\n+                derefed_type = structurally_resolved_type(fcx, sp, derefed_type)\n+            }\n+            trait_cast_types_autoref(fcx, autoref, derefed_type, sp)\n+        }\n+        _ => None\n     }\n }\n "}, {"sha": "7951c8dfc1980b8d087d2336ff2b95ef5964f091", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -259,6 +259,7 @@ impl<'cx> WritebackCx<'cx> {\n             }\n \n             Some(adjustment) => {\n+                let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n                     ty::AutoAddEnv(store) => {\n                         // FIXME(eddyb) #2190 Allow only statically resolved\n@@ -286,24 +287,17 @@ impl<'cx> WritebackCx<'cx> {\n                             self.visit_vtable_map_entry(reason, method_call);\n                         }\n \n+                        if adj_object {\n+                            let method_call = MethodCall::autoobject(id);\n+                            self.visit_method_map_entry(reason, method_call);\n+                            self.visit_vtable_map_entry(reason, method_call);\n+                        }\n+\n                         ty::AutoDerefRef(ty::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n                         })\n                     }\n-\n-                    ty::AutoObject(trait_store, bb, def_id, substs) => {\n-                        let method_call = MethodCall::autoobject(id);\n-                        self.visit_method_map_entry(reason, method_call);\n-                        self.visit_vtable_map_entry(reason, method_call);\n-\n-                        ty::AutoObject(\n-                            self.resolve(&trait_store, reason),\n-                            self.resolve(&bb, reason),\n-                            def_id,\n-                            self.resolve(&substs, reason)\n-                        )\n-                    }\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n                 self.tcx().adjustments.borrow_mut().insert("}, {"sha": "a6fa9d84600bf6d5fb8fea5c95f6b16a79b64a4e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -23,7 +23,7 @@ use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n@@ -86,7 +86,7 @@ fn get_base_type(inference_context: &InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_err |\n+        ty_infer(..) | ty_param(..) | ty_err | ty_open(..) |\n         ty_box(_) | ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n@@ -166,6 +166,9 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                                enum, struct, or trait\");\n                     }\n                 },\n+                ty_trait(box ty::TyTrait { def_id, .. }) => {\n+                    Some(def_id)\n+                }\n                 _ => {\n                     fail!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");"}, {"sha": "abf366381139cdead006d0d081137a2c9e6bcd10", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 199, "deletions": 108, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -65,14 +65,15 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::subst;\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowObj, AutoDerefRef};\n+use middle::ty::{AutoPtr, AutoDerefRef, AutoUnsize};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::{CombineFields, Combine};\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::indenter;\n+use util::ppaux;\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -94,38 +95,51 @@ impl<'f> Coerce<'f> {\n                b.repr(self.get_ref().infcx.tcx));\n         let _indent = indenter();\n \n+        // Special case: if the subtype is a sized array literal (`[T, ..n]`),\n+        // then it would get auto-borrowed to `&[T, ..n]` and then DST-ified\n+        // to `&[T]`. Doing it all at once makes the target code a bit more\n+        // efficient and spares us from having to handle multiple coercions.\n+        match ty::get(b).sty {\n+            ty::ty_rptr(_, mt_b) => {\n+                match ty::get(mt_b.ty).sty {\n+                    ty::ty_vec(_, None) => {\n+                        let unsize_and_ref = self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_unsized_with_borrow(a, sty_a, b, mt_b.mutbl)\n+                        });\n+                        if unsize_and_ref.is_ok() {\n+                            return unsize_and_ref;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // Consider coercing the subtype to a DST\n+        let unsize = self.unpack_actual_value(a, |sty_a| {\n+            self.coerce_unsized(a, sty_a, b)\n+        });\n+        if unsize.is_ok() {\n+            return unsize;\n+        }\n+\n         // Examine the supertype and consider auto-borrowing.\n         //\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match ty::get(b).sty {\n-            ty::ty_rptr(r_b, mt_b) => {\n+            ty::ty_rptr(_, mt_b) => {\n                 match ty::get(mt_b.ty).sty {\n-                    ty::ty_vec(mt_b, None) => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_vector(a, sty_a, b, mt_b.mutbl)\n-                        });\n-                    }\n-                    ty::ty_vec(_, _) => {},\n                     ty::ty_str => {\n                         return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_string(a, sty_a, b)\n+                            self.coerce_borrowed_pointer(a, sty_a, b, ast::MutImmutable)\n                         });\n                     }\n \n-                    ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n+                    ty::ty_trait(..) => {\n                         let result = self.unpack_actual_value(a, |sty_a| {\n-                            match *sty_a {\n-                                ty::ty_rptr(_, mt_a) => match ty::get(mt_a.ty).sty {\n-                                    ty::ty_trait(..) => {\n-                                        self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n-                                    }\n-                                    _ => self.coerce_object(a, sty_a, b, def_id, substs,\n-                                                            ty::RegionTraitStore(r_b, mt_b.mutbl),\n-                                                            bounds)\n-                                },\n-                                _ => self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n-                            }\n+                            self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n                         });\n \n                         match result {\n@@ -136,37 +150,12 @@ impl<'f> Coerce<'f> {\n \n                     _ => {\n                         return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n+                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b.mutbl)\n                         });\n                     }\n                 };\n             }\n \n-            ty::ty_uniq(t_b) => {\n-                match ty::get(t_b).sty {\n-                    ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n-                        let result = self.unpack_actual_value(a, |sty_a| {\n-                            match *sty_a {\n-                                ty::ty_uniq(t_a) => match ty::get(t_a).sty {\n-                                    ty::ty_trait(..) => {\n-                                        Err(ty::terr_mismatch)\n-                                    }\n-                                    _ => self.coerce_object(a, sty_a, b, def_id, substs,\n-                                                            ty::UniqTraitStore, bounds)\n-                                },\n-                                _ => Err(ty::terr_mismatch)\n-                            }\n-                        });\n-\n-                        match result {\n-                            Ok(t) => return Ok(t),\n-                            Err(..) => {}\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n             ty::ty_closure(box ty::ClosureTy {\n                     store: ty::RegionTraitStore(..),\n                     ..\n@@ -210,8 +199,8 @@ impl<'f> Coerce<'f> {\n         }\n     }\n \n-    pub fn unpack_actual_value(&self, a: ty::t, f: |&ty::sty| -> CoerceResult)\n-                               -> CoerceResult {\n+    pub fn unpack_actual_value<T>(&self, a: ty::t, f: |&ty::sty| -> T)\n+                                  -> T {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n@@ -221,20 +210,21 @@ impl<'f> Coerce<'f> {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n                     self.get_ref().trace.origin.span(),\n                     format!(\"failed to resolve even without \\\n-                          any force options: {:?}\", e).as_slice());\n+                             any force options: {:?}\", e).as_slice());\n             }\n         }\n     }\n \n+    // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n                                    a: ty::t,\n                                    sty_a: &ty::sty,\n                                    b: ty::t,\n-                                   mt_b: ty::mt)\n+                                   mutbl_b: ast::Mutability)\n                                    -> CoerceResult {\n-        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n+        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n-               b.repr(self.get_ref().infcx.tcx), mt_b);\n+               b.repr(self.get_ref().infcx.tcx));\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -256,64 +246,182 @@ impl<'f> Coerce<'f> {\n \n         let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                      r_borrow,\n-                                     mt {ty: inner_ty, mutbl: mt_b.mutbl});\n+                                     mt {ty: inner_ty, mutbl: mutbl_b});\n         if_ok!(sub.tys(a_borrowed, b));\n+\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n-            autoref: Some(AutoPtr(r_borrow, mt_b.mutbl))\n+            autoref: Some(AutoPtr(r_borrow, mutbl_b, None))\n         })))\n     }\n \n-    pub fn coerce_borrowed_string(&self,\n+    // [T, ..n] -> &[T] or &mut [T]\n+    fn coerce_unsized_with_borrow(&self,\n                                   a: ty::t,\n                                   sty_a: &ty::sty,\n-                                  b: ty::t)\n+                                  b: ty::t,\n+                                  mutbl_b: ast::Mutability)\n                                   -> CoerceResult {\n-        debug!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsized_with_borrow(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n         match *sty_a {\n-            ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n-            _ => return self.subtype(a, b),\n+            ty::ty_vec(t_a, Some(len)) => {\n+                let sub = Sub(self.get_ref().clone());\n+                let coercion = Coercion(self.get_ref().trace.clone());\n+                let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+                let unsized_ty = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n+                                              mt {ty: t_a, mutbl: mutbl_b});\n+                if_ok!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n+                Ok(Some(AutoDerefRef(AutoDerefRef {\n+                    autoderefs: 0,\n+                    autoref: Some(ty::AutoPtr(r_borrow,\n+                                              mutbl_b,\n+                                              Some(box AutoUnsize(ty::UnsizeLength(len)))))\n+                })))\n+            }\n+            _ => Err(ty::terr_mismatch)\n         }\n     }\n \n-    pub fn coerce_borrowed_vector(&self,\n-                                  a: ty::t,\n-                                  sty_a: &ty::sty,\n-                                  b: ty::t,\n-                                  mutbl_b: ast::Mutability)\n-                                  -> CoerceResult {\n-        debug!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n+    // &[T, ..n] or &mut [T, ..n] -> &[T]\n+    // or &mut [T, ..n] -> &mut [T]\n+    // or &Concrete -> &Trait, etc.\n+    fn coerce_unsized(&self,\n+                      a: ty::t,\n+                      sty_a: &ty::sty,\n+                      b: ty::t)\n+                      -> CoerceResult {\n+        debug!(\"coerce_unsized(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n+        // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n+        // a DST unless we have to. This currently comes out in the wash since\n+        // we can't unify [T] with U. But to properly support DST, we need to allow\n+        // that, at which point we will need extra checks on b here.\n+\n         let sub = Sub(self.get_ref().clone());\n-        let coercion = Coercion(self.get_ref().trace.clone());\n-        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n-        let ty_inner = match *sty_a {\n-            ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n-            ty::ty_ptr(ty::mt{ty: t, ..}) |\n-            ty::ty_rptr(_, ty::mt{ty: t, ..}) => match ty::get(t).sty {\n-                ty::ty_vec(mt, None) => mt.ty,\n-                _ => {\n-                    return self.subtype(a, b);\n-                }\n-            },\n-            ty::ty_vec(mt, _) => mt.ty,\n-            _ => {\n-                return self.subtype(a, b);\n+\n+        let sty_b = &ty::get(b).sty;\n+        match (sty_a, sty_b) {\n+            (&ty::ty_uniq(_), &ty::ty_rptr(..)) => Err(ty::terr_mismatch),\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_rptr(_, mt_b)) => {\n+                self.unpack_actual_value(t_a, |sty_a| {\n+                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                        Some((ty, kind)) => {\n+                            let coercion = Coercion(self.get_ref().trace.clone());\n+                            let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+                            let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n+                                                 r_borrow,\n+                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                                autoderefs: 1,\n+                                autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n+                                                          Some(box AutoUnsize(kind))))\n+                            })))\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n+                })\n             }\n-        };\n+            (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n+                self.unpack_actual_value(t_a, |sty_a| {\n+                    match self.unsize_ty(sty_a, t_b) {\n+                        Some((ty, kind)) => {\n+                            let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n+                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                    AutoUnsizeUniq({:?}))\", kind);\n+                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                                autoderefs: 1,\n+                                autoref: Some(ty::AutoUnsizeUniq(kind))\n+                            })))\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n+                })\n+            }\n+            _ => Err(ty::terr_mismatch)\n+        }\n+    }\n \n-        let a_borrowed = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n-                                      mt {ty: ty_inner, mutbl: mutbl_b});\n-        if_ok!(sub.tys(a_borrowed, b));\n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n-            autoderefs: 0,\n-            autoref: Some(AutoBorrowVec(r_borrow, mutbl_b))\n-        })))\n+    // Takes a type and returns an unsized version along with the adjustment\n+    // performed to unsize it.\n+    // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n+    fn unsize_ty(&self,\n+                 sty_a: &ty::sty,\n+                 ty_b: ty::t)\n+                 -> Option<(ty::t, ty::UnsizeKind)> {\n+        debug!(\"unsize_ty(sty_a={:?}\", sty_a);\n+\n+        let tcx = self.get_ref().infcx.tcx;\n+\n+        self.unpack_actual_value(ty_b, |sty_b|\n+            match (sty_a, sty_b) {\n+                (&ty::ty_vec(t_a, Some(len)), _) => {\n+                    let ty = ty::mk_vec(tcx, t_a, None);\n+                    Some((ty, ty::UnsizeLength(len)))\n+                }\n+                (&ty::ty_trait(..), &ty::ty_trait(..)) => None,\n+                (_, &ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds })) => {\n+                    let ty = ty::mk_trait(tcx,\n+                                          def_id,\n+                                          substs.clone(),\n+                                          bounds);\n+                    Some((ty, ty::UnsizeVtable(bounds,\n+                                               def_id,\n+                                               substs.clone())))\n+                }\n+                (&ty::ty_struct(did_a, ref substs_a), &ty::ty_struct(did_b, ref substs_b))\n+                  if did_a == did_b => {\n+                    debug!(\"unsizing a struct\");\n+                    // Try unsizing each type param in turn to see if we end up with ty_b.\n+                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n+                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n+                    assert!(ty_substs_a.len() == ty_substs_b.len());\n+\n+                    let sub = Sub(self.get_ref().clone());\n+\n+                    let mut result = None;\n+                    let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                    for (i, (tp_a, tp_b)) in tps {\n+                        if self.get_ref().infcx.try(|| sub.tys(*tp_a, *tp_b)).is_ok() {\n+                            continue;\n+                        }\n+                        match self.unpack_actual_value(*tp_a, |tp| self.unsize_ty(tp, *tp_b)) {\n+                            Some((new_tp, k)) => {\n+                                // Check that the whole types match.\n+                                let mut new_substs = substs_a.clone();\n+                                new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n+                                let ty = ty::mk_struct(tcx, did_a, new_substs);\n+                                if self.get_ref().infcx.try(|| sub.tys(ty, ty_b)).is_err() {\n+                                    debug!(\"Unsized type parameter '{}', but still \\\n+                                            could not match types {} and {}\",\n+                                           ppaux::ty_to_string(tcx, *tp_a),\n+                                           ppaux::ty_to_string(tcx, ty),\n+                                           ppaux::ty_to_string(tcx, ty_b));\n+                                    // We can only unsize a single type parameter, so\n+                                    // if we unsize one and it doesn't give us the\n+                                    // type we want, then we won't succeed later.\n+                                    break;\n+                                }\n+\n+                                result = Some((ty, ty::UnsizeStruct(box k, i)));\n+                                break;\n+                            }\n+                            None => {}\n+                        }\n+                    }\n+                    result\n+                }\n+                _ => None\n+            }\n+        )\n     }\n \n     fn coerce_borrowed_object(&self,\n@@ -352,8 +460,8 @@ impl<'f> Coerce<'f> {\n \n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n-            autoderefs: 0,\n-            autoref: Some(AutoBorrowObj(r_a, b_mutbl))\n+            autoderefs: 1,\n+            autoref: Some(AutoPtr(r_a, b_mutbl, None))\n         })))\n     }\n \n@@ -438,21 +546,4 @@ impl<'f> Coerce<'f> {\n             autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n         })))\n     }\n-\n-    pub fn coerce_object(&self,\n-                         a: ty::t,\n-                         sty_a: &ty::sty,\n-                         b: ty::t,\n-                         trait_def_id: ast::DefId,\n-                         trait_substs: &subst::Substs,\n-                         trait_store: ty::TraitStore,\n-                         bounds: ty::BuiltinBounds) -> CoerceResult {\n-\n-        debug!(\"coerce_object(a={}, sty_a={:?}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n-               b.repr(self.get_ref().infcx.tcx));\n-\n-        Ok(Some(ty::AutoObject(trait_store, bounds,\n-                               trait_def_id, trait_substs.clone())))\n-    }\n }"}, {"sha": "a57dec9045522a74dba8ca4a1a73f39150855b30", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -529,10 +529,10 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n             check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n       }\n \n-      (&ty::ty_vec(ref a_mt, sz_a), &ty::ty_vec(ref b_mt, sz_b)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| {\n+      (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n+        this.tys(a_t, b_t).and_then(|t| {\n             if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, mt, sz_a))\n+                Ok(ty::mk_vec(tcx, t, sz_a))\n             } else {\n                 Err(ty::terr_sorts(expected_found(this, a, b)))\n             }"}, {"sha": "920fa23f31df3860ace504d21aac992ce981f7ce", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1411,8 +1411,8 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             infer::AutoBorrow(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that automatically reference is valid \\\n-                     at the time of borrow\");\n+                    \"...so that reference is valid \\\n+                     at the time of implicit borrow\");\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note("}, {"sha": "a54afb1102fb99019cb832150399677c2868dd48", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -129,10 +129,23 @@ impl<'f> Combine for Sub<'f> {\n                 if_ok!(self.get_ref().var_sub_var(a_id, b_id));\n                 Ok(a)\n             }\n+            // The vec/str check here and below is so that we don't unify\n+            // T with [T], this is necessary so we reflect subtyping of references\n+            // (&T does not unify with &[T]) where that in turn is to reflect\n+            // the historical non-typedness of [T].\n+            (&ty::ty_infer(TyVar(_)), &ty::ty_str) |\n+            (&ty::ty_infer(TyVar(_)), &ty::ty_vec(_, None)) => {\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n+            }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n                 if_ok!(self.get_ref().var_sub_t(a_id, b));\n                 Ok(a)\n             }\n+\n+            (&ty::ty_str, &ty::ty_infer(TyVar(_))) |\n+            (&ty::ty_vec(_, None), &ty::ty_infer(TyVar(_))) => {\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n+            }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n                 if_ok!(self.get_ref().t_sub_var(a, b_id));\n                 Ok(a)"}, {"sha": "e6227b9c12829df69edfa10f721479fa3e13684d", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -741,11 +741,7 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_vec(ref mt, _) => {\n-                self.add_constraints_from_mt(mt, variance);\n-            }\n-\n-            ty::ty_uniq(typ) | ty::ty_box(typ) => {\n+            ty::ty_uniq(typ) | ty::ty_box(typ) | ty::ty_vec(typ, _) | ty::ty_open(typ) => {\n                 self.add_constraints_from_ty(typ, variance);\n             }\n "}, {"sha": "5dff183108ce8f78290c96d27bb35413a4860400", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup};\n+use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n@@ -370,6 +370,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n           buf.push_str(mt_to_string(cx, tm).as_slice());\n           buf\n       }\n+      ty_open(typ) => format!(\"opened<{}>\", ty_to_string(cx, typ)),\n       ty_tup(ref elems) => {\n         let strs: Vec<String> = elems.iter().map(|elem| ty_to_string(cx, *elem)).collect();\n         format!(\"({})\", strs.connect(\",\"))\n@@ -407,7 +408,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n           let trait_def = ty::lookup_trait_def(cx, did);\n           let ty = parameterized(cx, base.as_slice(),\n                                  substs, &trait_def.generics);\n-          let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n+          let bound_sep = if bounds.is_empty() { \"\" } else { \"+\" };\n           let bound_str = bounds.repr(cx);\n           format!(\"{}{}{}\",\n                   ty,\n@@ -416,12 +417,12 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n       }\n       ty_str => \"str\".to_string(),\n       ty_unboxed_closure(..) => \"closure\".to_string(),\n-      ty_vec(ref mt, sz) => {\n+      ty_vec(t, sz) => {\n           match sz {\n               Some(n) => {\n-                  format!(\"[{}, .. {}]\", mt_to_string(cx, mt), n)\n+                  format!(\"[{}, .. {}]\", ty_to_string(cx, t), n)\n               }\n-              None => format!(\"[{}]\", ty_to_string(cx, mt.ty)),\n+              None => format!(\"[{}]\", ty_to_string(cx, t)),\n           }\n       }\n     }"}, {"sha": "e859a5d21d7e75095a8520ac975cf2855bc67644", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -20,14 +20,8 @@ pub static fn_field_box: uint = 1u;\n \n // The two fields of a trait object/trait instance: vtable and box.\n // The vtable contains the type descriptor as first element.\n-pub static trt_field_vtable: uint = 0u;\n-pub static trt_field_box: uint = 1u;\n-\n-pub static vec_elt_fill: uint = 0u;\n-\n-pub static vec_elt_alloc: uint = 1u;\n-\n-pub static vec_elt_elems: uint = 2u;\n+pub static trt_field_box: uint = 0u;\n+pub static trt_field_vtable: uint = 1u;\n \n pub static slice_elt_base: uint = 0u;\n pub static slice_elt_len: uint = 1u;"}, {"sha": "6af19d948e0e8b467c153ae03fb825d3394ae441", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -225,7 +225,6 @@ mod svh_visitor {\n         SawExprBreak(Option<token::InternedString>),\n         SawExprAgain(Option<token::InternedString>),\n \n-        SawExprVstore,\n         SawExprBox,\n         SawExprVec,\n         SawExprCall,\n@@ -257,7 +256,6 @@ mod svh_visitor {\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n         match *node {\n-            ExprVstore(..)           => SawExprVstore,\n             ExprBox(..)              => SawExprBox,\n             ExprVec(..)              => SawExprVec,\n             ExprCall(..)             => SawExprCall,"}, {"sha": "dc2c0d1d0830d89ce98cdc81128ab365a74d543e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1250,8 +1250,8 @@ impl Clean<Type> for ty::t {\n                 });\n                 lang_struct(box_did, t, \"Box\", Unique)\n             }\n-            ty::ty_vec(mt, None) => Vector(box mt.ty.clean()),\n-            ty::ty_vec(mt, Some(i)) => FixedVector(box mt.ty.clean(),\n+            ty::ty_vec(ty, None) => Vector(box ty.clean()),\n+            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(),\n                                                    format!(\"{}\", i)),\n             ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(), box mt.ty.clean()),\n             ty::ty_rptr(r, mt) => BorrowedRef {\n@@ -1315,6 +1315,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_unboxed_closure(..) => Primitive(Unit), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => fail!(\"ty_infer\"),\n+            ty::ty_open(..) => fail!(\"ty_open\"),\n             ty::ty_err => fail!(\"ty_err\"),\n         }\n     }"}, {"sha": "6415ee85f5704d5f5861f5dbf8518a71b8610c2b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -259,7 +259,8 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n-    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n+    let default: &[_] = &[];\n+    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n                 match *attr {"}, {"sha": "55d9811ccadc05a65a0a770c4bb3f264521bc4d1", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -72,13 +72,15 @@ impl Clone for HomeHandle {\n }\n \n pub fn local_id() -> uint {\n+    use std::raw::TraitObject;\n+\n     let mut io = match LocalIo::borrow() {\n         Some(io) => io, None => return 0,\n     };\n     let io = io.get();\n     unsafe {\n-        let (_vtable, ptr): (uint, uint) = mem::transmute(io);\n-        return ptr;\n+        let obj: TraitObject = mem::transmute(io);\n+        return mem::transmute(obj.data);\n     }\n }\n "}, {"sha": "6e948992979d86e8c4044be8ea5e9f21c32d427b", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -462,13 +462,14 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n // This function is full of lies!\n #[cfg(test)]\n fn local_loop() -> &'static mut uvio::UvIoFactory {\n+    use std::raw::TraitObject;\n     unsafe {\n         mem::transmute({\n             let mut task = Local::borrow(None::<Task>);\n             let mut io = task.local_io().unwrap();\n-            let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n+            let obj: TraitObject =\n                 mem::transmute(io.get());\n-            uvio\n+            obj.data\n         })\n     }\n }"}, {"sha": "1d2fcc8b77b15f7a02a2fd8b90a9b7d27bca2ef9", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -183,16 +183,17 @@ mod tests {\n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0u, 256) {\n+            let ii: &[u8] = &[i as u8];\n             assert_eq!(format!(\"{:02x}\", i as uint).as_slice()\n                                                    .from_hex()\n                                                    .unwrap()\n                                                    .as_slice(),\n-                       &[i as u8]);\n+                       ii);\n             assert_eq!(format!(\"{:02X}\", i as uint).as_slice()\n                                                    .from_hex()\n                                                    .unwrap()\n                                                    .as_slice(),\n-                       &[i as u8]);\n+                       ii);\n         }\n     }\n "}, {"sha": "f7b23163dfe482130947df206e9895b8cd1097b6", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -609,11 +609,12 @@ mod tests {\n     #[test]\n     fn test_ascii_vec() {\n         let test = &[40u8, 32u8, 59u8];\n-        assert_eq!(test.to_ascii(), v2ascii!([40, 32, 59]));\n-        assert_eq!(\"( ;\".to_ascii(), v2ascii!([40, 32, 59]));\n+        let b: &[_] = v2ascii!([40, 32, 59]);\n+        assert_eq!(test.to_ascii(), b);\n+        assert_eq!(\"( ;\".to_ascii(), b);\n         let v = vec![40u8, 32u8, 59u8];\n-        assert_eq!(v.as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n-        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n+        assert_eq!(v.as_slice().to_ascii(), b);\n+        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), b);\n \n         assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_string(), \"abcdef&?#\".to_string());\n         assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_string(), \"ABCDEF&?#\".to_string());\n@@ -688,13 +689,12 @@ mod tests {\n         assert_eq!((test1).to_ascii_opt(), None);\n \n         let v = [40u8, 32u8, 59u8];\n-        let v2 = v2ascii!(&[40, 32, 59]);\n+        let v2: &[_] = v2ascii!(&[40, 32, 59]);\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         let v = [127u8, 128u8, 255u8];\n         assert_eq!(v.to_ascii_opt(), None);\n \n         let v = \"( ;\";\n-        let v2 = v2ascii!(&[40, 32, 59]);\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n "}, {"sha": "1d638e498d44928b7d2c18059ba9adb590f12db9", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -415,21 +415,25 @@ mod test {\n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(2), nread);\n-        assert_eq!(buf.as_slice(), &[0, 1, 0]);\n+        let b: &[_] = &[0, 1, 0];\n+        assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!(buf.as_slice(), &[2]);\n+        let b: &[_] = &[2];\n+        assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!(buf.as_slice(), &[3, 0, 0]);\n+        let b: &[_] = &[3, 0, 0];\n+        assert_eq!(buf.as_slice(), b);\n \n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!(buf.as_slice(), &[4, 0, 0]);\n+        let b: &[_] = &[4, 0, 0];\n+        assert_eq!(buf.as_slice(), b);\n \n         assert!(reader.read(buf).is_err());\n     }\n@@ -440,45 +444,53 @@ mod test {\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n         writer.write([0, 1]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[]);\n+        let b: &[_] = &[];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.write([2]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.write([3]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n+        assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.flush().unwrap();\n-        assert_eq!(&[0, 1, 2, 3], writer.get_ref().get_ref());\n+        let a: &[_] = &[0, 1, 2, 3];\n+        assert_eq!(a, writer.get_ref().get_ref());\n \n         writer.write([4]).unwrap();\n         writer.write([5]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3], writer.get_ref().get_ref());\n+        assert_eq!(a, writer.get_ref().get_ref());\n \n         writer.write([6]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5],\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5];\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n         writer.write([7, 8]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5, 6],\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n         writer.write([9, 10, 11]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n         writer.flush().unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n         w.write([0, 1]).unwrap();\n-        assert_eq!(&[], w.get_ref().get_ref());\n+        let a: &[_] = &[];\n+        assert_eq!(a, w.get_ref().get_ref());\n         let w = w.unwrap();\n-        assert_eq!(&[0, 1], w.get_ref());\n+        let a: &[_] = &[0, 1];\n+        assert_eq!(a, w.get_ref());\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -519,20 +531,22 @@ mod test {\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n         writer.write([0]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[]);\n+        let b: &[_] = &[];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[]);\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.write([0, b'\\n', 1, b'\\n', 2]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, b'\\n', 1, b'\\n']);\n+        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.write([3, b'\\n']).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(),\n-            &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n+        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n     }\n \n     #[test]"}, {"sha": "1c8b047f56f4db71fbf6a820e20f8121012d157c", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -154,26 +154,29 @@ mod test {\n         assert_eq!(Ok(0), reader.read([]));\n \n         assert_eq!(Ok(3), reader.read(buf));\n-        assert_eq!(&[1,2,3], buf.as_slice());\n+        let a: &[u8] = &[1,2,3];\n+        assert_eq!(a, buf.as_slice());\n \n         assert_eq!(Ok(3), reader.read(buf));\n-        assert_eq!(&[4,5,6], buf.as_slice());\n+        let a: &[u8] = &[4,5,6];\n+        assert_eq!(a, buf.as_slice());\n \n         assert_eq!(Ok(2), reader.read(buf));\n-        assert_eq!(&[7,8,6], buf.as_slice());\n+        let a: &[u8] = &[7,8,6];\n+        assert_eq!(a, buf.as_slice());\n \n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(&[7,8,6], buf.as_slice());\n+        assert_eq!(a, buf.as_slice());\n \n         // Ensure it continues to fail in the same way.\n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(&[7,8,6], buf.as_slice());\n+        assert_eq!(a, buf.as_slice());\n     }\n \n     #[test]"}, {"sha": "21ab9c1fdd431fcf5d568798789ffe586b4ffdaf", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -346,7 +346,8 @@ mod test {\n         writer.write([0]).unwrap();\n         writer.write([1, 2, 3]).unwrap();\n         writer.write([4, 5, 6, 7]).unwrap();\n-        assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n     }\n \n     #[test]\n@@ -363,7 +364,8 @@ mod test {\n             writer.write([]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n         }\n-        assert_eq!(buf.as_slice(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     #[test]\n@@ -391,7 +393,8 @@ mod test {\n             assert_eq!(writer.tell(), Ok(8));\n \n         }\n-        assert_eq!(buf.as_slice(), &[1, 3, 2, 0, 0, 0, 0, 4]);\n+        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     #[test]\n@@ -415,13 +418,16 @@ mod test {\n         let mut buf = [0];\n         assert_eq!(reader.read(buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n-        assert_eq!(buf.as_slice(), &[0]);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n-        assert_eq!(buf.as_slice(), &[1, 2, 3, 4]);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n-        assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -439,13 +445,16 @@ mod test {\n         let mut buf = [0];\n         assert_eq!(reader.read(buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n-        assert_eq!(buf.as_slice(), &[0]);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n-        assert_eq!(buf.as_slice(), &[1, 2, 3, 4]);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n-        assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -537,13 +546,16 @@ mod test {\n         let mut r = MemReader::new(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n         let mut buf = [0, ..3];\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n-        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        let b: &[_] = &[1, 2, 3];\n+        assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(0, buf.mut_slice_to(0)).is_ok());\n-        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n-        assert_eq!(buf.as_slice(), &[4, 5, 6]);\n+        let b: &[_] = &[4, 5, 6];\n+        assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_err());\n-        assert_eq!(buf.as_slice(), &[7, 8, 6]);\n+        let b: &[_] = &[7, 8, 6];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {"}, {"sha": "03637079241d6cb542d4626f02ee821dd8ca76a7", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -111,7 +111,8 @@ mod test {\n             Ok(MemReader::new(vec!(0, 1, 2, 3)));\n         let mut buf = [0, 0];\n         reader.read(buf).unwrap();\n-        assert_eq!(buf.as_slice(), &[0, 1]);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     #[test]"}, {"sha": "f452f8b23e7bac5fa37c4abbb5fd9a08a1a73658", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -295,7 +295,8 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             for p in input.iter() {\n                 let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n                 let key = Vec::from_slice(it.next().unwrap());\n-                let val = Vec::from_slice(it.next().unwrap_or(&[]));\n+                let default: &[u8] = &[];\n+                let val = Vec::from_slice(it.next().unwrap_or(default));\n                 pairs.push((key, val));\n             }\n             pairs"}, {"sha": "50441cb534de12d0c1da3a1b9156e1fdf572107f", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -846,7 +846,10 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {\n         String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n-                None => &[],\n+                None => {\n+                    let result: &[u8] = &[];\n+                    result\n+                }\n                 Some(v) => v\n             }\n         } else {"}, {"sha": "06eab31d7bff56cab0e62b43ffee63b8ee1af3c3", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -464,6 +464,7 @@ static dot_dot_static: &'static [u8] = b\"..\";\n mod tests {\n     use prelude::*;\n     use super::*;\n+    use mem;\n     use str;\n     use str::StrSlice;\n \n@@ -621,8 +622,10 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n-                    assert!(path.$op() == ($exp).as_bytes());\n+                    unsafe {\n+                        let path = Path::new($path);\n+                        assert!(path.$op() == mem::transmute(($exp).as_bytes()));\n+                    }\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n@@ -634,9 +637,11 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let arg = $path;\n-                    let path = Path::new(arg);\n-                    assert!(path.$op() == $exp);\n+                    unsafe {\n+                        let arg = $path;\n+                        let path = Path::new(arg);\n+                        assert!(path.$op() == mem::transmute($exp));\n+                    }\n                 }\n             );\n         )\n@@ -684,8 +689,9 @@ mod tests {\n         t!(v: b\"hi/there.txt\", extension, Some(b\"txt\"));\n         t!(v: b\"hi/there\\x80.txt\", extension, Some(b\"txt\"));\n         t!(v: b\"hi/there.t\\x80xt\", extension, Some(b\"t\\x80xt\"));\n-        t!(v: b\"hi/there\", extension, None);\n-        t!(v: b\"hi/there\\x80\", extension, None);\n+        let no: Option<&'static [u8]> = None;\n+        t!(v: b\"hi/there\", extension, no);\n+        t!(v: b\"hi/there\\x80\", extension, no);\n         t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n         t!(s: \"hi/there\", extension, None, opt);\n         t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n@@ -974,57 +980,62 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    let filename = $filename;\n-                    assert!(path.filename_str() == filename,\n-                            \"{}.filename_str(): Expected `{:?}`, found {:?}\",\n-                            path.as_str().unwrap(), filename, path.filename_str());\n-                    let dirname = $dirname;\n-                    assert!(path.dirname_str() == dirname,\n-                            \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), dirname, path.dirname_str());\n-                    let filestem = $filestem;\n-                    assert!(path.filestem_str() == filestem,\n-                            \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), filestem, path.filestem_str());\n-                    let ext = $ext;\n-                    assert!(path.extension_str() == ext,\n-                            \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), ext, path.extension_str());\n+                    unsafe {\n+                        let path = $path;\n+                        let filename = $filename;\n+                        assert!(path.filename_str() == filename,\n+                                \"{}.filename_str(): Expected `{:?}`, found {:?}\",\n+                                path.as_str().unwrap(), filename, path.filename_str());\n+                        let dirname = $dirname;\n+                        assert!(path.dirname_str() == dirname,\n+                                \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), dirname, path.dirname_str());\n+                        let filestem = $filestem;\n+                        assert!(path.filestem_str() == filestem,\n+                                \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), filestem, path.filestem_str());\n+                        let ext = $ext;\n+                        assert!(path.extension_str() == mem::transmute(ext),\n+                                \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), ext, path.extension_str());\n+                    }\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    assert!(path.filename() == $filename);\n-                    assert!(path.dirname() == $dirname);\n-                    assert!(path.filestem() == $filestem);\n-                    assert!(path.extension() == $ext);\n+                    unsafe {\n+                        let path = $path;\n+                        assert!(path.filename() == mem::transmute($filename));\n+                        assert!(path.dirname() == mem::transmute($dirname));\n+                        assert!(path.filestem() == mem::transmute($filestem));\n+                        assert!(path.extension() == mem::transmute($ext));\n+                    }\n                 }\n             )\n         )\n \n-        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n-        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n+        let no: Option<&'static str> = None;\n+        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), no);\n+        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), no);\n         t!(v: Path::new(b\"hi/there.\\xFF\"), Some(b\"there.\\xFF\"), b\"hi\",\n               Some(b\"there\"), Some(b\"\\xFF\"));\n-        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, None);\n+        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), no);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, no);\n+        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, no);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, no);\n+        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, no);\n         t!(s: Path::new(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), no);\n         t!(s: Path::new(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), no);\n         t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, no);\n         t!(s: Path::new(b\"a/b/\\xFF.txt\"), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), no);\n+        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), no);\n     }\n \n     #[test]"}, {"sha": "d9864cfaa6130a35a3e4946ae835bdc271056761", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1141,6 +1141,7 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n \n #[cfg(test)]\n mod tests {\n+    use mem;\n     use prelude::*;\n     use super::*;\n     use super::parse_prefix;\n@@ -1383,9 +1384,11 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    assert!(path.$op() == Some($exp));\n+                    unsafe {\n+                        let path = $path;\n+                        let path = Path::new(path);\n+                        assert!(path.$op() == Some(mem::transmute($exp)));\n+                    }\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n@@ -1398,9 +1401,11 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    assert!(path.$op() == $exp);\n+                    unsafe {\n+                        let path = $path;\n+                        let path = Path::new(path);\n+                        assert!(path.$op() == mem::transmute($exp));\n+                    }\n                 }\n             )\n         )\n@@ -1485,7 +1490,8 @@ mod tests {\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n         t!(v: b\"hi\\\\there.txt\", extension, Some(b\"txt\"));\n-        t!(v: b\"hi\\\\there\", extension, None);\n+        let no: Option<&'static [u8]> = None;\n+        t!(v: b\"hi\\\\there\", extension, no);\n         t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n         t!(s: \"hi\\\\there\", extension_str, None, opt);\n         t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n@@ -1892,48 +1898,53 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    let filename = $filename;\n-                    assert!(path.filename_str() == filename,\n-                            \"`{}`.filename_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), filename, path.filename_str());\n-                    let dirname = $dirname;\n-                    assert!(path.dirname_str() == dirname,\n-                            \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), dirname, path.dirname_str());\n-                    let filestem = $filestem;\n-                    assert!(path.filestem_str() == filestem,\n-                            \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), filestem, path.filestem_str());\n-                    let ext = $ext;\n-                    assert!(path.extension_str() == ext,\n-                            \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), ext, path.extension_str());\n+                    unsafe {\n+                        let path = $path;\n+                        let filename = $filename;\n+                        assert!(path.filename_str() == filename,\n+                                \"`{}`.filename_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), filename, path.filename_str());\n+                        let dirname = $dirname;\n+                        assert!(path.dirname_str() == dirname,\n+                                \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), dirname, path.dirname_str());\n+                        let filestem = $filestem;\n+                        assert!(path.filestem_str() == filestem,\n+                                \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), filestem, path.filestem_str());\n+                        let ext = $ext;\n+                        assert!(path.extension_str() == mem::transmute(ext),\n+                                \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), ext, path.extension_str());\n+                    }\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    assert!(path.filename() == $filename);\n-                    assert!(path.dirname() == $dirname);\n-                    assert!(path.filestem() == $filestem);\n-                    assert!(path.extension() == $ext);\n+                    unsafe {\n+                        let path = $path;\n+                        assert!(path.filename() == mem::transmute($filename));\n+                        assert!(path.dirname() == mem::transmute($dirname));\n+                        assert!(path.filestem() == mem::transmute($filestem));\n+                        assert!(path.extension() == mem::transmute($ext));\n+                    }\n                 }\n             )\n         )\n \n-        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n-        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n+        let no: Option<&'static str> = None;\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), no);\n+        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), no);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, no);\n+        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, no);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, no);\n+        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, no);\n         t!(s: Path::new(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), no);\n         t!(s: Path::new(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), no);\n         t!(s: Path::new(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n "}, {"sha": "b9b7a02b62f1ba09f9c63a08c6ff49e39b14c4c7", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -531,15 +531,17 @@ mod test {\n         r.shuffle(empty);\n         let mut one = [1i];\n         r.shuffle(one);\n-        assert_eq!(one.as_slice(), &[1]);\n+        let b: &[_] = &[1];\n+        assert_eq!(one.as_slice(), b);\n \n         let mut two = [1i, 2];\n         r.shuffle(two);\n         assert!(two == [1, 2] || two == [2, 1]);\n \n         let mut x = [1i, 1, 1];\n         r.shuffle(x);\n-        assert_eq!(x.as_slice(), &[1, 1, 1]);\n+        let b: &[_] = &[1, 1, 1];\n+        assert_eq!(x.as_slice(), b);\n     }\n \n     #[test]\n@@ -548,7 +550,8 @@ mod test {\n         r.gen::<int>();\n         let mut v = [1i, 1, 1];\n         r.shuffle(v);\n-        assert_eq!(v.as_slice(), &[1, 1, 1]);\n+        let b: &[_] = &[1, 1, 1];\n+        assert_eq!(v.as_slice(), b);\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n "}, {"sha": "7d5787092a5c5df13f1b8910a82db15c8c450121", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -394,16 +394,6 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum ExprVstore {\n-    /// ~[1, 2, 3, 4]\n-    ExprVstoreUniq,\n-    /// &[1, 2, 3, 4]\n-    ExprVstoreSlice,\n-    /// &mut [1, 2, 3, 4]\n-    ExprVstoreMutSlice,\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BinOp {\n     BiAdd,\n@@ -522,7 +512,6 @@ pub struct Expr {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n-    ExprVstore(Gc<Expr>, ExprVstore),\n     /// First expr is the place; second expr is the value.\n     ExprBox(Gc<Expr>, Gc<Expr>),\n     ExprVec(Vec<Gc<Expr>>),"}, {"sha": "909f8f1e78ce42e9768cff7c5aa4fe9234b42e97", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -143,12 +143,10 @@ pub trait AstBuilder {\n     fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr>;\n     fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr>;\n \n-    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr>;\n     fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n     fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr>;\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n     fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n \n     fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n@@ -654,9 +652,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }\n \n-    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr> {\n-        self.expr(sp, ast::ExprVstore(expr, vst))\n-    }\n     fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprVec(exprs))\n     }\n@@ -669,15 +664,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               Vec::new())\n     }\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n-        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n+        self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n     fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n-        self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n-    }\n-\n \n     fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>, ty: P<ast::Ty>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprCast(expr, ty))"}, {"sha": "4a0787aeb9efab7a472c765749caa75be8a46c90", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1088,9 +1088,6 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n     let id = folder.new_id(e.id);\n     let node = match e.node {\n-        ExprVstore(e, v) => {\n-            ExprVstore(folder.fold_expr(e), v)\n-        }\n         ExprBox(p, e) => {\n             ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n         }"}, {"sha": "585b98925cc58f963aa804775e736347f215ab20", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1137,7 +1137,8 @@ mod test {\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n         let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n                     .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n-        assert_eq!(docs.as_slice(), &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()]);\n+        let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n+        assert_eq!(docs.as_slice(), b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();"}, {"sha": "01de001c043c748b8f65add177da2001a2b5628a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 67, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -27,9 +27,8 @@ use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n-use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n-use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, Field, FnDecl};\n-use ast::{ExprVstoreUniq, Once, Many};\n+use ast::{ExprVec, ExprWhile, ExprForLoop, Field, FnDecl};\n+use ast::{Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n@@ -62,7 +61,7 @@ use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause, WherePredicate};\n use ast;\n-use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n+use ast_util::{as_prec, ident_to_path, operator_prec};\n use ast_util;\n use attr;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n@@ -1428,13 +1427,16 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n-            let last_span = self.last_span;\n+            let span = self.last_span;\n             match self.token {\n-                token::LBRACKET =>\n-                    self.obsolete(last_span, ObsoleteOwnedVector),\n-                _ => self.obsolete(last_span, ObsoleteOwnedType),\n-            };\n-            TyUniq(self.parse_ty(true))\n+                token::IDENT(ref ident, _)\n+                        if \"str\" == token::get_ident(*ident).get() => {\n+                    // This is OK (for now).\n+                }\n+                token::LBRACKET => {}   // Also OK.\n+                _ => self.obsolete(span, ObsoleteOwnedType)\n+            }\n+            TyUniq(self.parse_ty(false))\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -2549,16 +2551,7 @@ impl<'a> Parser<'a> {\n             let m = self.parse_mutability();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn &[...] into a &-vec\n-            ex = match e.node {\n-              ExprVec(..) if m == MutImmutable => {\n-                ExprVstore(e, ExprVstoreSlice)\n-              }\n-              ExprVec(..) if m == MutMutable => {\n-                ExprVstore(e, ExprVstoreMutSlice)\n-              }\n-              _ => ExprAddrOf(m, e)\n-            };\n+            ex = ExprAddrOf(m, e);\n           }\n           token::AT => {\n             self.bump();\n@@ -2570,61 +2563,43 @@ impl<'a> Parser<'a> {\n           }\n           token::TILDE => {\n             self.bump();\n+            let span = self.last_span;\n+            match self.token {\n+                token::LIT_STR(_) => {\n+                    // This is OK (for now).\n+                }\n+                token::LBRACKET => {}   // Also OK.\n+                _ => self.obsolete(span, ObsoleteOwnedExpr)\n+            }\n \n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn ~[...] into a ~-vec\n-            let last_span = self.last_span;\n-            ex = match e.node {\n-              ExprVec(..) | ExprRepeat(..) => {\n-                  self.obsolete(last_span, ObsoleteOwnedVector);\n-                  ExprVstore(e, ExprVstoreUniq)\n-              }\n-              ExprLit(lit) if lit_is_str(lit) => {\n-                  self.obsolete(last_span, ObsoleteOwnedExpr);\n-                  ExprVstore(e, ExprVstoreUniq)\n-              }\n-              _ => {\n-                  self.obsolete(last_span, ObsoleteOwnedExpr);\n-                  self.mk_unary(UnUniq, e)\n-              }\n-            };\n+            ex = self.mk_unary(UnUniq, e);\n           }\n           token::IDENT(_, _) => {\n-              if self.is_keyword(keywords::Box) {\n-                self.bump();\n+            if !self.is_keyword(keywords::Box) {\n+                return self.parse_dot_or_call_expr();\n+            }\n \n-                // Check for a place: `box(PLACE) EXPR`.\n-                if self.eat(&token::LPAREN) {\n-                    // Support `box() EXPR` as the default.\n-                    if !self.eat(&token::RPAREN) {\n-                        let place = self.parse_expr();\n-                        self.expect(&token::RPAREN);\n-                        let subexpression = self.parse_prefix_expr();\n-                        hi = subexpression.span.hi;\n-                        ex = ExprBox(place, subexpression);\n-                        return self.mk_expr(lo, hi, ex);\n-                    }\n+            self.bump();\n+\n+            // Check for a place: `box(PLACE) EXPR`.\n+            if self.eat(&token::LPAREN) {\n+                // Support `box() EXPR` as the default.\n+                if !self.eat(&token::RPAREN) {\n+                    let place = self.parse_expr();\n+                    self.expect(&token::RPAREN);\n+                    let subexpression = self.parse_prefix_expr();\n+                    hi = subexpression.span.hi;\n+                    ex = ExprBox(place, subexpression);\n+                    return self.mk_expr(lo, hi, ex);\n                 }\n+            }\n \n-                // Otherwise, we use the unique pointer default.\n-                let subexpression = self.parse_prefix_expr();\n-                hi = subexpression.span.hi;\n-                // HACK: turn `box [...]` into a boxed-vec\n-                ex = match subexpression.node {\n-                    ExprVec(..) | ExprRepeat(..) => {\n-                        let last_span = self.last_span;\n-                        self.obsolete(last_span, ObsoleteOwnedVector);\n-                        ExprVstore(subexpression, ExprVstoreUniq)\n-                    }\n-                    ExprLit(lit) if lit_is_str(lit) => {\n-                        ExprVstore(subexpression, ExprVstoreUniq)\n-                    }\n-                    _ => self.mk_unary(UnUniq, subexpression)\n-                };\n-              } else {\n-                return self.parse_dot_or_call_expr()\n-              }\n+            // Otherwise, we use the unique pointer default.\n+            let subexpression = self.parse_prefix_expr();\n+            hi = subexpression.span.hi;\n+            ex = self.mk_unary(UnUniq, subexpression);\n           }\n           _ => return self.parse_dot_or_call_expr()\n         }"}, {"sha": "d5b6c5652a0ccf9a9eb95775ceb1a23d23d6a795", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -159,14 +159,16 @@ impl<'a> State<'a> {\n }\n \n pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n+    use std::raw::TraitObject;\n     let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n     unsafe {\n         // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n         // that we \"know\" to be a `MemWriter` that works around the lack of checked\n         // downcasts.\n-        let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n+        let obj: TraitObject = mem::transmute_copy(&s.s.out);\n+        let wr: Box<MemWriter> = mem::transmute(obj.data);\n         let result =\n             String::from_utf8(Vec::from_slice(wr.get_ref().as_slice())).unwrap();\n         mem::forget(wr);\n@@ -1321,16 +1323,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_expr_vstore(&mut self, t: ast::ExprVstore) -> IoResult<()> {\n-        match t {\n-            ast::ExprVstoreUniq => word(&mut self.s, \"box \"),\n-            ast::ExprVstoreSlice => word(&mut self.s, \"&\"),\n-            ast::ExprVstoreMutSlice => {\n-                try!(word(&mut self.s, \"&\"));\n-                word(&mut self.s, \"mut\")\n-            }\n-        }\n-    }\n \n     fn print_call_post(&mut self, args: &[Gc<ast::Expr>]) -> IoResult<()> {\n         try!(self.popen());\n@@ -1355,10 +1347,6 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprVstore(ref e, v) => {\n-                try!(self.print_expr_vstore(v));\n-                try!(self.print_expr(&**e));\n-            },\n             ast::ExprBox(ref p, ref e) => {\n                 try!(word(&mut self.s, \"box\"));\n                 try!(word(&mut self.s, \"(\"));"}, {"sha": "517c5e5bf47da3ca809503387efdc79740bc8090", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -64,7 +64,10 @@ impl<T> SmallVector<T> {\n \n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n         match self.repr {\n-            Zero => &[],\n+            Zero => {\n+                let result: &[T] = &[];\n+                result\n+            }\n             One(ref v) => slice::ref_slice(v),\n             Many(ref vs) => vs.as_slice()\n         }"}, {"sha": "6c6f59f0df6391de5e4aff636685253dafa0d39f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -729,9 +729,6 @@ pub fn walk_mac<E, V: Visitor<E>>(_: &mut V, _: &Mac, _: E) {\n \n pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, env: E) {\n     match expression.node {\n-        ExprVstore(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression, env.clone())\n-        }\n         ExprBox(ref place, ref subexpression) => {\n             visitor.visit_expr(&**place, env.clone());\n             visitor.visit_expr(&**subexpression, env.clone())"}, {"sha": "429a16ec5c89aee418cb8271ec270551f54ae065", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1060,7 +1060,6 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n           'w' => (tm.tm_wday as int).to_string(),\n           'Y' => (tm.tm_year as int + 1900).to_string(),\n           'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => \"\".to_string(),    // FIXME(pcwalton): Implement this.\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;"}, {"sha": "c71cf5557e35f89f293056daa90de5762d71af75", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -46,9 +46,11 @@ pub trait UnicodeStrSlice<'a> {\n     ///\n     /// ```rust\n     /// let gr1 = \"a\\u0310e\\u0301o\\u0308\\u0332\".graphemes(true).collect::<Vec<&str>>();\n-    /// assert_eq!(gr1.as_slice(), &[\"a\\u0310\", \"e\\u0301\", \"o\\u0308\\u0332\"]);\n+    /// let b: &[_] = &[\"a\\u0310\", \"e\\u0301\", \"o\\u0308\\u0332\"];\n+    /// assert_eq!(gr1.as_slice(), b);\n     /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n-    /// assert_eq!(gr2.as_slice(), &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"]);\n+    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n     fn graphemes(&self, is_extended: bool) -> Graphemes<'a>;\n \n@@ -59,7 +61,8 @@ pub trait UnicodeStrSlice<'a> {\n     ///\n     /// ```rust\n     /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-    /// assert_eq!(gr_inds.as_slice(), &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")]);\n+    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices<'a>;\n "}, {"sha": "b5ffdef22e968dac5531f33fd210cacbdb41bfe9", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -1095,7 +1095,8 @@ mod tests {\n         t(\"\\0\", \"%00\");\n         t(\"\\n\", \"%0A\");\n \n-        t(&[0u8, 10, 37], \"%00%0A%25\");\n+        let a: &[_] = &[0u8, 10, 37];\n+        t(a, \"%00%0A%25\");\n     }\n \n     #[test]\n@@ -1130,7 +1131,8 @@ mod tests {\n         t(\"\\0\", \"%00\");\n         t(\"\\n\", \"%0A\");\n \n-        t(&[0u8, 10, 37], \"%00%0A%25\");\n+        let a: &[_] = &[0u8, 10, 37];\n+        t(a, \"%00%0A%25\");\n     }\n \n     #[test]"}, {"sha": "f68ace395aaa5f97483ebec2c33fa1243bd7ccfd", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -100,7 +100,8 @@ fn main() {\n     let mut rand = Vec::with_capacity(n_keys);\n \n     {\n-        let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);\n+        let seed: &[_] = &[1, 1, 1, 1, 1, 1, 1];\n+        let mut rng: IsaacRng = SeedableRng::from_seed(seed);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.gen();"}, {"sha": "7f85bc1d700aff3ef683b073563a9b98bb168c0a", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -164,7 +164,7 @@ fn main() {\n         }\n     };\n \n-    let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let max = 200000;\n \n     {"}, {"sha": "6b8e126db7790a51989b47f8ff98a65125090266", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n static a: &'static str = \"foo\";\n-static b: *const u8 = a as *const u8; //~ ERROR non-scalar cast\n-static c: *const u8 = &a as *const u8; //~ ERROR mismatched types\n+static b: *const u8 = a as *const u8;\n+//~^ ERROR mismatched types: expected `*const u8`, found `&'static str`\n+static c: *const u8 = &a as *const u8;\n+//~^ ERROR mismatched types: expected `*const u8`, found `&&'static str`\n \n fn main() {\n }"}, {"sha": "08e51038104365e985b2d2599f8f604293600c26", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+struct Fat<Sized? T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar1 {\n+    f: int\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> int;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    let z: Box<ToBar> = box Bar1 {f: 36};\n+    f5.ptr = *z;  //~ ERROR dynamically sized type on lhs of assignment\n+}"}, {"sha": "17149941a7e1a4c0e6787d49947cabea02e25a72", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+struct Fat<Sized? T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar1 {\n+    f: int\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> int;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    let z: Box<ToBar> = box Bar1 {f: 36};\n+    f5.ptr = Bar1 {f: 36}; //~ ERROR mismatched types: expected `ToBar`, found `Bar1`\n+}"}, {"sha": "a609740eaebf50c1e0be78b50a774037c805eacf", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to change the type as well as unsizing.\n+\n+struct Fat<Sized? T> {\n+    ptr: T\n+}\n+\n+struct Foo;\n+trait Bar {}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = &f1;\n+    let f3: &Fat<[uint]> = f2;\n+    //~^ ERROR mismatched types: expected `&Fat<[uint]>`, found `&Fat<[int, .. 3]>`\n+\n+    // With a trait.\n+    let f1 = Fat { ptr: Foo };\n+    let f2: &Fat<Foo> = &f1;\n+    let f3: &Fat<Bar> = f2;\n+    //~^ ERROR failed to find an implementation of trait Bar for Foo\n+}"}, {"sha": "118e4ce7e08340ac015bd7e0168805d82219c530", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to change the mutability as well as unsizing.\n+\n+struct Fat<Sized? T> {\n+    ptr: T\n+}\n+\n+struct Foo;\n+trait Bar {}\n+impl Bar for Foo {}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = &f1;\n+    let f3: &mut Fat<[int]> = f2; //~ ERROR cannot borrow immutable dereference\n+\n+    // With a trait.\n+    let f1 = Fat { ptr: Foo };\n+    let f2: &Fat<Foo> = &f1;\n+    let f3: &mut Fat<Bar> = f2; //~ ERROR cannot borrow immutable dereference\n+}"}, {"sha": "7cf647a26d7a7ef89fb318449d7d3a7619aa0020", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to extend the lifetime as well as unsizing.\n+\n+struct Fat<Sized? T> {\n+    ptr: T\n+}\n+\n+struct Foo;\n+trait Bar {}\n+impl Bar for Foo {}\n+\n+fn baz<'a>() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a Fat<[int]> = f2;\n+\n+    // With a trait.\n+    let f1 = Fat { ptr: Foo };\n+    let f2: &Fat<Foo> = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a Fat<Bar> = f2;\n+}\n+\n+pub fn main() {\n+    baz();\n+}"}, {"sha": "9a192334997d28e47ad939fa2bef2b3af7748652", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to coerce from unsized to sized.\n+\n+struct Fat<Sized? T> {\n+    ptr: T\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = f1;\n+    //~^ ERROR mismatched types: expected `&Fat<[int, .. 3]>`, found `&Fat<[int]>`\n+}"}, {"sha": "cf526392283304bc0274daf84700e50577a7c8be", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Try to initialise a DST struct where the lost information is deeply nested.\n+// This is an error because it requires an unsized rvalue. This is a problem\n+// because it would require stack allocation of an unsized temporary (*g in the\n+// test).\n+\n+struct Fat<Sized? T> {\n+    ptr: T\n+}\n+\n+pub fn main() {\n+    let f: Fat<[int, ..3]> = Fat { ptr: [5i, 6, 7] };\n+    let g: &Fat<[int]> = &f;\n+    let h: &Fat<Fat<[int]>> = &Fat { ptr: *g };\n+    //~^ ERROR trying to initialise a dynamically sized struct\n+}"}, {"sha": "8ae20dfde9123e68e869ee3a6e53a176de7b5032", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test<'x>(x: &'x int) { //~ NOTE the lifetime 'x as defined\n+fn test<'x>(x: &'x int) {\n     drop::< <'z>|&'z int| -> &'z int>(|z| {\n-        //~^ ERROR mismatched types\n-        //~^^ ERROR cannot infer an appropriate lifetime\n         x\n+        //~^ ERROR cannot infer an appropriate lifetime\n     });\n }\n "}, {"sha": "162324b7c59b25e1b2473c343f64803e7c910dca", "filename": "src/test/compile-fail/issue-13446.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -11,7 +11,9 @@\n \n // Used to cause ICE\n \n-static VEC: [u32, ..256] = vec!(); //~ ERROR mismatched types\n+// error-pattern: mismatched types\n+\n+static VEC: [u32, ..256] = vec!();\n \n fn main() {}\n "}, {"sha": "ab9f7a8453078b0beb77decdf7120b5609e4c27a", "filename": "src/test/compile-fail/issue-3907-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -11,10 +11,12 @@\n // aux-build:issue_3907.rs\n extern crate issue_3907;\n \n-type Foo = issue_3907::Foo; //~ ERROR: reference to trait\n+type Foo = issue_3907::Foo;\n \n struct S {\n     name: int\n }\n \n+fn bar(_x: Foo) {} //~ ERROR variable `_x` has dynamically sized type `issue_3907::Foo`\n+\n fn main() {}"}, {"sha": "5063a78e38348d6eb0e4e8fcbdaf4ebfe70f7e30", "filename": "src/test/compile-fail/issue-4523.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -10,8 +10,8 @@\n \n fn foopy() {}\n \n-static f: ||: 'static = foopy; //~ ERROR found extern fn\n+static f: ||: 'static = foopy;\n \n fn main () {\n-    f();\n+    f(); //~ ERROR closure invocation in a static location\n }"}, {"sha": "199bc3f5c29d9a22a060528fbd99efa768c6b357", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -17,7 +17,7 @@ pub enum TraitWrapper {\n \n fn get_tw_map(tw: &TraitWrapper) -> &MyTrait {\n     match *tw {\n-        A(box ref map) => map, //~ ERROR cannot be dereferenced\n+        A(box ref map) => map, //~ ERROR type `Box<MyTrait>` cannot be dereferenced\n     }\n }\n "}, {"sha": "689b8f7c6136043d9e4dbb42342c704a716715f7", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n trait I {}\n-type K = I; //~ ERROR: reference to trait\n+type K = I;\n+\n+fn foo(_x: K) {} //~ ERROR: variable `_x` has dynamically sized type `I`\n \n fn main() {}"}, {"sha": "14136d96c2dffc71dec1413da0f3217f927a5795", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -11,15 +11,14 @@\n trait A {}\n \n struct Struct {\n-    r: A //~ ERROR reference to trait `A` where a type is expected; try `Box<A>` or `&A`\n+    r: A\n }\n \n fn new_struct(r: A) -> Struct {\n-    //~^ ERROR reference to trait `A` where a type is expected; try `Box<A>` or `&A`\n-    Struct { r: r }\n+    //~^ ERROR variable `r` has dynamically sized type `A`\n+    Struct { r: r } //~ ERROR trying to initialise a dynamically sized struct\n }\n \n trait Curve {}\n enum E {X(Curve)}\n-//~^ ERROR reference to trait `Curve` where a type is expected; try `Box<Curve>` or `&Curve`\n fn main() {}"}, {"sha": "ef585998aa5a5b5ce83f95475c176d5c0d04783d", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -32,7 +32,7 @@ struct A {\n \n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n-    //~^ ERROR cannot pack type `Box<B>`, which does not fulfill `Send`\n+    //~^ ERROR cannot pack type `Box<B>`, which does not fulfill `Send`, as a trait bounded by Send\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();\n     let b = &*v;"}, {"sha": "481fb3dee73a83630671978f74cf740339fdf98b", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -36,14 +36,14 @@ fn foo4<'a, 'b>(x: &'a Foo) -> (&'b int, &'a int, &'b int) {\n struct Bar<'x, 'y, 'z> { bar: &'y int, baz: int }\n fn bar1<'a>(x: &Bar) -> (&'a int, &'a int, &'a int) {\n //~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n-    (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n+    (x.bar, &x.baz, &x.baz) //~ ERROR: cannot infer\n     //~^ ERROR: cannot infer\n     //~^^ ERROR: cannot infer\n }\n \n fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a int, &'a int, &'a int) {\n //~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n-    (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n+    (x.bar, &x.baz, &x.baz) //~ ERROR: cannot infer\n     //~^ ERROR: cannot infer\n     //~^^ ERROR: cannot infer\n }\n@@ -53,21 +53,19 @@ struct Dog<'y> { dog: &'y int }\n \n fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'x int {\n //~^ NOTE: consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x int\n-    x.t.dog //~ ERROR: mismatched types\n+    x.t.dog //~ ERROR: cannot infer\n }\n \n struct Baz<'x> {\n     bar: &'x int\n }\n \n-\n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &int) -> (&'b int, &'b int) {\n         // The lifetime that gets assigned to `x` seems somewhat random.\n         // I have disabled this test for the time being. --pcwalton\n         (self.bar, x) //~ ERROR: cannot infer\n-        //~^ ERROR: mismatched types\n-        //~^^ ERROR: mismatched types\n+        //~^ ERROR: cannot infer\n     }\n }\n "}, {"sha": "5440219e55eb969b09d1a21d3074774b9550d998", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -31,18 +31,18 @@ pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n }\n \n pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    if maybestr.is_none() { //~ ERROR mismatched types\n+    if maybestr.is_none() {\n         \"(none)\"\n     } else {\n         let s: &'a str = maybestr.get_ref().as_slice();\n-        s\n+        s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     }\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    if maybestr.is_some() {  //~ ERROR mismatched types\n+    if maybestr.is_some() {\n         let s: &'a str = maybestr.get_ref().as_slice();\n-        s\n+        s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     } else {\n         \"(none)\"\n     }"}, {"sha": "febe5f45d96b07bcee63a2c52f5b193e245d0f9e", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -33,7 +33,7 @@ pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n }\n \n pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    match *maybestr { //~ ERROR mismatched types\n+    match *maybestr {  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n         None => \"(none)\",\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n@@ -43,7 +43,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    match *maybestr { //~ ERROR mismatched types\n+    match *maybestr {  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n             s"}, {"sha": "0cb88b924f85c204d660790c8fdf86db0aad0843", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -27,7 +27,7 @@ impl<'a> GetRef<'a> for Box<'a> {\n \n impl<'a> Box<'a> {\n     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a int {\n-        g2.get() //~ ERROR lifetime mismatch\n+        g2.get() //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n     }\n }\n "}, {"sha": "25016c104adc8f58f0e096f3b019c9410193fdac", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -26,7 +26,7 @@ impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n }\n \n fn get<'a,'b,G:GetRef<'a, int>>(g1: G, b: &'b int) -> &'b int {\n-    g1.get() //~ ERROR lifetime mismatch\n+    g1.get() //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n }\n \n fn main() {"}, {"sha": "0eb47da16b600cbe3d869725aa8c82e51bf4e05f", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -22,9 +22,9 @@ mod argparse {\n \n     impl<'a> Flag<'a> {\n         pub fn set_desc(self, s: &str) -> Flag<'a> {\n-            Flag { //~ ERROR cannot infer\n+            Flag {\n                 name: self.name,\n-                desc: s,\n+                desc: s, //~ ERROR cannot infer an appropriate lifetime for automatic coercion due t\n                 max_count: self.max_count,\n                 value: self.value\n             }"}, {"sha": "7dc57d37e2496461c25c19757d28f275219f8957", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -21,8 +21,7 @@ fn nested<'x>(x: &'x int) {\n     });\n \n     ignore::< <'z>|&'z int| -> &'z int>(|z| {\n-        if false { return x; }  //~ ERROR mismatched types\n-        //~^ ERROR cannot infer\n+        if false { return x; }  //~ ERROR cannot infer an appropriate lifetime for automatic\n         if false { return ay; }\n         return z;\n     });"}, {"sha": "df46b2aaac0134b6f56c4af5a42e23e3ff14e81b", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -17,7 +17,7 @@ fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n }\n \n fn return_it<'a>() -> &'a int {\n-    with(|o| o) //~ ERROR mismatched types\n+    with(|o| o)\n         //~^ ERROR lifetime of return value does not outlive the function call\n         //~^^ ERROR cannot infer\n }"}, {"sha": "507a48fb741704ee9127610fb088aef9a201b5bb", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -20,7 +20,7 @@ fn with<R>(f: |x: &int| -> R) -> R {\n }\n \n fn return_it<'a>() -> &'a int {\n-    with(|o| o) //~ ERROR mismatched types\n+    with(|o| o)\n         //~^ ERROR lifetime of return value does not outlive the function call\n         //~^^ ERROR cannot infer\n }"}, {"sha": "3c5423c44d089df13a60efedb3260b7042bd4998", "filename": "src/test/compile-fail/regions-return-stack-allocated-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-return-stack-allocated-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Fregions-return-stack-allocated-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-return-stack-allocated-vec.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -11,7 +11,7 @@\n // Test that we cannot return a stack allocated slice\n \n fn function(x: int) -> &'static [int] {\n-    &[x] //~ ERROR mismatched types\n+    &[x] //~ ERROR borrowed value does not live long enough\n }\n \n fn main() {"}, {"sha": "78b4ab817bfacd3dc2cf81ec3ea54820173a0a04", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -14,7 +14,7 @@ trait Foo {\n // This should emit the less confusing error, not the more confusing one.\n \n fn foo(_x: Foo + Send) {\n-    //~^ERROR reference to trait `Foo` where a type is expected; try `Box<Foo>` or `&Foo`\n+    //~^ERROR variable `_x` has dynamically sized type `Foo+Send`\n }\n \n fn main() { }"}, {"sha": "1500a3cbe52db8df89ba0a5b382716b16bb28543", "filename": "src/test/compile-fail/tuple-arity-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -13,6 +13,6 @@\n fn first((value, _): (int, f64)) -> int { value }\n \n fn main() {\n-    let y = first ((1,2,3));\n+    let y = first ((1,2.0,3));\n     //~^ ERROR expected a tuple with 2 elements, found one with 3 elements\n }"}, {"sha": "7f93c8595f2a2721dd2b001848fdd9c0df606eb9", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -48,8 +48,8 @@\n                        as core::fmt::rt::Piece<'static>)] as\n                      [core::fmt::rt::Piece<'static>, .. 1]);\n              let __args_vec =\n-                 (&([] as &'static [core::fmt::Argument<'static>]) as\n-                     &'static [core::fmt::Argument<'static>]);\n+                 (&([] as [core::fmt::Argument<'static>, .. 0]) as\n+                     &'static [core::fmt::Argument<'static>, .. 0]);\n              let __args =\n                  (unsafe {\n                       ((::std::fmt::Arguments::new as\n@@ -58,7 +58,7 @@\n                                                                                                                                                [core::fmt::rt::Piece<'static>, .. 1]),\n                                                                                                                                            (__args_vec\n                                                                                                                                                as\n-                                                                                                                                               &'static [core::fmt::Argument<'static>]))\n+                                                                                                                                               &'static [core::fmt::Argument<'static>, .. 0]))\n                           as core::fmt::Arguments<'static>)\n                   } as core::fmt::Arguments<'static>);\n "}, {"sha": "77ee0df5512ef05484f444c167dba6716bab8e84", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -6,37 +6,37 @@ digraph block {\n     N4[label=\"expr 151i\"];\n     N5[label=\"local mut y\"];\n     N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l                if y >= 2i { break ; \\\"unreachable\\\" }\\l                y -= 3i;\\l            }\\l        y -= 4i;\\l        x -= 5i;\\l    }\\l\"];\n+    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { break ; \\\"unreachable\\\"; }\\l                y -= 3i;\\l            }\\l        y -= 4i;\\l        x -= 5i;\\l    }\\l\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l        if y >= 2i { break ; \\\"unreachable\\\" }\\l        y -= 3i;\\l    }\\l\"];\n+    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l\"];\n     N10[label=\"expr x\"];\n     N11[label=\"expr 1i\"];\n     N12[label=\"expr x == 1i\"];\n     N13[label=\"expr break \\'outer\"];\n     N14[label=\"(dummy_node)\"];\n     N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { break \\'outer ; \\\"unreachable\\\" }\"];\n-    N17[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\" }\"];\n+    N16[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N17[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n     N18[label=\"expr y\"];\n     N19[label=\"expr 2i\"];\n     N20[label=\"expr y >= 2i\"];\n     N21[label=\"expr break\"];\n     N22[label=\"(dummy_node)\"];\n     N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { break ; \\\"unreachable\\\" }\"];\n-    N25[label=\"expr if y >= 2i { break ; \\\"unreachable\\\" }\"];\n+    N24[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N25[label=\"expr if y >= 2i { break ; \\\"unreachable\\\"; }\"];\n     N26[label=\"expr 3i\"];\n     N27[label=\"expr y\"];\n     N28[label=\"expr y -= 3i\"];\n-    N29[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l    if y >= 2i { break ; \\\"unreachable\\\" }\\l    y -= 3i;\\l}\\l\"];\n+    N29[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n     N30[label=\"expr 4i\"];\n     N31[label=\"expr y\"];\n     N32[label=\"expr y -= 4i\"];\n     N33[label=\"expr 5i\"];\n     N34[label=\"expr x\"];\n     N35[label=\"expr x -= 5i\"];\n-    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l            if y >= 2i { break ; \\\"unreachable\\\" }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n-    N37[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l                    if y >= 2i { break ; \\\"unreachable\\\" }\\l                    y -= 3i;\\l                }\\l            y -= 4i;\\l            x -= 5i;\\l        }\\l}\\l\"];\n+    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n+    N37[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { break ; \\\"unreachable\\\"; }\\l                    y -= 3i;\\l                }\\l            y -= 4i;\\l            x -= 5i;\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -47,7 +47,7 @@ digraph block {\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\" },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l    if y >= 2i { break ; \\\"unreachable\\\" }\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l        if y >= 2i { break ; \\\"unreachable\\\" }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l        if y >= 2i { break ; \\\"unreachable\\\" }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l            if y >= 2i { break ; \\\"unreachable\\\" }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n+    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n     N14 -> N15;\n     N15 -> N16;\n     N12 -> N17;\n@@ -56,7 +56,7 @@ digraph block {\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\" },\\lexiting scope_3 expr if y >= 2i { break ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if y >= 2i { break ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l    if y >= 2i { break ; \\\"unreachable\\\" }\\l    y -= 3i;\\l}\\l\"];\n+    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n     N22 -> N23;\n     N23 -> N24;\n     N20 -> N25;"}, {"sha": "62233dcb7d8a18cfba44f8971606ace62202ea41", "filename": "src/test/run-make/graphviz-flowgraph/f15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -16,11 +16,11 @@ pub fn expr_break_label_15() {\n         'inner: loop {\n             if x == 1i {\n                 break 'outer;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             if y >= 2i {\n                 break;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             y -= 3i;\n         }"}, {"sha": "b5a867e60297f8202557870ebcbedbf550a883fb", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -6,38 +6,38 @@ digraph block {\n     N4[label=\"expr 16i\"];\n     N5[label=\"local mut y\"];\n     N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l                if y >= 1i { break ; \\\"unreachable\\\" }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n+    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l        if y >= 1i { break ; \\\"unreachable\\\" }\\l        y -= 1i;\\l    }\\l\"];\n+    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l\"];\n     N10[label=\"expr x\"];\n     N11[label=\"expr 1i\"];\n     N12[label=\"expr x == 1i\"];\n     N13[label=\"expr continue \\'outer\"];\n     N14[label=\"(dummy_node)\"];\n     N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { continue \\'outer ; \\\"unreachable\\\" }\"];\n-    N17[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\"];\n+    N16[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N17[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n     N18[label=\"expr y\"];\n     N19[label=\"expr 1i\"];\n     N20[label=\"expr y >= 1i\"];\n     N21[label=\"expr break\"];\n     N22[label=\"(dummy_node)\"];\n     N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { break ; \\\"unreachable\\\" }\"];\n-    N25[label=\"expr if y >= 1i { break ; \\\"unreachable\\\" }\"];\n+    N24[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N25[label=\"expr if y >= 1i { break ; \\\"unreachable\\\"; }\"];\n     N26[label=\"expr 1i\"];\n     N27[label=\"expr y\"];\n     N28[label=\"expr y -= 1i\"];\n-    N29[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l    if y >= 1i { break ; \\\"unreachable\\\" }\\l    y -= 1i;\\l}\\l\"];\n+    N29[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n     N30[label=\"expr 1i\"];\n     N31[label=\"expr y\"];\n     N32[label=\"expr y -= 1i\"];\n     N33[label=\"expr 1i\"];\n     N34[label=\"expr x\"];\n     N35[label=\"expr x -= 1i\"];\n-    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l            if y >= 1i { break ; \\\"unreachable\\\" }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n+    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n     N37[label=\"expr \\\"unreachable\\\"\"];\n-    N38[label=\"block {\\l    let mut x = 16i;\\l    let mut y = 16i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l                    if y >= 1i { break ; \\\"unreachable\\\" }\\l                    y -= 1i;\\l                }\\l            y -= 1i;\\l            x -= 1i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N38[label=\"block {\\l    let mut x = 16i;\\l    let mut y = 16i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1i { break ; \\\"unreachable\\\"; }\\l                    y -= 1i;\\l                }\\l            y -= 1i;\\l            x -= 1i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -48,7 +48,7 @@ digraph block {\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N6[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\" },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l    if y >= 1i { break ; \\\"unreachable\\\" }\\l    y -= 1i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l        if y >= 1i { break ; \\\"unreachable\\\" }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l        if y >= 1i { break ; \\\"unreachable\\\" }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l            if y >= 1i { break ; \\\"unreachable\\\" }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n+    N13 -> N6[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n     N14 -> N15;\n     N15 -> N16;\n     N12 -> N17;\n@@ -57,7 +57,7 @@ digraph block {\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\" },\\lexiting scope_3 expr if y >= 1i { break ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if y >= 1i { break ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l    if y >= 1i { break ; \\\"unreachable\\\" }\\l    y -= 1i;\\l}\\l\"];\n+    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n     N22 -> N23;\n     N23 -> N24;\n     N20 -> N25;"}, {"sha": "2683d8bd06b9792479b247ce03ff2597399c1638", "filename": "src/test/run-make/graphviz-flowgraph/f16.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -16,11 +16,11 @@ pub fn expr_continue_label_16() {\n         'inner: loop {\n             if x == 1i {\n                 continue 'outer;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             if y >= 1i {\n                 break;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             y -= 1i;\n         }"}, {"sha": "058dc426766bce81c451211b61554fdb230b4833", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -37,13 +37,16 @@ pub fn main() {\n         _ => fail!()\n     }\n \n-    assert_eq!(b\"a\\n\\r\\t\\\\\\'\\\"\\0\\xF0\",\n-               &[97u8, 10u8, 13u8, 9u8, 92u8, 39u8, 34u8, 0u8, 240u8]);\n+    let expected: &[_] = &[97u8, 10u8, 13u8, 9u8, 92u8, 39u8, 34u8, 0u8, 240u8];\n+    assert_eq!(b\"a\\n\\r\\t\\\\\\'\\\"\\0\\xF0\", expected);\n+    let expected: &[_] = &[97u8, 98u8];\n     assert_eq!(b\"a\\\n-                 b\", &[97u8, 98u8]);\n-    assert_eq!(BAR, &[97u8, 240u8, 9u8]);\n+                 b\", expected);\n+    let expected: &[_] = &[97u8, 240u8, 9u8];\n+    assert_eq!(BAR, expected);\n \n-    match &[97u8, 10u8] {\n+    let val: &[_] = &[97u8, 10u8];\n+    match val {\n         b\"a\\n\" => {},\n         _ => fail!(),\n     }\n@@ -55,9 +58,12 @@ pub fn main() {\n          _ => 3u\n     }, 2);\n \n-    assert_eq!(BAZ, &[97u8, 92u8, 110u8]);\n-    assert_eq!(br\"a\\n\", &[97u8, 92u8, 110u8]);\n+    let expected: &[_] = &[97u8, 92u8, 110u8];\n+    assert_eq!(BAZ, expected);\n+    let expected: &[_] = &[97u8, 92u8, 110u8];\n+    assert_eq!(br\"a\\n\", expected);\n     assert_eq!(br\"a\\n\", b\"a\\\\n\");\n-    assert_eq!(br###\"a\"##b\"###, &[97u8, 34u8, 35u8, 35u8, 98u8]);\n+    let expected: &[_] = &[97u8, 34u8, 35u8, 35u8, 98u8];\n+    assert_eq!(br###\"a\"##b\"###, expected);\n     assert_eq!(br###\"a\"##b\"###, b\"a\\\"##b\");\n }"}, {"sha": "17957dbcc1389504de451c9b01dc526b22c21c11", "filename": "src/test/run-pass/check-static-slice.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the various ways of getting to a reference to a vec (both sized\n+// and unsized) work properly.\n+\n+static aa: [int, ..3] = [1, 2, 3];\n+static ab: &'static [int, ..3] = &aa;\n+static ac: &'static [int] = ab;\n+static ad: &'static [int] = &aa;\n+static ae: &'static [int, ..3] = &[1, 2, 3];\n+static af: &'static [int] = &[1, 2, 3];\n+\n+static ca: int = aa[0];\n+static cb: int = ab[1];\n+static cc: int = ac[2];\n+static cd: int = ad[0];\n+static ce: int = ae[1];\n+static cf: int = af[2];\n+\n+fn main () {\n+    let b: &[int] = &[1, 2, 3];\n+    assert!(ac == b);\n+    assert!(ad == b);\n+    assert!(af == b);\n+\n+    assert!(ca == 1);\n+    assert!(cb == 2);\n+    assert!(cc == 3);\n+    assert!(cd == 1);\n+    assert!(ce == 2);\n+    assert!(cf == 3);\n+}"}, {"sha": "5be21696bd1edcd730d7955c07a60e78b3f389bd", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -12,6 +12,9 @@ enum E { V1(int), V0 }\n static C: &'static [E] = &[V0, V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];\n+static D: &'static [E, ..2] = &[V0, V1(0xDEADBEE)];\n+static D0: E = C[0];\n+static D1: E = C[1];\n \n pub fn main() {\n     match C0 {\n@@ -22,4 +25,13 @@ pub fn main() {\n         V1(n) => assert!(n == 0xDEADBEE),\n         _ => fail!()\n     }\n+\n+    match D0 {\n+        V0 => (),\n+        _ => fail!()\n+    }\n+    match D1 {\n+        V1(n) => assert!(n == 0xDEADBEE),\n+        _ => fail!()\n+    }\n }"}, {"sha": "6e2ae117ce7ae97d44728a4c6aa60a9cf0c49213", "filename": "src/test/run-pass/dst-dtor-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-dtor-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-dtor-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-dtor-1.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROP_RAN: bool = false;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN = true; }\n+    }\n+}\n+\n+trait Trait {}\n+impl Trait for Foo {}\n+\n+struct Fat<Sized? T> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<Fat<Trait>> = box Fat { f: Foo };\n+    }\n+    unsafe {\n+        assert!(DROP_RAN);\n+    }\n+}"}, {"sha": "deaf49228bc842810c92f671134d5dcb7843f530", "filename": "src/test/run-pass/dst-dtor-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-dtor-2.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROP_RAN: int = 0;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN += 1; }\n+    }\n+}\n+\n+struct Fat<Sized? T> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<Fat<[Foo]>> = box Fat { f: [Foo, Foo, Foo] };\n+    }\n+    unsafe {\n+        assert!(DROP_RAN == 3);\n+    }\n+}"}, {"sha": "2028ebf64c217afd68e71edeaa0a015d23183188", "filename": "src/test/run-pass/dst-struct-reflect.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME(15049) Re-enable this test.\n+// ignore-test\n+// Test that structs with unsized fields work with {:?} reflection.\n+\n+extern crate debug;\n+\n+struct Fat<Sized? T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn reflect(x: &Fat<[int]>, cmp: &str) {\n+    // Don't test this result because reflecting unsized fields is undefined for now.\n+    let _s = format!(\"{:?}\", x);\n+    let s = format!(\"{:?}\", &x.ptr);\n+    assert!(s == cmp.to_string())\n+\n+    println!(\"{:?}\", x);\n+    println!(\"{:?}\", &x.ptr);\n+}\n+\n+fn reflect_0(x: &Fat<[int]>) {\n+    let _s = format!(\"{:?}\", x.ptr[0]);\n+    println!(\"{:?}\", x.ptr[0]);\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    reflect(&f1, \"&[1, 2, 3]\");\n+    reflect_0(&f1);\n+    let f2 = &f1;\n+    reflect(f2, \"&[1, 2, 3]\");\n+    reflect_0(f2);\n+    let f3: &Fat<[int]> = f2;\n+    reflect(f3, \"&[1, 2, 3]\");\n+    reflect_0(f3);\n+    let f4: &Fat<[int]> = &f1;\n+    reflect(f4, \"&[1, 2, 3]\");\n+    reflect_0(f4);\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    reflect(f5, \"&[1, 2, 3]\");\n+    reflect_0(f5);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    reflect(f5, \"&[]\");\n+}\n+"}, {"sha": "04fe6d5cefdc39b8d55382fcaca928bc43e2f4b8", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-struct.rs, but the unsized field is the only field in the struct.\n+\n+struct Fat<Sized? T> {\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[int]>) {\n+    let y = &x.ptr;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0] == 1);\n+    assert!(x.ptr[1] == 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0].to_bar() == bar);\n+    assert!(x.ptr[1].to_bar() == bar);\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[int]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[int]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[int]> = &mut Fat { ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert!(f5.ptr[0] == 1);\n+    assert!(f5.ptr[1] == 34);\n+    assert!(f5.ptr[2] == 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[int]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+}"}, {"sha": "6b8e25e85590f6aaa2d57bbcf84e306885f9465e", "filename": "src/test/run-pass/dst-struct.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Fat<Sized? T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[int]>) {\n+    let y = &x.ptr;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0] == 1);\n+    assert!(x.ptr[1] == 2);\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0].to_bar() == bar);\n+    assert!(x.ptr[1].to_bar() == bar);\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[int]>>) {\n+    let y = &x.ptr.ptr;\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+    assert!(x.ptr.f1 == 8);\n+    assert!(x.ptr.f2 == \"deep str\");\n+    assert!(x.ptr.ptr.len() == 3);\n+    assert!(y[0] == 1);\n+    assert!(x.ptr.ptr[1] == 2);\n+}\n+\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[int]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[int]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[int]> = &mut Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert!(f5.ptr[0] == 1);\n+    assert!(f5.ptr[1] == 34);\n+    assert!(f5.ptr[2] == 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+\n+    // Deeply nested.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[int]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[int]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[int]>> =\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = box [1i, 2, 3];\n+    assert!((*f1)[1] == 2);\n+    let f2: Box<[int]> = f1;\n+    assert!((*f2)[1] == 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[int, ..3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&*f1);\n+    let f2 : Box<Fat<[int]>> = f1;\n+    foo(&*f2);\n+    let f3 : Box<Fat<[int]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&*f3);\n+}"}, {"sha": "976273095510402e0fa93ba56c80041990b11a7f", "filename": "src/test/run-pass/dst-trait.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Fat<Sized? T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar1 {\n+    f: int\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> int;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+    fn to_val(&self) -> int {\n+        0\n+    }\n+}\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<ToBar>) {\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+    assert!(x.ptr.to_bar() == Bar);\n+    assert!(x.ptr.to_val() == 42);\n+\n+    let y = &x.ptr;\n+    assert!(y.to_bar() == Bar);\n+    assert!(y.to_val() == 42);\n+}\n+\n+fn bar(x: &ToBar) {\n+    assert!(x.to_bar() == Bar);\n+    assert!(x.to_val() == 42);\n+}\n+\n+fn baz(x: &Fat<Fat<ToBar>>) {\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+    assert!(x.ptr.f1 == 8);\n+    assert!(x.ptr.f2 == \"deep str\");\n+    assert!(x.ptr.ptr.to_bar() == Bar);\n+    assert!(x.ptr.ptr.to_val() == 42);\n+\n+    let y = &x.ptr.ptr;\n+    assert!(y.to_bar() == Bar);\n+    assert!(y.to_val() == 42);\n+\n+}\n+\n+pub fn main() {\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<ToBar> = f2;\n+    foo(f3);\n+    let f4: &Fat<ToBar> = &f1;\n+    foo(f4);\n+    let f5: &Fat<ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    foo(f5);\n+\n+    // Zero size object.\n+    let f6: &Fat<ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar };\n+    assert!(f6.ptr.to_bar() == Bar);\n+\n+    // &*\n+    let f7: Box<ToBar> = box Bar1 {f :42};\n+    bar(&*f7);\n+\n+    // Deep nesting\n+    let f1 =\n+        Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: Bar1 {f :42}} };\n+    baz(&f1);\n+    let f2 = &f1;\n+    baz(f2);\n+    let f3: &Fat<Fat<ToBar>> = f2;\n+    baz(f3);\n+    let f4: &Fat<Fat<ToBar>> = &f1;\n+    baz(f4);\n+    let f5: &Fat<Fat<ToBar>> =\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: Bar1 {f :42}} };\n+    baz(f5);\n+}"}, {"sha": "4a112f145c3ed9ec91276c71d50a3a680fe0496f", "filename": "src/test/run-pass/evec-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fevec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fevec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-slice.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -14,7 +14,7 @@ extern crate debug;\n \n pub fn main() {\n     let x : &[int] = &[1,2,3,4,5];\n-    let mut z = &[1,2,3,4,5];\n+    let mut z : &[int] = &[1,2,3,4,5];\n     z = x;\n     assert_eq!(z[0], 1);\n     assert_eq!(z[4], 5);"}, {"sha": "430ee16bc8a26682078697fd3d7fc92d517851a6", "filename": "src/test/run-pass/gc-vec.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fgc-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fgc-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgc-vec.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::gc::{GC};\n+\n+fn main() {\n+    // A fixed-size array allocated in a garbage-collected box\n+    let x = box(GC) [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(x[0], 1);\n+    assert_eq!(x[6], 7);\n+    assert_eq!(x[9], 10);\n+\n+    let y = x;\n+    assert!(*y == [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}"}, {"sha": "0aca74c76c3e78aace1b8cb9943886d06177aaeb", "filename": "src/test/run-pass/issue-14936.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -30,7 +30,8 @@ macro_rules! demo {\n                      : \"r\"(&wrap(y, \"in\", &mut history)));\n             }\n             assert_eq!((x,y), (1,1));\n-            assert_eq!(history.as_slice(), &[\"out\", \"in\"]);\n+            let b: &[_] = &[\"out\", \"in\"];\n+            assert_eq!(history.as_slice(), b);\n         }\n     }\n }"}, {"sha": "444e8bd37707e7273ed3f8221f75f723d2b41e3b", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut x = &[1i, 2, 3, 4];\n+    let mut x: &[_] = &[1i, 2, 3, 4];\n \n     let mut result = vec!();\n     loop {"}, {"sha": "96db28f4a101fbaab6d30fe890a47e48d310e992", "filename": "src/test/run-pass/issue-7012.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-7012.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-7012.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7012.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -22,6 +22,7 @@ static test1: signature<'static> =  signature {\n };\n \n pub fn main() {\n-  let test = &[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,0x03707344u32,0xa4093822u32,0x299f31d0u32];\n+  let test: &[u32] = &[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,\n+                       0x03707344u32,0xa4093822u32,0x299f31d0u32];\n   println!(\"{}\",test==test1.pattern);\n }"}, {"sha": "2818b8249692a1fd499bba4f75fe0e9d0694b627", "filename": "src/test/run-pass/issue-9259.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9259.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -14,7 +14,7 @@ struct A<'a> {\n }\n \n pub fn main() {\n-    let b = &[\"foo\".to_string()];\n+    let b: &[String] = &[\"foo\".to_string()];\n     let a = A {\n         a: &[\"test\".to_string()],\n         b: Some(b),"}, {"sha": "de1bb02bfefc675964c5a482975ddcc741538572", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -68,15 +68,21 @@ fn main() {\n     assert_eq!(match_vecs_snoc::<uint>(&[], &[]), \"both empty\");\n     assert_eq!(match_vecs_snoc(&[1i, 2, 3], &[]), \"one empty\");\n \n-    assert_eq!(match_nested_vecs_cons(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_cons(None, Ok::<&[_], ()>(&[4u, 2u])),\n+               \"None, Ok(at least two elements)\");\n     assert_eq!(match_nested_vecs_cons::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n-    assert_eq!(match_nested_vecs_cons::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n-    assert_eq!(match_nested_vecs_cons(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n-    assert_eq!(match_nested_vecs_cons(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_cons::<bool>(Some::<&[_]>(&[]), Ok::<&[_], ()>(&[])),\n+               \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_cons(Some::<&[_]>(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_cons(Some::<&[_]>(&[(42i, ())]), Ok::<&[_], ()>(&[(1i, ())])),\n+               \"Some(non-empty), any\");\n \n-    assert_eq!(match_nested_vecs_snoc(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_snoc(None, Ok::<&[_], ()>(&[4u, 2u])),\n+               \"None, Ok(at least two elements)\");\n     assert_eq!(match_nested_vecs_snoc::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n-    assert_eq!(match_nested_vecs_snoc::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n-    assert_eq!(match_nested_vecs_snoc(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n-    assert_eq!(match_nested_vecs_snoc(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_snoc::<bool>(Some::<&[_]>(&[]), Ok::<&[_], ()>(&[])),\n+               \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_snoc(Some::<&[_]>(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_snoc(Some::<&[_]>(&[(42i, ())]), Ok::<&[_], ()>(&[(1i, ())])),\n+               \"Some(non-empty), any\");\n }"}, {"sha": "9a76beac9e5f75c49c160750bae829f82cc5e70a", "filename": "src/test/run-pass/order-drop-with-match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -59,6 +59,7 @@ fn main() {\n         }\n     }\n     unsafe {\n-        assert_eq!(&[1, 2, 3], ORDER.as_slice());\n+        let expected: &[_] = &[1, 2, 3];\n+        assert_eq!(expected, ORDER.as_slice());\n     }\n }"}, {"sha": "2d54663993925e1e1fc2c74d0b23e8ef49dfea09", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -81,5 +81,6 @@ pub fn main() {\n \n     // Check the final states.\n     assert_eq!(*n, 2);\n-    assert_eq!((*v).as_slice(), &[1, 2]);\n+    let expected: &[_] = &[1, 2];\n+    assert_eq!((*v).as_slice(), expected);\n }"}, {"sha": "f599a2b7ad55c9f04923cd15840917c7a7261fd5", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -61,6 +61,8 @@ impl TyVisitor for MyVisitor {\n     fn visit_char(&mut self) -> bool { true }\n \n     fn visit_estr_slice(&mut self) -> bool { true }\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self,\n                         _sz: uint, _sz2: uint,\n                         _align: uint) -> bool { true }\n@@ -72,7 +74,7 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n     fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n-                        _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n+                        _inner: *const TyDesc) -> bool { true }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }"}, {"sha": "3f559df4b7e7a7098b9624705c565487fd75027c", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -43,14 +43,22 @@ fn main() {\n     let args = os::args();\n     let me = args.get(0).as_slice();\n \n-    pass(Command::new(me).arg(&[1u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[2u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[3u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[4u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[5u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[6u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[7u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[8u8]).output().unwrap());\n+    let x: &[u8] = &[1u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[2u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[3u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[4u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[5u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[6u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[7u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[8u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n }\n \n fn pass(output: ProcessOutput) {"}, {"sha": "52e7118653766d4b6130fecbc3ff189844dc7146", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -22,6 +22,7 @@ extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"sized\"] pub trait Sized {}\n \n #[start]\n #[no_split_stack]"}, {"sha": "8d5333e5b3fc5aa4d79af138a7412940f19ee115", "filename": "src/test/run-pass/syntax-extension-bytes.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -12,13 +12,17 @@ static static_vec: &'static [u8] = bytes!(\"abc\", 0xFF, '!');\n \n pub fn main() {\n     let vec = bytes!(\"abc\");\n-    assert_eq!(vec, &[97_u8, 98_u8, 99_u8]);\n+    let expected: &[u8] = &[97_u8, 98_u8, 99_u8];\n+    assert_eq!(vec, expected);\n \n     let vec = bytes!(\"null\", 0);\n-    assert_eq!(vec, &[110_u8, 117_u8, 108_u8, 108_u8, 0_u8]);\n+    let expected: &[u8] = &[110_u8, 117_u8, 108_u8, 108_u8, 0_u8];\n+    assert_eq!(vec, expected);\n \n     let vec = bytes!(' ', \" \", 32, 32u8);\n-    assert_eq!(vec, &[32_u8, 32_u8, 32_u8, 32_u8]);\n+    let expected: &[u8] = &[32_u8, 32_u8, 32_u8, 32_u8];\n+    assert_eq!(vec, expected);\n \n-    assert_eq!(static_vec, &[97_u8, 98_u8, 99_u8, 255_u8, 33_u8]);\n+    let expected: &[u8] = &[97_u8, 98_u8, 99_u8, 255_u8, 33_u8];\n+    assert_eq!(static_vec, expected);\n }"}, {"sha": "10c91274f10f81387d45299c82f5f45a41967a8a", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -15,10 +15,11 @@ static CONSTEXPR: *const int = &413 as *const _;\n \n pub fn main() {\n     let x: Vec<_> = range(0u, 5).collect();\n-    assert_eq!(x.as_slice(), &[0u,1,2,3,4]);\n+    let expected: &[uint] = &[0,1,2,3,4];\n+    assert_eq!(x.as_slice(), expected);\n \n     let x = range(0u, 5).collect::<Vec<_>>();\n-    assert_eq!(x.as_slice(), &[0u,1,2,3,4]);\n+    assert_eq!(x.as_slice(), expected);\n \n     let y: _ = \"hello\";\n     assert_eq!(y.len(), 5);"}, {"sha": "809dde38eb498fd51b10251e6bdb78cc63a42395", "filename": "src/test/run-pass/vec-dst.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate debug;\n+\n+fn reflect() {\n+    // Tests for reflective printing.\n+    // Also tests drop glue.\n+    let x = [1, 2, 3, 4];\n+    let x2 = [(), (), ()];\n+    let e1: [uint, ..0] = [];\n+    let e2: [&'static str, ..0] = [];\n+    let e3: [(), ..0] = [];\n+    assert!(format!(\"{:?}\", x) == \"[1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", x2) == \"[(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", e1) == \"[]\".to_string());\n+    assert!(format!(\"{:?}\", e2) == \"[]\".to_string());\n+    assert!(format!(\"{:?}\", e3) == \"[]\".to_string());\n+\n+    let rx: &[uint, ..4] = &x;\n+    let rx2: &[(), ..3] = &x2;\n+    let re1: &[uint, ..0] = &e1;\n+    let re2: &[&'static str, ..0] = &e2;\n+    let re3: &[(), ..0] = &e3;\n+    assert!(format!(\"{:?}\", rx) == \"&[1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"&[(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"&[]\".to_string());\n+\n+    let rx: &[uint] = &x;\n+    let rx2: &[()] = &x2;\n+    let re1: &[uint] = &e1;\n+    let re2: &[&'static str] = &e2;\n+    let re3: &[()] = &e3;\n+    assert!(format!(\"{:?}\", rx) == \"&[1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"&[(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"&[]\".to_string());\n+\n+    // FIXME(15049) These should all work some day.\n+    /*let rx: Box<[uint, ..4]> = box x;\n+    let rx2: Box<[(), ..3]> = box x2;\n+    let re1: Box<[uint, ..0]> = box e1;\n+    let re2: Box<[&'static str, ..0]> = box e2;\n+    let re3: Box<[(), ..0]> = box e3;\n+    assert!(format!(\"{:?}\", rx) == \"box [1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"box [(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"box []\".to_string());\n+\n+    let x = [1, 2, 3, 4];\n+    let x2 = [(), (), ()];\n+    let e1: [uint, ..0] = [];\n+    let e2: [&'static str, ..0] = [];\n+    let e3: [(), ..0] = [];\n+    let rx: Box<[uint]> = box x;\n+    let rx2: Box<[()]> = box x2;\n+    let re1: Box<[uint]> = box e1;\n+    let re2: Box<[&'static str]> = box e2;\n+    let re3: Box<[()]> = box e3;\n+    assert!(format!(\"{:?}\", rx) == \"box [1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"box [(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"box []\".to_string());*/\n+}\n+\n+fn sub_expr() {\n+    // Test for a &[T] => &&[T] coercion in sub-expression position\n+    // (surpisingly, this can cause errors which are not caused by either of:\n+    //    `let x = vec.mut_slice(0, 2);`\n+    //    `foo(vec.mut_slice(0, 2));` ).\n+    let mut vec: Vec<int> = vec!(1, 2, 3, 4);\n+    let b: &mut [int] = [1, 2];\n+    assert!(vec.mut_slice(0, 2) == b);\n+}\n+\n+fn index() {\n+    // Tests for indexing into box/& [T, ..n]\n+    let x: [int, ..3] = [1, 2, 3];\n+    let mut x: Box<[int, ..3]> = box x;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 2);\n+    assert!(x[2] == 3);\n+    x[1] = 45;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 45);\n+    assert!(x[2] == 3);\n+\n+    let mut x: [int, ..3] = [1, 2, 3];\n+    let x: &mut [int, ..3] = &mut x;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 2);\n+    assert!(x[2] == 3);\n+    x[1] = 45;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 45);\n+    assert!(x[2] == 3);\n+}\n+\n+pub fn main() {\n+    reflect();\n+    sub_expr();\n+    index();\n+}"}, {"sha": "2fd8a4ab256fd8fb1dee7ed20966c5fc2b280b4f", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -10,6 +10,7 @@\n \n pub fn main() {\n     let x = &[1i, 2, 3, 4, 5];\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n             [1, ..ref tail] => &tail[0],"}, {"sha": "e95495a42d2823bac8292c3e521469c61ee52abb", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -23,20 +23,23 @@ fn b() {\n         [a, b, ..c] => {\n             assert_eq!(a, 1);\n             assert_eq!(b, 2);\n-            assert_eq!(c, &[3]);\n+            let expected: &[_] = &[3];\n+            assert_eq!(c, expected);\n         }\n     }\n     match x {\n         [..a, b, c] => {\n-            assert_eq!(a, &[1]);\n+            let expected: &[_] = &[1];\n+            assert_eq!(a, expected);\n             assert_eq!(b, 2);\n             assert_eq!(c, 3);\n         }\n     }\n     match x {\n         [a, ..b, c] => {\n             assert_eq!(a, 1);\n-            assert_eq!(b, &[2]);\n+            let expected: &[_] = &[2];\n+            assert_eq!(b, expected);\n             assert_eq!(c, 3);\n         }\n     }\n@@ -69,7 +72,8 @@ fn d() {\n }\n \n fn e() {\n-    match &[1i, 2, 3] {\n+    let x: &[int] = &[1i, 2, 3];\n+    match x {\n         [1, 2] => (),\n         [..] => ()\n     }"}, {"sha": "52e0ba89479f555340f95043ad9b916573f84a67", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932b719ec2b65acfa8c3e74aad29346d47ee992/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=7932b719ec2b65acfa8c3e74aad29346d47ee992", "patch": "@@ -10,10 +10,9 @@\n \n pub fn main() {\n     assert_eq!((vec!(0i, 1)).to_string(), \"[0, 1]\".to_string());\n-    assert_eq!((&[1i, 2]).to_string(), \"[1, 2]\".to_string());\n \n     let foo = vec!(3i, 4);\n-    let bar = &[4i, 5];\n+    let bar: &[int] = &[4, 5];\n \n     assert_eq!(foo.to_string(), \"[3, 4]\".to_string());\n     assert_eq!(bar.to_string(), \"[4, 5]\".to_string());"}]}