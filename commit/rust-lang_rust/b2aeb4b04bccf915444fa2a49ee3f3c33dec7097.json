{"sha": "b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYWViNGIwNGJjY2Y5MTU0NDRmYTJhNDllZTNmM2MzM2RlYzcwOTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-16T10:17:55Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:58:28Z"}, "message": "debuginfo: Cleaned up style issues for pull request.", "tree": {"sha": "9cdea2fb0e594e8d8e3f9a8f6deaf93f019e316f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cdea2fb0e594e8d8e3f9a8f6deaf93f019e316f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "html_url": "https://github.com/rust-lang/rust/commit/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eed2d0e1f2f4c6743b33efa06d5028fcc33db3b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/eed2d0e1f2f4c6743b33efa06d5028fcc33db3b1", "html_url": "https://github.com/rust-lang/rust/commit/eed2d0e1f2f4c6743b33efa06d5028fcc33db3b1"}], "stats": {"total": 1090, "additions": 589, "deletions": 501}, "files": [{"sha": "7acd9545efdd016f734a8584ed13b6b2822f2473", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -2127,7 +2127,7 @@ pub mod llvm {\n             AlignInBits: c_ulonglong,\n             Flags: c_uint ,\n             Elements: ValueRef,\n-            RunTimeLang : c_uint) -> ValueRef;\n+            RunTimeLang: c_uint) -> ValueRef;\n     }\n }\n "}, {"sha": "eea65a4c48addc6c184cd49e2d0f90402bcaf06f", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 449, "deletions": 395, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -65,8 +65,8 @@ use syntax::{ast, codemap, ast_util, ast_map};\n \n static DW_LANG_RUST: int = 0x9000;\n \n-static AutoVariableTag: int = 256;\n-static ArgVariableTag: int = 257;\n+static DW_TAG_auto_variable: int = 0x100;\n+static DW_TAG_arg_variable: int = 0x101;\n \n static DW_ATE_boolean: int = 0x02;\n static DW_ATE_float: int = 0x04;\n@@ -116,7 +116,7 @@ impl DebugContext {\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n-    create_compile_unit_metadata(cx);\n+    compile_unit_metadata(cx);\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n         llvm::LLVMDIBuilderDispose(DIB(cx));\n@@ -144,27 +144,29 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n \n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n-    let type_metadata = get_or_create_type_metadata(cx, ty, local.node.ty.span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let type_metadata = type_metadata(cx, ty, local.node.ty.span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n     let context = match bcx.parent {\n         None => create_function_metadata(bcx.fcx),\n-        Some(_) => get_or_create_block_metadata(bcx)\n+        Some(_) => block_metadata(bcx)\n     };\n \n-    let var_metadata = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateLocalVariable(\n-            DIB(cx),\n-            AutoVariableTag as u32,\n-            context,\n-            name,\n-            file_metadata,\n-            loc.line as c_uint,\n-            type_metadata,\n-            false,\n-            0,\n-            0)\n-        }};\n+    let var_metadata = do as_c_str(name) |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateLocalVariable(\n+                DIB(cx),\n+                DW_TAG_auto_variable as u32,\n+                context,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                type_metadata,\n+                false,\n+                0,\n+                0)\n+        }\n+    };\n \n     // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n     let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n@@ -176,7 +178,7 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n         }\n     };\n \n-    set_debug_location(cx, get_or_create_block_metadata(bcx), loc.line, loc.col.to_uint());\n+    set_debug_location(cx, block_metadata(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n@@ -207,32 +209,34 @@ pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Optio\n     }\n \n     let ty = node_id_type(bcx, arg.id);\n-    let type_metadata = get_or_create_type_metadata(cx, ty, arg.ty.span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let type_metadata = type_metadata(cx, ty, arg.ty.span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n     let context = create_function_metadata(fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, ref path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n-            let var_metadata = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n-                    DIB(cx),\n-                    ArgVariableTag as u32,\n-                    context,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    false,\n-                    0,\n-                    0)\n+            let var_metadata = do as_c_str(name) |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateLocalVariable(\n+                        DIB(cx),\n+                        DW_TAG_arg_variable as u32,\n+                        context,\n+                        name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        false,\n+                        0,\n+                        0)\n                     // XXX need to pass in a real argument number\n-            }};\n+                }\n+            };\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, get_or_create_block_metadata(bcx), loc.line, loc.col.to_uint());\n+            set_debug_location(cx, block_metadata(bcx), loc.line, loc.col.to_uint());\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                         DIB(cx), llptr, var_metadata, bcx.llbb);\n@@ -255,7 +259,7 @@ pub fn update_source_pos(bcx: block, span: span) {\n     }\n     debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n     let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), get_or_create_block_metadata(bcx), loc.line, loc.col.to_uint())\n+    set_debug_location(bcx.ccx(), block_metadata(bcx), loc.line, loc.col.to_uint())\n }\n \n /// Creates debug information for the given function.\n@@ -305,12 +309,12 @@ pub fn create_function_metadata(fcx: fn_ctxt) -> DISubprogram {\n            cx.sess.codemap.span_to_str(span));\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n     let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => ptr::null(),\n-          _ => get_or_create_type_metadata(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n         }\n     } else {\n         ptr::null()\n@@ -325,24 +329,26 @@ pub fn create_function_metadata(fcx: fn_ctxt) -> DISubprogram {\n \n     let fn_metadata =\n         do as_c_str(cx.sess.str_of(ident)) |name| {\n-        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n-            llvm::LLVMDIBuilderCreateFunction(\n-                DIB(cx),\n-                file_metadata,\n-                name,\n-                linkage,\n-                file_metadata,\n-                loc.line as c_uint,\n-                fn_ty,\n-                false,\n-                true,\n-                loc.line as c_uint,\n-                FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No,\n-                fcx.llfn,\n-                ptr::null(),\n-                ptr::null())\n-            }}};\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateFunction(\n+                    DIB(cx),\n+                    file_metadata,\n+                    name,\n+                    linkage,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    fn_ty,\n+                    false,\n+                    true,\n+                    loc.line as c_uint,\n+                    FlagPrototyped as c_uint,\n+                    cx.sess.opts.optimize != session::No,\n+                    fcx.llfn,\n+                    ptr::null(),\n+                    ptr::null())\n+            }\n+        }};\n \n     dbg_cx(cx).created_functions.insert(id, fn_metadata);\n     return fn_metadata;\n@@ -361,11 +367,11 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn create_compile_unit_metadata(cx: @mut CrateContext) {\n+fn compile_unit_metadata(cx: @mut CrateContext) {\n     let dcx = dbg_cx(cx);\n     let crate_name: &str = dcx.crate_file;\n \n-    debug!(\"create_compile_unit_metadata: %?\", crate_name);\n+    debug!(\"compile_unit_metadata: %?\", crate_name);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n@@ -374,21 +380,23 @@ fn create_compile_unit_metadata(cx: @mut CrateContext) {\n     do as_c_str(work_dir) |work_dir| {\n     do as_c_str(producer) |producer| {\n     do as_c_str(\"\") |flags| {\n-    do as_c_str(\"\") |split_name| { unsafe {\n-        llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n-            DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n-            cx.sess.opts.optimize != session::No,\n-            flags, 0, split_name);\n-    }}}}}};\n+    do as_c_str(\"\") |split_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n+                DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+                cx.sess.opts.optimize != session::No,\n+                flags, 0, split_name);\n+        }\n+    }}}}};\n }\n \n-fn get_or_create_file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n+fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     match dbg_cx(cx).created_files.find_equiv(&full_path) {\n         Some(file_metadata) => return *file_metadata,\n         None => ()\n     }\n \n-    debug!(\"get_or_create_file_metadata: %s\", full_path);\n+    debug!(\"file_metadata: %s\", full_path);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let file_name =\n@@ -400,15 +408,17 @@ fn get_or_create_file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile\n \n     let file_metadata =\n         do as_c_str(file_name) |file_name| {\n-        do as_c_str(work_dir) |work_dir| { unsafe {\n-            llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n-        }}};\n+        do as_c_str(work_dir) |work_dir| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n+            }\n+        }};\n \n     dbg_cx(cx).created_files.insert(full_path.to_owned(), file_metadata);\n     return file_metadata;\n }\n \n-fn get_or_create_block_metadata(bcx: block) -> DILexicalBlock {\n+fn block_metadata(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n     let cx = bcx.ccx();\n \n@@ -426,15 +436,15 @@ fn get_or_create_block_metadata(bcx: block) -> DILexicalBlock {\n         None => ()\n     }\n \n-    debug!(\"get_or_create_block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n+    debug!(\"block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n \n     let parent = match bcx.parent {\n         None => create_function_metadata(bcx.fcx),\n-        Some(b) => get_or_create_block_metadata(b)\n+        Some(b) => block_metadata(b)\n     };\n     let cx = bcx.ccx();\n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n     let block_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n@@ -448,9 +458,9 @@ fn get_or_create_block_metadata(bcx: block) -> DILexicalBlock {\n     return block_metadata;\n }\n \n-fn create_basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n+fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n-    debug!(\"create_basic_type_metadata: %?\", ty::get(t));\n+    debug!(\"basic_type_metadata: %?\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -475,58 +485,62 @@ fn create_basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::create_basic_type_metadata - t is invalid type\")\n+        _ => cx.sess.bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = do as_c_str(name) |name| { unsafe {\n+    let ty_metadata = do as_c_str(name) |name| {\n+        unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n                 name,\n                 bytes_to_bits(size),\n                 bytes_to_bits(align),\n                 encoding as c_uint)\n-        }};\n+        }\n+    };\n \n     return ty_metadata;\n }\n \n-fn create_pointer_type_metadata(cx: &mut CrateContext,\n-                                pointer_type: ty::t,\n-                                pointee_type_metadata: DIType)\n-                             -> DIType {\n+fn pointer_type_metadata(cx: &mut CrateContext,\n+                         pointer_type: ty::t,\n+                         pointee_type_metadata: DIType)\n+                      -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ty_to_str(cx.tcx, pointer_type);\n-    let ptr_metadata = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(\n-            DIB(cx),\n-            pointee_type_metadata,\n-            bytes_to_bits(pointer_size),\n-            bytes_to_bits(pointer_align),\n-            name)\n-        }};\n+    let ptr_metadata = do as_c_str(name) |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreatePointerType(\n+                DIB(cx),\n+                pointee_type_metadata,\n+                bytes_to_bits(pointer_size),\n+                bytes_to_bits(pointer_align),\n+                name)\n+        }\n+    };\n     return ptr_metadata;\n }\n \n-fn create_struct_metadata(cx: &mut CrateContext,\n-                          struct_type: ty::t,\n-                          fields: ~[ty::field],\n-                          span: span)\n-                       -> DICompositeType {\n+fn struct_metadata(cx: &mut CrateContext,\n+                   struct_type: ty::t,\n+                   fields: ~[ty::field],\n+                   span: span)\n+                -> DICompositeType {\n     let struct_name = ty_to_str(cx.tcx, struct_type);\n-    debug!(\"create_struct_metadata: %s\", struct_name);\n+    debug!(\"struct_metadata: %s\", struct_name);\n \n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n     let field_names = do fields.map |field| { cx.sess.str_of(field.ident).to_owned() };\n     let field_types_metadata = do fields.map |field| {\n-        get_or_create_type_metadata(cx, field.mt.ty, span)\n+        type_metadata(cx, field.mt.ty, span)\n     };\n \n-    return create_composite_type_metadata(\n+    return composite_type_metadata(\n         cx,\n         struct_llvm_type,\n         struct_name,\n@@ -536,22 +550,22 @@ fn create_struct_metadata(cx: &mut CrateContext,\n         span);\n }\n \n-fn create_tuple_metadata(cx: &mut CrateContext,\n-                         tuple_type: ty::t,\n-                         component_types: &[ty::t],\n-                         span: span)\n-                      -> DICompositeType {\n+fn tuple_metadata(cx: &mut CrateContext,\n+                  tuple_type: ty::t,\n+                  component_types: &[ty::t],\n+                  span: span)\n+               -> DICompositeType {\n \n     let tuple_name = ty_to_str(cx.tcx, tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     let component_names = do component_types.map |_| { ~\"\" };\n     let component_llvm_types = do component_types.map |it| { type_of::type_of(cx, *it) };\n     let component_types_metadata = do component_types.map |it| {\n-        get_or_create_type_metadata(cx, *it, span)\n+        type_metadata(cx, *it, span)\n     };\n \n-    return create_composite_type_metadata(\n+    return composite_type_metadata(\n         cx,\n         tuple_llvm_type,\n         tuple_name,\n@@ -564,19 +578,19 @@ fn create_tuple_metadata(cx: &mut CrateContext,\n // The stage0 snapshot does not yet support the fixes from PR #7557, so there are two versions of\n // following function for now\n #[cfg(not(stage0))]\n-fn create_enum_metadata(cx: &mut CrateContext,\n-                        enum_type: ty::t,\n-                        enum_def_id: ast::def_id,\n-                        substs: &ty::substs,\n-                        span: span)\n-                     -> DIType {\n+fn enum_metadata(cx: &mut CrateContext,\n+                 enum_type: ty::t,\n+                 enum_def_id: ast::def_id,\n+                 substs: &ty::substs,\n+                 span: span)\n+              -> DIType {\n \n     let enum_name = ty_to_str(cx.tcx, enum_type);\n \n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        return create_composite_type_metadata(cx, Type::nil(), enum_name, &[], &[], &[], span);\n+        return composite_type_metadata(cx, Type::nil(), enum_name, [], [], [], span);\n     }\n \n     // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n@@ -585,112 +599,120 @@ fn create_enum_metadata(cx: &mut CrateContext,\n     let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n \n     assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_type_metadata = get_or_create_type_metadata(cx, ty::mk_int(), span);\n+    let discriminant_type_metadata = type_metadata(cx, ty::mk_int(), span);\n \n-    let variants : &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n \n-    let enumerators_metadata : ~[DIDescriptor] = variants\n+    let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n         .transform(|v| {\n-            let name : &str = cx.sess.str_of(v.name);\n+            let name: &str = cx.sess.str_of(v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n-            do name.as_c_str |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    name,\n-                    discriminant_value)\n-            }}\n+            do name.as_c_str |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name,\n+                        discriminant_value)\n+                }\n+            }\n         })\n         .collect();\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| { unsafe {\n-        llvm::LLVMDIBuilderCreateEnumerationType(\n-            DIB(cx),\n-            file_metadata,\n-            enum_name,\n-            file_metadata,\n-            loc.line as c_uint,\n-            bytes_to_bits(discriminant_size),\n-            bytes_to_bits(discriminant_align),\n-            create_DIArray(DIB(cx), enumerators_metadata),\n-            discriminant_type_metadata)\n-    }};\n+    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateEnumerationType(\n+                DIB(cx),\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(discriminant_size),\n+                bytes_to_bits(discriminant_align),\n+                create_DIArray(DIB(cx), enumerators_metadata),\n+                discriminant_type_metadata)\n+        }\n+    };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n \n     match *type_rep {\n         adt::CEnum(*) => {\n             return discriminant_type_metadata;\n         }\n-        adt::Univariant(ref struct_def, _destroyed_flag) => {\n+        adt::Univariant(ref struct_def, _) => {\n             assert!(variants.len() == 1);\n-            return create_adt_struct_metadata(cx, struct_def, variants[0], None, span);\n+            return adt_struct_metadata(cx, struct_def, variants[0], None, span);\n         }\n         adt::General(ref struct_defs) => {\n-            let variants_member_metadata : ~[DIDescriptor] = do struct_defs\n+            let variants_member_metadata: ~[DIDescriptor] = do struct_defs\n                 .iter()\n                 .enumerate()\n                 .transform |(i, struct_def)| {\n-                    let variant_type_metadata = create_adt_struct_metadata(\n+                    let variant_type_metadata = adt_struct_metadata(\n                         cx,\n                         struct_def,\n                         variants[i],\n                         Some(discriminant_type_metadata),\n                         span);\n \n-                    do \"\".as_c_str |name| { unsafe {\n-                        llvm::LLVMDIBuilderCreateMemberType(\n-                            DIB(cx),\n-                            file_metadata,\n-                            name,\n-                            file_metadata,\n-                            loc.line as c_uint,\n-                            bytes_to_bits(struct_def.size as uint),\n-                            bytes_to_bits(struct_def.align as uint),\n-                            bytes_to_bits(0),\n-                            0,\n-                            variant_type_metadata)\n-                    }}\n+                    do \"\".as_c_str |name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateMemberType(\n+                                DIB(cx),\n+                                file_metadata,\n+                                name,\n+                                file_metadata,\n+                                loc.line as c_uint,\n+                                bytes_to_bits(struct_def.size as uint),\n+                                bytes_to_bits(struct_def.align as uint),\n+                                bytes_to_bits(0),\n+                                0,\n+                                variant_type_metadata)\n+                        }\n+                    }\n             }.collect();\n \n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            return do enum_name.as_c_str |enum_name| { unsafe { llvm::LLVMDIBuilderCreateUnionType(\n-                DIB(cx),\n-                file_metadata,\n-                enum_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(enum_type_size),\n-                bytes_to_bits(enum_type_align),\n-                0, // Flags\n-                create_DIArray(DIB(cx), variants_member_metadata),\n-                0) // RuntimeLang\n+            return do enum_name.as_c_str |enum_name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateUnionType(\n+                    DIB(cx),\n+                    file_metadata,\n+                    enum_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(enum_type_size),\n+                    bytes_to_bits(enum_type_align),\n+                    0, // Flags\n+                    create_DIArray(DIB(cx), variants_member_metadata),\n+                    0) // RuntimeLang\n             }};\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n-            return create_adt_struct_metadata(cx, struct_def, variants[nndiscr], None, span);\n+            return adt_struct_metadata(cx, struct_def, variants[nndiscr], None, span);\n         }\n     }\n \n-    fn create_adt_struct_metadata(cx: &mut CrateContext,\n+    fn adt_struct_metadata(cx: &mut CrateContext,\n                                   struct_def: &adt::Struct,\n                                   variant_info: &ty::VariantInfo,\n                                   discriminant_type_metadata: Option<DIType>,\n                                   span: span)\n                                -> DICompositeType\n     {\n-        let arg_llvm_types : ~[Type] = do struct_def.fields.map |&ty| { type_of::type_of(cx, ty) };\n-        let arg_metadata : ~[DIType] = do struct_def.fields.iter().enumerate()\n+        let arg_llvm_types: ~[Type] = do struct_def.fields.map |&ty| { type_of::type_of(cx, ty) };\n+        let arg_metadata: ~[DIType] = do struct_def.fields.iter().enumerate()\n             .transform |(i, &ty)| {\n                 match discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n-                    _                        => get_or_create_type_metadata(cx, ty, span)\n+                    _                        => type_metadata(cx, ty, span)\n                 }\n         }.collect();\n \n@@ -699,14 +721,14 @@ fn create_enum_metadata(cx: &mut CrateContext,\n             None => do variant_info.args.map |_| { ~\"\" }\n         };\n \n-        if (discriminant_type_metadata.is_some()) {\n+        if discriminant_type_metadata.is_some() {\n             arg_names.insert(0, ~\"\");\n         }\n \n         let variant_llvm_type = Type::struct_(arg_llvm_types, struct_def.packed);\n-        let variant_name : &str = cx.sess.str_of(variant_info.name);\n+        let variant_name: &str = cx.sess.str_of(variant_info.name);\n \n-        return create_composite_type_metadata(\n+        return composite_type_metadata(\n             cx,\n             variant_llvm_type,\n             variant_name,\n@@ -718,19 +740,19 @@ fn create_enum_metadata(cx: &mut CrateContext,\n }\n \n #[cfg(stage0)]\n-fn create_enum_metadata(cx: &mut CrateContext,\n-                        enum_type: ty::t,\n-                        enum_def_id: ast::def_id,\n-                        substs: &ty::substs,\n-                        span: span)\n-                     -> DIType {\n+fn enum_metadata(cx: &mut CrateContext,\n+                 enum_type: ty::t,\n+                 enum_def_id: ast::def_id,\n+                 substs: &ty::substs,\n+                 span: span)\n+              -> DIType {\n \n     let enum_name = ty_to_str(cx.tcx, enum_type);\n \n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        return create_composite_type_metadata(cx, Type::nil(), enum_name, &[], &[], &[], span);\n+        return composite_type_metadata(cx, Type::nil(), enum_name, &[], &[], &[], span);\n     }\n \n     // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n@@ -739,40 +761,44 @@ fn create_enum_metadata(cx: &mut CrateContext,\n     let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n \n     assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_type_metadata = get_or_create_type_metadata(cx, ty::mk_int(), span);\n+    let discriminant_type_metadata = type_metadata(cx, ty::mk_int(), span);\n \n-    let variants : &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n \n-    let enumerators_metadata : ~[DIDescriptor] = variants\n+    let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n         .transform(|v| {\n-            let name : &str = cx.sess.str_of(v.name);\n+            let name: &str = cx.sess.str_of(v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n-            do name.as_c_str |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    name,\n-                    discriminant_value)\n-            }}\n+            do name.as_c_str |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name,\n+                        discriminant_value)\n+                }\n+            }\n         })\n         .collect();\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| { unsafe {\n-        llvm::LLVMDIBuilderCreateEnumerationType(\n-            DIB(cx),\n-            file_metadata,\n-            enum_name,\n-            file_metadata,\n-            loc.line as c_uint,\n-            bytes_to_bits(discriminant_size),\n-            bytes_to_bits(discriminant_align),\n-            create_DIArray(DIB(cx), enumerators_metadata),\n-            discriminant_type_metadata)\n-    }};\n+    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateEnumerationType(\n+                DIB(cx),\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(discriminant_size),\n+                bytes_to_bits(discriminant_align),\n+                create_DIArray(DIB(cx), enumerators_metadata),\n+                discriminant_type_metadata)\n+        }\n+    };\n \n     if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n         return discriminant_type_metadata;\n@@ -782,7 +808,7 @@ fn create_enum_metadata(cx: &mut CrateContext,\n \n     let variants_metadata = do variants.map |&vi| {\n \n-        let raw_types : &[ty::t] = vi.args;\n+        let raw_types: &[ty::t] = vi.args;\n         let arg_types = do raw_types.map |&raw_type| { ty::subst(cx.tcx, substs, raw_type) };\n \n         let mut arg_llvm_types = do arg_types.map |&ty| { type_of::type_of(cx, ty) };\n@@ -791,7 +817,7 @@ fn create_enum_metadata(cx: &mut CrateContext,\n             None => do arg_types.map |_| { ~\"\" }\n         };\n \n-        let mut arg_metadata = do arg_types.map |&ty| { get_or_create_type_metadata(cx, ty, span) };\n+        let mut arg_metadata = do arg_types.map |&ty| { type_metadata(cx, ty, span) };\n \n         if !is_univariant {\n             arg_llvm_types.insert(0, discriminant_llvm_type);\n@@ -802,7 +828,7 @@ fn create_enum_metadata(cx: &mut CrateContext,\n         let variant_llvm_type = Type::struct_(arg_llvm_types, false);\n         let (variant_type_size, variant_type_align) = size_and_align_of(cx, variant_llvm_type);\n \n-        let variant_type_metadata = create_composite_type_metadata(\n+        let variant_type_metadata = composite_type_metadata(\n             cx,\n             variant_llvm_type,\n             &\"\",\n@@ -811,135 +837,150 @@ fn create_enum_metadata(cx: &mut CrateContext,\n             arg_metadata,\n             span);\n \n-        do \"\".as_c_str |name| { unsafe {\n-            llvm::LLVMDIBuilderCreateMemberType(\n-                DIB(cx),\n-                file_metadata,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(variant_type_size),\n-                bytes_to_bits(variant_type_align),\n-                bytes_to_bits(0),\n-                0,\n-                variant_type_metadata)\n-        }}\n+        do \"\".as_c_str |name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    file_metadata,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(variant_type_size),\n+                    bytes_to_bits(variant_type_align),\n+                    bytes_to_bits(0),\n+                    0,\n+                    variant_type_metadata)\n+            }\n+        }\n     };\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n     let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-    return do enum_name.as_c_str |enum_name| { unsafe { llvm::LLVMDIBuilderCreateUnionType(\n-        DIB(cx),\n-        file_metadata,\n-        enum_name,\n-        file_metadata,\n-        loc.line as c_uint,\n-        bytes_to_bits(enum_type_size),\n-        bytes_to_bits(enum_type_align),\n-        0, // Flags\n-        create_DIArray(DIB(cx), variants_metadata),\n-        0) // RuntimeLang\n-    }};\n+    return do enum_name.as_c_str |enum_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateUnionType(\n+                DIB(cx),\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(enum_type_size),\n+                bytes_to_bits(enum_type_align),\n+                0, // Flags\n+                create_DIArray(DIB(cx), variants_metadata),\n+                0) // RuntimeLang\n+        }\n+    };\n }\n \n \n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn create_composite_type_metadata(cx: &mut CrateContext,\n-                                  composite_llvm_type: Type,\n-                                  composite_type_name: &str,\n-                                  member_llvm_types: &[Type],\n-                                  member_names: &[~str],\n-                                  member_type_metadata: &[DIType],\n-                                  span: span)\n-                               -> DICompositeType {\n+fn composite_type_metadata(cx: &mut CrateContext,\n+                           composite_llvm_type: Type,\n+                           composite_type_name: &str,\n+                           member_llvm_types: &[Type],\n+                           member_names: &[~str],\n+                           member_type_metadata: &[DIType],\n+                           span: span)\n+                        -> DICompositeType {\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n     let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n \n-    let member_metadata : ~[DIDescriptor] = member_llvm_types\n+    let member_metadata: ~[DIDescriptor] = member_llvm_types\n         .iter()\n         .enumerate()\n         .transform(|(i, &member_llvm_type)| {\n             let (member_size, member_align) = size_and_align_of(cx, member_llvm_type);\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n-            let member_name : &str = member_names[i];\n-\n-            do member_name.as_c_str |member_name| { unsafe {\n-                llvm::LLVMDIBuilderCreateMemberType(\n-                    DIB(cx),\n-                    file_metadata,\n-                    member_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    bytes_to_bits(member_size),\n-                    bytes_to_bits(member_align),\n-                    bytes_to_bits(member_offset),\n-                    0,\n-                    member_type_metadata[i])\n-            }}\n+            let member_name: &str = member_names[i];\n+\n+            do member_name.as_c_str |member_name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateMemberType(\n+                        DIB(cx),\n+                        file_metadata,\n+                        member_name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        bytes_to_bits(member_size),\n+                        bytes_to_bits(member_align),\n+                        bytes_to_bits(member_offset),\n+                        0,\n+                        member_type_metadata[i])\n+                }\n+            }\n         })\n         .collect();\n \n-    return do composite_type_name.as_c_str |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateStructType(\n-            DIB(cx),\n-            file_metadata,\n-            name,\n-            file_metadata,\n-            loc.line as c_uint,\n-            bytes_to_bits(composite_size),\n-            bytes_to_bits(composite_align),\n-            0,\n-            ptr::null(),\n-            create_DIArray(DIB(cx), member_metadata),\n-            0,\n-            ptr::null())\n-    }};\n+    return do composite_type_name.as_c_str |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateStructType(\n+                DIB(cx),\n+                file_metadata,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(composite_size),\n+                bytes_to_bits(composite_align),\n+                0,\n+                ptr::null(),\n+                create_DIArray(DIB(cx), member_metadata),\n+                0,\n+                ptr::null())\n+    }\n+    };\n }\n \n-fn create_boxed_type_metadata(cx: &mut CrateContext,\n-                              content_llvm_type: Type,\n-                              content_type_metadata: DIType,\n-                              span: span)\n-                           -> DICompositeType {\n+fn boxed_type_metadata(cx: &mut CrateContext,\n+                       content_type_name: Option<&str>,\n+                       content_llvm_type: Type,\n+                       content_type_metadata: DIType,\n+                       span: span)\n+                    -> DICompositeType {\n+\n+    let box_type_name = match content_type_name {\n+        Some(content_type_name) => fmt!(\"Boxed<%s>\", content_type_name),\n+        None                    => ~\"BoxedType\"\n+    };\n \n     let box_llvm_type = Type::box(cx, &content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     let member_names = [~\"refcnt\", ~\"tydesc\", ~\"prev\", ~\"next\", ~\"val\"];\n \n-    assert!(box_layout_is_as_expected(cx, member_llvm_types, content_llvm_type));\n+    assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n \n     let int_type = ty::mk_int();\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n \n     let member_types_metadata = [\n-        get_or_create_type_metadata(cx, int_type, span),\n-        get_or_create_type_metadata(cx, nil_pointer_type, span),\n-        get_or_create_type_metadata(cx, nil_pointer_type, span),\n-        get_or_create_type_metadata(cx, nil_pointer_type, span),\n+        type_metadata(cx, int_type, span),\n+        type_metadata(cx, nil_pointer_type, span),\n+        type_metadata(cx, nil_pointer_type, span),\n+        type_metadata(cx, nil_pointer_type, span),\n         content_type_metadata\n     ];\n \n-    return create_composite_type_metadata(\n+    return composite_type_metadata(\n         cx,\n         box_llvm_type,\n-        \"box name\",\n+        box_type_name,\n         member_llvm_types,\n         member_names,\n         member_types_metadata,\n         span);\n \n     // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n-    // 'next' and 'prev' pointers are in the order.\n-    fn box_layout_is_as_expected(cx: &CrateContext,\n-                                 member_llvm_types: &[Type],\n-                                 content_llvm_type: Type)\n-                              -> bool {\n+    // 'next' and 'prev' pointers are in the correct order.\n+    fn box_layout_is_correct(cx: &CrateContext,\n+                             member_llvm_types: &[Type],\n+                             content_llvm_type: Type)\n+                          -> bool {\n         member_llvm_types.len() == 5 &&\n         member_llvm_types[0] == cx.int_type &&\n         member_llvm_types[1] == cx.tydesc_type.ptr_to() &&\n@@ -949,59 +990,62 @@ fn create_boxed_type_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn create_fixed_vec_metadata(cx: &mut CrateContext,\n-                             element_type: ty::t,\n-                             len: uint,\n-                             span: span)\n-                          -> DIType {\n-    let element_type_metadata = get_or_create_type_metadata(cx, element_type, span);\n+fn fixed_vec_metadata(cx: &mut CrateContext,\n+                      element_type: ty::t,\n+                      len: uint,\n+                      span: span)\n+                   -> DIType {\n+    let element_type_metadata = type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n \n-    let subrange = unsafe { llvm::LLVMDIBuilderGetOrCreateSubrange(\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(\n         DIB(cx),\n         0,\n-        len as c_longlong\n-    )};\n+        len as c_longlong)\n+    };\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n-    return unsafe { llvm::LLVMDIBuilderCreateArrayType(\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n             bytes_to_bits(element_type_size * len),\n             bytes_to_bits(element_type_align),\n             element_type_metadata,\n-            subscripts\n-    )};\n+            subscripts)\n+    };\n }\n \n-fn create_boxed_vec_metadata(cx: &mut CrateContext,\n-                             element_type: ty::t,\n-                             span: span)\n-                          -> DICompositeType {\n+fn boxed_vec_metadata(cx: &mut CrateContext,\n+                      element_type: ty::t,\n+                      span: span)\n+                   -> DICompositeType {\n \n-    let element_type_metadata = get_or_create_type_metadata(cx, element_type, span);\n+    let element_type_metadata = type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name = &\"vec\";\n+    let vec_type_name: &str = fmt!(\"[%s]\", ty_to_str(cx.tcx, element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n     let member_names = &[~\"fill\", ~\"alloc\", ~\"elements\"];\n \n-    let int_type_metadata = get_or_create_type_metadata(cx, ty::mk_int(), span);\n-    let array_type_metadata = unsafe { llvm::LLVMDIBuilderCreateArrayType(\n-        DIB(cx),\n-        bytes_to_bits(element_size),\n-        bytes_to_bits(element_align),\n-        element_type_metadata,\n-        create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n+    let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n+    let array_type_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(\n+            DIB(cx),\n+            bytes_to_bits(element_size),\n+            bytes_to_bits(element_align),\n+            element_type_metadata,\n+            create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n     };\n \n-    //                           fill         alloc        elements\n+    //                           fill               alloc              elements\n     let member_type_metadata = &[int_type_metadata, int_type_metadata, array_type_metadata];\n \n-    let vec_metadata = create_composite_type_metadata(\n+    let vec_metadata = composite_type_metadata(\n         cx,\n         vec_llvm_type,\n         vec_type_name,\n@@ -1010,33 +1054,36 @@ fn create_boxed_vec_metadata(cx: &mut CrateContext,\n         member_type_metadata,\n         span);\n \n-    return create_boxed_type_metadata(cx, vec_llvm_type, vec_metadata, span);\n+    return boxed_type_metadata(\n+        cx,\n+        Some(vec_type_name),\n+        vec_llvm_type,\n+        vec_metadata,\n+        span);\n }\n \n-fn create_vec_slice_metadata(cx: &mut CrateContext,\n-                             vec_type: ty::t,\n-                             element_type: ty::t,\n-                             span: span)\n-                          -> DICompositeType {\n+fn vec_slice_metadata(cx: &mut CrateContext,\n+                      vec_type: ty::t,\n+                      element_type: ty::t,\n+                      span: span)\n+                   -> DICompositeType {\n \n-    debug!(\"create_vec_slice_metadata: %?\", ty::get(vec_type));\n+    debug!(\"vec_slice_metadata: %?\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ty_to_str(cx.tcx, vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     let member_names = &[~\"data_ptr\", ~\"size_in_bytes\"];\n \n-    assert!(slice_layout_is_as_expected(cx, member_llvm_types, element_type));\n+    assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n \n-    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_const });\n+    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_imm });\n \n-    let member_type_metadata = &[\n-        get_or_create_type_metadata(cx, data_ptr_type, span),\n-        get_or_create_type_metadata(cx, ty::mk_uint(), span)\n-        ];\n+    let member_type_metadata = &[type_metadata(cx, data_ptr_type, span),\n+                                 type_metadata(cx, ty::mk_uint(), span)];\n \n-    return create_composite_type_metadata(\n+    return composite_type_metadata(\n         cx,\n         slice_llvm_type,\n         slice_type_name,\n@@ -1045,33 +1092,33 @@ fn create_vec_slice_metadata(cx: &mut CrateContext,\n         member_type_metadata,\n         span);\n \n-    fn slice_layout_is_as_expected(cx: &mut CrateContext,\n-                                   member_llvm_types: &[Type],\n-                                   element_type: ty::t)\n-                                -> bool {\n+    fn slice_layout_is_correct(cx: &mut CrateContext,\n+                               member_llvm_types: &[Type],\n+                               element_type: ty::t)\n+                            -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n         member_llvm_types[1] == cx.int_type\n     }\n }\n \n-fn create_bare_fn_metadata(cx: &mut CrateContext,\n-                           _fn_ty: ty::t,\n-                           inputs: ~[ty::t],\n-                           output: ty::t,\n-                           span: span)\n-                        -> DICompositeType {\n+fn bare_fn_metadata(cx: &mut CrateContext,\n+                    _fn_ty: ty::t,\n+                    inputs: ~[ty::t],\n+                    output: ty::t,\n+                    span: span)\n+                 -> DICompositeType {\n \n-    debug!(\"create_bare_fn_metadata: %?\", ty::get(_fn_ty));\n+    debug!(\"bare_fn_metadata: %?\", ty::get(_fn_ty));\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let nil_pointer_type_metadata = get_or_create_type_metadata(cx, ty::mk_nil_ptr(cx.tcx), span);\n-    let output_metadata = get_or_create_type_metadata(cx, output, span);\n-    let output_ptr_metadata = create_pointer_type_metadata(cx, output, output_metadata);\n+    let nil_pointer_type_metadata = type_metadata(cx, ty::mk_nil_ptr(cx.tcx), span);\n+    let output_metadata = type_metadata(cx, output, span);\n+    let output_ptr_metadata = pointer_type_metadata(cx, output, output_metadata);\n \n-    let inputs_vals = do inputs.map |arg| { get_or_create_type_metadata(cx, *arg, span) };\n+    let inputs_vals = do inputs.map |arg| { type_metadata(cx, *arg, span) };\n     let members = ~[output_ptr_metadata, nil_pointer_type_metadata] + inputs_vals;\n \n     return unsafe {\n@@ -1082,32 +1129,57 @@ fn create_bare_fn_metadata(cx: &mut CrateContext,\n     };\n }\n \n-fn create_unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug!(\"create_unimplemented_type_metadata: %?\", ty::get(t));\n+fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n+    debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n-    let metadata = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateBasicType(\n-            DIB(cx),\n-            name,\n-            0_u64,\n-            8_u64,\n-            DW_ATE_unsigned as c_uint)\n-        }};\n+    let metadata = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateBasicType(\n+                DIB(cx),\n+                name,\n+                0_u64,\n+                8_u64,\n+                DW_ATE_unsigned as c_uint)\n+            }\n+        };\n+\n     return metadata;\n }\n \n-fn get_or_create_type_metadata(cx: &mut CrateContext,\n-                               t: ty::t,\n-                               span: span)\n-                            -> DIType {\n+fn type_metadata(cx: &mut CrateContext,\n+                 t: ty::t,\n+                 span: span)\n+              -> DIType {\n     let type_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&type_id) {\n         Some(type_metadata) => return *type_metadata,\n         None => ()\n     }\n \n-    debug!(\"get_or_create_type_metadata: %?\", ty::get(t));\n+    fn create_pointer_to_box_metadata(cx: &mut CrateContext,\n+                                      pointer_type: ty::t,\n+                                      type_in_box: ty::t)\n+                                   -> DIType {\n+\n+        let content_type_name: &str = ty_to_str(cx.tcx, type_in_box);\n+        let content_llvm_type = type_of::type_of(cx, type_in_box);\n+        let content_type_metadata = type_metadata(\n+            cx,\n+            type_in_box,\n+            codemap::dummy_sp());\n+\n+        let box_metadata = boxed_type_metadata(\n+            cx,\n+            Some(content_type_name),\n+            content_llvm_type,\n+            content_type_metadata,\n+            codemap::dummy_sp());\n+\n+        pointer_type_metadata(cx, pointer_type, box_metadata)\n+    }\n+\n+    debug!(\"type_metadata: %?\", ty::get(t));\n \n     let sty = copy ty::get(t).sty;\n     let type_metadata = match sty {\n@@ -1117,42 +1189,42 @@ fn get_or_create_type_metadata(cx: &mut CrateContext,\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n-            create_basic_type_metadata(cx, t)\n+            basic_type_metadata(cx, t)\n         },\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec_metadata(cx, i8_t, len + 1, span)\n+                    fixed_vec_metadata(cx, i8_t, len + 1, span)\n                 },\n                 ty::vstore_uniq |\n                 ty::vstore_box => {\n-                    let box_metadata = create_boxed_vec_metadata(cx, i8_t, span);\n-                    create_pointer_type_metadata(cx, t, box_metadata)\n+                    let box_metadata = boxed_vec_metadata(cx, i8_t, span);\n+                    pointer_type_metadata(cx, t, box_metadata)\n                 }\n                 ty::vstore_slice(_region) => {\n-                    create_vec_slice_metadata(cx, t, i8_t, span)\n+                    vec_slice_metadata(cx, t, i8_t, span)\n                 }\n             }\n         },\n         ty::ty_enum(def_id, ref substs) => {\n-            create_enum_metadata(cx, t, def_id, substs, span)\n+            enum_metadata(cx, t, def_id, substs, span)\n         },\n         ty::ty_box(ref mt) => {\n             create_pointer_to_box_metadata(cx, t, mt.ty)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec_metadata(cx, mt.ty, len, span)\n+                    fixed_vec_metadata(cx, mt.ty, len, span)\n                 },\n                 ty::vstore_uniq |\n                 ty::vstore_box  => {\n-                    let box_metadata = create_boxed_vec_metadata(cx, mt.ty, span);\n-                    create_pointer_type_metadata(cx, t, box_metadata)\n+                    let box_metadata = boxed_vec_metadata(cx, mt.ty, span);\n+                    pointer_type_metadata(cx, t, box_metadata)\n                 },\n                 ty::vstore_slice(_) => {\n-                    create_vec_slice_metadata(cx, t, mt.ty, span)\n+                    vec_slice_metadata(cx, t, mt.ty, span)\n                 }\n             }\n         },\n@@ -1162,52 +1234,34 @@ fn get_or_create_type_metadata(cx: &mut CrateContext,\n         ty::ty_uniq(ref mt)    |\n         ty::ty_ptr(ref mt)     |\n         ty::ty_rptr(_, ref mt) => {\n-            let pointee = get_or_create_type_metadata(cx, mt.ty, span);\n-            create_pointer_type_metadata(cx, t, pointee)\n+            let pointee = type_metadata(cx, mt.ty, span);\n+            pointer_type_metadata(cx, t, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = barefnty.sig.inputs.map(|a| *a);\n             let output = barefnty.sig.output;\n-            create_bare_fn_metadata(cx, t, inputs, output, span)\n+            bare_fn_metadata(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n             cx.sess.span_note(span, \"debuginfo for closure NYI\");\n-            create_unimplemented_type_metadata(cx, t)\n+            unimplemented_type_metadata(cx, t)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n-            create_unimplemented_type_metadata(cx, t)\n+            unimplemented_type_metadata(cx, t)\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n-            create_struct_metadata(cx, t, fields, span)\n+            struct_metadata(cx, t, fields, span)\n         },\n         ty::ty_tup(ref elements) => {\n-            create_tuple_metadata(cx, t, *elements, span)\n+            tuple_metadata(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in get_or_create_type_metadata\")\n+        _ => cx.sess.bug(\"debuginfo: unexpected type in type_metadata\")\n     };\n \n     dbg_cx(cx).created_types.insert(type_id, type_metadata);\n     return type_metadata;\n-\n-\n-    fn create_pointer_to_box_metadata(cx: &mut CrateContext,\n-                                      pointer_type: ty::t,\n-                                      type_in_box: ty::t)\n-                                   -> DIType {\n-        let content_llvm_type = type_of::type_of(cx, type_in_box);\n-        let content_type_metadata = get_or_create_type_metadata(cx,\n-                                                                type_in_box,\n-                                                                codemap::dummy_sp());\n-\n-        let box_metadata = create_boxed_type_metadata(cx,\n-                                                      content_llvm_type,\n-                                                      content_type_metadata,\n-                                                      codemap::dummy_sp());\n-\n-        create_pointer_type_metadata(cx, pointer_type, box_metadata)\n-    }\n }\n \n fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {"}, {"sha": "6c1d8b966e5a30d78dc60eed79ae9105d3f60299", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -3731,17 +3731,18 @@ impl VariantInfo {\n             },\n             ast::struct_variant_kind(ref struct_def) => {\n \n-                let fields : &[@struct_field] = struct_def.fields;\n+                let fields: &[@struct_field] = struct_def.fields;\n \n                 assert!(fields.len() > 0);\n \n                 let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n                 let arg_names = do fields.map |field| {\n                     match field.node.kind {\n-                        named_field(ident, _visibility) => ident,\n+                        named_field(ident, _) => ident,\n                         unnamed_field => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n-                    }};\n+                    }\n+                };\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3904,7 +3905,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let mut last_discriminant : Option<int> = None;\n+            let mut last_discriminant: Option<int> = None;\n             @enum_definition.variants.iter().transform(|variant| {\n \n                 let mut discriminant = match last_discriminant {\n@@ -3914,8 +3915,13 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n \n                 match variant.node.disr_expr {\n                     Some(e) => match const_eval::eval_const_expr_partial(cx, e) {\n-                        Ok(const_eval::const_int(val)) => { discriminant = val as int; }\n-                        _ => {}\n+                        Ok(const_eval::const_int(val)) => discriminant = val as int,\n+                        Ok(_) => {\n+                            cx.sess.span_err(e.span, \"expected signed integer constant\");\n+                        }\n+                        Err(ref err) => {\n+                            cx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                        }\n                     },\n                     None => {}\n                 };"}, {"sha": "fa24c8c6d0983ab53eafa8ec70bee3aa19293f37", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -3138,9 +3138,9 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 -> ~[@ty::VariantInfo] {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants : ~[@ty::VariantInfo] = ~[];\n+        let mut variants: ~[@ty::VariantInfo] = ~[];\n         let mut disr_vals: ~[int] = ~[];\n-        let mut prev_disr_val : Option<int> = None;\n+        let mut prev_disr_val: Option<int> = None;\n \n         for vs.iter().advance |v| {\n \n@@ -3163,7 +3163,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                     // handle, so we may still get an internal compiler error\n \n                     match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n-                        Ok(const_eval::const_int(val)) => { current_disr_val = val as int; }\n+                        Ok(const_eval::const_int(val)) => current_disr_val = val as int,\n                         Ok(_) => {\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}, {"sha": "7610301f6f0358baf940d2617d8a8e3f3c03d24b", "filename": "src/test/debug-info/borrowed-basic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -64,49 +64,49 @@\n \n fn main() {\n     let bool_val: bool = true;\n-    let bool_ref : &bool = &bool_val;\n+    let bool_ref: &bool = &bool_val;\n \n     let int_val: int = -1;\n-    let int_ref : &int = &int_val;\n+    let int_ref: &int = &int_val;\n \n     let char_val: char = 'a';\n-    let char_ref : &char = &char_val;\n+    let char_ref: &char = &char_val;\n \n     let i8_val: i8 = 68;\n-    let i8_ref : &i8 = &i8_val;\n+    let i8_ref: &i8 = &i8_val;\n \n     let i16_val: i16 = -16;\n-    let i16_ref : &i16 = &i16_val;\n+    let i16_ref: &i16 = &i16_val;\n \n     let i32_val: i32 = -32;\n-    let i32_ref : &i32 = &i32_val;\n+    let i32_ref: &i32 = &i32_val;\n \n     let uint_val: i64 = -64;\n-    let i64_ref : &i64 = &uint_val;\n+    let i64_ref: &i64 = &uint_val;\n \n     let uint_val: uint = 1;\n-    let uint_ref : &uint = &uint_val;\n+    let uint_ref: &uint = &uint_val;\n \n     let u8_val: u8 = 100;\n-    let u8_ref : &u8 = &u8_val;\n+    let u8_ref: &u8 = &u8_val;\n \n     let u16_val: u16 = 16;\n-    let u16_ref : &u16 = &u16_val;\n+    let u16_ref: &u16 = &u16_val;\n \n     let u32_val: u32 = 32;\n-    let u32_ref : &u32 = &u32_val;\n+    let u32_ref: &u32 = &u32_val;\n \n     let u64_val: u64 = 64;\n-    let u64_ref : &u64 = &u64_val;\n+    let u64_ref: &u64 = &u64_val;\n \n     let float_val: float = 1.5;\n-    let float_ref : &float = &float_val;\n+    let float_ref: &float = &float_val;\n \n     let f32_val: f32 = 2.5;\n-    let f32_ref : &f32 = &f32_val;\n+    let f32_ref: &f32 = &f32_val;\n \n     let f64_val: f64 = 3.5;\n-    let f64_ref : &f64 = &f64_val;\n+    let f64_ref: &f64 = &f64_val;\n     zzz();\n }\n "}, {"sha": "70c85258c7921518cafd1d5dbc084472b004d15e", "filename": "src/test/debug-info/borrowed-c-style-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -28,13 +28,13 @@ enum ABC { TheA, TheB, TheC }\n \n fn main() {\n     let the_a = TheA;\n-    let the_a_ref : &ABC = &the_a;\n+    let the_a_ref: &ABC = &the_a;\n \n     let the_b = TheB;\n-    let the_b_ref : &ABC = &the_b;\n+    let the_b_ref: &ABC = &the_b;\n \n     let the_c = TheC;\n-    let the_c_ref : &ABC = &the_c;\n+    let the_c_ref: &ABC = &the_c;\n \n     zzz();\n }"}, {"sha": "38aa9c38810006fd5caf7b9c9d64499c917cb596", "filename": "src/test/debug-info/borrowed-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -44,17 +44,17 @@ fn main() {\n \t// 0b0111110001111100 = 31868\n \t// 0b01111100 = 124\n     let the_a = TheA { x: 0, y: 8970181431921507452 };\n-    let the_a_ref : &ABC = &the_a;\n+    let the_a_ref: &ABC = &the_a;\n \n     // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n     // 0b00010001000100010001000100010001 = 286331153\n     // 0b0001000100010001 = 4369\n     // 0b00010001 = 17\n     let the_b = TheB (0, 286331153, 286331153);\n-    let the_b_ref : &ABC = &the_b;\n+    let the_b_ref: &ABC = &the_b;\n \n     let univariant = TheOnlyCase(4820353753753434);\n-    let univariant_ref : &Univariant = &univariant;\n+    let univariant_ref: &Univariant = &univariant;\n \n     zzz();\n }"}, {"sha": "9087bb36fa5d66d9171753bc0c8fbfc6a53403e4", "filename": "src/test/debug-info/borrowed-managed-basic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -65,49 +65,49 @@\n \n fn main() {\n     let bool_box: @bool = @true;\n-    let bool_ref : &bool = bool_box;\n+    let bool_ref: &bool = bool_box;\n \n     let int_box: @int = @-1;\n-    let int_ref : &int = int_box;\n+    let int_ref: &int = int_box;\n \n     let char_box: @char = @'a';\n-    let char_ref : &char = char_box;\n+    let char_ref: &char = char_box;\n \n     let i8_box: @i8 = @68;\n-    let i8_ref : &i8 = i8_box;\n+    let i8_ref: &i8 = i8_box;\n \n     let i16_box: @i16 = @-16;\n-    let i16_ref : &i16 = i16_box;\n+    let i16_ref: &i16 = i16_box;\n \n     let i32_box: @i32 = @-32;\n-    let i32_ref : &i32 = i32_box;\n+    let i32_ref: &i32 = i32_box;\n \n     let i64_box: @i64 = @-64;\n-    let i64_ref : &i64 = i64_box;\n+    let i64_ref: &i64 = i64_box;\n \n     let uint_box: @uint = @1;\n-    let uint_ref : &uint = uint_box;\n+    let uint_ref: &uint = uint_box;\n \n     let u8_box: @u8 = @100;\n-    let u8_ref : &u8 = u8_box;\n+    let u8_ref: &u8 = u8_box;\n \n     let u16_box: @u16 = @16;\n-    let u16_ref : &u16 = u16_box;\n+    let u16_ref: &u16 = u16_box;\n \n     let u32_box: @u32 = @32;\n-    let u32_ref : &u32 = u32_box;\n+    let u32_ref: &u32 = u32_box;\n \n     let u64_box: @u64 = @64;\n-    let u64_ref : &u64 = u64_box;\n+    let u64_ref: &u64 = u64_box;\n \n     let float_box: @float = @1.5;\n-    let float_ref : &float = float_box;\n+    let float_ref: &float = float_box;\n \n     let f32_box: @f32 = @2.5;\n-    let f32_ref : &f32 = f32_box;\n+    let f32_ref: &f32 = f32_box;\n \n     let f64_box: @f64 = @3.5;\n-    let f64_ref : &f64 = f64_box;\n+    let f64_ref: &f64 = f64_box;\n     zzz();\n }\n "}, {"sha": "8b6eca3e37f79d2338c7c66d15a274b304879424", "filename": "src/test/debug-info/borrowed-struct.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -54,20 +54,20 @@ struct SomeStruct {\n \n fn main() {\n     let stack_val: SomeStruct = SomeStruct { x: 10, y: 23.5 };\n-    let stack_val_ref : &SomeStruct = &stack_val;\n-    let stack_val_interior_ref_1 : &int = &stack_val.x;\n-    let stack_val_interior_ref_2 : &f64 = &stack_val.y;\n-    let ref_to_unnamed : &SomeStruct = &SomeStruct { x: 11, y: 24.5 };\n+    let stack_val_ref: &SomeStruct = &stack_val;\n+    let stack_val_interior_ref_1: &int = &stack_val.x;\n+    let stack_val_interior_ref_2: &f64 = &stack_val.y;\n+    let ref_to_unnamed: &SomeStruct = &SomeStruct { x: 11, y: 24.5 };\n \n     let managed_val = @SomeStruct { x: 12, y: 25.5 };\n-    let managed_val_ref : &SomeStruct = managed_val;\n-    let managed_val_interior_ref_1 : &int = &managed_val.x;\n-    let managed_val_interior_ref_2 : &f64 = &managed_val.y;\n+    let managed_val_ref: &SomeStruct = managed_val;\n+    let managed_val_interior_ref_1: &int = &managed_val.x;\n+    let managed_val_interior_ref_2: &f64 = &managed_val.y;\n \n     let unique_val = ~SomeStruct { x: 13, y: 26.5 };\n-    let unique_val_ref : &SomeStruct = unique_val;\n-    let unique_val_interior_ref_1 : &int = &unique_val.x;\n-    let unique_val_interior_ref_2 : &f64 = &unique_val.y;\n+    let unique_val_ref: &SomeStruct = unique_val;\n+    let unique_val_interior_ref_1: &int = &unique_val.x;\n+    let unique_val_interior_ref_2: &f64 = &unique_val.y;\n \n     zzz();\n }"}, {"sha": "da199941c841975a8937fb8ef02afa485e6fb797", "filename": "src/test/debug-info/borrowed-tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -29,14 +29,14 @@\n \n fn main() {\n     let stack_val: (i16, f32) = (-14, -19f32);\n-    let stack_val_ref : &(i16, f32) = &stack_val;\n-    let ref_to_unnamed : &(i16, f32) = &(-15, -20f32);\n+    let stack_val_ref: &(i16, f32) = &stack_val;\n+    let ref_to_unnamed: &(i16, f32) = &(-15, -20f32);\n \n-    let managed_val : @(i16, f32) = @(-16, -21f32);\n-    let managed_val_ref : &(i16, f32) = managed_val;\n+    let managed_val: @(i16, f32) = @(-16, -21f32);\n+    let managed_val_ref: &(i16, f32) = managed_val;\n \n     let unique_val: ~(i16, f32) = ~(-17, -22f32);\n-    let unique_val_ref : &(i16, f32) = unique_val;\n+    let unique_val_ref: &(i16, f32) = unique_val;\n \n     zzz();\n }"}, {"sha": "52f5a2cba1ebe721feeccffb3f23384b939408de", "filename": "src/test/debug-info/borrowed-unique-basic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -65,49 +65,49 @@\n \n fn main() {\n     let bool_box: ~bool = ~true;\n-    let bool_ref : &bool = bool_box;\n+    let bool_ref: &bool = bool_box;\n \n     let int_box: ~int = ~-1;\n-    let int_ref : &int = int_box;\n+    let int_ref: &int = int_box;\n \n     let char_box: ~char = ~'a';\n-    let char_ref : &char = char_box;\n+    let char_ref: &char = char_box;\n \n     let i8_box: ~i8 = ~68;\n-    let i8_ref : &i8 = i8_box;\n+    let i8_ref: &i8 = i8_box;\n \n     let i16_box: ~i16 = ~-16;\n-    let i16_ref : &i16 = i16_box;\n+    let i16_ref: &i16 = i16_box;\n \n     let i32_box: ~i32 = ~-32;\n-    let i32_ref : &i32 = i32_box;\n+    let i32_ref: &i32 = i32_box;\n \n     let i64_box: ~i64 = ~-64;\n-    let i64_ref : &i64 = i64_box;\n+    let i64_ref: &i64 = i64_box;\n \n     let uint_box: ~uint = ~1;\n-    let uint_ref : &uint = uint_box;\n+    let uint_ref: &uint = uint_box;\n \n     let u8_box: ~u8 = ~100;\n-    let u8_ref : &u8 = u8_box;\n+    let u8_ref: &u8 = u8_box;\n \n     let u16_box: ~u16 = ~16;\n-    let u16_ref : &u16 = u16_box;\n+    let u16_ref: &u16 = u16_box;\n \n     let u32_box: ~u32 = ~32;\n-    let u32_ref : &u32 = u32_box;\n+    let u32_ref: &u32 = u32_box;\n \n     let u64_box: ~u64 = ~64;\n-    let u64_ref : &u64 = u64_box;\n+    let u64_ref: &u64 = u64_box;\n \n     let float_box: ~float = ~1.5;\n-    let float_ref : &float = float_box;\n+    let float_ref: &float = float_box;\n \n     let f32_box: ~f32 = ~2.5;\n-    let f32_ref : &f32 = f32_box;\n+    let f32_ref: &f32 = f32_box;\n \n     let f64_box: ~f64 = ~3.5;\n-    let f64_ref : &f64 = f64_box;\n+    let f64_ref: &f64 = f64_box;\n     zzz();\n }\n "}, {"sha": "c63cffd7b74bb7311743f212380ea52b14e3d92b", "filename": "src/test/debug-info/box.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n // debugger:break _zzz"}, {"sha": "86162f0fa04cd4abbf92d09fe68d73363b49d26b", "filename": "src/test/debug-info/boxed-struct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run"}, {"sha": "964ca689e8af1db140063e061ad2eb6cc77699cb", "filename": "src/test/debug-info/boxed-vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -25,8 +27,8 @@\n \n fn main() {\n \n-    let managed : @[i64] = @[7, 8, 9];\n-    let unique : ~[i64] = ~[10, 11, 12, 13];\n+    let managed: @[i64] = @[7, 8, 9];\n+    let unique: ~[i64] = ~[10, 11, 12, 13];\n \n     zzz();\n }"}, {"sha": "47e433ea814abef3eec95fca5e2c9201e815714a", "filename": "src/test/debug-info/c-style-enum-in-composite.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run"}, {"sha": "d7cce4e6f3fb54585cc9a0add5ccb94546b82e58", "filename": "src/test/debug-info/c-style-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run"}, {"sha": "207899fe3b5104976a92b3610a4a176f65ae44f7", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -22,7 +22,7 @@\n // check:$2 = false\n \n fn main() {\n-    let (a, b) : (int, bool) = (9898, false);\n+    let (a, b): (int, bool) = (9898, false);\n \n     zzz();\n }"}, {"sha": "3eb1c2ef01e55da2465f4e716842c3de473678c6", "filename": "src/test/debug-info/managed-box-within-unique.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fmanaged-box-within-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fmanaged-box-within-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-box-within-unique.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n // debugger:break zzz"}, {"sha": "d3afd4b11f9cd1f5e84e5e477b69fc2018c8bac1", "filename": "src/test/debug-info/nil-enum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fnil-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -28,8 +30,8 @@ enum AnotherNilEnum {}\n // 2. That gdb prints the string \"{<No data fields>}\" for empty structs (which may change some time)\n fn main() {\n     unsafe {\n-        let first : ANilEnum = std::cast::transmute(());\n-        let second : AnotherNilEnum = std::cast::transmute(());\n+        let first: ANilEnum = std::cast::transmute(());\n+        let second: AnotherNilEnum = std::cast::transmute(());\n \n         zzz();\n     }"}, {"sha": "6d3b157d63e802136c322e4c08cf55b9dd444c1e", "filename": "src/test/debug-info/option-like-enum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -49,8 +51,8 @@ enum NamedFields<'self> {\n \n fn main() {\n \n-    let some : Option<&u32> = Some(unsafe { std::cast::transmute(0x12345678) });\n-    let none : Option<&u32> = None;\n+    let some: Option<&u32> = Some(unsafe { std::cast::transmute(0x12345678) });\n+    let none: Option<&u32> = None;\n \n     let full = Full(454545, unsafe { std::cast::transmute(0x87654321) }, 9988);\n "}, {"sha": "f45294221af1686a84f4bf383e883ad95417aa3a", "filename": "src/test/debug-info/simple-tuple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -35,15 +35,15 @@\n \n \n fn main() {\n-    let noPadding8 : (i8, u8) = (-100, 100);\n-    let noPadding16 : (i16, i16, u16) = (0, 1, 2);\n-    let noPadding32 : (i32, f32, u32) = (3, 4.5, 5);\n-    let noPadding64 : (i64, f64, u64) = (6, 7.5, 8);\n+    let noPadding8: (i8, u8) = (-100, 100);\n+    let noPadding16: (i16, i16, u16) = (0, 1, 2);\n+    let noPadding32: (i32, f32, u32) = (3, 4.5, 5);\n+    let noPadding64: (i64, f64, u64) = (6, 7.5, 8);\n \n-    let internalPadding1 : (i16, i32) = (9, 10);\n-    let internalPadding2 : (i16, i32, u32, u64) = (11, 12, 13, 14);\n+    let internalPadding1: (i16, i32) = (9, 10);\n+    let internalPadding2: (i16, i32, u32, u64) = (11, 12, 13, 14);\n \n-    let paddingAtEnd : (i32, i16) = (15, 16);\n+    let paddingAtEnd: (i32, i16) = (15, 16);\n \n     zzz();\n }"}, {"sha": "1002266a1a98539c8cf18ab7b9aefee74233d05c", "filename": "src/test/debug-info/struct-in-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-in-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print union on\n // debugger:break zzz"}, {"sha": "61bbd2e215ff6933b138f9c40ac4b7a318e40a0e", "filename": "src/test/debug-info/struct-style-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-style-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print union on\n // debugger:break zzz"}, {"sha": "ba28153ebafd55a546f93b4d0691296c3a6a5f88", "filename": "src/test/debug-info/struct-with-destructor.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -29,13 +31,13 @@\n \n \n struct NoDestructor {\n-    x : i32,\n-    y : i64\n+    x: i32,\n+    y: i64\n }\n \n struct WithDestructor {\n-    x : i32,\n-    y : i64\n+    x: i32,\n+    y: i64\n }\n \n impl Drop for WithDestructor {"}, {"sha": "9c6805dae67d37721390fbf53ae8f0d7cf8d8265", "filename": "src/test/debug-info/tuple-in-tuple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -34,15 +34,15 @@\n // check:$7 = {{21, 22}, 23}\n \n fn main() {\n-    let no_padding1 : ((u32, u32), u32, u32) = ((0, 1), 2, 3);\n-    let no_padding2 : (u32, (u32, u32), u32) = (4, (5, 6), 7);\n-    let no_padding3 : (u32, u32, (u32, u32)) = (8, 9, (10, 11));\n+    let no_padding1: ((u32, u32), u32, u32) = ((0, 1), 2, 3);\n+    let no_padding2: (u32, (u32, u32), u32) = (4, (5, 6), 7);\n+    let no_padding3: (u32, u32, (u32, u32)) = (8, 9, (10, 11));\n \n-    let internal_padding1 : (i16, (i32, i32)) = (12, (13, 14));\n-    let internal_padding2 : (i16, (i16, i32)) = (15, (16, 17));\n+    let internal_padding1: (i16, (i32, i32)) = (12, (13, 14));\n+    let internal_padding2: (i16, (i16, i32)) = (15, (16, 17));\n \n-    let padding_at_end1 : (i32, (i32, i16)) = (18, (19, 20));\n-    let padding_at_end2 : ((i32, i16), i32) = ((21, 22), 23);\n+    let padding_at_end1: (i32, (i32, i16)) = (18, (19, 20));\n+    let padding_at_end2: ((i32, i16), i32) = ((21, 22), 23);\n \n     zzz();\n }"}, {"sha": "ba1d02bb62a3c6cbcbf7417a0af3057496750eb6", "filename": "src/test/debug-info/tuple-style-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print union on\n // debugger:break zzz"}, {"sha": "4691de049172136c9313c43dbb13ab7f2c2a5fe3", "filename": "src/test/debug-info/vec-slices.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec-slices.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n // debugger:break zzz\n@@ -52,14 +54,14 @@ struct AStruct {\n }\n \n fn main() {\n-    let empty : &[i64] = &[];\n-    let singleton : &[i64] = &[1];\n-    let multiple : &[i64] = &[2, 3, 4, 5];\n+    let empty: &[i64] = &[];\n+    let singleton: &[i64] = &[1];\n+    let multiple: &[i64] = &[2, 3, 4, 5];\n     let slice_of_slice = multiple.slice(1,3);\n \n-    let padded_tuple : &[(i32, i16)] = &[(6, 7), (8, 9)];\n+    let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n \n-    let padded_struct : &[AStruct] = &[\n+    let padded_struct: &[AStruct] = &[\n         AStruct { x: 10, y: 11, z: 12 },\n         AStruct { x: 13, y: 14, z: 15 }\n     ];"}, {"sha": "57130b45eae303be66e0f13aee07517150ff46fb", "filename": "src/test/debug-info/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aeb4b04bccf915444fa2a49ee3f3c33dec7097/src%2Ftest%2Fdebug-info%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec.rs?ref=b2aeb4b04bccf915444fa2a49ee3f3c33dec7097", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n // debugger:break zzz"}]}