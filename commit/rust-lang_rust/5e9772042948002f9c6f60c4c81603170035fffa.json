{"sha": "5e9772042948002f9c6f60c4c81603170035fffa", "node_id": "C_kwDOAAsO6NoAKDVlOTc3MjA0Mjk0ODAwMmY5YzZmNjBjNGM4MTYwMzE3MDAzNWZmZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T17:32:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T17:32:45Z"}, "message": "Auto merge of #103450 - cjgillot:elision-nodedup, r=Mark-Simulacrum\n\nDo not consider repeated lifetime params for elision.\n\nFixes https://github.com/rust-lang/rust/issues/103330", "tree": {"sha": "51c350d2a6a336c4ee58ab582ae30d19409418c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c350d2a6a336c4ee58ab582ae30d19409418c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9772042948002f9c6f60c4c81603170035fffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9772042948002f9c6f60c4c81603170035fffa", "html_url": "https://github.com/rust-lang/rust/commit/5e9772042948002f9c6f60c4c81603170035fffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9772042948002f9c6f60c4c81603170035fffa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68c836a904e5a421712db311421c5266f9ce71c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c836a904e5a421712db311421c5266f9ce71c0", "html_url": "https://github.com/rust-lang/rust/commit/68c836a904e5a421712db311421c5266f9ce71c0"}, {"sha": "cb1e7d96767525fde3965f86bace8a5acf0dc643", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1e7d96767525fde3965f86bace8a5acf0dc643", "html_url": "https://github.com/rust-lang/rust/commit/cb1e7d96767525fde3965f86bace8a5acf0dc643"}], "stats": {"total": 123, "additions": 88, "deletions": 35}, "files": [{"sha": "00eb768ad18d4f79dbd914cb09cf12051adf9a3f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5e9772042948002f9c6f60c4c81603170035fffa/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9772042948002f9c6f60c4c81603170035fffa/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=5e9772042948002f9c6f60c4c81603170035fffa", "patch": "@@ -30,6 +30,7 @@ use rustc_span::{BytePos, Span};\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n+use std::assert_matches::debug_assert_matches;\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n \n@@ -568,7 +569,7 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// They will be used to determine the correct lifetime for the fn return type.\n     /// The `LifetimeElisionCandidate` is used for diagnostics, to suggest introducing named\n     /// lifetimes.\n-    lifetime_elision_candidates: Option<FxIndexMap<LifetimeRes, LifetimeElisionCandidate>>,\n+    lifetime_elision_candidates: Option<Vec<(LifetimeRes, LifetimeElisionCandidate)>>,\n \n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n@@ -1802,7 +1803,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         match res {\n             LifetimeRes::Param { .. } | LifetimeRes::Fresh { .. } | LifetimeRes::Static => {\n                 if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n-                    candidates.insert(res, candidate);\n+                    candidates.push((res, candidate));\n                 }\n             }\n             LifetimeRes::Infer | LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n@@ -1855,12 +1856,25 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         has_self: bool,\n         inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)>,\n     ) -> Result<LifetimeRes, (Vec<MissingLifetime>, Vec<ElisionFnParameter>)> {\n-        let outer_candidates =\n-            replace(&mut self.lifetime_elision_candidates, Some(Default::default()));\n+        enum Elision {\n+            /// We have not found any candidate.\n+            None,\n+            /// We have a candidate bound to `self`.\n+            Self_(LifetimeRes),\n+            /// We have a candidate bound to a parameter.\n+            Param(LifetimeRes),\n+            /// We failed elision.\n+            Err,\n+        }\n \n-        let mut elision_lifetime = None;\n-        let mut lifetime_count = 0;\n+        // Save elision state to reinstate it later.\n+        let outer_candidates = self.lifetime_elision_candidates.take();\n+\n+        // Result of elision.\n+        let mut elision_lifetime = Elision::None;\n+        // Information for diagnostics.\n         let mut parameter_info = Vec::new();\n+        let mut all_candidates = Vec::new();\n \n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         for (index, (pat, ty)) in inputs.enumerate() {\n@@ -1870,61 +1884,82 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     this.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n                 }\n             });\n+\n+            // Record elision candidates only for this parameter.\n+            debug_assert_matches!(self.lifetime_elision_candidates, None);\n+            self.lifetime_elision_candidates = Some(Default::default());\n             self.visit_ty(ty);\n+            let local_candidates = self.lifetime_elision_candidates.take();\n \n-            if let Some(ref candidates) = self.lifetime_elision_candidates {\n-                let new_count = candidates.len();\n-                let local_count = new_count - lifetime_count;\n-                if local_count != 0 {\n+            if let Some(candidates) = local_candidates {\n+                let distinct: FxHashSet<_> = candidates.iter().map(|(res, _)| *res).collect();\n+                let lifetime_count = distinct.len();\n+                if lifetime_count != 0 {\n                     parameter_info.push(ElisionFnParameter {\n                         index,\n                         ident: if let Some(pat) = pat && let PatKind::Ident(_, ident, _) = pat.kind {\n                             Some(ident)\n                         } else {\n                             None\n                         },\n-                        lifetime_count: local_count,\n+                        lifetime_count,\n                         span: ty.span,\n                     });\n+                    all_candidates.extend(candidates.into_iter().filter_map(|(_, candidate)| {\n+                        match candidate {\n+                            LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => {\n+                                None\n+                            }\n+                            LifetimeElisionCandidate::Missing(missing) => Some(missing),\n+                        }\n+                    }));\n+                }\n+                let mut distinct_iter = distinct.into_iter();\n+                if let Some(res) = distinct_iter.next() {\n+                    match elision_lifetime {\n+                        // We are the first parameter to bind lifetimes.\n+                        Elision::None => {\n+                            if distinct_iter.next().is_none() {\n+                                // We have a single lifetime => success.\n+                                elision_lifetime = Elision::Param(res)\n+                            } else {\n+                                // We have have multiple lifetimes => error.\n+                                elision_lifetime = Elision::Err;\n+                            }\n+                        }\n+                        // We have 2 parameters that bind lifetimes => error.\n+                        Elision::Param(_) => elision_lifetime = Elision::Err,\n+                        // `self` elision takes precedence over everything else.\n+                        Elision::Self_(_) | Elision::Err => {}\n+                    }\n                 }\n-                lifetime_count = new_count;\n             }\n \n             // Handle `self` specially.\n             if index == 0 && has_self {\n                 let self_lifetime = self.find_lifetime_for_self(ty);\n                 if let Set1::One(lifetime) = self_lifetime {\n-                    elision_lifetime = Some(lifetime);\n-                    self.lifetime_elision_candidates = None;\n+                    // We found `self` elision.\n+                    elision_lifetime = Elision::Self_(lifetime);\n                 } else {\n-                    self.lifetime_elision_candidates = Some(Default::default());\n-                    lifetime_count = 0;\n+                    // We do not have `self` elision: disregard the `Elision::Param` that we may\n+                    // have found.\n+                    elision_lifetime = Elision::None;\n                 }\n             }\n             debug!(\"(resolving function / closure) recorded parameter\");\n         }\n \n-        let all_candidates = replace(&mut self.lifetime_elision_candidates, outer_candidates);\n-        debug!(?all_candidates);\n+        // Reinstate elision state.\n+        debug_assert_matches!(self.lifetime_elision_candidates, None);\n+        self.lifetime_elision_candidates = outer_candidates;\n \n-        if let Some(res) = elision_lifetime {\n+        if let Elision::Param(res) | Elision::Self_(res) = elision_lifetime {\n             return Ok(res);\n         }\n \n-        // We do not have a `self` candidate, look at the full list.\n-        let all_candidates = all_candidates.unwrap();\n-        if all_candidates.len() == 1 {\n-            Ok(*all_candidates.first().unwrap().0)\n-        } else {\n-            let all_candidates = all_candidates\n-                .into_iter()\n-                .filter_map(|(_, candidate)| match candidate {\n-                    LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => None,\n-                    LifetimeElisionCandidate::Missing(missing) => Some(missing),\n-                })\n-                .collect();\n-            Err((all_candidates, parameter_info))\n-        }\n+        // We do not have a candidate.\n+        Err((all_candidates, parameter_info))\n     }\n \n     /// List all the lifetimes that appear in the provided type.\n@@ -2394,7 +2429,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // Do not account for the parameters we just bound for function lifetime elision.\n         if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n             for (_, res) in function_lifetime_rib.bindings.values() {\n-                candidates.remove(res);\n+                candidates.retain(|(r, _)| r != res);\n             }\n         }\n "}, {"sha": "d0a8fe795efd03549df1ec44ac889d45a8a0d506", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e9772042948002f9c6f60c4c81603170035fffa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9772042948002f9c6f60c4c81603170035fffa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=5e9772042948002f9c6f60c4c81603170035fffa", "patch": "@@ -42,4 +42,10 @@ fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n     panic!()\n }\n \n+fn l<'a>(_: &'a str, _: &'a str) -> &str { \"\" }\n+//~^ ERROR missing lifetime specifier\n+\n+// This is ok because both `'a` are for the same parameter.\n+fn m<'a>(_: &'a Foo<'a>) -> &str { \"\" }\n+\n fn main() {}"}, {"sha": "5eee953ef189fb190e180ace7867f0f44de4ca94", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-requires-explicit-lifetime.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e9772042948002f9c6f60c4c81603170035fffa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9772042948002f9c6f60c4c81603170035fffa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr?ref=5e9772042948002f9c6f60c4c81603170035fffa", "patch": "@@ -70,6 +70,18 @@ help: consider using the `'a` lifetime\n LL | fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &'a isize {\n    |                                                  ++\n \n-error: aborting due to 6 previous errors\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:45:37\n+   |\n+LL | fn l<'a>(_: &'a str, _: &'a str) -> &str { \"\" }\n+   |             -------     -------     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn l<'a>(_: &'a str, _: &'a str) -> &'a str { \"\" }\n+   |                                      ++\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}]}