{"sha": "7e42a780161e757ddd7d20925691a861f9d86725", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNDJhNzgwMTYxZTc1N2RkZDdkMjA5MjU2OTFhODYxZjlkODY3MjU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-28T23:38:26Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:36Z"}, "message": "Implement default method inheritance.\n\nThis commit leverages the specialization graph infrastructure to allow\nspecializing trait implementations to leave off methods for which their\nparents have provided defaults.\n\nIt does not yet check that the `default` keyword is appropriately used\nin such cases.", "tree": {"sha": "d7ab5d046937d831738e04c9c184671dbafb177e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7ab5d046937d831738e04c9c184671dbafb177e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e42a780161e757ddd7d20925691a861f9d86725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e42a780161e757ddd7d20925691a861f9d86725", "html_url": "https://github.com/rust-lang/rust/commit/7e42a780161e757ddd7d20925691a861f9d86725", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e42a780161e757ddd7d20925691a861f9d86725/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957ee5ce347999ef2c1acfdb63a76643c61f6516", "url": "https://api.github.com/repos/rust-lang/rust/commits/957ee5ce347999ef2c1acfdb63a76643c61f6516", "html_url": "https://github.com/rust-lang/rust/commit/957ee5ce347999ef2c1acfdb63a76643c61f6516"}], "stats": {"total": 434, "additions": 296, "deletions": 138}, "files": [{"sha": "33a1e3816e348ce204d563190bab20ffcf494c90", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -85,10 +85,7 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n         return None\n     }\n \n-    let substituted = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n-    let freshened = selcx.infcx().freshen(substituted);\n-\n-    Some(freshened)\n+    Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool"}, {"sha": "8d3403021e41577f9ab7bd7d5649d73b34a8f839", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -50,7 +50,7 @@ pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n-pub use self::specialize::{Overlap, SpecializationGraph, specializes};\n+pub use self::specialize::{Overlap, SpecializationGraph, get_impl_item_or_default, ItemSource, specializes};\n pub use self::util::elaborate_predicates;\n pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;"}, {"sha": "d319ac0219c75fa8bc5373ffc4acfffbaa4b11f3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -1629,7 +1629,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // i.e. EvaluatedToOk:\n                 if other.evaluation == EvaluatedToOk {\n                     if let ImplCandidate(victim_def) = victim.candidate {\n-                        return traits::specializes(self.infcx(), other_def, victim_def);\n+                        return traits::specializes(self.tcx(), other_def, victim_def);\n                     }\n                 }\n "}, {"sha": "b2339b3080c9aa4c15ef7e59666237766e0933df", "filename": "src/librustc/middle/traits/specialize.rs", "status": "modified", "additions": 221, "deletions": 33, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -23,7 +23,7 @@ use middle::infer::{self, InferCtxt, TypeOrigin};\n use middle::region;\n use middle::subst::{Subst, Substs};\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{self, ImplOrTraitItem};\n use syntax::codemap::DUMMY_SP;\n use util::nodemap::DefIdMap;\n \n@@ -51,6 +51,8 @@ pub struct SpecializationGraph {\n /// Information pertinent to an overlapping impl error.\n pub struct Overlap<'tcx> {\n     pub with_impl: DefId,\n+\n+    /// NB: this TraitRef can contain inference variables!\n     pub on_trait_ref: ty::TraitRef<'tcx>,\n }\n \n@@ -72,9 +74,7 @@ impl SpecializationGraph {\n                         -> Result<(), Overlap<'tcx>> {\n         assert!(impl_def_id.is_local());\n \n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n         let mut parent = trait_ref.def_id;\n-\n         let mut my_children = vec![];\n \n         // descend the existing tree, looking for the right location to add this impl\n@@ -84,13 +84,12 @@ impl SpecializationGraph {\n             for slot in possible_siblings.iter_mut() {\n                 let possible_sibling = *slot;\n \n-                let overlap = infcx.probe(|_| {\n-                    traits::overlapping_impls(&infcx, possible_sibling, impl_def_id)\n-                });\n+                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n \n                 if let Some(trait_ref) = overlap {\n-                    let le = specializes(&infcx, impl_def_id, possible_sibling);\n-                    let ge = specializes(&infcx, possible_sibling, impl_def_id);\n+                    let le = specializes(tcx, impl_def_id, possible_sibling);\n+                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n \n                     if le && !ge {\n                         // the impl specializes possible_sibling\n@@ -120,22 +119,184 @@ impl SpecializationGraph {\n         }\n \n         if self.children.insert(impl_def_id, my_children).is_some() {\n-            panic!(\"When inserting an impl into the specialization graph, existing children for \\\n-                    the impl were already present.\");\n+            tcx.sess\n+               .bug(\"When inserting an impl into the specialization graph, existing children for \\\n+                     the impl were already present.\");\n         }\n \n         Ok(())\n     }\n \n-    /// Insert cached metadata mapping from a child impl back to its parent\n+    /// Insert cached metadata mapping from a child impl back to its parent.\n     pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n-        if self.parent.insert(child, Some(parent)).is_some() {\n+        if self.parent.insert(child, parent).is_some() {\n             panic!(\"When recording an impl from the crate store, information about its parent \\\n                     was already present.\");\n         }\n \n         self.children.entry(parent).or_insert(vec![]).push(child);\n     }\n+\n+    /// The parent of a given impl, which is the def id of the trait when the\n+    /// impl is a \"specialization root\".\n+    pub fn parent(&self, child: DefId) -> DefId {\n+        *self.parent.get(&child).unwrap()\n+    }\n+}\n+\n+/// When we have selected one impl, but are actually using item definitions from\n+/// a parent impl providing a default, we need a way to translate between the\n+/// type parameters of the two impls. Here the `source_impl` is the one we've\n+/// selected, and `source_substs` is a substitution of its generics (and possibly\n+/// some relevant `FnSpace` variables as well). And `target_impl` is the impl\n+/// we're actually going to get the definition from.\n+fn translate_substs_between_impls<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        source_impl: DefId,\n+                                        source_substs: Substs<'tcx>,\n+                                        target_impl: DefId)\n+                                        -> Substs<'tcx> {\n+\n+    // We need to build a subst that covers all the generics of\n+    // `target_impl`. Start by introducing fresh infer variables:\n+    let target_generics = tcx.lookup_item_type(target_impl).generics;\n+    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut target_substs = infcx.fresh_substs_for_generics(DUMMY_SP, &target_generics);\n+    if source_substs.regions.is_erased() {\n+        target_substs = target_substs.erase_regions()\n+    }\n+\n+    if !fulfill_implication(&mut infcx,\n+                            source_impl,\n+                            source_substs.clone(),\n+                            target_impl,\n+                            target_substs.clone()) {\n+        tcx.sess\n+           .bug(\"When translating substitutions for specialization, the expected specializaiton \\\n+                 failed to hold\")\n+    }\n+\n+    // Now resolve the *substitution* we built for the target earlier, replacing\n+    // the inference variables inside with whatever we got from fulfillment. We\n+    // also carry along any FnSpace substitutions, which don't need to be\n+    // adjusted when mapping from one impl to another.\n+    infcx.resolve_type_vars_if_possible(&target_substs)\n+         .with_method_from_subst(&source_substs)\n+}\n+\n+/// When we've selected an impl but need to use an item definition provided by\n+/// the trait itself, we need to translate the substitution applied to the impl\n+/// to one that makes sense for the trait.\n+fn translate_substs_from_impl_to_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                             source_impl: DefId,\n+                                             source_substs: Substs<'tcx>)\n+                                             -> Substs<'tcx> {\n+\n+    let source_trait_ref = tcx.impl_trait_ref(source_impl).unwrap().subst(tcx, &source_substs);\n+\n+    let mut new_substs = source_trait_ref.substs.clone();\n+    if source_substs.regions.is_erased() {\n+        new_substs = new_substs.erase_regions()\n+    }\n+\n+    // Carry any FnSpace substitutions along; they don't need to be adjusted\n+    new_substs.with_method_from_subst(&source_substs)\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+/// When looking up an item in an impl, it may turn out that the item\n+/// is actually provided as a default by a more generic impl, or by\n+/// the trait itself. This enum says where the item came from.\n+pub enum ItemSource {\n+    Impl {\n+        requested_impl: DefId,\n+        actual_impl: DefId,\n+    },\n+    Trait {\n+        requested_impl: DefId,\n+    },\n+}\n+\n+impl ItemSource {\n+    pub fn is_from_trait(&self) -> bool {\n+        match *self {\n+            ItemSource::Trait { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Given a subst for the requested impl, translate it to a subst\n+    /// appropriate for the actual item definition (whether it be in that impl,\n+    /// a parent impl, or the trait).\n+    pub fn translate_substs<'tcx>(&self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  requested_impl_substs: Substs<'tcx>)\n+                                  -> Substs<'tcx> {\n+        match *self {\n+            ItemSource::Impl { requested_impl, actual_impl } => {\n+                // no need to translate if we're targetting the impl we started with\n+                if requested_impl == actual_impl {\n+                    return requested_impl_substs;\n+                }\n+\n+                translate_substs_between_impls(tcx,\n+                                               requested_impl,\n+                                               requested_impl_substs,\n+                                               actual_impl)\n+\n+            }\n+            ItemSource::Trait { requested_impl } => {\n+                translate_substs_from_impl_to_trait(tcx, requested_impl, requested_impl_substs)\n+            }\n+        }\n+    }\n+}\n+\n+/// Lookup the definition of an item within `requested_impl` or its specialization\n+/// parents, including provided items from the trait itself.\n+///\n+/// The closure `f` works in the style of `filter_map`.\n+pub fn get_impl_item_or_default<'tcx, I, F>(tcx: &ty::ctxt<'tcx>,\n+                                            requested_impl: DefId,\n+                                            mut f: F)\n+                                            -> Option<(I, ItemSource)>\n+    where F: for<'a> FnMut(&ImplOrTraitItem<'tcx>) -> Option<I>\n+{\n+    let impl_or_trait_items_map = tcx.impl_or_trait_items.borrow();\n+    let trait_def_id = tcx.trait_id_of_impl(requested_impl).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    // Walk up the specialization tree, looking for a matching item definition\n+\n+    let mut current_impl = requested_impl;\n+    loop {\n+        for impl_item_id in &tcx.impl_items.borrow()[&current_impl] {\n+            let impl_item = &impl_or_trait_items_map[&impl_item_id.def_id()];\n+            if let Some(t) = f(impl_item) {\n+                let source = ItemSource::Impl {\n+                    requested_impl: requested_impl,\n+                    actual_impl: current_impl,\n+                };\n+                return Some((t, source));\n+            }\n+        }\n+\n+        if let Some(parent) = trait_def.parent_of_impl(current_impl) {\n+            current_impl = parent;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // The item isn't defined anywhere in the hierarchy. Get the\n+    // default from the trait.\n+\n+    for trait_item in tcx.trait_items(trait_def_id).iter() {\n+        if let Some(t) = f(trait_item) {\n+            return Some((t, ItemSource::Trait { requested_impl: requested_impl }));\n+        }\n+    }\n+\n+    None\n }\n \n fn skolemizing_subst_for_impl<'a>(tcx: &ty::ctxt<'a>, impl_def_id: DefId) -> Substs<'a> {\n@@ -155,30 +316,57 @@ fn skolemizing_subst_for_impl<'a>(tcx: &ty::ctxt<'a>, impl_def_id: DefId) -> Sub\n /// Specialization is determined by the sets of types to which the impls apply;\n /// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n /// to.\n-pub fn specializes(infcx: &InferCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n-    let tcx = &infcx.tcx;\n-\n+pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n     // We determine whether there's a subset relationship by:\n     //\n     // - skolemizing impl1,\n+    // - instantiating impl2 with fresh inference variables,\n     // - assuming the where clauses for impl1,\n     // - unifying,\n     // - attempting to prove the where clauses for impl2\n     //\n+    // The last three steps are essentially checking for an implication between two impls\n+    // after appropriate substitutions. This is what `fulfill_implication` checks for.\n+    //\n     // See RFC 1210 for more details and justification.\n \n+    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+\n     let impl1_substs = skolemizing_subst_for_impl(tcx, impl1_def_id);\n+    let impl2_substs = util::fresh_type_vars_for_impl(&infcx, DUMMY_SP, impl2_def_id);\n+\n+    fulfill_implication(&mut infcx,\n+                        impl1_def_id,\n+                        impl1_substs,\n+                        impl2_def_id,\n+                        impl2_substs)\n+}\n+\n+/// Does impl1 (instantiated with the impl1_substs) imply impl2\n+/// (instantiated with impl2_substs)?\n+///\n+/// Mutates the `infcx` in two ways:\n+/// - by adding the obligations of impl1 to the parameter environment\n+/// - via fulfillment, so that if the implication holds the various unifications\n+fn fulfill_implication<'a, 'tcx>(infcx: &mut InferCtxt<'a, 'tcx>,\n+                                 impl1_def_id: DefId,\n+                                 impl1_substs: Substs<'tcx>,\n+                                 impl2_def_id: DefId,\n+                                 impl2_substs: Substs<'tcx>)\n+                                 -> bool {\n+    let tcx = &infcx.tcx;\n+\n     let (impl1_trait_ref, impl1_obligations) = {\n         let selcx = &mut SelectionContext::new(&infcx);\n         util::impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n     };\n \n     let impl1_predicates: Vec<_> = impl1_obligations.iter()\n-        .cloned()\n-        .map(|oblig| oblig.predicate)\n-        .collect();\n+                                                    .cloned()\n+                                                    .map(|oblig| oblig.predicate)\n+                                                    .collect();\n \n-    let penv = ty::ParameterEnvironment {\n+    infcx.parameter_environment = ty::ParameterEnvironment {\n         tcx: tcx,\n         free_substs: impl1_substs,\n         implicit_region_bound: ty::ReEmpty, // FIXME: is this OK?\n@@ -188,21 +376,18 @@ pub fn specializes(infcx: &InferCtxt, impl1_def_id: DefId, impl2_def_id: DefId)\n         free_id_outlive: region::DUMMY_CODE_EXTENT, // FIXME: is this OK?\n     };\n \n-    // FIXME: unclear what `errors_will_be_reported` should be here...\n-    let infcx = infer::new_infer_ctxt(tcx, infcx.tables, Some(penv), true);\n     let selcx = &mut SelectionContext::new(&infcx);\n-\n-    let impl2_substs = util::fresh_type_vars_for_impl(&infcx, DUMMY_SP, impl2_def_id);\n-    let (impl2_trait_ref, impl2_obligations) =\n-        util::impl_trait_ref_and_oblig(selcx, impl2_def_id, &impl2_substs);\n+    let (impl2_trait_ref, impl2_obligations) = util::impl_trait_ref_and_oblig(selcx,\n+                                                                              impl2_def_id,\n+                                                                              &impl2_substs);\n \n     // do the impls unify? If not, no specialization.\n     if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n                                             true,\n                                             TypeOrigin::Misc(DUMMY_SP),\n                                             impl1_trait_ref,\n                                             impl2_trait_ref) {\n-        debug!(\"specializes: {:?} does not unify with {:?}\",\n+        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n                impl1_trait_ref,\n                impl2_trait_ref);\n         return false;\n@@ -212,21 +397,24 @@ pub fn specializes(infcx: &InferCtxt, impl1_def_id: DefId, impl2_def_id: DefId)\n \n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n+\n     for oblig in impl2_obligations.into_iter() {\n         fulfill_cx.register_predicate_obligation(&infcx, oblig);\n     }\n \n     if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n-        debug!(\"specializes: for impls on {:?} and {:?}, could not fulfill: {:?} given {:?}\",\n+        // no dice!\n+        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                {:?}\",\n                impl1_trait_ref,\n                impl2_trait_ref,\n                errors,\n                infcx.parameter_environment.caller_bounds);\n-        return false;\n+        false\n+    } else {\n+        debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n+               impl1_trait_ref,\n+               impl2_trait_ref);\n+        true\n     }\n-\n-    debug!(\"specializes: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n-           impl1_trait_ref,\n-           impl2_trait_ref);\n-    true\n }"}, {"sha": "7fa20f2135ae1d56f790f62b1fe6c7b29f9f513c", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -2719,28 +2719,4 @@ impl<'tcx> TyCtxt<'tcx> {\n             Some(d) => f(&d[..])\n         }\n     }\n-\n-    pub fn make_substs_for_receiver_types(&self,\n-                                          trait_ref: &ty::TraitRef<'tcx>,\n-                                          method: &ty::Method<'tcx>)\n-                                          -> subst::Substs<'tcx>\n-    {\n-        /*!\n-         * Substitutes the values for the receiver's type parameters\n-         * that are found in method, leaving the method's type parameters\n-         * intact.\n-         */\n-\n-        let meth_tps: Vec<Ty> =\n-            method.generics.types.get_slice(subst::FnSpace)\n-                  .iter()\n-                  .map(|def| self.mk_param_from_def(def))\n-                  .collect();\n-        let meth_regions: Vec<ty::Region> =\n-            method.generics.regions.get_slice(subst::FnSpace)\n-                  .iter()\n-                  .map(|def| def.to_early_bound_region())\n-                  .collect();\n-        trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n-    }\n }"}, {"sha": "582b289455196fc545c3d62ca0c3eef0eb79f7dc", "filename": "src/librustc/middle/ty/trait_def.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -190,8 +190,14 @@ impl<'tcx> TraitDef<'tcx> {\n             .insert(tcx, impl_def_id, impl_trait_ref)\n     }\n \n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n-        self.read_trait_impls(tcx);\n+    /// Returns the immediately less specialized impl, if any.\n+    pub fn parent_of_impl(&self, impl_def_id: DefId) -> Option<DefId> {\n+        let parent = self.specialization_graph.borrow().parent(impl_def_id);\n+        if parent == self.trait_ref.def_id { None } else { Some(parent) }\n+    }\n+\n+        pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n+            self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {"}, {"sha": "db28963d2c0c6f03c1595e58c114d0f774ffb643", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -14,7 +14,7 @@ use back::svh::Svh;\n use middle::const_eval::{self, ConstVal, ErrKind};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def_id::DefId;\n-use middle::subst::{self, Subst, Substs};\n+use middle::subst;\n use middle::infer;\n use middle::pat_util;\n use middle::traits;\n@@ -26,7 +26,6 @@ use rustc_const_eval::{ConstInt, ConstIsize, ConstUsize};\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n-use std::rc::Rc;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n@@ -536,58 +535,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct ImplMethod<'tcx> {\n-    pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub is_provided: bool\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn get_impl_method(&self,\n-                           impl_def_id: DefId,\n-                           substs: &'tcx Substs<'tcx>,\n-                           name: Name)\n-                           -> ImplMethod<'tcx>\n-    {\n-        // there don't seem to be nicer accessors to these:\n-        let impl_or_trait_items_map = self.impl_or_trait_items.borrow();\n-\n-        for impl_item in &self.impl_items.borrow()[&impl_def_id] {\n-            if let ty::MethodTraitItem(ref meth) =\n-                impl_or_trait_items_map[&impl_item.def_id()] {\n-                if meth.name == name {\n-                    return ImplMethod {\n-                        method: meth.clone(),\n-                        substs: substs,\n-                        is_provided: false\n-                    }\n-                }\n-            }\n-        }\n-\n-        // It is not in the impl - get the default from the trait.\n-        let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n-        for trait_item in self.trait_items(trait_ref.def_id).iter() {\n-            if let &ty::MethodTraitItem(ref meth) = trait_item {\n-                if meth.name == name {\n-                    let impl_to_trait_substs = self\n-                        .make_substs_for_receiver_types(&trait_ref, meth);\n-                    let substs = impl_to_trait_substs.subst(self, substs);\n-                    return ImplMethod {\n-                        method: meth.clone(),\n-                        substs: self.mk_substs(substs),\n-                        is_provided: true\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.sess.bug(&format!(\"method {:?} not found in {:?}\",\n-                               name, impl_def_id))\n-    }\n-}\n-\n impl<'tcx> ty::TyS<'tcx> {\n     fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n                        bound: ty::BuiltinBound,"}, {"sha": "073ef9797ed2a46d068c7c68eb4b1a6780714016", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rc::Rc;\n+\n use arena::TypedArena;\n use back::link;\n use llvm::{ValueRef, get_params};\n@@ -33,7 +35,7 @@ use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty, TyCtxt};\n \n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n \n@@ -107,7 +109,7 @@ pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // those from the impl and those from the method:\n             let impl_substs = vtable_impl.substs.with_method_from(&substs);\n             let substs = ccx.tcx().mk_substs(impl_substs);\n-            let mth = ccx.tcx().get_impl_method(impl_did, substs, mname);\n+            let mth = get_impl_method(ccx.tcx(), impl_did, impl_substs, mname);\n \n             // Translate the function, bypassing Callee::def.\n             // That is because default methods have the same ID as the\n@@ -428,7 +430,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = tcx.get_impl_method(impl_id, substs, name);\n+            let mth = get_impl_method(tcx, impl_id, substs.clone(), name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -466,3 +468,38 @@ fn opaque_method_ty<'tcx>(tcx: &TyCtxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n         }),\n     })\n }\n+\n+#[derive(Debug)]\n+pub struct ImplMethod<'tcx> {\n+    pub method: Rc<ty::Method<'tcx>>,\n+    pub substs: Substs<'tcx>,\n+    pub is_provided: bool\n+}\n+\n+/// Locates the applicable definition of a method, given its name.\n+pub fn get_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             impl_def_id: DefId,\n+                             substs: Substs<'tcx>,\n+                             name: Name)\n+                             -> ImplMethod<'tcx>\n+{\n+    assert!(!substs.types.needs_infer());\n+\n+    traits::get_impl_item_or_default(tcx, impl_def_id, |cand| {\n+        if let &ty::MethodTraitItem(ref meth) = cand {\n+            if meth.name == name {\n+                return Some(meth.clone())\n+            }\n+        }\n+        None\n+    }).map(|(meth, source)| {\n+        ImplMethod {\n+            method: meth,\n+            substs: source.translate_substs(tcx, substs),\n+            is_provided: source.is_from_trait(),\n+        }\n+    }).unwrap_or_else(|| {\n+        tcx.sess.bug(&format!(\"method {:?} not found in {:?}\",\n+                              name, impl_def_id))\n+    })\n+}"}, {"sha": "136e8c6569b769204c5dea2add7eca088741bded", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e42a780161e757ddd7d20925691a861f9d86725/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7e42a780161e757ddd7d20925691a861f9d86725", "patch": "@@ -672,10 +672,12 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          match ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(it.id)) {\n+          let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n+          match ccx.tcx.impl_trait_ref(impl_def_id) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n+                                               impl_def_id,\n                                                &impl_trait_ref,\n                                                impl_items);\n               }\n@@ -864,6 +866,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n+                                            impl_id: DefId,\n                                             impl_trait_ref: &ty::TraitRef<'tcx>,\n                                             impl_items: &[hir::ImplItem]) {\n     // Locate trait methods\n@@ -973,23 +976,27 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 }\n             }\n             ty::MethodTraitItem(ref trait_method) => {\n-                let is_implemented =\n-                    impl_items.iter().any(|ii| {\n-                        match ii.node {\n-                            hir::ImplItemKind::Method(..) => {\n-                                ii.name == trait_method.name\n-                            }\n-                            _ => false,\n+                let search_result = traits::get_impl_item_or_default(tcx, impl_id, |cand| {\n+                    if let &ty::MethodTraitItem(ref meth) = cand {\n+                        if meth.name == trait_method.name {\n+                            return Some(());\n                         }\n-                    });\n-                let is_provided =\n-                    provided_methods.iter().any(|m| m.name == trait_method.name);\n-                if !is_implemented {\n-                    if !is_provided {\n-                        missing_items.push(trait_method.name);\n-                    } else if associated_type_overridden {\n-                        invalidated_items.push(trait_method.name);\n                     }\n+                    None\n+                });\n+\n+                if let Some((_, source)) = search_result {\n+                    if source.is_from_trait() {\n+                        let is_provided =\n+                            provided_methods.iter().any(|m| m.name == trait_method.name);\n+                        if !is_provided {\n+                            missing_items.push(trait_method.name);\n+                        } else if associated_type_overridden {\n+                            invalidated_items.push(trait_method.name);\n+                        }\n+                    }\n+                } else {\n+                    missing_items.push(trait_method.name);\n                 }\n             }\n             ty::TypeTraitItem(ref associated_type) => {"}]}