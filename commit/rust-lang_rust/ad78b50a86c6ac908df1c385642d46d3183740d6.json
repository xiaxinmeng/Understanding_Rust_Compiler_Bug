{"sha": "ad78b50a86c6ac908df1c385642d46d3183740d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNzhiNTBhODZjNmFjOTA4ZGYxYzM4NTY0MmQ0NmQzMTgzNzQwZDY=", "commit": {"author": {"name": "Tor Hovland", "email": "tor.hovland@bekk.no", "date": "2021-04-24T11:57:41Z"}, "committer": {"name": "Tor Hovland", "email": "tor.hovland@bekk.no", "date": "2021-04-24T11:57:41Z"}, "message": "Implemented suggestion.", "tree": {"sha": "1a9c9f87008cd33ca1b1e5066a19d3436931c934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a9c9f87008cd33ca1b1e5066a19d3436931c934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad78b50a86c6ac908df1c385642d46d3183740d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad78b50a86c6ac908df1c385642d46d3183740d6", "html_url": "https://github.com/rust-lang/rust/commit/ad78b50a86c6ac908df1c385642d46d3183740d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad78b50a86c6ac908df1c385642d46d3183740d6/comments", "author": null, "committer": null, "parents": [{"sha": "484c61943f818272719bac81f6d5709fc5456438", "url": "https://api.github.com/repos/rust-lang/rust/commits/484c61943f818272719bac81f6d5709fc5456438", "html_url": "https://github.com/rust-lang/rust/commit/484c61943f818272719bac81f6d5709fc5456438"}], "stats": {"total": 82, "additions": 77, "deletions": 5}, "files": [{"sha": "236fec94bdba79fc0e28bd9d3adc9fcade141fb0", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad78b50a86c6ac908df1c385642d46d3183740d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad78b50a86c6ac908df1c385642d46d3183740d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=ad78b50a86c6ac908df1c385642d46d3183740d6", "patch": "@@ -1494,7 +1494,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         if let (Some((expr, _)), Some((fn_decl, _, _))) =\n             (expression, fcx.get_node_fn_decl(parent_item))\n         {\n-            fcx.suggest_missing_return_expr(&mut err, expr, fn_decl, expected, found, parent_id);\n+            fcx.suggest_missing_break_or_return_expr(\n+                &mut err, expr, fn_decl, expected, found, id, parent_id,\n+            );\n         }\n \n         if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.get(), fn_output) {"}, {"sha": "c3417247725feb608ed8f1cab3e178e8fc080c59", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ad78b50a86c6ac908df1c385642d46d3183740d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad78b50a86c6ac908df1c385642d46d3183740d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=ad78b50a86c6ac908df1c385642d46d3183740d6", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ExprKind, ItemKind, Node};\n+use rustc_hir::{ExprKind, ItemKind, Node, StmtKind};\n use rustc_infer::infer;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, Ty};\n@@ -55,7 +55,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             pointing_at_return_type =\n                 self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n             let fn_id = self.tcx.hir().get_return_block(blk_id).unwrap();\n-            self.suggest_missing_return_expr(err, expr, &fn_decl, expected, found, fn_id);\n+            self.suggest_missing_break_or_return_expr(\n+                err, expr, &fn_decl, expected, found, blk_id, fn_id,\n+            );\n         }\n         pointing_at_return_type\n     }\n@@ -472,22 +474,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(in super::super) fn suggest_missing_return_expr(\n+    pub(in super::super) fn suggest_missing_break_or_return_expr(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &'tcx hir::Expr<'tcx>,\n         fn_decl: &hir::FnDecl<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         id: hir::HirId,\n+        fn_id: hir::HirId,\n     ) {\n         if !expected.is_unit() {\n             return;\n         }\n         let found = self.resolve_vars_with_obligations(found);\n+\n+        if self.in_loop(id) {\n+            if self.in_local_statement(id) {\n+                err.multipart_suggestion(\n+                    \"you might have meant to break the loop with this value\",\n+                    vec![\n+                        (expr.span.shrink_to_lo(), \"break \".to_string()),\n+                        (expr.span.shrink_to_hi(), \";\".to_string()),\n+                    ],\n+                    Applicability::MaybeIncorrect,\n+                );\n+                return;\n+            }\n+        }\n+\n         if let hir::FnRetTy::Return(ty) = fn_decl.output {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n-            let bound_vars = self.tcx.late_bound_vars(id);\n+            let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             if self.can_coerce(found, ty) {\n@@ -514,4 +532,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.sess.parse_sess.expr_parentheses_needed(err, *sp, None);\n         }\n     }\n+\n+    fn in_loop(&self, id: hir::HirId) -> bool {\n+        if self.is_loop(id) {\n+            return true;\n+        }\n+\n+        for (parent_id, _) in self.tcx.hir().parent_iter(id) {\n+            if self.is_loop(parent_id) {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn is_loop(&self, id: hir::HirId) -> bool {\n+        let node = self.tcx.hir().get(id);\n+\n+        if let Node::Expr(expr) = node {\n+            if let ExprKind::Loop(..) = expr.kind {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn in_local_statement(&self, id: hir::HirId) -> bool {\n+        if self.is_local_statement(id) {\n+            return true;\n+        }\n+\n+        for (parent_id, _) in self.tcx.hir().parent_iter(id) {\n+            if self.is_local_statement(parent_id) {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn is_local_statement(&self, id: hir::HirId) -> bool {\n+        let node = self.tcx.hir().get(id);\n+\n+        if let Node::Stmt(stmt) = node {\n+            if let StmtKind::Local(..) = stmt.kind {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n }"}]}