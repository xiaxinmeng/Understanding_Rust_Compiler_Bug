{"sha": "8b04b098695951f561ef4eedf33c6fbc63728caa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMDRiMDk4Njk1OTUxZjU2MWVmNGVlZGYzM2M2ZmJjNjM3MjhjYWE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-15T13:43:58Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:32Z"}, "message": "Move alignment checks out of `Allocation`", "tree": {"sha": "152c0e41efe0fa16773a6d7795e8db637e0594db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/152c0e41efe0fa16773a6d7795e8db637e0594db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b04b098695951f561ef4eedf33c6fbc63728caa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b04b098695951f561ef4eedf33c6fbc63728caa", "html_url": "https://github.com/rust-lang/rust/commit/8b04b098695951f561ef4eedf33c6fbc63728caa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b04b098695951f561ef4eedf33c6fbc63728caa/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c08ced99589114164f057bc4cd020a6bad48af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c08ced99589114164f057bc4cd020a6bad48af9", "html_url": "https://github.com/rust-lang/rust/commit/1c08ced99589114164f057bc4cd020a6bad48af9"}], "stats": {"total": 128, "additions": 43, "deletions": 85}, "files": [{"sha": "b2c4454880575264efcf8a924090c1dc885bf334", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 57, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=8b04b098695951f561ef4eedf33c6fbc63728caa", "patch": "@@ -15,7 +15,7 @@ use super::{\n     truncate,\n };\n \n-use ty::layout::{self, Size, Align};\n+use ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n use mir;\n@@ -103,10 +103,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        align: Align,\n         check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]> {\n-        self.check_align(ptr.into(), align)?;\n         self.check_bounds(cx, ptr, size)?;\n \n         if check_defined_and_ptr {\n@@ -126,14 +124,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     #[inline]\n-    fn get_bytes(\n+    pub fn get_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        align: Align\n     ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(cx, ptr, size, align, true)\n+        self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n@@ -144,9 +141,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        align: Align\n     ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(cx, ptr, size, align, false)\n+        self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n@@ -156,10 +152,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_align(ptr.into(), align)?;\n         self.check_bounds(cx, ptr, size)?;\n \n         self.mark_definedness(ptr, size, true)?;\n@@ -201,9 +195,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n         allow_ptr_and_undef: bool,\n     ) -> EvalResult<'tcx> {\n-        let align = Align::from_bytes(1).unwrap();\n         // Check bounds, align and relocations on the edges\n-        self.get_bytes_with_undef_and_ptr(cx, ptr, size, align)?;\n+        self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Check undef and ptr\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n@@ -212,26 +205,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    pub fn read_bytes(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        let align = Align::from_bytes(1).unwrap();\n-        self.get_bytes(cx, ptr, size, align)\n-    }\n-\n     pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         src: &[u8],\n     ) -> EvalResult<'tcx> {\n-        let align = Align::from_bytes(1).unwrap();\n-        let bytes = self.get_bytes_mut(\n-            cx, ptr, Size::from_bytes(src.len() as u64), align,\n-        )?;\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n@@ -243,8 +223,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         val: u8,\n         count: Size\n     ) -> EvalResult<'tcx> {\n-        let align = Align::from_bytes(1).unwrap();\n-        let bytes = self.get_bytes_mut(cx, ptr, count, align)?;\n+        let bytes = self.get_bytes_mut(cx, ptr, count)?;\n         for b in bytes {\n             *b = val;\n         }\n@@ -256,13 +235,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        ptr_align: Align,\n         size: Size\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n-        // get_bytes_unchecked tests alignment and relocation edges\n-        let bytes = self.get_bytes_with_undef_and_ptr(\n-            cx, ptr, size, ptr_align.min(int_align(cx, size))\n-        )?;\n+        // get_bytes_unchecked tests relocation edges\n+        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n@@ -293,17 +269,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        ptr_align: Align\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n-        self.read_scalar(cx, ptr, ptr_align, cx.data_layout().pointer_size)\n+        self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n     /// Write a *non-ZST* scalar\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        ptr_align: Align,\n         val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n     ) -> EvalResult<'tcx> {\n@@ -327,9 +301,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         };\n \n         {\n-            // get_bytes_mut checks alignment\n             let endian = cx.data_layout().endian;\n-            let dst = self.get_bytes_mut(cx, ptr, type_size, ptr_align)?;\n+            let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n             write_target_uint(endian, dst, bytes).unwrap();\n         }\n \n@@ -351,31 +324,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        ptr_align: Align,\n         val: ScalarMaybeUndef<Tag>\n     ) -> EvalResult<'tcx> {\n         let ptr_size = cx.data_layout().pointer_size;\n-        self.write_scalar(cx, ptr.into(), ptr_align, val, ptr_size)\n+        self.write_scalar(cx, ptr.into(), val, ptr_size)\n     }\n }\n \n-fn int_align(\n-    cx: &impl HasDataLayout,\n-    size: Size,\n-) -> Align {\n-    // We assume pointer-sized integers have the same alignment as pointers.\n-    // We also assume signed and unsigned integers of the same size have the same alignment.\n-    let ity = match size.bytes() {\n-        1 => layout::I8,\n-        2 => layout::I16,\n-        4 => layout::I32,\n-        8 => layout::I64,\n-        16 => layout::I128,\n-        _ => bug!(\"bad integer size: {}\", size.bytes()),\n-    };\n-    ity.align(cx).abi\n-}\n-\n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Return all relocations overlapping with the given ptr-offset pair."}, {"sha": "2e47d7e69d9a528bffa2a8668575b4a71b8959f7", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8b04b098695951f561ef4eedf33c6fbc63728caa", "patch": "@@ -578,7 +578,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Ok(&[])\n         } else {\n             let ptr = ptr.to_ptr()?;\n-            self.get(ptr.alloc_id)?.read_bytes(self, ptr, size)\n+            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n         }\n     }\n }\n@@ -656,10 +656,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         length: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n+        self.check_align(src, src_align)?;\n+        self.check_align(dest, dest_align)?;\n         if size.bytes() == 0 {\n             // Nothing to do for ZST, other than checking alignment and non-NULLness.\n-            self.check_align(src, src_align)?;\n-            self.check_align(dest, dest_align)?;\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -689,12 +689,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         let tcx = self.tcx.tcx;\n \n-        // This also checks alignment, and relocation edges on the src.\n+        // This checks relocation edges on the src.\n         let src_bytes = self.get(src.alloc_id)?\n-            .get_bytes_with_undef_and_ptr(&tcx, src, size, src_align)?\n+            .get_bytes_with_undef_and_ptr(&tcx, src, size)?\n             .as_ptr();\n         let dest_bytes = self.get_mut(dest.alloc_id)?\n-            .get_bytes_mut(&tcx, dest, size * length, dest_align)?\n+            .get_bytes_mut(&tcx, dest, size * length)?\n             .as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes"}, {"sha": "ba995afddc813e42f6c09bd2444ce386a065a9d3", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8b04b098695951f561ef4eedf33c6fbc63728caa", "patch": "@@ -275,12 +275,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             return Ok(Some(Immediate::Scalar(Scalar::zst().into())));\n         }\n \n+        // check for integer pointers before alignment to report better errors\n         let ptr = ptr.to_ptr()?;\n+        self.memory.check_align(ptr.into(), ptr_align)?;\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory\n                     .get(ptr.alloc_id)?\n-                    .read_scalar(self, ptr, ptr_align, mplace.layout.size)?;\n+                    .read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(Immediate::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n@@ -289,13 +291,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let a_ptr = ptr;\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n-                let b_ptr = ptr.offset(b_offset, self)?.into();\n+                let b_ptr = ptr.offset(b_offset, self)?;\n                 let a_val = self.memory\n                     .get(ptr.alloc_id)?\n-                    .read_scalar(self, a_ptr, ptr_align, a_size)?;\n+                    .read_scalar(self, a_ptr, a_size)?;\n+                self.memory.check_align(b_ptr.into(), b.align(self))?;\n                 let b_val = self.memory\n                     .get(ptr.alloc_id)?\n-                    .read_scalar(self, b_ptr, ptr_align, b_size)?;\n+                    .read_scalar(self, b_ptr, b_size)?;\n                 Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),"}, {"sha": "6317cfb94d27fc107e549544e4fa7f142864c7c6", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8b04b098695951f561ef4eedf33c6fbc63728caa", "patch": "@@ -713,11 +713,12 @@ where\n \n         // Nothing to do for ZSTs, other than checking alignment\n         if dest.layout.is_zst() {\n-            self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(());\n+            return self.memory.check_align(ptr, ptr_align);\n         }\n \n+        // check for integer pointers before alignment to report better errors\n         let ptr = ptr.to_ptr()?;\n+        self.memory.check_align(ptr.into(), ptr_align)?;\n         let tcx = &*self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n@@ -729,9 +730,8 @@ where\n                     _ => bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                             dest.layout)\n                 }\n-\n                 self.memory.get_mut(ptr.alloc_id)?.write_scalar(\n-                    tcx, ptr, ptr_align.min(dest.layout.align.abi), scalar, dest.layout.size\n+                    tcx, ptr, scalar, dest.layout.size\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n@@ -741,20 +741,22 @@ where\n                               dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n-                let (a_align, b_align) = (a.align(self).abi, b.align(self).abi);\n+                let b_align = b.align(self).abi;\n                 let b_offset = a_size.align_to(b_align);\n                 let b_ptr = ptr.offset(b_offset, self)?;\n \n+                self.memory.check_align(b_ptr.into(), ptr_align.min(b_align))?;\n+\n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n                 self.memory\n                     .get_mut(ptr.alloc_id)?\n-                    .write_scalar(tcx, ptr, ptr_align.min(a_align), a_val, a_size)?;\n+                    .write_scalar(tcx, ptr, a_val, a_size)?;\n                 self.memory\n                     .get_mut(b_ptr.alloc_id)?\n-                    .write_scalar(tcx, b_ptr, ptr_align.min(b_align), b_val, b_size)\n+                    .write_scalar(tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }"}, {"sha": "617d204fe1042a8ea59a1c9ddfa38b1532150aa4", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=8b04b098695951f561ef4eedf33c6fbc63728caa", "patch": "@@ -401,13 +401,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.pointer_size();\n-                let ptr_align = self.tcx.data_layout.pointer_align.abi;\n                 let ptr = self.deref_operand(args[0])?;\n                 let vtable = ptr.vtable()?;\n+                self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n                 let fn_ptr = self.memory.get(vtable.alloc_id)?.read_ptr_sized(\n                     self,\n                     vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n-                    ptr_align\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n "}, {"sha": "37979c8ee664c28c1d95d8656ac955b26df2fede", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04b098695951f561ef4eedf33c6fbc63728caa/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=8b04b098695951f561ef4eedf33c6fbc63728caa", "patch": "@@ -61,16 +61,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n         self.memory\n             .get_mut(vtable.alloc_id)?\n-            .write_ptr_sized(tcx, vtable, ptr_align, Scalar::Ptr(drop).into())?;\n+            .write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, self)?;\n         self.memory\n             .get_mut(size_ptr.alloc_id)?\n-            .write_ptr_sized(tcx, size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n+            .write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, self)?;\n         self.memory\n             .get_mut(align_ptr.alloc_id)?\n-            .write_ptr_sized(tcx, align_ptr, ptr_align, Scalar::from_uint(align, ptr_size).into())?;\n+            .write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n@@ -79,7 +79,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory\n                     .get_mut(method_ptr.alloc_id)?\n-                    .write_ptr_sized(tcx, method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n+                    .write_ptr_sized(tcx, method_ptr, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n \n@@ -95,10 +95,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n-        let pointer_align = self.tcx.data_layout.pointer_align.abi;\n+        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n         let drop_fn = self.memory\n             .get(vtable.alloc_id)?\n-            .read_ptr_sized(self, vtable, pointer_align)?\n+            .read_ptr_sized(self, vtable)?\n             .to_ptr()?;\n         let drop_instance = self.memory.get_fn(drop_fn)?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n@@ -114,14 +114,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n-        let pointer_align = self.tcx.data_layout.pointer_align.abi;\n+        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n         let alloc = self.memory.get(vtable.alloc_id)?;\n-        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?, pointer_align)?\n+        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?\n             .to_bits(pointer_size)? as u64;\n         let align = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size * 2, self)?,\n-            pointer_align\n         )?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align).unwrap()))\n     }"}]}