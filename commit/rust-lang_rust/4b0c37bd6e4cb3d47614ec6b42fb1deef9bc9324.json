{"sha": "4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMGMzN2JkNmU0Y2IzZDQ3NjE0ZWM2YjQyZmIxZGVlZjliYzkzMjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-06-25T12:37:07Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-06-25T12:37:07Z"}, "message": "Merge #1439\n\n1439: Rich mapping of cargo watch output r=matklad a=etaoins\n\nCurrently we depend on the ASCII rendering string that `rustc` provides to populate Visual Studio Code's diagnostic. This has a number of shortcomings:\r\n\r\n1. It's not a very good use of space in the error list\r\n2. We can't jump to secondary spans (e.g. where a called function is defined)\r\n3. We can't use Code Actions aka Quick Fix\r\n\r\nThis moves all of the low-level parsing and mapping to a `rust_diagnostics.ts`. This uses some heuristics to map Rust diagnostics to VsCode:\r\n\r\n1. As before, the Rust diagnostic message and primary span is used for the root diagnostic. However, we now just use the message instead of the rendered version.\r\n\r\n2. Every secondary span is converted to \"related information\". This  shows as child in the error list and can be jumped to.\r\n\r\n3. Every child diagnostic is categorised in to three buckets:\r\n    1. If they have no span they're treated as another line of the root messages\r\n    2. If they have replacement text they're treated as a Code Action\r\n    3. If they have a span but no replacement text they're treated as related information (same as secondary spans).\n\nCo-authored-by: Ryan Cumming <etaoins@gmail.com>", "tree": {"sha": "31ac3e97ade900dd51bc39c007316aa20a2e85fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31ac3e97ade900dd51bc39c007316aa20a2e85fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324", "html_url": "https://github.com/rust-lang/rust/commit/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ba97a5fbd2e14f38c633948f0d1551d0cf086ca3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba97a5fbd2e14f38c633948f0d1551d0cf086ca3", "html_url": "https://github.com/rust-lang/rust/commit/ba97a5fbd2e14f38c633948f0d1551d0cf086ca3"}, {"sha": "5c6ab1145319414e897a8eaca2bf1ad5558ccf24", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6ab1145319414e897a8eaca2bf1ad5558ccf24", "html_url": "https://github.com/rust-lang/rust/commit/5c6ab1145319414e897a8eaca2bf1ad5558ccf24"}], "stats": {"total": 412, "additions": 358, "deletions": 54}, "files": [{"sha": "126a8b1b3b8aa8c96b8ecdab33e28c26ad6f3b4c", "filename": "editors/code/src/commands/cargo_watch.ts", "status": "modified", "additions": 132, "deletions": 54, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts?ref=4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324", "patch": "@@ -4,6 +4,10 @@ import * as path from 'path';\n import * as vscode from 'vscode';\n import { Server } from '../server';\n import { terminate } from '../utils/processes';\n+import {\n+    mapRustDiagnosticToVsCode,\n+    RustDiagnostic\n+} from '../utils/rust_diagnostics';\n import { LineBuffer } from './line_buffer';\n import { StatusDisplay } from './watch_status';\n \n@@ -33,10 +37,17 @@ export function registerCargoWatchProvider(\n     return provider;\n }\n \n-export class CargoWatchProvider implements vscode.Disposable {\n+export class CargoWatchProvider\n+    implements vscode.Disposable, vscode.CodeActionProvider {\n     private readonly diagnosticCollection: vscode.DiagnosticCollection;\n     private readonly statusDisplay: StatusDisplay;\n     private readonly outputChannel: vscode.OutputChannel;\n+\n+    private codeActions: {\n+        [fileUri: string]: vscode.CodeAction[];\n+    };\n+    private readonly codeActionDispose: vscode.Disposable;\n+\n     private cargoProcess?: child_process.ChildProcess;\n \n     constructor() {\n@@ -49,6 +60,16 @@ export class CargoWatchProvider implements vscode.Disposable {\n         this.outputChannel = vscode.window.createOutputChannel(\n             'Cargo Watch Trace'\n         );\n+\n+        // Register code actions for rustc's suggested fixes\n+        this.codeActions = {};\n+        this.codeActionDispose = vscode.languages.registerCodeActionsProvider(\n+            [{ scheme: 'file', language: 'rust' }],\n+            this,\n+            {\n+                providedCodeActionKinds: [vscode.CodeActionKind.QuickFix]\n+            }\n+        );\n     }\n \n     public start() {\n@@ -127,6 +148,14 @@ export class CargoWatchProvider implements vscode.Disposable {\n         this.diagnosticCollection.dispose();\n         this.outputChannel.dispose();\n         this.statusDisplay.dispose();\n+        this.codeActionDispose.dispose();\n+    }\n+\n+    public provideCodeActions(\n+        document: vscode.TextDocument\n+    ): vscode.ProviderResult<Array<vscode.Command | vscode.CodeAction>> {\n+        const documentActions = this.codeActions[document.uri.toString()];\n+        return documentActions || [];\n     }\n \n     private logInfo(line: string) {\n@@ -147,41 +176,73 @@ export class CargoWatchProvider implements vscode.Disposable {\n     private parseLine(line: string) {\n         if (line.startsWith('[Running')) {\n             this.diagnosticCollection.clear();\n+            this.codeActions = {};\n             this.statusDisplay.show();\n         }\n \n         if (line.startsWith('[Finished running')) {\n             this.statusDisplay.hide();\n         }\n \n-        function getLevel(s: string): vscode.DiagnosticSeverity {\n-            if (s === 'error') {\n-                return vscode.DiagnosticSeverity.Error;\n+        function areDiagnosticsEqual(\n+            left: vscode.Diagnostic,\n+            right: vscode.Diagnostic\n+        ): boolean {\n+            return (\n+                left.source === right.source &&\n+                left.severity === right.severity &&\n+                left.range.isEqual(right.range) &&\n+                left.message === right.message\n+            );\n+        }\n+\n+        function areCodeActionsEqual(\n+            left: vscode.CodeAction,\n+            right: vscode.CodeAction\n+        ): boolean {\n+            if (\n+                left.kind !== right.kind ||\n+                left.title !== right.title ||\n+                !left.edit ||\n+                !right.edit\n+            ) {\n+                return false;\n             }\n-            if (s.startsWith('warn')) {\n-                return vscode.DiagnosticSeverity.Warning;\n+\n+            const leftEditEntries = left.edit.entries();\n+            const rightEditEntries = right.edit.entries();\n+\n+            if (leftEditEntries.length !== rightEditEntries.length) {\n+                return false;\n             }\n-            return vscode.DiagnosticSeverity.Information;\n-        }\n \n-        // Reference:\n-        // https://github.com/rust-lang/rust/blob/master/src/libsyntax/json.rs\n-        interface RustDiagnosticSpan {\n-            line_start: number;\n-            line_end: number;\n-            column_start: number;\n-            column_end: number;\n-            is_primary: boolean;\n-            file_name: string;\n-        }\n+            for (let i = 0; i < leftEditEntries.length; i++) {\n+                const [leftUri, leftEdits] = leftEditEntries[i];\n+                const [rightUri, rightEdits] = rightEditEntries[i];\n+\n+                if (leftUri.toString() !== rightUri.toString()) {\n+                    return false;\n+                }\n \n-        interface RustDiagnostic {\n-            spans: RustDiagnosticSpan[];\n-            rendered: string;\n-            level: string;\n-            code?: {\n-                code: string;\n-            };\n+                if (leftEdits.length !== rightEdits.length) {\n+                    return false;\n+                }\n+\n+                for (let j = 0; j < leftEdits.length; j++) {\n+                    const leftEdit = leftEdits[j];\n+                    const rightEdit = rightEdits[j];\n+\n+                    if (!leftEdit.range.isEqual(rightEdit.range)) {\n+                        return false;\n+                    }\n+\n+                    if (leftEdit.newText !== rightEdit.newText) {\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            return true;\n         }\n \n         interface CargoArtifact {\n@@ -215,41 +276,58 @@ export class CargoWatchProvider implements vscode.Disposable {\n         } else if (data.reason === 'compiler-message') {\n             const msg = data.message as RustDiagnostic;\n \n-            const spans = msg.spans.filter(o => o.is_primary);\n-\n-            // We only handle primary span right now.\n-            if (spans.length > 0) {\n-                const o = spans[0];\n+            const mapResult = mapRustDiagnosticToVsCode(msg);\n+            if (!mapResult) {\n+                return;\n+            }\n \n-                const rendered = msg.rendered;\n-                const level = getLevel(msg.level);\n-                const range = new vscode.Range(\n-                    new vscode.Position(o.line_start - 1, o.column_start - 1),\n-                    new vscode.Position(o.line_end - 1, o.column_end - 1)\n-                );\n+            const { location, diagnostic, codeActions } = mapResult;\n+            const fileUri = location.uri;\n \n-                const fileName = path.join(\n-                    vscode.workspace.rootPath!,\n-                    o.file_name\n-                );\n-                const diagnostic = new vscode.Diagnostic(\n-                    range,\n-                    rendered,\n-                    level\n-                );\n+            const diagnostics: vscode.Diagnostic[] = [\n+                ...(this.diagnosticCollection!.get(fileUri) || [])\n+            ];\n \n-                diagnostic.source = 'rustc';\n-                diagnostic.code = msg.code ? msg.code.code : undefined;\n-                diagnostic.relatedInformation = [];\n+            // If we're building multiple targets it's possible we've already seen this diagnostic\n+            const isDuplicate = diagnostics.some(d =>\n+                areDiagnosticsEqual(d, diagnostic)\n+            );\n \n-                const fileUrl = vscode.Uri.file(fileName!);\n+            if (isDuplicate) {\n+                return;\n+            }\n \n-                const diagnostics: vscode.Diagnostic[] = [\n-                    ...(this.diagnosticCollection!.get(fileUrl) || [])\n-                ];\n-                diagnostics.push(diagnostic);\n+            diagnostics.push(diagnostic);\n+            this.diagnosticCollection!.set(fileUri, diagnostics);\n+\n+            if (codeActions.length) {\n+                const fileUriString = fileUri.toString();\n+                const existingActions = this.codeActions[fileUriString] || [];\n+\n+                for (const newAction of codeActions) {\n+                    const existingAction = existingActions.find(existing =>\n+                        areCodeActionsEqual(existing, newAction)\n+                    );\n+\n+                    if (existingAction) {\n+                        if (!existingAction.diagnostics) {\n+                            existingAction.diagnostics = [];\n+                        }\n+                        // This action also applies to this diagnostic\n+                        existingAction.diagnostics.push(diagnostic);\n+                    } else {\n+                        newAction.diagnostics = [diagnostic];\n+                        existingActions.push(newAction);\n+                    }\n+                }\n \n-                this.diagnosticCollection!.set(fileUrl, diagnostics);\n+                // Have VsCode query us for the code actions\n+                this.codeActions[fileUriString] = existingActions;\n+                vscode.commands.executeCommand(\n+                    'vscode.executeCodeActionProvider',\n+                    fileUri,\n+                    diagnostic.range\n+                );\n             }\n         }\n     }"}, {"sha": "ed049c95ef0db60f594565c1216daee4b115e9a8", "filename": "editors/code/src/utils/rust_diagnostics.ts", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324/editors%2Fcode%2Fsrc%2Futils%2Frust_diagnostics.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324/editors%2Fcode%2Fsrc%2Futils%2Frust_diagnostics.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Frust_diagnostics.ts?ref=4b0c37bd6e4cb3d47614ec6b42fb1deef9bc9324", "patch": "@@ -0,0 +1,226 @@\n+import * as path from 'path';\n+import * as vscode from 'vscode';\n+\n+// Reference:\n+// https://github.com/rust-lang/rust/blob/master/src/libsyntax/json.rs\n+export interface RustDiagnosticSpan {\n+    line_start: number;\n+    line_end: number;\n+    column_start: number;\n+    column_end: number;\n+    is_primary: boolean;\n+    file_name: string;\n+    label?: string;\n+    suggested_replacement?: string;\n+    suggestion_applicability?:\n+        | 'MachineApplicable'\n+        | 'HasPlaceholders'\n+        | 'MaybeIncorrect'\n+        | 'Unspecified';\n+}\n+\n+export interface RustDiagnostic {\n+    spans: RustDiagnosticSpan[];\n+    rendered: string;\n+    message: string;\n+    level: string;\n+    code?: {\n+        code: string;\n+    };\n+    children: RustDiagnostic[];\n+}\n+\n+export interface MappedRustDiagnostic {\n+    location: vscode.Location;\n+    diagnostic: vscode.Diagnostic;\n+    codeActions: vscode.CodeAction[];\n+}\n+\n+interface MappedRustChildDiagnostic {\n+    related?: vscode.DiagnosticRelatedInformation;\n+    codeAction?: vscode.CodeAction;\n+    messageLine?: string;\n+}\n+\n+/**\n+ * Converts a Rust level string to a VsCode severity\n+ */\n+function mapLevelToSeverity(s: string): vscode.DiagnosticSeverity {\n+    if (s === 'error') {\n+        return vscode.DiagnosticSeverity.Error;\n+    }\n+    if (s.startsWith('warn')) {\n+        return vscode.DiagnosticSeverity.Warning;\n+    }\n+    return vscode.DiagnosticSeverity.Information;\n+}\n+\n+/**\n+ * Converts a Rust span to a VsCode location\n+ */\n+function mapSpanToLocation(span: RustDiagnosticSpan): vscode.Location {\n+    const fileName = path.join(vscode.workspace.rootPath!, span.file_name);\n+    const fileUri = vscode.Uri.file(fileName);\n+\n+    const range = new vscode.Range(\n+        new vscode.Position(span.line_start - 1, span.column_start - 1),\n+        new vscode.Position(span.line_end - 1, span.column_end - 1)\n+    );\n+\n+    return new vscode.Location(fileUri, range);\n+}\n+\n+/**\n+ * Converts a secondary Rust span to a VsCode related information\n+ *\n+ * If the span is unlabelled this will return `undefined`.\n+ */\n+function mapSecondarySpanToRelated(\n+    span: RustDiagnosticSpan\n+): vscode.DiagnosticRelatedInformation | undefined {\n+    if (!span.label) {\n+        // Nothing to label this with\n+        return;\n+    }\n+\n+    const location = mapSpanToLocation(span);\n+    return new vscode.DiagnosticRelatedInformation(location, span.label);\n+}\n+\n+/**\n+ * Determines if diagnostic is related to unused code\n+ */\n+function isUnusedOrUnnecessary(rd: RustDiagnostic): boolean {\n+    if (!rd.code) {\n+        return false;\n+    }\n+\n+    return [\n+        'dead_code',\n+        'unknown_lints',\n+        'unused_attributes',\n+        'unused_imports',\n+        'unused_macros',\n+        'unused_variables'\n+    ].includes(rd.code.code);\n+}\n+\n+/**\n+ * Converts a Rust child diagnostic to a VsCode related information\n+ *\n+ * This can have three outcomes:\n+ *\n+ * 1. If this is no primary span this will return a `noteLine`\n+ * 2. If there is a primary span with a suggested replacement it will return a\n+ *    `codeAction`.\n+ * 3. If there is a primary span without a suggested replacement it will return\n+ *    a `related`.\n+ */\n+function mapRustChildDiagnostic(rd: RustDiagnostic): MappedRustChildDiagnostic {\n+    const span = rd.spans.find(s => s.is_primary);\n+\n+    if (!span) {\n+        // `rustc` uses these spanless children as a way to print multi-line\n+        // messages\n+        return { messageLine: rd.message };\n+    }\n+\n+    // If we have a primary span use its location, otherwise use the parent\n+    const location = mapSpanToLocation(span);\n+\n+    // We need to distinguish `null` from an empty string\n+    if (span && typeof span.suggested_replacement === 'string') {\n+        const edit = new vscode.WorkspaceEdit();\n+        edit.replace(location.uri, location.range, span.suggested_replacement);\n+\n+        // Include our replacement in the label unless it's empty\n+        const title = span.suggested_replacement\n+            ? `${rd.message}: \\`${span.suggested_replacement}\\``\n+            : rd.message;\n+\n+        const codeAction = new vscode.CodeAction(\n+            title,\n+            vscode.CodeActionKind.QuickFix\n+        );\n+\n+        codeAction.edit = edit;\n+        codeAction.isPreferred =\n+            span.suggestion_applicability === 'MachineApplicable';\n+\n+        return { codeAction };\n+    } else {\n+        const related = new vscode.DiagnosticRelatedInformation(\n+            location,\n+            rd.message\n+        );\n+\n+        return { related };\n+    }\n+}\n+\n+/**\n+ * Converts a Rust root diagnostic to VsCode form\n+ *\n+ * This flattens the Rust diagnostic by:\n+ *\n+ * 1. Creating a `vscode.Diagnostic` with the root message and primary span.\n+ * 2. Adding any labelled secondary spans to `relatedInformation`\n+ * 3. Categorising child diagnostics as either Quick Fix actions,\n+ *    `relatedInformation` or additional message lines.\n+ *\n+ * If the diagnostic has no primary span this will return `undefined`\n+ */\n+export function mapRustDiagnosticToVsCode(\n+    rd: RustDiagnostic\n+): MappedRustDiagnostic | undefined {\n+    const codeActions = [];\n+\n+    const primarySpan = rd.spans.find(s => s.is_primary);\n+    if (!primarySpan) {\n+        return;\n+    }\n+\n+    const location = mapSpanToLocation(primarySpan);\n+    const secondarySpans = rd.spans.filter(s => !s.is_primary);\n+\n+    const severity = mapLevelToSeverity(rd.level);\n+\n+    const vd = new vscode.Diagnostic(location.range, rd.message, severity);\n+\n+    vd.source = 'rustc';\n+    vd.code = rd.code ? rd.code.code : undefined;\n+    vd.relatedInformation = [];\n+\n+    for (const secondarySpan of secondarySpans) {\n+        const related = mapSecondarySpanToRelated(secondarySpan);\n+        if (related) {\n+            vd.relatedInformation.push(related);\n+        }\n+    }\n+\n+    for (const child of rd.children) {\n+        const { related, codeAction, messageLine } = mapRustChildDiagnostic(\n+            child\n+        );\n+\n+        if (related) {\n+            vd.relatedInformation.push(related);\n+        }\n+        if (codeAction) {\n+            codeActions.push(codeAction);\n+        }\n+        if (messageLine) {\n+            vd.message += `\\n${messageLine}`;\n+        }\n+    }\n+\n+    if (isUnusedOrUnnecessary(rd)) {\n+        vd.tags = [vscode.DiagnosticTag.Unnecessary];\n+    }\n+\n+    return {\n+        location,\n+        diagnostic: vd,\n+        codeActions\n+    };\n+}"}]}