{"sha": "a779e3b5c432c341b0e32d588d966199d3be9c27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NzllM2I1YzQzMmMzNDFiMGUzMmQ1ODhkOTY2MTk5ZDNiZTljMjc=", "commit": {"author": {"name": "jfager", "email": "jfager@gmail.com", "date": "2014-11-30T23:11:40Z"}, "committer": {"name": "jfager", "email": "jfager@gmail.com", "date": "2014-11-30T23:11:40Z"}, "message": "fix missed switch pointed out in review plus a few others", "tree": {"sha": "8ba1621e1126aca514083c1d2f364703781e3245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ba1621e1126aca514083c1d2f364703781e3245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a779e3b5c432c341b0e32d588d966199d3be9c27", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a779e3b5c432c341b0e32d588d966199d3be9c27", "html_url": "https://github.com/rust-lang/rust/commit/a779e3b5c432c341b0e32d588d966199d3be9c27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a779e3b5c432c341b0e32d588d966199d3be9c27/comments", "author": {"login": "jfager", "id": 23755, "node_id": "MDQ6VXNlcjIzNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/23755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfager", "html_url": "https://github.com/jfager", "followers_url": "https://api.github.com/users/jfager/followers", "following_url": "https://api.github.com/users/jfager/following{/other_user}", "gists_url": "https://api.github.com/users/jfager/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfager/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfager/subscriptions", "organizations_url": "https://api.github.com/users/jfager/orgs", "repos_url": "https://api.github.com/users/jfager/repos", "events_url": "https://api.github.com/users/jfager/events{/privacy}", "received_events_url": "https://api.github.com/users/jfager/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jfager", "id": 23755, "node_id": "MDQ6VXNlcjIzNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/23755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfager", "html_url": "https://github.com/jfager", "followers_url": "https://api.github.com/users/jfager/followers", "following_url": "https://api.github.com/users/jfager/following{/other_user}", "gists_url": "https://api.github.com/users/jfager/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfager/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfager/subscriptions", "organizations_url": "https://api.github.com/users/jfager/orgs", "repos_url": "https://api.github.com/users/jfager/repos", "events_url": "https://api.github.com/users/jfager/events{/privacy}", "received_events_url": "https://api.github.com/users/jfager/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232ffa039ddb349c9e9c08d0872aaf95970a1369", "url": "https://api.github.com/repos/rust-lang/rust/commits/232ffa039ddb349c9e9c08d0872aaf95970a1369", "html_url": "https://github.com/rust-lang/rust/commit/232ffa039ddb349c9e9c08d0872aaf95970a1369"}], "stats": {"total": 85, "additions": 33, "deletions": 52}, "files": [{"sha": "aa99fe996f02ab9ed37564cbd99cd43bc22744c2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a779e3b5c432c341b0e32d588d966199d3be9c27/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a779e3b5c432c341b0e32d588d966199d3be9c27/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a779e3b5c432c341b0e32d588d966199d3be9c27", "patch": "@@ -1173,14 +1173,12 @@ impl LintPass for NonShorthandFieldPatterns {\n                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n                              .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n                                                 == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n-                match fieldpat.node.pat.node {\n-                    ast::PatIdent(_, ident, None) if ident.node.as_str()\n-                                                     == fieldpat.node.ident.as_str() => {\n+                if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n+                    if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      format!(\"the `{}:` in this pattern is redundant and can \\\n                                               be removed\", ident.node.as_str()).as_slice())\n-                    },\n-                    _ => {},\n+                    }\n                 }\n             }\n         }\n@@ -1198,15 +1196,12 @@ impl LintPass for UnusedUnsafe {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n+        if let ast::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n-            ast::ExprBlock(ref blk) => {\n-                if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                    !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n                     cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n-                }\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -1222,12 +1217,11 @@ impl LintPass for UnsafeBlocks {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n+        if let ast::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n-            ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) {\n                 cx.span_lint(UNSAFE_BLOCKS, blk.span, \"usage of an `unsafe` block\");\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -1246,17 +1240,13 @@ impl UnusedMut {\n         for p in pats.iter() {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n-                match mode {\n-                    ast::BindByValue(ast::MutMutable) => {\n-                        if !token::get_ident(ident).get().starts_with(\"_\") {\n-                            match mutables.entry(ident.name.uint()) {\n-                                Vacant(entry) => { entry.set(vec![id]); },\n-                                Occupied(mut entry) => { entry.get_mut().push(id); },\n-                            }\n+                if let ast::BindByValue(ast::MutMutable) = mode {\n+                    if !token::get_ident(ident).get().starts_with(\"_\") {\n+                        match mutables.entry(ident.name.uint()) {\n+                            Vacant(entry) => { entry.set(vec![id]); },\n+                            Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }\n                     }\n-                    _ => {\n-                    }\n                 }\n             });\n         }\n@@ -1379,9 +1369,10 @@ impl MissingDoc {\n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a NodeId).\n-        match id {\n-            Some(ref id) if !cx.exported_items.contains(id) => return,\n-            _ => ()\n+        if let Some(ref id) = id {\n+            if !cx.exported_items.contains(id) {\n+                return;\n+            }\n         }\n \n         let has_doc = attrs.iter().any(|a| {\n@@ -1465,15 +1456,14 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n-        match sf.node.kind {\n-            ast::NamedField(_, vis) if vis == ast::Public || self.in_variant => {\n+        if let ast::NamedField(_, vis) = sf.node.kind {\n+            if vis == ast::Public || self.in_variant {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                             sf.node.attrs.as_slice(), sf.span,\n-                                             \"a struct field\")\n+                                              sf.node.attrs.as_slice(), sf.span,\n+                                              \"a struct field\")\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1639,12 +1629,9 @@ impl LintPass for Stability {\n         match item.node {\n             ast::ItemTrait(_, _, ref supertraits, _) => {\n                 for t in supertraits.iter() {\n-                    match *t {\n-                        ast::TraitTyParamBound(ref t) => {\n-                            let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n-                            self.lint(cx, id, t.trait_ref.path.span);\n-                        }\n-                        _ => (/* pass */)\n+                    if let ast::TraitTyParamBound(ref t) = *t {\n+                        let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n+                        self.lint(cx, id, t.trait_ref.path.span);\n                     }\n                 }\n             }"}, {"sha": "ec812cea3728da68668f1f579d1a6b94e3583bd1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a779e3b5c432c341b0e32d588d966199d3be9c27/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a779e3b5c432c341b0e32d588d966199d3be9c27/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a779e3b5c432c341b0e32d588d966199d3be9c27", "patch": "@@ -521,21 +521,15 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                 let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n                                                    cdata);\n                 if let Some(impl_method_doc) = maybe_find_item(impl_item_def_id.node, items) {\n-                    match item_family(impl_method_doc) {\n-                        StaticMethod => {\n-                            // Hand off the static method\n-                            // to the callback.\n-                            let static_method_name =\n-                                item_name(&*intr, impl_method_doc);\n-                            let static_method_def_like =\n-                                item_to_def_like(impl_method_doc,\n-                                                 impl_item_def_id,\n-                                                 cdata.cnum);\n-                            callback(static_method_def_like,\n-                                     static_method_name,\n-                                     item_visibility(impl_method_doc));\n-                        }\n-                        _ => {}\n+                    if let StaticMethod = item_family(impl_method_doc) {\n+                        // Hand off the static method to the callback.\n+                        let static_method_name = item_name(&*intr, impl_method_doc);\n+                        let static_method_def_like = item_to_def_like(impl_method_doc,\n+                                                                      impl_item_def_id,\n+                                                                      cdata.cnum);\n+                        callback(static_method_def_like,\n+                                 static_method_name,\n+                                 item_visibility(impl_method_doc));\n                     }\n                 }\n                 true"}]}