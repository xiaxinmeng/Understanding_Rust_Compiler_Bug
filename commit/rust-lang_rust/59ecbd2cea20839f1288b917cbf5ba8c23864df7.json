{"sha": "59ecbd2cea20839f1288b917cbf5ba8c23864df7", "node_id": "C_kwDOAAsO6NoAKDU5ZWNiZDJjZWEyMDgzOWYxMjg4YjkxN2NiZjViYThjMjM4NjRkZjc", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-01-19T09:24:17Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-05-05T19:44:13Z"}, "message": "Add parsing for builtin # in expression and item context", "tree": {"sha": "c60e269ea5a5df36aa47f2f7ee400d859376c475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c60e269ea5a5df36aa47f2f7ee400d859376c475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59ecbd2cea20839f1288b917cbf5ba8c23864df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59ecbd2cea20839f1288b917cbf5ba8c23864df7", "html_url": "https://github.com/rust-lang/rust/commit/59ecbd2cea20839f1288b917cbf5ba8c23864df7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59ecbd2cea20839f1288b917cbf5ba8c23864df7/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b94c232192b0fa0314b5afa18e366356e210c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b94c232192b0fa0314b5afa18e366356e210c4c", "html_url": "https://github.com/rust-lang/rust/commit/4b94c232192b0fa0314b5afa18e366356e210c4c"}], "stats": {"total": 97, "additions": 96, "deletions": 1}, "files": [{"sha": "711447a0af0775af746402ef4205f96fbda06839", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -257,6 +257,10 @@ parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are inva\n     .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n     .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n \n+parse_expected_builtin_ident = expected identifier after `builtin #`\n+\n+parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n+\n parse_non_string_abi_literal = non-string ABI literal\n     .suggestion = specify the ABI with a string literal\n "}, {"sha": "0810f0efef98d7137433897e4d970ef3ac096c73", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -2644,3 +2644,18 @@ pub(crate) struct MalformedCfgAttr {\n     pub span: Span,\n     pub sugg: &'static str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unknown_builtin_construct)]\n+pub(crate) struct UnknownBuiltinConstruct {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_builtin_ident)]\n+pub(crate) struct ExpectedBuiltinIdent {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "844cf3359628bdc84ef9cc4e485950539ad9467f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -1300,6 +1300,8 @@ impl<'a> Parser<'a> {\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n             self.parse_expr_array_or_repeat(Delimiter::Bracket)\n+        } else if self.is_builtin() {\n+            self.parse_expr_builtin()\n         } else if self.check_path() {\n             self.parse_expr_path_start()\n         } else if self.check_keyword(kw::Move)\n@@ -1755,6 +1757,42 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n+    /// Parse `builtin # ident(args,*)`.\n+    fn parse_expr_builtin(&mut self) -> PResult<'a, P<Expr>> {\n+        self.parse_builtin(|_this, _lo, _ident| {\n+            Ok(None)\n+        })\n+    }\n+\n+    pub(crate) fn parse_builtin<T>(\n+        &mut self,\n+        parse: impl FnOnce(&mut Parser<'a>, Span, Ident) -> PResult<'a, Option<T>>,\n+    ) -> PResult<'a, T> {\n+        let lo = self.token.span;\n+\n+        self.bump(); // `builtin`\n+        self.bump(); // `#`\n+\n+        let Some((ident, false)) = self.token.ident() else {\n+            let err = errors::ExpectedBuiltinIdent { span: self.token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            return Err(err);\n+        };\n+        self.bump();\n+\n+        self.expect(&TokenKind::OpenDelim(Delimiter::Parenthesis))?;\n+        let ret = if let Some(res) = parse(self, lo, ident)? {\n+            Ok(res)\n+        } else {\n+            let err = errors::UnknownBuiltinConstruct { span: lo.to(ident.span), name: ident.name }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            return Err(err);\n+        };\n+        self.expect(&TokenKind::CloseDelim(Delimiter::Parenthesis))?;\n+\n+        ret\n+    }\n+\n     /// Returns a string literal if the next token is a string literal.\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n@@ -2824,6 +2862,10 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    pub(crate) fn is_builtin(&self) -> bool {\n+        self.token.is_keyword(kw::Builtin) && self.look_ahead(1, |t| *t == token::Pound)\n+    }\n+\n     /// Parses a `try {...}` expression (`try` token already eaten).\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;"}, {"sha": "edfe316ec954e0247075622cbf3872f2f7272ad4", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -265,6 +265,9 @@ impl<'a> Parser<'a> {\n             // UNION ITEM\n             self.bump(); // `union`\n             self.parse_item_union()?\n+        } else if self.is_builtin() {\n+            // BUILTIN# ITEM\n+            return self.parse_item_builtin();\n         } else if self.eat_keyword(kw::Macro) {\n             // MACROS 2.0 ITEM\n             self.parse_item_decl_macro(lo)?\n@@ -434,6 +437,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn parse_item_builtin(&mut self) -> PResult<'a, Option<ItemInfo>> {\n+        // To be expanded\n+        return Ok(None);\n+    }\n+\n     /// Parses an item macro, e.g., `item!();`.\n     fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, MacCall> {\n         let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`"}, {"sha": "a0bd086053e4e6c976e5185d2db551745831c2eb", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -90,7 +90,11 @@ impl<'a> Parser<'a> {\n                 attrs,\n                 errors::InvalidVariableDeclarationSub::UseLetNotVar,\n             )?\n-        } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n+        } else if self.check_path()\n+            && !self.token.is_qpath_start()\n+            && !self.is_path_start_item()\n+            && !self.is_builtin()\n+        {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path."}, {"sha": "9e543fc8de45f0bf145e53358856bd0eacd291de", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -95,6 +95,7 @@ symbols! {\n \n         // Weak keywords, have special meaning only in specific contexts.\n         Auto:               \"auto\",\n+        Builtin:            \"builtin\",\n         Catch:              \"catch\",\n         Default:            \"default\",\n         MacroRules:         \"macro_rules\","}, {"sha": "c0b91a58073ed925e6f3368cf1e8e310159da824", "filename": "tests/ui/parser/builtin-syntax.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/tests%2Fui%2Fparser%2Fbuiltin-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/tests%2Fui%2Fparser%2Fbuiltin-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbuiltin-syntax.rs?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    builtin # foobar(); //~ ERROR unknown `builtin #` construct\n+}\n+\n+fn not_identifier() {\n+    builtin # {}(); //~ ERROR expected identifier after\n+}"}, {"sha": "2679049fb5ef5ca4c6606a07d1fac8a523483140", "filename": "tests/ui/parser/builtin-syntax.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59ecbd2cea20839f1288b917cbf5ba8c23864df7/tests%2Fui%2Fparser%2Fbuiltin-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59ecbd2cea20839f1288b917cbf5ba8c23864df7/tests%2Fui%2Fparser%2Fbuiltin-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbuiltin-syntax.stderr?ref=59ecbd2cea20839f1288b917cbf5ba8c23864df7", "patch": "@@ -0,0 +1,14 @@\n+error: unknown `builtin #` construct `foobar`\n+  --> $DIR/builtin-syntax.rs:2:5\n+   |\n+LL |     builtin # foobar();\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: expected identifier after `builtin #`\n+  --> $DIR/builtin-syntax.rs:6:15\n+   |\n+LL |     builtin # {}();\n+   |               ^\n+\n+error: aborting due to 2 previous errors\n+"}]}