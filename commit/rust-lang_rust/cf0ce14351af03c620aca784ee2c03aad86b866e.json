{"sha": "cf0ce14351af03c620aca784ee2c03aad86b866e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMGNlMTQzNTFhZjAzYzYyMGFjYTc4NGVlMmMwM2FhZDg2Yjg2NmU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-06T14:51:10Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-06T14:51:10Z"}, "message": "Merge #429\n\n429: Reorganize hir public API in terms of code model r=matklad a=matklad\n\nRecently, I've been thinking about introducing \"object orient code model\" API for rust: a set of APIs with types like `Function`, `Module`, etc, with methods like `get_containing_declaration()`, `get_type()`, etc. \r\n\r\nHere's how a similar API might look like in .Net land:\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.semanticmodel?view=roslyn-dotnet\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.imethodsymbol?view=roslyn-dotnet\r\n\r\nThe main feature of such API is that it can be powered by different backends. For example, one can imagine a backend based on salsa, and a backend which reads all the data from a specially prepared JSON file. The \"OO\" bit is interesting mostly in this \"can swap implementations via dynamic dispatch\" aspect, the actual API could have a more database/ECS flavored feeling.\r\n\r\nIt's not clear at this moment how exactly should we implement such a dynamically (or if we even need dynamism in the first pace) swapable API in Rust, but I'd love to experiment with this a bit. \r\n\r\nFor starters, I propose creating a `code_model_api` which contains various definition types and their public methods (mandatory implemented as one-liners, so that the API has a header-file feel). Specifically, I propose that each type is a wrapper around some integer ID, and that all methods of it accept a `&db` argument.  The actual impl goes elsewhere: into the db queries or, absent a better place, into the `code_model_api_impl`. In the first commit, I've moved the simplest type, `Crate`, over to this pattern.\r\n\r\nI *think* that we, at least initially, will be used types from `code_model_api` *inside* `hir` as well, but this is not required: we might pick a different implementation down the line, while preserving the API. \r\n\r\nLong term I'd love to replace the `db: &impl HirDatabase` argument by a `mp: &dyn ModelProvider`, implement `ModelProvider` for `T: HirDatabase`, and move `code_model_api` into the separate crate, which does not depend on `hir`. \r\n\r\n@flodiebold you've recently done some `Def`s work, would do you think of this plan? Could it become a good API in the future, or is it just a useless boilerplate duplicating method signatures between `code_model_api` and `code_model_impl`?\r\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "bffd84981df9cca1143807796dc6772ddcfe8e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bffd84981df9cca1143807796dc6772ddcfe8e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf0ce14351af03c620aca784ee2c03aad86b866e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0ce14351af03c620aca784ee2c03aad86b866e", "html_url": "https://github.com/rust-lang/rust/commit/cf0ce14351af03c620aca784ee2c03aad86b866e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf0ce14351af03c620aca784ee2c03aad86b866e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "eaf553dade9a28b41631387d7c88b09fd0ba64e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf553dade9a28b41631387d7c88b09fd0ba64e2", "html_url": "https://github.com/rust-lang/rust/commit/eaf553dade9a28b41631387d7c88b09fd0ba64e2"}, {"sha": "733383446fc229a35d4432d14c295c5a01e5a87f", "url": "https://api.github.com/repos/rust-lang/rust/commits/733383446fc229a35d4432d14c295c5a01e5a87f", "html_url": "https://github.com/rust-lang/rust/commit/733383446fc229a35d4432d14c295c5a01e5a87f"}], "stats": {"total": 1499, "additions": 790, "deletions": 709}, "files": [{"sha": "ee9052d3d5d558231fcdec776da826c4e2306ec2", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -20,14 +20,17 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n     }\n \n     let module_scope = module.scope(ctx.db)?;\n+    let (file_id, _) = module.defenition_source(ctx.db)?;\n     module_scope\n         .entries()\n         .filter(|(_name, res)| {\n             // Don't expose this item\n+            // FIXME: this penetrates through all kinds of abstractions,\n+            // we need to figura out the way to do it less ugly.\n             match res.import {\n                 None => true,\n                 Some(import) => {\n-                    let range = import.range(ctx.db, module.file_id());\n+                    let range = import.range(ctx.db, file_id);\n                     !range.is_subrange(&ctx.leaf.range())\n                 }\n             }"}, {"sha": "aa0616e3b3b6ce2bd44a260ae6eaed9e6e8b6629", "filename": "crates/ra_analysis/src/goto_defenition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -60,8 +60,8 @@ fn name_defenition(\n             if let Some(child_module) =\n                 hir::source_binder::module_from_declaration(db, file_id, module)?\n             {\n-                let file_id = child_module.file_id();\n-                let name = match child_module.name() {\n+                let (file_id, _) = child_module.defenition_source(db)?;\n+                let name = match child_module.name(db)? {\n                     Some(name) => name.to_string().into(),\n                     None => \"\".into(),\n                 };"}, {"sha": "07a9662905247adfa3c14c2b5be18bfb6dbaafb7", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -105,39 +105,35 @@ impl db::RootDatabase {\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Vec<NavigationTarget>> {\n-        let descr = match source_binder::module_from_position(self, position)? {\n+        let module = match source_binder::module_from_position(self, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n-        let (file_id, decl) = match descr.parent_link_source(self) {\n+        let (file_id, ast_module) = match module.declaration_source(self)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n-        let decl = decl.borrowed();\n-        let decl_name = decl.name().unwrap();\n+        let ast_module = ast_module.borrowed();\n+        let name = ast_module.name().unwrap();\n         Ok(vec![NavigationTarget {\n             file_id,\n-            name: decl_name.text(),\n-            range: decl_name.syntax().range(),\n+            name: name.text(),\n+            range: name.syntax().range(),\n             kind: MODULE,\n             ptr: None,\n         }])\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub(crate) fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let descr = match source_binder::module_from_file_id(self, file_id)? {\n+        let module = match source_binder::module_from_file_id(self, file_id)? {\n+            Some(it) => it,\n             None => return Ok(Vec::new()),\n+        };\n+        let krate = match module.krate(self)? {\n             Some(it) => it,\n+            None => return Ok(Vec::new()),\n         };\n-        let root = descr.crate_root();\n-        let file_id = root.file_id();\n-\n-        let crate_graph = self.crate_graph();\n-        let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n-        Ok(crate_id.into_iter().collect())\n-    }\n-    pub(crate) fn crate_root(&self, crate_id: CrateId) -> FileId {\n-        self.crate_graph().crate_root(crate_id)\n+        Ok(vec![krate.crate_id()])\n     }\n     pub(crate) fn find_all_refs(\n         &self,\n@@ -209,7 +205,7 @@ impl db::RootDatabase {\n             })\n             .collect::<Vec<_>>();\n         if let Some(m) = source_binder::module_from_file_id(self, file_id)? {\n-            for (name_node, problem) in m.problems(self) {\n+            for (name_node, problem) in m.problems(self)? {\n                 let source_root = self.file_source_root(file_id);\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {"}, {"sha": "77f77e9a8c94b43ec4399e8f28ffe085f72af184", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -397,7 +397,7 @@ impl Analysis {\n     }\n     /// Returns the root file of the given crate.\n     pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n-        Ok(self.db.crate_root(crate_id))\n+        Ok(self.db.crate_graph().crate_root(crate_id))\n     }\n     /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {"}, {"sha": "216209098d3b99c4e9cf99f91a12e3281f4f811f", "filename": "crates/ra_analysis/src/runnables.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Frunnables.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -72,12 +72,15 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n     let range = module.syntax().range();\n     let module =\n         hir::source_binder::module_from_child_node(db, file_id, module.syntax()).ok()??;\n+\n+    // FIXME: thread cancellation instead of `.ok`ing\n     let path = module\n-        .path_to_root()\n+        .path_to_root(db)\n+        .ok()?\n         .into_iter()\n         .rev()\n-        .into_iter()\n-        .filter_map(|it| it.name().map(Clone::clone))\n+        .filter_map(|it| it.name(db).ok())\n+        .filter_map(|it| it)\n         .join(\"::\");\n     Some(Runnable {\n         range,"}, {"sha": "85911de921bd210ab7283cf351cb1b8974463949", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -31,6 +31,7 @@ fn test_unresolved_module_diagnostic() {\n     );\n }\n \n+// FIXME: move this test to hir\n #[test]\n fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n     let (analysis, file_id) = single_file(\"mod foo {}\");"}, {"sha": "09b532f7464757672965107e0694ef2c07b878af", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -0,0 +1,110 @@\n+use relative_path::RelativePathBuf;\n+use ra_db::{CrateId, Cancelable, FileId};\n+use ra_syntax::{ast, SyntaxNode};\n+\n+use crate::{Name, db::HirDatabase, DefId, Path, PerNs, nameres::ModuleScope};\n+\n+/// hir::Crate describes a single crate. It's the main inteface with which\n+/// crate's dependencies interact. Mostly, it should be just a proxy for the\n+/// root module.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Crate {\n+    pub(crate) crate_id: CrateId,\n+}\n+\n+#[derive(Debug)]\n+pub struct CrateDependency {\n+    pub krate: Crate,\n+    pub name: Name,\n+}\n+\n+impl Crate {\n+    pub fn crate_id(&self) -> CrateId {\n+        self.crate_id\n+    }\n+    pub fn dependencies(&self, db: &impl HirDatabase) -> Cancelable<Vec<CrateDependency>> {\n+        Ok(self.dependencies_impl(db))\n+    }\n+    pub fn root_module(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+        self.root_module_impl(db)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Module {\n+    pub(crate) def_id: DefId,\n+}\n+\n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFileNode),\n+    Module(ast::ModuleNode),\n+}\n+\n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Problem {\n+    UnresolvedModule {\n+        candidate: RelativePathBuf,\n+    },\n+    NotDirOwner {\n+        move_to: RelativePathBuf,\n+        candidate: RelativePathBuf,\n+    },\n+}\n+\n+impl Module {\n+    /// Name of this module.\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n+        self.name_impl(db)\n+    }\n+\n+    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n+    pub fn defenition_source(&self, db: &impl HirDatabase) -> Cancelable<(FileId, ModuleSource)> {\n+        self.defenition_source_impl(db)\n+    }\n+    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n+    /// `None` for the crate root.\n+    pub fn declaration_source(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+        self.declaration_source_impl(db)\n+    }\n+\n+    /// Returns the crate this module is part of.\n+    pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n+        self.krate_impl(db)\n+    }\n+    /// Topmost parent of this module. Every module has a `crate_root`, but some\n+    /// might miss `krate`. This can happen if a module's file is not included\n+    /// into any module tree of any target from Cargo.toml.\n+    pub fn crate_root(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        self.crate_root_impl(db)\n+    }\n+    /// Finds a child module with the specified name.\n+    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+        self.child_impl(db, name)\n+    }\n+    /// Finds a parent module.\n+    pub fn parent(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+        self.parent_impl(db)\n+    }\n+    pub fn path_to_root(&self, db: &impl HirDatabase) -> Cancelable<Vec<Module>> {\n+        let mut res = vec![self.clone()];\n+        let mut curr = self.clone();\n+        while let Some(next) = curr.parent(db)? {\n+            res.push(next.clone());\n+            curr = next\n+        }\n+        Ok(res)\n+    }\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        self.scope_impl(db)\n+    }\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n+        self.resolve_path_impl(db, path)\n+    }\n+    pub fn problems(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+        self.problems_impl(db)\n+    }\n+}"}, {"sha": "157b0c61688723f4a2b0c7b4121cea07c5fe644f", "filename": "crates/ra_hir/src/code_model_impl.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -0,0 +1,2 @@\n+mod krate; // `crate` is invalid ident :(\n+mod module;"}, {"sha": "591a81597da6715fa25916c158d3a014ebb7f98d", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "renamed", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -1,26 +1,15 @@\n-pub use ra_db::{CrateId, Cancelable};\n+use ra_db::{CrateId, Cancelable};\n \n-use crate::{HirDatabase, Module, Name, AsName, HirFileId};\n-\n-/// hir::Crate describes a single crate. It's the main inteface with which\n-/// crate's dependencies interact. Mostly, it should be just a proxy for the\n-/// root module.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Crate {\n-    crate_id: CrateId,\n-}\n-\n-#[derive(Debug)]\n-pub struct CrateDependency {\n-    pub krate: Crate,\n-    pub name: Name,\n-}\n+use crate::{\n+    HirFileId, Crate, CrateDependency, AsName, DefLoc, DefKind, Module,\n+    db::HirDatabase,\n+};\n \n impl Crate {\n     pub(crate) fn new(crate_id: CrateId) -> Crate {\n         Crate { crate_id }\n     }\n-    pub fn dependencies(&self, db: &impl HirDatabase) -> Vec<CrateDependency> {\n+    pub(crate) fn dependencies_impl(&self, db: &impl HirDatabase) -> Vec<CrateDependency> {\n         let crate_graph = db.crate_graph();\n         crate_graph\n             .dependencies(self.crate_id)\n@@ -31,7 +20,7 @@ impl Crate {\n             })\n             .collect()\n     }\n-    pub fn root_module(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+    pub(crate) fn root_module_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         let crate_graph = db.crate_graph();\n         let file_id = crate_graph.crate_root(self.crate_id);\n         let source_root_id = db.file_source_root(file_id);\n@@ -42,7 +31,15 @@ impl Crate {\n             .modules_with_sources()\n             .find(|(_, src)| src.file_id() == file_id));\n \n-        let module = Module::new(db, source_root_id, module_id)?;\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id,\n+            module_id,\n+            source_item_id: module_id.source(&module_tree).0,\n+        };\n+        let def_id = def_loc.id(db);\n+\n+        let module = Module::new(def_id);\n         Ok(Some(module))\n     }\n }", "previous_filename": "crates/ra_hir/src/krate.rs"}, {"sha": "02078f188dcc71d5542aa8e3976df757bd8da8a1", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -0,0 +1,154 @@\n+use ra_db::{Cancelable, SourceRootId, FileId};\n+use ra_syntax::{ast, SyntaxNode, AstNode};\n+\n+use crate::{\n+    Module, ModuleSource, Problem,\n+    Crate, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def, ModuleId,\n+    nameres::ModuleScope,\n+    db::HirDatabase,\n+};\n+\n+impl Module {\n+    pub(crate) fn new(def_id: DefId) -> Self {\n+        crate::code_model_api::Module { def_id }\n+    }\n+    pub(crate) fn from_module_id(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Cancelable<Self> {\n+        let module_tree = db.module_tree(source_root_id)?;\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id,\n+            module_id,\n+            source_item_id: module_id.source(&module_tree).0,\n+        };\n+        let def_id = def_loc.id(db);\n+        let module = Module::new(def_id);\n+        Ok(module)\n+    }\n+\n+    pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let link = ctry!(loc.module_id.parent_link(&module_tree));\n+        Ok(Some(link.name(&module_tree).clone()))\n+    }\n+\n+    pub fn defenition_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<(FileId, ModuleSource)> {\n+        let loc = self.def_id.loc(db);\n+        let file_id = loc.source_item_id.file_id.as_original_file();\n+        let syntax_node = db.file_item(loc.source_item_id);\n+        let syntax_node = syntax_node.borrowed();\n+        let module_source = if let Some(source_file) = ast::SourceFile::cast(syntax_node) {\n+            ModuleSource::SourceFile(source_file.owned())\n+        } else {\n+            let module = ast::Module::cast(syntax_node).unwrap();\n+            ModuleSource::Module(module.owned())\n+        };\n+        Ok((file_id, module_source))\n+    }\n+\n+    pub fn declaration_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let link = ctry!(loc.module_id.parent_link(&module_tree));\n+        let file_id = link\n+            .owner(&module_tree)\n+            .source(&module_tree)\n+            .file_id()\n+            .as_original_file();\n+        let src = link.bind_source(&module_tree, db);\n+        Ok(Some((file_id, src)))\n+    }\n+\n+    pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n+        let root = self.crate_root(db)?;\n+        let loc = root.def_id.loc(db);\n+        let file_id = loc.source_item_id.file_id.as_original_file();\n+\n+        let crate_graph = db.crate_graph();\n+        let crate_id = ctry!(crate_graph.crate_id_for_crate_root(file_id));\n+        Ok(Some(Crate::new(crate_id)))\n+    }\n+\n+    pub(crate) fn crate_root_impl(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let module_id = loc.module_id.crate_root(&module_tree);\n+        Module::from_module_id(db, loc.source_root_id, module_id)\n+    }\n+    /// Finds a child module with the specified name.\n+    pub fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let child_id = ctry!(loc.module_id.child(&module_tree, name));\n+        Module::from_module_id(db, loc.source_root_id, child_id).map(Some)\n+    }\n+    pub fn parent_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let parent_id = ctry!(loc.module_id.parent(&module_tree));\n+        Module::from_module_id(db, loc.source_root_id, parent_id).map(Some)\n+    }\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope_impl(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        let loc = self.def_id.loc(db);\n+        let item_map = db.item_map(loc.source_root_id)?;\n+        let res = item_map.per_module[&loc.module_id].clone();\n+        Ok(res)\n+    }\n+    pub fn resolve_path_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> Cancelable<PerNs<DefId>> {\n+        let mut curr_per_ns = PerNs::types(\n+            match path.kind {\n+                PathKind::Crate => self.crate_root(db)?,\n+                PathKind::Self_ | PathKind::Plain => self.clone(),\n+                PathKind::Super => {\n+                    if let Some(p) = self.parent(db)? {\n+                        p\n+                    } else {\n+                        return Ok(PerNs::none());\n+                    }\n+                }\n+            }\n+            .def_id,\n+        );\n+\n+        let segments = &path.segments;\n+        for name in segments.iter() {\n+            let curr = if let Some(r) = curr_per_ns.as_ref().take_types() {\n+                r\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n+            let module = match curr.resolve(db)? {\n+                Def::Module(it) => it,\n+                // TODO here would be the place to handle enum variants...\n+                _ => return Ok(PerNs::none()),\n+            };\n+            let scope = module.scope(db)?;\n+            curr_per_ns = if let Some(r) = scope.get(&name) {\n+                r.def_id\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n+        }\n+        Ok(curr_per_ns)\n+    }\n+    pub fn problems_impl(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        Ok(loc.module_id.problems(&module_tree, db))\n+    }\n+}"}, {"sha": "e4249de141e4180f676068e48b587d9c4aa7005a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -9,8 +9,8 @@ use crate::{\n     query_definitions,\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n-    module::{ModuleId, ModuleTree, ModuleSource,\n-    nameres::{ItemMap, InputModuleItems}},\n+    module_tree::{ModuleId, ModuleTree, ModuleSource},\n+    nameres::{ItemMap, InputModuleItems},\n     ty::{InferenceResult, Ty},\n     adt::{StructData, EnumData},\n     impl_block::ModuleImplBlocks,\n@@ -71,9 +71,9 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::file_item;\n     }\n \n-    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module::imp::Submodule>>> {\n+    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module_tree::Submodule>>> {\n         type SubmodulesQuery;\n-        use fn query_definitions::submodules;\n+        use fn crate::module_tree::Submodule::submodules_query;\n     }\n \n     fn input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n@@ -86,7 +86,7 @@ pub trait HirDatabase: SyntaxDatabase\n     }\n     fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n         type ModuleTreeQuery;\n-        use fn crate::module::imp::module_tree;\n+        use fn crate::module_tree::ModuleTree::module_tree_query;\n     }\n \n     fn impls_in_module(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleImplBlocks>> {"}, {"sha": "c7391ee05606df525b28cfabb55865acf5993187", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -2,7 +2,9 @@ use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n-use crate::{HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum, ImplBlock, Crate};\n+use crate::{HirDatabase, PerNs, ModuleId, Def, Function, Struct, Enum, ImplBlock, Crate};\n+\n+use crate::code_model_api::Module;\n \n /// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n@@ -151,7 +153,7 @@ impl DefId {\n         let loc = self.loc(db);\n         let res = match loc.kind {\n             DefKind::Module => {\n-                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n+                let module = Module::from_module_id(db, loc.source_root_id, loc.module_id)?;\n                 Def::Module(module)\n             }\n             DefKind::Function => {\n@@ -175,12 +177,12 @@ impl DefId {\n     /// For a module, returns that module; for any other def, returns the containing module.\n     pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n         let loc = self.loc(db);\n-        Module::new(db, loc.source_root_id, loc.module_id)\n+        Module::from_module_id(db, loc.source_root_id, loc.module_id)\n     }\n \n     /// Returns the containing crate.\n     pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n-        Ok(self.module(db)?.krate(db))\n+        Ok(self.module(db)?.krate(db)?)\n     }\n \n     /// Returns the containing impl block, if this is an impl item."}, {"sha": "7ce8d17e66420d0595d48ba349fa6769034a0c22", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -7,12 +7,14 @@ use ra_db::{LocationIntener, Cancelable, SourceRootId};\n \n use crate::{\n     DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n-    Module, Function,\n+    Function,\n     db::HirDatabase,\n     type_ref::TypeRef,\n-    module::{ModuleSourceNode, ModuleId},\n+    module_tree::ModuleId,\n };\n \n+use crate::code_model_api::{Module, ModuleSource};\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImplBlock {\n     module_impl_blocks: Arc<ModuleImplBlocks>,\n@@ -64,7 +66,7 @@ impl ImplData {\n     ) -> Self {\n         let target_trait = node.target_type().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let file_id = module.source().file_id();\n+        let module_loc = module.def_id.loc(db);\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n@@ -75,14 +77,14 @@ impl ImplData {\n                         ast::ImplItem::TypeDef(..) => DefKind::Item,\n                     };\n                     let item_id = file_items.id_of_unchecked(item_node.syntax());\n+                    let source_item_id = SourceItemId {\n+                        file_id: module_loc.source_item_id.file_id,\n+                        item_id: Some(item_id),\n+                    };\n                     let def_loc = DefLoc {\n                         kind,\n-                        source_root_id: module.source_root_id,\n-                        module_id: module.module_id,\n-                        source_item_id: SourceItemId {\n-                            file_id,\n-                            item_id: Some(item_id),\n-                        },\n+                        source_item_id,\n+                        ..module_loc\n                     };\n                     let def_id = def_loc.id(db);\n                     match item_node {\n@@ -148,13 +150,13 @@ impl ModuleImplBlocks {\n     }\n \n     fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n-        let module_source_node = module.source().resolve(db);\n-        let node = match &module_source_node {\n-            ModuleSourceNode::SourceFile(node) => node.borrowed().syntax(),\n-            ModuleSourceNode::Module(node) => node.borrowed().syntax(),\n+        let (file_id, module_source) = module.defenition_source(db)?;\n+        let node = match &module_source {\n+            ModuleSource::SourceFile(node) => node.borrowed().syntax(),\n+            ModuleSource::Module(node) => node.borrowed().syntax(),\n         };\n \n-        let source_file_items = db.file_items(module.source().file_id());\n+        let source_file_items = db.file_items(file_id.into());\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n             let impl_block = ImplData::from_ast(db, &source_file_items, &module, impl_block_ast);\n@@ -174,7 +176,7 @@ pub(crate) fn impls_in_module(\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleImplBlocks>> {\n     let mut result = ModuleImplBlocks::new();\n-    let module = Module::new(db, source_root_id, module_id)?;\n+    let module = Module::from_module_id(db, source_root_id, module_id)?;\n     result.collect(db, module)?;\n     Ok(Arc::new(result))\n }"}, {"sha": "9f133f1749156ac46306e43aa04a91baaf377ed8", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -24,16 +24,18 @@ pub mod source_binder;\n mod ids;\n mod macros;\n mod name;\n-// can't use `crate` or `r#crate` here :(\n-mod krate;\n-mod module;\n+mod module_tree;\n+mod nameres;\n mod function;\n mod adt;\n mod type_ref;\n mod ty;\n mod impl_block;\n mod expr;\n \n+mod code_model_api;\n+mod code_model_impl;\n+\n use crate::{\n     db::HirDatabase,\n     name::{AsName, KnownName},\n@@ -43,10 +45,10 @@ use crate::{\n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n-    krate::Crate,\n     ids::{HirFileId, DefId, DefLoc, MacroCallId, MacroCallLoc},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n-    module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n+    module_tree::ModuleId,\n+    nameres::{ItemMap, PerNs, Namespace, Resolution},\n     function::{Function, FnSignature, FnScopes, ScopesWithSyntaxMapping},\n     adt::{Struct, Enum},\n     ty::Ty,\n@@ -55,6 +57,11 @@ pub use self::{\n \n pub use self::function::FnSignatureInfo;\n \n+pub use self::code_model_api::{\n+    Crate, CrateDependency,\n+    Module, ModuleSource, Problem,\n+};\n+\n pub enum Def {\n     Module(Module),\n     Function(Function),"}, {"sha": "b9821115ce8ba39b232c5c3d245b2799b23ddf90", "filename": "crates/ra_hir/src/module.rs", "status": "removed", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -1,376 +0,0 @@\n-pub(super) mod imp;\n-pub(super) mod nameres;\n-\n-use std::sync::Arc;\n-use log;\n-\n-use ra_syntax::{\n-    algo::generate,\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxNode,\n-};\n-use ra_arena::{Arena, RawId, impl_arena_id};\n-use ra_db::{SourceRootId, FileId, Cancelable};\n-use relative_path::RelativePathBuf;\n-\n-use crate::{\n-    Def, DefKind, DefLoc, DefId,\n-    Name, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n-    HirFileId,\n-};\n-\n-pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n-\n-/// `Module` is API entry point to get all the information\n-/// about a particular module.\n-#[derive(Debug, Clone)]\n-pub struct Module {\n-    tree: Arc<ModuleTree>,\n-    pub(crate) source_root_id: SourceRootId,\n-    pub(crate) module_id: ModuleId,\n-}\n-\n-impl Module {\n-    pub(super) fn new(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Cancelable<Module> {\n-        let module_tree = db.module_tree(source_root_id)?;\n-        let res = Module {\n-            tree: module_tree,\n-            source_root_id,\n-            module_id,\n-        };\n-        Ok(res)\n-    }\n-\n-    /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n-    /// Returns `None` for the root module\n-    pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n-        let link = self.module_id.parent_link(&self.tree)?;\n-        let file_id = link\n-            .owner(&self.tree)\n-            .source(&self.tree)\n-            .file_id()\n-            .as_original_file();\n-        let src = link.bind_source(&self.tree, db);\n-        Some((file_id, src))\n-    }\n-\n-    pub fn file_id(&self) -> FileId {\n-        self.source().file_id().as_original_file()\n-    }\n-\n-    /// Parent module. Returns `None` if this is a root module.\n-    pub fn parent(&self) -> Option<Module> {\n-        let parent_id = self.module_id.parent(&self.tree)?;\n-        Some(Module {\n-            module_id: parent_id,\n-            ..self.clone()\n-        })\n-    }\n-\n-    /// Returns an iterator of all children of this module.\n-    pub fn children<'a>(&'a self) -> impl Iterator<Item = (Name, Module)> + 'a {\n-        self.module_id\n-            .children(&self.tree)\n-            .map(move |(name, module_id)| {\n-                (\n-                    name,\n-                    Module {\n-                        module_id,\n-                        ..self.clone()\n-                    },\n-                )\n-            })\n-    }\n-\n-    /// Returns the crate this module is part of.\n-    pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        let root_id = self.module_id.crate_root(&self.tree);\n-        let file_id = root_id.source(&self.tree).file_id().as_original_file();\n-        let crate_graph = db.crate_graph();\n-        let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n-        Some(Crate::new(crate_id))\n-    }\n-\n-    /// Returns the all modules on the way to the root.\n-    pub fn path_to_root(&self) -> Vec<Module> {\n-        generate(Some(self.clone()), move |it| it.parent()).collect::<Vec<Module>>()\n-    }\n-\n-    /// The root of the tree this module is part of\n-    pub fn crate_root(&self) -> Module {\n-        let root_id = self.module_id.crate_root(&self.tree);\n-        Module {\n-            module_id: root_id,\n-            ..self.clone()\n-        }\n-    }\n-\n-    /// `name` is `None` for the crate's root module\n-    pub fn name(&self) -> Option<&Name> {\n-        let link = self.module_id.parent_link(&self.tree)?;\n-        Some(link.name(&self.tree))\n-    }\n-\n-    pub fn def_id(&self, db: &impl HirDatabase) -> DefId {\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id: self.source_root_id,\n-            module_id: self.module_id,\n-            source_item_id: self.module_id.source(&self.tree).0,\n-        };\n-        def_loc.id(db)\n-    }\n-\n-    /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &Name) -> Option<Module> {\n-        let child_id = self.module_id.child(&self.tree, name)?;\n-        Some(Module {\n-            module_id: child_id,\n-            ..self.clone()\n-        })\n-    }\n-\n-    /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n-        let item_map = db.item_map(self.source_root_id)?;\n-        let res = item_map.per_module[&self.module_id].clone();\n-        Ok(res)\n-    }\n-\n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n-        let mut curr_per_ns = PerNs::types(\n-            match path.kind {\n-                PathKind::Crate => self.crate_root(),\n-                PathKind::Self_ | PathKind::Plain => self.clone(),\n-                PathKind::Super => {\n-                    if let Some(p) = self.parent() {\n-                        p\n-                    } else {\n-                        return Ok(PerNs::none());\n-                    }\n-                }\n-            }\n-            .def_id(db),\n-        );\n-\n-        let segments = &path.segments;\n-        for name in segments.iter() {\n-            let curr = if let Some(r) = curr_per_ns.as_ref().take(Namespace::Types) {\n-                r\n-            } else {\n-                return Ok(PerNs::none());\n-            };\n-            let module = match curr.resolve(db)? {\n-                Def::Module(it) => it,\n-                // TODO here would be the place to handle enum variants...\n-                _ => return Ok(PerNs::none()),\n-            };\n-            let scope = module.scope(db)?;\n-            curr_per_ns = if let Some(r) = scope.get(&name) {\n-                r.def_id\n-            } else {\n-                return Ok(PerNs::none());\n-            };\n-        }\n-        Ok(curr_per_ns)\n-    }\n-\n-    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n-        self.module_id.problems(&self.tree, db)\n-    }\n-\n-    pub(crate) fn source(&self) -> ModuleSource {\n-        self.module_id.source(&self.tree)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ModuleId(RawId);\n-impl_arena_id!(ModuleId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct LinkId(RawId);\n-impl_arena_id!(LinkId);\n-\n-/// Physically, rust source is organized as a set of files, but logically it is\n-/// organized as a tree of modules. Usually, a single file corresponds to a\n-/// single module, but it is not nessary the case.\n-///\n-/// Module encapsulate the logic of transitioning from the fuzzy world of files\n-/// (which can have multiple parents) to the precise world of modules (which\n-/// always have one parent).\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub struct ModuleTree {\n-    mods: Arena<ModuleId, ModuleData>,\n-    links: Arena<LinkId, LinkData>,\n-}\n-\n-impl ModuleTree {\n-    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n-        self.mods.iter().map(|(id, _)| id)\n-    }\n-\n-    pub(crate) fn modules_with_sources<'a>(\n-        &'a self,\n-    ) -> impl Iterator<Item = (ModuleId, ModuleSource)> + 'a {\n-        self.mods.iter().map(|(id, m)| (id, m.source))\n-    }\n-}\n-\n-/// `ModuleSource` is the syntax tree element that produced this module:\n-/// either a file, or an inlinde module.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct ModuleSource(SourceItemId);\n-\n-/// An owned syntax node for a module. Unlike `ModuleSource`,\n-/// this holds onto the AST for the whole file.\n-pub(crate) enum ModuleSourceNode {\n-    SourceFile(ast::SourceFileNode),\n-    Module(ast::ModuleNode),\n-}\n-\n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Problem {\n-    UnresolvedModule {\n-        candidate: RelativePathBuf,\n-    },\n-    NotDirOwner {\n-        move_to: RelativePathBuf,\n-        candidate: RelativePathBuf,\n-    },\n-}\n-\n-impl ModuleId {\n-    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n-        tree.mods[self].source\n-    }\n-    fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n-        tree.mods[self].parent\n-    }\n-    fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n-        let link = self.parent_link(tree)?;\n-        Some(tree.links[link].owner)\n-    }\n-    fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n-        generate(Some(self), move |it| it.parent(tree))\n-            .last()\n-            .unwrap()\n-    }\n-    fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n-        let link = tree.mods[self]\n-            .children\n-            .iter()\n-            .map(|&it| &tree.links[it])\n-            .find(|it| it.name == *name)?;\n-        Some(*link.points_to.first()?)\n-    }\n-    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n-        tree.mods[self].children.iter().filter_map(move |&it| {\n-            let link = &tree.links[it];\n-            let module = *link.points_to.first()?;\n-            Some((link.name.clone(), module))\n-        })\n-    }\n-    fn problems(self, tree: &ModuleTree, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n-        tree.mods[self]\n-            .children\n-            .iter()\n-            .filter_map(|&it| {\n-                let p = tree.links[it].problem.clone()?;\n-                let s = it.bind_source(tree, db);\n-                let s = s.borrowed().name().unwrap().syntax().owned();\n-                Some((s, p))\n-            })\n-            .collect()\n-    }\n-}\n-\n-impl LinkId {\n-    fn owner(self, tree: &ModuleTree) -> ModuleId {\n-        tree.links[self].owner\n-    }\n-    fn name(self, tree: &ModuleTree) -> &Name {\n-        &tree.links[self].name\n-    }\n-    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n-        let owner = self.owner(tree);\n-        match owner.source(tree).resolve(db) {\n-            ModuleSourceNode::SourceFile(root) => {\n-                let ast = imp::modules(root.borrowed())\n-                    .find(|(name, _)| name == &tree.links[self].name)\n-                    .unwrap()\n-                    .1;\n-                ast.owned()\n-            }\n-            ModuleSourceNode::Module(it) => it,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-pub struct ModuleData {\n-    source: ModuleSource,\n-    parent: Option<LinkId>,\n-    children: Vec<LinkId>,\n-}\n-\n-impl ModuleSource {\n-    // precondition: item_id **must** point to module\n-    fn new(file_id: HirFileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n-        let source_item_id = SourceItemId { file_id, item_id };\n-        ModuleSource(source_item_id)\n-    }\n-\n-    pub(crate) fn new_file(file_id: HirFileId) -> ModuleSource {\n-        ModuleSource::new(file_id, None)\n-    }\n-\n-    pub(crate) fn new_inline(\n-        db: &impl HirDatabase,\n-        file_id: HirFileId,\n-        m: ast::Module,\n-    ) -> ModuleSource {\n-        assert!(!m.has_semi());\n-        let file_items = db.file_items(file_id);\n-        let item_id = file_items.id_of(file_id, m.syntax());\n-        ModuleSource::new(file_id, Some(item_id))\n-    }\n-\n-    pub(crate) fn file_id(self) -> HirFileId {\n-        self.0.file_id\n-    }\n-\n-    pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n-        let syntax_node = db.file_item(self.0);\n-        let syntax_node = syntax_node.borrowed();\n-        if let Some(file) = ast::SourceFile::cast(syntax_node) {\n-            return ModuleSourceNode::SourceFile(file.owned());\n-        }\n-        let module = ast::Module::cast(syntax_node).unwrap();\n-        ModuleSourceNode::Module(module.owned())\n-    }\n-}\n-\n-#[derive(Hash, Debug, PartialEq, Eq)]\n-struct LinkData {\n-    owner: ModuleId,\n-    name: Name,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n-}\n-\n-impl ModuleTree {\n-    fn push_mod(&mut self, data: ModuleData) -> ModuleId {\n-        self.mods.alloc(data)\n-    }\n-    fn push_link(&mut self, data: LinkData) -> LinkId {\n-        let owner = data.owner;\n-        let id = self.links.alloc(data);\n-        self.mods[owner].children.push(id);\n-        id\n-    }\n-}"}, {"sha": "3849026dbdd7a745ccee4a1a840c019ec6d156b3", "filename": "crates/ra_hir/src/module/imp.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -1,190 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::ast::{self, NameOwner};\n-use relative_path::RelativePathBuf;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use arrayvec::ArrayVec;\n-use ra_db::{SourceRoot, SourceRootId, Cancelable, FileId};\n-\n-use crate::{\n-    HirDatabase, Name, AsName,\n-};\n-\n-use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleSource,\n-    ModuleTree, Problem,\n-};\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub enum Submodule {\n-    Declaration(Name),\n-    Definition(Name, ModuleSource),\n-}\n-\n-impl Submodule {\n-    fn name(&self) -> &Name {\n-        match self {\n-            Submodule::Declaration(name) => name,\n-            Submodule::Definition(name, _) => name,\n-        }\n-    }\n-}\n-\n-pub(crate) fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n-    root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n-            _ => None,\n-        })\n-        .filter_map(|module| {\n-            let name = module.name()?.as_name();\n-            Some((name, module))\n-        })\n-}\n-\n-pub(crate) fn module_tree(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ModuleTree>> {\n-    db.check_canceled()?;\n-    let res = create_module_tree(db, source_root)?;\n-    Ok(Arc::new(res))\n-}\n-\n-fn create_module_tree<'a>(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<ModuleTree> {\n-    let mut tree = ModuleTree::default();\n-\n-    let mut roots = FxHashMap::default();\n-    let mut visited = FxHashSet::default();\n-\n-    let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.values() {\n-        let source = ModuleSource::new_file(file_id.into());\n-        if visited.contains(&source) {\n-            continue; // TODO: use explicit crate_roots here\n-        }\n-        assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(\n-            db,\n-            &source_root,\n-            &mut tree,\n-            &mut visited,\n-            &mut roots,\n-            None,\n-            source,\n-        )?;\n-        roots.insert(file_id, module_id);\n-    }\n-    Ok(tree)\n-}\n-\n-fn build_subtree(\n-    db: &impl HirDatabase,\n-    source_root: &SourceRoot,\n-    tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<ModuleSource>,\n-    roots: &mut FxHashMap<FileId, ModuleId>,\n-    parent: Option<LinkId>,\n-    source: ModuleSource,\n-) -> Cancelable<ModuleId> {\n-    visited.insert(source);\n-    let id = tree.push_mod(ModuleData {\n-        source,\n-        parent,\n-        children: Vec::new(),\n-    });\n-    for sub in db.submodules(source)?.iter() {\n-        let link = tree.push_link(LinkData {\n-            name: sub.name().clone(),\n-            owner: id,\n-            points_to: Vec::new(),\n-            problem: None,\n-        });\n-\n-        let (points_to, problem) = match sub {\n-            Submodule::Declaration(name) => {\n-                let (points_to, problem) = resolve_submodule(db, source, &name);\n-                let points_to = points_to\n-                    .into_iter()\n-                    .map(|file_id| match roots.remove(&file_id) {\n-                        Some(module_id) => {\n-                            tree.mods[module_id].parent = Some(link);\n-                            Ok(module_id)\n-                        }\n-                        None => build_subtree(\n-                            db,\n-                            source_root,\n-                            tree,\n-                            visited,\n-                            roots,\n-                            Some(link),\n-                            ModuleSource::new_file(file_id.into()),\n-                        ),\n-                    })\n-                    .collect::<Cancelable<Vec<_>>>()?;\n-                (points_to, problem)\n-            }\n-            Submodule::Definition(_name, submodule_source) => {\n-                let points_to = build_subtree(\n-                    db,\n-                    source_root,\n-                    tree,\n-                    visited,\n-                    roots,\n-                    Some(link),\n-                    *submodule_source,\n-                )?;\n-                (vec![points_to], None)\n-            }\n-        };\n-\n-        tree.links[link].points_to = points_to;\n-        tree.links[link].problem = problem;\n-    }\n-    Ok(id)\n-}\n-\n-fn resolve_submodule(\n-    db: &impl HirDatabase,\n-    source: ModuleSource,\n-    name: &Name,\n-) -> (Vec<FileId>, Option<Problem>) {\n-    // FIXME: handle submodules of inline modules properly\n-    let file_id = source.file_id().original_file(db);\n-    let source_root_id = db.file_source_root(file_id);\n-    let path = db.file_relative_path(file_id);\n-    let root = RelativePathBuf::default();\n-    let dir_path = path.parent().unwrap_or(&root);\n-    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n-    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n-\n-    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 2]>::new();\n-    if is_dir_owner {\n-        candidates.push(file_mod.clone());\n-        candidates.push(dir_mod);\n-    } else {\n-        candidates.push(file_dir_mod.clone());\n-    };\n-    let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n-}"}, {"sha": "b7912ba5edb348172520a95da26bcffc63a18621", "filename": "crates/ra_hir/src/module_tree.rs", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -0,0 +1,409 @@\n+use std::sync::Arc;\n+\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use arrayvec::ArrayVec;\n+use relative_path::RelativePathBuf;\n+use ra_db::{FileId, SourceRootId, Cancelable, SourceRoot};\n+use ra_syntax::{\n+    algo::generate,\n+    ast::{self, AstNode, NameOwner},\n+    SyntaxNode,\n+};\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+\n+use crate::{Name, AsName, HirDatabase, SourceItemId, SourceFileItemId, HirFileId, Problem};\n+\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n+pub enum Submodule {\n+    Declaration(Name),\n+    Definition(Name, ModuleSource),\n+}\n+\n+impl Submodule {\n+    pub(crate) fn submodules_query(\n+        db: &impl HirDatabase,\n+        source: ModuleSource,\n+    ) -> Cancelable<Arc<Vec<Submodule>>> {\n+        db.check_canceled()?;\n+        let file_id = source.file_id();\n+        let submodules = match source.resolve(db) {\n+            ModuleSourceNode::SourceFile(it) => collect_submodules(db, file_id, it.borrowed()),\n+            ModuleSourceNode::Module(it) => it\n+                .borrowed()\n+                .item_list()\n+                .map(|it| collect_submodules(db, file_id, it))\n+                .unwrap_or_else(Vec::new),\n+        };\n+        return Ok(Arc::new(submodules));\n+\n+        fn collect_submodules<'a>(\n+            db: &impl HirDatabase,\n+            file_id: HirFileId,\n+            root: impl ast::ModuleItemOwner<'a>,\n+        ) -> Vec<Submodule> {\n+            modules(root)\n+                .map(|(name, m)| {\n+                    if m.has_semi() {\n+                        Submodule::Declaration(name)\n+                    } else {\n+                        let src = ModuleSource::new_inline(db, file_id, m);\n+                        Submodule::Definition(name, src)\n+                    }\n+                })\n+                .collect()\n+        }\n+    }\n+\n+    fn name(&self) -> &Name {\n+        match self {\n+            Submodule::Declaration(name) => name,\n+            Submodule::Definition(name, _) => name,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ModuleId(RawId);\n+impl_arena_id!(ModuleId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct LinkId(RawId);\n+impl_arena_id!(LinkId);\n+\n+/// Physically, rust source is organized as a set of files, but logically it is\n+/// organized as a tree of modules. Usually, a single file corresponds to a\n+/// single module, but it is not nessary the case.\n+///\n+/// Module encapsulate the logic of transitioning from the fuzzy world of files\n+/// (which can have multiple parents) to the precise world of modules (which\n+/// always have one parent).\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub struct ModuleTree {\n+    mods: Arena<ModuleId, ModuleData>,\n+    links: Arena<LinkId, LinkData>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub struct ModuleData {\n+    source: ModuleSource,\n+    parent: Option<LinkId>,\n+    children: Vec<LinkId>,\n+}\n+\n+#[derive(Hash, Debug, PartialEq, Eq)]\n+struct LinkData {\n+    owner: ModuleId,\n+    name: Name,\n+    points_to: Vec<ModuleId>,\n+    problem: Option<Problem>,\n+}\n+\n+impl ModuleTree {\n+    pub(crate) fn module_tree_query(\n+        db: &impl HirDatabase,\n+        source_root: SourceRootId,\n+    ) -> Cancelable<Arc<ModuleTree>> {\n+        db.check_canceled()?;\n+        let res = create_module_tree(db, source_root)?;\n+        Ok(Arc::new(res))\n+    }\n+\n+    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+        self.mods.iter().map(|(id, _)| id)\n+    }\n+\n+    pub(crate) fn modules_with_sources<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (ModuleId, ModuleSource)> + 'a {\n+        self.mods.iter().map(|(id, m)| (id, m.source))\n+    }\n+}\n+\n+/// `ModuleSource` is the syntax tree element that produced this module:\n+/// either a file, or an inlinde module.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct ModuleSource(pub(crate) SourceItemId);\n+\n+/// An owned syntax node for a module. Unlike `ModuleSource`,\n+/// this holds onto the AST for the whole file.\n+pub(crate) enum ModuleSourceNode {\n+    SourceFile(ast::SourceFileNode),\n+    Module(ast::ModuleNode),\n+}\n+\n+impl ModuleId {\n+    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n+        tree.mods[self].source\n+    }\n+    pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n+        tree.mods[self].parent\n+    }\n+    pub(crate) fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n+        let link = self.parent_link(tree)?;\n+        Some(tree.links[link].owner)\n+    }\n+    pub(crate) fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n+        generate(Some(self), move |it| it.parent(tree))\n+            .last()\n+            .unwrap()\n+    }\n+    pub(crate) fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n+        let link = tree.mods[self]\n+            .children\n+            .iter()\n+            .map(|&it| &tree.links[it])\n+            .find(|it| it.name == *name)?;\n+        Some(*link.points_to.first()?)\n+    }\n+    pub(crate) fn children<'a>(\n+        self,\n+        tree: &'a ModuleTree,\n+    ) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n+        tree.mods[self].children.iter().filter_map(move |&it| {\n+            let link = &tree.links[it];\n+            let module = *link.points_to.first()?;\n+            Some((link.name.clone(), module))\n+        })\n+    }\n+    pub(crate) fn problems(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl HirDatabase,\n+    ) -> Vec<(SyntaxNode, Problem)> {\n+        tree.mods[self]\n+            .children\n+            .iter()\n+            .filter_map(|&it| {\n+                let p = tree.links[it].problem.clone()?;\n+                let s = it.bind_source(tree, db);\n+                let s = s.borrowed().name().unwrap().syntax().owned();\n+                Some((s, p))\n+            })\n+            .collect()\n+    }\n+}\n+\n+impl LinkId {\n+    pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n+        tree.links[self].owner\n+    }\n+    pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n+        &tree.links[self].name\n+    }\n+    pub(crate) fn bind_source<'a>(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl HirDatabase,\n+    ) -> ast::ModuleNode {\n+        let owner = self.owner(tree);\n+        match owner.source(tree).resolve(db) {\n+            ModuleSourceNode::SourceFile(root) => {\n+                let ast = modules(root.borrowed())\n+                    .find(|(name, _)| name == &tree.links[self].name)\n+                    .unwrap()\n+                    .1;\n+                ast.owned()\n+            }\n+            ModuleSourceNode::Module(it) => it,\n+        }\n+    }\n+}\n+\n+impl ModuleSource {\n+    // precondition: item_id **must** point to module\n+    fn new(file_id: HirFileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n+        let source_item_id = SourceItemId { file_id, item_id };\n+        ModuleSource(source_item_id)\n+    }\n+\n+    pub(crate) fn new_file(file_id: HirFileId) -> ModuleSource {\n+        ModuleSource::new(file_id, None)\n+    }\n+\n+    pub(crate) fn new_inline(\n+        db: &impl HirDatabase,\n+        file_id: HirFileId,\n+        m: ast::Module,\n+    ) -> ModuleSource {\n+        assert!(!m.has_semi());\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of(file_id, m.syntax());\n+        ModuleSource::new(file_id, Some(item_id))\n+    }\n+\n+    pub(crate) fn file_id(self) -> HirFileId {\n+        self.0.file_id\n+    }\n+\n+    pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n+        let syntax_node = db.file_item(self.0);\n+        let syntax_node = syntax_node.borrowed();\n+        if let Some(file) = ast::SourceFile::cast(syntax_node) {\n+            return ModuleSourceNode::SourceFile(file.owned());\n+        }\n+        let module = ast::Module::cast(syntax_node).unwrap();\n+        ModuleSourceNode::Module(module.owned())\n+    }\n+}\n+\n+impl ModuleTree {\n+    fn push_mod(&mut self, data: ModuleData) -> ModuleId {\n+        self.mods.alloc(data)\n+    }\n+    fn push_link(&mut self, data: LinkData) -> LinkId {\n+        let owner = data.owner;\n+        let id = self.links.alloc(data);\n+        self.mods[owner].children.push(id);\n+        id\n+    }\n+}\n+\n+fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.as_name();\n+            Some((name, module))\n+        })\n+}\n+\n+fn create_module_tree<'a>(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<ModuleTree> {\n+    let mut tree = ModuleTree::default();\n+\n+    let mut roots = FxHashMap::default();\n+    let mut visited = FxHashSet::default();\n+\n+    let source_root = db.source_root(source_root);\n+    for &file_id in source_root.files.values() {\n+        let source = ModuleSource::new_file(file_id.into());\n+        if visited.contains(&source) {\n+            continue; // TODO: use explicit crate_roots here\n+        }\n+        assert!(!roots.contains_key(&file_id));\n+        let module_id = build_subtree(\n+            db,\n+            &source_root,\n+            &mut tree,\n+            &mut visited,\n+            &mut roots,\n+            None,\n+            source,\n+        )?;\n+        roots.insert(file_id, module_id);\n+    }\n+    Ok(tree)\n+}\n+\n+fn build_subtree(\n+    db: &impl HirDatabase,\n+    source_root: &SourceRoot,\n+    tree: &mut ModuleTree,\n+    visited: &mut FxHashSet<ModuleSource>,\n+    roots: &mut FxHashMap<FileId, ModuleId>,\n+    parent: Option<LinkId>,\n+    source: ModuleSource,\n+) -> Cancelable<ModuleId> {\n+    visited.insert(source);\n+    let id = tree.push_mod(ModuleData {\n+        source,\n+        parent,\n+        children: Vec::new(),\n+    });\n+    for sub in db.submodules(source)?.iter() {\n+        let link = tree.push_link(LinkData {\n+            name: sub.name().clone(),\n+            owner: id,\n+            points_to: Vec::new(),\n+            problem: None,\n+        });\n+\n+        let (points_to, problem) = match sub {\n+            Submodule::Declaration(name) => {\n+                let (points_to, problem) = resolve_submodule(db, source, &name);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| match roots.remove(&file_id) {\n+                        Some(module_id) => {\n+                            tree.mods[module_id].parent = Some(link);\n+                            Ok(module_id)\n+                        }\n+                        None => build_subtree(\n+                            db,\n+                            source_root,\n+                            tree,\n+                            visited,\n+                            roots,\n+                            Some(link),\n+                            ModuleSource::new_file(file_id.into()),\n+                        ),\n+                    })\n+                    .collect::<Cancelable<Vec<_>>>()?;\n+                (points_to, problem)\n+            }\n+            Submodule::Definition(_name, submodule_source) => {\n+                let points_to = build_subtree(\n+                    db,\n+                    source_root,\n+                    tree,\n+                    visited,\n+                    roots,\n+                    Some(link),\n+                    *submodule_source,\n+                )?;\n+                (vec![points_to], None)\n+            }\n+        };\n+\n+        tree.links[link].points_to = points_to;\n+        tree.links[link].problem = problem;\n+    }\n+    Ok(id)\n+}\n+\n+fn resolve_submodule(\n+    db: &impl HirDatabase,\n+    source: ModuleSource,\n+    name: &Name,\n+) -> (Vec<FileId>, Option<Problem>) {\n+    // FIXME: handle submodules of inline modules properly\n+    let file_id = source.file_id().original_file(db);\n+    let source_root_id = db.file_source_root(file_id);\n+    let path = db.file_relative_path(file_id);\n+    let root = RelativePathBuf::default();\n+    let dir_path = path.parent().unwrap_or(&root);\n+    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n+    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+\n+    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+    let mut candidates = ArrayVec::<[_; 2]>::new();\n+    if is_dir_owner {\n+        candidates.push(file_mod.clone());\n+        candidates.push(dir_mod);\n+    } else {\n+        candidates.push(file_dir_mod.clone());\n+    };\n+    let sr = db.source_root(source_root_id);\n+    let points_to = candidates\n+        .into_iter()\n+        .filter_map(|path| sr.files.get(&path))\n+        .map(|&it| it)\n+        .collect::<Vec<_>>();\n+    let problem = if points_to.is_empty() {\n+        Some(Problem::UnresolvedModule {\n+            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n+        })\n+    } else {\n+        None\n+    };\n+    (points_to, problem)\n+}"}, {"sha": "e65cbcb2707bf9a501939561945033856a2af8a3", "filename": "crates/ra_hir/src/nameres.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     Path, PathKind,\n     HirDatabase, Crate,\n     Name, AsName,\n-    module::{Module, ModuleId, ModuleTree},\n+    module_tree::{ModuleId, ModuleTree},\n };\n \n /// Item map is the result of the name resolution. Item map contains, for each\n@@ -177,11 +177,11 @@ impl<T> PerNs<T> {\n     }\n \n     pub fn take_types(self) -> Option<T> {\n-        self.types\n+        self.take(Namespace::Types)\n     }\n \n     pub fn take_values(self) -> Option<T> {\n-        self.values\n+        self.take(Namespace::Values)\n     }\n \n     pub fn get(&self, namespace: Namespace) -> Option<&T> {\n@@ -344,9 +344,9 @@ where\n             if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id.as_original_file())\n             {\n                 let krate = Crate::new(crate_id);\n-                for dep in krate.dependencies(self.db) {\n+                for dep in krate.dependencies(self.db)? {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n-                        let def_id = module.def_id(self.db);\n+                        let def_id = module.def_id;\n                         self.add_module_item(\n                             &mut module_items,\n                             dep.name.clone(),\n@@ -466,7 +466,7 @@ where\n                         if source_root_id == self.source_root {\n                             target_module_id\n                         } else {\n-                            let module = Module::new(self.db, source_root_id, target_module_id)?;\n+                            let module = crate::code_model_api::Module::new(type_def_id);\n                             let path = Path {\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,", "previous_filename": "crates/ra_hir/src/module/nameres.rs"}, {"sha": "dcbe65aec36a921d1157302f468ac4eec30d1615", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -17,7 +17,7 @@ fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n     let module = hir::source_binder::module_from_position(&db, pos)\n         .unwrap()\n         .unwrap();\n-    let module_id = module.module_id;\n+    let module_id = module.def_id.loc(&db).module_id;\n     (db.item_map(source_root).unwrap(), module_id)\n }\n \n@@ -155,7 +155,7 @@ fn item_map_across_crates() {\n     let module = hir::source_binder::module_from_file_id(&db, main_id)\n         .unwrap()\n         .unwrap();\n-    let module_id = module.module_id;\n+    let module_id = module.def_id.loc(&db).module_id;\n     let item_map = db.item_map(source_root).unwrap();\n \n     check_module_item_map(", "previous_filename": "crates/ra_hir/src/module/nameres/tests.rs"}, {"sha": "f4b380022ebc0b9d6fa9f1c32adcd9ddafe0cef3", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 4, "deletions": 55, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -6,20 +6,17 @@ use std::{\n use rustc_hash::FxHashMap;\n use ra_syntax::{\n     AstNode, SyntaxNode,\n-    ast::{self, NameOwner, ModuleItemOwner}\n+    ast::{self, ModuleItemOwner}\n };\n use ra_db::{SourceRootId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, DefId, Name, AsName, HirFileId,\n+    SourceFileItems, SourceItemId, DefKind, DefId, HirFileId,\n     MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n-    module::{\n-        ModuleSource, ModuleSourceNode, ModuleId,\n-        imp::Submodule,\n-        nameres::{InputModuleItems, ItemMap, Resolver},\n-    },\n+    module_tree::{ModuleId, ModuleSourceNode},\n+    nameres::{InputModuleItems, ItemMap, Resolver},\n     adt::{StructData, EnumData},\n };\n \n@@ -61,54 +58,6 @@ pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) ->\n     }\n }\n \n-pub(crate) fn submodules(\n-    db: &impl HirDatabase,\n-    source: ModuleSource,\n-) -> Cancelable<Arc<Vec<Submodule>>> {\n-    db.check_canceled()?;\n-    let file_id = source.file_id();\n-    let submodules = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => collect_submodules(db, file_id, it.borrowed()),\n-        ModuleSourceNode::Module(it) => it\n-            .borrowed()\n-            .item_list()\n-            .map(|it| collect_submodules(db, file_id, it))\n-            .unwrap_or_else(Vec::new),\n-    };\n-    return Ok(Arc::new(submodules));\n-\n-    fn collect_submodules<'a>(\n-        db: &impl HirDatabase,\n-        file_id: HirFileId,\n-        root: impl ast::ModuleItemOwner<'a>,\n-    ) -> Vec<Submodule> {\n-        modules(root)\n-            .map(|(name, m)| {\n-                if m.has_semi() {\n-                    Submodule::Declaration(name)\n-                } else {\n-                    let src = ModuleSource::new_inline(db, file_id, m);\n-                    Submodule::Definition(name, src)\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n-pub(crate) fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n-    root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n-            _ => None,\n-        })\n-        .filter_map(|module| {\n-            let name = module.name()?.as_name();\n-            Some((name, module))\n-        })\n-}\n-\n pub(super) fn input_module_items(\n     db: &impl HirDatabase,\n     source_root_id: SourceRootId,"}, {"sha": "b7e3ff9b0c56944b4fc0cb9e556b4d9b7c19002f", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0ce14351af03c620aca784ee2c03aad86b866e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=cf0ce14351af03c620aca784ee2c03aad86b866e", "patch": "@@ -13,11 +13,13 @@ use ra_syntax::{\n };\n \n use crate::{\n-    HirDatabase, Module, Function, SourceItemId,\n-    module::ModuleSource,\n+    HirDatabase, Function, SourceItemId,\n+    module_tree::ModuleSource,\n     DefKind, DefLoc, AsName,\n };\n \n+use crate::code_model_api::Module;\n+\n /// Locates the module by `FileId`. Picks topmost module in the file.\n pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable<Option<Module>> {\n     let module_source = ModuleSource::new_file(file_id.into());\n@@ -34,7 +36,7 @@ pub fn module_from_declaration(\n     let child_name = decl.name();\n     match (parent_module, child_name) {\n         (Some(parent_module), Some(child_name)) => {\n-            if let Some(child) = parent_module.child(&child_name.as_name()) {\n+            if let Some(child) = parent_module.child(db, &child_name.as_name())? {\n                 return Ok(Some(child));\n             }\n         }\n@@ -84,7 +86,15 @@ fn module_from_source(\n         .modules_with_sources()\n         .find(|(_id, src)| src == &module_source);\n     let module_id = ctry!(m).0;\n-    Ok(Some(Module::new(db, source_root_id, module_id)?))\n+    let def_loc = DefLoc {\n+        kind: DefKind::Module,\n+        source_root_id,\n+        module_id,\n+        source_item_id: module_source.0,\n+    };\n+    let def_id = def_loc.id(db);\n+\n+    Ok(Some(Module::new(def_id)))\n }\n \n pub fn function_from_position(\n@@ -114,7 +124,8 @@ pub fn function_from_module(\n     module: &Module,\n     fn_def: ast::FnDef,\n ) -> Function {\n-    let file_id = module.source().file_id();\n+    let loc = module.def_id.loc(db);\n+    let file_id = loc.source_item_id.file_id;\n     let file_items = db.file_items(file_id);\n     let item_id = file_items.id_of(file_id, fn_def.syntax());\n     let source_item_id = SourceItemId {\n@@ -123,8 +134,8 @@ pub fn function_from_module(\n     };\n     let def_loc = DefLoc {\n         kind: DefKind::Function,\n-        source_root_id: module.source_root_id,\n-        module_id: module.module_id,\n+        source_root_id: loc.source_root_id,\n+        module_id: loc.module_id,\n         source_item_id,\n     };\n     Function::new(def_loc.id(db))\n@@ -147,7 +158,8 @@ pub fn macro_symbols(\n         Some(it) => it,\n         None => return Ok(Vec::new()),\n     };\n-    let items = db.input_module_items(module.source_root_id, module.module_id)?;\n+    let loc = module.def_id.loc(db);\n+    let items = db.input_module_items(loc.source_root_id, loc.module_id)?;\n     let mut res = Vec::new();\n \n     for macro_call_id in items"}]}