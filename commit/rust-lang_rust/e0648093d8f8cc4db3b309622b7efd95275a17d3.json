{"sha": "e0648093d8f8cc4db3b309622b7efd95275a17d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjQ4MDkzZDhmOGNjNGRiM2IzMDk2MjJiN2VmZDk1Mjc1YTE3ZDM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-05-21T07:05:45Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-05-24T23:49:46Z"}, "message": "Port more stuff to mark used attributes", "tree": {"sha": "6531121b27807a9bf8eb474693fc7f950138ae90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6531121b27807a9bf8eb474693fc7f950138ae90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0648093d8f8cc4db3b309622b7efd95275a17d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0648093d8f8cc4db3b309622b7efd95275a17d3", "html_url": "https://github.com/rust-lang/rust/commit/e0648093d8f8cc4db3b309622b7efd95275a17d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0648093d8f8cc4db3b309622b7efd95275a17d3/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50181add04279eaac2b078d36823035933844226", "url": "https://api.github.com/repos/rust-lang/rust/commits/50181add04279eaac2b078d36823035933844226", "html_url": "https://github.com/rust-lang/rust/commit/50181add04279eaac2b078d36823035933844226"}], "stats": {"total": 116, "additions": 63, "deletions": 53}, "files": [{"sha": "d2b567395f020f10e5ed8de996f680bcc48cf1b2", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -176,7 +176,7 @@ pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: |Vec<@ast::MetaItem> |) {\n+                      f: |Vec<ast::Attribute> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node, f)\n }"}, {"sha": "54243ea6f1f4c1aada156cf219d482e1815ebc39", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -953,20 +953,14 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       orig_node_id: ast::NodeId,\n-                      f: |Vec<@ast::MetaItem> |) {\n+                      f: |Vec<ast::Attribute>|) {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n     let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n     let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n     let item = lookup_item(node_id, cdata.data());\n-    reader::tagged_docs(item, tag_attributes, |attributes| {\n-        reader::tagged_docs(attributes, tag_attribute, |attribute| {\n-            f(get_meta_items(attribute));\n-            true\n-        });\n-        true\n-    });\n+    f(get_attributes(item));\n }\n \n fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {"}, {"sha": "5f7376396e4a1966ab9802d98f7197e8593bebb1", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -64,7 +64,7 @@ use collections::SmallIntMap;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n-use syntax::attr::{AttrMetaMethods, AttributeMethods};\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n@@ -1148,8 +1148,7 @@ fn check_attrs_usage(cx: &Context, attrs: &[ast::Attribute]) {\n fn check_unused_attribute(cx: &Context, attrs: &[ast::Attribute]) {\n     for attr in attrs.iter() {\n         if !attr::is_used(attr) {\n-            cx.span_lint(UnusedAttribute, attr.span,\n-                         format!(\"unused attribute {}\", attr.name()).as_slice());\n+            cx.span_lint(UnusedAttribute, attr.span, \"unused attribute\");\n         }\n     }\n }\n@@ -1654,9 +1653,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     let stability = if ast_util::is_local(id) {\n         // this crate\n         let s = cx.tcx.map.with_attrs(id.node, |attrs| {\n-            attrs.map(|a| {\n-                attr::find_stability(a.iter().map(|a| a.meta()))\n-            })\n+            attrs.map(|a| attr::find_stability(a.as_slice()))\n         });\n         match s {\n             Some(s) => s,\n@@ -1672,9 +1669,9 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         let mut s = None;\n         // run through all the attributes and take the first\n         // stability one.\n-        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |meta_items| {\n+        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |attrs| {\n             if s.is_none() {\n-                s = attr::find_stability(meta_items.move_iter())\n+                s = attr::find_stability(attrs.as_slice())\n             }\n         });\n         s"}, {"sha": "da28c3008ddd02ad996021d5b6b04288546729a3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -227,10 +227,8 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n \n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n-    csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n-        set_llvm_fn_attrs(meta_items.iter().map(|&x| {\n-            attr::mk_attr_outer(attr::mk_attr_id(), x)\n-        }).collect::<Vec<_>>().as_slice(), f)\n+    csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n+        set_llvm_fn_attrs(attrs.as_slice(), f)\n     });\n \n     ccx.externs.borrow_mut().insert(name.to_strbuf(), f);"}, {"sha": "9176b33331f1af7858e26ba770e2f620055980b5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -3889,20 +3889,22 @@ pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n }\n \n-/// Iterate over meta_items of a definition.\n+/// Iterate over attributes of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: &ctxt, did: DefId, f: |@ast::MetaItem| -> bool) -> bool {\n+pub fn each_attr(tcx: &ctxt, did: DefId, f: |&ast::Attribute| -> bool) -> bool {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n-        item.attrs.iter().advance(|attr| f(attr.node.value))\n+        item.attrs.iter().advance(|attr| f(attr))\n     } else {\n+        info!(\"getting foreign attrs\");\n         let mut cont = true;\n-        csearch::get_item_attrs(&tcx.sess.cstore, did, |meta_items| {\n+        csearch::get_item_attrs(&tcx.sess.cstore, did, |attrs| {\n             if cont {\n-                cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n+                cont = attrs.iter().advance(|attr| f(attr));\n             }\n         });\n+        info!(\"done\");\n         cont\n     }\n }\n@@ -3911,7 +3913,7 @@ pub fn each_attr(tcx: &ctxt, did: DefId, f: |@ast::MetaItem| -> bool) -> bool {\n pub fn has_attr(tcx: &ctxt, did: DefId, attr: &str) -> bool {\n     let mut found = false;\n     each_attr(tcx, did, |item| {\n-        if item.name().equiv(&attr) {\n+        if item.check_name(attr) {\n             found = true;\n             false\n         } else {"}, {"sha": "b09ac8f94af983b2ff962c6fd95c54f53d4cf430", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -1091,8 +1091,8 @@ impl<'a> fmt::Show for Item<'a> {\n                     shortty(self.item), self.item.name.get_ref().as_slice()));\n \n         // Write stability attributes\n-        match attr::find_stability(self.item.attrs.iter()) {\n-            Some(ref stability) => {\n+        match attr::find_stability_generic(self.item.attrs.iter()) {\n+            Some((ref stability, _)) => {\n                 try!(write!(fmt,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),"}, {"sha": "bbd333163b593edfcd48948d25b380e188f3f227", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -238,22 +238,22 @@ pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n     metas.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n-        item.name().equiv(&name)\n+        item.check_name(name)\n     })\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n                                  -> Option<InternedString> {\n     attrs.iter()\n-        .find(|at| at.name().equiv(&name))\n+        .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<InternedString> {\n     items.iter()\n          .rev()\n-         .find(|mi| mi.name().equiv(&name))\n+         .find(|mi| mi.check_name(name))\n          .and_then(|i| i.value_str())\n }\n \n@@ -289,7 +289,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n  */\n pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<@MetaItem> {\n     let mut result = Vec::new();\n-    for attr in attrs.iter().filter(|at| at.name().equiv(&(\"link\"))) {\n+    for attr in attrs.iter().filter(|at| at.check_name(\"link\")) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(items.as_slice()),\n             _ => ()\n@@ -318,17 +318,21 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n-          MetaWord(ref n) if n.equiv(&(\"inline\")) => InlineHint,\n-          MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n-            if contains_name(items.as_slice(), \"always\") {\n-                InlineAlways\n-            } else if contains_name(items.as_slice(), \"never\") {\n-                InlineNever\n-            } else {\n+            MetaWord(ref n) if n.equiv(&(\"inline\")) => {\n+                mark_used(attr);\n                 InlineHint\n             }\n-          }\n-          _ => ia\n+            MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n+                mark_used(attr);\n+                if contains_name(items.as_slice(), \"always\") {\n+                    InlineAlways\n+                } else if contains_name(items.as_slice(), \"never\") {\n+                    InlineNever\n+                } else {\n+                    InlineHint\n+                }\n+            }\n+            _ => ia\n         }\n     })\n }\n@@ -348,7 +352,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     // this doesn't work.\n     let some_cfg_matches = metas.any(|mi| {\n         debug!(\"testing name: {}\", mi.name());\n-        if mi.name().equiv(&(\"cfg\")) { // it is a #[cfg()] attribute\n+        if mi.check_name(\"cfg\") { // it is a #[cfg()] attribute\n             debug!(\"is cfg\");\n             no_cfgs = false;\n              // only #[cfg(...)] ones are understood.\n@@ -399,11 +403,13 @@ pub enum StabilityLevel {\n     Locked\n }\n \n-/// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n-                      -> Option<Stability> {\n-    for m in metas {\n-        let level = match m.name().get() {\n+pub fn find_stability_generic<'a,\n+                              AM: AttrMetaMethods,\n+                              I: Iterator<&'a AM>>\n+                             (mut attrs: I)\n+                             -> Option<(Stability, &'a AM)> {\n+    for attr in attrs {\n+        let level = match attr.name().get() {\n             \"deprecated\" => Deprecated,\n             \"experimental\" => Experimental,\n             \"unstable\" => Unstable,\n@@ -413,14 +419,22 @@ pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n             _ => continue // not a stability level\n         };\n \n-        return Some(Stability {\n+        return Some((Stability {\n                 level: level,\n-                text: m.value_str()\n-            });\n+                text: attr.value_str()\n+            }, attr));\n     }\n     None\n }\n \n+/// Find the first stability attribute. `None` if none exists.\n+pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n+    find_stability_generic(attrs.iter()).map(|(s, attr)| {\n+        mark_used(attr);\n+        s\n+    })\n+}\n+\n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n@@ -447,11 +461,13 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n  * present (before fields, if any) with that type; reprensentation\n  * optimizations which would remove it will not be done.\n  */\n-pub fn find_repr_attr(diagnostic: &SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n+pub fn find_repr_attr(diagnostic: &SpanHandler, attr: &Attribute, acc: ReprAttr)\n     -> ReprAttr {\n     let mut acc = acc;\n-    match attr.node {\n+    info!(\"{}\", ::print::pprust::attribute_to_str(attr));\n+    match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n+            mark_used(attr);\n             for item in items.iter() {\n                 match item.node {\n                     ast::MetaWord(ref word) => {"}, {"sha": "658e4bafbe25a090dc304985a522f86392690c33", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0648093d8f8cc4db3b309622b7efd95275a17d3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e0648093d8f8cc4db3b309622b7efd95275a17d3", "patch": "@@ -265,6 +265,8 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n \n         match fld.extsbox.find(&intern(mname.get())) {\n             Some(&ItemDecorator(dec_fn)) => {\n+                attr::mark_used(attr);\n+\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: attr.span,\n                     callee: NameAndSpan {\n@@ -336,6 +338,7 @@ fn expand_item_modifiers(mut it: @ast::Item, fld: &mut MacroExpander)\n \n         match fld.extsbox.find(&intern(mname.get())) {\n             Some(&ItemModifier(dec_fn)) => {\n+                attr::mark_used(attr);\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: attr.span,\n                     callee: NameAndSpan {"}]}