{"sha": "c0c3327ade8b0caa3043425ee45842c86fbd4f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYzMzMjdhZGU4YjBjYWEzMDQzNDI1ZWU0NTg0MmM4NmZiZDRmNzY=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-06-11T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-06-15T07:56:34Z"}, "message": "Check for overflow in DroplessArena and return aligned pointer\n\n* Check for overflow when calculating the slice start & end position.\n* Align the pointer obtained from the allocator, ensuring that it\n  satisfies user requested alignment (the allocator is only asked for\n  layout compatible with u8 slice).\n* Remove an incorrect assertion from DroplessArena::align.", "tree": {"sha": "ce50521ed437aa4a0707feb5c21a29845265b745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce50521ed437aa4a0707feb5c21a29845265b745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0c3327ade8b0caa3043425ee45842c86fbd4f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c3327ade8b0caa3043425ee45842c86fbd4f76", "html_url": "https://github.com/rust-lang/rust/commit/c0c3327ade8b0caa3043425ee45842c86fbd4f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0c3327ade8b0caa3043425ee45842c86fbd4f76/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fb54ed484e2239a3e9eff3be17df00d2a162be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb54ed484e2239a3e9eff3be17df00d2a162be3", "html_url": "https://github.com/rust-lang/rust/commit/4fb54ed484e2239a3e9eff3be17df00d2a162be3"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "c8400a953a6e850b74886c745982c8b3ab72a5ef", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c0c3327ade8b0caa3043425ee45842c86fbd4f76/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c3327ade8b0caa3043425ee45842c86fbd4f76/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=c0c3327ade8b0caa3043425ee45842c86fbd4f76", "patch": "@@ -333,13 +333,6 @@ impl Default for DroplessArena {\n }\n \n impl DroplessArena {\n-    #[inline]\n-    fn align(&self, align: usize) {\n-        let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n-        self.ptr.set(final_address as *mut u8);\n-        assert!(self.ptr <= self.end);\n-    }\n-\n     #[inline(never)]\n     #[cold]\n     fn grow(&self, additional: usize) {\n@@ -370,22 +363,42 @@ impl DroplessArena {\n         }\n     }\n \n+    /// Allocates a byte slice with specified size and alignment from the\n+    /// current memory chunk. Returns `None` if there is no free space left to\n+    /// satisfy the request.\n     #[inline]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n-        unsafe {\n-            assert!(bytes != 0);\n-\n-            self.align(align);\n+    fn alloc_raw_without_grow(&self, bytes: usize, align: usize) -> Option<&mut [u8]> {\n+        let ptr = self.ptr.get() as usize;\n+        let end = self.end.get() as usize;\n+        // The allocation request fits into the current chunk iff:\n+        //\n+        // let aligned = align_to(ptr, align);\n+        // ptr <= aligned && aligned + bytes <= end\n+        //\n+        // Except that we work with fixed width integers and need to be careful\n+        // about potential overflow in the calcuation. If the overflow does\n+        // happen, then we definitely don't have enough free and need to grow\n+        // the arena.\n+        let aligned = ptr.checked_add(align - 1)? & !(align - 1);\n+        let new_ptr = aligned.checked_add(bytes)?;\n+        if new_ptr <= end {\n+            self.ptr.set(new_ptr as *mut u8);\n+            unsafe { Some(slice::from_raw_parts_mut(aligned as *mut u8, bytes)) }\n+        } else {\n+            None\n+        }\n+    }\n \n-            let future_end = intrinsics::arith_offset(self.ptr.get(), bytes as isize);\n-            if (future_end as *mut u8) > self.end.get() {\n-                self.grow(bytes);\n+    #[inline]\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n+        assert!(bytes != 0);\n+        loop {\n+            if let Some(a) = self.alloc_raw_without_grow(bytes, align) {\n+                break a;\n             }\n-\n-            let ptr = self.ptr.get();\n-            // Set the pointer past ourselves\n-            self.ptr.set(intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8);\n-            slice::from_raw_parts_mut(ptr, bytes)\n+            // No free space left. Allocate a new chunk to satisfy the request.\n+            // On failure the grow will panic or abort.\n+            self.grow(bytes);\n         }\n     }\n "}]}