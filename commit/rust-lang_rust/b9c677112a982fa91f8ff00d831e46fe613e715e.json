{"sha": "b9c677112a982fa91f8ff00d831e46fe613e715e", "node_id": "C_kwDOAAsO6NoAKGI5YzY3NzExMmE5ODJmYTkxZjhmZjAwZDgzMWU0NmZlNjEzZTcxNWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T12:56:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T12:56:44Z"}, "message": "Auto merge of #2382 - RalfJung:atomic, r=RalfJung\n\nadd support for new RMW orders\n\nImplements support for https://github.com/rust-lang/rust/pull/98383.\n\nAlso restructure intrinsic shims a bit so we have atomic and SIMD intrinsics in their own file, and refactor atomic intrinsic name parsing.", "tree": {"sha": "daed04c7143631026e9034e624157df41aac83c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daed04c7143631026e9034e624157df41aac83c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9c677112a982fa91f8ff00d831e46fe613e715e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c677112a982fa91f8ff00d831e46fe613e715e", "html_url": "https://github.com/rust-lang/rust/commit/b9c677112a982fa91f8ff00d831e46fe613e715e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9c677112a982fa91f8ff00d831e46fe613e715e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a4d71faad15cc62407c4d3134337978f4a482f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4d71faad15cc62407c4d3134337978f4a482f2", "html_url": "https://github.com/rust-lang/rust/commit/5a4d71faad15cc62407c4d3134337978f4a482f2"}, {"sha": "6ab64620a60f958883ef9dfee8515a776001b85d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab64620a60f958883ef9dfee8515a776001b85d", "html_url": "https://github.com/rust-lang/rust/commit/6ab64620a60f958883ef9dfee8515a776001b85d"}], "stats": {"total": 2878, "additions": 1408, "deletions": 1470}, "files": [{"sha": "362bcc35eade2c6e252a1c71d6ecc420dcb209e8", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -1 +1 @@\n-db41351753df840773ca628d8daa040e95d00eef\n+880416180b0a9ee1141c07d4d17667edb77daebd"}, {"sha": "8d82c912f3803081fddaa8028590ab4f81624771", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -297,8 +297,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Some(p) => p,\n         };\n \n-        // Second: functions that return.\n-        match this.emulate_foreign_item_by_name(link_name, abi, args, dest, ret)? {\n+        // Second: functions that return immediately.\n+        match this.emulate_foreign_item_by_name(link_name, abi, args, dest)? {\n             EmulateByNameResult::NeedsJumping => {\n                 trace!(\"{:?}\", this.dump_place(**dest));\n                 this.go_to_block(ret);\n@@ -355,7 +355,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n \n@@ -702,8 +701,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Platform-specific shims\n             _ => match this.tcx.sess.target.os.as_ref() {\n-                target if target_os_is_unix(target) => return shims::unix::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n-                \"windows\" => return shims::windows::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n+                target if target_os_is_unix(target) => return shims::unix::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                \"windows\" => return shims::windows::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n                 target => throw_unsup_format!(\"the target `{}` is not supported\", target),\n             }\n         };"}, {"sha": "ab79438c734de429bb79a1075d6087c75fbb4e54", "filename": "src/shims/intrinsics.rs", "status": "removed", "additions": 0, "deletions": 1423, "changes": 1423, "blob_url": "https://github.com/rust-lang/rust/blob/5a4d71faad15cc62407c4d3134337978f4a482f2/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4d71faad15cc62407c4d3134337978f4a482f2/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=5a4d71faad15cc62407c4d3134337978f4a482f2", "patch": "@@ -1,1423 +0,0 @@\n-use std::iter;\n-\n-use log::trace;\n-\n-use rustc_apfloat::{Float, Round};\n-use rustc_middle::ty::layout::{HasParamEnv, IntegerExt, LayoutOf};\n-use rustc_middle::{mir, mir::BinOp, ty, ty::FloatTy};\n-use rustc_target::abi::{Align, Endian, HasDataLayout, Integer, Size};\n-\n-use crate::*;\n-use helpers::check_arg_count;\n-\n-pub enum AtomicOp {\n-    MirOp(mir::BinOp, bool),\n-    Max,\n-    Min,\n-}\n-\n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn call_intrinsic(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        ret: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        if this.emulate_intrinsic(instance, args, dest, ret)? {\n-            return Ok(());\n-        }\n-\n-        // All supported intrinsics have a return place.\n-        let intrinsic_name = this.tcx.item_name(instance.def_id());\n-        let intrinsic_name = intrinsic_name.as_str();\n-        let ret = match ret {\n-            None => throw_unsup_format!(\"unimplemented (diverging) intrinsic: `{intrinsic_name}`\"),\n-            Some(p) => p,\n-        };\n-\n-        // Then handle terminating intrinsics.\n-        match intrinsic_name {\n-            // Miri overwriting CTFE intrinsics.\n-            \"ptr_guaranteed_eq\" => {\n-                let [left, right] = check_arg_count(args)?;\n-                let left = this.read_immediate(left)?;\n-                let right = this.read_immediate(right)?;\n-                this.binop_ignore_overflow(mir::BinOp::Eq, &left, &right, dest)?;\n-            }\n-            \"ptr_guaranteed_ne\" => {\n-                let [left, right] = check_arg_count(args)?;\n-                let left = this.read_immediate(left)?;\n-                let right = this.read_immediate(right)?;\n-                this.binop_ignore_overflow(mir::BinOp::Ne, &left, &right, dest)?;\n-            }\n-            \"const_allocate\" => {\n-                // For now, for compatibility with the run-time implementation of this, we just return null.\n-                // See <https://github.com/rust-lang/rust/issues/93935>.\n-                this.write_null(dest)?;\n-            }\n-            \"const_deallocate\" => {\n-                // complete NOP\n-            }\n-\n-            // Raw memory accesses\n-            \"volatile_load\" => {\n-                let [place] = check_arg_count(args)?;\n-                let place = this.deref_operand(place)?;\n-                this.copy_op(&place.into(), dest, /*allow_transmute*/ false)?;\n-            }\n-            \"volatile_store\" => {\n-                let [place, dest] = check_arg_count(args)?;\n-                let place = this.deref_operand(place)?;\n-                this.copy_op(dest, &place.into(), /*allow_transmute*/ false)?;\n-            }\n-\n-            \"write_bytes\" | \"volatile_set_memory\" => {\n-                let [ptr, val_byte, count] = check_arg_count(args)?;\n-                let ty = instance.substs.type_at(0);\n-                let ty_layout = this.layout_of(ty)?;\n-                let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n-                let ptr = this.read_pointer(ptr)?;\n-                let count = this.read_scalar(count)?.to_machine_usize(this)?;\n-                // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n-                // but no actual allocation can be big enough for the difference to be noticeable.\n-                let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n-                    err_ub_format!(\"overflow computing total size of `{intrinsic_name}`\")\n-                })?;\n-                this.write_bytes_ptr(\n-                    ptr,\n-                    iter::repeat(val_byte).take(byte_count.bytes() as usize),\n-                )?;\n-            }\n-\n-            // Floating-point operations\n-            \"fabsf32\" => {\n-                let [f] = check_arg_count(args)?;\n-                let f = this.read_scalar(f)?.to_f32()?;\n-                // Can be implemented in soft-floats.\n-                this.write_scalar(Scalar::from_f32(f.abs()), dest)?;\n-            }\n-            \"fabsf64\" => {\n-                let [f] = check_arg_count(args)?;\n-                let f = this.read_scalar(f)?.to_f64()?;\n-                // Can be implemented in soft-floats.\n-                this.write_scalar(Scalar::from_f64(f.abs()), dest)?;\n-            }\n-            #[rustfmt::skip]\n-            | \"sinf32\"\n-            | \"cosf32\"\n-            | \"sqrtf32\"\n-            | \"expf32\"\n-            | \"exp2f32\"\n-            | \"logf32\"\n-            | \"log10f32\"\n-            | \"log2f32\"\n-            | \"floorf32\"\n-            | \"ceilf32\"\n-            | \"truncf32\"\n-            | \"roundf32\"\n-            => {\n-                let [f] = check_arg_count(args)?;\n-                // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n-                let f = match intrinsic_name {\n-                    \"sinf32\" => f.sin(),\n-                    \"cosf32\" => f.cos(),\n-                    \"sqrtf32\" => f.sqrt(),\n-                    \"expf32\" => f.exp(),\n-                    \"exp2f32\" => f.exp2(),\n-                    \"logf32\" => f.ln(),\n-                    \"log10f32\" => f.log10(),\n-                    \"log2f32\" => f.log2(),\n-                    \"floorf32\" => f.floor(),\n-                    \"ceilf32\" => f.ceil(),\n-                    \"truncf32\" => f.trunc(),\n-                    \"roundf32\" => f.round(),\n-                    _ => bug!(),\n-                };\n-                this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n-            }\n-\n-            #[rustfmt::skip]\n-            | \"sinf64\"\n-            | \"cosf64\"\n-            | \"sqrtf64\"\n-            | \"expf64\"\n-            | \"exp2f64\"\n-            | \"logf64\"\n-            | \"log10f64\"\n-            | \"log2f64\"\n-            | \"floorf64\"\n-            | \"ceilf64\"\n-            | \"truncf64\"\n-            | \"roundf64\"\n-            => {\n-                let [f] = check_arg_count(args)?;\n-                // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n-                let f = match intrinsic_name {\n-                    \"sinf64\" => f.sin(),\n-                    \"cosf64\" => f.cos(),\n-                    \"sqrtf64\" => f.sqrt(),\n-                    \"expf64\" => f.exp(),\n-                    \"exp2f64\" => f.exp2(),\n-                    \"logf64\" => f.ln(),\n-                    \"log10f64\" => f.log10(),\n-                    \"log2f64\" => f.log2(),\n-                    \"floorf64\" => f.floor(),\n-                    \"ceilf64\" => f.ceil(),\n-                    \"truncf64\" => f.trunc(),\n-                    \"roundf64\" => f.round(),\n-                    _ => bug!(),\n-                };\n-                this.write_scalar(Scalar::from_u64(f.to_bits()), dest)?;\n-            }\n-\n-            #[rustfmt::skip]\n-            | \"fadd_fast\"\n-            | \"fsub_fast\"\n-            | \"fmul_fast\"\n-            | \"fdiv_fast\"\n-            | \"frem_fast\"\n-            => {\n-                let [a, b] = check_arg_count(args)?;\n-                let a = this.read_immediate(a)?;\n-                let b = this.read_immediate(b)?;\n-                let op = match intrinsic_name {\n-                    \"fadd_fast\" => mir::BinOp::Add,\n-                    \"fsub_fast\" => mir::BinOp::Sub,\n-                    \"fmul_fast\" => mir::BinOp::Mul,\n-                    \"fdiv_fast\" => mir::BinOp::Div,\n-                    \"frem_fast\" => mir::BinOp::Rem,\n-                    _ => bug!(),\n-                };\n-                let float_finite = |x: ImmTy<'tcx, _>| -> InterpResult<'tcx, bool> {\n-                    Ok(match x.layout.ty.kind() {\n-                        ty::Float(FloatTy::F32) => x.to_scalar()?.to_f32()?.is_finite(),\n-                        ty::Float(FloatTy::F64) => x.to_scalar()?.to_f64()?.is_finite(),\n-                        _ => bug!(\n-                            \"`{intrinsic_name}` called with non-float input type {ty:?}\",\n-                            ty = x.layout.ty,\n-                        ),\n-                    })\n-                };\n-                match (float_finite(a)?, float_finite(b)?) {\n-                    (false, false) => throw_ub_format!(\n-                        \"`{intrinsic_name}` intrinsic called with non-finite value as both parameters\",\n-                    ),\n-                    (false, _) => throw_ub_format!(\n-                        \"`{intrinsic_name}` intrinsic called with non-finite value as first parameter\",\n-                    ),\n-                    (_, false) => throw_ub_format!(\n-                        \"`{intrinsic_name}` intrinsic called with non-finite value as second parameter\",\n-                    ),\n-                    _ => {}\n-                }\n-                this.binop_ignore_overflow(op, &a, &b, dest)?;\n-            }\n-\n-            #[rustfmt::skip]\n-            | \"minnumf32\"\n-            | \"maxnumf32\"\n-            | \"copysignf32\"\n-            => {\n-                let [a, b] = check_arg_count(args)?;\n-                let a = this.read_scalar(a)?.to_f32()?;\n-                let b = this.read_scalar(b)?.to_f32()?;\n-                let res = match intrinsic_name {\n-                    \"minnumf32\" => a.min(b),\n-                    \"maxnumf32\" => a.max(b),\n-                    \"copysignf32\" => a.copy_sign(b),\n-                    _ => bug!(),\n-                };\n-                this.write_scalar(Scalar::from_f32(res), dest)?;\n-            }\n-\n-            #[rustfmt::skip]\n-            | \"minnumf64\"\n-            | \"maxnumf64\"\n-            | \"copysignf64\"\n-            => {\n-                let [a, b] = check_arg_count(args)?;\n-                let a = this.read_scalar(a)?.to_f64()?;\n-                let b = this.read_scalar(b)?.to_f64()?;\n-                let res = match intrinsic_name {\n-                    \"minnumf64\" => a.min(b),\n-                    \"maxnumf64\" => a.max(b),\n-                    \"copysignf64\" => a.copy_sign(b),\n-                    _ => bug!(),\n-                };\n-                this.write_scalar(Scalar::from_f64(res), dest)?;\n-            }\n-\n-            \"powf32\" => {\n-                let [f, f2] = check_arg_count(args)?;\n-                // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n-                let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n-                this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n-            }\n-\n-            \"powf64\" => {\n-                let [f, f2] = check_arg_count(args)?;\n-                // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n-                let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n-                this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n-            }\n-\n-            \"fmaf32\" => {\n-                let [a, b, c] = check_arg_count(args)?;\n-                let a = this.read_scalar(a)?.to_f32()?;\n-                let b = this.read_scalar(b)?.to_f32()?;\n-                let c = this.read_scalar(c)?.to_f32()?;\n-                let res = a.mul_add(b, c).value;\n-                this.write_scalar(Scalar::from_f32(res), dest)?;\n-            }\n-\n-            \"fmaf64\" => {\n-                let [a, b, c] = check_arg_count(args)?;\n-                let a = this.read_scalar(a)?.to_f64()?;\n-                let b = this.read_scalar(b)?.to_f64()?;\n-                let c = this.read_scalar(c)?.to_f64()?;\n-                let res = a.mul_add(b, c).value;\n-                this.write_scalar(Scalar::from_f64(res), dest)?;\n-            }\n-\n-            \"powif32\" => {\n-                let [f, i] = check_arg_count(args)?;\n-                // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n-                let i = this.read_scalar(i)?.to_i32()?;\n-                this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n-            }\n-\n-            \"powif64\" => {\n-                let [f, i] = check_arg_count(args)?;\n-                // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n-                let i = this.read_scalar(i)?.to_i32()?;\n-                this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n-            }\n-\n-            \"float_to_int_unchecked\" => {\n-                let [val] = check_arg_count(args)?;\n-                let val = this.read_immediate(val)?;\n-\n-                let res = match val.layout.ty.kind() {\n-                    ty::Float(FloatTy::F32) =>\n-                        this.float_to_int_unchecked(val.to_scalar()?.to_f32()?, dest.layout.ty)?,\n-                    ty::Float(FloatTy::F64) =>\n-                        this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?,\n-                    _ =>\n-                        span_bug!(\n-                            this.cur_span(),\n-                            \"`float_to_int_unchecked` called with non-float input type {:?}\",\n-                            val.layout.ty\n-                        ),\n-                };\n-\n-                this.write_scalar(res, dest)?;\n-            }\n-\n-            // SIMD operations\n-            #[rustfmt::skip]\n-            | \"simd_neg\"\n-            | \"simd_fabs\"\n-            | \"simd_ceil\"\n-            | \"simd_floor\"\n-            | \"simd_round\"\n-            | \"simd_trunc\"\n-            | \"simd_fsqrt\" => {\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, op_len);\n-\n-                #[derive(Copy, Clone)]\n-                enum HostFloatOp {\n-                    Ceil,\n-                    Floor,\n-                    Round,\n-                    Trunc,\n-                    Sqrt,\n-                }\n-                #[derive(Copy, Clone)]\n-                enum Op {\n-                    MirOp(mir::UnOp),\n-                    Abs,\n-                    HostOp(HostFloatOp),\n-                }\n-                let which = match intrinsic_name {\n-                    \"simd_neg\" => Op::MirOp(mir::UnOp::Neg),\n-                    \"simd_fabs\" => Op::Abs,\n-                    \"simd_ceil\" => Op::HostOp(HostFloatOp::Ceil),\n-                    \"simd_floor\" => Op::HostOp(HostFloatOp::Floor),\n-                    \"simd_round\" => Op::HostOp(HostFloatOp::Round),\n-                    \"simd_trunc\" => Op::HostOp(HostFloatOp::Trunc),\n-                    \"simd_fsqrt\" => Op::HostOp(HostFloatOp::Sqrt),\n-                    _ => unreachable!(),\n-                };\n-\n-                for i in 0..dest_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-                    let val = match which {\n-                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar()?,\n-                        Op::Abs => {\n-                            // Works for f32 and f64.\n-                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n-                            };\n-                            let op = op.to_scalar()?;\n-                            match float_ty {\n-                                FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n-                                FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n-                            }\n-                        }\n-                        Op::HostOp(host_op) => {\n-                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n-                            };\n-                            // FIXME using host floats\n-                            match float_ty {\n-                                FloatTy::F32 => {\n-                                    let f = f32::from_bits(op.to_scalar()?.to_u32()?);\n-                                    let res = match host_op {\n-                                        HostFloatOp::Ceil => f.ceil(),\n-                                        HostFloatOp::Floor => f.floor(),\n-                                        HostFloatOp::Round => f.round(),\n-                                        HostFloatOp::Trunc => f.trunc(),\n-                                        HostFloatOp::Sqrt => f.sqrt(),\n-                                    };\n-                                    Scalar::from_u32(res.to_bits())\n-                                }\n-                                FloatTy::F64 => {\n-                                    let f = f64::from_bits(op.to_scalar()?.to_u64()?);\n-                                    let res = match host_op {\n-                                        HostFloatOp::Ceil => f.ceil(),\n-                                        HostFloatOp::Floor => f.floor(),\n-                                        HostFloatOp::Round => f.round(),\n-                                        HostFloatOp::Trunc => f.trunc(),\n-                                        HostFloatOp::Sqrt => f.sqrt(),\n-                                    };\n-                                    Scalar::from_u64(res.to_bits())\n-                                }\n-                            }\n-\n-                        }\n-                    };\n-                    this.write_scalar(val, &dest.into())?;\n-                }\n-            }\n-            #[rustfmt::skip]\n-            | \"simd_add\"\n-            | \"simd_sub\"\n-            | \"simd_mul\"\n-            | \"simd_div\"\n-            | \"simd_rem\"\n-            | \"simd_shl\"\n-            | \"simd_shr\"\n-            | \"simd_and\"\n-            | \"simd_or\"\n-            | \"simd_xor\"\n-            | \"simd_eq\"\n-            | \"simd_ne\"\n-            | \"simd_lt\"\n-            | \"simd_le\"\n-            | \"simd_gt\"\n-            | \"simd_ge\"\n-            | \"simd_fmax\"\n-            | \"simd_fmin\"\n-            | \"simd_saturating_add\"\n-            | \"simd_saturating_sub\"\n-            | \"simd_arith_offset\" => {\n-                use mir::BinOp;\n-\n-                let [left, right] = check_arg_count(args)?;\n-                let (left, left_len) = this.operand_to_simd(left)?;\n-                let (right, right_len) = this.operand_to_simd(right)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, left_len);\n-                assert_eq!(dest_len, right_len);\n-\n-                enum Op {\n-                    MirOp(BinOp),\n-                    SaturatingOp(BinOp),\n-                    FMax,\n-                    FMin,\n-                    WrappingOffset,\n-                }\n-                let which = match intrinsic_name {\n-                    \"simd_add\" => Op::MirOp(BinOp::Add),\n-                    \"simd_sub\" => Op::MirOp(BinOp::Sub),\n-                    \"simd_mul\" => Op::MirOp(BinOp::Mul),\n-                    \"simd_div\" => Op::MirOp(BinOp::Div),\n-                    \"simd_rem\" => Op::MirOp(BinOp::Rem),\n-                    \"simd_shl\" => Op::MirOp(BinOp::Shl),\n-                    \"simd_shr\" => Op::MirOp(BinOp::Shr),\n-                    \"simd_and\" => Op::MirOp(BinOp::BitAnd),\n-                    \"simd_or\" => Op::MirOp(BinOp::BitOr),\n-                    \"simd_xor\" => Op::MirOp(BinOp::BitXor),\n-                    \"simd_eq\" => Op::MirOp(BinOp::Eq),\n-                    \"simd_ne\" => Op::MirOp(BinOp::Ne),\n-                    \"simd_lt\" => Op::MirOp(BinOp::Lt),\n-                    \"simd_le\" => Op::MirOp(BinOp::Le),\n-                    \"simd_gt\" => Op::MirOp(BinOp::Gt),\n-                    \"simd_ge\" => Op::MirOp(BinOp::Ge),\n-                    \"simd_fmax\" => Op::FMax,\n-                    \"simd_fmin\" => Op::FMin,\n-                    \"simd_saturating_add\" => Op::SaturatingOp(BinOp::Add),\n-                    \"simd_saturating_sub\" => Op::SaturatingOp(BinOp::Sub),\n-                    \"simd_arith_offset\" => Op::WrappingOffset,\n-                    _ => unreachable!(),\n-                };\n-\n-                for i in 0..dest_len {\n-                    let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n-                    let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-                    let val = match which {\n-                        Op::MirOp(mir_op) => {\n-                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n-                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n-                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n-                                // See <https://github.com/rust-lang/rust/issues/91237>.\n-                                if overflowed {\n-                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n-                                    throw_ub_format!(\"overflowing shift by {r_val} in `{intrinsic_name}` in SIMD lane {i}\");\n-                                }\n-                            }\n-                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n-                                // Special handling for boolean-returning operations\n-                                assert_eq!(ty, this.tcx.types.bool);\n-                                let val = val.to_bool().unwrap();\n-                                bool_to_simd_element(val, dest.layout.size)\n-                            } else {\n-                                assert_ne!(ty, this.tcx.types.bool);\n-                                assert_eq!(ty, dest.layout.ty);\n-                                val\n-                            }\n-                        }\n-                        Op::SaturatingOp(mir_op) => {\n-                            this.saturating_arith(mir_op, &left, &right)?\n-                        }\n-                        Op::WrappingOffset => {\n-                            let ptr = this.scalar_to_ptr(left.to_scalar()?)?;\n-                            let offset_count = right.to_scalar()?.to_machine_isize(this)?;\n-                            let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n-\n-                            let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n-                            let offset_bytes = offset_count.wrapping_mul(pointee_size);\n-                            let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, this);\n-                            Scalar::from_maybe_pointer(offset_ptr, this)\n-                        }\n-                        Op::FMax => {\n-                            fmax_op(&left, &right)?\n-                        }\n-                        Op::FMin => {\n-                            fmin_op(&left, &right)?\n-                        }\n-                    };\n-                    this.write_scalar(val, &dest.into())?;\n-                }\n-            }\n-            \"simd_fma\" => {\n-                let [a, b, c] = check_arg_count(args)?;\n-                let (a, a_len) = this.operand_to_simd(a)?;\n-                let (b, b_len) = this.operand_to_simd(b)?;\n-                let (c, c_len) = this.operand_to_simd(c)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, a_len);\n-                assert_eq!(dest_len, b_len);\n-                assert_eq!(dest_len, c_len);\n-\n-                for i in 0..dest_len {\n-                    let a = this.read_immediate(&this.mplace_index(&a, i)?.into())?.to_scalar()?;\n-                    let b = this.read_immediate(&this.mplace_index(&b, i)?.into())?.to_scalar()?;\n-                    let c = this.read_immediate(&this.mplace_index(&c, i)?.into())?.to_scalar()?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    // Works for f32 and f64.\n-                    let ty::Float(float_ty) = dest.layout.ty.kind() else {\n-                        span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n-                    };\n-                    let val = match float_ty {\n-                        FloatTy::F32 =>\n-                            Scalar::from_f32(a.to_f32()?.mul_add(b.to_f32()?, c.to_f32()?).value),\n-                        FloatTy::F64 =>\n-                            Scalar::from_f64(a.to_f64()?.mul_add(b.to_f64()?, c.to_f64()?).value),\n-                    };\n-                    this.write_scalar(val, &dest.into())?;\n-                }\n-            }\n-            #[rustfmt::skip]\n-            | \"simd_reduce_and\"\n-            | \"simd_reduce_or\"\n-            | \"simd_reduce_xor\"\n-            | \"simd_reduce_any\"\n-            | \"simd_reduce_all\"\n-            | \"simd_reduce_max\"\n-            | \"simd_reduce_min\" => {\n-                use mir::BinOp;\n-\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-\n-                let imm_from_bool =\n-                    |b| ImmTy::from_scalar(Scalar::from_bool(b), this.machine.layouts.bool);\n-\n-                enum Op {\n-                    MirOp(BinOp),\n-                    MirOpBool(BinOp),\n-                    Max,\n-                    Min,\n-                }\n-                let which = match intrinsic_name {\n-                    \"simd_reduce_and\" => Op::MirOp(BinOp::BitAnd),\n-                    \"simd_reduce_or\" => Op::MirOp(BinOp::BitOr),\n-                    \"simd_reduce_xor\" => Op::MirOp(BinOp::BitXor),\n-                    \"simd_reduce_any\" => Op::MirOpBool(BinOp::BitOr),\n-                    \"simd_reduce_all\" => Op::MirOpBool(BinOp::BitAnd),\n-                    \"simd_reduce_max\" => Op::Max,\n-                    \"simd_reduce_min\" => Op::Min,\n-                    _ => unreachable!(),\n-                };\n-\n-                // Initialize with first lane, then proceed with the rest.\n-                let mut res = this.read_immediate(&this.mplace_index(&op, 0)?.into())?;\n-                if matches!(which, Op::MirOpBool(_)) {\n-                    // Convert to `bool` scalar.\n-                    res = imm_from_bool(simd_element_to_bool(res)?);\n-                }\n-                for i in 1..op_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    res = match which {\n-                        Op::MirOp(mir_op) => {\n-                            this.binary_op(mir_op, &res, &op)?\n-                        }\n-                        Op::MirOpBool(mir_op) => {\n-                            let op = imm_from_bool(simd_element_to_bool(op)?);\n-                            this.binary_op(mir_op, &res, &op)?\n-                        }\n-                        Op::Max => {\n-                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n-                                ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n-                            } else {\n-                                // Just boring integers, so NaNs to worry about\n-                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar()?.to_bool()? {\n-                                    res\n-                                } else {\n-                                    op\n-                                }\n-                            }\n-                        }\n-                        Op::Min => {\n-                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n-                                ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n-                            } else {\n-                                // Just boring integers, so NaNs to worry about\n-                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar()?.to_bool()? {\n-                                    res\n-                                } else {\n-                                    op\n-                                }\n-                            }\n-                        }\n-                    };\n-                }\n-                this.write_immediate(*res, dest)?;\n-            }\n-            #[rustfmt::skip]\n-            | \"simd_reduce_add_ordered\"\n-            | \"simd_reduce_mul_ordered\" => {\n-                use mir::BinOp;\n-\n-                let [op, init] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let init = this.read_immediate(init)?;\n-\n-                let mir_op = match intrinsic_name {\n-                    \"simd_reduce_add_ordered\" => BinOp::Add,\n-                    \"simd_reduce_mul_ordered\" => BinOp::Mul,\n-                    _ => unreachable!(),\n-                };\n-\n-                let mut res = init;\n-                for i in 0..op_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    res = this.binary_op(mir_op, &res, &op)?;\n-                }\n-                this.write_immediate(*res, dest)?;\n-            }\n-            \"simd_select\" => {\n-                let [mask, yes, no] = check_arg_count(args)?;\n-                let (mask, mask_len) = this.operand_to_simd(mask)?;\n-                let (yes, yes_len) = this.operand_to_simd(yes)?;\n-                let (no, no_len) = this.operand_to_simd(no)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, mask_len);\n-                assert_eq!(dest_len, yes_len);\n-                assert_eq!(dest_len, no_len);\n-\n-                for i in 0..dest_len {\n-                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n-                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n-                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if simd_element_to_bool(mask)? { yes } else { no };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-            }\n-            \"simd_select_bitmask\" => {\n-                let [mask, yes, no] = check_arg_count(args)?;\n-                let (yes, yes_len) = this.operand_to_simd(yes)?;\n-                let (no, no_len) = this.operand_to_simd(no)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-                let bitmask_len = dest_len.max(8);\n-\n-                assert!(mask.layout.ty.is_integral());\n-                assert!(bitmask_len <= 64);\n-                assert_eq!(bitmask_len, mask.layout.size.bits());\n-                assert_eq!(dest_len, yes_len);\n-                assert_eq!(dest_len, no_len);\n-\n-                let mask: u64 = this\n-                    .read_scalar(mask)?\n-                    .check_init()?\n-                    .to_bits(mask.layout.size)?\n-                    .try_into()\n-                    .unwrap();\n-                for i in 0..dest_len {\n-                    let mask =\n-                        mask & (1 << simd_bitmask_index(i, dest_len, this.data_layout().endian));\n-                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n-                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if mask != 0 { yes } else { no };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-                for i in dest_len..bitmask_len {\n-                    // If the mask is \"padded\", ensure that padding is all-zero.\n-                    let mask = mask & (1 << i);\n-                    if mask != 0 {\n-                        throw_ub_format!(\n-                            \"a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\"\n-                        );\n-                    }\n-                }\n-            }\n-            #[rustfmt::skip]\n-            \"simd_cast\" | \"simd_as\" => {\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, op_len);\n-\n-                let safe_cast = intrinsic_name == \"simd_as\";\n-\n-                for i in 0..dest_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n-                        // Int-to-(int|float): always safe\n-                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n-                        // Float-to-float: always safe\n-                        (ty::Float(_), ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n-                        // Float-to-int in safe mode\n-                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n-                        // Float-to-int in unchecked mode\n-                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n-                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n-                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n-                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n-                        _ =>\n-                            throw_unsup_format!(\n-                                \"Unsupported SIMD cast from element type {from_ty} to {to_ty}\",\n-                                from_ty = op.layout.ty,\n-                                to_ty = dest.layout.ty,\n-                            ),\n-                    };\n-                    this.write_immediate(val, &dest.into())?;\n-                }\n-            }\n-            \"simd_shuffle\" => {\n-                let [left, right, index] = check_arg_count(args)?;\n-                let (left, left_len) = this.operand_to_simd(left)?;\n-                let (right, right_len) = this.operand_to_simd(right)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                // `index` is an array, not a SIMD type\n-                let ty::Array(_, index_len) = index.layout.ty.kind() else {\n-                    span_bug!(this.cur_span(), \"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n-                };\n-                let index_len = index_len.eval_usize(*this.tcx, this.param_env());\n-\n-                assert_eq!(left_len, right_len);\n-                assert_eq!(index_len, dest_len);\n-\n-                for i in 0..dest_len {\n-                    let src_index: u64 = this\n-                        .read_immediate(&this.operand_index(index, i)?)?\n-                        .to_scalar()?\n-                        .to_u32()?\n-                        .into();\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if src_index < left_len {\n-                        this.read_immediate(&this.mplace_index(&left, src_index)?.into())?\n-                    } else if src_index < left_len.checked_add(right_len).unwrap() {\n-                        this.read_immediate(\n-                            &this.mplace_index(&right, src_index - left_len)?.into(),\n-                        )?\n-                    } else {\n-                        span_bug!(\n-                            this.cur_span(),\n-                            \"simd_shuffle index {src_index} is out of bounds for 2 vectors of size {left_len}\",\n-                        );\n-                    };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-            }\n-            \"simd_gather\" => {\n-                let [passthru, ptrs, mask] = check_arg_count(args)?;\n-                let (passthru, passthru_len) = this.operand_to_simd(passthru)?;\n-                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n-                let (mask, mask_len) = this.operand_to_simd(mask)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, passthru_len);\n-                assert_eq!(dest_len, ptrs_len);\n-                assert_eq!(dest_len, mask_len);\n-\n-                for i in 0..dest_len {\n-                    let passthru = this.read_immediate(&this.mplace_index(&passthru, i)?.into())?;\n-                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n-                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if simd_element_to_bool(mask)? {\n-                        let place = this.deref_operand(&ptr.into())?;\n-                        this.read_immediate(&place.into())?\n-                    } else {\n-                        passthru\n-                    };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-            }\n-            \"simd_scatter\" => {\n-                let [value, ptrs, mask] = check_arg_count(args)?;\n-                let (value, value_len) = this.operand_to_simd(value)?;\n-                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n-                let (mask, mask_len) = this.operand_to_simd(mask)?;\n-\n-                assert_eq!(ptrs_len, value_len);\n-                assert_eq!(ptrs_len, mask_len);\n-\n-                for i in 0..ptrs_len {\n-                    let value = this.read_immediate(&this.mplace_index(&value, i)?.into())?;\n-                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n-                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n-\n-                    if simd_element_to_bool(mask)? {\n-                        let place = this.deref_operand(&ptr.into())?;\n-                        this.write_immediate(*value, &place.into())?;\n-                    }\n-                }\n-            }\n-            \"simd_bitmask\" => {\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let bitmask_len = op_len.max(8);\n-\n-                assert!(dest.layout.ty.is_integral());\n-                assert!(bitmask_len <= 64);\n-                assert_eq!(bitmask_len, dest.layout.size.bits());\n-\n-                let mut res = 0u64;\n-                for i in 0..op_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    if simd_element_to_bool(op)? {\n-                        res |= 1 << simd_bitmask_index(i, op_len, this.data_layout().endian);\n-                    }\n-                }\n-                this.write_int(res, dest)?;\n-            }\n-\n-            // Atomic operations\n-            \"atomic_load_seqcst\" => this.atomic_load(args, dest, AtomicReadOrd::SeqCst)?,\n-            \"atomic_load_relaxed\" => this.atomic_load(args, dest, AtomicReadOrd::Relaxed)?,\n-            \"atomic_load_acquire\" => this.atomic_load(args, dest, AtomicReadOrd::Acquire)?,\n-\n-            \"atomic_store_seqcst\" => this.atomic_store(args, AtomicWriteOrd::SeqCst)?,\n-            \"atomic_store_relaxed\" => this.atomic_store(args, AtomicWriteOrd::Relaxed)?,\n-            \"atomic_store_release\" => this.atomic_store(args, AtomicWriteOrd::Release)?,\n-\n-            \"atomic_fence_acquire\" => this.atomic_fence(args, AtomicFenceOrd::Acquire)?,\n-            \"atomic_fence_release\" => this.atomic_fence(args, AtomicFenceOrd::Release)?,\n-            \"atomic_fence_acqrel\" => this.atomic_fence(args, AtomicFenceOrd::AcqRel)?,\n-            \"atomic_fence_seqcst\" => this.atomic_fence(args, AtomicFenceOrd::SeqCst)?,\n-\n-            \"atomic_singlethreadfence_acquire\" =>\n-                this.compiler_fence(args, AtomicFenceOrd::Acquire)?,\n-            \"atomic_singlethreadfence_release\" =>\n-                this.compiler_fence(args, AtomicFenceOrd::Release)?,\n-            \"atomic_singlethreadfence_acqrel\" =>\n-                this.compiler_fence(args, AtomicFenceOrd::AcqRel)?,\n-            \"atomic_singlethreadfence_seqcst\" =>\n-                this.compiler_fence(args, AtomicFenceOrd::SeqCst)?,\n-\n-            \"atomic_xchg_seqcst\" => this.atomic_exchange(args, dest, AtomicRwOrd::SeqCst)?,\n-            \"atomic_xchg_acquire\" => this.atomic_exchange(args, dest, AtomicRwOrd::Acquire)?,\n-            \"atomic_xchg_release\" => this.atomic_exchange(args, dest, AtomicRwOrd::Release)?,\n-            \"atomic_xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOrd::AcqRel)?,\n-            \"atomic_xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOrd::Relaxed)?,\n-\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_acquire_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_release_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_acqrel_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_acquire_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchg_seqcst_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n-\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_acquire_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_release_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_acqrel_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_acquire_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_cxchgweak_seqcst_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n-\n-            #[rustfmt::skip]\n-            \"atomic_or_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_or_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_or_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"atomic_or_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"atomic_or_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_xor_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_xor_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_xor_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"atomic_xor_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"atomic_xor_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_and_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_and_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_and_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"atomic_and_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"atomic_and_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_nand_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_nand_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_nand_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"atomic_nand_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"atomic_nand_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_xadd_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_xadd_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_xadd_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"atomic_xadd_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"atomic_xadd_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"atomic_xsub_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"atomic_xsub_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"atomic_xsub_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"atomic_xsub_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"atomic_xsub_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Relaxed)?,\n-            \"atomic_min_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n-            \"atomic_min_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n-            \"atomic_min_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n-            \"atomic_min_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n-            \"atomic_min_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n-            \"atomic_max_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n-            \"atomic_max_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n-            \"atomic_max_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n-            \"atomic_max_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n-            \"atomic_max_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n-            \"atomic_umin_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n-            \"atomic_umin_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n-            \"atomic_umin_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n-            \"atomic_umin_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n-            \"atomic_umin_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n-            \"atomic_umax_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n-            \"atomic_umax_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n-            \"atomic_umax_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n-            \"atomic_umax_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n-            \"atomic_umax_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n-\n-            // Other\n-            \"exact_div\" => {\n-                let [num, denom] = check_arg_count(args)?;\n-                this.exact_div(&this.read_immediate(num)?, &this.read_immediate(denom)?, dest)?;\n-            }\n-\n-            \"try\" => return this.handle_try(args, dest, ret),\n-\n-            \"breakpoint\" => {\n-                let [] = check_arg_count(args)?;\n-                // normally this would raise a SIGTRAP, which aborts if no debugger is connected\n-                throw_machine_stop!(TerminationInfo::Abort(\"Trace/breakpoint trap\".to_string()))\n-            }\n-\n-            name => throw_unsup_format!(\"unimplemented intrinsic: `{name}`\"),\n-        }\n-\n-        trace!(\"{:?}\", this.dump_place(**dest));\n-        this.go_to_block(ret);\n-        Ok(())\n-    }\n-\n-    fn atomic_load(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        let [place] = check_arg_count(args)?;\n-        let place = this.deref_operand(place)?;\n-\n-        // make sure it fits into a scalar; otherwise it cannot be atomic\n-        let val = this.read_scalar_atomic(&place, atomic)?;\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-        // Perform regular access.\n-        this.write_scalar(val, dest)?;\n-        Ok(())\n-    }\n-\n-    fn atomic_store(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicWriteOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        let [place, val] = check_arg_count(args)?;\n-        let place = this.deref_operand(place)?;\n-        let val = this.read_scalar(val)?; // make sure it fits into a scalar; otherwise it cannot be atomic\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n-        // Perform atomic store\n-        this.write_scalar_atomic(val, &place, atomic)?;\n-        Ok(())\n-    }\n-\n-    fn compiler_fence(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicFenceOrd,\n-    ) -> InterpResult<'tcx> {\n-        let [] = check_arg_count(args)?;\n-        let _ = atomic;\n-        //FIXME: compiler fences are currently ignored\n-        Ok(())\n-    }\n-\n-    fn atomic_fence(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicFenceOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let [] = check_arg_count(args)?;\n-        this.validate_atomic_fence(atomic)?;\n-        Ok(())\n-    }\n-\n-    fn atomic_op(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        atomic_op: AtomicOp,\n-        atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        let [place, rhs] = check_arg_count(args)?;\n-        let place = this.deref_operand(place)?;\n-\n-        if !place.layout.ty.is_integral() && !place.layout.ty.is_unsafe_ptr() {\n-            span_bug!(\n-                this.cur_span(),\n-                \"atomic arithmetic operations only work on integer and raw pointer types\",\n-            );\n-        }\n-        let rhs = this.read_immediate(rhs)?;\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n-        match atomic_op {\n-            AtomicOp::Min => {\n-                let old = this.atomic_min_max_scalar(&place, rhs, true, atomic)?;\n-                this.write_immediate(*old, dest)?; // old value is returned\n-                Ok(())\n-            }\n-            AtomicOp::Max => {\n-                let old = this.atomic_min_max_scalar(&place, rhs, false, atomic)?;\n-                this.write_immediate(*old, dest)?; // old value is returned\n-                Ok(())\n-            }\n-            AtomicOp::MirOp(op, neg) => {\n-                let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n-                this.write_immediate(*old, dest)?; // old value is returned\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    fn atomic_exchange(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        let [place, new] = check_arg_count(args)?;\n-        let place = this.deref_operand(place)?;\n-        let new = this.read_scalar(new)?;\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n-        let old = this.atomic_exchange_scalar(&place, new, atomic)?;\n-        this.write_scalar(old, dest)?; // old value is returned\n-        Ok(())\n-    }\n-\n-    fn atomic_compare_exchange_impl(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOrd,\n-        fail: AtomicReadOrd,\n-        can_fail_spuriously: bool,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        let [place, expect_old, new] = check_arg_count(args)?;\n-        let place = this.deref_operand(place)?;\n-        let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n-        let new = this.read_scalar(new)?;\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n-        let old = this.atomic_compare_exchange_scalar(\n-            &place,\n-            &expect_old,\n-            new,\n-            success,\n-            fail,\n-            can_fail_spuriously,\n-        )?;\n-\n-        // Return old value.\n-        this.write_immediate(old, dest)?;\n-        Ok(())\n-    }\n-\n-    fn atomic_compare_exchange(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOrd,\n-        fail: AtomicReadOrd,\n-    ) -> InterpResult<'tcx> {\n-        self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n-    }\n-\n-    fn atomic_compare_exchange_weak(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOrd,\n-        fail: AtomicReadOrd,\n-    ) -> InterpResult<'tcx> {\n-        self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n-    }\n-\n-    fn float_to_int_unchecked<F>(\n-        &self,\n-        f: F,\n-        dest_ty: ty::Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<Tag>>\n-    where\n-        F: Float + Into<Scalar<Tag>>,\n-    {\n-        let this = self.eval_context_ref();\n-\n-        // Step 1: cut off the fractional part of `f`. The result of this is\n-        // guaranteed to be precisely representable in IEEE floats.\n-        let f = f.round_to_integral(Round::TowardZero).value;\n-\n-        // Step 2: Cast the truncated float to the target integer type and see if we lose any information in this step.\n-        Ok(match dest_ty.kind() {\n-            // Unsigned\n-            ty::Uint(t) => {\n-                let size = Integer::from_uint_ty(this, *t).size();\n-                let res = f.to_u128(size.bits_usize());\n-                if res.status.is_empty() {\n-                    // No status flags means there was no further rounding or other loss of precision.\n-                    Scalar::from_uint(res.value, size)\n-                } else {\n-                    // `f` was not representable in this integer type.\n-                    throw_ub_format!(\n-                        \"`float_to_int_unchecked` intrinsic called on {f} which cannot be represented in target type `{dest_ty:?}`\",\n-                    );\n-                }\n-            }\n-            // Signed\n-            ty::Int(t) => {\n-                let size = Integer::from_int_ty(this, *t).size();\n-                let res = f.to_i128(size.bits_usize());\n-                if res.status.is_empty() {\n-                    // No status flags means there was no further rounding or other loss of precision.\n-                    Scalar::from_int(res.value, size)\n-                } else {\n-                    // `f` was not representable in this integer type.\n-                    throw_ub_format!(\n-                        \"`float_to_int_unchecked` intrinsic called on {f} which cannot be represented in target type `{dest_ty:?}`\",\n-                    );\n-                }\n-            }\n-            // Nothing else\n-            _ =>\n-                span_bug!(\n-                    this.cur_span(),\n-                    \"`float_to_int_unchecked` called with non-int output type {dest_ty:?}\"\n-                ),\n-        })\n-    }\n-}\n-\n-fn fmax_op<'tcx>(\n-    left: &ImmTy<'tcx, Tag>,\n-    right: &ImmTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n-    assert_eq!(left.layout.ty, right.layout.ty);\n-    let ty::Float(float_ty) = left.layout.ty.kind() else {\n-        bug!(\"fmax operand is not a float\")\n-    };\n-    let left = left.to_scalar()?;\n-    let right = right.to_scalar()?;\n-    Ok(match float_ty {\n-        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n-        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n-    })\n-}\n-\n-fn fmin_op<'tcx>(\n-    left: &ImmTy<'tcx, Tag>,\n-    right: &ImmTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n-    assert_eq!(left.layout.ty, right.layout.ty);\n-    let ty::Float(float_ty) = left.layout.ty.kind() else {\n-        bug!(\"fmin operand is not a float\")\n-    };\n-    let left = left.to_scalar()?;\n-    let right = right.to_scalar()?;\n-    Ok(match float_ty {\n-        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n-        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n-    })\n-}\n-\n-fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n-    // SIMD uses all-1 as pattern for \"true\"\n-    let val = if b { -1 } else { 0 };\n-    Scalar::from_int(val, size)\n-}\n-\n-fn simd_element_to_bool(elem: ImmTy<'_, Tag>) -> InterpResult<'_, bool> {\n-    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n-    Ok(match val {\n-        0 => false,\n-        -1 => true,\n-        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n-    })\n-}\n-\n-fn simd_bitmask_index(idx: u64, vec_len: u64, endianess: Endian) -> u64 {\n-    assert!(idx < vec_len);\n-    match endianess {\n-        Endian::Little => idx,\n-        Endian::Big => vec_len - 1 - idx, // reverse order of bits\n-    }\n-}"}, {"sha": "78e13a498ce1b34eb2f961768e350b75beb4d0f1", "filename": "src/shims/intrinsics/atomic.rs", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fatomic.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -0,0 +1,340 @@\n+use rustc_middle::{mir, mir::BinOp, ty};\n+use rustc_target::abi::Align;\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+pub enum AtomicOp {\n+    /// The `bool` indicates whether the result of the operation should be negated\n+    /// (must be a boolean-typed operation).\n+    MirOp(mir::BinOp, bool),\n+    Max,\n+    Min,\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Calls the atomic intrinsic `intrinsic`; the `atomic_` prefix has already been removed.\n+    fn emulate_atomic_intrinsic(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let intrinsic_structure: Vec<_> = intrinsic_name.split('_').collect();\n+\n+        fn read_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicReadOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicReadOrd::SeqCst,\n+                \"acquire\" => AtomicReadOrd::Acquire,\n+                \"relaxed\" => AtomicReadOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported read ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn write_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicWriteOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicWriteOrd::SeqCst,\n+                \"release\" => AtomicWriteOrd::Release,\n+                \"relaxed\" => AtomicWriteOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported write ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn rw_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicRwOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicRwOrd::SeqCst,\n+                \"acqrel\" => AtomicRwOrd::AcqRel,\n+                \"acquire\" => AtomicRwOrd::Acquire,\n+                \"release\" => AtomicRwOrd::Release,\n+                \"relaxed\" => AtomicRwOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported read-write ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn fence_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicFenceOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicFenceOrd::SeqCst,\n+                \"acqrel\" => AtomicFenceOrd::AcqRel,\n+                \"acquire\" => AtomicFenceOrd::Acquire,\n+                \"release\" => AtomicFenceOrd::Release,\n+                _ => throw_unsup_format!(\"unsupported fence ordering `{ord}`\"),\n+            })\n+        }\n+\n+        match &*intrinsic_structure {\n+            [\"load\", ord] => this.atomic_load(args, dest, read_ord(ord)?)?,\n+            [\"store\", ord] => this.atomic_store(args, write_ord(ord)?)?,\n+\n+            [\"fence\", ord] => this.atomic_fence(args, fence_ord(ord)?)?,\n+            [\"singlethreadfence\", ord] => this.compiler_fence(args, fence_ord(ord)?)?,\n+\n+            [\"xchg\", ord] => this.atomic_exchange(args, dest, rw_ord(ord)?)?,\n+            [\"cxchg\", ord1, ord2] =>\n+                this.atomic_compare_exchange(args, dest, rw_ord(ord1)?, read_ord(ord2)?)?,\n+            [\"cxchgweak\", ord1, ord2] =>\n+                this.atomic_compare_exchange_weak(args, dest, rw_ord(ord1)?, read_ord(ord2)?)?,\n+\n+            [\"or\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), rw_ord(ord)?)?,\n+            [\"xor\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), rw_ord(ord)?)?,\n+            [\"and\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), rw_ord(ord)?)?,\n+            [\"nand\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), rw_ord(ord)?)?,\n+            [\"xadd\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), rw_ord(ord)?)?,\n+            [\"xsub\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), rw_ord(ord)?)?,\n+            [\"min\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Int(_)));\n+                this.atomic_op(args, dest, AtomicOp::Min, rw_ord(ord)?)?;\n+            }\n+            [\"umin\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Uint(_)));\n+                this.atomic_op(args, dest, AtomicOp::Min, rw_ord(ord)?)?;\n+            }\n+            [\"max\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Int(_)));\n+                this.atomic_op(args, dest, AtomicOp::Max, rw_ord(ord)?)?;\n+            }\n+            [\"umax\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Uint(_)));\n+                this.atomic_op(args, dest, AtomicOp::Max, rw_ord(ord)?)?;\n+            }\n+\n+            _ => throw_unsup_format!(\"unimplemented intrinsic: `atomic_{intrinsic_name}`\"),\n+        }\n+        Ok(())\n+    }\n+\n+    fn atomic_load(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        atomic: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+\n+        // make sure it fits into a scalar; otherwise it cannot be atomic\n+        let val = this.read_scalar_atomic(&place, atomic)?;\n+\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+        // Perform regular access.\n+        this.write_scalar(val, dest)?;\n+        Ok(())\n+    }\n+\n+    fn atomic_store(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        atomic: AtomicWriteOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, val] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let val = this.read_scalar(val)?; // make sure it fits into a scalar; otherwise it cannot be atomic\n+\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+\n+        // Perform atomic store\n+        this.write_scalar_atomic(val, &place, atomic)?;\n+        Ok(())\n+    }\n+\n+    fn compiler_fence(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        atomic: AtomicFenceOrd,\n+    ) -> InterpResult<'tcx> {\n+        let [] = check_arg_count(args)?;\n+        let _ = atomic;\n+        //FIXME: compiler fences are currently ignored\n+        Ok(())\n+    }\n+\n+    fn atomic_fence(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        atomic: AtomicFenceOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let [] = check_arg_count(args)?;\n+        this.validate_atomic_fence(atomic)?;\n+        Ok(())\n+    }\n+\n+    fn atomic_op(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        atomic_op: AtomicOp,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, rhs] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let rhs = this.read_immediate(rhs)?;\n+\n+        if !place.layout.ty.is_integral() && !place.layout.ty.is_unsafe_ptr() {\n+            span_bug!(\n+                this.cur_span(),\n+                \"atomic arithmetic operations only work on integer and raw pointer types\",\n+            );\n+        }\n+        if rhs.layout.ty != place.layout.ty {\n+            span_bug!(this.cur_span(), \"atomic arithmetic operation type mismatch\");\n+        }\n+\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+\n+        match atomic_op {\n+            AtomicOp::Min => {\n+                let old = this.atomic_min_max_scalar(&place, rhs, true, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+            AtomicOp::Max => {\n+                let old = this.atomic_min_max_scalar(&place, rhs, false, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+            AtomicOp::MirOp(op, neg) => {\n+                let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn atomic_exchange(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, new] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let new = this.read_scalar(new)?;\n+\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+\n+        let old = this.atomic_exchange_scalar(&place, new, atomic)?;\n+        this.write_scalar(old, dest)?; // old value is returned\n+        Ok(())\n+    }\n+\n+    fn atomic_compare_exchange_impl(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+        can_fail_spuriously: bool,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, expect_old, new] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n+        let new = this.read_scalar(new)?;\n+\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+\n+        let old = this.atomic_compare_exchange_scalar(\n+            &place,\n+            &expect_old,\n+            new,\n+            success,\n+            fail,\n+            can_fail_spuriously,\n+        )?;\n+\n+        // Return old value.\n+        this.write_immediate(old, dest)?;\n+        Ok(())\n+    }\n+\n+    fn atomic_compare_exchange(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n+    }\n+\n+    fn atomic_compare_exchange_weak(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n+    }\n+}"}, {"sha": "9ffa40f3335353d06dfdc9e5138adaa598dbc090", "filename": "src/shims/intrinsics/mod.rs", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fmod.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -0,0 +1,426 @@\n+mod atomic;\n+mod simd;\n+\n+use std::iter;\n+\n+use log::trace;\n+\n+use rustc_apfloat::{Float, Round};\n+use rustc_middle::ty::layout::{IntegerExt, LayoutOf};\n+use rustc_middle::{mir, ty, ty::FloatTy};\n+use rustc_target::abi::Integer;\n+\n+use crate::*;\n+use atomic::EvalContextExt as _;\n+use helpers::check_arg_count;\n+use simd::EvalContextExt as _;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn call_intrinsic(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        ret: Option<mir::BasicBlock>,\n+        _unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // See if the core engine can handle this intrinsic.\n+        if this.emulate_intrinsic(instance, args, dest, ret)? {\n+            return Ok(());\n+        }\n+\n+        // All remaining supported intrinsics have a return place.\n+        let intrinsic_name = this.tcx.item_name(instance.def_id());\n+        let intrinsic_name = intrinsic_name.as_str();\n+        let ret = match ret {\n+            None => throw_unsup_format!(\"unimplemented (diverging) intrinsic: `{intrinsic_name}`\"),\n+            Some(p) => p,\n+        };\n+\n+        // Some intrinsics are special and need the \"ret\".\n+        match intrinsic_name {\n+            \"try\" => return this.handle_try(args, dest, ret),\n+            _ => {}\n+        }\n+\n+        // The rest jumps to `ret` immediately.\n+        this.emulate_intrinsic_by_name(intrinsic_name, args, dest)?;\n+\n+        trace!(\"{:?}\", this.dump_place(**dest));\n+        this.go_to_block(ret);\n+        Ok(())\n+    }\n+\n+    /// Emulates a Miri-supported intrinsic (not supported by the core engine).\n+    fn emulate_intrinsic_by_name(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        if let Some(name) = intrinsic_name.strip_prefix(\"atomic_\") {\n+            return this.emulate_atomic_intrinsic(name, args, dest);\n+        }\n+        if let Some(name) = intrinsic_name.strip_prefix(\"simd_\") {\n+            return this.emulate_simd_intrinsic(name, args, dest);\n+        }\n+\n+        match intrinsic_name {\n+            // Miri overwriting CTFE intrinsics.\n+            \"ptr_guaranteed_eq\" => {\n+                let [left, right] = check_arg_count(args)?;\n+                let left = this.read_immediate(left)?;\n+                let right = this.read_immediate(right)?;\n+                this.binop_ignore_overflow(mir::BinOp::Eq, &left, &right, dest)?;\n+            }\n+            \"ptr_guaranteed_ne\" => {\n+                let [left, right] = check_arg_count(args)?;\n+                let left = this.read_immediate(left)?;\n+                let right = this.read_immediate(right)?;\n+                this.binop_ignore_overflow(mir::BinOp::Ne, &left, &right, dest)?;\n+            }\n+            \"const_allocate\" => {\n+                // For now, for compatibility with the run-time implementation of this, we just return null.\n+                // See <https://github.com/rust-lang/rust/issues/93935>.\n+                this.write_null(dest)?;\n+            }\n+            \"const_deallocate\" => {\n+                // complete NOP\n+            }\n+\n+            // Raw memory accesses\n+            \"volatile_load\" => {\n+                let [place] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                this.copy_op(&place.into(), dest, /*allow_transmute*/ false)?;\n+            }\n+            \"volatile_store\" => {\n+                let [place, dest] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                this.copy_op(dest, &place.into(), /*allow_transmute*/ false)?;\n+            }\n+\n+            \"write_bytes\" | \"volatile_set_memory\" => {\n+                let [ptr, val_byte, count] = check_arg_count(args)?;\n+                let ty = ptr.layout.ty.builtin_deref(true).unwrap().ty;\n+                let ty_layout = this.layout_of(ty)?;\n+                let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let count = this.read_scalar(count)?.to_machine_usize(this)?;\n+                // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+                // but no actual allocation can be big enough for the difference to be noticeable.\n+                let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n+                    err_ub_format!(\"overflow computing total size of `{intrinsic_name}`\")\n+                })?;\n+                this.write_bytes_ptr(\n+                    ptr,\n+                    iter::repeat(val_byte).take(byte_count.bytes() as usize),\n+                )?;\n+            }\n+\n+            // Floating-point operations\n+            \"fabsf32\" => {\n+                let [f] = check_arg_count(args)?;\n+                let f = this.read_scalar(f)?.to_f32()?;\n+                // Can be implemented in soft-floats.\n+                this.write_scalar(Scalar::from_f32(f.abs()), dest)?;\n+            }\n+            \"fabsf64\" => {\n+                let [f] = check_arg_count(args)?;\n+                let f = this.read_scalar(f)?.to_f64()?;\n+                // Can be implemented in soft-floats.\n+                this.write_scalar(Scalar::from_f64(f.abs()), dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"sinf32\"\n+            | \"cosf32\"\n+            | \"sqrtf32\"\n+            | \"expf32\"\n+            | \"exp2f32\"\n+            | \"logf32\"\n+            | \"log10f32\"\n+            | \"log2f32\"\n+            | \"floorf32\"\n+            | \"ceilf32\"\n+            | \"truncf32\"\n+            | \"roundf32\"\n+            => {\n+                let [f] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let f = match intrinsic_name {\n+                    \"sinf32\" => f.sin(),\n+                    \"cosf32\" => f.cos(),\n+                    \"sqrtf32\" => f.sqrt(),\n+                    \"expf32\" => f.exp(),\n+                    \"exp2f32\" => f.exp2(),\n+                    \"logf32\" => f.ln(),\n+                    \"log10f32\" => f.log10(),\n+                    \"log2f32\" => f.log2(),\n+                    \"floorf32\" => f.floor(),\n+                    \"ceilf32\" => f.ceil(),\n+                    \"truncf32\" => f.trunc(),\n+                    \"roundf32\" => f.round(),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"sinf64\"\n+            | \"cosf64\"\n+            | \"sqrtf64\"\n+            | \"expf64\"\n+            | \"exp2f64\"\n+            | \"logf64\"\n+            | \"log10f64\"\n+            | \"log2f64\"\n+            | \"floorf64\"\n+            | \"ceilf64\"\n+            | \"truncf64\"\n+            | \"roundf64\"\n+            => {\n+                let [f] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let f = match intrinsic_name {\n+                    \"sinf64\" => f.sin(),\n+                    \"cosf64\" => f.cos(),\n+                    \"sqrtf64\" => f.sqrt(),\n+                    \"expf64\" => f.exp(),\n+                    \"exp2f64\" => f.exp2(),\n+                    \"logf64\" => f.ln(),\n+                    \"log10f64\" => f.log10(),\n+                    \"log2f64\" => f.log2(),\n+                    \"floorf64\" => f.floor(),\n+                    \"ceilf64\" => f.ceil(),\n+                    \"truncf64\" => f.trunc(),\n+                    \"roundf64\" => f.round(),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u64(f.to_bits()), dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"fadd_fast\"\n+            | \"fsub_fast\"\n+            | \"fmul_fast\"\n+            | \"fdiv_fast\"\n+            | \"frem_fast\"\n+            => {\n+                let [a, b] = check_arg_count(args)?;\n+                let a = this.read_immediate(a)?;\n+                let b = this.read_immediate(b)?;\n+                let op = match intrinsic_name {\n+                    \"fadd_fast\" => mir::BinOp::Add,\n+                    \"fsub_fast\" => mir::BinOp::Sub,\n+                    \"fmul_fast\" => mir::BinOp::Mul,\n+                    \"fdiv_fast\" => mir::BinOp::Div,\n+                    \"frem_fast\" => mir::BinOp::Rem,\n+                    _ => bug!(),\n+                };\n+                let float_finite = |x: ImmTy<'tcx, _>| -> InterpResult<'tcx, bool> {\n+                    Ok(match x.layout.ty.kind() {\n+                        ty::Float(FloatTy::F32) => x.to_scalar()?.to_f32()?.is_finite(),\n+                        ty::Float(FloatTy::F64) => x.to_scalar()?.to_f64()?.is_finite(),\n+                        _ => bug!(\n+                            \"`{intrinsic_name}` called with non-float input type {ty:?}\",\n+                            ty = x.layout.ty,\n+                        ),\n+                    })\n+                };\n+                match (float_finite(a)?, float_finite(b)?) {\n+                    (false, false) => throw_ub_format!(\n+                        \"`{intrinsic_name}` intrinsic called with non-finite value as both parameters\",\n+                    ),\n+                    (false, _) => throw_ub_format!(\n+                        \"`{intrinsic_name}` intrinsic called with non-finite value as first parameter\",\n+                    ),\n+                    (_, false) => throw_ub_format!(\n+                        \"`{intrinsic_name}` intrinsic called with non-finite value as second parameter\",\n+                    ),\n+                    _ => {}\n+                }\n+                this.binop_ignore_overflow(op, &a, &b, dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"minnumf32\"\n+            | \"maxnumf32\"\n+            | \"copysignf32\"\n+            => {\n+                let [a, b] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f32()?;\n+                let b = this.read_scalar(b)?.to_f32()?;\n+                let res = match intrinsic_name {\n+                    \"minnumf32\" => a.min(b),\n+                    \"maxnumf32\" => a.max(b),\n+                    \"copysignf32\" => a.copy_sign(b),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_f32(res), dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"minnumf64\"\n+            | \"maxnumf64\"\n+            | \"copysignf64\"\n+            => {\n+                let [a, b] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f64()?;\n+                let b = this.read_scalar(b)?.to_f64()?;\n+                let res = match intrinsic_name {\n+                    \"minnumf64\" => a.min(b),\n+                    \"maxnumf64\" => a.max(b),\n+                    \"copysignf64\" => a.copy_sign(b),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_f64(res), dest)?;\n+            }\n+\n+            \"powf32\" => {\n+                let [f, f2] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n+                this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n+            }\n+\n+            \"powf64\" => {\n+                let [f, f2] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n+                this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n+            }\n+\n+            \"fmaf32\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f32()?;\n+                let b = this.read_scalar(b)?.to_f32()?;\n+                let c = this.read_scalar(c)?.to_f32()?;\n+                let res = a.mul_add(b, c).value;\n+                this.write_scalar(Scalar::from_f32(res), dest)?;\n+            }\n+\n+            \"fmaf64\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f64()?;\n+                let b = this.read_scalar(b)?.to_f64()?;\n+                let c = this.read_scalar(c)?.to_f64()?;\n+                let res = a.mul_add(b, c).value;\n+                this.write_scalar(Scalar::from_f64(res), dest)?;\n+            }\n+\n+            \"powif32\" => {\n+                let [f, i] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let i = this.read_scalar(i)?.to_i32()?;\n+                this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n+            }\n+\n+            \"powif64\" => {\n+                let [f, i] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let i = this.read_scalar(i)?.to_i32()?;\n+                this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n+            }\n+\n+            \"float_to_int_unchecked\" => {\n+                let [val] = check_arg_count(args)?;\n+                let val = this.read_immediate(val)?;\n+\n+                let res = match val.layout.ty.kind() {\n+                    ty::Float(FloatTy::F32) =>\n+                        this.float_to_int_unchecked(val.to_scalar()?.to_f32()?, dest.layout.ty)?,\n+                    ty::Float(FloatTy::F64) =>\n+                        this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?,\n+                    _ =>\n+                        span_bug!(\n+                            this.cur_span(),\n+                            \"`float_to_int_unchecked` called with non-float input type {:?}\",\n+                            val.layout.ty\n+                        ),\n+                };\n+\n+                this.write_scalar(res, dest)?;\n+            }\n+\n+            // Other\n+            \"exact_div\" => {\n+                let [num, denom] = check_arg_count(args)?;\n+                this.exact_div(&this.read_immediate(num)?, &this.read_immediate(denom)?, dest)?;\n+            }\n+\n+            \"breakpoint\" => {\n+                let [] = check_arg_count(args)?;\n+                // normally this would raise a SIGTRAP, which aborts if no debugger is connected\n+                throw_machine_stop!(TerminationInfo::Abort(\"Trace/breakpoint trap\".to_string()))\n+            }\n+\n+            name => throw_unsup_format!(\"unimplemented intrinsic: `{name}`\"),\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn float_to_int_unchecked<F>(\n+        &self,\n+        f: F,\n+        dest_ty: ty::Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Scalar<Tag>>\n+    where\n+        F: Float + Into<Scalar<Tag>>,\n+    {\n+        let this = self.eval_context_ref();\n+\n+        // Step 1: cut off the fractional part of `f`. The result of this is\n+        // guaranteed to be precisely representable in IEEE floats.\n+        let f = f.round_to_integral(Round::TowardZero).value;\n+\n+        // Step 2: Cast the truncated float to the target integer type and see if we lose any information in this step.\n+        Ok(match dest_ty.kind() {\n+            // Unsigned\n+            ty::Uint(t) => {\n+                let size = Integer::from_uint_ty(this, *t).size();\n+                let res = f.to_u128(size.bits_usize());\n+                if res.status.is_empty() {\n+                    // No status flags means there was no further rounding or other loss of precision.\n+                    Scalar::from_uint(res.value, size)\n+                } else {\n+                    // `f` was not representable in this integer type.\n+                    throw_ub_format!(\n+                        \"`float_to_int_unchecked` intrinsic called on {f} which cannot be represented in target type `{dest_ty:?}`\",\n+                    );\n+                }\n+            }\n+            // Signed\n+            ty::Int(t) => {\n+                let size = Integer::from_int_ty(this, *t).size();\n+                let res = f.to_i128(size.bits_usize());\n+                if res.status.is_empty() {\n+                    // No status flags means there was no further rounding or other loss of precision.\n+                    Scalar::from_int(res.value, size)\n+                } else {\n+                    // `f` was not representable in this integer type.\n+                    throw_ub_format!(\n+                        \"`float_to_int_unchecked` intrinsic called on {f} which cannot be represented in target type `{dest_ty:?}`\",\n+                    );\n+                }\n+            }\n+            // Nothing else\n+            _ =>\n+                span_bug!(\n+                    this.cur_span(),\n+                    \"`float_to_int_unchecked` called with non-int output type {dest_ty:?}\"\n+                ),\n+        })\n+    }\n+}"}, {"sha": "fe5250ed08434bfc363b3ff7cc0fb03e486c8a75", "filename": "src/shims/intrinsics/simd.rs", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fsimd.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -0,0 +1,613 @@\n+use rustc_apfloat::Float;\n+use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n+use rustc_middle::{mir, ty, ty::FloatTy};\n+use rustc_target::abi::{Endian, HasDataLayout, Size};\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Calls the simd intrinsic `intrinsic`; the `simd_` prefix has already been removed.\n+    fn emulate_simd_intrinsic(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        match intrinsic_name {\n+            #[rustfmt::skip]\n+            | \"neg\"\n+            | \"fabs\"\n+            | \"ceil\"\n+            | \"floor\"\n+            | \"round\"\n+            | \"trunc\"\n+            | \"fsqrt\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                #[derive(Copy, Clone)]\n+                enum HostFloatOp {\n+                    Ceil,\n+                    Floor,\n+                    Round,\n+                    Trunc,\n+                    Sqrt,\n+                }\n+                #[derive(Copy, Clone)]\n+                enum Op {\n+                    MirOp(mir::UnOp),\n+                    Abs,\n+                    HostOp(HostFloatOp),\n+                }\n+                let which = match intrinsic_name {\n+                    \"neg\" => Op::MirOp(mir::UnOp::Neg),\n+                    \"fabs\" => Op::Abs,\n+                    \"ceil\" => Op::HostOp(HostFloatOp::Ceil),\n+                    \"floor\" => Op::HostOp(HostFloatOp::Floor),\n+                    \"round\" => Op::HostOp(HostFloatOp::Round),\n+                    \"trunc\" => Op::HostOp(HostFloatOp::Trunc),\n+                    \"fsqrt\" => Op::HostOp(HostFloatOp::Sqrt),\n+                    _ => unreachable!(),\n+                };\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar()?,\n+                        Op::Abs => {\n+                            // Works for f32 and f64.\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            let op = op.to_scalar()?;\n+                            match float_ty {\n+                                FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n+                                FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n+                            }\n+                        }\n+                        Op::HostOp(host_op) => {\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            // FIXME using host floats\n+                            match float_ty {\n+                                FloatTy::F32 => {\n+                                    let f = f32::from_bits(op.to_scalar()?.to_u32()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                        HostFloatOp::Sqrt => f.sqrt(),\n+                                    };\n+                                    Scalar::from_u32(res.to_bits())\n+                                }\n+                                FloatTy::F64 => {\n+                                    let f = f64::from_bits(op.to_scalar()?.to_u64()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                        HostFloatOp::Sqrt => f.sqrt(),\n+                                    };\n+                                    Scalar::from_u64(res.to_bits())\n+                                }\n+                            }\n+\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            #[rustfmt::skip]\n+            | \"add\"\n+            | \"sub\"\n+            | \"mul\"\n+            | \"div\"\n+            | \"rem\"\n+            | \"shl\"\n+            | \"shr\"\n+            | \"and\"\n+            | \"or\"\n+            | \"xor\"\n+            | \"eq\"\n+            | \"ne\"\n+            | \"lt\"\n+            | \"le\"\n+            | \"gt\"\n+            | \"ge\"\n+            | \"fmax\"\n+            | \"fmin\"\n+            | \"saturating_add\"\n+            | \"saturating_sub\"\n+            | \"arith_offset\" => {\n+                use mir::BinOp;\n+\n+                let [left, right] = check_arg_count(args)?;\n+                let (left, left_len) = this.operand_to_simd(left)?;\n+                let (right, right_len) = this.operand_to_simd(right)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, left_len);\n+                assert_eq!(dest_len, right_len);\n+\n+                enum Op {\n+                    MirOp(BinOp),\n+                    SaturatingOp(BinOp),\n+                    FMax,\n+                    FMin,\n+                    WrappingOffset,\n+                }\n+                let which = match intrinsic_name {\n+                    \"add\" => Op::MirOp(BinOp::Add),\n+                    \"sub\" => Op::MirOp(BinOp::Sub),\n+                    \"mul\" => Op::MirOp(BinOp::Mul),\n+                    \"div\" => Op::MirOp(BinOp::Div),\n+                    \"rem\" => Op::MirOp(BinOp::Rem),\n+                    \"shl\" => Op::MirOp(BinOp::Shl),\n+                    \"shr\" => Op::MirOp(BinOp::Shr),\n+                    \"and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"or\" => Op::MirOp(BinOp::BitOr),\n+                    \"xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"eq\" => Op::MirOp(BinOp::Eq),\n+                    \"ne\" => Op::MirOp(BinOp::Ne),\n+                    \"lt\" => Op::MirOp(BinOp::Lt),\n+                    \"le\" => Op::MirOp(BinOp::Le),\n+                    \"gt\" => Op::MirOp(BinOp::Gt),\n+                    \"ge\" => Op::MirOp(BinOp::Ge),\n+                    \"fmax\" => Op::FMax,\n+                    \"fmin\" => Op::FMin,\n+                    \"saturating_add\" => Op::SaturatingOp(BinOp::Add),\n+                    \"saturating_sub\" => Op::SaturatingOp(BinOp::Sub),\n+                    \"arith_offset\" => Op::WrappingOffset,\n+                    _ => unreachable!(),\n+                };\n+\n+                for i in 0..dest_len {\n+                    let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n+                    let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => {\n+                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n+                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n+                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n+                                // See <https://github.com/rust-lang/rust/issues/91237>.\n+                                if overflowed {\n+                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n+                                    throw_ub_format!(\"overflowing shift by {r_val} in `simd_{intrinsic_name}` in SIMD lane {i}\");\n+                                }\n+                            }\n+                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n+                                // Special handling for boolean-returning operations\n+                                assert_eq!(ty, this.tcx.types.bool);\n+                                let val = val.to_bool().unwrap();\n+                                bool_to_simd_element(val, dest.layout.size)\n+                            } else {\n+                                assert_ne!(ty, this.tcx.types.bool);\n+                                assert_eq!(ty, dest.layout.ty);\n+                                val\n+                            }\n+                        }\n+                        Op::SaturatingOp(mir_op) => {\n+                            this.saturating_arith(mir_op, &left, &right)?\n+                        }\n+                        Op::WrappingOffset => {\n+                            let ptr = this.scalar_to_ptr(left.to_scalar()?)?;\n+                            let offset_count = right.to_scalar()?.to_machine_isize(this)?;\n+                            let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n+\n+                            let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+                            let offset_bytes = offset_count.wrapping_mul(pointee_size);\n+                            let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, this);\n+                            Scalar::from_maybe_pointer(offset_ptr, this)\n+                        }\n+                        Op::FMax => {\n+                            fmax_op(&left, &right)?\n+                        }\n+                        Op::FMin => {\n+                            fmin_op(&left, &right)?\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            \"fma\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                let (a, a_len) = this.operand_to_simd(a)?;\n+                let (b, b_len) = this.operand_to_simd(b)?;\n+                let (c, c_len) = this.operand_to_simd(c)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, a_len);\n+                assert_eq!(dest_len, b_len);\n+                assert_eq!(dest_len, c_len);\n+\n+                for i in 0..dest_len {\n+                    let a = this.read_immediate(&this.mplace_index(&a, i)?.into())?.to_scalar()?;\n+                    let b = this.read_immediate(&this.mplace_index(&b, i)?.into())?.to_scalar()?;\n+                    let c = this.read_immediate(&this.mplace_index(&c, i)?.into())?.to_scalar()?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    // Works for f32 and f64.\n+                    let ty::Float(float_ty) = dest.layout.ty.kind() else {\n+                        span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                    };\n+                    let val = match float_ty {\n+                        FloatTy::F32 =>\n+                            Scalar::from_f32(a.to_f32()?.mul_add(b.to_f32()?, c.to_f32()?).value),\n+                        FloatTy::F64 =>\n+                            Scalar::from_f64(a.to_f64()?.mul_add(b.to_f64()?, c.to_f64()?).value),\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            #[rustfmt::skip]\n+            | \"reduce_and\"\n+            | \"reduce_or\"\n+            | \"reduce_xor\"\n+            | \"reduce_any\"\n+            | \"reduce_all\"\n+            | \"reduce_max\"\n+            | \"reduce_min\" => {\n+                use mir::BinOp;\n+\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+\n+                let imm_from_bool =\n+                    |b| ImmTy::from_scalar(Scalar::from_bool(b), this.machine.layouts.bool);\n+\n+                enum Op {\n+                    MirOp(BinOp),\n+                    MirOpBool(BinOp),\n+                    Max,\n+                    Min,\n+                }\n+                let which = match intrinsic_name {\n+                    \"reduce_and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"reduce_or\" => Op::MirOp(BinOp::BitOr),\n+                    \"reduce_xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"reduce_any\" => Op::MirOpBool(BinOp::BitOr),\n+                    \"reduce_all\" => Op::MirOpBool(BinOp::BitAnd),\n+                    \"reduce_max\" => Op::Max,\n+                    \"reduce_min\" => Op::Min,\n+                    _ => unreachable!(),\n+                };\n+\n+                // Initialize with first lane, then proceed with the rest.\n+                let mut res = this.read_immediate(&this.mplace_index(&op, 0)?.into())?;\n+                if matches!(which, Op::MirOpBool(_)) {\n+                    // Convert to `bool` scalar.\n+                    res = imm_from_bool(simd_element_to_bool(res)?);\n+                }\n+                for i in 1..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    res = match which {\n+                        Op::MirOp(mir_op) => {\n+                            this.binary_op(mir_op, &res, &op)?\n+                        }\n+                        Op::MirOpBool(mir_op) => {\n+                            let op = imm_from_bool(simd_element_to_bool(op)?);\n+                            this.binary_op(mir_op, &res, &op)?\n+                        }\n+                        Op::Max => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar()?.to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                        Op::Min => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar()?.to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                    };\n+                }\n+                this.write_immediate(*res, dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"reduce_add_ordered\"\n+            | \"reduce_mul_ordered\" => {\n+                use mir::BinOp;\n+\n+                let [op, init] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let init = this.read_immediate(init)?;\n+\n+                let mir_op = match intrinsic_name {\n+                    \"reduce_add_ordered\" => BinOp::Add,\n+                    \"reduce_mul_ordered\" => BinOp::Mul,\n+                    _ => unreachable!(),\n+                };\n+\n+                let mut res = init;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    res = this.binary_op(mir_op, &res, &op)?;\n+                }\n+                this.write_immediate(*res, dest)?;\n+            }\n+            \"select\" => {\n+                let [mask, yes, no] = check_arg_count(args)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, mask_len);\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                for i in 0..dest_len {\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if simd_element_to_bool(mask)? { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"select_bitmask\" => {\n+                let [mask, yes, no] = check_arg_count(args)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+                let bitmask_len = dest_len.max(8);\n+\n+                assert!(mask.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, mask.layout.size.bits());\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                let mask: u64 = this\n+                    .read_scalar(mask)?\n+                    .check_init()?\n+                    .to_bits(mask.layout.size)?\n+                    .try_into()\n+                    .unwrap();\n+                for i in 0..dest_len {\n+                    let mask =\n+                        mask & (1 << simd_bitmask_index(i, dest_len, this.data_layout().endian));\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if mask != 0 { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+                for i in dest_len..bitmask_len {\n+                    // If the mask is \"padded\", ensure that padding is all-zero.\n+                    let mask = mask & (1 << i);\n+                    if mask != 0 {\n+                        throw_ub_format!(\n+                            \"a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\"\n+                        );\n+                    }\n+                }\n+            }\n+            #[rustfmt::skip]\n+            \"cast\" | \"as\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                let safe_cast = intrinsic_name == \"as\";\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n+                        // Int-to-(int|float): always safe\n+                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-float: always safe\n+                        (ty::Float(_), ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in safe mode\n+                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in unchecked mode\n+                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n+                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n+                        _ =>\n+                            throw_unsup_format!(\n+                                \"Unsupported SIMD cast from element type {from_ty} to {to_ty}\",\n+                                from_ty = op.layout.ty,\n+                                to_ty = dest.layout.ty,\n+                            ),\n+                    };\n+                    this.write_immediate(val, &dest.into())?;\n+                }\n+            }\n+            \"shuffle\" => {\n+                let [left, right, index] = check_arg_count(args)?;\n+                let (left, left_len) = this.operand_to_simd(left)?;\n+                let (right, right_len) = this.operand_to_simd(right)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                // `index` is an array, not a SIMD type\n+                let ty::Array(_, index_len) = index.layout.ty.kind() else {\n+                    span_bug!(this.cur_span(), \"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n+                };\n+                let index_len = index_len.eval_usize(*this.tcx, this.param_env());\n+\n+                assert_eq!(left_len, right_len);\n+                assert_eq!(index_len, dest_len);\n+\n+                for i in 0..dest_len {\n+                    let src_index: u64 = this\n+                        .read_immediate(&this.operand_index(index, i)?)?\n+                        .to_scalar()?\n+                        .to_u32()?\n+                        .into();\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if src_index < left_len {\n+                        this.read_immediate(&this.mplace_index(&left, src_index)?.into())?\n+                    } else if src_index < left_len.checked_add(right_len).unwrap() {\n+                        this.read_immediate(\n+                            &this.mplace_index(&right, src_index - left_len)?.into(),\n+                        )?\n+                    } else {\n+                        span_bug!(\n+                            this.cur_span(),\n+                            \"simd_shuffle index {src_index} is out of bounds for 2 vectors of size {left_len}\",\n+                        );\n+                    };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"gather\" => {\n+                let [passthru, ptrs, mask] = check_arg_count(args)?;\n+                let (passthru, passthru_len) = this.operand_to_simd(passthru)?;\n+                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, passthru_len);\n+                assert_eq!(dest_len, ptrs_len);\n+                assert_eq!(dest_len, mask_len);\n+\n+                for i in 0..dest_len {\n+                    let passthru = this.read_immediate(&this.mplace_index(&passthru, i)?.into())?;\n+                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if simd_element_to_bool(mask)? {\n+                        let place = this.deref_operand(&ptr.into())?;\n+                        this.read_immediate(&place.into())?\n+                    } else {\n+                        passthru\n+                    };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"scatter\" => {\n+                let [value, ptrs, mask] = check_arg_count(args)?;\n+                let (value, value_len) = this.operand_to_simd(value)?;\n+                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+\n+                assert_eq!(ptrs_len, value_len);\n+                assert_eq!(ptrs_len, mask_len);\n+\n+                for i in 0..ptrs_len {\n+                    let value = this.read_immediate(&this.mplace_index(&value, i)?.into())?;\n+                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+\n+                    if simd_element_to_bool(mask)? {\n+                        let place = this.deref_operand(&ptr.into())?;\n+                        this.write_immediate(*value, &place.into())?;\n+                    }\n+                }\n+            }\n+            \"bitmask\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let bitmask_len = op_len.max(8);\n+\n+                assert!(dest.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, dest.layout.size.bits());\n+\n+                let mut res = 0u64;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    if simd_element_to_bool(op)? {\n+                        res |= 1 << simd_bitmask_index(i, op_len, this.data_layout().endian);\n+                    }\n+                }\n+                this.write_int(res, dest)?;\n+            }\n+\n+            name => throw_unsup_format!(\"unimplemented intrinsic: `simd_{name}`\"),\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n+    // SIMD uses all-1 as pattern for \"true\"\n+    let val = if b { -1 } else { 0 };\n+    Scalar::from_int(val, size)\n+}\n+\n+fn simd_element_to_bool(elem: ImmTy<'_, Tag>) -> InterpResult<'_, bool> {\n+    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n+    Ok(match val {\n+        0 => false,\n+        -1 => true,\n+        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n+    })\n+}\n+\n+fn simd_bitmask_index(idx: u64, vec_len: u64, endianess: Endian) -> u64 {\n+    assert!(idx < vec_len);\n+    match endianess {\n+        Endian::Little => idx,\n+        Endian::Big => vec_len - 1 - idx, // reverse order of bits\n+    }\n+}\n+\n+fn fmax_op<'tcx>(\n+    left: &ImmTy<'tcx, Tag>,\n+    right: &ImmTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmax operand is not a float\")\n+    };\n+    let left = left.to_scalar()?;\n+    let right = right.to_scalar()?;\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n+    })\n+}\n+\n+fn fmin_op<'tcx>(\n+    left: &ImmTy<'tcx, Tag>,\n+    right: &ImmTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmin operand is not a float\")\n+    };\n+    let left = left.to_scalar()?;\n+    let right = right.to_scalar()?;\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n+    })\n+}"}, {"sha": "cf34b4baec7f73a23183b520192ec52eb1dd792a", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -2,7 +2,6 @@ use std::ffi::OsStr;\n \n use log::trace;\n \n-use rustc_middle::mir;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_span::Symbol;\n use rustc_target::abi::{Align, Size};\n@@ -22,7 +21,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n \n@@ -533,9 +531,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Platform-specific shims\n             _ => {\n                 match this.tcx.sess.target.os.as_ref() {\n-                    \"linux\" => return shims::unix::linux::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n-                    \"macos\" => return shims::unix::macos::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n-                    \"freebsd\" => return shims::unix::freebsd::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n+                    \"linux\" => return shims::unix::linux::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                    \"macos\" => return shims::unix::macos::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                    \"freebsd\" => return shims::unix::freebsd::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n                     _ => unreachable!(),\n                 }\n             }"}, {"sha": "2350e5a12c11d8e1c47a20848c5d0e0ce6324088", "filename": "src/shims/unix/freebsd/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -1,4 +1,3 @@\n-use rustc_middle::mir;\n use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n@@ -14,7 +13,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n         match link_name.as_str() {"}, {"sha": "efd4e2a8c03d3d1bb0a7ab19f86df77b3b5a73e8", "filename": "src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -1,4 +1,3 @@\n-use rustc_middle::mir;\n use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n@@ -17,7 +16,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "a81fdb5e9988896f0b32b0ee2a18a8c820ab26c5", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -169,7 +169,7 @@ pub fn futex<'tcx>(\n             //\n             // Thankfully, preemptions cannot happen inside a Miri shim, so we do not need to\n             // do anything special to guarantee fence-load-comparison atomicity.\n-            this.atomic_fence(&[], AtomicFenceOrd::SeqCst)?;\n+            this.validate_atomic_fence(AtomicFenceOrd::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             let futex_val = this\n@@ -240,7 +240,7 @@ pub fn futex<'tcx>(\n             // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n             // will see the latest value on addr which could be changed by our caller\n             // before doing the syscall.\n-            this.atomic_fence(&[], AtomicFenceOrd::SeqCst)?;\n+            this.validate_atomic_fence(AtomicFenceOrd::SeqCst)?;\n             let mut n = 0;\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr_usize, bitset) {"}, {"sha": "58dd40cda301d521b7c3c1a6eb7ee84b8cc38456", "filename": "src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -1,4 +1,3 @@\n-use rustc_middle::mir;\n use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n@@ -15,7 +14,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "65634342417beac915446fd59d96005a92c4d158", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -1,6 +1,5 @@\n use std::iter;\n \n-use rustc_middle::mir;\n use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n@@ -18,7 +17,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "e3d80a78916f6a22880e2c995faf9ffcb6273880", "filename": "tests/pass/atomic.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b9c677112a982fa91f8ff00d831e46fe613e715e/tests%2Fpass%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c677112a982fa91f8ff00d831e46fe613e715e/tests%2Fpass%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fatomic.rs?ref=b9c677112a982fa91f8ff00d831e46fe613e715e", "patch": "@@ -51,18 +51,22 @@ fn atomic_all_ops() {\n     static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n     static ATOMIC_UNSIGNED: AtomicU64 = AtomicU64::new(0);\n \n+    let load_orders = [Relaxed, Acquire, SeqCst];\n+    let stored_orders = [Relaxed, Release, SeqCst];\n+    let rmw_orders = [Relaxed, Release, Acquire, AcqRel, SeqCst];\n+\n     // loads\n-    for o in [Relaxed, Acquire, SeqCst] {\n+    for o in load_orders {\n         ATOMIC.load(o);\n     }\n \n     // stores\n-    for o in [Relaxed, Release, SeqCst] {\n+    for o in stored_orders {\n         ATOMIC.store(1, o);\n     }\n \n     // most RMWs\n-    for o in [Relaxed, Release, Acquire, AcqRel, SeqCst] {\n+    for o in rmw_orders {\n         ATOMIC.swap(0, o);\n         ATOMIC.fetch_or(0, o);\n         ATOMIC.fetch_xor(0, o);\n@@ -76,37 +80,26 @@ fn atomic_all_ops() {\n         ATOMIC_UNSIGNED.fetch_max(0, o);\n     }\n \n-    // RMWs with deparate failure ordering\n-    ATOMIC.store(0, SeqCst);\n-    assert_eq!(ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed), Ok(0));\n-    assert_eq!(ATOMIC.compare_exchange(0, 2, Acquire, Relaxed), Err(1));\n-    assert_eq!(ATOMIC.compare_exchange(0, 1, Release, Relaxed), Err(1));\n-    assert_eq!(ATOMIC.compare_exchange(1, 0, AcqRel, Relaxed), Ok(1));\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n-\n-    ATOMIC.store(0, SeqCst);\n-    compare_exchange_weak_loop!(ATOMIC, 0, 1, Relaxed, Relaxed);\n-    assert_eq!(ATOMIC.compare_exchange_weak(0, 2, Acquire, Relaxed), Err(1));\n-    assert_eq!(ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed), Err(1));\n-    compare_exchange_weak_loop!(ATOMIC, 1, 0, AcqRel, Relaxed);\n-    assert_eq!(ATOMIC.load(Relaxed), 0);\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n+    // RMWs with separate failure ordering\n+    for o1 in rmw_orders {\n+        for o2 in load_orders {\n+            let _res = ATOMIC.compare_exchange(0, 0, o1, o2);\n+            let _res = ATOMIC.compare_exchange_weak(0, 0, o1, o2);\n+        }\n+    }\n }\n \n fn atomic_u64() {\n     static ATOMIC: AtomicU64 = AtomicU64::new(0);\n \n     ATOMIC.store(1, SeqCst);\n     assert_eq!(ATOMIC.compare_exchange(0, 0x100, AcqRel, Acquire), Err(1));\n+    assert_eq!(ATOMIC.compare_exchange(0, 1, Release, Relaxed), Err(1));\n+    assert_eq!(ATOMIC.compare_exchange(1, 0, AcqRel, Relaxed), Ok(1));\n+    assert_eq!(ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed), Ok(0));\n     compare_exchange_weak_loop!(ATOMIC, 1, 0x100, AcqRel, Acquire);\n+    assert_eq!(ATOMIC.compare_exchange_weak(0, 2, Acquire, Relaxed), Err(0x100));\n+    assert_eq!(ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed), Err(0x100));\n     assert_eq!(ATOMIC.load(Relaxed), 0x100);\n \n     assert_eq!(ATOMIC.fetch_max(0x10, SeqCst), 0x100);"}]}