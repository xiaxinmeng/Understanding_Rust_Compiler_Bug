{"sha": "d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "node_id": "C_kwDOAAsO6NoAKGQ2Yjk2YjYxZTc1ZGQ1YWQyNGE3N2Q2YTI2YTdlZWYzYjQ5Mjg1NmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T16:09:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T16:09:56Z"}, "message": "Auto merge of #100064 - RalfJung:disaligned, r=petrochenkov\n\nfix is_disaligned logic for nested packed structs\n\nhttps://github.com/rust-lang/rust/pull/83605 broke the `is_disaligned` logic by bailing out of the loop in `is_within_packed` early. This PR fixes that problem and adds suitable tests.\n\nFixes https://github.com/rust-lang/rust/issues/99838", "tree": {"sha": "416c2a4dab6081d97b9feba787a2e7fa35c135e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/416c2a4dab6081d97b9feba787a2e7fa35c135e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "html_url": "https://github.com/rust-lang/rust/commit/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04f72f95384d97f4c4e7a59e60cb85ec581ebe06", "url": "https://api.github.com/repos/rust-lang/rust/commits/04f72f95384d97f4c4e7a59e60cb85ec581ebe06", "html_url": "https://github.com/rust-lang/rust/commit/04f72f95384d97f4c4e7a59e60cb85ec581ebe06"}, {"sha": "9097ce905427c30bd262f62a403f1e987ebb10c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9097ce905427c30bd262f62a403f1e987ebb10c6", "html_url": "https://github.com/rust-lang/rust/commit/9097ce905427c30bd262f62a403f1e987ebb10c6"}], "stats": {"total": 179, "additions": 162, "deletions": 17}, "files": [{"sha": "4f39dad205ae335e6ede6e21880021c05245b288", "filename": "compiler/rustc_const_eval/src/util/alignment.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs?ref=d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "patch": "@@ -48,20 +48,16 @@ fn is_within_packed<'tcx, L>(\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    for (place_base, elem) in place.iter_projections().rev() {\n-        match elem {\n-            // encountered a Deref, which is ABI-aligned\n-            ProjectionElem::Deref => break,\n-            ProjectionElem::Field(..) => {\n-                let ty = place_base.ty(local_decls, tcx).ty;\n-                match ty.kind() {\n-                    ty::Adt(def, _) => return def.repr().pack,\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    None\n+    place\n+        .iter_projections()\n+        .rev()\n+        // Stop at `Deref`; standard ABI alignment applies there.\n+        .take_while(|(_base, elem)| !matches!(elem, ProjectionElem::Deref))\n+        // Consider the packed alignments at play here...\n+        .filter_map(|(base, _elem)| {\n+            base.ty(local_decls, tcx).ty.ty_adt_def().and_then(|adt| adt.repr().pack)\n+        })\n+        // ... and compute their minimum.\n+        // The overall smallest alignment is what matters.\n+        .min()\n }"}, {"sha": "eaeeac72b25e17ee0a2611b518f92222c32cb10a", "filename": "src/test/ui/issues/issue-99838.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/src%2Ftest%2Fui%2Fissues%2Fissue-99838.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/src%2Ftest%2Fui%2Fissues%2Fissue-99838.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-99838.rs?ref=d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "patch": "@@ -0,0 +1,40 @@\n+// run-pass\n+#![feature(bench_black_box)]\n+use std::hint;\n+\n+struct U16(u16);\n+\n+impl Drop for U16 {\n+    fn drop(&mut self) {\n+        // Prevent LLVM from optimizing away our alignment check.\n+        assert!(hint::black_box(self as *mut U16 as usize) % 2 == 0);\n+    }\n+}\n+\n+struct HasDrop;\n+\n+impl Drop for HasDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Wrapper {\n+    _a: U16,\n+    b: HasDrop,\n+}\n+\n+#[repr(packed)]\n+struct Misalign(u8, Wrapper);\n+\n+fn main() {\n+    let m = Misalign(\n+        0,\n+        Wrapper {\n+            _a: U16(10),\n+            b: HasDrop,\n+        },\n+    );\n+    // Put it somewhere definitely even (so the `a` field is definitely at an odd address).\n+    let m: ([u16; 0], Misalign) = ([], m);\n+    // Move out one field, so we run custom per-field drop logic below.\n+    let _x = m.1.1.b;\n+}"}, {"sha": "e547f031a9cfdf9886a0d7ad7e384edd102e1c54", "filename": "src/test/ui/lint/unaligned_references.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs?ref=d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "patch": "@@ -47,4 +47,57 @@ fn main() {\n         let _ = &packed2.y; // ok, has align 2 in packed(2) struct\n         let _ = &packed2.z; // ok, has align 1\n     }\n+\n+    unsafe {\n+        struct U16(u16);\n+\n+        impl Drop for U16 {\n+            fn drop(&mut self) {\n+                println!(\"{:p}\", self);\n+            }\n+        }\n+\n+        struct HasDrop;\n+\n+        impl Drop for HasDrop {\n+            fn drop(&mut self) {}\n+        }\n+\n+        #[allow(unused)]\n+        struct Wrapper {\n+            a: U16,\n+            b: HasDrop,\n+        }\n+        #[allow(unused)]\n+        #[repr(packed(2))]\n+        struct Wrapper2 {\n+            a: U16,\n+            b: HasDrop,\n+        }\n+\n+        // An outer struct with more restrictive packing than the inner struct -- make sure we\n+        // notice that!\n+        #[repr(packed)]\n+        struct Misalign<T>(u8, T);\n+\n+        let m1 = Misalign(\n+            0,\n+            Wrapper {\n+                a: U16(10),\n+                b: HasDrop,\n+            },\n+        );\n+        let _ref = &m1.1.a; //~ ERROR reference to packed field\n+        //~^ previously accepted\n+\n+        let m2 = Misalign(\n+            0,\n+            Wrapper2 {\n+                a: U16(10),\n+                b: HasDrop,\n+            },\n+        );\n+        let _ref = &m2.1.a; //~ ERROR reference to packed field\n+        //~^ previously accepted\n+    }\n }"}, {"sha": "97dbec2861cd2ababaae65e09ab1678148e12e13", "filename": "src/test/ui/lint/unaligned_references.stderr", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6b96b61e75dd5ad24a77d6a26a7eef3b492856e/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr?ref=d6b96b61e75dd5ad24a77d6a26a7eef3b492856e", "patch": "@@ -80,7 +80,29 @@ LL |         let _ = &packed2.x;\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n-error: aborting due to 7 previous errors\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:90:20\n+   |\n+LL |         let _ref = &m1.1.a;\n+   |                    ^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:100:20\n+   |\n+LL |         let _ref = &m2.1.a;\n+   |                    ^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+error: aborting due to 9 previous errors\n \n Future incompatibility report: Future breakage diagnostic:\n error: reference to packed field is unaligned\n@@ -201,3 +223,37 @@ LL | #![deny(unaligned_references)]\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:90:20\n+   |\n+LL |         let _ref = &m1.1.a;\n+   |                    ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:100:20\n+   |\n+LL |         let _ref = &m2.1.a;\n+   |                    ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}]}