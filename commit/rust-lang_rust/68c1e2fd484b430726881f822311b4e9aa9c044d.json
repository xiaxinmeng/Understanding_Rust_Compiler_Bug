{"sha": "68c1e2fd484b430726881f822311b4e9aa9c044d", "node_id": "C_kwDOAAsO6NoAKDY4YzFlMmZkNDg0YjQzMDcyNjg4MWY4MjIzMTFiNGU5YWE5YzA0NGQ", "commit": {"author": {"name": "Giacomo Pasini", "email": "giacomo@status.im", "date": "2023-01-24T17:48:05Z"}, "committer": {"name": "Giacomo Pasini", "email": "giacomo@status.im", "date": "2023-01-29T23:20:40Z"}, "message": "Treat Drop as a rmw operation\n\nPreviously, a Drop terminator was considered a move in MIR.\nThis commit changes the behavior to only treat Drop as a mutable\naccess to the dropped place.\n\nIn order for this change to be correct, we need to guarantee that\n  a) A dropped value won't be used again\n  b) Places that appear in a drop won't be used again before a\n     subsequent initialization.\n\nWe can ensure this to be correct at MIR construction because Drop\nwill only be emitted when a variable goes out of scope,\nthus having:\n  (a) as there is no way of reaching the old value. drop-elaboration\n     will also remove any uninitialized drop.\n  (b) as the place can't be named following the end of the scope.\n\nHowever, the initialization status, previously tracked by moves,\nshould also be tied to the execution of a Drop, hence the\nadditional logic in the dataflow analyses.", "tree": {"sha": "ada08309044abcf08662a460dd2606d31940317e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ada08309044abcf08662a460dd2606d31940317e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c1e2fd484b430726881f822311b4e9aa9c044d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEElHY+FNnS7QgcFjiQoDhRt4psmkYFAmPW/0sACgkQoDhRt4ps\nmka+pg/6A5GZuQcZPyhTVmE5TG6FVNUYuQXikOyxwYkl8Py6yYFMGmiUOEqQF5XK\nwCGpmjK5FuGO66B25Lhvw3J183Oi8LCWPYCcsX9mxBdUGXVz5KRuUQcMnYY2pO/8\njKLBjrBHoRQUua3F+1UMGY52EEQg8LdG01/RVnxt0g0Edk/4SpkWv4UTI2oDDiA6\n7nCIrpsVVZuwrcYW+WCQhsR1MJ0FI0mqwjenOzsKbVbGGyD/fVGNfXMtkywS/2Va\nEjAA4yR6/pNLEnmOj11bF7Ea8Sc/EloWPOx4EhdlgSsQajQUj34/gpdh34Khfz4y\nVnAcmHDNP1D+X8oTA8VbKZbz/esEkGfeyaQ4LMwGRxDl8blHeuDRunVpO1ywe6yV\nKMR3+Kfqut1WUnUkcfz/YPUFEvYPUslilzCnV1GZlRxAwuEm1AxMRJEZ2MCJ4jcy\nKmC6kqe6TyEXdbowMiOdWIpRiUmDMWQE5MybTykpdZ5ISqMo+F5UDqDYprFJdfv0\n/jgUcME6MaodPfQlSB044HciYhLt3YVZfmjNqmzkVRd5EVaHwb0p4nIpilCXGyEi\nbvdxbqs1qbQeKlWSGwt7dhgq1bw6ag/c2uQf/fIUGKN8G81An4Sbj3r2FDNFH14t\nn5njQDbdO0RHXXMgIljuM8hL3z37Y/JZgkjYOu8p5CTNBhCkEY0=\n=xjv5\n-----END PGP SIGNATURE-----", "payload": "tree ada08309044abcf08662a460dd2606d31940317e\nparent c8e6a9e8b6251bbc8276cb78cabe1998deecbed7\nauthor Giacomo Pasini <giacomo@status.im> 1674582485 +0100\ncommitter Giacomo Pasini <giacomo@status.im> 1675034440 +0100\n\nTreat Drop as a rmw operation\n\nPreviously, a Drop terminator was considered a move in MIR.\nThis commit changes the behavior to only treat Drop as a mutable\naccess to the dropped place.\n\nIn order for this change to be correct, we need to guarantee that\n  a) A dropped value won't be used again\n  b) Places that appear in a drop won't be used again before a\n     subsequent initialization.\n\nWe can ensure this to be correct at MIR construction because Drop\nwill only be emitted when a variable goes out of scope,\nthus having:\n  (a) as there is no way of reaching the old value. drop-elaboration\n     will also remove any uninitialized drop.\n  (b) as the place can't be named following the end of the scope.\n\nHowever, the initialization status, previously tracked by moves,\nshould also be tied to the execution of a Drop, hence the\nadditional logic in the dataflow analyses.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c1e2fd484b430726881f822311b4e9aa9c044d", "html_url": "https://github.com/rust-lang/rust/commit/68c1e2fd484b430726881f822311b4e9aa9c044d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c1e2fd484b430726881f822311b4e9aa9c044d/comments", "author": {"login": "Zeegomo", "id": 21265557, "node_id": "MDQ6VXNlcjIxMjY1NTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21265557?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zeegomo", "html_url": "https://github.com/Zeegomo", "followers_url": "https://api.github.com/users/Zeegomo/followers", "following_url": "https://api.github.com/users/Zeegomo/following{/other_user}", "gists_url": "https://api.github.com/users/Zeegomo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zeegomo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zeegomo/subscriptions", "organizations_url": "https://api.github.com/users/Zeegomo/orgs", "repos_url": "https://api.github.com/users/Zeegomo/repos", "events_url": "https://api.github.com/users/Zeegomo/events{/privacy}", "received_events_url": "https://api.github.com/users/Zeegomo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zeegomo", "id": 21265557, "node_id": "MDQ6VXNlcjIxMjY1NTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21265557?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zeegomo", "html_url": "https://github.com/Zeegomo", "followers_url": "https://api.github.com/users/Zeegomo/followers", "following_url": "https://api.github.com/users/Zeegomo/following{/other_user}", "gists_url": "https://api.github.com/users/Zeegomo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zeegomo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zeegomo/subscriptions", "organizations_url": "https://api.github.com/users/Zeegomo/orgs", "repos_url": "https://api.github.com/users/Zeegomo/repos", "events_url": "https://api.github.com/users/Zeegomo/events{/privacy}", "received_events_url": "https://api.github.com/users/Zeegomo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "html_url": "https://github.com/rust-lang/rust/commit/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7"}], "stats": {"total": 55, "additions": 46, "deletions": 9}, "files": [{"sha": "0d466bbe56e01d82b7d5550ca8dc2688495c3a0c", "filename": "compiler/rustc_mir_dataflow/src/drop_flag_effects.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs?ref=68c1e2fd484b430726881f822311b4e9aa9c044d", "patch": "@@ -1,5 +1,5 @@\n use crate::elaborate_drops::DropFlagState;\n-use rustc_middle::mir::{self, Body, Location};\n+use rustc_middle::mir::{self, Body, Location, Terminator, TerminatorKind};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -194,6 +194,17 @@ pub fn drop_flag_effects_for_location<'tcx, F>(\n         on_all_children_bits(tcx, body, move_data, path, |mpi| callback(mpi, DropFlagState::Absent))\n     }\n \n+    // Drop does not count as a move but we should still consider the variable uninitialized.\n+    if let Some(Terminator { kind: TerminatorKind::Drop { place, .. }, .. }) =\n+        body.stmt_at(loc).right()\n+    {\n+        if let LookupResult::Exact(mpi) = move_data.rev_lookup.find(place.as_ref()) {\n+            on_all_children_bits(tcx, body, move_data, mpi, |mpi| {\n+                callback(mpi, DropFlagState::Absent)\n+            })\n+        }\n+    }\n+\n     debug!(\"drop_flag_effects: assignment for location({:?})\", loc);\n \n     for_location_inits(tcx, body, move_data, loc, |mpi| callback(mpi, DropFlagState::Present));"}, {"sha": "f7f98d6e31cc6f635c66762a1f3fc914ab303f8a", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=68c1e2fd484b430726881f822311b4e9aa9c044d", "patch": "@@ -375,7 +375,8 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n             | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Unreachable => {}\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. } => {}\n \n             TerminatorKind::Assert { ref cond, .. } => {\n                 self.gather_operand(cond);\n@@ -390,10 +391,6 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.create_move_path(place);\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n-\n-            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n-                self.gather_move(place);\n-            }\n             TerminatorKind::DropAndReplace { place, ref value, .. } => {\n                 self.create_move_path(place);\n                 self.gather_operand(value);"}, {"sha": "8c5cf0e557492470359fa7a6cae2c4f031b859af", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=68c1e2fd484b430726881f822311b4e9aa9c044d", "patch": "@@ -222,13 +222,13 @@ pub trait ValueAnalysis<'tcx> {\n         self.super_terminator(terminator, state)\n     }\n \n-    fn super_terminator(&self, terminator: &Terminator<'tcx>, _state: &mut State<Self::Value>) {\n+    fn super_terminator(&self, terminator: &Terminator<'tcx>, state: &mut State<Self::Value>) {\n         match &terminator.kind {\n             TerminatorKind::Call { .. } | TerminatorKind::InlineAsm { .. } => {\n                 // Effect is applied by `handle_call_return`.\n             }\n-            TerminatorKind::Drop { .. } => {\n-                // We don't track dropped places.\n+            TerminatorKind::Drop { place, .. } => {\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n             }\n             TerminatorKind::DropAndReplace { .. } | TerminatorKind::Yield { .. } => {\n                 // They would have an effect, but are not allowed in this phase."}, {"sha": "c2ff8645635e01597ea6c0d55ece679df9e80f9f", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1e2fd484b430726881f822311b4e9aa9c044d/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=68c1e2fd484b430726881f822311b4e9aa9c044d", "patch": "@@ -18,6 +18,35 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use std::fmt;\n \n+/// During MIR building, Drop and DropAndReplace terminators are inserted in every place where a drop may occur.\n+/// However, in this phase, the presence of these terminators does not guarantee that a destructor will run,\n+/// as the target of the drop may be uninitialized.\n+/// In general, the compiler cannot determine at compile time whether a destructor will run or not.\n+///\n+/// At a high level, this pass refines Drop and DropAndReplace to only run the destructor if the\n+/// target is initialized. The way this is achievied is by inserting drop flags for every variable\n+/// that may be dropped, and then using those flags to determine whether a destructor should run.\n+/// This pass also removes DropAndReplace, replacing it with a Drop paired with an assign statement.\n+/// Once this is complete, Drop terminators in the MIR correspond to a call to the \"drop glue\" or\n+/// \"drop shim\" for the type of the dropped place.\n+///\n+/// This pass relies on dropped places having an associated move path, which is then used to determine\n+/// the initialization status of the place and its descendants.\n+/// It's worth noting that a MIR containing a Drop without an associated move path is probably ill formed,\n+/// as it would allow running a destructor on a place behind a reference:\n+///\n+/// ```text\n+// fn drop_term<T>(t: &mut T) {\n+//     mir!(\n+//         {\n+//             Drop(*t, exit)\n+//         }\n+//         exit = {\n+//             Return()\n+//         }\n+//     )\n+// }\n+/// ```\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {"}]}