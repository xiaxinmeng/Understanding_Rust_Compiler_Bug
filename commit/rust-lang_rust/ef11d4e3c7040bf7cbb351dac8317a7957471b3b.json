{"sha": "ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMTFkNGUzYzcwNDBiZjdjYmIzNTFkYWM4MzE3YTc5NTc0NzFiM2I=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-07-22T15:56:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-12T03:43:34Z"}, "message": "rustc: add TyAnon (impl Trait) to the typesystem.", "tree": {"sha": "163620cf8be4fda40f6e91281db5d64e501f7edf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/163620cf8be4fda40f6e91281db5d64e501f7edf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "html_url": "https://github.com/rust-lang/rust/commit/ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0baec691f9bfcfc70d6f35b1a86f7cf204a7d4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0baec691f9bfcfc70d6f35b1a86f7cf204a7d4f", "html_url": "https://github.com/rust-lang/rust/commit/f0baec691f9bfcfc70d6f35b1a86f7cf204a7d4f"}], "stats": {"total": 335, "additions": 250, "deletions": 85}, "files": [{"sha": "752b0e9a253dd9a7ee1cf41cd922c1f8467ce1c2", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -268,6 +268,9 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n         if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n             self.visit_ast_const_integer(length);\n         }\n+        if let TyKind::ImplTrait(..) = ty.node {\n+            self.create_def(ty.id, DefPathData::ImplTrait);\n+        }\n         visit::walk_ty(self, ty);\n     }\n \n@@ -428,6 +431,9 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n             self.visit_hir_const_integer(length);\n         }\n+        if let hir::TyImplTrait(..) = ty.node {\n+            self.create_def(ty.id, DefPathData::ImplTrait);\n+        }\n         intravisit::walk_ty(self, ty);\n     }\n "}, {"sha": "901a489728eeca0aca5c4ff7d9e26b23985047af", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -215,6 +215,8 @@ pub enum DefPathData {\n     Initializer,\n     /// Pattern binding\n     Binding(InternedString),\n+    /// An `impl Trait` type node.\n+    ImplTrait\n }\n \n impl Definitions {\n@@ -369,6 +371,10 @@ impl DefPathData {\n             Initializer => {\n                 InternedString::new(\"{{initializer}}\")\n             }\n+\n+            ImplTrait => {\n+                InternedString::new(\"{{impl-Trait}}\")\n+            }\n         }\n     }\n "}, {"sha": "1fb4e59e13189ff07fc14de61e81f58142d9ecff", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -170,7 +170,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyClosure(..) |\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |\n-            ty::TyParam(..) => {\n+            ty::TyParam(..) |\n+            ty::TyAnon(..) => {\n                 t.super_fold_with(self)\n             }\n         }"}, {"sha": "37193d45e68852245a523c298b94e01689ce8164", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -281,7 +281,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             true\n         }\n \n-        ty::TyClosure(..) => {\n+        ty::TyClosure(..) | ty::TyAnon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "09b5a34fdf33722cb048348fe8e70b16d6c13a3b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -211,6 +211,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyTuple(..) => Some(12),\n                 ty::TyProjection(..) => Some(13),\n                 ty::TyParam(..) => Some(14),\n+                ty::TyAnon(..) => Some(15),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }"}, {"sha": "aed4f4393241191d1f2d655f2ba594a709d67b10", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -94,6 +94,16 @@ pub enum Reveal {\n     NotSpecializable,\n \n     /// At trans time, all monomorphic projections will succeed.\n+    /// Also, `impl Trait` is normalized to the concrete type,\n+    /// which has to be already collected by type-checking.\n+    ///\n+    /// NOTE: As `impl Trait`'s concrete type should *never*\n+    /// be observable directly by the user, `Reveal::All`\n+    /// should not be used by checks which may expose\n+    /// type equality or type contents to the user.\n+    /// There are some exceptions, e.g. around OIBITS and\n+    /// transmute-checking, which expose some details, but\n+    /// not the whole concrete type of the `impl Trait`.\n     All,\n }\n \n@@ -298,6 +308,17 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n+            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+                // Only normalize `impl Trait` after type-checking, usually in trans.\n+                if self.selcx.projection_mode() == Reveal::All {\n+                    let generic_ty = self.tcx().lookup_item_type(def_id).ty;\n+                    let concrete_ty = generic_ty.subst(self.tcx(), substs);\n+                    self.fold_ty(concrete_ty)\n+                } else {\n+                    ty\n+                }\n+            }\n+\n             ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n@@ -773,8 +794,11 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     // Check whether the self-type is itself a projection.\n-    let trait_ref = match obligation_trait_ref.self_ty().sty {\n-        ty::TyProjection(ref data) => data.trait_ref.clone(),\n+    let (def_id, substs) = match obligation_trait_ref.self_ty().sty {\n+        ty::TyProjection(ref data) => {\n+            (data.trait_ref.def_id, data.trait_ref.substs)\n+        }\n+        ty::TyAnon(def_id, substs) => (def_id, substs),\n         ty::TyInfer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -785,8 +809,8 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().lookup_predicates(trait_ref.def_id);\n-    let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n+    let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n+    let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,"}, {"sha": "f353c54089db5b6c205c31087d09f67e22e41066", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -1158,20 +1158,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n-        let trait_def_id = match obligation.predicate.0.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) => data.trait_ref.def_id,\n+        match obligation.predicate.0.trait_ref.self_ty().sty {\n+            ty::TyProjection(_) | ty::TyAnon(..) => {}\n             ty::TyInfer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n                     \"Self=_ should have been handled by assemble_candidates\");\n             }\n-            _ => { return; }\n-        };\n-\n-        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n-               trait_def_id);\n+            _ => return\n+        }\n \n         let result = self.probe(|this, snapshot| {\n-            this.match_projection_obligation_against_bounds_from_trait(obligation,\n+            this.match_projection_obligation_against_definition_bounds(obligation,\n                                                                        snapshot)\n         });\n \n@@ -1180,7 +1177,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn match_projection_obligation_against_bounds_from_trait(\n+    fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         snapshot: &infer::CombinedSnapshot)\n@@ -1190,28 +1187,29 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         let (skol_trait_predicate, skol_map) =\n             self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 skol_trait_predicate={:?} skol_map={:?}\",\n                skol_trait_predicate,\n                skol_map);\n \n-        let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) => &data.trait_ref,\n+        let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n+            ty::TyProjection(ref data) => (data.trait_ref.def_id, data.trait_ref.substs),\n+            ty::TyAnon(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n-                    \"match_projection_obligation_against_bounds_from_trait() called \\\n+                    \"match_projection_obligation_against_definition_bounds() called \\\n                      but self-ty not a projection: {:?}\",\n                     skol_trait_predicate.trait_ref.self_ty());\n             }\n         };\n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                projection_trait_ref={:?}\",\n-               projection_trait_ref);\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n+                def_id={:?}, substs={:?}\",\n+               def_id, substs);\n \n-        let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n-        let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+        let item_predicates = self.tcx().lookup_predicates(def_id);\n+        let bounds = item_predicates.instantiate(self.tcx(), substs);\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 bounds={:?}\",\n                bounds);\n \n@@ -1226,7 +1224,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                     &skol_map,\n                                                     snapshot)));\n \n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 matching_bound={:?}\",\n                matching_bound);\n         match matching_bound {\n@@ -1472,7 +1470,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n                 ty::TyParam(..) |\n-                ty::TyProjection(..) => {\n+                ty::TyProjection(..) |\n+                ty::TyAnon(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1796,7 +1795,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }))\n             }\n \n-            ty::TyProjection(_) | ty::TyParam(_) => None,\n+            ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,\n             ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n \n             ty::TyInfer(ty::FreshTy(_))\n@@ -1842,7 +1841,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.to_vec()))\n             }\n \n-            ty::TyStruct(..) | ty::TyEnum(..) | ty::TyProjection(..) | ty::TyParam(..) => {\n+            ty::TyStruct(..) | ty::TyEnum(..) |\n+            ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -1893,6 +1893,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyTrait(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n+            ty::TyAnon(..) |\n             ty::TyInfer(ty::TyVar(_)) |\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |\n@@ -2073,7 +2074,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         self.in_snapshot(|this, snapshot| {\n             let result =\n-                this.match_projection_obligation_against_bounds_from_trait(obligation,\n+                this.match_projection_obligation_against_definition_bounds(obligation,\n                                                                            snapshot);\n             assert!(result);\n         })"}, {"sha": "8da7568c558a70b6d16b7fbcc8854122fd02c983", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -240,7 +240,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyProjection(..) |\n-                ty::TyParam(_) => {\n+                ty::TyParam(_) |\n+                ty::TyAnon(..) => {\n                     TC::All\n                 }\n "}, {"sha": "13401e91265eb9ac8db3f4ae39490b01ec67d0fd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         sty_debug_print!(\n             self,\n             TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n+            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1355,6 +1355,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n \n+    pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyAnon(def_id, substs))\n+    }\n+\n     pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n             let def_ids = self.trait_item_def_ids(trait_did);"}, {"sha": "66165ec6ff7d06aa179c4c7c5279aa4daadd51ae", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -247,6 +247,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     \"type parameter\".to_string()\n                 }\n             }\n+            ty::TyAnon(..) => \"anonymized type\".to_string(),\n             ty::TyError => \"type error\".to_string(),\n         }\n     }"}, {"sha": "e6f2ba8b650f1c77851ceb6c3eeaaeee93489295", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -30,6 +30,7 @@ pub enum SimplifiedType {\n     TraitSimplifiedType(DefId),\n     StructSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n+    AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }\n@@ -98,6 +99,9 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 None\n             }\n         }\n+        ty::TyAnon(def_id, _) => {\n+            Some(AnonSimplifiedType(def_id))\n+        }\n         ty::TyInfer(_) | ty::TyError => None,\n     }\n }"}, {"sha": "85b7d66a2eb085e8a1740d66d87387479277f602", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -110,6 +110,11 @@ impl FlagComputation {\n                 self.add_projection_ty(data);\n             }\n \n+            &ty::TyAnon(_, substs) => {\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_substs(substs);\n+            }\n+\n             &ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_substs(principal.0.substs);"}, {"sha": "3580013c2a9129aa973bf308a31b5bded98fb2a2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -695,7 +695,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             match t.sty {\n-                ty::TyProjection(..) => { return false; }\n+                ty::TyProjection(..) | ty::TyAnon(..) => { return false; }\n                 _ => { }\n             }\n         }"}, {"sha": "bfe6303d8a328a7bf8793d78a0c9a95853475a72", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -188,7 +188,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::Initializer |\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::Binding(..) => {\n+            data @ DefPathData::Binding(..) |\n+            data @ DefPathData::ImplTrait => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);\n                 buffer.push(&data.as_interned_str());\n@@ -345,6 +346,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyFnPtr(_) |\n         ty::TyProjection(_) |\n         ty::TyParam(_) |\n+        ty::TyAnon(..) |\n         ty::TyInfer(_) |\n         ty::TyError |\n         ty::TyFloat(_) => None,"}, {"sha": "d73e412f55f267c7b1e40d5c18ccb5890aa209ff", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -594,7 +594,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n                 Struct::non_zero_field_path(infcx, Some(ety).into_iter())\n             }\n \n-            (_, &ty::TyProjection(_)) => {\n+            (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n                 let normalized = normalize_associated_type(infcx, ty);\n                 if ty == normalized {\n                     return Ok(None);\n@@ -1108,7 +1108,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // Types with no meaningful known layout.\n-            ty::TyProjection(_) => {\n+            ty::TyProjection(_) | ty::TyAnon(..) => {\n                 let normalized = normalize_associated_type(infcx, ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n@@ -1332,7 +1332,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 }\n             }\n \n-            ty::TyProjection(_) => {\n+            ty::TyProjection(_) | ty::TyAnon(..) => {\n                 let normalized = normalize_associated_type(infcx, ty);\n                 if ty == normalized {\n                     Err(err)"}, {"sha": "fe5c602575beaa03827a5800242acae9c21b81bf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -1885,7 +1885,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 }\n             }\n \n-            TyProjection(..) => {\n+            TyProjection(..) | TyAnon(..) => {\n                 // must calculate explicitly.\n                 // FIXME: consider special-casing always-Sized projections\n                 vec![ty]"}, {"sha": "df907c26f71420b3e091c36ab02c96d5e5df394a", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -174,6 +174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::TyEnum(..) |        // OutlivesNominalType\n             ty::TyStruct(..) |      // OutlivesNominalType\n             ty::TyBox(..) |         // OutlivesNominalType (ish)\n+            ty::TyAnon(..) |        // OutlivesNominalType (ish)\n             ty::TyStr |             // OutlivesScalar (ish)\n             ty::TyArray(..) |       // ...\n             ty::TySlice(..) |       // ..."}, {"sha": "f9263947c0379c099562fc55c35046ffc025dd0e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -582,6 +582,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name))\n         }\n \n+        (&ty::TyAnon(a_def_id, a_substs), &ty::TyAnon(b_def_id, b_substs))\n+            if a_def_id == b_def_id =>\n+        {\n+            let substs = relate_substs(relation, None, a_substs, b_substs)?;\n+            Ok(tcx.mk_anon(a_def_id, substs))\n+        }\n+\n         _ =>\n         {\n             Err(TypeError::Sorts(expected_found(relation, &a, &b)))"}, {"sha": "e542e8f237f1a1c88097ba766da88ca2a475476c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -485,6 +485,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n+            ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n             ty::TyParam(..) => self.sty.clone(),\n@@ -513,6 +514,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n+            ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n             ty::TyParam(..) => false,"}, {"sha": "912cb39face0a6d9ec910ce33194618826999551", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -166,6 +166,12 @@ pub enum TypeVariants<'tcx> {\n     /// `<T as Trait<..>>::N`.\n     TyProjection(ProjectionTy<'tcx>),\n \n+    /// Anonymized (`impl Trait`) type found in a return type.\n+    /// The DefId comes from the `impl Trait` ast::Ty node, and the\n+    /// substitutions are for the generics of the function in question.\n+    /// After typeck, the concrete type can be found in the `tcache` map.\n+    TyAnon(DefId, &'tcx Substs<'tcx>),\n+\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     TyParam(ParamTy),\n \n@@ -1232,7 +1238,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 v\n             }\n             TyEnum(_, substs) |\n-            TyStruct(_, substs) => {\n+            TyStruct(_, substs) |\n+            TyAnon(_, substs) => {\n                 substs.regions.as_slice().to_vec()\n             }\n             TyClosure(_, ref substs) => {"}, {"sha": "e7bcfbfd823453dd2893fae3044744e7a8ee4b5c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -437,6 +437,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n+            TyAnon(def_id, _) |\n             TyFnDef(def_id, _, _) => self.def_id(def_id),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety);\n@@ -559,7 +560,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }) => Some(true),\n \n             TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n-            TyClosure(..) | TyEnum(..) | TyStruct(..) |\n+            TyClosure(..) | TyEnum(..) | TyStruct(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| !self.impls_bound(tcx, param_env, ty::BoundCopy, span));\n \n@@ -600,7 +601,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             TyStr | TyTrait(..) | TySlice(_) => Some(false),\n \n             TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n-            TyInfer(..) | TyError => None\n+            TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| self.impls_bound(tcx, param_env, ty::BoundSized, span));\n \n         if !self.has_param_types() && !self.has_self_ty() {"}, {"sha": "ebc2642678bfd80bb3b9d0a794dd0704dc88c263", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -88,7 +88,8 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             }).collect::<Vec<_>>());\n         }\n         ty::TyEnum(_, ref substs) |\n-        ty::TyStruct(_, ref substs) => {\n+        ty::TyStruct(_, ref substs) |\n+        ty::TyAnon(_, ref substs) => {\n             push_reversed(stack, substs.types.as_slice());\n         }\n         ty::TyClosure(_, ref substs) => {"}, {"sha": "f6ddfe60d40e6804c7ffee6f72b0276a303bcbe6", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -383,6 +383,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // types appearing in the fn signature\n                 }\n \n+                ty::TyAnon(..) => {\n+                    // all of the requirements on type parameters\n+                    // should've been checked by the instantiation\n+                    // of whatever returned this exact `impl Trait`.\n+                }\n+\n                 ty::TyTrait(ref data) => {\n                     // WfObject\n                     //"}, {"sha": "a17c01068139a376cd6c5b1aaa83d1a16e1fb57a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -907,6 +907,37 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n+            ty::TyAnon(def_id, substs) => {\n+                ty::tls::with(|tcx| {\n+                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                    // by looking up the projections associated with the def_id.\n+                    let item_predicates = tcx.lookup_predicates(def_id);\n+                    let substs = tcx.lift(&substs).unwrap_or_else(|| {\n+                        tcx.mk_substs(subst::Substs::empty())\n+                    });\n+                    let bounds = item_predicates.instantiate(tcx, substs);\n+\n+                    let mut first = true;\n+                    let mut is_sized = false;\n+                    write!(f, \"impl\")?;\n+                    for predicate in bounds.predicates.into_vec() {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            if Some(trait_ref.def_id()) == tcx.lang_items.sized_trait() {\n+                                is_sized = true;\n+                                continue;\n+                            }\n+\n+                            write!(f, \"{}{}\", if first { \" \" } else { \"+\" }, trait_ref)?;\n+                            first = false;\n+                        }\n+                    }\n+                    if !is_sized {\n+                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n+                    }\n+                    Ok(())\n+                })\n+            }\n             TyStr => write!(f, \"str\"),\n             TyClosure(did, substs) => ty::tls::with(|tcx| {\n                 write!(f, \"[closure\")?;"}, {"sha": "b9861c309dbec985d3e467eb9c9032219ecbf336", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -596,7 +596,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n \n             ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n-            ty::TyClosure(..) | ty::TyProjection(..) |\n+            ty::TyClosure(..) | ty::TyProjection(..) | ty::TyAnon(..) |\n             ty::TyFnDef(..) => {\n                 bug!(\"Unexpected type in foreign function\")\n             }"}, {"sha": "285ca2e4d4d4de2367259410dd9f09a3e291e73c", "filename": "src/librustc_metadata/def_key.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -41,6 +41,7 @@ pub enum DefPathData {\n     StructCtor,\n     Initializer,\n     Binding,\n+    ImplTrait,\n }\n \n pub fn simplify_def_key(key: hir_map::DefKey) -> DefKey {\n@@ -72,6 +73,7 @@ fn simplify_def_path_data(data: hir_map::DefPathData) -> DefPathData {\n         hir_map::DefPathData::StructCtor => DefPathData::StructCtor,\n         hir_map::DefPathData::Initializer => DefPathData::Initializer,\n         hir_map::DefPathData::Binding(_) => DefPathData::Binding,\n+        hir_map::DefPathData::ImplTrait => DefPathData::ImplTrait,\n     }\n }\n \n@@ -103,5 +105,6 @@ fn recover_def_path_data(data: DefPathData, name: Option<InternedString>) -> hir\n         DefPathData::StructCtor => hir_map::DefPathData::StructCtor,\n         DefPathData::Initializer => hir_map::DefPathData::Initializer,\n         DefPathData::Binding => hir_map::DefPathData::Binding(name.unwrap()),\n+        DefPathData::ImplTrait => hir_map::DefPathData::ImplTrait,\n     }\n }"}, {"sha": "1dcec35adb285554642a41712abcc6265d736166", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -445,6 +445,13 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let name = token::intern(&self.parse_str(']'));\n                 return tcx.mk_projection(trait_ref, name);\n             }\n+            'A' => {\n+                assert_eq!(self.next(), '[');\n+                let def_id = self.parse_def();\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                return self.tcx.mk_anon(def_id, self.tcx.mk_substs(substs));\n+            }\n             'e' => {\n                 return tcx.types.err;\n             }"}, {"sha": "c2e91eba0d2523a600d322ccf35f1d548375958a", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -170,6 +170,11 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_trait_ref(w, cx, data.trait_ref);\n             write!(w, \"{}]\", data.item_name);\n         }\n+        ty::TyAnon(def_id, substs) => {\n+            write!(w, \"A[{}|\", (cx.ds)(cx.tcx, def_id));\n+            enc_substs(w, cx, substs);\n+            write!(w, \"]\");\n+        }\n         ty::TyError => {\n             write!(w, \"e\");\n         }"}, {"sha": "4a6dbb2bdae56d746926987e2a7921357e1eadbb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -796,6 +796,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyProjection(_) |\n         ty::TyParam(_)      |\n         ty::TyInfer(_)      |\n+        ty::TyAnon(..)      |\n         ty::TyError         => {\n             bug!(\"encountered unexpected type\");\n         }"}, {"sha": "bee2667c71f9db974660ff39bde162776e9379b3", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -150,6 +150,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyError |\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n+        ty::TyAnon(..) |\n         ty::TyParam(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {:?}\", t);"}, {"sha": "187ffe353fdcb5f596bd87dbfb0994feaa8e8c79", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -536,7 +536,8 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyError |\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n-        ty::TyParam(_) => {\n+        ty::TyParam(_) |\n+        ty::TyAnon(..) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                   unexpected type: {:?}\", t);\n         }"}, {"sha": "cde53f6fa899cb9c89a33977e8e42070764b6f19", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -112,7 +112,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError => {\n+        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) |\n+        ty::TyAnon(..) | ty::TyError => {\n             bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n         }\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => bug!()\n@@ -339,10 +340,11 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n       }\n \n-      ty::TyInfer(..) => bug!(\"type_of with TyInfer\"),\n-      ty::TyProjection(..) => bug!(\"type_of with TyProjection\"),\n-      ty::TyParam(..) => bug!(\"type_of with ty_param\"),\n-      ty::TyError => bug!(\"type_of with TyError\"),\n+      ty::TyInfer(..) |\n+      ty::TyProjection(..) |\n+      ty::TyParam(..) |\n+      ty::TyAnon(..) |\n+      ty::TyError => bug!(\"type_of with {:?}\", t),\n     };\n \n     debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);"}, {"sha": "f1d2bdb0117a87068dde5d9fe9224765d08af3f2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -56,6 +56,7 @@ use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n+use rustc::ty::subst::VecPerParamSpace;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -1745,6 +1746,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPolyTraitRef(ref bounds) => {\n                 self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n             }\n+            hir::TyImplTrait(ref bounds) => {\n+                use collect::{compute_bounds, SizedByDefault};\n+\n+                // Create the anonymized type.\n+                let def_id = tcx.map.local_def_id(ast_ty.id);\n+                let substs = tcx.mk_substs(Substs::empty());\n+                let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n+\n+                // Collect the bounds, i.e. the `Trait` in `impl Trait`.\n+                let bounds = compute_bounds(self, ty, bounds, SizedByDefault::Yes, ast_ty.span);\n+                let predicates = tcx.lift_to_global(&bounds.predicates(tcx, ty)).unwrap();\n+                let predicates = ty::GenericPredicates {\n+                    predicates: VecPerParamSpace::new(vec![], vec![], predicates)\n+                };\n+                tcx.predicates.borrow_mut().insert(def_id, predicates);\n+\n+                ty\n+            }\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = tcx.expect_resolution(ast_ty.id);"}, {"sha": "f65e15430daf75c7de17357c61f1bab01cc2d49a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -499,7 +499,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n         }\n \n         // these are always dtorck\n-        ty::TyTrait(..) | ty::TyProjection(_) => bug!(),\n+        ty::TyTrait(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n     }\n }\n \n@@ -509,7 +509,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n             def.is_dtorck(tcx)\n         }\n-        ty::TyTrait(..) | ty::TyProjection(..) => {\n+        ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n             true\n         },"}, {"sha": "99f1b13d4e4ab422a6c218dd0c202da6812b037e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -786,16 +786,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             debug!(\"assemble_projection_candidates: step={:?}\",\n                    step);\n \n-            let projection_trait_ref = match step.self_ty.sty {\n-                ty::TyProjection(ref data) => &data.trait_ref,\n+            let (def_id, substs) = match step.self_ty.sty {\n+                ty::TyProjection(ref data) => {\n+                    (data.trait_ref.def_id, data.trait_ref.substs)\n+                }\n+                ty::TyAnon(def_id, substs) => (def_id, substs),\n                 _ => continue,\n             };\n \n-            debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n-                   projection_trait_ref);\n+            debug!(\"assemble_projection_candidates: def_id={:?} substs={:?}\",\n+                   def_id, substs);\n \n-            let trait_predicates = self.tcx.lookup_predicates(projection_trait_ref.def_id);\n-            let bounds = trait_predicates.instantiate(self.tcx, projection_trait_ref.substs);\n+            let trait_predicates = self.tcx.lookup_predicates(def_id);\n+            let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n                    predicates);\n@@ -806,9 +809,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             {\n                 let bound = self.erase_late_bound_regions(&poly_bound);\n \n-                debug!(\"assemble_projection_candidates: projection_trait_ref={:?} bound={:?}\",\n-                       projection_trait_ref,\n-                       bound);\n+                debug!(\"assemble_projection_candidates: def_id={:?} substs={:?} bound={:?}\",\n+                       def_id, substs, bound);\n \n                 if self.can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item,"}, {"sha": "13deac57330e3b28e5c44914b07b439d29d905cc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n-use rustc::ty::TyProjection;\n+use rustc::ty::{TyProjection, TyAnon};\n use rustc::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 None\n             }\n \n-            TyInfer(..) | TyClosure(..) => {\n+            TyInfer(..) | TyClosure(..) | TyAnon(..) => {\n                 // `ty` comes from a user declaration so we should only expect types\n                 // that the user can type\n                 span_bug!("}, {"sha": "480a166f56a966b0abfe4d441721c79d9cefbcf1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -1694,10 +1694,10 @@ fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                           bounds: &mut ty::BuiltinBounds,\n-                           ast_bounds: &[hir::TyParamBound],\n-                           span: Span)\n+fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                       bounds: &mut ty::BuiltinBounds,\n+                                       ast_bounds: &[hir::TyParamBound],\n+                                       span: Span)\n {\n     let tcx = astconv.tcx();\n \n@@ -2038,17 +2038,17 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-enum SizedByDefault { Yes, No, }\n+pub enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                        param_ty: ty::Ty<'tcx>,\n-                        ast_bounds: &[hir::TyParamBound],\n-                        sized_by_default: SizedByDefault,\n-                        span: Span)\n-                        -> Bounds<'tcx>\n+pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                        param_ty: ty::Ty<'tcx>,\n+                                        ast_bounds: &[hir::TyParamBound],\n+                                        sized_by_default: SizedByDefault,\n+                                        span: Span)\n+                                        -> Bounds<'tcx>\n {\n     let mut bounds =\n         conv_param_bounds(astconv,\n@@ -2098,11 +2098,11 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                             param_ty: Ty<'tcx>,\n-                             trait_ref: &hir::PolyTraitRef,\n-                             projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                             -> ty::PolyTraitRef<'tcx>\n+fn conv_poly_trait_ref<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                         param_ty: Ty<'tcx>,\n+                                         trait_ref: &hir::PolyTraitRef,\n+                                         projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                                         -> ty::PolyTraitRef<'tcx>\n {\n     AstConv::instantiate_poly_trait_ref(astconv,\n                                         &ExplicitRscope,\n@@ -2111,11 +2111,11 @@ fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                                         projections)\n }\n \n-fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                              span: Span,\n-                              param_ty: ty::Ty<'tcx>,\n-                              ast_bounds: &[hir::TyParamBound])\n-                              -> Bounds<'tcx>\n+fn conv_param_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                       span: Span,\n+                                       param_ty: ty::Ty<'tcx>,\n+                                       ast_bounds: &[hir::TyParamBound])\n+                                       -> Bounds<'tcx>\n {\n     let tcx = astconv.tcx();\n     let PartitionedBounds {"}, {"sha": "7d3bd095a3a888c930b813f17654334ae4e92ded", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -45,7 +45,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         match t.sty {\n-            ty::TyProjection(..) if !self.include_nonconstraining => {\n+            ty::TyProjection(..) | ty::TyAnon(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;\n             }"}, {"sha": "b9e0b4a10ea45ec9396a186cd103800ac0b085c1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 /* leaf type -- noop */\n             }\n \n-            ty::TyClosure(..) => {\n+            ty::TyClosure(..) | ty::TyAnon(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n "}, {"sha": "73bc647fa9ffbcf63d8129fb30d8f66e452a5502", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef11d4e3c7040bf7cbb351dac8317a7957471b3b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "patch": "@@ -1867,6 +1867,18 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n             ty::TyParam(ref p) => Generic(p.name.to_string()),\n \n+            ty::TyAnon(def_id, substs) => {\n+                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                // by looking up the projections associated with the def_id.\n+                let item_predicates = cx.tcx().lookup_predicates(def_id);\n+                let substs = cx.tcx().lift(&substs).unwrap();\n+                let bounds = item_predicates.instantiate(cx.tcx(), substs);\n+                let predicates = bounds.predicates.into_vec();\n+                ImplTrait(predicates.into_iter().filter_map(|predicate| {\n+                    predicate.to_opt_poly_trait_ref().clean(cx)\n+                }).collect())\n+            }\n+\n             ty::TyClosure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::TyInfer(..) => panic!(\"TyInfer\"),"}]}