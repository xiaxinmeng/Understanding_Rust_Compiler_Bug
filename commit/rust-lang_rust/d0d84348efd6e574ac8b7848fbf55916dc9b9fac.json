{"sha": "d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZDg0MzQ4ZWZkNmU1NzRhYzhiNzg0OGZiZjU1OTE2ZGM5YjlmYWM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-15T04:39:09Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-15T20:38:41Z"}, "message": "Make most send_map functions pure", "tree": {"sha": "58e36811c2a3e27d47bfe8dcca4c0ba05981df75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58e36811c2a3e27d47bfe8dcca4c0ba05981df75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "html_url": "https://github.com/rust-lang/rust/commit/d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0d84348efd6e574ac8b7848fbf55916dc9b9fac/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1834249e8dff3419f33ee8595a4bf347e50c3c62", "url": "https://api.github.com/repos/rust-lang/rust/commits/1834249e8dff3419f33ee8595a4bf347e50c3c62", "html_url": "https://github.com/rust-lang/rust/commit/1834249e8dff3419f33ee8595a4bf347e50c3c62"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "4ddd16a52f510b1ac998bf347951c7795e93b940", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d0d84348efd6e574ac8b7848fbf55916dc9b9fac/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d84348efd6e574ac8b7848fbf55916dc9b9fac/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "patch": "@@ -16,14 +16,14 @@ trait SendMap<K:Eq Hash, V: Copy> {\n     fn clear(&mut self);\n     pure fn len(&const self) -> uint;\n     pure fn is_empty(&const self) -> bool;\n-    fn contains_key(&const self, k: &K) -> bool;\n-    fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool);\n-    fn each_key_ref(&self, blk: fn(k: &K) -> bool);\n-    fn each_value_ref(&self, blk: fn(v: &V) -> bool);\n-    fn find(&const self, k: &K) -> Option<V>;\n-    fn get(&const self, k: &K) -> V;\n-    fn find_ref(&self, k: &K) -> Option<&self/V>;\n-    fn get_ref(&self, k: &K) -> &self/V;\n+    pure fn contains_key(&const self, k: &K) -> bool;\n+    pure fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool);\n+    pure fn each_key_ref(&self, blk: fn(k: &K) -> bool);\n+    pure fn each_value_ref(&self, blk: fn(v: &V) -> bool);\n+    pure fn find(&const self, k: &K) -> Option<V>;\n+    pure fn get(&const self, k: &K) -> V;\n+    pure fn find_ref(&self, k: &K) -> Option<&self/V>;\n+    pure fn get_ref(&self, k: &K) -> &self/V;\n }\n \n /// Open addressing with linear probing.\n@@ -267,15 +267,15 @@ mod linear {\n             self.len() == 0\n         }\n \n-        fn contains_key(&const self,\n+        pure fn contains_key(&const self,\n                         k: &K) -> bool {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(_) => {true}\n                 TableFull | FoundHole(_) => {false}\n             }\n         }\n \n-        fn find_ref(&self, k: &K) -> Option<&self/V> {\n+        pure fn find_ref(&self, k: &K) -> Option<&self/V> {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(idx) => {\n                     match self.buckets[idx] {\n@@ -304,14 +304,14 @@ mod linear {\n             }\n         }\n \n-        fn get_ref(&self, k: &K) -> &self/V {\n+        pure fn get_ref(&self, k: &K) -> &self/V {\n             match self.find_ref(k) {\n                 Some(v) => v,\n                 None => fail fmt!(\"No entry found for key: %?\", k),\n             }\n         }\n \n-        fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool) {\n+        pure fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool) {\n             for vec::each(self.buckets) |slot| {\n                 let mut broke = false;\n                 do slot.iter |bucket| {\n@@ -323,17 +323,17 @@ mod linear {\n             }\n         }\n \n-        fn each_key_ref(&self, blk: fn(k: &K) -> bool) {\n+        pure fn each_key_ref(&self, blk: fn(k: &K) -> bool) {\n             self.each_ref(|k, _v| blk(k))\n         }\n \n-        fn each_value_ref(&self, blk: fn(v: &V) -> bool) {\n+        pure fn each_value_ref(&self, blk: fn(v: &V) -> bool) {\n             self.each_ref(|_k, v| blk(v))\n         }\n     }\n \n     impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n-        fn find(&const self, k: &K) -> Option<V> {\n+        pure fn find(&const self, k: &K) -> Option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(idx) => {\n                     // FIXME (#3148): Once we rewrite found_entry, this\n@@ -349,7 +349,7 @@ mod linear {\n             }\n         }\n \n-        fn get(&const self, k: &K) -> V {\n+        pure fn get(&const self, k: &K) -> V {\n             let value = self.find(k);\n             if value.is_none() {\n                 fail fmt!(\"No entry found for key: %?\", k);\n@@ -360,17 +360,17 @@ mod linear {\n     }\n \n     impl<K: Hash IterBytes Eq Copy, V: Copy> LinearMap<K,V> {\n-        fn each(&self, blk: fn(+K,+V) -> bool) {\n+        pure fn each(&self, blk: fn(+K,+V) -> bool) {\n             self.each_ref(|k,v| blk(copy *k, copy *v));\n         }\n     }\n     impl<K: Hash IterBytes Eq Copy, V> LinearMap<K,V> {\n-        fn each_key(&self, blk: fn(+K) -> bool) {\n+        pure fn each_key(&self, blk: fn(+K) -> bool) {\n             self.each_key_ref(|k| blk(copy *k));\n         }\n     }\n     impl<K: Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n-        fn each_value(&self, blk: fn(+V) -> bool) {\n+        pure fn each_value(&self, blk: fn(+V) -> bool) {\n             self.each_value_ref(|v| blk(copy *v));\n         }\n     }"}]}