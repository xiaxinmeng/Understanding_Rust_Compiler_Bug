{"sha": "30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "node_id": "C_kwDOAAsO6NoAKDMwMjQzZGQ4N2U3ZGJkMTdkNjhlMWExZDE2YmEwNjZhN2QyY2ViZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-15T01:03:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-15T01:03:55Z"}, "message": "Auto merge of #98203 - kckeiks:gather-body-owners-in-hir-item-queries, r=cjgillot\n\ngather body owners\n\nIssue #96341", "tree": {"sha": "afdb4753680b64ff8da2f9075efac1ebdbe9e362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afdb4753680b64ff8da2f9075efac1ebdbe9e362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "html_url": "https://github.com/rust-lang/rust/commit/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba1fec234d07f43765c3c65ac341a4e64fb911a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba1fec234d07f43765c3c65ac341a4e64fb911a", "html_url": "https://github.com/rust-lang/rust/commit/1ba1fec234d07f43765c3c65ac341a4e64fb911a"}, {"sha": "2d265b6f7572efc77705f139ea1fb5e2089d2a9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d265b6f7572efc77705f139ea1fb5e2089d2a9c", "html_url": "https://github.com/rust-lang/rust/commit/2d265b6f7572efc77705f139ea1fb5e2089d2a9c"}], "stats": {"total": 610, "additions": 301, "deletions": 309}, "files": [{"sha": "3a59b2069b3b72b47e10773a94863ab95a8bf615", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 104, "deletions": 113, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -39,6 +39,7 @@ pub fn fn_sig<'hir>(node: Node<'hir>) -> Option<&'hir FnSig<'hir>> {\n     }\n }\n \n+#[inline]\n pub fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n     match node {\n         Node::Item(Item {\n@@ -486,35 +487,13 @@ impl<'hir> Map<'hir> {\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n-        self.krate()\n-            .owners\n-            .iter_enumerated()\n-            .flat_map(move |(owner, owner_info)| {\n-                let bodies = &owner_info.as_owner()?.nodes.bodies;\n-                Some(bodies.iter().map(move |&(local_id, _)| {\n-                    let hir_id = HirId { owner, local_id };\n-                    let body_id = BodyId { hir_id };\n-                    self.body_owner_def_id(body_id)\n-                }))\n-            })\n-            .flatten()\n+        self.tcx.hir_crate_items(()).body_owners.iter().copied()\n     }\n \n     pub fn par_body_owners<F: Fn(LocalDefId) + Sync + Send>(self, f: F) {\n         use rustc_data_structures::sync::{par_iter, ParallelIterator};\n-        #[cfg(parallel_compiler)]\n-        use rustc_rayon::iter::IndexedParallelIterator;\n-\n-        par_iter(&self.krate().owners.raw).enumerate().for_each(|(owner, owner_info)| {\n-            let owner = LocalDefId::new(owner);\n-            if let MaybeOwner::Owner(owner_info) = owner_info {\n-                par_iter(owner_info.nodes.bodies.range(..)).for_each(|(local_id, _)| {\n-                    let hir_id = HirId { owner, local_id: *local_id };\n-                    let body_id = BodyId { hir_id };\n-                    f(self.body_owner_def_id(body_id))\n-                })\n-            }\n-        });\n+\n+        par_iter(&self.tcx.hir_crate_items(()).body_owners[..]).for_each(|&def_id| f(def_id));\n     }\n \n     pub fn ty_param_owner(self, def_id: LocalDefId) -> LocalDefId {\n@@ -1283,133 +1262,145 @@ fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n }\n \n pub(super) fn hir_module_items(tcx: TyCtxt<'_>, module_id: LocalDefId) -> ModuleItems {\n-    let mut collector = ModuleCollector {\n-        tcx,\n-        submodules: Vec::default(),\n-        items: Vec::default(),\n-        trait_items: Vec::default(),\n-        impl_items: Vec::default(),\n-        foreign_items: Vec::default(),\n-    };\n+    let mut collector = ItemCollector::new(tcx, false);\n \n     let (hir_mod, span, hir_id) = tcx.hir().get_module(module_id);\n     collector.visit_mod(hir_mod, span, hir_id);\n \n-    let ModuleCollector { submodules, items, trait_items, impl_items, foreign_items, .. } =\n-        collector;\n+    let ItemCollector {\n+        submodules,\n+        items,\n+        trait_items,\n+        impl_items,\n+        foreign_items,\n+        body_owners,\n+        ..\n+    } = collector;\n     return ModuleItems {\n         submodules: submodules.into_boxed_slice(),\n         items: items.into_boxed_slice(),\n         trait_items: trait_items.into_boxed_slice(),\n         impl_items: impl_items.into_boxed_slice(),\n         foreign_items: foreign_items.into_boxed_slice(),\n+        body_owners: body_owners.into_boxed_slice(),\n     };\n-\n-    struct ModuleCollector<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        submodules: Vec<LocalDefId>,\n-        items: Vec<ItemId>,\n-        trait_items: Vec<TraitItemId>,\n-        impl_items: Vec<ImplItemId>,\n-        foreign_items: Vec<ForeignItemId>,\n-    }\n-\n-    impl<'hir> Visitor<'hir> for ModuleCollector<'hir> {\n-        type NestedFilter = nested_filter::All;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-\n-        fn visit_item(&mut self, item: &'hir Item<'hir>) {\n-            self.items.push(item.item_id());\n-            if let ItemKind::Mod(..) = item.kind {\n-                // If this declares another module, do not recurse inside it.\n-                self.submodules.push(item.def_id);\n-            } else {\n-                intravisit::walk_item(self, item)\n-            }\n-        }\n-\n-        fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n-            self.trait_items.push(item.trait_item_id());\n-            intravisit::walk_trait_item(self, item)\n-        }\n-\n-        fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n-            self.impl_items.push(item.impl_item_id());\n-            intravisit::walk_impl_item(self, item)\n-        }\n-\n-        fn visit_foreign_item(&mut self, item: &'hir ForeignItem<'hir>) {\n-            self.foreign_items.push(item.foreign_item_id());\n-            intravisit::walk_foreign_item(self, item)\n-        }\n-    }\n }\n \n pub(crate) fn hir_crate_items(tcx: TyCtxt<'_>, _: ()) -> ModuleItems {\n-    let mut collector = CrateCollector {\n-        tcx,\n-        submodules: Vec::default(),\n-        items: Vec::default(),\n-        trait_items: Vec::default(),\n-        impl_items: Vec::default(),\n-        foreign_items: Vec::default(),\n-    };\n+    let mut collector = ItemCollector::new(tcx, true);\n \n+    // A \"crate collector\" and \"module collector\" start at a\n+    // module item (the former starts at the crate root) but only\n+    // the former needs to collect it. ItemCollector does not do this for us.\n+    collector.submodules.push(CRATE_DEF_ID);\n     tcx.hir().walk_toplevel_module(&mut collector);\n \n-    let CrateCollector { submodules, items, trait_items, impl_items, foreign_items, .. } =\n-        collector;\n+    let ItemCollector {\n+        submodules,\n+        items,\n+        trait_items,\n+        impl_items,\n+        foreign_items,\n+        body_owners,\n+        ..\n+    } = collector;\n \n     return ModuleItems {\n         submodules: submodules.into_boxed_slice(),\n         items: items.into_boxed_slice(),\n         trait_items: trait_items.into_boxed_slice(),\n         impl_items: impl_items.into_boxed_slice(),\n         foreign_items: foreign_items.into_boxed_slice(),\n+        body_owners: body_owners.into_boxed_slice(),\n     };\n+}\n \n-    struct CrateCollector<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        submodules: Vec<LocalDefId>,\n-        items: Vec<ItemId>,\n-        trait_items: Vec<TraitItemId>,\n-        impl_items: Vec<ImplItemId>,\n-        foreign_items: Vec<ForeignItemId>,\n+struct ItemCollector<'tcx> {\n+    // When true, it collects all items in the create,\n+    // otherwise it collects items in some module.\n+    crate_collector: bool,\n+    tcx: TyCtxt<'tcx>,\n+    submodules: Vec<LocalDefId>,\n+    items: Vec<ItemId>,\n+    trait_items: Vec<TraitItemId>,\n+    impl_items: Vec<ImplItemId>,\n+    foreign_items: Vec<ForeignItemId>,\n+    body_owners: Vec<LocalDefId>,\n+}\n+\n+impl<'tcx> ItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, crate_collector: bool) -> ItemCollector<'tcx> {\n+        ItemCollector {\n+            crate_collector,\n+            tcx,\n+            submodules: Vec::default(),\n+            items: Vec::default(),\n+            trait_items: Vec::default(),\n+            impl_items: Vec::default(),\n+            foreign_items: Vec::default(),\n+            body_owners: Vec::default(),\n+        }\n     }\n+}\n+\n+impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n+    type NestedFilter = nested_filter::All;\n \n-    impl<'hir> Visitor<'hir> for CrateCollector<'hir> {\n-        type NestedFilter = nested_filter::All;\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n \n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n+    fn visit_item(&mut self, item: &'hir Item<'hir>) {\n+        if associated_body(Node::Item(item)).is_some() {\n+            self.body_owners.push(item.def_id);\n         }\n \n-        fn visit_item(&mut self, item: &'hir Item<'hir>) {\n-            self.items.push(item.item_id());\n+        self.items.push(item.item_id());\n+\n+        // Items that are modules are handled here instead of in visit_mod.\n+        if let ItemKind::Mod(module) = &item.kind {\n+            self.submodules.push(item.def_id);\n+            // A module collector does not recurse inside nested modules.\n+            if self.crate_collector {\n+                intravisit::walk_mod(self, module, item.hir_id());\n+            }\n+        } else {\n             intravisit::walk_item(self, item)\n         }\n+    }\n \n-        fn visit_mod(&mut self, m: &'hir Mod<'hir>, _s: Span, n: HirId) {\n-            self.submodules.push(n.owner);\n-            intravisit::walk_mod(self, m, n);\n-        }\n+    fn visit_foreign_item(&mut self, item: &'hir ForeignItem<'hir>) {\n+        self.foreign_items.push(item.foreign_item_id());\n+        intravisit::walk_foreign_item(self, item)\n+    }\n+\n+    fn visit_anon_const(&mut self, c: &'hir AnonConst) {\n+        self.body_owners.push(self.tcx.hir().local_def_id(c.hir_id));\n+        intravisit::walk_anon_const(self, c)\n+    }\n \n-        fn visit_foreign_item(&mut self, item: &'hir ForeignItem<'hir>) {\n-            self.foreign_items.push(item.foreign_item_id());\n-            intravisit::walk_foreign_item(self, item)\n+    fn visit_expr(&mut self, ex: &'hir Expr<'hir>) {\n+        if matches!(ex.kind, ExprKind::Closure { .. }) {\n+            self.body_owners.push(self.tcx.hir().local_def_id(ex.hir_id));\n         }\n+        intravisit::walk_expr(self, ex)\n+    }\n \n-        fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n-            self.trait_items.push(item.trait_item_id());\n-            intravisit::walk_trait_item(self, item)\n+    fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n+        if associated_body(Node::TraitItem(item)).is_some() {\n+            self.body_owners.push(item.def_id);\n         }\n \n-        fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n-            self.impl_items.push(item.impl_item_id());\n-            intravisit::walk_impl_item(self, item)\n+        self.trait_items.push(item.trait_item_id());\n+        intravisit::walk_trait_item(self, item)\n+    }\n+\n+    fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n+        if associated_body(Node::ImplItem(item)).is_some() {\n+            self.body_owners.push(item.def_id);\n         }\n+\n+        self.impl_items.push(item.impl_item_id());\n+        intravisit::walk_impl_item(self, item)\n     }\n }"}, {"sha": "a605e234be95f7c88033c73f9631e450de83ad01", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -44,6 +44,7 @@ pub struct ModuleItems {\n     trait_items: Box<[TraitItemId]>,\n     impl_items: Box<[ImplItemId]>,\n     foreign_items: Box<[ForeignItemId]>,\n+    body_owners: Box<[LocalDefId]>,\n }\n \n impl ModuleItems {"}, {"sha": "162ff1d32bc44b486fc8f0b41e82cc8998e7faef", "filename": "src/test/ui/asm/type-check-1.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -33,33 +33,6 @@ LL |         asm!(\"{}\", sym x);\n    |\n    = help: `sym` operands must refer to either a function or a static\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:58:26\n-   |\n-LL |         asm!(\"{}\", const 0f32);\n-   |                          ^^^^ expected integer, found `f32`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:60:26\n-   |\n-LL |         asm!(\"{}\", const 0 as *mut u8);\n-   |                          ^^^^^^^^^^^^ expected integer, found *-ptr\n-   |\n-   = note:     expected type `{integer}`\n-           found raw pointer `*mut u8`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:62:26\n-   |\n-LL |         asm!(\"{}\", const &0);\n-   |                          ^^ expected integer, found `&{integer}`\n-   |\n-help: consider removing the borrow\n-   |\n-LL -         asm!(\"{}\", const &0);\n-LL +         asm!(\"{}\", const 0);\n-   |\n-\n error: invalid asm output\n   --> $DIR/type-check-1.rs:15:29\n    |\n@@ -123,6 +96,33 @@ LL |         asm!(\"{}\", inout(reg) v[..]);\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n+error[E0308]: mismatched types\n+  --> $DIR/type-check-1.rs:58:26\n+   |\n+LL |         asm!(\"{}\", const 0f32);\n+   |                          ^^^^ expected integer, found `f32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-check-1.rs:60:26\n+   |\n+LL |         asm!(\"{}\", const 0 as *mut u8);\n+   |                          ^^^^^^^^^^^^ expected integer, found *-ptr\n+   |\n+   = note:     expected type `{integer}`\n+           found raw pointer `*mut u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-check-1.rs:62:26\n+   |\n+LL |         asm!(\"{}\", const &0);\n+   |                          ^^ expected integer, found `&{integer}`\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         asm!(\"{}\", const &0);\n+LL +         asm!(\"{}\", const 0);\n+   |\n+\n error[E0308]: mismatched types\n   --> $DIR/type-check-1.rs:76:25\n    |"}, {"sha": "8672e79b3e8c8afd5a0b9e7c2ccd0e1a345c693e", "filename": "src/test/ui/const-generics/const-arg-in-const-arg.full.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.full.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -22,30 +22,6 @@ note: the late bound lifetime parameter is introduced here\n LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n    |              ^^\n \n-error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/const-arg-in-const-arg.rs:30:23\n-   |\n-LL |     let _ = [0; faz::<'a>(&())];\n-   |                       ^^\n-   |\n-note: the late bound lifetime parameter is introduced here\n-  --> $DIR/const-arg-in-const-arg.rs:8:14\n-   |\n-LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n-   |              ^^\n-\n-error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/const-arg-in-const-arg.rs:33:23\n-   |\n-LL |     let _ = [0; faz::<'b>(&())];\n-   |                       ^^\n-   |\n-note: the late bound lifetime parameter is introduced here\n-  --> $DIR/const-arg-in-const-arg.rs:8:14\n-   |\n-LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n-   |              ^^\n-\n error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n   --> $DIR/const-arg-in-const-arg.rs:41:24\n    |\n@@ -118,6 +94,30 @@ LL |     let _ = [0; bar::<N>()];\n    |\n    = help: try adding a `where` bound using this expression: `where [(); bar::<N>()]:`\n \n+error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+  --> $DIR/const-arg-in-const-arg.rs:30:23\n+   |\n+LL |     let _ = [0; faz::<'a>(&())];\n+   |                       ^^\n+   |\n+note: the late bound lifetime parameter is introduced here\n+  --> $DIR/const-arg-in-const-arg.rs:8:14\n+   |\n+LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n+   |              ^^\n+\n+error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+  --> $DIR/const-arg-in-const-arg.rs:33:23\n+   |\n+LL |     let _ = [0; faz::<'b>(&())];\n+   |                       ^^\n+   |\n+note: the late bound lifetime parameter is introduced here\n+  --> $DIR/const-arg-in-const-arg.rs:8:14\n+   |\n+LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n+   |              ^^\n+\n error: unconstrained generic constant\n   --> $DIR/const-arg-in-const-arg.rs:47:19\n    |"}, {"sha": "f1353aa99437de05d6668c311ed3ec4b693e5be3", "filename": "src/test/ui/const-generics/const-arg-in-const-arg.min.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.min.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -241,21 +241,21 @@ LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n    |              ^^\n \n error[E0747]: unresolved item provided when a constant was expected\n-  --> $DIR/const-arg-in-const-arg.rs:27:23\n+  --> $DIR/const-arg-in-const-arg.rs:38:24\n    |\n-LL |     let _ = [0; bar::<N>()];\n-   |                       ^\n+LL |     let _: Foo<{ bar::<N>() }>;\n+   |                        ^\n    |\n help: if this generic argument was intended as a const parameter, surround it with braces\n    |\n-LL |     let _ = [0; bar::<{ N }>()];\n-   |                       +   +\n+LL |     let _: Foo<{ bar::<{ N }>() }>;\n+   |                        +   +\n \n error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/const-arg-in-const-arg.rs:30:23\n+  --> $DIR/const-arg-in-const-arg.rs:41:24\n    |\n-LL |     let _ = [0; faz::<'a>(&())];\n-   |                       ^^\n+LL |     let _: Foo<{ faz::<'a>(&()) }>;\n+   |                        ^^\n    |\n note: the late bound lifetime parameter is introduced here\n   --> $DIR/const-arg-in-const-arg.rs:8:14\n@@ -264,33 +264,41 @@ LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n    |              ^^\n \n error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/const-arg-in-const-arg.rs:33:23\n+  --> $DIR/const-arg-in-const-arg.rs:44:24\n    |\n-LL |     let _ = [0; faz::<'b>(&())];\n-   |                       ^^\n+LL |     let _: Foo<{ faz::<'b>(&()) }>;\n+   |                        ^^\n    |\n note: the late bound lifetime parameter is introduced here\n   --> $DIR/const-arg-in-const-arg.rs:8:14\n    |\n LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n    |              ^^\n \n+error: constant expression depends on a generic parameter\n+  --> $DIR/const-arg-in-const-arg.rs:25:17\n+   |\n+LL |     let _ = [0; foo::<T>()];\n+   |                 ^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n error[E0747]: unresolved item provided when a constant was expected\n-  --> $DIR/const-arg-in-const-arg.rs:38:24\n+  --> $DIR/const-arg-in-const-arg.rs:27:23\n    |\n-LL |     let _: Foo<{ bar::<N>() }>;\n-   |                        ^\n+LL |     let _ = [0; bar::<N>()];\n+   |                       ^\n    |\n help: if this generic argument was intended as a const parameter, surround it with braces\n    |\n-LL |     let _: Foo<{ bar::<{ N }>() }>;\n-   |                        +   +\n+LL |     let _ = [0; bar::<{ N }>()];\n+   |                       +   +\n \n error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/const-arg-in-const-arg.rs:41:24\n+  --> $DIR/const-arg-in-const-arg.rs:30:23\n    |\n-LL |     let _: Foo<{ faz::<'a>(&()) }>;\n-   |                        ^^\n+LL |     let _ = [0; faz::<'a>(&())];\n+   |                       ^^\n    |\n note: the late bound lifetime parameter is introduced here\n   --> $DIR/const-arg-in-const-arg.rs:8:14\n@@ -299,25 +307,17 @@ LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n    |              ^^\n \n error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/const-arg-in-const-arg.rs:44:24\n+  --> $DIR/const-arg-in-const-arg.rs:33:23\n    |\n-LL |     let _: Foo<{ faz::<'b>(&()) }>;\n-   |                        ^^\n+LL |     let _ = [0; faz::<'b>(&())];\n+   |                       ^^\n    |\n note: the late bound lifetime parameter is introduced here\n   --> $DIR/const-arg-in-const-arg.rs:8:14\n    |\n LL | const fn faz<'a>(_: &'a ()) -> usize { 13 }\n    |              ^^\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/const-arg-in-const-arg.rs:25:17\n-   |\n-LL |     let _ = [0; foo::<T>()];\n-   |                 ^^^^^^^^^^\n-   |\n-   = note: this may fail depending on what value the parameter takes\n-\n error[E0747]: unresolved item provided when a constant was expected\n   --> $DIR/const-arg-in-const-arg.rs:49:27\n    |"}, {"sha": "34ec8aadbcf3bda1f5efdb0b9dbc637536292278", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-requires-unsafe.mir.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.mir.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,16 +1,16 @@\n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/const-extern-fn-requires-unsafe.rs:9:17\n+  --> $DIR/const-extern-fn-requires-unsafe.rs:12:5\n    |\n-LL |     let a: [u8; foo()];\n-   |                 ^^^^^ call to unsafe function\n+LL |     foo();\n+   |     ^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/const-extern-fn-requires-unsafe.rs:12:5\n+  --> $DIR/const-extern-fn-requires-unsafe.rs:9:17\n    |\n-LL |     foo();\n-   |     ^^^^^ call to unsafe function\n+LL |     let a: [u8; foo()];\n+   |                 ^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n "}, {"sha": "b45f57b7b846bdcf8d90d94336464d506b96c999", "filename": "src/test/ui/issues/issue-47486.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,3 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-47486.rs:2:10\n+   |\n+LL |     () < std::mem::size_of::<_>();\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `usize`\n+\n error[E0282]: type annotations needed\n   --> $DIR/issue-47486.rs:3:11\n    |\n@@ -9,12 +15,6 @@ help: consider specifying the generic argument\n LL |     [0u8; std::mem::size_of::<_>()];\n    |                            ~~~~~\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-47486.rs:2:10\n-   |\n-LL |     () < std::mem::size_of::<_>();\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `usize`\n-\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0282, E0308."}, {"sha": "3e37fcb2141fc57f36d004a864af1291eb7a0e8c", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -143,36 +143,36 @@ LL | fn duplicate_custom_4<T: A + Copy + Trait>(t: S<T>) -> (S<T>, S<T>)\n    |                            ++++++++++++++\n \n error[E0382]: use of moved value: `t`\n-  --> $DIR/use_of_moved_value_copy_suggestions.rs:83:9\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:75:9\n    |\n-LL | fn existing_colon_in_where<T>(t: T)\n-   |                               - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n-...\n+LL | fn existing_colon<T:>(t: T) {\n+   |                       - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+LL |\n LL |     [t, t];\n    |      -  ^ value used here after move\n    |      |\n    |      value moved here\n    |\n-help: consider further restricting type parameter `T`\n+help: consider restricting type parameter `T`\n    |\n-LL |     T:, T: Copy\n-   |       ~~~~~~~~~\n+LL | fn existing_colon<T: Copy>(t: T) {\n+   |                      ++++\n \n error[E0382]: use of moved value: `t`\n-  --> $DIR/use_of_moved_value_copy_suggestions.rs:75:9\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:83:9\n    |\n-LL | fn existing_colon<T:>(t: T) {\n-   |                       - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n-LL |\n+LL | fn existing_colon_in_where<T>(t: T)\n+   |                               - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+...\n LL |     [t, t];\n    |      -  ^ value used here after move\n    |      |\n    |      value moved here\n    |\n-help: consider restricting type parameter `T`\n+help: consider further restricting type parameter `T`\n    |\n-LL | fn existing_colon<T: Copy>(t: T) {\n-   |                      ++++\n+LL |     T:, T: Copy\n+   |       ~~~~~~~~~\n \n error: aborting due to 11 previous errors\n "}, {"sha": "7f3a7e670b9b75b8c5727f55502d9b03c985a8a1", "filename": "src/test/ui/proc-macro/attribute-with-error.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,11 +1,3 @@\n-error[E0308]: mismatched types\n-  --> $DIR/attribute-with-error.rs:25:22\n-   |\n-LL |         let a: i32 = \"foo\";\n-   |                ---   ^^^^^ expected `i32`, found `&str`\n-   |                |\n-   |                expected due to this\n-\n error[E0308]: mismatched types\n   --> $DIR/attribute-with-error.rs:10:18\n    |\n@@ -22,6 +14,14 @@ LL |     let b: i32 = \"f'oo\";\n    |            |\n    |            expected due to this\n \n+error[E0308]: mismatched types\n+  --> $DIR/attribute-with-error.rs:25:22\n+   |\n+LL |         let a: i32 = \"foo\";\n+   |                ---   ^^^^^ expected `i32`, found `&str`\n+   |                |\n+   |                expected due to this\n+\n error[E0308]: mismatched types\n   --> $DIR/attribute-with-error.rs:35:22\n    |"}, {"sha": "e222c141f8b6a0b184d35a5509d61c96911bf536", "filename": "src/test/ui/repeat-expr/repeat_count.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Frepeat-expr%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Frepeat-expr%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat-expr%2Frepeat_count.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -30,6 +30,12 @@ error[E0308]: mismatched types\n LL |     let e = [0; \"foo\"];\n    |                 ^^^^^ expected `usize`, found `&str`\n \n+error[E0308]: mismatched types\n+  --> $DIR/repeat_count.rs:31:17\n+   |\n+LL |     let g = [0; G { g: () }];\n+   |                 ^^^^^^^^^^^ expected `usize`, found struct `G`\n+\n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:19:17\n    |\n@@ -57,12 +63,6 @@ help: change the type of the numeric literal from `u8` to `usize`\n LL |     let f = [0; 4usize];\n    |                  ~~~~~\n \n-error[E0308]: mismatched types\n-  --> $DIR/repeat_count.rs:31:17\n-   |\n-LL |     let g = [0; G { g: () }];\n-   |                 ^^^^^^^^^^^ expected `usize`, found struct `G`\n-\n error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0308, E0435."}, {"sha": "a763eb6f2f85499ef5c44377636834e872e3c1c7", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,3 +1,22 @@\n+error[E0277]: `<impl Iterator as Iterator>::Item` doesn't implement `Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:6:13\n+   |\n+LL |         qux(constraint);\n+   |         --- ^^^^^^^^^^ `<impl Iterator as Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |         |\n+   |         required by a bound introduced by this call\n+   |\n+   = help: the trait `Debug` is not implemented for `<impl Iterator as Iterator>::Item`\n+note: required by a bound in `qux`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:50:16\n+   |\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                ^^^^^^^^^^^^^^^ required by this bound in `qux`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn foo<I: Iterator>(constraints: I) where <I as Iterator>::Item: Debug {\n+   |       +++++++++++++              ~  ++++++++++++++++++++++++++++++++++\n+\n error[E0277]: `<impl Iterator as Iterator>::Item` doesn't implement `Debug`\n   --> $DIR/impl-trait-with-missing-bounds.rs:14:13\n    |\n@@ -74,25 +93,6 @@ help: introduce a type parameter with a trait bound instead of using `impl Trait\n LL | fn bak<I: Iterator + std::fmt::Debug>(constraints: I) where <I as Iterator>::Item: Debug {\n    |       +++++++++++++++++++++++++++++++              ~  ++++++++++++++++++++++++++++++++++\n \n-error[E0277]: `<impl Iterator as Iterator>::Item` doesn't implement `Debug`\n-  --> $DIR/impl-trait-with-missing-bounds.rs:6:13\n-   |\n-LL |         qux(constraint);\n-   |         --- ^^^^^^^^^^ `<impl Iterator as Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n-   |         |\n-   |         required by a bound introduced by this call\n-   |\n-   = help: the trait `Debug` is not implemented for `<impl Iterator as Iterator>::Item`\n-note: required by a bound in `qux`\n-  --> $DIR/impl-trait-with-missing-bounds.rs:50:16\n-   |\n-LL | fn qux(_: impl std::fmt::Debug) {}\n-   |                ^^^^^^^^^^^^^^^ required by this bound in `qux`\n-help: introduce a type parameter with a trait bound instead of using `impl Trait`\n-   |\n-LL | fn foo<I: Iterator>(constraints: I) where <I as Iterator>::Item: Debug {\n-   |       +++++++++++++              ~  ++++++++++++++++++++++++++++++++++\n-\n error[E0277]: `<impl Iterator as Iterator>::Item` doesn't implement `Debug`\n   --> $DIR/impl-trait-with-missing-bounds.rs:45:13\n    |"}, {"sha": "84cbc93571a710f4b8cbafe39bf245fb647a9dd6", "filename": "src/test/ui/suggestions/suggest-ref-macro.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,3 +1,25 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-ref-macro.rs:8:1\n+   |\n+LL | #[hello]\n+   | ^^^^^^^^\n+   | |\n+   | expected `&mut i32`, found integer\n+   | arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/suggest-ref-macro.rs:8:1\n+   |\n+LL |   #[hello]\n+   |  _-^^^^^^^\n+LL | | fn abc() {}\n+LL | |\n+LL | | fn x(_: &mut i32) {}\n+LL | |\n+LL | | macro_rules! bla {\n+   | |_____________-\n+   = note: this error originates in the attribute macro `hello` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0308]: mismatched types\n   --> $DIR/suggest-ref-macro.rs:15:11\n    |\n@@ -36,28 +58,6 @@ note: function defined here\n LL | fn x(_: &mut i32) {}\n    |    ^ -----------\n \n-error[E0308]: mismatched types\n-  --> $DIR/suggest-ref-macro.rs:8:1\n-   |\n-LL | #[hello]\n-   | ^^^^^^^^\n-   | |\n-   | expected `&mut i32`, found integer\n-   | arguments to this function are incorrect\n-   |\n-note: function defined here\n-  --> $DIR/suggest-ref-macro.rs:8:1\n-   |\n-LL |   #[hello]\n-   |  _-^^^^^^^\n-LL | | fn abc() {}\n-LL | |\n-LL | | fn x(_: &mut i32) {}\n-LL | |\n-LL | | macro_rules! bla {\n-   | |_____________-\n-   = note: this error originates in the attribute macro `hello` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "148fb5046705bf6265734a1586f09556bd73a58f", "filename": "src/test/ui/union/union-derive-clone.mirunsafeck.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.mirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.mirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.mirunsafeck.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,3 +1,20 @@\n+error[E0277]: the trait bound `U1: Copy` is not satisfied\n+  --> $DIR/union-derive-clone.rs:6:10\n+   |\n+LL | #[derive(Clone)]\n+   |          ^^^^^ the trait `Copy` is not implemented for `U1`\n+   |\n+note: required by a bound in `AssertParamIsCopy`\n+  --> $SRC_DIR/core/src/clone.rs:LL:COL\n+   |\n+LL | pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n+   |                                 ^^^^ required by this bound in `AssertParamIsCopy`\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `U1` with `#[derive(Copy)]`\n+   |\n+LL | #[derive(Copy)]\n+   |\n+\n error[E0599]: the method `clone` exists for union `U5<CloneNoCopy>`, but its trait bounds were not satisfied\n   --> $DIR/union-derive-clone.rs:38:15\n    |\n@@ -26,23 +43,6 @@ help: consider annotating `CloneNoCopy` with `#[derive(Clone, Copy)]`\n LL | #[derive(Clone, Copy)]\n    |\n \n-error[E0277]: the trait bound `U1: Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:6:10\n-   |\n-LL | #[derive(Clone)]\n-   |          ^^^^^ the trait `Copy` is not implemented for `U1`\n-   |\n-note: required by a bound in `AssertParamIsCopy`\n-  --> $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n-   |                                 ^^^^ required by this bound in `AssertParamIsCopy`\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `U1` with `#[derive(Copy)]`\n-   |\n-LL | #[derive(Copy)]\n-   |\n-\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0599."}, {"sha": "148fb5046705bf6265734a1586f09556bd73a58f", "filename": "src/test/ui/union/union-derive-clone.thirunsafeck.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.thirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.thirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.thirunsafeck.stderr?ref=30243dd87e7dbd17d68e1a1d16ba066a7d2cebe5", "patch": "@@ -1,3 +1,20 @@\n+error[E0277]: the trait bound `U1: Copy` is not satisfied\n+  --> $DIR/union-derive-clone.rs:6:10\n+   |\n+LL | #[derive(Clone)]\n+   |          ^^^^^ the trait `Copy` is not implemented for `U1`\n+   |\n+note: required by a bound in `AssertParamIsCopy`\n+  --> $SRC_DIR/core/src/clone.rs:LL:COL\n+   |\n+LL | pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n+   |                                 ^^^^ required by this bound in `AssertParamIsCopy`\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `U1` with `#[derive(Copy)]`\n+   |\n+LL | #[derive(Copy)]\n+   |\n+\n error[E0599]: the method `clone` exists for union `U5<CloneNoCopy>`, but its trait bounds were not satisfied\n   --> $DIR/union-derive-clone.rs:38:15\n    |\n@@ -26,23 +43,6 @@ help: consider annotating `CloneNoCopy` with `#[derive(Clone, Copy)]`\n LL | #[derive(Clone, Copy)]\n    |\n \n-error[E0277]: the trait bound `U1: Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:6:10\n-   |\n-LL | #[derive(Clone)]\n-   |          ^^^^^ the trait `Copy` is not implemented for `U1`\n-   |\n-note: required by a bound in `AssertParamIsCopy`\n-  --> $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n-   |                                 ^^^^ required by this bound in `AssertParamIsCopy`\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `U1` with `#[derive(Copy)]`\n-   |\n-LL | #[derive(Copy)]\n-   |\n-\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0599."}]}