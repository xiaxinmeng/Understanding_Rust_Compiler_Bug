{"sha": "a95c5e21219cd6569e2630637fd4268e24c0ca03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NWM1ZTIxMjE5Y2Q2NTY5ZTI2MzA2MzdmZDQyNjhlMjRjMGNhMDM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-18T10:52:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-18T10:52:27Z"}, "message": "Merge #5758\n\n5758: SSR: Explicitly autoderef and ref placeholders as needed r=matklad a=davidlattimore\n\nStructural search replace now inserts *, & and &mut in the replacement to match any auto[de]ref in the matched code.\r\n\r\ne.g. `$a.foo() ==>> bar($a)` might convert `x.foo()` to `bar(&mut x)`\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "8f8d7348d4916479396abb58adc6891163cb9cbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f8d7348d4916479396abb58adc6891163cb9cbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a95c5e21219cd6569e2630637fd4268e24c0ca03", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfO7LrCRBK7hj4Ov3rIwAAdHIIAIkZDw1tFskwVQudzscogk27\nW139sMEI9JlN6Nq7jqqMijZBwXFjAnhQpRW2fPm9w4ci3pYJVQ5sAIYBQk7RsdVG\nhX+Vw1e4lzkmXC403563ZPQNQM20E6OwrQ/6CoPpwIkvuA3RDESIgyN2GfdCqc+j\nx9RCuOFc7yQrDL8el77IiXv6P018n7PAADjupkObezjcn0Nw9IIH+xlN50QyLQbi\nGY2xVjbiFqf+6WcuObONp6l/arDjc5A0zWd6Po9MBhEedmwaK4LgfUNfNjtpone6\notrQGRIgSTYIfGynNOHJ4wBuseS3uFMEGabnPP98oYthmt7CdEDQ4/etjlrz+JQ=\n=qIIY\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f8d7348d4916479396abb58adc6891163cb9cbc\nparent 5d97db8d480d58559e7490e1efdb0e45d1a8832f\nparent 29e6238cb7330f7d29f33ff03a4ccc0a0cec9f4d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1597747947 +0000\ncommitter GitHub <noreply@github.com> 1597747947 +0000\n\nMerge #5758\n\n5758: SSR: Explicitly autoderef and ref placeholders as needed r=matklad a=davidlattimore\n\nStructural search replace now inserts *, & and &mut in the replacement to match any auto[de]ref in the matched code.\r\n\r\ne.g. `$a.foo() ==>> bar($a)` might convert `x.foo()` to `bar(&mut x)`\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a95c5e21219cd6569e2630637fd4268e24c0ca03", "html_url": "https://github.com/rust-lang/rust/commit/a95c5e21219cd6569e2630637fd4268e24c0ca03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a95c5e21219cd6569e2630637fd4268e24c0ca03/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d97db8d480d58559e7490e1efdb0e45d1a8832f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d97db8d480d58559e7490e1efdb0e45d1a8832f", "html_url": "https://github.com/rust-lang/rust/commit/5d97db8d480d58559e7490e1efdb0e45d1a8832f"}, {"sha": "29e6238cb7330f7d29f33ff03a4ccc0a0cec9f4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e6238cb7330f7d29f33ff03a4ccc0a0cec9f4d", "html_url": "https://github.com/rust-lang/rust/commit/29e6238cb7330f7d29f33ff03a4ccc0a0cec9f4d"}], "stats": {"total": 285, "additions": 247, "deletions": 38}, "files": [{"sha": "ffa3851068c230a764e316524b0b1a313ad51f5d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -1455,6 +1455,7 @@ dependencies = [\n  \"expect\",\n  \"hir\",\n  \"ide_db\",\n+ \"itertools\",\n  \"rustc-hash\",\n  \"syntax\",\n  \"test_utils\","}, {"sha": "7c2090de3cc59d9640e7376c46966489aa4ff5ea", "filename": "crates/ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2FCargo.toml?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -12,6 +12,7 @@ doctest = false\n \n [dependencies]\n rustc-hash = \"1.1.0\"\n+itertools = \"0.9.0\"\n \n text_edit = { path = \"../text_edit\" }\n syntax = { path = \"../syntax\" }"}, {"sha": "ba669fd56c98631f7a88dce6c50cbd799d2eeb6e", "filename": "crates/ssr/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Flib.rs?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -21,7 +21,10 @@\n // code in the `foo` module, we'll insert just `Bar`.\n //\n // Inherent method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will\n-// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n+// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`. When a\n+// placeholder is the receiver of a method call in the search pattern (e.g. `$s.foo()`), but not in\n+// the replacement template (e.g. `bar($s)`), then *, & and &mut will be added as needed to mirror\n+// whatever autoderef and autoref was happening implicitly in the matched code.\n //\n // The scope of the search / replace will be restricted to the current selection if any, otherwise\n // it will apply to the whole workspace."}, {"sha": "8bb5ced9007ff3e70f1c2c9a614d9cce0daf95eb", "filename": "crates/ssr/src/matching.rs", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fmatching.rs?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -2,7 +2,7 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Constraint, NodeKind, Placeholder},\n+    parsing::{Constraint, NodeKind, Placeholder, Var},\n     resolving::{ResolvedPattern, ResolvedRule, UfcsCallInfo},\n     SsrMatches,\n };\n@@ -56,10 +56,6 @@ pub struct Match {\n     pub(crate) rendered_template_paths: FxHashMap<SyntaxNode, hir::ModPath>,\n }\n \n-/// Represents a `$var` in an SSR query.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct Var(pub String);\n-\n /// Information about a placeholder bound in a match.\n #[derive(Debug)]\n pub(crate) struct PlaceholderMatch {\n@@ -69,6 +65,10 @@ pub(crate) struct PlaceholderMatch {\n     pub(crate) range: FileRange,\n     /// More matches, found within `node`.\n     pub(crate) inner_matches: SsrMatches,\n+    /// How many times the code that the placeholder matched needed to be dereferenced. Will only be\n+    /// non-zero if the placeholder matched to the receiver of a method call.\n+    pub(crate) autoderef_count: usize,\n+    pub(crate) autoref_kind: ast::SelfParamKind,\n }\n \n #[derive(Debug)]\n@@ -173,7 +173,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         // Handle placeholders.\n-        if let Some(placeholder) = self.get_placeholder(&SyntaxElement::Node(pattern.clone())) {\n+        if let Some(placeholder) = self.get_placeholder_for_node(pattern) {\n             for constraint in &placeholder.constraints {\n                 self.check_constraint(constraint, code)?;\n             }\n@@ -183,8 +183,8 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 // probably can't fail range validation, but just to be safe...\n                 self.validate_range(&original_range)?;\n                 matches_out.placeholder_values.insert(\n-                    Var(placeholder.ident.to_string()),\n-                    PlaceholderMatch::new(code, original_range),\n+                    placeholder.ident.clone(),\n+                    PlaceholderMatch::new(Some(code), original_range),\n                 );\n             }\n             return Ok(());\n@@ -487,7 +487,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 }\n                 if let Phase::Second(match_out) = phase {\n                     match_out.placeholder_values.insert(\n-                        Var(placeholder.ident.to_string()),\n+                        placeholder.ident.clone(),\n                         PlaceholderMatch::from_range(FileRange {\n                             file_id: self.sema.original_range(code).file_id,\n                             range: first_matched_token\n@@ -536,18 +536,40 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         if pattern_ufcs.function != code_resolved_function {\n             fail_match!(\"Method call resolved to a different function\");\n         }\n-        if code_resolved_function.has_self_param(self.sema.db) {\n-            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n-                self.check_expr_type(pattern_type, expr)?;\n-            }\n-        }\n         // Check arguments.\n         let mut pattern_args = pattern_ufcs\n             .call_expr\n             .arg_list()\n             .ok_or_else(|| match_error!(\"Pattern function call has no args\"))?\n             .args();\n-        self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        // If the function we're calling takes a self parameter, then we store additional\n+        // information on the placeholder match about autoderef and autoref. This allows us to use\n+        // the placeholder in a context where autoderef and autoref don't apply.\n+        if code_resolved_function.has_self_param(self.sema.db) {\n+            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n+                let deref_count = self.check_expr_type(pattern_type, expr)?;\n+                let pattern_receiver = pattern_args.next();\n+                self.attempt_match_opt(phase, pattern_receiver.clone(), code.expr())?;\n+                if let Phase::Second(match_out) = phase {\n+                    if let Some(placeholder_value) = pattern_receiver\n+                        .and_then(|n| self.get_placeholder_for_node(n.syntax()))\n+                        .and_then(|placeholder| {\n+                            match_out.placeholder_values.get_mut(&placeholder.ident)\n+                        })\n+                    {\n+                        placeholder_value.autoderef_count = deref_count;\n+                        placeholder_value.autoref_kind = self\n+                            .sema\n+                            .resolve_method_call_as_callable(code)\n+                            .and_then(|callable| callable.receiver_param(self.sema.db))\n+                            .map(|self_param| self_param.kind())\n+                            .unwrap_or(ast::SelfParamKind::Owned);\n+                    }\n+                }\n+            }\n+        } else {\n+            self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        }\n         let mut code_args =\n             code.arg_list().ok_or_else(|| match_error!(\"Code method call has no args\"))?.args();\n         loop {\n@@ -575,26 +597,35 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         self.attempt_match_node_children(phase, pattern_ufcs.call_expr.syntax(), code.syntax())\n     }\n \n+    /// Verifies that `expr` matches `pattern_type`, possibly after dereferencing some number of\n+    /// times. Returns the number of times it needed to be dereferenced.\n     fn check_expr_type(\n         &self,\n         pattern_type: &hir::Type,\n         expr: &ast::Expr,\n-    ) -> Result<(), MatchFailed> {\n+    ) -> Result<usize, MatchFailed> {\n         use hir::HirDisplay;\n         let code_type = self.sema.type_of_expr(&expr).ok_or_else(|| {\n             match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n         })?;\n-        if !code_type\n+        // Temporary needed to make the borrow checker happy.\n+        let res = code_type\n             .autoderef(self.sema.db)\n-            .any(|deref_code_type| *pattern_type == deref_code_type)\n-        {\n-            fail_match!(\n-                \"Pattern type `{}` didn't match code type `{}`\",\n-                pattern_type.display(self.sema.db),\n-                code_type.display(self.sema.db)\n-            );\n-        }\n-        Ok(())\n+            .enumerate()\n+            .find(|(_, deref_code_type)| pattern_type == deref_code_type)\n+            .map(|(count, _)| count)\n+            .ok_or_else(|| {\n+                match_error!(\n+                    \"Pattern type `{}` didn't match code type `{}`\",\n+                    pattern_type.display(self.sema.db),\n+                    code_type.display(self.sema.db)\n+                )\n+            });\n+        res\n+    }\n+\n+    fn get_placeholder_for_node(&self, node: &SyntaxNode) -> Option<&Placeholder> {\n+        self.get_placeholder(&SyntaxElement::Node(node.clone()))\n     }\n \n     fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n@@ -676,12 +707,18 @@ fn recording_match_fail_reasons() -> bool {\n }\n \n impl PlaceholderMatch {\n-    fn new(node: &SyntaxNode, range: FileRange) -> Self {\n-        Self { node: Some(node.clone()), range, inner_matches: SsrMatches::default() }\n+    fn new(node: Option<&SyntaxNode>, range: FileRange) -> Self {\n+        Self {\n+            node: node.cloned(),\n+            range,\n+            inner_matches: SsrMatches::default(),\n+            autoderef_count: 0,\n+            autoref_kind: ast::SelfParamKind::Owned,\n+        }\n     }\n \n     fn from_range(range: FileRange) -> Self {\n-        Self { node: None, range, inner_matches: SsrMatches::default() }\n+        Self::new(None, range)\n     }\n }\n "}, {"sha": "05b66dcd780e511181e809528e5b343473e45d5e", "filename": "crates/ssr/src/parsing.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fparsing.rs?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -8,7 +8,7 @@\n use crate::errors::bail;\n use crate::{SsrError, SsrPattern, SsrRule};\n use rustc_hash::{FxHashMap, FxHashSet};\n-use std::str::FromStr;\n+use std::{fmt::Display, str::FromStr};\n use syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, T};\n use test_utils::mark;\n \n@@ -34,12 +34,16 @@ pub(crate) enum PatternElement {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Placeholder {\n     /// The name of this placeholder. e.g. for \"$a\", this would be \"a\"\n-    pub(crate) ident: SmolStr,\n+    pub(crate) ident: Var,\n     /// A unique name used in place of this placeholder when we parse the pattern as Rust code.\n     stand_in_name: String,\n     pub(crate) constraints: Vec<Constraint>,\n }\n \n+/// Represents a `$var` in an SSR query.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct Var(pub String);\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Constraint {\n     Kind(NodeKind),\n@@ -205,7 +209,7 @@ fn parse_pattern(pattern_str: &str) -> Result<Vec<PatternElement>, SsrError> {\n         if token.kind == T![$] {\n             let placeholder = parse_placeholder(&mut tokens)?;\n             if !placeholder_names.insert(placeholder.ident.clone()) {\n-                bail!(\"Name `{}` repeats more than once\", placeholder.ident);\n+                bail!(\"Placeholder `{}` repeats more than once\", placeholder.ident);\n             }\n             res.push(PatternElement::Placeholder(placeholder));\n         } else {\n@@ -228,7 +232,7 @@ fn validate_rule(rule: &SsrRule) -> Result<(), SsrError> {\n     for p in &rule.template.tokens {\n         if let PatternElement::Placeholder(placeholder) = p {\n             if !defined_placeholders.contains(&placeholder.ident) {\n-                undefined.push(format!(\"${}\", placeholder.ident));\n+                undefined.push(placeholder.ident.to_string());\n             }\n             if !placeholder.constraints.is_empty() {\n                 bail!(\"Replacement placeholders cannot have constraints\");\n@@ -344,7 +348,17 @@ impl NodeKind {\n \n impl Placeholder {\n     fn new(name: SmolStr, constraints: Vec<Constraint>) -> Self {\n-        Self { stand_in_name: format!(\"__placeholder_{}\", name), constraints, ident: name }\n+        Self {\n+            stand_in_name: format!(\"__placeholder_{}\", name),\n+            constraints,\n+            ident: Var(name.to_string()),\n+        }\n+    }\n+}\n+\n+impl Display for Var {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"${}\", self.0)\n     }\n }\n "}, {"sha": "29284e3f1c2dad5e5294de577735ffbb66ff973d", "filename": "crates/ssr/src/replacing.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Freplacing.rs?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -1,10 +1,11 @@\n //! Code for applying replacement templates for matches that have previously been found.\n \n-use crate::matching::Var;\n use crate::{resolving::ResolvedRule, Match, SsrMatches};\n+use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast::{self, AstToken};\n use syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize};\n+use test_utils::mark;\n use text_edit::TextEdit;\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n@@ -114,11 +115,33 @@ impl ReplacementRenderer<'_> {\n     fn render_token(&mut self, token: &SyntaxToken) {\n         if let Some(placeholder) = self.rule.get_placeholder(&token) {\n             if let Some(placeholder_value) =\n-                self.match_info.placeholder_values.get(&Var(placeholder.ident.to_string()))\n+                self.match_info.placeholder_values.get(&placeholder.ident)\n             {\n                 let range = &placeholder_value.range.range;\n                 let mut matched_text =\n                     self.file_src[usize::from(range.start())..usize::from(range.end())].to_owned();\n+                // If a method call is performed directly on the placeholder, then autoderef and\n+                // autoref will apply, so we can just substitute whatever the placeholder matched to\n+                // directly. If we're not applying a method call, then we need to add explicitly\n+                // deref and ref in order to match whatever was being done implicitly at the match\n+                // site.\n+                if !token_is_method_call_receiver(token)\n+                    && (placeholder_value.autoderef_count > 0\n+                        || placeholder_value.autoref_kind != ast::SelfParamKind::Owned)\n+                {\n+                    mark::hit!(replace_autoref_autoderef_capture);\n+                    let ref_kind = match placeholder_value.autoref_kind {\n+                        ast::SelfParamKind::Owned => \"\",\n+                        ast::SelfParamKind::Ref => \"&\",\n+                        ast::SelfParamKind::MutRef => \"&mut \",\n+                    };\n+                    matched_text = format!(\n+                        \"{}{}{}\",\n+                        ref_kind,\n+                        \"*\".repeat(placeholder_value.autoderef_count),\n+                        matched_text\n+                    );\n+                }\n                 let edit = matches_to_edit_at_offset(\n                     &placeholder_value.inner_matches,\n                     self.file_src,\n@@ -179,6 +202,29 @@ impl ReplacementRenderer<'_> {\n     }\n }\n \n+/// Returns whether token is the receiver of a method call. Note, being within the receiver of a\n+/// method call doesn't count. e.g. if the token is `$a`, then `$a.foo()` will return true, while\n+/// `($a + $b).foo()` or `x.foo($a)` will return false.\n+fn token_is_method_call_receiver(token: &SyntaxToken) -> bool {\n+    use syntax::ast::AstNode;\n+    // Find the first method call among the ancestors of `token`, then check if the only token\n+    // within the receiver is `token`.\n+    if let Some(receiver) =\n+        token.ancestors().find_map(ast::MethodCallExpr::cast).and_then(|call| call.expr())\n+    {\n+        let tokens = receiver.syntax().descendants_with_tokens().filter_map(|node_or_token| {\n+            match node_or_token {\n+                SyntaxElement::Token(t) => Some(t),\n+                _ => None,\n+            }\n+        });\n+        if let Some((only_token,)) = tokens.collect_tuple() {\n+            return only_token == *token;\n+        }\n+    }\n+    false\n+}\n+\n fn parse_as_kind(code: &str, kind: SyntaxKind) -> Option<SyntaxNode> {\n     use syntax::ast::AstNode;\n     if ast::Expr::can_cast(kind) {"}, {"sha": "e45c88864d7aabc0d106d1f240575b2cd15e0fc6", "filename": "crates/ssr/src/tests.rs", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95c5e21219cd6569e2630637fd4268e24c0ca03/crates%2Fssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Ftests.rs?ref=a95c5e21219cd6569e2630637fd4268e24c0ca03", "patch": "@@ -31,7 +31,7 @@ fn parser_two_delimiters() {\n fn parser_repeated_name() {\n     assert_eq!(\n         parse_error_text(\"foo($a, $a) ==>>\"),\n-        \"Parse error: Name `a` repeats more than once\"\n+        \"Parse error: Placeholder `$a` repeats more than once\"\n     );\n }\n \n@@ -1172,3 +1172,110 @@ fn match_trait_method_call() {\n     assert_matches(\"Bar::foo($a, $b)\", code, &[\"v1.foo(1)\", \"Bar::foo(&v1, 3)\", \"v1_ref.foo(5)\"]);\n     assert_matches(\"Bar2::foo($a, $b)\", code, &[\"v2.foo(2)\", \"Bar2::foo(&v2, 4)\", \"v2_ref.foo(6)\"]);\n }\n+\n+#[test]\n+fn replace_autoref_autoderef_capture() {\n+    // Here we have several calls to `$a.foo()`. In the first case autoref is applied, in the\n+    // second, we already have a reference, so it isn't. When $a is used in a context where autoref\n+    // doesn't apply, we need to prefix it with `&`. Finally, we have some cases where autoderef\n+    // needs to be applied.\n+    mark::check!(replace_autoref_autoderef_capture);\n+    let code = r#\"\n+        struct Foo {}\n+        impl Foo {\n+            fn foo(&self) {}\n+            fn foo2(&self) {}\n+        }\n+        fn bar(_: &Foo) {}\n+        fn main() {\n+            let f = Foo {};\n+            let fr = &f;\n+            let fr2 = &fr;\n+            let fr3 = &fr2;\n+            f.foo();\n+            fr.foo();\n+            fr2.foo();\n+            fr3.foo();\n+        }\n+        \"#;\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> bar($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&self) {}\n+                fn foo2(&self) {}\n+            }\n+            fn bar(_: &Foo) {}\n+            fn main() {\n+                let f = Foo {};\n+                let fr = &f;\n+                let fr2 = &fr;\n+                let fr3 = &fr2;\n+                bar(&f);\n+                bar(&*fr);\n+                bar(&**fr2);\n+                bar(&***fr3);\n+            }\n+        \"#]],\n+    );\n+    // If the placeholder is used as the receiver of another method call, then we don't need to\n+    // explicitly autoderef or autoref.\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> $a.foo2()\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&self) {}\n+                fn foo2(&self) {}\n+            }\n+            fn bar(_: &Foo) {}\n+            fn main() {\n+                let f = Foo {};\n+                let fr = &f;\n+                let fr2 = &fr;\n+                let fr3 = &fr2;\n+                f.foo2();\n+                fr.foo2();\n+                fr2.foo2();\n+                fr3.foo2();\n+            }\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_autoref_mut() {\n+    let code = r#\"\n+        struct Foo {}\n+        impl Foo {\n+            fn foo(&mut self) {}\n+        }\n+        fn bar(_: &mut Foo) {}\n+        fn main() {\n+            let mut f = Foo {};\n+            f.foo();\n+            let fr = &mut f;\n+            fr.foo();\n+        }\n+        \"#;\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> bar($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&mut self) {}\n+            }\n+            fn bar(_: &mut Foo) {}\n+            fn main() {\n+                let mut f = Foo {};\n+                bar(&mut f);\n+                let fr = &mut f;\n+                bar(&mut *fr);\n+            }\n+        \"#]],\n+    );\n+}"}]}