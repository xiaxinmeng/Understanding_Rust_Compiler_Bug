{"sha": "0a11090053d73af94de3c1a96d125c4980a16626", "node_id": "C_kwDOAAsO6NoAKDBhMTEwOTAwNTNkNzNhZjk0ZGUzYzFhOTZkMTI1YzQ5ODBhMTY2MjY", "commit": {"author": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2021-05-10T20:56:27Z"}, "committer": {"name": "gilescope", "email": "gilescope@gmail.com", "date": "2022-03-26T14:25:18Z"}, "message": "faster parsing when not possible to overflow", "tree": {"sha": "4d9524ddd2ba785ac4f1fed996e07cfbd0a50811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d9524ddd2ba785ac4f1fed996e07cfbd0a50811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a11090053d73af94de3c1a96d125c4980a16626", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0hoVRXRPubZAqGkYx9jUtSpSe8FAmI/Ik4ACgkQYx9jUtSp\nSe/+bA//c2340iR89baimwKVJUnemOYwPxXbhsEUCFCunLWLaev0SmURG8jaBx6u\njZZxSimWc9wMEvEBJpdSR8xI15gwZTUkWNHTMNp0hpwuRdPDEKoCT8w/duVoOBTE\n2OP7xMGkpD56lTwnXPfYAeK3Mx9k1jtaMECU1sOWRH2xelzUuZCQRPT/mPaSp3s0\njAsPNiJQpBSKKhWftKANglejDhN1KqrZUFuK5UCL8uu/URLOKue7vfGPa5KEQgJN\n4D/1EYDsq36Op+L7WFvnSziubUqaLndb+aP1SkXHICDX4uuaXWcyjVyn6HBT16Wu\nI5WGCb/YyFpinZJDvEIAuxGZsDq1IksVOyG1GjD2P8i+Hlht5G+A3EZ0fg6njXse\nMFRjjtyj8nUnvqWuvXwyojaFE2AY7C7S1+dsx3fzFBozMmNjQiiPm76c7vNUErx9\nKuYFDO/sI21/UZxS/3KgjCIuoWpkBxuz+QrdP83UUllEcWGDKk1Ji7yBb3CUgk2f\nRs+1I572PnuU74NkWVFzXgTXSD0fkgAXQDU+A4fEhgW+FOJOpyNeK4dhqynbEef2\nFxKSW84+x7uzz9guGHROMpHs6pVio03fPYUbg2SKr79aYHA6s3faatcLKspW0b5D\nRLGJ51qhya/aNGBXad/dqKWxLDZrwmUWsqIClQCBvCHzCMYh49M=\n=s/dM\n-----END PGP SIGNATURE-----", "payload": "tree 4d9524ddd2ba785ac4f1fed996e07cfbd0a50811\nparent bc881e83d1cced71046e844fa55c0b0e9f9af382\nauthor Giles Cope <gilescope@gmail.com> 1620680187 +0100\ncommitter gilescope <gilescope@gmail.com> 1648304718 +0000\n\nfaster parsing when not possible to overflow\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a11090053d73af94de3c1a96d125c4980a16626", "html_url": "https://github.com/rust-lang/rust/commit/0a11090053d73af94de3c1a96d125c4980a16626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a11090053d73af94de3c1a96d125c4980a16626/comments", "author": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc881e83d1cced71046e844fa55c0b0e9f9af382", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc881e83d1cced71046e844fa55c0b0e9f9af382", "html_url": "https://github.com/rust-lang/rust/commit/bc881e83d1cced71046e844fa55c0b0e9f9af382"}], "stats": {"total": 85, "additions": 50, "deletions": 35}, "files": [{"sha": "5fd697fd4285f40e2f9b53ee6bc7cd496fdaf58b", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0a11090053d73af94de3c1a96d125c4980a16626/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a11090053d73af94de3c1a96d125c4980a16626/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=0a11090053d73af94de3c1a96d125c4980a16626", "patch": "@@ -970,12 +970,14 @@ pub enum FpCategory {\n \n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n-    fn min_value() -> Self;\n-    fn max_value() -> Self;\n+    const MIN: Self;\n     fn from_u32(u: u32) -> Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_sub(&self, other: u32) -> Option<Self>;\n     fn checked_add(&self, other: u32) -> Option<Self>;\n+    unsafe fn unchecked_mul(&self, other: u32) -> Self;\n+    unsafe fn unchecked_sub(&self, other: u32) -> Self;\n+    unsafe fn unchecked_add(&self, other: u32) -> Self;\n }\n \n macro_rules! from_str_radix_int_impl {\n@@ -993,10 +995,7 @@ from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n-        #[inline]\n-        fn min_value() -> Self { Self::MIN }\n-        #[inline]\n-        fn max_value() -> Self { Self::MAX }\n+        const MIN: Self = Self::MIN;\n         #[inline]\n         fn from_u32(u: u32) -> Self { u as Self }\n         #[inline]\n@@ -1011,6 +1010,27 @@ macro_rules! doit {\n         fn checked_add(&self, other: u32) -> Option<Self> {\n             Self::checked_add(*self, other as Self)\n         }\n+        #[inline]\n+        unsafe fn unchecked_mul(&self, other: u32) -> Self {\n+            // SAFETY:  Conditions of `Self::unchecked_mul` must be upheld by the caller.\n+            unsafe {\n+                Self::unchecked_mul(*self, other as Self)\n+            }\n+        }\n+        #[inline]\n+        unsafe fn unchecked_sub(&self, other: u32) -> Self {\n+            // SAFETY:  Conditions of `Self::unchecked_sub` must be upheld by the caller.\n+            unsafe {\n+                Self::unchecked_sub(*self, other as Self)\n+            }\n+        }\n+        #[inline]\n+        unsafe fn unchecked_add(&self, other: u32) -> Self {\n+            // SAFETY: Conditions of `Self::unchecked_add` must be upheld by the caller.\n+            unsafe {\n+                Self::unchecked_add(*self, other as Self)\n+            }\n+        }\n     })*)\n }\n doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n@@ -1029,7 +1049,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n         return Err(PIE { kind: Empty });\n     }\n \n-    let is_signed_ty = T::from_u32(0) > T::min_value();\n+    let is_signed_ty = T::from_u32(0) > T::MIN;\n \n     // all valid digits are ascii, so we will just iterate over the utf8 bytes\n     // and cast them to chars. .to_digit() will safely return None for anything\n@@ -1047,37 +1067,32 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     };\n \n     let mut result = T::from_u32(0);\n-    if is_positive {\n-        // The number is positive\n-        for &c in digits {\n-            let x = match (c as char).to_digit(radix) {\n-                Some(x) => x,\n-                None => return Err(PIE { kind: InvalidDigit }),\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: PosOverflow }),\n-            };\n-            result = match result.checked_add(x) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: PosOverflow }),\n-            };\n+\n+    if radix <= 16 && digits.len() <= mem::size_of::<T>() * 2 - is_signed_ty as usize {\n+        // SAFETY: Consider the highest radix of 16:\n+        // `u8::MAX` is `ff` (2 characters), `u16::MAX` is `ffff` (4 characters)\n+        // We can be sure that any src len of 2 would fit in a u8 so we don't need\n+        // to check for overflow.\n+        unsafe {\n+            let unchecked_additive_op =\n+                if is_positive { T::unchecked_add } else { T::unchecked_sub };\n+\n+            for &c in digits {\n+                result = result.unchecked_mul(radix);\n+                let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;\n+                result = unchecked_additive_op(&result, x);\n+            }\n         }\n     } else {\n-        // The number is negative\n+        let additive_op = if is_positive { T::checked_add } else { T::checked_sub };\n+        let overflow_err = || PIE { kind: if is_positive { PosOverflow } else { NegOverflow } };\n+\n         for &c in digits {\n-            let x = match (c as char).to_digit(radix) {\n-                Some(x) => x,\n-                None => return Err(PIE { kind: InvalidDigit }),\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: NegOverflow }),\n-            };\n-            result = match result.checked_sub(x) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: NegOverflow }),\n-            };\n+            let mul = result.checked_mul(radix);\n+            let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;\n+            // multiply done early for performance reasons.\n+            result = mul.ok_or_else(overflow_err)?;\n+            result = additive_op(&result, x).ok_or_else(overflow_err)?;\n         }\n     }\n     Ok(result)"}]}