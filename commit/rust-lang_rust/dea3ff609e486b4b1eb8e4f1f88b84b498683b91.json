{"sha": "dea3ff609e486b4b1eb8e4f1f88b84b498683b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYTNmZjYwOWU0ODZiNGIxZWI4ZTRmMWY4OGI4NGI0OTg2ODNiOTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-10T16:06:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-10T16:06:01Z"}, "message": "Merge #8458\n\n8458: Respect test style guidelines in tests::traits r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a308319eb5c28c38f9994a1bd5361209dd1fb5fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a308319eb5c28c38f9994a1bd5361209dd1fb5fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dea3ff609e486b4b1eb8e4f1f88b84b498683b91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgcczpCRBK7hj4Ov3rIwAAdHIIAJw/IDRxst6tXYLsja3lrHSU\nK9HYs3vq1y2oL29DM46dz6Wtd1iRbOvlIiywE/oz95pURYtTGtsB7Z4ryzZDmr2r\nAh2G1GE5FURPDK71yDEAzwrw6biZQLORPVTIFv84yXmRGZDJjlVVwx06O/u5tOdL\nq4tFlEZYVkhbsWLkiooqPMPUJbQUoh5O/0Bihqo6EeGX8+w5R65zAUJIxWQN5g9L\nM8rpF5sAw8sXf1xaq5E4+anEIgpmdCRCnsX1QVPq+KUmlLfJm01WdUDPj8Ch47Fh\nFRbBesX+ZqFj9gvgJGi8FotUhGqV8wYMQ9xZv+r6jIB53U29cZ3oKB8j4gtgFSQ=\n=2tWe\n-----END PGP SIGNATURE-----\n", "payload": "tree a308319eb5c28c38f9994a1bd5361209dd1fb5fd\nparent 4bf32eea21d1bbf268951f7f30b1356485bd547b\nparent 8113c3a914c7b4fc27a7b5af321711a83af716d9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618070761 +0000\ncommitter GitHub <noreply@github.com> 1618070761 +0000\n\nMerge #8458\n\n8458: Respect test style guidelines in tests::traits r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dea3ff609e486b4b1eb8e4f1f88b84b498683b91", "html_url": "https://github.com/rust-lang/rust/commit/dea3ff609e486b4b1eb8e4f1f88b84b498683b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dea3ff609e486b4b1eb8e4f1f88b84b498683b91/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bf32eea21d1bbf268951f7f30b1356485bd547b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf32eea21d1bbf268951f7f30b1356485bd547b", "html_url": "https://github.com/rust-lang/rust/commit/4bf32eea21d1bbf268951f7f30b1356485bd547b"}, {"sha": "8113c3a914c7b4fc27a7b5af321711a83af716d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8113c3a914c7b4fc27a7b5af321711a83af716d9", "html_url": "https://github.com/rust-lang/rust/commit/8113c3a914c7b4fc27a7b5af321711a83af716d9"}], "stats": {"total": 1354, "additions": 656, "deletions": 698}, "files": [{"sha": "ffc7c8ef4ddf545dff6dd3500ab99cb7c821ee79", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 656, "deletions": 698, "changes": 1354, "blob_url": "https://github.com/rust-lang/rust/blob/dea3ff609e486b4b1eb8e4f1f88b84b498683b91/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dea3ff609e486b4b1eb8e4f1f88b84b498683b91/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=dea3ff609e486b4b1eb8e4f1f88b84b498683b91", "patch": "@@ -263,15 +263,14 @@ mod ops {\n fn infer_from_bound_1() {\n     check_infer(\n         r#\"\n-        trait Trait<T> {}\n-        struct S<T>(T);\n-        impl<U> Trait<U> for S<U> {}\n-        fn foo<T: Trait<u32>>(t: T) {}\n-        fn test() {\n-            let s = S(unknown);\n-            foo(s);\n-        }\n-        \"#,\n+trait Trait<T> {}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn foo<T: Trait<u32>>(t: T) {}\n+fn test() {\n+    let s = S(unknown);\n+    foo(s);\n+}\"#,\n         expect![[r#\"\n             85..86 't': T\n             91..93 '{}': ()\n@@ -291,15 +290,14 @@ fn infer_from_bound_1() {\n fn infer_from_bound_2() {\n     check_infer(\n         r#\"\n-        trait Trait<T> {}\n-        struct S<T>(T);\n-        impl<U> Trait<U> for S<U> {}\n-        fn foo<U, T: Trait<U>>(t: T) -> U {}\n-        fn test() {\n-            let s = S(unknown);\n-            let x: u32 = foo(s);\n-        }\n-        \"#,\n+trait Trait<T> {}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn foo<U, T: Trait<U>>(t: T) -> U {}\n+fn test() {\n+    let s = S(unknown);\n+    let x: u32 = foo(s);\n+}\"#,\n         expect![[r#\"\n             86..87 't': T\n             97..99 '{}': ()\n@@ -321,13 +319,12 @@ fn trait_default_method_self_bound_implements_trait() {\n     cov_mark::check!(trait_self_implements_self);\n     check_infer(\n         r#\"\n-        trait Trait {\n-            fn foo(&self) -> i64;\n-            fn bar(&self) -> {\n-                let x = self.foo();\n-            }\n-        }\n-        \"#,\n+trait Trait {\n+    fn foo(&self) -> i64;\n+    fn bar(&self) -> {\n+        let x = self.foo();\n+    }\n+}\"#,\n         expect![[r#\"\n             26..30 'self': &Self\n             52..56 'self': &Self\n@@ -343,15 +340,14 @@ fn trait_default_method_self_bound_implements_trait() {\n fn trait_default_method_self_bound_implements_super_trait() {\n     check_infer(\n         r#\"\n-        trait SuperTrait {\n-            fn foo(&self) -> i64;\n-        }\n-        trait Trait: SuperTrait {\n-            fn bar(&self) -> {\n-                let x = self.foo();\n-            }\n-        }\n-        \"#,\n+trait SuperTrait {\n+    fn foo(&self) -> i64;\n+}\n+trait Trait: SuperTrait {\n+    fn bar(&self) -> {\n+        let x = self.foo();\n+    }\n+}\"#,\n         expect![[r#\"\n             31..35 'self': &Self\n             85..89 'self': &Self\n@@ -367,18 +363,17 @@ fn trait_default_method_self_bound_implements_super_trait() {\n fn infer_project_associated_type() {\n     check_infer(\n         r#\"\n-        trait Iterable {\n-            type Item;\n-        }\n-        struct S;\n-        impl Iterable for S { type Item = u32; }\n-        fn test<T: Iterable>() {\n-            let x: <S as Iterable>::Item = 1;\n-            let y: <T as Iterable>::Item = no_matter;\n-            let z: T::Item = no_matter;\n-            let a: <T>::Item = no_matter;\n-        }\n-        \"#,\n+trait Iterable {\n+    type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn test<T: Iterable>() {\n+    let x: <S as Iterable>::Item = 1;\n+    let y: <T as Iterable>::Item = no_matter;\n+    let z: T::Item = no_matter;\n+    let a: <T>::Item = no_matter;\n+}\"#,\n         expect![[r#\"\n             108..261 '{     ...ter; }': ()\n             118..119 'x': u32\n@@ -397,20 +392,19 @@ fn infer_project_associated_type() {\n fn infer_return_associated_type() {\n     check_infer(\n         r#\"\n-        trait Iterable {\n-            type Item;\n-        }\n-        struct S;\n-        impl Iterable for S { type Item = u32; }\n-        fn foo1<T: Iterable>(t: T) -> T::Item {}\n-        fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n-        fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n-        fn test() {\n-            let x = foo1(S);\n-            let y = foo2(S);\n-            let z = foo3(S);\n-        }\n-        \"#,\n+trait Iterable {\n+    type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn foo1<T: Iterable>(t: T) -> T::Item {}\n+fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n+fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n+fn test() {\n+    let x = foo1(S);\n+    let y = foo2(S);\n+    let z = foo3(S);\n+}\"#,\n         expect![[r#\"\n             106..107 't': T\n             123..125 '{}': ()\n@@ -439,13 +433,12 @@ fn infer_return_associated_type() {\n fn infer_associated_type_bound() {\n     check_infer(\n         r#\"\n-        trait Iterable {\n-            type Item;\n-        }\n-        fn test<T: Iterable<Item=u32>>() {\n-            let y: T::Item = unknown;\n-        }\n-        \"#,\n+trait Iterable {\n+    type Item;\n+}\n+fn test<T: Iterable<Item=u32>>() {\n+    let y: T::Item = unknown;\n+}\"#,\n         expect![[r#\"\n             67..100 '{     ...own; }': ()\n             77..78 'y': u32\n@@ -458,9 +451,8 @@ fn infer_associated_type_bound() {\n fn infer_const_body() {\n     check_infer(\n         r#\"\n-        const A: u32 = 1 + 1;\n-        static B: u64 = { let x = 1; x };\n-        \"#,\n+const A: u32 = 1 + 1;\n+static B: u64 = { let x = 1; x };\"#,\n         expect![[r#\"\n             15..16 '1': u32\n             15..20 '1 + 1': u32\n@@ -477,13 +469,12 @@ fn infer_const_body() {\n fn tuple_struct_fields() {\n     check_infer(\n         r#\"\n-        struct S(i32, u64);\n-        fn test() -> u64 {\n-            let a = S(4, 6);\n-            let b = a.0;\n-            a.1\n-        }\n-        \"#,\n+struct S(i32, u64);\n+fn test() -> u64 {\n+    let a = S(4, 6);\n+    let b = a.0;\n+    a.1\n+}\"#,\n         expect![[r#\"\n             37..86 '{     ... a.1 }': u64\n             47..48 'a': S\n@@ -504,13 +495,12 @@ fn tuple_struct_fields() {\n fn tuple_struct_with_fn() {\n     check_infer(\n         r#\"\n-        struct S(fn(u32) -> u64);\n-        fn test() -> u64 {\n-            let a = S(|i| 2*i);\n-            let b = a.0(4);\n-            a.0(2)\n-        }\n-        \"#,\n+struct S(fn(u32) -> u64);\n+fn test() -> u64 {\n+    let a = S(|i| 2*i);\n+    let b = a.0(4);\n+    a.0(2)\n+}\"#,\n         expect![[r#\"\n             43..101 '{     ...0(2) }': u64\n             53..54 'a': S\n@@ -949,27 +939,26 @@ fn test<T: ApplyL>(t: T) {\n fn argument_impl_trait() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait Trait<T> {\n-            fn foo(&self) -> T;\n-            fn foo2(&self) -> i64;\n-        }\n-        fn bar(x: impl Trait<u16>) {}\n-        struct S<T>(T);\n-        impl<T> Trait<T> for S<T> {}\n-\n-        fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n-            x;\n-            y;\n-            let z = S(1);\n-            bar(z);\n-            x.foo();\n-            y.foo();\n-            z.foo();\n-            x.foo2();\n-            y.foo2();\n-            z.foo2();\n-        }\n-        \"#,\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar(x: impl Trait<u16>) {}\n+struct S<T>(T);\n+impl<T> Trait<T> for S<T> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n+    x;\n+    y;\n+    let z = S(1);\n+    bar(z);\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\"#,\n         expect![[r#\"\n             29..33 'self': &Self\n             54..58 'self': &Self\n@@ -1007,30 +996,29 @@ fn argument_impl_trait() {\n fn argument_impl_trait_type_args_1() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait Trait {}\n-        trait Foo {\n-            // this function has an implicit Self param, an explicit type param,\n-            // and an implicit impl Trait param!\n-            fn bar<T>(x: impl Trait) -> T { loop {} }\n-        }\n-        fn foo<T>(x: impl Trait) -> T { loop {} }\n-        struct S;\n-        impl Trait for S {}\n-        struct F;\n-        impl Foo for F {}\n-\n-        fn test() {\n-            Foo::bar(S);\n-            <F as Foo>::bar(S);\n-            F::bar(S);\n-            Foo::bar::<u32>(S);\n-            <F as Foo>::bar::<u32>(S);\n-\n-            foo(S);\n-            foo::<u32>(S);\n-            foo::<u32, i32>(S); // we should ignore the extraneous i32\n-        }\n-        \"#,\n+trait Trait {}\n+trait Foo {\n+    // this function has an implicit Self param, an explicit type param,\n+    // and an implicit impl Trait param!\n+    fn bar<T>(x: impl Trait) -> T { loop {} }\n+}\n+fn foo<T>(x: impl Trait) -> T { loop {} }\n+struct S;\n+impl Trait for S {}\n+struct F;\n+impl Foo for F {}\n+\n+fn test() {\n+    Foo::bar(S);\n+    <F as Foo>::bar(S);\n+    F::bar(S);\n+    Foo::bar::<u32>(S);\n+    <F as Foo>::bar::<u32>(S);\n+\n+    foo(S);\n+    foo::<u32>(S);\n+    foo::<u32, i32>(S); // we should ignore the extraneous i32\n+}\"#,\n         expect![[r#\"\n             155..156 'x': impl Trait\n             175..186 '{ loop {} }': T\n@@ -1073,21 +1061,20 @@ fn argument_impl_trait_type_args_1() {\n fn argument_impl_trait_type_args_2() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait Trait {}\n-        struct S;\n-        impl Trait for S {}\n-        struct F<T>;\n-        impl<T> F<T> {\n-            fn foo<U>(self, x: impl Trait) -> (T, U) { loop {} }\n-        }\n+trait Trait {}\n+struct S;\n+impl Trait for S {}\n+struct F<T>;\n+impl<T> F<T> {\n+    fn foo<U>(self, x: impl Trait) -> (T, U) { loop {} }\n+}\n \n-        fn test() {\n-            F.foo(S);\n-            F::<u32>.foo(S);\n-            F::<u32>.foo::<i32>(S);\n-            F::<u32>.foo::<i32, u32>(S); // extraneous argument should be ignored\n-        }\n-        \"#,\n+fn test() {\n+    F.foo(S);\n+    F::<u32>.foo(S);\n+    F::<u32>.foo::<i32>(S);\n+    F::<u32>.foo::<i32, u32>(S); // extraneous argument should be ignored\n+}\"#,\n         expect![[r#\"\n             87..91 'self': F<T>\n             93..94 'x': impl Trait\n@@ -1115,15 +1102,14 @@ fn argument_impl_trait_type_args_2() {\n fn argument_impl_trait_to_fn_pointer() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait Trait {}\n-        fn foo(x: impl Trait) { loop {} }\n-        struct S;\n-        impl Trait for S {}\n+trait Trait {}\n+fn foo(x: impl Trait) { loop {} }\n+struct S;\n+impl Trait for S {}\n \n-        fn test() {\n-            let f: fn(S) -> () = foo;\n-        }\n-        \"#,\n+fn test() {\n+    let f: fn(S) -> () = foo;\n+}\"#,\n         expect![[r#\"\n             22..23 'x': impl Trait\n             37..48 '{ loop {} }': ()\n@@ -1140,24 +1126,23 @@ fn argument_impl_trait_to_fn_pointer() {\n fn impl_trait() {\n     check_infer(\n         r#\"\n-        trait Trait<T> {\n-            fn foo(&self) -> T;\n-            fn foo2(&self) -> i64;\n-        }\n-        fn bar() -> impl Trait<u64> {}\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> impl Trait<u64> {}\n \n-        fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n-            x;\n-            y;\n-            let z = bar();\n-            x.foo();\n-            y.foo();\n-            z.foo();\n-            x.foo2();\n-            y.foo2();\n-            z.foo2();\n-        }\n-        \"#,\n+fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\"#,\n         expect![[r#\"\n             29..33 'self': &Self\n             54..58 'self': &Self\n@@ -1191,16 +1176,15 @@ fn simple_return_pos_impl_trait() {\n     cov_mark::check!(lower_rpit);\n     check_infer(\n         r#\"\n-        trait Trait<T> {\n-            fn foo(&self) -> T;\n-        }\n-        fn bar() -> impl Trait<u64> { loop {} }\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> impl Trait<u64> { loop {} }\n \n-        fn test() {\n-            let a = bar();\n-            a.foo();\n-        }\n-        \"#,\n+fn test() {\n+    let a = bar();\n+    a.foo();\n+}\"#,\n         expect![[r#\"\n             29..33 'self': &Self\n             71..82 '{ loop {} }': !\n@@ -1220,25 +1204,24 @@ fn simple_return_pos_impl_trait() {\n fn more_return_pos_impl_trait() {\n     check_infer(\n         r#\"\n-        trait Iterator {\n-            type Item;\n-            fn next(&mut self) -> Self::Item;\n-        }\n-        trait Trait<T> {\n-            fn foo(&self) -> T;\n-        }\n-        fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>) { loop {} }\n-        fn baz<T>(t: T) -> (impl Iterator<Item = impl Trait<T>>, impl Trait<T>) { loop {} }\n-\n-        fn test() {\n-            let (a, b) = bar();\n-            a.next().foo();\n-            b.foo();\n-            let (c, d) = baz(1u128);\n-            c.next().foo();\n-            d.foo();\n-        }\n-        \"#,\n+trait Iterator {\n+    type Item;\n+    fn next(&mut self) -> Self::Item;\n+}\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>) { loop {} }\n+fn baz<T>(t: T) -> (impl Iterator<Item = impl Trait<T>>, impl Trait<T>) { loop {} }\n+\n+fn test() {\n+    let (a, b) = bar();\n+    a.next().foo();\n+    b.foo();\n+    let (c, d) = baz(1u128);\n+    c.next().foo();\n+    d.foo();\n+}\"#,\n         expect![[r#\"\n             49..53 'self': &mut Self\n             101..105 'self': &Self\n@@ -1279,24 +1262,23 @@ fn more_return_pos_impl_trait() {\n fn dyn_trait() {\n     check_infer(\n         r#\"\n-        trait Trait<T> {\n-            fn foo(&self) -> T;\n-            fn foo2(&self) -> i64;\n-        }\n-        fn bar() -> dyn Trait<u64> {}\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> dyn Trait<u64> {}\n \n-        fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n-            x;\n-            y;\n-            let z = bar();\n-            x.foo();\n-            y.foo();\n-            z.foo();\n-            x.foo2();\n-            y.foo2();\n-            z.foo2();\n-        }\n-        \"#,\n+fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\"#,\n         expect![[r#\"\n             29..33 'self': &Self\n             54..58 'self': &Self\n@@ -1329,22 +1311,21 @@ fn dyn_trait() {\n fn dyn_trait_in_impl() {\n     check_infer(\n         r#\"\n-        trait Trait<T, U> {\n-            fn foo(&self) -> (T, U);\n-        }\n-        struct S<T, U> {}\n-        impl<T, U> S<T, U> {\n-            fn bar(&self) -> &dyn Trait<T, U> { loop {} }\n-        }\n-        trait Trait2<T, U> {\n-            fn baz(&self) -> (T, U);\n-        }\n-        impl<T, U> Trait2<T, U> for dyn Trait<T, U> { }\n+trait Trait<T, U> {\n+    fn foo(&self) -> (T, U);\n+}\n+struct S<T, U> {}\n+impl<T, U> S<T, U> {\n+    fn bar(&self) -> &dyn Trait<T, U> { loop {} }\n+}\n+trait Trait2<T, U> {\n+    fn baz(&self) -> (T, U);\n+}\n+impl<T, U> Trait2<T, U> for dyn Trait<T, U> { }\n \n-        fn test(s: S<u32, i32>) {\n-            s.bar().baz();\n-        }\n-        \"#,\n+fn test(s: S<u32, i32>) {\n+    s.bar().baz();\n+}\"#,\n         expect![[r#\"\n             32..36 'self': &Self\n             102..106 'self': &S<T, U>\n@@ -1365,20 +1346,19 @@ fn dyn_trait_in_impl() {\n fn dyn_trait_bare() {\n     check_infer(\n         r#\"\n-        trait Trait {\n-            fn foo(&self) -> u64;\n-        }\n-        fn bar() -> Trait {}\n+trait Trait {\n+    fn foo(&self) -> u64;\n+}\n+fn bar() -> Trait {}\n \n-        fn test(x: Trait, y: &Trait) -> u64 {\n-            x;\n-            y;\n-            let z = bar();\n-            x.foo();\n-            y.foo();\n-            z.foo();\n-        }\n-        \"#,\n+fn test(x: Trait, y: &Trait) -> u64 {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\"#,\n         expect![[r#\"\n             26..30 'self': &Self\n             60..62 '{}': ()\n@@ -1404,17 +1384,24 @@ fn dyn_trait_bare() {\n fn weird_bounds() {\n     check_infer(\n         r#\"\n-        trait Trait {}\n-        fn test(a: impl Trait + 'lifetime, b: impl 'lifetime, c: impl (Trait), d: impl ('lifetime), e: impl ?Sized, f: impl Trait + ?Sized) {}\n-        \"#,\n+trait Trait {}\n+fn test(\n+    a: impl Trait + 'lifetime,\n+    b: impl 'lifetime,\n+    c: impl (Trait),\n+    d: impl ('lifetime),\n+    e: impl ?Sized,\n+    f: impl Trait + ?Sized\n+) {}\n+\"#,\n         expect![[r#\"\n-            23..24 'a': impl Trait\n-            50..51 'b': impl\n-            69..70 'c': impl Trait\n-            86..87 'd': impl\n-            107..108 'e': impl\n-            123..124 'f': impl Trait\n-            147..149 '{}': ()\n+            28..29 'a': impl Trait\n+            59..60 'b': impl\n+            82..83 'c': impl Trait\n+            103..104 'd': impl\n+            128..129 'e': impl\n+            148..149 'f': impl Trait\n+            173..175 '{}': ()\n         \"#]],\n     );\n }\n@@ -1439,27 +1426,26 @@ fn test(x: (impl Trait + UnknownTrait)) {\n fn assoc_type_bindings() {\n     check_infer(\n         r#\"\n-        trait Trait {\n-            type Type;\n-        }\n+trait Trait {\n+    type Type;\n+}\n \n-        fn get<T: Trait>(t: T) -> <T as Trait>::Type {}\n-        fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n-        fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n-\n-        struct S<T>;\n-        impl<T> Trait for S<T> { type Type = T; }\n-\n-        fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n-            get(x);\n-            get2(x);\n-            get(y);\n-            get2(y);\n-            get(set(S));\n-            get2(set(S));\n-            get2(S::<str>);\n-        }\n-        \"#,\n+fn get<T: Trait>(t: T) -> <T as Trait>::Type {}\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> Trait for S<T> { type Type = T; }\n+\n+fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n+    get(x);\n+    get2(x);\n+    get(y);\n+    get2(y);\n+    get(set(S));\n+    get2(set(S));\n+    get2(S::<str>);\n+}\"#,\n         expect![[r#\"\n             49..50 't': T\n             77..79 '{}': ()\n@@ -1546,18 +1532,17 @@ mod iter {\n fn projection_eq_within_chalk() {\n     check_infer(\n         r#\"\n-        trait Trait1 {\n-            type Type;\n-        }\n-        trait Trait2<T> {\n-            fn foo(self) -> T;\n-        }\n-        impl<T, U> Trait2<T> for U where U: Trait1<Type = T> {}\n+trait Trait1 {\n+    type Type;\n+}\n+trait Trait2<T> {\n+    fn foo(self) -> T;\n+}\n+impl<T, U> Trait2<T> for U where U: Trait1<Type = T> {}\n \n-        fn test<T: Trait1<Type = u32>>(x: T) {\n-            x.foo();\n-        }\n-        \"#,\n+fn test<T: Trait1<Type = u32>>(x: T) {\n+    x.foo();\n+}\"#,\n         expect![[r#\"\n             61..65 'self': Self\n             163..164 'x': T\n@@ -1589,19 +1574,18 @@ fn test<T: foo::Trait>(x: T) {\n fn super_trait_method_resolution() {\n     check_infer(\n         r#\"\n-        mod foo {\n-            trait SuperTrait {\n-                fn foo(&self) -> u32 {}\n-            }\n-        }\n-        trait Trait1: foo::SuperTrait {}\n-        trait Trait2 where Self: foo::SuperTrait {}\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n+trait Trait2 where Self: foo::SuperTrait {}\n \n-        fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n-            x.foo();\n-            y.foo();\n-        }\n-        \"#,\n+fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n+    x.foo();\n+    y.foo();\n+}\"#,\n         expect![[r#\"\n             49..53 'self': &Self\n             62..64 '{}': ()\n@@ -1620,17 +1604,16 @@ fn super_trait_method_resolution() {\n fn super_trait_impl_trait_method_resolution() {\n     check_infer(\n         r#\"\n-        mod foo {\n-            trait SuperTrait {\n-                fn foo(&self) -> u32 {}\n-            }\n-        }\n-        trait Trait1: foo::SuperTrait {}\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n \n-        fn test(x: &impl Trait1) {\n-            x.foo();\n-        }\n-        \"#,\n+fn test(x: &impl Trait1) {\n+    x.foo();\n+}\"#,\n         expect![[r#\"\n             49..53 'self': &Self\n             62..64 '{}': ()\n@@ -1667,20 +1650,19 @@ fn super_trait_cycle() {\n fn super_trait_assoc_type_bounds() {\n     check_infer(\n         r#\"\n-        trait SuperTrait { type Type; }\n-        trait Trait where Self: SuperTrait {}\n+trait SuperTrait { type Type; }\n+trait Trait where Self: SuperTrait {}\n \n-        fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n-        fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n \n-        struct S<T>;\n-        impl<T> SuperTrait for S<T> { type Type = T; }\n-        impl<T> Trait for S<T> {}\n+struct S<T>;\n+impl<T> SuperTrait for S<T> { type Type = T; }\n+impl<T> Trait for S<T> {}\n \n-        fn test() {\n-            get2(set(S));\n-        }\n-        \"#,\n+fn test() {\n+    get2(set(S));\n+}\"#,\n         expect![[r#\"\n             102..103 't': T\n             113..115 '{}': ()\n@@ -1701,16 +1683,15 @@ fn super_trait_assoc_type_bounds() {\n fn fn_trait() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait FnOnce<Args> {\n-            type Output;\n+trait FnOnce<Args> {\n+    type Output;\n \n-            fn call_once(self, args: Args) -> <Self as FnOnce<Args>>::Output;\n-        }\n+    fn call_once(self, args: Args) -> <Self as FnOnce<Args>>::Output;\n+}\n \n-        fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n-            f.call_once((1, 2));\n-        }\n-        \"#,\n+fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n+    f.call_once((1, 2));\n+}\"#,\n         expect![[r#\"\n             56..60 'self': Self\n             62..66 'args': Args\n@@ -1729,37 +1710,36 @@ fn fn_trait() {\n fn fn_ptr_and_item() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang=\"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n+#[lang=\"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n \n-            fn call_once(self, args: Args) -> Self::Output;\n-        }\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n \n-        trait Foo<T> {\n-            fn foo(&self) -> T;\n-        }\n+trait Foo<T> {\n+    fn foo(&self) -> T;\n+}\n \n-        struct Bar<T>(T);\n+struct Bar<T>(T);\n \n-        impl<A1, R, F: FnOnce(A1) -> R> Foo<(A1, R)> for Bar<F> {\n-            fn foo(&self) -> (A1, R) { loop {} }\n-        }\n+impl<A1, R, F: FnOnce(A1) -> R> Foo<(A1, R)> for Bar<F> {\n+    fn foo(&self) -> (A1, R) { loop {} }\n+}\n \n-        enum Opt<T> { None, Some(T) }\n-        impl<T> Opt<T> {\n-            fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Opt<U> { loop {} }\n-        }\n+enum Opt<T> { None, Some(T) }\n+impl<T> Opt<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Opt<U> { loop {} }\n+}\n \n-        fn test() {\n-            let bar: Bar<fn(u8) -> u32>;\n-            bar.foo();\n+fn test() {\n+    let bar: Bar<fn(u8) -> u32>;\n+    bar.foo();\n \n-            let opt: Opt<u8>;\n-            let f: fn(u8) -> u32;\n-            opt.map(f);\n-        }\n-        \"#,\n+    let opt: Opt<u8>;\n+    let f: fn(u8) -> u32;\n+    opt.map(f);\n+}\"#,\n         expect![[r#\"\n             74..78 'self': Self\n             80..84 'args': Args\n@@ -1790,46 +1770,45 @@ fn fn_ptr_and_item() {\n fn fn_trait_deref_with_ty_default() {\n     check_infer(\n         r#\"\n-        #[lang = \"deref\"]\n-        trait Deref {\n-            type Target;\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n \n-            fn deref(&self) -> &Self::Target;\n-        }\n+    fn deref(&self) -> &Self::Target;\n+}\n \n-        #[lang=\"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n+#[lang=\"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n \n-            fn call_once(self, args: Args) -> Self::Output;\n-        }\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n \n-        struct Foo;\n+struct Foo;\n \n-        impl Foo {\n-            fn foo(&self) -> usize {}\n-        }\n+impl Foo {\n+    fn foo(&self) -> usize {}\n+}\n \n-        struct Lazy<T, F = fn() -> T>(F);\n+struct Lazy<T, F = fn() -> T>(F);\n \n-        impl<T, F> Lazy<T, F> {\n-            pub fn new(f: F) -> Lazy<T, F> {}\n-        }\n+impl<T, F> Lazy<T, F> {\n+    pub fn new(f: F) -> Lazy<T, F> {}\n+}\n \n-        impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n-            type Target = T;\n-        }\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+}\n \n-        fn test() {\n-            let lazy1: Lazy<Foo, _> = Lazy::new(|| Foo);\n-            let r1 = lazy1.foo();\n+fn test() {\n+    let lazy1: Lazy<Foo, _> = Lazy::new(|| Foo);\n+    let r1 = lazy1.foo();\n \n-            fn make_foo_fn() -> Foo {}\n-            let make_foo_fn_ptr: fn() -> Foo = make_foo_fn;\n-            let lazy2: Lazy<Foo, _> = Lazy::new(make_foo_fn_ptr);\n-            let r2 = lazy2.foo();\n-        }\n-        \"#,\n+    fn make_foo_fn() -> Foo {}\n+    let make_foo_fn_ptr: fn() -> Foo = make_foo_fn;\n+    let lazy2: Lazy<Foo, _> = Lazy::new(make_foo_fn_ptr);\n+    let r2 = lazy2.foo();\n+}\"#,\n         expect![[r#\"\n             64..68 'self': &Self\n             165..169 'self': Self\n@@ -1865,23 +1844,22 @@ fn fn_trait_deref_with_ty_default() {\n fn closure_1() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n-        }\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n \n-        enum Option<T> { Some(T), None }\n-        impl<T> Option<T> {\n-            fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> { loop {} }\n-        }\n+enum Option<T> { Some(T), None }\n+impl<T> Option<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> { loop {} }\n+}\n \n-        fn test() {\n-            let x = Option::Some(1u32);\n-            x.map(|v| v + 1);\n-            x.map(|_v| 1u64);\n-            let y: Option<i64> = x.map(|_v| 1);\n-        }\n-        \"#,\n+fn test() {\n+    let x = Option::Some(1u32);\n+    x.map(|v| v + 1);\n+    x.map(|_v| 1u64);\n+    let y: Option<i64> = x.map(|_v| 1);\n+}\"#,\n         expect![[r#\"\n             147..151 'self': Option<T>\n             153..154 'f': F\n@@ -1919,33 +1897,32 @@ fn closure_1() {\n fn closure_2() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"add\"]\n-        pub trait Add<Rhs = Self> {\n-            type Output;\n-            fn add(self, rhs: Rhs) -> Self::Output;\n-        }\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+}\n \n-        trait FnOnce<Args> {\n-            type Output;\n-        }\n+trait FnOnce<Args> {\n+    type Output;\n+}\n \n-        impl Add for u64 {\n-            type Output = Self;\n-            fn add(self, rhs: u64) -> Self::Output {0}\n-        }\n+impl Add for u64 {\n+    type Output = Self;\n+    fn add(self, rhs: u64) -> Self::Output {0}\n+}\n \n-        impl Add for u128 {\n-            type Output = Self;\n-            fn add(self, rhs: u128) -> Self::Output {0}\n-        }\n+impl Add for u128 {\n+    type Output = Self;\n+    fn add(self, rhs: u128) -> Self::Output {0}\n+}\n \n-        fn test<F: FnOnce(u32) -> u64>(f: F) {\n-            f(1);\n-            let g = |v| v + 1;\n-            g(1u64);\n-            let h = |v| 1u128 + v;\n-        }\n-        \"#,\n+fn test<F: FnOnce(u32) -> u64>(f: F) {\n+    f(1);\n+    let g = |v| v + 1;\n+    g(1u64);\n+    let h = |v| 1u128 + v;\n+}\"#,\n         expect![[r#\"\n             72..76 'self': Self\n             78..81 'rhs': Rhs\n@@ -1985,29 +1962,28 @@ fn closure_2() {\n fn closure_as_argument_inference_order() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n-        }\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n \n-        fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U { loop {} }\n-        fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U { loop {} }\n+fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U { loop {} }\n+fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U { loop {} }\n \n-        struct S;\n-        impl S {\n-            fn method(self) -> u64;\n+struct S;\n+impl S {\n+    fn method(self) -> u64;\n \n-            fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U { loop {} }\n-            fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U { loop {} }\n-        }\n+    fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U { loop {} }\n+    fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U { loop {} }\n+}\n \n-        fn test() {\n-            let x1 = foo1(S, |s| s.method());\n-            let x2 = foo2(|s| s.method(), S);\n-            let x3 = S.foo1(S, |s| s.method());\n-            let x4 = S.foo2(|s| s.method(), S);\n-        }\n-        \"#,\n+fn test() {\n+    let x1 = foo1(S, |s| s.method());\n+    let x2 = foo2(|s| s.method(), S);\n+    let x3 = S.foo1(S, |s| s.method());\n+    let x4 = S.foo2(|s| s.method(), S);\n+}\"#,\n         expect![[r#\"\n             94..95 'x': T\n             100..101 'f': F\n@@ -2136,27 +2112,26 @@ fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n fn unselected_projection_on_impl_self() {\n     check_infer(\n         r#\"\n-        //- /main.rs\n-        trait Trait {\n-            type Item;\n+//- /main.rs\n+trait Trait {\n+    type Item;\n \n-            fn f(&self, x: Self::Item);\n-        }\n+    fn f(&self, x: Self::Item);\n+}\n \n-        struct S;\n+struct S;\n \n-        impl Trait for S {\n-            type Item = u32;\n-            fn f(&self, x: Self::Item) { let y = x; }\n-        }\n+impl Trait for S {\n+    type Item = u32;\n+    fn f(&self, x: Self::Item) { let y = x; }\n+}\n \n-        struct S2;\n+struct S2;\n \n-        impl Trait for S2 {\n-            type Item = i32;\n-            fn f(&self, x: <Self>::Item) { let y = x; }\n-        }\n-        \"#,\n+impl Trait for S2 {\n+    type Item = i32;\n+    fn f(&self, x: <Self>::Item) { let y = x; }\n+}\"#,\n         expect![[r#\"\n             40..44 'self': &Self\n             46..47 'x': Trait::Item<Self>\n@@ -2392,58 +2367,57 @@ fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n fn proc_macro_server_types() {\n     check_infer(\n         r#\"\n-        macro_rules! with_api {\n-            ($S:ident, $self:ident, $m:ident) => {\n-                $m! {\n-                    TokenStream {\n-                        fn new() -> $S::TokenStream;\n-                    },\n-                    Group {\n-                    },\n-                }\n-            };\n-        }\n-        macro_rules! associated_item {\n-            (type TokenStream) =>\n-                (type TokenStream: 'static;);\n-            (type Group) =>\n-                (type Group: 'static;);\n-            ($($item:tt)*) => ($($item)*;)\n+macro_rules! with_api {\n+    ($S:ident, $self:ident, $m:ident) => {\n+        $m! {\n+            TokenStream {\n+                fn new() -> $S::TokenStream;\n+            },\n+            Group {\n+            },\n         }\n-        macro_rules! declare_server_traits {\n-            ($($name:ident {\n-                $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-            }),* $(,)?) => {\n-                pub trait Types {\n-                    $(associated_item!(type $name);)*\n-                }\n-\n-                $(pub trait $name: Types {\n-                    $(associated_item!(fn $method($($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n-                })*\n-\n-                pub trait Server: Types $(+ $name)* {}\n-                impl<S: Types $(+ $name)*> Server for S {}\n-            }\n+    };\n+}\n+macro_rules! associated_item {\n+    (type TokenStream) =>\n+        (type TokenStream: 'static;);\n+    (type Group) =>\n+        (type Group: 'static;);\n+    ($($item:tt)*) => ($($item)*;)\n+}\n+macro_rules! declare_server_traits {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        pub trait Types {\n+            $(associated_item!(type $name);)*\n         }\n \n-        with_api!(Self, self_, declare_server_traits);\n-        struct G {}\n-        struct T {}\n-        struct Rustc;\n-        impl Types for Rustc {\n-            type TokenStream = T;\n-            type Group = G;\n-        }\n+        $(pub trait $name: Types {\n+            $(associated_item!(fn $method($($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+        })*\n \n-        fn make<T>() -> T { loop {} }\n-        impl TokenStream for Rustc {\n-            fn new() -> Self::TokenStream {\n-                let group: Self::Group = make();\n-                make()\n-            }\n-        }\n-        \"#,\n+        pub trait Server: Types $(+ $name)* {}\n+        impl<S: Types $(+ $name)*> Server for S {}\n+    }\n+}\n+\n+with_api!(Self, self_, declare_server_traits);\n+struct G {}\n+struct T {}\n+struct Rustc;\n+impl Types for Rustc {\n+    type TokenStream = T;\n+    type Group = G;\n+}\n+\n+fn make<T>() -> T { loop {} }\n+impl TokenStream for Rustc {\n+    fn new() -> Self::TokenStream {\n+        let group: Self::Group = make();\n+        make()\n+    }\n+}\"#,\n         expect![[r#\"\n             1061..1072 '{ loop {} }': T\n             1063..1070 'loop {}': !\n@@ -2462,23 +2436,22 @@ fn proc_macro_server_types() {\n fn unify_impl_trait() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait Trait<T> {}\n+trait Trait<T> {}\n \n-        fn foo(x: impl Trait<u32>) { loop {} }\n-        fn bar<T>(x: impl Trait<T>) -> T { loop {} }\n+fn foo(x: impl Trait<u32>) { loop {} }\n+fn bar<T>(x: impl Trait<T>) -> T { loop {} }\n \n-        struct S<T>(T);\n-        impl<T> Trait<T> for S<T> {}\n+struct S<T>(T);\n+impl<T> Trait<T> for S<T> {}\n \n-        fn default<T>() -> T { loop {} }\n+fn default<T>() -> T { loop {} }\n \n-        fn test() -> impl Trait<i32> {\n-            let s1 = S(default());\n-            foo(s1);\n-            let x: i32 = bar(S(default()));\n-            S(default())\n-        }\n-        \"#,\n+fn test() -> impl Trait<i32> {\n+    let s1 = S(default());\n+    foo(s1);\n+    let x: i32 = bar(S(default()));\n+    S(default())\n+}\"#,\n         expect![[r#\"\n             26..27 'x': impl Trait<u32>\n             46..57 '{ loop {} }': ()\n@@ -2519,30 +2492,29 @@ fn unify_impl_trait() {\n fn assoc_types_from_bounds() {\n     check_infer(\n         r#\"\n-        //- /main.rs\n-        #[lang = \"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n-        }\n+//- /main.rs\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n \n-        trait T {\n-            type O;\n-        }\n+trait T {\n+    type O;\n+}\n \n-        impl T for () {\n-            type O = ();\n-        }\n+impl T for () {\n+    type O = ();\n+}\n \n-        fn f<X, F>(_v: F)\n-        where\n-            X: T,\n-            F: FnOnce(&X::O),\n-        { }\n+fn f<X, F>(_v: F)\n+where\n+    X: T,\n+    F: FnOnce(&X::O),\n+{ }\n \n-        fn main() {\n-            f::<(), _>(|z| { z; });\n-        }\n-        \"#,\n+fn main() {\n+    f::<(), _>(|z| { z; });\n+}\"#,\n         expect![[r#\"\n             133..135 '_v': F\n             178..181 '{ }': ()\n@@ -2628,76 +2600,75 @@ fn test() {\n fn iterator_chain() {\n     check_infer_with_mismatches(\n         r#\"\n-        //- /main.rs\n-        #[lang = \"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n-        }\n-        #[lang = \"fn_mut\"]\n-        trait FnMut<Args>: FnOnce<Args> { }\n+//- /main.rs\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+#[lang = \"fn_mut\"]\n+trait FnMut<Args>: FnOnce<Args> { }\n \n-        enum Option<T> { Some(T), None }\n-        use Option::*;\n+enum Option<T> { Some(T), None }\n+use Option::*;\n \n-        pub trait Iterator {\n-            type Item;\n+pub trait Iterator {\n+    type Item;\n \n-            fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>\n-            where\n-                F: FnMut(Self::Item) -> Option<B>,\n-            { loop {} }\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>\n+    where\n+        F: FnMut(Self::Item) -> Option<B>,\n+    { loop {} }\n \n-            fn for_each<F>(self, f: F)\n-            where\n-                F: FnMut(Self::Item),\n-            { loop {} }\n-        }\n+    fn for_each<F>(self, f: F)\n+    where\n+        F: FnMut(Self::Item),\n+    { loop {} }\n+}\n \n-        pub trait IntoIterator {\n-            type Item;\n-            type IntoIter: Iterator<Item = Self::Item>;\n-            fn into_iter(self) -> Self::IntoIter;\n-        }\n+pub trait IntoIterator {\n+    type Item;\n+    type IntoIter: Iterator<Item = Self::Item>;\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n \n-        pub struct FilterMap<I, F> { }\n-        impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-        where\n-            F: FnMut(I::Item) -> Option<B>,\n-        {\n-            type Item = B;\n-        }\n+pub struct FilterMap<I, F> { }\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+}\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<I: Iterator> IntoIterator for I {\n-            type Item = I::Item;\n-            type IntoIter = I;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n \n-            fn into_iter(self) -> I {\n-                self\n-            }\n-        }\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n \n-        struct Vec<T> {}\n-        impl<T> Vec<T> {\n-            fn new() -> Self { loop {} }\n-        }\n+struct Vec<T> {}\n+impl<T> Vec<T> {\n+    fn new() -> Self { loop {} }\n+}\n \n-        impl<T> IntoIterator for Vec<T> {\n-            type Item = T;\n-            type IntoIter = IntoIter<T>;\n-        }\n+impl<T> IntoIterator for Vec<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n \n-        pub struct IntoIter<T> { }\n-        impl<T> Iterator for IntoIter<T> {\n-            type Item = T;\n-        }\n+pub struct IntoIter<T> { }\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+}\n \n-        fn main() {\n-            Vec::<i32>::new().into_iter()\n-            .filter_map(|x| if x > 0 { Some(x as u32) } else { None })\n-            .for_each(|y| { y; });\n-        }\n-        \"#,\n+fn main() {\n+    Vec::<i32>::new().into_iter()\n+    .filter_map(|x| if x > 0 { Some(x as u32) } else { None })\n+    .for_each(|y| { y; });\n+}\"#,\n         expect![[r#\"\n             226..230 'self': Self\n             232..233 'f': F\n@@ -2779,14 +2750,13 @@ fn main() {\n fn trait_object_no_coercion() {\n     check_infer_with_mismatches(\n         r#\"\n-        trait Foo {}\n+trait Foo {}\n \n-        fn foo(x: &dyn Foo) {}\n+fn foo(x: &dyn Foo) {}\n \n-        fn test(x: &dyn Foo) {\n-            foo(x);\n-        }\n-        \"#,\n+fn test(x: &dyn Foo) {\n+    foo(x);\n+}\"#,\n         expect![[r#\"\n             21..22 'x': &dyn Foo\n             34..36 '{}': ()\n@@ -2803,23 +2773,22 @@ fn trait_object_no_coercion() {\n fn builtin_copy() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"copy\"]\n-        trait Copy {}\n+#[lang = \"copy\"]\n+trait Copy {}\n \n-        struct IsCopy;\n-        impl Copy for IsCopy {}\n-        struct NotCopy;\n+struct IsCopy;\n+impl Copy for IsCopy {}\n+struct NotCopy;\n \n-        trait Test { fn test(&self) -> bool; }\n-        impl<T: Copy> Test for T {}\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Copy> Test for T {}\n \n-        fn test() {\n-            IsCopy.test();\n-            NotCopy.test();\n-            (IsCopy, IsCopy).test();\n-            (IsCopy, NotCopy).test();\n-        }\n-        \"#,\n+fn test() {\n+    IsCopy.test();\n+    NotCopy.test();\n+    (IsCopy, IsCopy).test();\n+    (IsCopy, NotCopy).test();\n+}\"#,\n         expect![[r#\"\n             110..114 'self': &Self\n             166..267 '{     ...t(); }': ()\n@@ -2843,24 +2812,23 @@ fn builtin_copy() {\n fn builtin_fn_def_copy() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"copy\"]\n-        trait Copy {}\n+#[lang = \"copy\"]\n+trait Copy {}\n \n-        fn foo() {}\n-        fn bar<T: Copy>(T) -> T {}\n-        struct Struct(usize);\n-        enum Enum { Variant(usize) }\n+fn foo() {}\n+fn bar<T: Copy>(T) -> T {}\n+struct Struct(usize);\n+enum Enum { Variant(usize) }\n \n-        trait Test { fn test(&self) -> bool; }\n-        impl<T: Copy> Test for T {}\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Copy> Test for T {}\n \n-        fn test() {\n-            foo.test();\n-            bar.test();\n-            Struct.test();\n-            Enum::Variant.test();\n-        }\n-        \"#,\n+fn test() {\n+    foo.test();\n+    bar.test();\n+    Struct.test();\n+    Enum::Variant.test();\n+}\"#,\n         expect![[r#\"\n             41..43 '{}': ()\n             60..61 'T': {unknown}\n@@ -2884,18 +2852,17 @@ fn builtin_fn_def_copy() {\n fn builtin_fn_ptr_copy() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"copy\"]\n-        trait Copy {}\n+#[lang = \"copy\"]\n+trait Copy {}\n \n-        trait Test { fn test(&self) -> bool; }\n-        impl<T: Copy> Test for T {}\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Copy> Test for T {}\n \n-        fn test(f1: fn(), f2: fn(usize) -> u8, f3: fn(u8, u8) -> &u8) {\n-            f1.test();\n-            f2.test();\n-            f3.test();\n-        }\n-        \"#,\n+fn test(f1: fn(), f2: fn(usize) -> u8, f3: fn(u8, u8) -> &u8) {\n+    f1.test();\n+    f2.test();\n+    f3.test();\n+}\"#,\n         expect![[r#\"\n             54..58 'self': &Self\n             108..110 'f1': fn()\n@@ -2916,19 +2883,18 @@ fn builtin_fn_ptr_copy() {\n fn builtin_sized() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        trait Sized {}\n+#[lang = \"sized\"]\n+trait Sized {}\n \n-        trait Test { fn test(&self) -> bool; }\n-        impl<T: Sized> Test for T {}\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Sized> Test for T {}\n \n-        fn test() {\n-            1u8.test();\n-            (*\"foo\").test(); // not Sized\n-            (1u8, 1u8).test();\n-            (1u8, *\"foo\").test(); // not Sized\n-        }\n-        \"#,\n+fn test() {\n+    1u8.test();\n+    (*\"foo\").test(); // not Sized\n+    (1u8, 1u8).test();\n+    (1u8, *\"foo\").test(); // not Sized\n+}\"#,\n         expect![[r#\"\n             56..60 'self': &Self\n             113..228 '{     ...ized }': ()\n@@ -2998,19 +2964,18 @@ impl<A: Step> iter::Iterator for ops::Range<A> {\n fn infer_closure_arg() {\n     check_infer(\n         r#\"\n-        //- /lib.rs\n+//- /lib.rs\n \n-        enum Option<T> {\n-            None,\n-            Some(T)\n-        }\n+enum Option<T> {\n+    None,\n+    Some(T)\n+}\n \n-        fn foo() {\n-            let s = Option::None;\n-            let f = |x: Option<i32>| {};\n-            (&f)(s)\n-        }\n-        \"#,\n+fn foo() {\n+    let s = Option::None;\n+    let f = |x: Option<i32>| {};\n+    (&f)(s)\n+}\"#,\n         expect![[r#\"\n             52..126 '{     ...)(s) }': ()\n             62..63 's': Option<i32>\n@@ -3079,46 +3044,45 @@ fn infer_box_fn_arg() {\n     // The type mismatch is a bug\n     check_infer_with_mismatches(\n         r#\"\n-        //- /lib.rs deps:std\n+//- /lib.rs deps:std\n \n-        #[lang = \"fn_once\"]\n-        pub trait FnOnce<Args> {\n-            type Output;\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    type Output;\n \n-            extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-        }\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n \n-        #[lang = \"deref\"]\n-        pub trait Deref {\n-            type Target: ?Sized;\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target: ?Sized;\n \n-            fn deref(&self) -> &Self::Target;\n-        }\n+    fn deref(&self) -> &Self::Target;\n+}\n \n-        #[lang = \"owned_box\"]\n-        pub struct Box<T: ?Sized> {\n-            inner: *mut T,\n-        }\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized> {\n+    inner: *mut T,\n+}\n \n-        impl<T: ?Sized> Deref for Box<T> {\n-            type Target = T;\n+impl<T: ?Sized> Deref for Box<T> {\n+    type Target = T;\n \n-            fn deref(&self) -> &T {\n-                &self.inner\n-            }\n-        }\n+    fn deref(&self) -> &T {\n+        &self.inner\n+    }\n+}\n \n-        enum Option<T> {\n-            None,\n-            Some(T)\n-        }\n+enum Option<T> {\n+    None,\n+    Some(T)\n+}\n \n-        fn foo() {\n-            let s = Option::None;\n-            let f: Box<dyn FnOnce(&Option<i32>)> = box (|ps| {});\n-            f(&s);\n-        }\n-        \"#,\n+fn foo() {\n+    let s = Option::None;\n+    let f: Box<dyn FnOnce(&Option<i32>)> = box (|ps| {});\n+    f(&s);\n+}\"#,\n         expect![[r#\"\n             100..104 'self': Self\n             106..110 'args': Args\n@@ -3284,8 +3248,7 @@ fn f() {\n         ().method();\n       //^^^^^^^^^^^ u8\n     }\n-}\n-        \"#,\n+}\"#,\n         expect![[r#\"\n             46..50 'self': &Self\n             58..63 '{ 0 }': u8\n@@ -3339,8 +3302,7 @@ fn f() {\n     fn inner() -> S {\n         let s = inner();\n     }\n-}\n-        \"#,\n+}\"#,\n         expect![[r#\"\n             17..73 '{     ...   } }': ()\n             39..71 '{     ...     }': ()\n@@ -3375,8 +3337,7 @@ fn test() {\n     let x = A;\n     let y = A;\n     let r = x.do_op(y);\n-}\n-        \"#,\n+}\"#,\n         expect![[r#\"\n             63..67 'self': Self\n             69..72 'rhs': RHS\n@@ -3425,9 +3386,7 @@ impl foo::Bar for F {\n fn foo() {\n     use foo::Bar;\n     let x = <F as Bar>::boo();\n-}\n-\n-        \"#,\n+}\"#,\n         expect![[r#\"\n             132..163 '{     ...     }': Bar::Output<Self>\n             146..153 'loop {}': !\n@@ -3465,8 +3424,7 @@ fn foo() {\n \n pub trait Deserialize {\n     fn deserialize() -> u8;\n-}\n-    \"#,\n+}\"#,\n     );\n }\n "}]}