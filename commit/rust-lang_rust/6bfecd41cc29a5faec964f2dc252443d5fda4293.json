{"sha": "6bfecd41cc29a5faec964f2dc252443d5fda4293", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZmVjZDQxY2MyOWE1ZmFlYzk2NGYyZGMyNTI0NDNkNWZkYTQyOTM=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2017-09-14T20:09:09Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2017-10-18T10:58:15Z"}, "message": "Avoid unnecessary allocas for indirect function arguments\n\nThe extra alloca was only necessary because it made LLVM implicitly\nhandle the necessary deref to get to the actual value. The same happens\nfor indirect arguments that have the byval attribute. But the Rust ABI\ndoes not use the byval attribute and so we need to manually add the\nderef operation to the debuginfo.", "tree": {"sha": "0547ff1100e10486af306da4982854cea26c9a71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0547ff1100e10486af306da4982854cea26c9a71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bfecd41cc29a5faec964f2dc252443d5fda4293", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfecd41cc29a5faec964f2dc252443d5fda4293", "html_url": "https://github.com/rust-lang/rust/commit/6bfecd41cc29a5faec964f2dc252443d5fda4293", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bfecd41cc29a5faec964f2dc252443d5fda4293/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d7514545cbe83e771a400d04049b96dfb210cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d7514545cbe83e771a400d04049b96dfb210cd", "html_url": "https://github.com/rust-lang/rust/commit/f6d7514545cbe83e771a400d04049b96dfb210cd"}], "stats": {"total": 33, "additions": 26, "deletions": 7}, "files": [{"sha": "6df40c34ec54ae7b820434e42a76ebf662c80d00", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bfecd41cc29a5faec964f2dc252443d5fda4293/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfecd41cc29a5faec964f2dc252443d5fda4293/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=6bfecd41cc29a5faec964f2dc252443d5fda4293", "patch": "@@ -113,6 +113,10 @@ impl ArgAttributes {\n         self\n     }\n \n+    pub fn contains(&self, attr: ArgAttribute) -> bool {\n+        self.regular.contains(attr)\n+    }\n+\n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         unsafe {\n             self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));"}, {"sha": "d5d44bfa7ba43038169add3e7f9c33ba4d4aafbc", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6bfecd41cc29a5faec964f2dc252443d5fda4293/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfecd41cc29a5faec964f2dc252443d5fda4293/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=6bfecd41cc29a5faec964f2dc252443d5fda4293", "patch": "@@ -23,7 +23,7 @@ use builder::Builder;\n use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n-use abi::FnType;\n+use abi::{ArgAttribute, FnType};\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n@@ -378,6 +378,10 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         None\n     };\n \n+    let deref_op = unsafe {\n+        [llvm::LLVMRustDIBuilderCreateOpDeref()]\n+    };\n+\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n         let arg_ty = mircx.monomorphize(&arg_decl.ty);\n@@ -432,10 +436,9 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n+        let llval = if arg.is_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n-            // already put it in a temporary alloca and gave it up, unless\n-            // we emit extra-debug-info, which requires local allocas :(.\n+            // already put it in a temporary alloca and gave it up\n             // FIXME: lifetimes\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n@@ -444,8 +447,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             llarg_idx += 1;\n             llarg\n         } else if !lvalue_locals.contains(local.index()) &&\n-                  !arg.is_indirect() && arg.cast.is_none() &&\n-                  arg_scope.is_none() {\n+                  arg.cast.is_none() && arg_scope.is_none() {\n             if arg.is_ignore() {\n                 return LocalRef::new_operand(bcx.ccx, arg_ty);\n             }\n@@ -510,13 +512,26 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n             if arg_index > 0 || mir.upvar_decls.is_empty() {\n+                // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n+                // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n+                // byval attribute, for which LLVM does the deref itself, so we must not add it.\n+                let variable_access = if arg.is_indirect() &&\n+                    !arg.attrs.contains(ArgAttribute::ByVal) {\n+                    VariableAccess::IndirectVariable {\n+                        alloca: llval,\n+                        address_operations: &deref_op,\n+                    }\n+                } else {\n+                    VariableAccess::DirectVariable { alloca: llval }\n+                };\n+\n                 declare_local(\n                     bcx,\n                     &mircx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg_ty,\n                     scope,\n-                    VariableAccess::DirectVariable { alloca: llval },\n+                    variable_access,\n                     VariableKind::ArgumentVariable(arg_index + 1),\n                     DUMMY_SP\n                 );"}]}