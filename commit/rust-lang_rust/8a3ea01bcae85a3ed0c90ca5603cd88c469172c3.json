{"sha": "8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhM2VhMDFiY2FlODVhM2VkMGM5MGNhNTYwM2NkODhjNDY5MTcyYzM=", "commit": {"author": {"name": "matthewjasper", "email": "mjjasper1@gmail.com", "date": "2017-04-22T16:55:59Z"}, "committer": {"name": "matthewjasper", "email": "mjjasper1@gmail.com", "date": "2017-04-22T16:55:59Z"}, "message": "Resolve merge conflict", "tree": {"sha": "291c7e740787ea95d87ac7a39f89a99d00b41c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/291c7e740787ea95d87ac7a39f89a99d00b41c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "html_url": "https://github.com/rust-lang/rust/commit/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fc25224da78afcfdd76783c38ad3beff42a990c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc25224da78afcfdd76783c38ad3beff42a990c", "html_url": "https://github.com/rust-lang/rust/commit/5fc25224da78afcfdd76783c38ad3beff42a990c"}, {"sha": "6d841da4a0d7629f826117f99052e3d4a7997a7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d841da4a0d7629f826117f99052e3d4a7997a7e", "html_url": "https://github.com/rust-lang/rust/commit/6d841da4a0d7629f826117f99052e3d4a7997a7e"}], "stats": {"total": 2402, "additions": 1690, "deletions": 712}, "files": [{"sha": "c5ecc2236894cf0c5cb6cf2c4214249b2a648a2b", "filename": "configure", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/configure", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -479,6 +479,7 @@ valopt i686-linux-android-ndk \"\" \"i686-linux-android NDK standalone path\"\n valopt arm-linux-androideabi-ndk \"\" \"arm-linux-androideabi NDK standalone path\"\n valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone path\"\n valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n+valopt x86_64-linux-android-ndk \"\" \"x86_64-linux-android NDK standalone path\"\n valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n valopt musl-root \"/usr/local\" \"MUSL root installation directory (deprecated)\"\n valopt musl-root-x86_64 \"\" \"x86_64-unknown-linux-musl install directory\"\n@@ -746,6 +747,7 @@ putvar CFG_AARCH64_LINUX_ANDROID_NDK\n putvar CFG_ARM_LINUX_ANDROIDEABI_NDK\n putvar CFG_ARMV7_LINUX_ANDROIDEABI_NDK\n putvar CFG_I686_LINUX_ANDROID_NDK\n+putvar CFG_X86_64_LINUX_ANDROID_NDK\n putvar CFG_NACL_CROSS_PATH\n putvar CFG_MANDIR\n putvar CFG_DOCDIR"}, {"sha": "6ecff95fdc3ee7ceed2b9b0cc1a3a64876860bce", "filename": "rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rls?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1 +1 @@\n-Subproject commit 016cbc514cf44a2bd3fe806e8afa6b9c50287373\n+Subproject commit 6ecff95fdc3ee7ceed2b9b0cc1a3a64876860bce"}, {"sha": "cd87b27d4f1aa65650ce896b85ecf0411d4f0c08", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -151,6 +151,7 @@ pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &st\n         if !up_to_date(src_file, dst_file) {\n             let mut cmd = Command::new(&compiler_path);\n             build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                        .arg(\"--cfg\").arg(format!(\"stage{}\", compiler.stage))\n                         .arg(\"--target\").arg(target)\n                         .arg(\"--emit=obj\")\n                         .arg(\"--out-dir\").arg(dst_dir)"}, {"sha": "34fbc33d981afddfdc8af7662b85e2ed82a885d4", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -570,6 +570,12 @@ impl Config {\n                                      .or_insert(Target::default());\n                     target.ndk = Some(parse_configure_path(value));\n                 }\n+                \"CFG_X86_64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n+                    let target = \"x86_64-linux-android\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.ndk = Some(parse_configure_path(value));\n+                }\n                 \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n                     let path = parse_configure_path(value);\n                     self.rustc = Some(push_exe_path(path.clone(), &[\"bin\", \"rustc\"]));"}, {"sha": "28cc885ed30dabae3cc7fb5e14be7179a1713425", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -36,16 +36,18 @@ RUN curl -o /usr/local/bin/sccache \\\n       chmod +x /usr/local/bin/sccache\n \n ENV TARGETS=arm-linux-androideabi\n+ENV TARGETS=$TARGETS,armv7-linux-androideabi\n ENV TARGETS=$TARGETS,i686-linux-android\n ENV TARGETS=$TARGETS,aarch64-linux-android\n-ENV TARGETS=$TARGETS,armv7-linux-androideabi\n+ENV TARGETS=$TARGETS,x86_64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n       --target=$TARGETS \\\n       --enable-extended \\\n       --arm-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --armv7-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --i686-linux-android-ndk=/android/ndk-x86-9 \\\n-      --aarch64-linux-android-ndk=/android/ndk-aarch64\n+      --aarch64-linux-android-ndk=/android/ndk-arm64-21 \\\n+      --x86_64-linux-android-ndk=/android/ndk-x86_64-21\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "d3a2d31754543c0b95c64861062e4367976bb2ac", "filename": "src/ci/docker/dist-android/install-ndk.sh", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fci%2Fdocker%2Fdist-android%2Finstall-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fci%2Fdocker%2Fdist-android%2Finstall-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2Finstall-ndk.sh?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -25,7 +25,7 @@ bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n         --platform=android-21 \\\n         --toolchain=aarch64-linux-android-4.9 \\\n-        --install-dir=/android/ndk-aarch64 \\\n+        --install-dir=/android/ndk-arm64-21 \\\n         --ndk-dir=/android/android-ndk-r11c \\\n         --arch=arm64\n bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n@@ -34,5 +34,11 @@ bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n         --install-dir=/android/ndk-x86-9 \\\n         --ndk-dir=/android/android-ndk-r11c \\\n         --arch=x86\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-21 \\\n+        --toolchain=x86_64-4.9 \\\n+        --install-dir=/android/ndk-x86_64-21 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=x86_64\n \n rm -rf ./android-ndk-r11c-linux-x86_64.zip ./android-ndk-r11c"}, {"sha": "1cfb46530237c1361a4893f832fd732d37b3c8d6", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -71,6 +71,7 @@\n     - [prelude_import](language-features/prelude-import.md)\n     - [proc_macro](language-features/proc-macro.md)\n     - [quote](language-features/quote.md)\n+    - [repr_align](language-features/repr-align.md)\n     - [repr_simd](language-features/repr-simd.md)\n     - [rustc_attrs](language-features/rustc-attrs.md)\n     - [rustc_diagnostic_macros](language-features/rustc-diagnostic-macros.md)\n@@ -224,4 +225,3 @@\n     - [windows_net](library-features/windows-net.md)\n     - [windows_stdio](library-features/windows-stdio.md)\n     - [zero_one](library-features/zero-one.md)\n->>>>>> Add top level sections to the Unstable Book."}, {"sha": "deea04f4c51cc7525328b0844034bebe1e603430", "filename": "src/doc/unstable-book/src/language-features/repr-align.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,11 @@\n+# `repr_align`\n+\n+The tracking issue for this feature is: [#33626]\n+\n+[#33626]: https://github.com/rust-lang/rust/issues/33626\n+\n+------------------------\n+\n+\n+\n+"}, {"sha": "52601cd96f80db4d0ee5c64bddcef0e39a517a80", "filename": "src/etc/rust-gdb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -17,7 +17,10 @@ RUSTC_SYSROOT=`rustc --print=sysroot`\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n \n # Run GDB with the additional arguments that load the pretty printers\n-PYTHONPATH=\"$PYTHONPATH:$GDB_PYTHON_MODULE_DIRECTORY\" gdb \\\n+# Set the environment variable `RUST_GDB` to overwrite the call to a\n+# different/specific command (defaults to `gdb`).\n+RUST_GDB=\"${RUST_GDB:-gdb}\"\n+PYTHONPATH=\"$PYTHONPATH:$GDB_PYTHON_MODULE_DIRECTORY\" ${RUST_GDB} \\\n   -d \"$GDB_PYTHON_MODULE_DIRECTORY\" \\\n   -iex \"add-auto-load-safe-path $GDB_PYTHON_MODULE_DIRECTORY\" \\\n   \"$@\""}, {"sha": "e05533aa50e3cf0d7ee3bd955a213d8642bd0eb4", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -138,7 +138,8 @@ pub struct Difference<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Difference<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Difference\")\n-         .field(&self.clone())\n+         .field(&self.a)\n+         .field(&self.b)\n          .finish()\n     }\n }\n@@ -160,7 +161,8 @@ pub struct SymmetricDifference<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for SymmetricDifference<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"SymmetricDifference\")\n-         .field(&self.clone())\n+         .field(&self.a)\n+         .field(&self.b)\n          .finish()\n     }\n }\n@@ -182,7 +184,8 @@ pub struct Intersection<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Intersection<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Intersection\")\n-         .field(&self.clone())\n+         .field(&self.a)\n+         .field(&self.b)\n          .finish()\n     }\n }\n@@ -204,7 +207,8 @@ pub struct Union<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Union<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Union\")\n-         .field(&self.clone())\n+         .field(&self.a)\n+         .field(&self.b)\n          .finish()\n     }\n }"}, {"sha": "aaee567bf1dbfe475b13951d6e28fdddb7c75eab", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -225,7 +225,8 @@ pub struct Iter<E> {\n impl<E: fmt::Debug> fmt::Debug for Iter<E> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Iter\")\n-         .field(&self.clone())\n+         .field(&self.index)\n+         .field(&self.bits)\n          .finish()\n     }\n }"}, {"sha": "1cc5e10418f2572c5e042194a85298e41a93ebae", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -75,7 +75,7 @@ pub struct Iter<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Iter\")\n-         .field(&self.clone())\n+         .field(&self.len)\n          .finish()\n     }\n }\n@@ -107,7 +107,8 @@ pub struct IterMut<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IterMut\")\n-         .field(self.clone())\n+         .field(&self.list)\n+         .field(&self.len)\n          .finish()\n     }\n }\n@@ -129,7 +130,7 @@ pub struct IntoIter<T> {\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n-         .field(self.clone())\n+         .field(&self.list)\n          .finish()\n     }\n }\n@@ -1128,7 +1129,7 @@ pub struct FrontPlace<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for FrontPlace<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"FrontPlace\")\n-         .field(self.clone())\n+         .field(&self.list)\n          .finish()\n     }\n }\n@@ -1183,7 +1184,7 @@ pub struct BackPlace<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for BackPlace<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"BackPlace\")\n-         .field(self.clone())\n+         .field(&self.list)\n          .finish()\n     }\n }"}, {"sha": "64c76142b59d660ca8d975a23da5aa7040c8f2aa", "filename": "src/libcollections/tests/vec.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fvec.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -84,6 +84,9 @@ fn test_extend() {\n     let mut v = Vec::new();\n     let mut w = Vec::new();\n \n+    v.extend(w.clone());\n+    assert_eq!(v, &[]);\n+\n     v.extend(0..3);\n     for i in 0..3 {\n         w.push(i)\n@@ -100,6 +103,25 @@ fn test_extend() {\n \n     v.extend(w.clone()); // specializes to `append`\n     assert!(v.iter().eq(w.iter().chain(w.iter())));\n+\n+    // Zero sized types\n+    #[derive(PartialEq, Debug)]\n+    struct Foo;\n+\n+    let mut a = Vec::new();\n+    let b = vec![Foo, Foo];\n+\n+    a.extend(b);\n+    assert_eq!(a, &[Foo, Foo]);\n+\n+    // Double drop\n+    let mut count_x = 0;\n+    {\n+        let mut x = Vec::new();\n+        let y = vec![DropCounter { count: &mut count_x }];\n+        x.extend(y);\n+    }\n+    assert_eq!(count_x, 1);\n }\n \n #[test]"}, {"sha": "6deb87ae772049b0c793df969cbd9d69107980b0", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1041,18 +1041,22 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        self.reserve(other.len());\n-        let len = self.len();\n-        unsafe {\n-            ptr::copy_nonoverlapping(other.as_ptr(), self.get_unchecked_mut(len), other.len());\n-        }\n-\n-        self.len += other.len();\n         unsafe {\n+            self.append_elements(other.as_slice() as _);\n             other.set_len(0);\n         }\n     }\n \n+    /// Appends elements to `Self` from other buffer.\n+    #[inline]\n+    unsafe fn append_elements(&mut self, other: *const [T]) {\n+        let count = (*other).len();\n+        self.reserve(count);\n+        let len = self.len();\n+        ptr::copy_nonoverlapping(other as *const T, self.get_unchecked_mut(len), count);\n+        self.len += count;\n+    }\n+\n     /// Create a draining iterator that removes the specified range in the vector\n     /// and yields the removed items.\n     ///\n@@ -1738,7 +1742,7 @@ impl<T, I> SpecExtend<T, I> for Vec<T>\n         vector\n     }\n \n-    fn spec_extend(&mut self, iterator: I) {\n+    default fn spec_extend(&mut self, iterator: I) {\n         // This is the case for a TrustedLen iterator.\n         let (low, high) = iterator.size_hint();\n         if let Some(high_value) = high {\n@@ -1783,6 +1787,13 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n             vector\n         }\n     }\n+\n+    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n+        unsafe {\n+            self.append_elements(iterator.as_slice() as _);\n+        }\n+        iterator.ptr = iterator.end;\n+    }\n }\n \n impl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>"}, {"sha": "a9e795f9378a681e0eee5e6644d6379acee2eb8f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1913,7 +1913,9 @@ pub struct Iter<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Iter\")\n-         .field(&self.clone())\n+         .field(&self.ring)\n+         .field(&self.tail)\n+         .field(&self.head)\n          .finish()\n     }\n }\n@@ -2000,7 +2002,9 @@ pub struct IterMut<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IterMut\")\n-         .field(&self.clone())\n+         .field(&self.ring)\n+         .field(&self.tail)\n+         .field(&self.head)\n          .finish()\n     }\n }\n@@ -2081,7 +2085,7 @@ pub struct IntoIter<T> {\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n-         .field(&self.clone())\n+         .field(&self.inner)\n          .finish()\n     }\n }\n@@ -2139,7 +2143,9 @@ pub struct Drain<'a, T: 'a> {\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n-         .field(&self.clone())\n+         .field(&self.after_tail)\n+         .field(&self.after_head)\n+         .field(&self.iter)\n          .finish()\n     }\n }"}, {"sha": "084736685e3a7f49bf23e4db4e3f7c97eec02fc9", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 133, "deletions": 50, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -17,25 +17,25 @@\n //! Like many traits, these are often used as bounds for generic functions, to\n //! support arguments of multiple types.\n //!\n-//! - Impl the `As*` traits for reference-to-reference conversions\n-//! - Impl the [`Into`] trait when you want to consume the value in the conversion\n+//! - Implement the `As*` traits for reference-to-reference conversions\n+//! - Implement the [`Into`] trait when you want to consume the value in the conversion\n //! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n //! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n //!   conversion to fail\n //!\n //! As a library author, you should prefer implementing [`From<T>`][`From`] or\n //! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n //! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n-//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a blanket implementation\n-//! in the standard library.\n+//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n+//! blanket implementation in the standard library.\n //!\n-//! # Generic impl\n+//! # Generic Implementations\n //!\n //! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n //! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n //! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n-//! - [`From`] and [`Into`] are reflexive, which means that all types can `into()`\n-//!   themselves and `from()` themselves\n+//! - [`From`] and [`Into`] are reflexive, which means that all types can\n+//!   `into` themselves and `from` themselves\n //!\n //! See each trait for usage examples.\n //!\n@@ -50,20 +50,42 @@\n \n use str::FromStr;\n \n-/// A cheap, reference-to-reference conversion.\n+/// A cheap reference-to-reference conversion. Used to convert a value to a\n+/// reference value within generic code.\n ///\n-/// `AsRef` is very similar to, but different than, [`Borrow`]. See\n-/// [the book][book] for more.\n+/// `AsRef` is very similar to, but serves a slightly different purpose than,\n+/// [`Borrow`].\n+///\n+/// `AsRef` is to be used when wishing to convert to a reference of another\n+/// type.\n+/// `Borrow` is more related to the notion of taking the reference. It is\n+/// useful when wishing to abstract over the type of reference\n+/// (`&T`, `&mut T`) or allow both the referenced and owned type to be treated\n+/// in the same manner.\n+///\n+/// The key difference between the two traits is the intention:\n+///\n+/// - Use `AsRef` when goal is to simply convert into a reference\n+/// - Use `Borrow` when goal is related to writing code that is agnostic to the\n+///   type of borrow and if is reference or value\n+///\n+/// See [the book][book] for a more detailed comparison.\n ///\n /// [book]: ../../book/borrow-and-asref.html\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n-/// returns an [`Option<T>`] or a [`Result<T, E>`].\n+/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n ///\n+/// # Generic Implementations\n+///\n+/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n+///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n+///   `&mut Foo` or `&&mut Foo`)\n+///\n /// # Examples\n ///\n /// Both [`String`] and `&str` implement `AsRef<str>`:\n@@ -82,11 +104,6 @@ use str::FromStr;\n /// is_hello(s);\n /// ```\n ///\n-/// # Generic Impls\n-///\n-/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n-/// reference (e.g.: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`)\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRef<T: ?Sized> {\n     /// Performs the conversion.\n@@ -96,12 +113,21 @@ pub trait AsRef<T: ?Sized> {\n \n /// A cheap, mutable reference-to-mutable reference conversion.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n-/// returns an [`Option<T>`] or a [`Result<T, E>`].\n+/// This trait is similar to `AsRef` but used for converting between mutable\n+/// references.\n+///\n+/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n ///\n+/// # Generic Implementations\n+///\n+/// - `AsMut` auto-dereferences if the inner type is a reference or a mutable\n+///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n+///   `&mut Foo` or `&&mut Foo`)\n+///\n /// # Examples\n ///\n /// [`Box<T>`] implements `AsMut<T>`:\n@@ -118,10 +144,6 @@ pub trait AsRef<T: ?Sized> {\n /// assert_eq!(*boxed_num, 1);\n /// ```\n ///\n-/// # Generic Impls\n-///\n-/// - `AsMut` auto-dereferences if the inner type is a reference or a mutable\n-/// reference (e.g.: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`)\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n@@ -130,14 +152,22 @@ pub trait AsMut<T: ?Sized> {\n     fn as_mut(&mut self) -> &mut T;\n }\n \n-/// A conversion that consumes `self`, which may or may not be expensive.\n+/// A conversion that consumes `self`, which may or may not be expensive. The\n+/// reciprocal of [`From`][From].\n+///\n+/// **Note: this trait must not fail**. If the conversion can fail, use\n+/// [`TryInto`] or a dedicated method which returns an [`Option<T>`] or a\n+/// [`Result<T, E>`].\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use [`TryInto`] or a dedicated\n-/// method which returns an [`Option<T>`] or a [`Result<T, E>`].\n+/// Library authors should not directly implement this trait, but should prefer\n+/// implementing the [`From`][From] trait, which offers greater flexibility and\n+/// provides an equivalent `Into` implementation for free, thanks to a blanket\n+/// implementation in the standard library.\n ///\n-/// Library authors should not directly implement this trait, but should prefer implementing\n-/// the [`From`][From] trait, which offers greater flexibility and provides an equivalent `Into`\n-/// implementation for free, thanks to a blanket implementation in the standard library.\n+/// # Generic Implementations\n+///\n+/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n+/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n ///\n /// # Examples\n ///\n@@ -153,11 +183,6 @@ pub trait AsMut<T: ?Sized> {\n /// is_hello(s);\n /// ```\n ///\n-/// # Generic Impls\n-///\n-/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n-/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n-///\n /// [`TryInto`]: trait.TryInto.html\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n@@ -171,10 +196,31 @@ pub trait Into<T>: Sized {\n     fn into(self) -> T;\n }\n \n-/// Construct `Self` via a conversion.\n+/// Simple and safe type conversions in to `Self`. It is the reciprocal of\n+/// `Into`.\n+///\n+/// This trait is useful when performing error handling as described by\n+/// [the book][book] and is closely related to the `?` operator.\n+///\n+/// When constructing a function that is capable of failing the return type\n+/// will generally be of the form `Result<T, E>`.\n+///\n+/// The `From` trait allows for simplification of error handling by providing a\n+/// means of returning a single error type that encapsulates numerous possible\n+/// erroneous situations.\n+///\n+/// This trait is not limited to error handling, rather the general case for\n+/// this trait would be in any type conversions to have an explicit definition\n+/// of how they are performed.\n+///\n+/// **Note: this trait must not fail**. If the conversion can fail, use\n+/// [`TryFrom`] or a dedicated method which returns an [`Option<T>`] or a\n+/// [`Result<T, E>`].\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use [`TryFrom`] or a dedicated\n-/// method which returns an [`Option<T>`] or a [`Result<T, E>`].\n+/// # Generic Implementations\n+///\n+/// - `From<T> for U` implies [`Into<U>`]` for T`\n+/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n ///\n /// # Examples\n ///\n@@ -186,29 +232,60 @@ pub trait Into<T>: Sized {\n ///\n /// assert_eq!(string, other_string);\n /// ```\n-/// # Generic impls\n ///\n-/// - `From<T> for U` implies [`Into<U>`]` for T`\n-/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n+/// An example usage for error handling:\n+///\n+/// ```\n+/// use std::io::{self, Read};\n+/// use std::num;\n+///\n+/// enum CliError {\n+///     IoError(io::Error),\n+///     ParseError(num::ParseIntError),\n+/// }\n+///\n+/// impl From<io::Error> for CliError {\n+///     fn from(error: io::Error) -> Self {\n+///         CliError::IoError(error)\n+///     }\n+/// }\n+///\n+/// impl From<num::ParseIntError> for CliError {\n+///     fn from(error: num::ParseIntError) -> Self {\n+///         CliError::ParseError(error)\n+///     }\n+/// }\n+///\n+/// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n+///     let mut file = std::fs::File::open(\"test\")?;\n+///     let mut contents = String::new();\n+///     file.read_to_string(&mut contents)?;\n+///     let num: i32 = contents.trim().parse()?;\n+///     Ok(num)\n+/// }\n+/// ```\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Into<U>`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n+/// [book]: ../../book/error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from(T) -> Self;\n }\n \n-/// An attempted conversion that consumes `self`, which may or may not be expensive.\n+/// An attempted conversion that consumes `self`, which may or may not be\n+/// expensive.\n ///\n-/// Library authors should not directly implement this trait, but should prefer implementing\n-/// the [`TryFrom`] trait, which offers greater flexibility and provides an equivalent `TryInto`\n-/// implementation for free, thanks to a blanket implementation in the standard library.\n+/// Library authors should not directly implement this trait, but should prefer\n+/// implementing the [`TryFrom`] trait, which offers greater flexibility and\n+/// provides an equivalent `TryInto` implementation for free, thanks to a\n+/// blanket implementation in the standard library.\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n@@ -236,15 +313,17 @@ pub trait TryFrom<T>: Sized {\n \n // As lifts over &\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U> {\n+impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U>\n+{\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n     }\n }\n \n // As lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n+impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U>\n+{\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n     }\n@@ -260,7 +339,8 @@ impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n \n // AsMut lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n+impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U>\n+{\n     fn as_mut(&mut self) -> &mut U {\n         (*self).as_mut()\n     }\n@@ -276,7 +356,8 @@ impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n \n // From implies Into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, U> Into<U> for T where U: From<T> {\n+impl<T, U> Into<U> for T where U: From<T>\n+{\n     fn into(self) -> U {\n         U::from(self)\n     }\n@@ -291,7 +372,8 @@ impl<T> From<T> for T {\n \n // TryFrom implies TryInto\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl<T, U> TryInto<U> for T where U: TryFrom<T> {\n+impl<T, U> TryInto<U> for T where U: TryFrom<T>\n+{\n     type Error = U::Error;\n \n     fn try_into(self) -> Result<U, U::Error> {\n@@ -327,7 +409,8 @@ impl AsRef<str> for str {\n \n // FromStr implies TryFrom<&str>\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl<'a, T> TryFrom<&'a str> for T where T: FromStr {\n+impl<'a, T> TryFrom<&'a str> for T where T: FromStr\n+{\n     type Error = <T as FromStr>::Err;\n \n     fn try_from(s: &'a str) -> Result<T, Self::Error> {"}, {"sha": "c0aa650a1e854735b6aca0746e14bae1b65bd360", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -16,6 +16,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use cell::UnsafeCell;\n use cmp;\n use hash::Hash;\n use hash::Hasher;\n@@ -553,3 +554,19 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n+\n+/// Compiler-internal trait used to determine whether a type contains\n+/// any `UnsafeCell` internally, but not through an indirection.\n+/// This affects, for example, whether a `static` of that type is\n+/// placed in read-only static memory or writable static memory.\n+#[cfg_attr(not(stage0), lang = \"freeze\")]\n+unsafe trait Freeze {}\n+\n+unsafe impl Freeze for .. {}\n+\n+impl<T: ?Sized> !Freeze for UnsafeCell<T> {}\n+unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\n+unsafe impl<T: ?Sized> Freeze for *const T {}\n+unsafe impl<T: ?Sized> Freeze for *mut T {}\n+unsafe impl<'a, T: ?Sized> Freeze for &'a T {}\n+unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}"}, {"sha": "c34a802d1eb037b44c5252078c7270b5472e0f65", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1 +1 @@\n-Subproject commit 05a2d197356ef253dfd985166576619ac9b6947f\n+Subproject commit c34a802d1eb037b44c5252078c7270b5472e0f65"}, {"sha": "2851191dc141a1373b04dbe78093f45245642686", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1847,5 +1847,6 @@ register_diagnostics! {\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0566  // conflicting representation hints\n+    E0566, // conflicting representation hints\n+    E0587, // conflicting packed and align representation hints\n }"}, {"sha": "bf292ccb8d86d064212c1d33c40e56b90c0c144a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -57,6 +57,9 @@ impl<'a> CheckAttrVisitor<'a> {\n         };\n \n         let mut conflicting_reprs = 0;\n+        let mut found_packed = false;\n+        let mut found_align = false;\n+\n         for word in words {\n \n             let name = match word.name() {\n@@ -84,6 +87,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                                 (\"attribute should be applied to struct or union\",\n                                  \"a struct or union\")\n                     } else {\n+                        found_packed = true;\n                         continue\n                     }\n                 }\n@@ -96,6 +100,15 @@ impl<'a> CheckAttrVisitor<'a> {\n                         continue\n                     }\n                 }\n+                \"align\" => {\n+                    found_align = true;\n+                    if target != Target::Struct {\n+                        (\"attribute should be applied to struct\",\n+                         \"a struct\")\n+                    } else {\n+                        continue\n+                    }\n+                }\n                 \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n@@ -117,6 +130,10 @@ impl<'a> CheckAttrVisitor<'a> {\n             span_warn!(self.sess, attr.span, E0566,\n                        \"conflicting representation hints\");\n         }\n+        if found_align && found_packed {\n+            struct_span_err!(self.sess, attr.span, E0587,\n+                             \"conflicting packed and align representation hints\").emit();\n+        }\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {"}, {"sha": "32dfb63d6150a5933d13294120e30a459ed4487f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -274,6 +274,7 @@ language_item_table! {\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n+    FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n \n     DropTraitLangItem,               \"drop\",                    drop_trait;\n "}, {"sha": "e14295982916f44ad0578777db464581b6a4554d", "filename": "src/librustc/ty/contents.rs", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/5fc25224da78afcfdd76783c38ad3beff42a990c/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc25224da78afcfdd76783c38ad3beff42a990c/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=5fc25224da78afcfdd76783c38ad3beff42a990c", "patch": "@@ -1,255 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir::def_id::{DefId};\n-use ty::{self, Ty, TyCtxt};\n-use util::common::MemoizationMap;\n-use util::nodemap::FxHashMap;\n-\n-use std::fmt;\n-use std::ops;\n-\n-use syntax::ast;\n-\n-/// Type contents is how the type checker reasons about kinds.\n-/// They track what kinds of things are found within a type.  You can\n-/// think of them as kind of an \"anti-kind\".  They track the kinds of values\n-/// and thinks that are contained in types.  Having a larger contents for\n-/// a type tends to rule that type *out* from various kinds.  For example,\n-/// a type that contains a reference is not sendable.\n-///\n-/// The reason we compute type contents and not kinds is that it is\n-/// easier for me (nmatsakis) to think about what is contained within\n-/// a type than to think about what is *not* contained within a type.\n-#[derive(Clone, Copy)]\n-pub struct TypeContents {\n-    pub bits: u64\n-}\n-\n-macro_rules! def_type_content_sets {\n-    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n-        #[allow(non_snake_case)]\n-        mod $mname {\n-            use super::TypeContents;\n-            $(\n-                #[allow(non_upper_case_globals)]\n-                pub const $name: TypeContents = TypeContents { bits: $bits };\n-             )+\n-        }\n-    }\n-}\n-\n-def_type_content_sets! {\n-    mod TC {\n-        None                                = 0b0000_0000__0000_0000__0000,\n-\n-        // Things that are interior to the value (first nibble):\n-        InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n-        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n-        // InteriorAll                         = 0b00000000__00000000__1111,\n-\n-        // Things that are owned by the value (second and third nibbles):\n-        OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n-        // OwnsAll                             = 0b0000_0000__1111_1111__0000,\n-\n-        // All bits\n-        All                                 = 0b1111_1111__1111_1111__1111\n-    }\n-}\n-\n-impl TypeContents {\n-    pub fn when(&self, cond: bool) -> TypeContents {\n-        if cond {*self} else {TC::None}\n-    }\n-\n-    pub fn intersects(&self, tc: TypeContents) -> bool {\n-        (self.bits & tc.bits) != 0\n-    }\n-\n-    pub fn interior_param(&self) -> bool {\n-        self.intersects(TC::InteriorParam)\n-    }\n-\n-    pub fn interior_unsafe(&self) -> bool {\n-        self.intersects(TC::InteriorUnsafe)\n-    }\n-\n-    pub fn needs_drop(&self, _: TyCtxt) -> bool {\n-        self.intersects(TC::OwnsDtor)\n-    }\n-\n-    pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n-        I: IntoIterator<Item=T>,\n-        F: FnMut(T) -> TypeContents,\n-    {\n-        v.into_iter().fold(TC::None, |tc, ty| tc | f(ty))\n-    }\n-}\n-\n-impl ops::BitOr for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn bitor(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n-    }\n-}\n-\n-impl ops::BitAnd for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn bitand(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & other.bits}\n-    }\n-}\n-\n-impl ops::Sub for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn sub(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & !other.bits}\n-    }\n-}\n-\n-impl fmt::Debug for TypeContents {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeContents({:b})\", self.bits)\n-    }\n-}\n-\n-impl<'a, 'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n-        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FxHashMap()));\n-\n-        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           ty: Ty<'tcx>,\n-                           cache: &mut FxHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n-        {\n-            // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n-            // private cache for this walk.  This is needed in the case of cyclic\n-            // types like:\n-            //\n-            //     struct List { next: Box<Option<List>>, ... }\n-            //\n-            // When computing the type contents of such a type, we wind up deeply\n-            // recursing as we go.  So when we encounter the recursive reference\n-            // to List, we temporarily use TC::None as its contents.  Later we'll\n-            // patch up the cache with the correct value, once we've computed it\n-            // (this is basically a co-inductive process, if that helps).  So in\n-            // the end we'll compute TC::OwnsOwned, in this case.\n-            //\n-            // The problem is, as we are doing the computation, we will also\n-            // compute an *intermediate* contents for, e.g., Option<List> of\n-            // TC::None.  This is ok during the computation of List itself, but if\n-            // we stored this intermediate value into tcx.tc_cache, then later\n-            // requests for the contents of Option<List> would also yield TC::None\n-            // which is incorrect.  This value was computed based on the crutch\n-            // value for the type contents of list.  The correct value is\n-            // TC::OwnsOwned.  This manifested as issue #4821.\n-            if let Some(tc) = cache.get(&ty) {\n-                return *tc;\n-            }\n-            // Must check both caches!\n-            if let Some(tc) = tcx.tc_cache.borrow().get(&ty) {\n-                return *tc;\n-            }\n-            cache.insert(ty, TC::None);\n-\n-            let result = match ty.sty {\n-                // usize and isize are ffi-unsafe\n-                ty::TyUint(ast::UintTy::Us) | ty::TyInt(ast::IntTy::Is) => {\n-                    TC::None\n-                }\n-\n-                // Scalar and unique types are sendable, and durable\n-                ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar => {\n-                    TC::None\n-                }\n-\n-                ty::TyDynamic(..) => {\n-                    TC::All - TC::InteriorParam\n-                }\n-\n-                ty::TyRawPtr(_) => {\n-                    TC::None\n-                }\n-\n-                ty::TyRef(..) => {\n-                    TC::None\n-                }\n-\n-                ty::TyArray(ty, _) => {\n-                    tc_ty(tcx, ty, cache)\n-                }\n-\n-                ty::TySlice(ty) => {\n-                    tc_ty(tcx, ty, cache)\n-                }\n-                ty::TyStr => TC::None,\n-\n-                ty::TyClosure(def_id, ref substs) => {\n-                    TypeContents::union(\n-                        substs.upvar_tys(def_id, tcx),\n-                        |ty| tc_ty(tcx, &ty, cache))\n-                }\n-\n-                ty::TyTuple(ref tys, _) => {\n-                    TypeContents::union(&tys[..],\n-                                        |ty| tc_ty(tcx, *ty, cache))\n-                }\n-\n-                ty::TyAdt(def, substs) => {\n-                    let mut res =\n-                        TypeContents::union(&def.variants, |v| {\n-                            TypeContents::union(&v.fields, |f| {\n-                                tc_ty(tcx, f.ty(tcx, substs), cache)\n-                            })\n-                        });\n-\n-                    if def.is_union() {\n-                        // unions don't have destructors regardless of the child types\n-                        res = res - TC::OwnsDtor;\n-                    }\n-\n-                    if def.has_dtor(tcx) {\n-                        res = res | TC::OwnsDtor;\n-                    }\n-\n-                    apply_lang_items(tcx, def.did, res)\n-                }\n-\n-                ty::TyProjection(..) |\n-                ty::TyParam(_) |\n-                ty::TyAnon(..) => {\n-                    TC::All\n-                }\n-\n-                ty::TyInfer(_) |\n-                ty::TyError => {\n-                    bug!(\"asked to compute contents of error type\");\n-                }\n-            };\n-\n-            cache.insert(ty, result);\n-            result\n-        }\n-\n-        fn apply_lang_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      did: DefId, tc: TypeContents)\n-                                      -> TypeContents {\n-            if Some(did) == tcx.lang_items.unsafe_cell_type() {\n-                tc | TC::InteriorUnsafe\n-            } else {\n-                tc\n-            }\n-        }\n-    }\n-}"}, {"sha": "a41629258716d51dc991639bc4654c129daaa48e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -436,9 +436,6 @@ pub struct GlobalCtxt<'tcx> {\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n-    // Cache for the type-contents routine. FIXME -- track deps?\n-    pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n-\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n@@ -708,7 +705,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             rcache: RefCell::new(FxHashMap()),\n-            tc_cache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,"}, {"sha": "6a206640b3baa0233e71bfbc15e794f61ab5c388", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -548,8 +548,12 @@ pub type FieldPath = Vec<u32>;\n /// A structure, a product type in ADT terms.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Struct {\n+    /// Maximum alignment of fields and repr alignment.\n     pub align: Align,\n \n+    /// Primitive alignment of fields without repr alignment.\n+    pub primitive_align: Align,\n+\n     /// If true, no alignment padding is used.\n     pub packed: bool,\n \n@@ -583,10 +587,20 @@ impl<'a, 'gcx, 'tcx> Struct {\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n                   repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = repr.packed();\n+        if repr.packed() && repr.align > 0 {\n+            bug!(\"Struct cannot be packed and aligned\");\n+        }\n+\n+        let align = if repr.packed() {\n+            dl.i8_align\n+        } else {\n+            dl.aggregate_align\n+        };\n+\n         let mut ret = Struct {\n-            align: if packed { dl.i8_align } else { dl.aggregate_align },\n-            packed: packed,\n+            align: align,\n+            primitive_align: align,\n+            packed: repr.packed(),\n             sized: true,\n             offsets: vec![],\n             memory_index: vec![],\n@@ -660,7 +674,9 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n             if !ret.packed {\n                 let align = field.align(dl);\n+                let primitive_align = field.primitive_align(dl);\n                 ret.align = ret.align.max(align);\n+                ret.primitive_align = ret.primitive_align.max(primitive_align);\n                 offset = offset.abi_align(align);\n             }\n \n@@ -671,6 +687,11 @@ impl<'a, 'gcx, 'tcx> Struct {\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n+        if repr.align > 0 {\n+            let repr_align = repr.align as u64;\n+            ret.align = ret.align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n+            debug!(\"Struct::new repr_align: {:?}\", repr_align);\n+        }\n \n         debug!(\"Struct::new min_size: {:?}\", offset);\n         ret.min_size = offset;\n@@ -836,12 +857,23 @@ impl<'a, 'gcx, 'tcx> Struct {\n         }\n         Ok(None)\n     }\n+\n+    pub fn over_align(&self) -> Option<u32> {\n+        let align = self.align.abi();\n+        let primitive_align = self.primitive_align.abi();\n+        if align > primitive_align {\n+            Some(align as u32)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// An untagged union.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Union {\n     pub align: Align,\n+    pub primitive_align: Align,\n \n     pub min_size: Size,\n \n@@ -851,8 +883,10 @@ pub struct Union {\n \n impl<'a, 'gcx, 'tcx> Union {\n     fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+        let align = if packed { dl.i8_align } else { dl.aggregate_align };\n         Union {\n-            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            align: align,\n+            primitive_align: align,\n             min_size: Size::from_bytes(0),\n             packed: packed,\n         }\n@@ -875,6 +909,7 @@ impl<'a, 'gcx, 'tcx> Union {\n \n             if !self.packed {\n                 self.align = self.align.max(field.align(dl));\n+                self.primitive_align = self.primitive_align.max(field.primitive_align(dl));\n             }\n             self.min_size = cmp::max(self.min_size, field.size(dl));\n         }\n@@ -888,6 +923,16 @@ impl<'a, 'gcx, 'tcx> Union {\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n+\n+    pub fn over_align(&self) -> Option<u32> {\n+        let align = self.align.abi();\n+        let primitive_align = self.primitive_align.abi();\n+        if align > primitive_align {\n+            Some(align as u32)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// The first half of a fat pointer.\n@@ -924,6 +969,7 @@ pub enum Layout {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n         align: Align,\n+        primitive_align: Align,\n         element_size: Size,\n         count: u64\n     },\n@@ -970,7 +1016,8 @@ pub enum Layout {\n         discr: Integer,\n         variants: Vec<Struct>,\n         size: Size,\n-        align: Align\n+        align: Align,\n+        primitive_align: Align,\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -1118,6 +1165,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: true,\n                     align: element.align(dl),\n+                    primitive_align: element.primitive_align(dl),\n                     element_size: element_size,\n                     count: count\n                 }\n@@ -1127,6 +1175,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: false,\n                     align: element.align(dl),\n+                    primitive_align: element.primitive_align(dl),\n                     element_size: element.size(dl),\n                     count: 0\n                 }\n@@ -1135,6 +1184,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: false,\n                     align: dl.i8_align,\n+                    primitive_align: dl.i8_align,\n                     element_size: Size::from_bytes(1),\n                     count: 0\n                 }\n@@ -1340,6 +1390,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 assert!(discr_max >= 0);\n                 let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n                 let mut align = dl.aggregate_align;\n+                let mut primitive_align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n                 // We're interested in the smallest alignment, so start large.\n@@ -1369,6 +1420,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n                     size = cmp::max(size, st.min_size);\n                     align = align.max(st.align);\n+                    primitive_align = primitive_align.max(st.primitive_align);\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1435,7 +1487,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     discr: ity,\n                     variants: variants,\n                     size: size,\n-                    align: align\n+                    align: align,\n+                    primitive_align: primitive_align\n                 }\n             }\n \n@@ -1557,6 +1610,30 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n+    /// Returns alignment before repr alignment is applied\n+    pub fn primitive_align(&self, dl: &TargetDataLayout) -> Align {\n+        match *self {\n+            Array { primitive_align, .. } | General { primitive_align, .. } => primitive_align,\n+            Univariant { ref variant, .. } |\n+            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+                variant.primitive_align\n+            },\n+\n+            _ => self.align(dl)\n+        }\n+    }\n+\n+    /// Returns repr alignment if it is greater than the primitive alignment.\n+    pub fn over_align(&self, dl: &TargetDataLayout) -> Option<u32> {\n+        let align = self.align(dl);\n+        let primitive_align = self.primitive_align(dl);\n+        if align.abi() > primitive_align.abi() {\n+            Some(align.abi() as u32)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn field_offset<C: HasDataLayout>(&self,\n                                           cx: C,\n                                           i: usize,"}, {"sha": "5be73542b931dd5a73c17c4c761ba2a8e4b7fe9e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -37,6 +37,7 @@ use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n+use std::cmp;\n use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -71,7 +72,6 @@ pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n \n-pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n@@ -99,7 +99,6 @@ pub mod walk;\n pub mod wf;\n pub mod util;\n \n-mod contents;\n mod context;\n mod flags;\n mod instance;\n@@ -425,6 +424,10 @@ bitflags! {\n         const IS_SIZED          = 1 << 17,\n         const MOVENESS_CACHED   = 1 << 18,\n         const MOVES_BY_DEFAULT  = 1 << 19,\n+        const FREEZENESS_CACHED = 1 << 20,\n+        const IS_FREEZE         = 1 << 21,\n+        const NEEDS_DROP_CACHED = 1 << 22,\n+        const NEEDS_DROP        = 1 << 23,\n     }\n }\n \n@@ -1181,6 +1184,9 @@ pub struct ParameterEnvironment<'tcx> {\n \n     /// A cache for `type_is_sized`\n     pub is_sized_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+\n+    /// A cache for `type_is_freeze`\n+    pub is_freeze_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n@@ -1195,6 +1201,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             free_id_outlive: self.free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n+            is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -1464,10 +1471,12 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n+    pub align: u16,\n     pub flags: ReprFlags,\n }\n \n impl_stable_hash_for!(struct ReprOptions {\n+    align,\n     int,\n     flags\n });\n@@ -1476,7 +1485,7 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-\n+        let mut max_align = 0;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n                 flags.insert(match r {\n@@ -1487,6 +1496,10 @@ impl ReprOptions {\n                         size = Some(i);\n                         ReprFlags::empty()\n                     },\n+                    attr::ReprAlign(align) => {\n+                        max_align = cmp::max(align, max_align);\n+                        ReprFlags::empty()\n+                    },\n                 });\n             }\n         }\n@@ -1500,7 +1513,7 @@ impl ReprOptions {\n         if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n-        ReprOptions { int: size, flags: flags }\n+        ReprOptions { int: size, align: max_align, flags: flags }\n     }\n \n     #[inline]\n@@ -2375,40 +2388,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Some(self.item_mir(did))\n     }\n \n-    /// If `type_needs_drop` returns true, then `ty` is definitely\n-    /// non-copy and *might* have a destructor attached; if it returns\n-    /// false, then `ty` definitely has no destructor (i.e. no drop glue).\n-    ///\n-    /// (Note that this implies that if `ty` has a destructor attached,\n-    /// then `type_needs_drop` will definitely return `true` for `ty`.)\n-    pub fn type_needs_drop_given_env(self,\n-                                     ty: Ty<'gcx>,\n-                                     param_env: &ty::ParameterEnvironment<'gcx>) -> bool {\n-        // Issue #22536: We first query type_moves_by_default.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        let tcx = self.global_tcx();\n-        let implements_copy = !ty.moves_by_default(tcx, param_env, DUMMY_SP);\n-\n-        if implements_copy { return false; }\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking if the `needs_drop` bit is set; we need\n-        // not zero non-Copy types if they have no destructor.\n-\n-        // FIXME(#22815): Note that calling `ty::type_contents` is a\n-        // conservative heuristic; it may report that `needs_drop` is set\n-        // when actual type does not actually have a destructor associated\n-        // with it. But since `ty` absolutely did not have the `Copy`\n-        // bound attached (see above), it is sound to treat it as having a\n-        // destructor (e.g. zero its memory on move).\n-\n-        let contents = ty.type_contents(tcx);\n-        debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n-        contents.needs_drop(tcx)\n-    }\n-\n     /// Get the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n         if let Some(id) = self.hir.as_local_node_id(did) {\n@@ -2531,6 +2510,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n+            is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2603,6 +2583,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n+            is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));"}, {"sha": "49d79f6545e2dd682b3cb1ff55ac936f7fced871", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -21,7 +21,7 @@ use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{FxHashMap, FxHashSet};\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n@@ -655,6 +655,165 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         result\n     }\n \n+    /// Returns `true` if and only if there are no `UnsafeCell`s\n+    /// nested within the type (ignoring `PhantomData` or pointers).\n+    #[inline]\n+    pub fn is_freeze(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     param_env: &ParameterEnvironment<'tcx>,\n+                     span: Span) -> bool\n+    {\n+        if self.flags.get().intersects(TypeFlags::FREEZENESS_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::IS_FREEZE);\n+        }\n+\n+        self.is_freeze_uncached(tcx, param_env, span)\n+    }\n+\n+    fn is_freeze_uncached(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: &ParameterEnvironment<'tcx>,\n+                          span: Span) -> bool {\n+        assert!(!self.needs_infer());\n+\n+        // Fast-path for primitive types\n+        let result = match self.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyStr | TyNever => Some(true),\n+\n+            TyArray(..) | TySlice(_) |\n+            TyTuple(..) | TyClosure(..) | TyAdt(..) |\n+            TyDynamic(..) | TyProjection(..) | TyParam(..) |\n+            TyInfer(..) | TyAnon(..) | TyError => None\n+        }.unwrap_or_else(|| {\n+            self.impls_bound(tcx, param_env, tcx.require_lang_item(lang_items::FreezeTraitLangItem),\n+                              &param_env.is_freeze_cache, span) });\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::FREEZENESS_CACHED | TypeFlags::IS_FREEZE\n+            } else {\n+                TypeFlags::FREEZENESS_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely\n+    /// non-copy and *might* have a destructor attached; if it returns\n+    /// `false`, then `ty` definitely has no destructor (i.e. no drop glue).\n+    ///\n+    /// (Note that this implies that if `ty` has a destructor attached,\n+    /// then `needs_drop` will definitely return `true` for `ty`.)\n+    #[inline]\n+    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    param_env: &ty::ParameterEnvironment<'tcx>) -> bool {\n+        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n+        }\n+\n+        self.needs_drop_uncached(tcx, param_env, &mut FxHashSet())\n+    }\n+\n+    fn needs_drop_inner(&'tcx self,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: &ty::ParameterEnvironment<'tcx>,\n+                        stack: &mut FxHashSet<Ty<'tcx>>)\n+                        -> bool {\n+        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n+        }\n+\n+        // This should be reported as an error by `check_representable`.\n+        //\n+        // Consider the type as not needing drop in the meanwhile to avoid\n+        // further errors.\n+        if let Some(_) = stack.replace(self) {\n+            return false;\n+        }\n+\n+        let needs_drop = self.needs_drop_uncached(tcx, param_env, stack);\n+\n+        // \"Pop\" the cycle detection \"stack\".\n+        stack.remove(self);\n+\n+        needs_drop\n+    }\n+\n+    fn needs_drop_uncached(&'tcx self,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           param_env: &ty::ParameterEnvironment<'tcx>,\n+                           stack: &mut FxHashSet<Ty<'tcx>>)\n+                           -> bool {\n+        assert!(!self.needs_infer());\n+\n+        let result = match self.sty {\n+            // Fast-path for primitive types\n+            ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+            ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+\n+            // Issue #22536: We first query type_moves_by_default.  It sees a\n+            // normalized version of the type, and therefore will definitely\n+            // know whether the type implements Copy (and thus needs no\n+            // cleanup/drop/zeroing) ...\n+            _ if !self.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n+\n+            // ... (issue #22536 continued) but as an optimization, still use\n+            // prior logic of asking for the structural \"may drop\".\n+\n+            // FIXME(#22815): Note that this is a conservative heuristic;\n+            // it may report that the type \"may drop\" when actual type does\n+            // not actually have a destructor associated with it. But since\n+            // the type absolutely did not have the `Copy` bound attached\n+            // (see above), it is sound to treat it as having a destructor.\n+\n+            // User destructors are the only way to have concrete drop types.\n+            ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+\n+            // Can refer to a type which may drop.\n+            // FIXME(eddyb) check this against a ParameterEnvironment.\n+            ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n+            ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+\n+            // Structural recursion.\n+            ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+                ty.needs_drop_inner(tcx, param_env, stack)\n+            }\n+\n+            ty::TyClosure(def_id, ref substs) => {\n+                substs.upvar_tys(def_id, tcx)\n+                    .any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n+            }\n+\n+            ty::TyTuple(ref tys, _) => {\n+                tys.iter().any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n+            }\n+\n+            // unions don't have destructors regardless of the child types\n+            ty::TyAdt(def, _) if def.is_union() => false,\n+\n+            ty::TyAdt(def, substs) => {\n+                def.variants.iter().any(|v| {\n+                    v.fields.iter().any(|f| {\n+                        f.ty(tcx, substs).needs_drop_inner(tcx, param_env, stack)\n+                    })\n+                })\n+            }\n+        };\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::NEEDS_DROP_CACHED | TypeFlags::NEEDS_DROP\n+            } else {\n+                TypeFlags::NEEDS_DROP_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n     #[inline]\n     pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n                         -> Result<&'tcx Layout, LayoutError<'tcx>> {"}, {"sha": "e60fdc386ce6ed90fa1f4a1f7441bdc557e2cb87", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -162,6 +162,7 @@ supported_targets! {\n     (\"sparc64-unknown-linux-gnu\", sparc64_unknown_linux_gnu),\n \n     (\"i686-linux-android\", i686_linux_android),\n+    (\"x86_64-linux-android\", x86_64_linux_android),\n     (\"arm-linux-androideabi\", arm_linux_androideabi),\n     (\"armv7-linux-androideabi\", armv7_linux_androideabi),\n     (\"aarch64-linux-android\", aarch64_linux_android),"}, {"sha": "75cf3e1243841aa79525b82685462e87749078c6", "filename": "src/librustc_back/target/x86_64_linux_android.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_back%2Ftarget%2Fx86_64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_back%2Ftarget%2Fx86_64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_linux_android.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::android_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    // https://developer.android.com/ndk/guides/abis.html#86-64\n+    base.features = \"+mmx,+sse,+sse2,+sse3,+ssse3,+sse4.1,+sse4.2,+popcnt\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-linux-android\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"android\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "de5613dbfaa38b183c8d34d4584c233191501805", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -322,7 +322,7 @@ fn on_all_drop_children_bits<'a, 'tcx, F>(\n         let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-        if tcx.type_needs_drop_given_env(ty, &ctxt.param_env) {\n+        if ty.needs_drop(tcx, &ctxt.param_env) {\n             each_child(child);\n         } else {\n             debug!(\"on_all_drop_children_bits - skipping\")"}, {"sha": "64652bb308bdc4952af117da586ff704648c68c6", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -263,6 +263,41 @@ impl EmitterWriter {\n \n         draw_col_separator(buffer, line_offset, width_offset - 2);\n \n+        // Special case when there's only one annotation involved, it is the start of a multiline\n+        // span and there's no text at the beginning of the code line. Instead of doing the whole\n+        // graph:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  _^\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_^ test\n+        //\n+        // we simplify the output to:\n+        //\n+        // 2 | / fn foo() {\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_^ test\n+        if line.annotations.len() == 1 {\n+            if let Some(ref ann) = line.annotations.get(0) {\n+                if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n+                    if source_string[0..ann.start_col].trim() == \"\" {\n+                        let style = if ann.is_primary {\n+                            Style::UnderlinePrimary\n+                        } else {\n+                            Style::UnderlineSecondary\n+                        };\n+                        buffer.putc(line_offset,\n+                                    width_offset + depth - 1,\n+                                    '/',\n+                                    style);\n+                        return vec![(depth, style)];\n+                    }\n+                }\n+            }\n+        }\n+\n         // We want to display like this:\n         //\n         //      vec.push(vec.pop().unwrap());\n@@ -355,10 +390,8 @@ impl EmitterWriter {\n         for (i, annotation) in annotations.iter().enumerate() {\n             for (j, next) in annotations.iter().enumerate() {\n                 if overlaps(next, annotation, 0)  // This label overlaps with another one and both\n-                    && !annotation.is_line()      // take space (they have text and are not\n-                    && !next.is_line()            // multiline lines).\n-                    && annotation.has_label()\n-                    && j > i\n+                    && annotation.has_label()     // take space (they have text and are not\n+                    && j > i                      // multiline lines).\n                     && p == 0  // We're currently on the first line, move the label one line down\n                 {\n                     // This annotation needs a new line in the output.\n@@ -374,7 +407,7 @@ impl EmitterWriter {\n                     } else {\n                         0\n                     };\n-                    if overlaps(next, annotation, l) // Do not allow two labels to be in the same\n+                    if (overlaps(next, annotation, l) // Do not allow two labels to be in the same\n                                                      // line if they overlap including padding, to\n                                                      // avoid situations like:\n                                                      //\n@@ -383,11 +416,18 @@ impl EmitterWriter {\n                                                      //      |      |\n                                                      //      fn_spanx_span\n                                                      //\n-                        && !annotation.is_line()     // Do not add a new line if this annotation\n-                        && !next.is_line()           // or the next are vertical line placeholders.\n                         && annotation.has_label()    // Both labels must have some text, otherwise\n-                        && next.has_label()          // they are not overlapping.\n+                        && next.has_label())         // they are not overlapping.\n+                                                     // Do not add a new line if this annotation\n+                                                     // or the next are vertical line placeholders.\n+                        || (annotation.takes_space() // If either this or the next annotation is\n+                            && next.has_label())     // multiline start/end, move it to a new line\n+                        || (annotation.has_label()   // so as not to overlap the orizontal lines.\n+                            && next.takes_space())\n+                        || (annotation.takes_space()\n+                            && next.takes_space())\n                     {\n+                        // This annotation needs a new line in the output.\n                         p += 1;\n                         break;\n                     }\n@@ -397,6 +437,7 @@ impl EmitterWriter {\n                 line_len = p;\n             }\n         }\n+\n         if line_len != 0 {\n             line_len += 1;\n         }\n@@ -480,7 +521,7 @@ impl EmitterWriter {\n             };\n             let pos = pos + 1;\n \n-            if pos > 1 && annotation.has_label() {\n+            if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..line_offset + pos + 1 {\n                     buffer.putc(p,\n                                 code_offset + annotation.start_col,\n@@ -514,12 +555,12 @@ impl EmitterWriter {\n         // After this we will have:\n         //\n         // 2 |   fn foo() {\n-        //   |  __________ starting here...\n+        //   |  __________\n         //   |      |\n         //   |      something about `foo`\n         // 3 |\n         // 4 |   }\n-        //   |  _  ...ending here: test\n+        //   |  _  test\n         for &(pos, annotation) in &annotations_position {\n             let style = if annotation.is_primary {\n                 Style::LabelPrimary\n@@ -557,12 +598,12 @@ impl EmitterWriter {\n         // After this we will have:\n         //\n         // 2 |   fn foo() {\n-        //   |  ____-_____^ starting here...\n+        //   |  ____-_____^\n         //   |      |\n         //   |      something about `foo`\n         // 3 |\n         // 4 |   }\n-        //   |  _^  ...ending here: test\n+        //   |  _^  test\n         for &(_, annotation) in &annotations_position {\n             let (underline, style) = if annotation.is_primary {\n                 ('^', Style::UnderlinePrimary)"}, {"sha": "7401ead22089bcfaad6e6317004a2b20e2312695", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -63,7 +63,7 @@ impl MultilineAnnotation {\n             start_col: self.start_col,\n             end_col: self.start_col + 1,\n             is_primary: self.is_primary,\n-            label: Some(\"starting here...\".to_owned()),\n+            label: None,\n             annotation_type: AnnotationType::MultilineStart(self.depth)\n         }\n     }\n@@ -73,10 +73,7 @@ impl MultilineAnnotation {\n             start_col: self.end_col - 1,\n             end_col: self.end_col,\n             is_primary: self.is_primary,\n-            label: match self.label {\n-                Some(ref label) => Some(format!(\"...ending here: {}\", label)),\n-                None => Some(\"...ending here\".to_owned()),\n-            },\n+            label: self.label.clone(),\n             annotation_type: AnnotationType::MultilineEnd(self.depth)\n         }\n     }\n@@ -106,9 +103,9 @@ pub enum AnnotationType {\n     // Each of these corresponds to one part of the following diagram:\n     //\n     //     x |   foo(1 + bar(x,\n-    //       |  _________^ starting here...           < MultilineStart\n-    //     x | |             y),                      < MultilineLine\n-    //       | |______________^ ...ending here: label < MultilineEnd\n+    //       |  _________^              < MultilineStart\n+    //     x | |             y),        < MultilineLine\n+    //       | |______________^ label   < MultilineEnd\n     //     x |       z);\n     /// Annotation marking the first character of a fully shown multiline span\n     MultilineStart(usize),\n@@ -189,6 +186,15 @@ impl Annotation {\n             false\n         }\n     }\n+\n+    pub fn takes_space(&self) -> bool {\n+        // Multiline annotations always have to keep vertical space.\n+        match self.annotation_type {\n+            AnnotationType::MultilineStart(_) |\n+            AnnotationType::MultilineEnd(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "1c69f3cff172a4321a49062bfcffcf3397e6c0fa", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1152,7 +1152,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.item_type(ctx.tcx.hir.local_def_id(field.id));\n-                if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n+                if field_ty.needs_drop(ctx.tcx, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,\n                                   \"union contains a field with possibly non-trivial drop code, \\"}, {"sha": "db9da2a280b94cc70af7e43645fef9e0e1b247bf", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                   type with inference types/regions\",\n                  ty);\n         });\n-        self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n+        ty.needs_drop(self.tcx.global_tcx(), &self.infcx.parameter_environment)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "892d67ac23725f2bd7015be805006a96bee95190", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -357,7 +357,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     // a regular goto.\n                     let ty = location.ty(&callee_mir, tcx).subst(tcx, callsite.substs);\n                     let ty = ty.to_ty(tcx);\n-                    if tcx.type_needs_drop_given_env(ty, &param_env) {\n+                    if ty.needs_drop(tcx, &param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n                             work_list.push(unwind);"}, {"sha": "526c1488ab480e96fe6873c985548f3cb7d8b610", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -80,10 +80,10 @@ impl<'a, 'tcx> Qualif {\n     fn restrict(&mut self, ty: Ty<'tcx>,\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 param_env: &ty::ParameterEnvironment<'tcx>) {\n-        if !ty.type_contents(tcx).interior_unsafe() {\n+        if ty.is_freeze(tcx, param_env, DUMMY_SP) {\n             *self = *self - Qualif::MUTABLE_INTERIOR;\n         }\n-        if !tcx.type_needs_drop_given_env(ty, param_env) {\n+        if !ty.needs_drop(tcx, param_env) {\n             *self = *self - Qualif::NEEDS_DROP;\n         }\n     }"}, {"sha": "07025fcfdb944de518e3e1dff13abb71f1611a48", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -277,8 +277,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let mut fields = fields;\n         fields.retain(|&(ref lvalue, _)| {\n-            self.tcx().type_needs_drop_given_env(\n-                self.lvalue_ty(lvalue), self.elaborator.param_env())\n+            self.lvalue_ty(lvalue).needs_drop(self.tcx(), self.elaborator.param_env())\n         });\n \n         debug!(\"drop_ladder - fields needing drop: {:?}\", fields);"}, {"sha": "fdb67522133781f74b3c2430ab58bc3aec917006", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -46,7 +46,7 @@ use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind, RangeEnd};\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n@@ -85,11 +85,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     // Adds the worst effect out of all the values of one type.\n     fn add_type(&mut self, ty: Ty<'gcx>) {\n-        if ty.type_contents(self.tcx).interior_unsafe() {\n+        if !ty.is_freeze(self.tcx, &self.param_env, DUMMY_SP) {\n             self.promotable = false;\n         }\n \n-        if self.tcx.type_needs_drop_given_env(ty, &self.param_env) {\n+        if ty.needs_drop(self.tcx, &self.param_env) {\n             self.promotable = false;\n         }\n     }"}, {"sha": "998e392b1f9078ac78dc68e4746666e8d0309e2e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -553,7 +553,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(ty, \"abi_cast\");\n+                let llscratch = bcx.alloca(ty, \"abi_cast\", None);\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value...\n@@ -746,13 +746,13 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n                 // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n                 // on memory dependencies rather than pointer equality\n-                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n+                let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n \n-                if mt.mutbl != hir::MutMutable && !interior_unsafe {\n+                if mt.mutbl != hir::MutMutable && is_freeze {\n                     arg.attrs.set(ArgAttribute::NoAlias);\n                 }\n \n-                if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n+                if mt.mutbl == hir::MutImmutable && is_freeze {\n                     arg.attrs.set(ArgAttribute::ReadOnly);\n                 }\n "}, {"sha": "d1c1dd7436a5ba5fae0ea61492cb6ddf22cc4bb2", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 66, "deletions": 25, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -90,12 +90,12 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    generic_type_of(cx, t, None, false, false)\n+    generic_type_of(cx, t, None)\n }\n \n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, t, Some(name), false, false)\n+    generic_type_of(cx, t, Some(name))\n }\n \n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -114,7 +114,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 _ => unreachable!()\n             };\n             let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false, false),\n+            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -123,12 +123,9 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              t: Ty<'tcx>,\n-                             name: Option<&str>,\n-                             sizing: bool,\n-                             dst: bool) -> Type {\n+                             name: Option<&str>) -> Type {\n     let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of t: {:?} name: {:?} sizing: {} dst: {}\",\n-           t, name, sizing, dst);\n+    debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n     match *l {\n         layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n         layout::RawNullablePointer { nndiscr, .. } => {\n@@ -148,11 +145,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing, dst),\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n-                    assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -163,13 +159,12 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, &variant, sizing, dst);\n+                    let fields = struct_llfields(cx, &fields, &variant);\n                     Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n                     // Hypothesis: named_struct's can never need a\n                     // drop flag. (... needs validation.)\n-                    assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -190,7 +185,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        layout::General { discr, size, align, .. } => {\n+        layout::General { discr, size, align, primitive_align, .. } => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -203,14 +198,15 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             let size = size.bytes();\n             let align = align.abi();\n+            let primitive_align = primitive_align.abi();\n             assert!(align <= std::u32::MAX as u64);\n             let discr_ty = Type::from_integer(cx, discr);\n             let discr_size = discr.size().bytes();\n             let padded_discr_size = roundup(discr_size, align as u32);\n             let variant_part_size = size-padded_discr_size;\n-            let variant_fill = union_fill(cx, variant_part_size, align);\n+            let variant_fill = union_fill(cx, variant_part_size, primitive_align);\n \n-            assert_eq!(machine::llalign_of_min(cx, variant_fill), align as u32);\n+            assert_eq!(machine::llalign_of_min(cx, variant_fill), primitive_align as u32);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n             let fields: Vec<Type> =\n                 [discr_ty,\n@@ -245,15 +241,60 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n }\n \n \n-fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n-                             variant: &layout::Struct,\n-                             sizing: bool, _dst: bool) -> Vec<Type> {\n-    let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n-    if sizing {\n-        bug!()\n+// Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n+fn struct_llfields_path(discrfield: &layout::FieldPath) -> Vec<usize> {\n+    discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>()\n+}\n+\n+\n+// Lookup `Struct::memory_index` and double it to account for padding\n+pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n+    (variant.memory_index[index] as usize) << 1\n+}\n+\n+\n+pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty<'tcx>>,\n+                             variant: &layout::Struct) -> Vec<Type> {\n+    debug!(\"struct_llfields: variant: {:?}\", variant);\n+    let mut first_field = true;\n+    let mut min_offset = 0;\n+    let mut result: Vec<Type> = Vec::with_capacity(field_tys.len() * 2);\n+    let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n+        (i, field_tys[i as usize], variant.offsets[i as usize].bytes()) });\n+    for (index, ty, target_offset) in field_iter {\n+        if first_field {\n+            debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n+                index, ty, min_offset, target_offset);\n+            first_field = false;\n+        } else {\n+            assert!(target_offset >= min_offset);\n+            let padding_bytes = if variant.packed { 0 } else { target_offset - min_offset };\n+            result.push(Type::array(&Type::i8(cx), padding_bytes));\n+            debug!(\"struct_llfields: {} ty: {} pad_bytes: {} min_offset: {} target_offset: {}\",\n+                index, ty, padding_bytes, min_offset, target_offset);\n+        }\n+        let llty = type_of::in_memory_type_of(cx, ty);\n+        result.push(llty);\n+        let layout = cx.layout_of(ty);\n+        let target_size = layout.size(&cx.tcx().data_layout).bytes();\n+        min_offset = target_offset + target_size;\n+    }\n+    if variant.sized && !field_tys.is_empty() {\n+        if variant.stride().bytes() < min_offset {\n+            bug!(\"variant: {:?} stride: {} min_offset: {}\", variant, variant.stride().bytes(),\n+            min_offset);\n+        }\n+        let padding_bytes = variant.stride().bytes() - min_offset;\n+        debug!(\"struct_llfields: pad_bytes: {} min_offset: {} min_size: {} stride: {}\\n\",\n+               padding_bytes, min_offset, variant.min_size.bytes(), variant.stride().bytes());\n+        result.push(Type::array(&Type::i8(cx), padding_bytes));\n+        assert!(result.len() == (field_tys.len() * 2));\n     } else {\n-        fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n+        debug!(\"struct_llfields: min_offset: {} min_size: {} stride: {}\\n\",\n+               min_offset, variant.min_size.bytes(), variant.stride().bytes());\n     }\n+\n+    result\n }\n \n pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n@@ -309,8 +350,8 @@ fn struct_wrapped_nullable_bitdiscr(\n     scrutinee: ValueRef,\n     alignment: Alignment,\n ) -> ValueRef {\n-    let llptrptr = bcx.gepi(scrutinee,\n-        &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>());\n+    let path = struct_llfields_path(discrfield);\n+    let llptrptr = bcx.gepi(scrutinee, &path);\n     let llptr = bcx.load(llptrptr, alignment.to_align());\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n@@ -380,7 +421,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {\n-                    let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n+                    let path = struct_llfields_path(discrfield);\n                     let llptrptr = bcx.gepi(val, &path);\n                     let llptrty = val_ty(llptrptr).element_type();\n                     bcx.store(C_null(llptrty), llptrptr, None);"}, {"sha": "5103ca5c5e1094ef94b66bbbe65a497e07f21cd7", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -477,24 +477,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        builder.dynamic_alloca(ty, name)\n+        builder.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n-            if name.is_empty() {\n+            let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n                 let name = CString::new(name).unwrap();\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n+            };\n+            if let Some(align) = align {\n+                llvm::LLVMSetAlignment(alloca, align as c_uint);\n             }\n+            alloca\n         }\n     }\n "}, {"sha": "eb3ac309be16d252353b10468c59927b3dd4d133", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -261,8 +261,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            let tcontents = ty.type_contents(ccx.tcx());\n-            if !tcontents.interior_unsafe() {\n+            if ccx.shared().type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }"}, {"sha": "1d1921bf7b96dd1ee62f1e146ad08cb0507d39a0", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -392,13 +392,17 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     }\n \n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.empty_param_env)\n+        ty.needs_drop(self.tcx, &self.empty_param_env)\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n     }\n \n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_freeze(self.tcx, &self.empty_param_env, DUMMY_SP)\n+    }\n+\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.exported_symbols\n     }"}, {"sha": "54e20f590c6718350bd22c1b4326402202f4cc63", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -778,7 +778,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\");\n+        let slot = bcx.alloca(i64p, \"slot\", None);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n "}, {"sha": "d94d7f4430bf006bfb0ed196e888c24e42e06c8b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -15,6 +15,7 @@ use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n+use adt;\n use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n@@ -177,7 +178,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\");\n+                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\", None);\n                             self.store_operand(&bcx, llscratch, None, op);\n                             llscratch\n                         }\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n+                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n                     self.store_operand(bcx, llscratch, None, op);\n                     (llscratch, Alignment::AbiAligned, true)\n                 } else {\n@@ -642,7 +643,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n+                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n                 base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n                 (llscratch, Alignment::AbiAligned, true)\n             }\n@@ -711,7 +712,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bug!(\"Not a tuple.\");\n                 };\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(llval, v.memory_index[n] as usize);\n+                    let mut elem = bcx.extract_value(\n+                        llval, adt::struct_llfields_index(v, n));\n                     // Truncate bools to i1, if needed\n                     if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n                         elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n@@ -750,7 +752,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.alloca(llretty, \"personalityslot\");\n+            let slot = bcx.alloca(llretty, \"personalityslot\", None);\n             self.llpersonalityslot = Some(slot);\n             slot\n         }"}, {"sha": "88e46b5c99a44186a4a033e4ff630544049555c1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -97,7 +97,8 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n-        let tmp = bcx.alloca(type_of::type_of(bcx.ccx, ty), name);\n+        let tmp = bcx.alloca(\n+            type_of::type_of(bcx.ccx, ty), name, bcx.ccx.over_align_of(ty));\n         assert!(!ty.has_param_types());\n         Self::new_sized_ty(tmp, ty, Alignment::AbiAligned)\n     }\n@@ -131,11 +132,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let alignment = self.alignment | Alignment::from_packed(st.packed);\n \n+        let llfields = adt::struct_llfields(ccx, fields, st);\n         let ptr_val = if needs_cast {\n-            let fields = st.field_index_by_increasing_offset().map(|i| {\n-                type_of::in_memory_type_of(ccx, fields[i])\n-            }).collect::<Vec<_>>();\n-            let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n+            let real_ty = Type::struct_(ccx, &llfields[..], st.packed);\n             bcx.pointercast(self.llval, real_ty.ptr_to())\n         } else {\n             self.llval\n@@ -147,14 +146,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   * Field is sized - pointer is properly aligned already\n         if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n             bcx.ccx.shared().type_is_sized(fty) {\n-                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n+                return (bcx.struct_gep(\n+                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n             }\n \n         // If the type of the last field is [T] or str, then we don't need to do\n         // any adjusments\n         match fty.sty {\n             ty::TySlice(..) | ty::TyStr => {\n-                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n+                return (bcx.struct_gep(\n+                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n             }\n             _ => ()\n         }\n@@ -163,7 +164,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         if !self.has_extra() {\n             debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                 ix, Value(ptr_val));\n-            return (bcx.struct_gep(ptr_val, ix), alignment);\n+            return (bcx.struct_gep(ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n         }\n \n         // We need to get the pointer manually now."}, {"sha": "d39a91405c1854a3cc2a8063e43ef35bcbbc6b4d", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -524,7 +524,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n+                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\", None);\n                 bcx.store(llval, alloc, None);\n                 alloc\n             } else {"}, {"sha": "6889b5064b649a9bf0098566e73503b256bd3943", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -15,6 +15,7 @@ use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n+use adt;\n use base;\n use common::{self, CrateContext, C_null};\n use builder::Builder;\n@@ -134,6 +135,12 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 if common::val_ty(elem) == Type::i1(bcx.ccx) {\n                     elem = bcx.zext(elem, Type::i8(bcx.ccx));\n                 }\n+                let layout = bcx.ccx.layout_of(self.ty);\n+                let i = if let Layout::Univariant { ref variant, .. } = *layout {\n+                    adt::struct_llfields_index(variant, i)\n+                } else {\n+                    i\n+                };\n                 llpair = bcx.insert_value(llpair, elem, i);\n             }\n             self.val = OperandValue::Immediate(llpair);\n@@ -183,14 +190,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             let (lldata, llextra) = base::load_fat_ptr(bcx, llval, align, ty);\n             OperandValue::Pair(lldata, llextra)\n         } else if common::type_is_imm_pair(bcx.ccx, ty) {\n-            let f_align = match *bcx.ccx.layout_of(ty) {\n-                Layout::Univariant { ref variant, .. } =>\n-                    Alignment::from_packed(variant.packed) | align,\n-                _ => align\n+            let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(ty) {\n+                Layout::Univariant { ref variant, .. } => {\n+                    (adt::struct_llfields_index(variant, 0),\n+                    adt::struct_llfields_index(variant, 1),\n+                    Alignment::from_packed(variant.packed) | align)\n+                },\n+                _ => (0, 1, align)\n             };\n             let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n-            let a_ptr = bcx.struct_gep(llval, 0);\n-            let b_ptr = bcx.struct_gep(llval, 1);\n+            let a_ptr = bcx.struct_gep(llval, ix0);\n+            let b_ptr = bcx.struct_gep(llval, ix1);\n \n             OperandValue::Pair(\n                 base::load_ty(bcx, a_ptr, f_align, a_ty),\n@@ -302,17 +312,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx.store(base::from_immediate(bcx, s), lldest, align);\n             }\n             OperandValue::Pair(a, b) => {\n-                let f_align = match *bcx.ccx.layout_of(operand.ty) {\n-                    Layout::Univariant { ref variant, .. } if variant.packed => {\n-                        Some(1)\n+                let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(operand.ty) {\n+                    Layout::Univariant { ref variant, .. } => {\n+                        (adt::struct_llfields_index(variant, 0),\n+                        adt::struct_llfields_index(variant, 1),\n+                        if variant.packed { Some(1) } else { None })\n                     }\n-                    _ => align\n+                    _ => (0, 1, align)\n                 };\n \n                 let a = base::from_immediate(bcx, a);\n                 let b = base::from_immediate(bcx, b);\n-                bcx.store(a, bcx.struct_gep(lldest, 0), f_align);\n-                bcx.store(b, bcx.struct_gep(lldest, 1), f_align);\n+                bcx.store(a, bcx.struct_gep(lldest, ix0), f_align);\n+                bcx.store(b, bcx.struct_gep(lldest, ix1), f_align);\n             }\n         }\n     }"}, {"sha": "de1c1e492f39b78b647873fe7bbe19e2d588a1c0", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -130,10 +130,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n                         let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n-                        let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n-                            Some(&variant.memory_index)\n-                        } else {\n-                            None\n+                        let get_memory_index = |i| {\n+                            if let Layout::Univariant { ref variant, .. } = *layout {\n+                                adt::struct_llfields_index(variant, i)\n+                            } else {\n+                                i\n+                            }\n                         };\n                         let alignment = dest.alignment;\n                         for (i, operand) in operands.iter().enumerate() {\n@@ -143,11 +145,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // Note: perhaps this should be StructGep, but\n                                 // note that in some cases the values here will\n                                 // not be structs but arrays.\n-                                let i = if let Some(ref t) = translation {\n-                                    t[i] as usize\n-                                } else {\n-                                    i\n-                                };\n+                                let i = get_memory_index(i);\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, alignment.to_align(), op);\n                             }"}, {"sha": "9f9126ba83a8f19fd59b8f66b5196d3c3982dbb1", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -214,6 +214,16 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n         self.layout_of(ty).size(self).bytes() as machine::llsize\n     }\n+\n+    pub fn over_align_of(&self, t: Ty<'tcx>)\n+                              -> Option<machine::llalign> {\n+        let layout = self.layout_of(t);\n+        if let Some(align) = layout.over_align(&self.tcx().data_layout) {\n+            Some(align as machine::llalign)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {"}, {"sha": "d21b5f739bd7b5510712cc7eac3c43c44cfdf034", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -78,6 +78,7 @@ use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n use syntax::ptr::P;\n+use syntax_pos;\n \n use std::collections::VecDeque;\n use std::ops::Deref;\n@@ -722,6 +723,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(target)\n     }\n \n+    /// Same as `try_coerce()`, but without side-effects.\n+    pub fn can_coerce(&self, expr_ty: Ty<'tcx>, target: Ty<'tcx>) -> bool {\n+        let source = self.resolve_type_vars_with_obligations(expr_ty);\n+        debug!(\"coercion::can({:?} -> {:?})\", source, target);\n+\n+        let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n+        let coerce = Coerce::new(self, cause);\n+        self.probe(|_| coerce.coerce::<hir::Expr>(&[], source, target)).is_ok()\n+    }\n+\n     /// Given some expressions, their known unified type and another expression,\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\")."}, {"sha": "4cc3f2dacdfe996a77e4fc4c641595ce49109871", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -10,15 +10,14 @@\n \n \n use check::FnCtxt;\n-use rustc::ty::Ty;\n-use rustc::infer::{InferOk};\n+use rustc::infer::InferOk;\n use rustc::traits::ObligationCause;\n \n use syntax::ast;\n use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::ty::{self, AssociatedItem};\n+use rustc::ty::{self, Ty, AssociatedItem};\n use errors::DiagnosticBuilder;\n \n use super::method::probe;\n@@ -80,18 +79,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            let mode = probe::Mode::MethodCall;\n-            let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n-                                                         mode,\n-                                                         expected,\n-                                                         checked_ty,\n-                                                         ast::DUMMY_NODE_ID);\n             let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n-            if suggestions.len() > 0 {\n-                err.help(&format!(\"here are some functions which \\\n-                                   might fulfill your needs:\\n{}\",\n-                                  self.get_best_match(&suggestions).join(\"\\n\")));\n-            };\n+            if let Some(suggestion) = self.check_ref(expr,\n+                                                     checked_ty,\n+                                                     expected) {\n+                err.help(&suggestion);\n+            } else {\n+                let mode = probe::Mode::MethodCall;\n+                let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                             mode,\n+                                                             expected,\n+                                                             checked_ty,\n+                                                             ast::DUMMY_NODE_ID);\n+                if suggestions.len() > 0 {\n+                    err.help(&format!(\"here are some functions which \\\n+                                       might fulfill your needs:\\n{}\",\n+                                      self.get_best_match(&suggestions).join(\"\\n\")));\n+                }\n+            }\n             err.emit();\n         }\n     }\n@@ -140,4 +145,60 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// This function is used to determine potential \"simple\" improvements or users' errors and\n+    /// provide them useful help. For example:\n+    ///\n+    /// ```\n+    /// fn some_fn(s: &str) {}\n+    ///\n+    /// let x = \"hey!\".to_owned();\n+    /// some_fn(x); // error\n+    /// ```\n+    ///\n+    /// No need to find every potential function which could make a coercion to transform a\n+    /// `String` into a `&str` since a `&` would do the trick!\n+    ///\n+    /// In addition of this check, it also checks between references mutability state. If the\n+    /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n+    /// `&mut`!\".\n+    fn check_ref(&self,\n+                 expr: &hir::Expr,\n+                 checked_ty: Ty<'tcx>,\n+                 expected: Ty<'tcx>)\n+                 -> Option<String> {\n+        match (&expected.sty, &checked_ty.sty) {\n+            (&ty::TyRef(_, _), &ty::TyRef(_, _)) => None,\n+            (&ty::TyRef(_, mutability), _) => {\n+                // Check if it can work when put into a ref. For example:\n+                //\n+                // ```\n+                // fn bar(x: &mut i32) {}\n+                //\n+                // let x = 0u32;\n+                // bar(&x); // error, expected &mut\n+                // ```\n+                let ref_ty = match mutability.mutbl {\n+                    hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_imm_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                };\n+                if self.can_coerce(ref_ty, expected) {\n+                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        return Some(format!(\"try with `{}{}`\",\n+                                            match mutability.mutbl {\n+                                                hir::Mutability::MutMutable => \"&mut \",\n+                                                hir::Mutability::MutImmutable => \"&\",\n+                                            },\n+                                            &src));\n+                    }\n+                }\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "839af0fa6706cf0250ab7955586fd56903e689e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -953,6 +953,12 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if def.repr.simd() {\n         check_simd(tcx, span, def_id);\n     }\n+\n+    // if struct is packed and not aligned, check fields for alignment.\n+    // Checks for combining packed and align attrs on single struct are done elsewhere.\n+    if tcx.lookup_adt_def(def_id).repr.packed() && tcx.lookup_adt_def(def_id).repr.align == 0 {\n+        check_packed(tcx, span, def_id);\n+    }\n }\n \n fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1371,6 +1377,47 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n     }\n }\n \n+fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    if check_packed_inner(tcx, def_id, &mut Vec::new()) {\n+        struct_span_err!(tcx.sess, sp, E0588,\n+            \"packed struct cannot transitively contain a `[repr(align)]` struct\").emit();\n+    }\n+}\n+\n+fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                def_id: DefId,\n+                                stack: &mut Vec<DefId>) -> bool {\n+    let t = tcx.item_type(def_id);\n+    if stack.contains(&def_id) {\n+        debug!(\"check_packed_inner: {:?} is recursive\", t);\n+        return false;\n+    }\n+    match t.sty {\n+        ty::TyAdt(def, substs) if def.is_struct() => {\n+            if tcx.lookup_adt_def(def.did).repr.align > 0 {\n+                return true;\n+            }\n+            // push struct def_id before checking fields\n+            stack.push(def_id);\n+            for field in &def.struct_variant().fields {\n+                let f = field.ty(tcx, substs);\n+                match f.sty {\n+                    ty::TyAdt(def, _) => {\n+                        if check_packed_inner(tcx, def.did, stack) {\n+                            return true;\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            // only need to pop if not early out\n+            stack.pop();\n+        }\n+        _ => ()\n+    }\n+    false\n+}\n+\n #[allow(trivial_numeric_casts)]\n pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span,"}, {"sha": "c50156fa5f2714107dc73ee9e2572c665763a847", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -4168,5 +4168,6 @@ register_diagnostics! {\n            // but `{}` was found in the type `{}`\n     E0567, // auto traits can not have type parameters\n     E0568, // auto-traits can not have predicates,\n+    E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n }"}, {"sha": "4bf856240f66a8cabd5928e4cd2eb40c6cfbb00d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -492,7 +492,7 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n                     text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer,\n                     data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n+                    _line: libc::size_t) {\n         unsafe {\n             if text.is_null() { return }\n             let block_info = if lang.is_null() {\n@@ -503,11 +503,15 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n                 LangString::parse(s)\n             };\n             if !block_info.rust { return }\n+            let text = (*text).as_bytes();\n             let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n             let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-            let line = tests.get_line() + line;\n+            let text = str::from_utf8(text).unwrap();\n+            let lines = text.lines().map(|l| {\n+                stripped_filtered_line(l).unwrap_or(l)\n+            });\n             let filename = tests.get_filename();\n-            tests.add_old_test(line, filename);\n+            tests.add_old_test(lines.collect::<Vec<&str>>().join(\"\\n\"), filename);\n         }\n     }\n "}, {"sha": "0ca267bb82d2eb1c7a95f1f73b851e024c89d8d9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -27,6 +27,7 @@\n #![feature(staged_api)]\n #![feature(test)]\n #![feature(unicode)]\n+#![feature(vec_remove_item)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "3206b5021075d5f5a5346abd759e5fc39b10296d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::HashMap;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -381,7 +382,7 @@ fn partition_source(s: &str) -> (String, String) {\n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     // to be removed when hoedown will be definitely gone\n-    pub old_tests: Vec<String>,\n+    pub old_tests: HashMap<String, Vec<String>>,\n     names: Vec<String>,\n     cfgs: Vec<String>,\n     libs: SearchPaths,\n@@ -403,7 +404,7 @@ impl Collector {\n                codemap: Option<Rc<CodeMap>>, filename: Option<String>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n-            old_tests: Vec::new(),\n+            old_tests: HashMap::new(),\n             names: Vec::new(),\n             cfgs: cfgs,\n             libs: libs,\n@@ -432,17 +433,39 @@ impl Collector {\n         }\n     }\n \n-    pub fn add_old_test(&mut self, line: usize, filename: String) {\n-        let name = self.generate_name(line, &filename);\n-        self.old_tests.push(name);\n+    // to be removed once hoedown is gone\n+    fn generate_name_beginning(&self, filename: &str) -> String {\n+        if self.use_headers {\n+            if let Some(ref header) = self.current_header {\n+                format!(\"{} - {} (line\", filename, header)\n+            } else {\n+                format!(\"{} - (line\", filename)\n+            }\n+        } else {\n+            format!(\"{} - {} (line\", filename, self.names.join(\"::\"))\n+        }\n+    }\n+\n+    pub fn add_old_test(&mut self, test: String, filename: String) {\n+        let name_beg = self.generate_name_beginning(&filename);\n+        let entry = self.old_tests.entry(name_beg)\n+                                  .or_insert(Vec::new());\n+        entry.push(test.trim().to_owned());\n     }\n \n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n                     line: usize, filename: String) {\n         let name = self.generate_name(line, &filename);\n-        if self.old_tests.iter().find(|&x| x == &name).is_none() {\n+        let name_beg = self.generate_name_beginning(&filename);\n+        let mut found = false;\n+        // to be removed when hoedown is removed\n+        let test = test.trim().to_owned();\n+        if let Some(entry) = self.old_tests.get_mut(&name_beg) {\n+            found = entry.remove_item(&test).is_some();\n+        }\n+        if !found {\n             let _ = writeln!(&mut io::stderr(),\n                              \"WARNING: {} Code block is not currently run as a test, but will in \\\n                               future versions of rustdoc. Please ensure this code block is a \\"}, {"sha": "60ad8fcc54ccd6af6eec6072f78ba811072d4575", "filename": "src/libstd/os/android/raw.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -165,3 +165,66 @@ mod arch {\n     }\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use os::raw::{c_uint, c_long, c_ulong};\n+    use os::unix::raw::{uid_t, gid_t};\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type dev_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type mode_t = u32;\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u32;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    #[derive(Clone)]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub struct stat {\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_dev: dev_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ino: ino_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_nlink: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mode: c_uint,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_uid: uid_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_gid: gid_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_rdev: dev_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_size: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blksize: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blocks: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime_nsec: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime_nsec: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime_nsec: c_ulong,\n+        __unused: [c_long; 3],\n+    }\n+}\n+"}, {"sha": "15bc74a83401096c22d6d7799e24ff9c8e110736", "filename": "src/libstd/path.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1189,8 +1189,13 @@ impl PathBuf {\n     /// If [`self.file_name`] was [`None`], this is equivalent to pushing\n     /// `file_name`.\n     ///\n+    /// Otherwise it is equivalent to calling [`pop`] and then pushing\n+    /// `file_name`. The new path will be a sibling of the original path.\n+    /// (That is, it will have the same parent.)\n+    ///\n     /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`pop`]: struct.PathBuf.html#method.pop\n     ///\n     /// # Examples\n     ///\n@@ -1725,7 +1730,10 @@ impl Path {\n         })\n     }\n \n-    /// Returns the final component of the `Path`, if it is a normal file.\n+    /// Returns the final component of the `Path`, if there is one.\n+    ///\n+    /// If the path is a normal file, this is the file name. If it's the path of a directory, this\n+    /// is the directory name.\n     ///\n     /// Returns [`None`] If the path terminates in `..`.\n     ///\n@@ -1737,10 +1745,12 @@ impl Path {\n     /// use std::path::Path;\n     /// use std::ffi::OsStr;\n     ///\n-    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt\").file_name());\n+    /// assert_eq!(Some(OsStr::new(\"bin\")), Path::new(\"/usr/bin/\").file_name());\n+    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"tmp/foo.txt\").file_name());\n     /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n     /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n     /// assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n+    /// assert_eq!(None, Path::new(\"/\").file_name());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n@@ -1926,6 +1936,9 @@ impl Path {\n     ///\n     /// let path = Path::new(\"/tmp/foo.txt\");\n     /// assert_eq!(path.with_file_name(\"bar.txt\"), PathBuf::from(\"/tmp/bar.txt\"));\n+    ///\n+    /// let path = Path::new(\"/tmp\");\n+    /// assert_eq!(path.with_file_name(\"var\"), PathBuf::from(\"/var\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {"}, {"sha": "4ec9076de61665766314c1e84b586836f6d714d5", "filename": "src/libstd/process.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -73,6 +73,15 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// spawning process and can itself be constructed using a builder-style\n /// interface.\n ///\n+/// There is no implementation of [`Drop`] for child processes,\n+/// so if you do not ensure the `Child` has exited then it will continue to\n+/// run, even after the `Child` handle to the child process has gone out of\n+/// scope.\n+///\n+/// Calling [`wait`](#method.wait) (or other functions that wrap around it) will make\n+/// the parent process wait until the child has actually exited before\n+/// continuing.\n+///\n /// # Examples\n ///\n /// ```should_panic\n@@ -89,17 +98,6 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// assert!(ecode.success());\n /// ```\n ///\n-/// # Note\n-///\n-/// Take note that there is no implementation of [`Drop`] for child processes,\n-/// so if you do not ensure the `Child` has exited then it will continue to\n-/// run, even after the `Child` handle to the child process has gone out of\n-/// scope.\n-///\n-/// Calling [`wait`][`wait`] (or other functions that wrap around it) will make\n-/// the parent process wait until the child has actually exited before\n-/// continuing.\n-///\n /// [`Command`]: struct.Command.html\n /// [`Drop`]: ../../core/ops/trait.Drop.html\n /// [`wait`]: #method.wait"}, {"sha": "82492d976276e05d6ed6d758872c48acc17405ee", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -147,6 +147,24 @@ impl NestedMetaItem {\n         self.meta_item().and_then(|meta_item| meta_item.value_str())\n     }\n \n+    /// Returns a name and single literal value tuple of the MetaItem.\n+    pub fn name_value_literal(&self) -> Option<(Name, &Lit)> {\n+        self.meta_item().and_then(\n+            |meta_item| meta_item.meta_item_list().and_then(\n+                |meta_item_list| {\n+                    if meta_item_list.len() == 1 {\n+                        let nested_item = &meta_item_list[0];\n+                        if nested_item.is_literal() {\n+                            Some((meta_item.name(), nested_item.literal().unwrap()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    else {\n+                        None\n+                    }}))\n+    }\n+\n     /// Returns a MetaItem if self is a MetaItem with Kind Word.\n     pub fn word(&self) -> Option<&MetaItem> {\n         self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n@@ -931,6 +949,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                     continue\n                 }\n \n+                let mut recognised = false;\n                 if let Some(mi) = item.word() {\n                     let word = &*mi.name().as_str();\n                     let hint = match word {\n@@ -941,20 +960,43 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         _ => match int_type_of_word(word) {\n                             Some(ity) => Some(ReprInt(ity)),\n                             None => {\n-                                // Not a word we recognize\n-                                span_err!(diagnostic, item.span, E0552,\n-                                          \"unrecognized representation hint\");\n                                 None\n                             }\n                         }\n                     };\n \n                     if let Some(h) = hint {\n+                        recognised = true;\n                         acc.push(h);\n                     }\n-                } else {\n-                    span_err!(diagnostic, item.span, E0553,\n-                              \"unrecognized enum representation hint\");\n+                } else if let Some((name, value)) = item.name_value_literal() {\n+                    if name == \"align\" {\n+                        recognised = true;\n+                        let mut align_error = None;\n+                        if let ast::LitKind::Int(align, ast::LitIntType::Unsuffixed) = value.node {\n+                            if align.is_power_of_two() {\n+                                // rustc::ty::layout::Align restricts align to <= 32768\n+                                if align <= 32768 {\n+                                    acc.push(ReprAlign(align as u16));\n+                                } else {\n+                                    align_error = Some(\"larger than 32768\");\n+                                }\n+                            } else {\n+                                align_error = Some(\"not a power of two\");\n+                            }\n+                        } else {\n+                            align_error = Some(\"not an unsuffixed integer\");\n+                        }\n+                        if let Some(align_error) = align_error {\n+                            span_err!(diagnostic, item.span, E0589,\n+                                      \"invalid `repr(align)` attribute: {}\", align_error);\n+                        }\n+                    }\n+                }\n+                if !recognised {\n+                    // Not a word we recognize\n+                    span_err!(diagnostic, item.span, E0552,\n+                              \"unrecognized representation hint\");\n                 }\n             }\n         }\n@@ -986,6 +1028,7 @@ pub enum ReprAttr {\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n+    ReprAlign(u16),\n }\n \n #[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]"}, {"sha": "01d1277ea6265014c018401a8854033db84931fa", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -287,10 +287,10 @@ register_diagnostics! {\n     E0550, // multiple deprecated attributes\n     E0551, // incorrect meta item\n     E0552, // unrecognized representation hint\n-    E0553, // unrecognized enum representation hint\n     E0554, // #[feature] may not be used on the [] release channel\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0557, // feature has been removed\n     E0584, // file for module `..` found at both .. and ..\n+    E0589, // invalid `repr(align)` attribute\n }"}, {"sha": "842398ea02b9e132f5b4445c2bce05f8797a031d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -205,6 +205,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         module.directory.pop();\n         self.cx.current_expansion.module = Rc::new(module);\n \n+        let orig_mod_span = krate.module.inner;\n+\n         let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n@@ -214,11 +216,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             vis: ast::Visibility::Public,\n         })));\n \n-        match self.expand(krate_item).make_items().pop().unwrap().unwrap() {\n-            ast::Item { attrs, node: ast::ItemKind::Mod(module), .. } => {\n+        match self.expand(krate_item).make_items().pop().map(P::unwrap) {\n+            Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n             },\n+            None => {\n+                // Resolution failed so we return an empty expansion\n+                krate.attrs = vec![];\n+                krate.module = ast::Mod {\n+                    inner: orig_mod_span,\n+                    items: vec![],\n+                };\n+            },\n             _ => unreachable!(),\n         };\n "}, {"sha": "fa0e45194dcb4e93f33962a379fd5f70cc171abf", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -335,6 +335,9 @@ declare_features! (\n     // Allows the `catch {...}` expression\n     (active, catch_expr, \"1.17.0\", Some(31436)),\n \n+    // Allows `repr(align(u16))` struct attribute (RFC 1358)\n+    (active, repr_align, \"1.17.0\", Some(33626)),\n+\n     // See rust-lang/rfcs#1414. Allows code like `let x: &'static u32 = &42` to work.\n     (active, rvalue_static_promotion, \"1.15.1\", Some(38865)),\n \n@@ -1185,6 +1188,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                                     and possibly buggy\");\n \n                             }\n+                            if item.check_name(\"align\") {\n+                                gate_feature_post!(&self, repr_align, i.span,\n+                                                   \"the struct `#[repr(align(u16))]` attribute \\\n+                                                    is experimental\");\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "dc9b22c37e28b5c14a32c1a5d58b5eff5f176bb2", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -128,9 +128,9 @@ error: foo\n  --> test.rs:2:10\n   |\n 2 |   fn foo() {\n-  |  __________^ starting here...\n+  |  __________^\n 3 | | }\n-  | |_^ ...ending here: test\n+  | |_^ test\n \n \"#);\n }\n@@ -161,11 +161,11 @@ error: foo\n  --> test.rs:2:10\n   |\n 2 |   fn foo() {\n-  |  __________^ starting here...\n+  |  __________^\n 3 | |\n 4 | |\n 5 | |   }\n-  | |___^ ...ending here: test\n+  | |___^ test\n \n \"#);\n }\n@@ -207,14 +207,14 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |      X0 Y0\n-  |  ____^__- starting here...\n+  |  ____^__-\n   | | ___|\n-  | ||   starting here...\n+  | ||\n 4 | ||   X1 Y1\n 5 | ||   X2 Y2\n-  | ||____^__- ...ending here: `Y` is a good letter too\n+  | ||____^__- `Y` is a good letter too\n   |  |____|\n-  |       ...ending here: `X` is a good letter\n+  |       `X` is a good letter\n \n \"#);\n }\n@@ -256,13 +256,13 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |      X0 Y0\n-  |  ____^__- starting here...\n+  |  ____^__-\n   | | ___|\n-  | ||   starting here...\n+  | ||\n 4 | ||   Y1 X1\n-  | ||____-__^ ...ending here: `X` is a good letter\n+  | ||____-__^ `X` is a good letter\n   | |_____|\n-  |       ...ending here: `Y` is a good letter too\n+  |       `Y` is a good letter too\n \n \"#);\n }\n@@ -306,13 +306,13 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^ starting here...\n+  |   ______^\n 4 |  |   X1 Y1 Z1\n-  |  |_________- starting here...\n+  |  |_________-\n 5 | ||   X2 Y2 Z2\n-  | ||____^ ...ending here: `X` is a good letter\n+  | ||____^ `X` is a good letter\n 6 | |    X3 Y3 Z3\n-  | |_____- ...ending here: `Y` is a good letter too\n+  | |_____- `Y` is a good letter too\n \n \"#);\n }\n@@ -366,16 +366,16 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |       X0 Y0 Z0\n-  |  _____^__-__- starting here...\n+  |  _____^__-__-\n   | | ____|__|\n-  | || ___|  starting here...\n-  | |||   starting here...\n+  | || ___|\n+  | |||\n 4 | |||   X1 Y1 Z1\n 5 | |||   X2 Y2 Z2\n-  | |||____^__-__- ...ending here: `Z` label\n+  | |||____^__-__- `Z` label\n   |  ||____|__|\n-  |   |____|  ...ending here: `Y` is a good letter too\n-  |        ...ending here: `X` is a good letter\n+  |   |____|  `Y` is a good letter too\n+  |        `X` is a good letter\n \n \"#);\n }\n@@ -430,17 +430,17 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^ starting here...\n+  |   ______^\n 4 |  |   X1 Y1 Z1\n-  |  |____^_- starting here...\n+  |  |____^_-\n   | ||____|\n-  | |     ...ending here: `X` is a good letter\n+  | |     `X` is a good letter\n 5 | |    X2 Y2 Z2\n-  | |____-______- ...ending here: `Y` is a good letter too\n+  | |____-______- `Y` is a good letter too\n   |  ____|\n-  | |    starting here...\n+  | |\n 6 | |    X3 Y3 Z3\n-  | |________- ...ending here: `Z`\n+  | |________- `Z`\n \n \"#);\n }\n@@ -458,7 +458,7 @@ fn foo() {\n     vec![\n         SpanLabel {\n             start: Position {\n-                string: \"Y0\",\n+                string: \"X0\",\n                 count: 1,\n             },\n             end: Position {\n@@ -481,16 +481,15 @@ fn foo() {\n     ],\n     r#\"\n error: foo\n- --> test.rs:3:6\n+ --> test.rs:3:3\n   |\n-3 |     X0 Y0 Z0\n-  |  ______^ starting here...\n+3 | /   X0 Y0 Z0\n 4 | |   X1 Y1 Z1\n-  | |____^ ...ending here: `X` is a good letter\n+  | |____^ `X` is a good letter\n 5 |     X2 Y2 Z2\n-  |  ______- starting here...\n+  |  ______-\n 6 | |   X3 Y3 Z3\n-  | |__________- ...ending here: `Y` is a good letter too\n+  | |__________- `Y` is a good letter too\n \n \"#);\n }\n@@ -534,14 +533,14 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^ starting here...\n+  |   ______^\n 4 |  |   X1 Y1 Z1\n-  |  |____^____- starting here...\n+  |  |____^____-\n   | ||____|\n-  | |     ...ending here: `X` is a good letter\n+  | |     `X` is a good letter\n 5 | |    X2 Y2 Z2\n 6 | |    X3 Y3 Z3\n-  | |___________- ...ending here: `Y` is a good letter too\n+  | |___________- `Y` is a good letter too\n \n \"#);\n }\n@@ -982,18 +981,18 @@ error: foo\n   --> test.rs:3:6\n    |\n 3  |      X0 Y0 Z0\n-   |   ______^ starting here...\n+   |   ______^\n 4  |  |   X1 Y1 Z1\n-   |  |____^____- starting here...\n+   |  |____^____-\n    | ||____|\n-   | |     ...ending here: `X` is a good letter\n+   | |     `X` is a good letter\n 5  | |  1\n 6  | |  2\n 7  | |  3\n ...  |\n 15 | |    X2 Y2 Z2\n 16 | |    X3 Y3 Z3\n-   | |___________- ...ending here: `Y` is a good letter too\n+   | |___________- `Y` is a good letter too\n \n \"#);\n }\n@@ -1047,21 +1046,21 @@ error: foo\n   --> test.rs:3:6\n    |\n 3  |      X0 Y0 Z0\n-   |   ______^ starting here...\n+   |   ______^\n 4  |  | 1\n 5  |  | 2\n 6  |  | 3\n 7  |  |   X1 Y1 Z1\n-   |  |_________- starting here...\n+   |  |_________-\n 8  | || 4\n 9  | || 5\n 10 | || 6\n 11 | ||   X2 Y2 Z2\n-   | ||__________- ...ending here: `Z` is a good letter too\n+   | ||__________- `Z` is a good letter too\n ...   |\n 15 |  | 10\n 16 |  |   X3 Y3 Z3\n-   |  |_______^ ...ending here: `Y` is a good letter\n+   |  |_______^ `Y` is a good letter\n \n \"#);\n }"}, {"sha": "e96883c26f33a1c854996e89ecbdc39d1cb78655", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -773,7 +773,7 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprPacked | attr::ReprSimd => continue,\n+                attr::ReprPacked | attr::ReprSimd | attr::ReprAlign(_) => continue,\n                 attr::ReprExtern => \"i32\",\n \n                 attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\","}, {"sha": "e8b92aab1da1e556f2518b9f7aac050ace6cd928", "filename": "src/rtstartup/rsbegin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -22,7 +22,7 @@\n // object (usually called `crtX.o), which then invokes initialization callbacks\n // of other runtime components (registered via yet another special image section).\n \n-#![feature(no_core, lang_items)]\n+#![feature(no_core, lang_items, optin_builtin_traits)]\n #![crate_type=\"rlib\"]\n #![no_core]\n #![allow(non_camel_case_types)]\n@@ -31,9 +31,12 @@\n trait Sized {}\n #[lang = \"sync\"]\n trait Sync {}\n+impl Sync for .. {}\n #[lang = \"copy\"]\n trait Copy {}\n-impl<T> Sync for T {}\n+#[cfg_attr(not(stage0), lang = \"freeze\")]\n+trait Freeze {}\n+impl Freeze for .. {}\n \n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n pub mod eh_frames {"}, {"sha": "99400bd147c201e2cc5f12c368e24c4fdecae505", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/issue-41211.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn emit_unchanged(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "17237912be49bd8844aa832a6f8aa1d776e012ca", "filename": "src/test/compile-fail-fulldeps/proc-macro/issue-41211.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-41211.rs\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/41430\n+// This is a temporary regression test for the ICE reported in #41211\n+\n+#![feature(proc_macro)]\n+#![emit_unchanged]\n+//~^ ERROR: cannot find attribute macro `emit_unchanged` in this scope\n+extern crate issue_41211;\n+use issue_41211::emit_unchanged;\n+\n+fn main() {}"}, {"sha": "c0bfd3690c8598fd3b5989aaea5102f6afcca4c8", "filename": "src/test/compile-fail/attr-usage-repr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n+#![feature(attr_literals)]\n #![feature(repr_simd)]\n \n #[repr(C)] //~ ERROR: attribute should be applied to struct, enum or union\n@@ -29,6 +30,9 @@ struct SInt(f64, f64);\n #[repr(C)]\n enum EExtern { A, B }\n \n+#[repr(align(8))] //~ ERROR: attribute should be applied to struct\n+enum EAlign { A, B }\n+\n #[repr(packed)] //~ ERROR: attribute should be applied to struct\n enum EPacked { A, B }\n "}, {"sha": "7c5a4e0c3c6f644467c7117cbdc8da80dcfd1d61", "filename": "src/test/compile-fail/coercion-slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -14,6 +14,5 @@ fn main() {\n     let _: &[i32] = [0];\n     //~^ ERROR mismatched types\n     //~| expected type `&[i32]`\n-    //~| found type `[{integer}; 1]`\n     //~| expected &[i32], found array of 1 elements\n }"}, {"sha": "01fa3ffbaa6ae7a82a9f9644ccba0209b4ee4f77", "filename": "src/test/compile-fail/conflicting-repr-hints.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n #![allow(dead_code)]\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n \n #[repr(C)]\n enum A { A }\n@@ -26,5 +27,7 @@ enum D { D }\n #[repr(C, packed)]\n struct E(i32);\n \n-#[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+#[repr(packed, align(8))] //~ ERROR conflicting packed and align representation hints\n+struct F(i32);\n+\n+fn main() {}"}, {"sha": "847a82c082651f1a4550cc7bfc34aefa873f2fa3", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -17,7 +17,7 @@ impl Trait for Foo {}\n \n pub fn main() {\n     let x: Box<Trait> = Box::new(Foo);\n-    let _y: &Trait = x; //~  ERROR mismatched types\n+    let _y: &Trait = x; //~ ERROR E0308\n                         //~| expected type `&Trait`\n                         //~| found type `std::boxed::Box<Trait>`\n }"}, {"sha": "8e986e197f2694d9113949cac7046f6117c5d880", "filename": "src/test/compile-fail/feature-gate-repr_align.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr_align.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+\n+#[repr(align(64))]\n+struct Foo(u64, u64); //~ error: the struct `#[repr(align(u16))]` attribute is experimental\n+\n+fn main() {}"}, {"sha": "1e444a6bebf9b23b573465a7090f60b174d52fa3", "filename": "src/test/compile-fail/issue-11374.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -33,5 +33,5 @@ pub fn for_stdin<'a>() -> Container<'a> {\n fn main() {\n     let mut c = for_stdin();\n     let mut v = Vec::new();\n-    c.read_to(v); //~ ERROR mismatched types\n+    c.read_to(v); //~ ERROR E0308\n }"}, {"sha": "ed1634441498be40d5a05f98c51f2c5b8019a02c", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -35,4 +35,5 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n fn main() {\n     check((3, 5));\n //~^ ERROR mismatched types\n+//~| HELP try with `&(3, 5)`\n }"}, {"sha": "eb0b27fe9c07ed5307a658e87da2fda19cc630bb", "filename": "src/test/compile-fail/repr-align.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Frepr-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Frepr-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-align.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(dead_code)]\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+\n+#[repr(align(16.0))] //~ ERROR: invalid `repr(align)` attribute: not an unsuffixed integer\n+struct A(i32);\n+\n+#[repr(align(15))] //~ ERROR: invalid `repr(align)` attribute: not a power of two\n+struct B(i32);\n+\n+#[repr(align(65536))] //~ ERROR: invalid `repr(align)` attribute: larger than 32768\n+struct C(i32);\n+\n+fn main() {}"}, {"sha": "c584dcf3e5993eacd8eeeb083f53d5a88d2386c4", "filename": "src/test/compile-fail/repr-packed-contains-align.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+#![allow(dead_code)]\n+\n+#[repr(align(16))]\n+struct A(i32);\n+\n+struct B(A);\n+\n+#[repr(packed)]\n+struct C(A); //~ ERROR: packed struct cannot transitively contain a `[repr(align)]` struct\n+\n+#[repr(packed)]\n+struct D(B); //~ ERROR: packed struct cannot transitively contain a `[repr(align)]` struct\n+\n+fn main() {}"}, {"sha": "8ab8f4715755ddbef149777ab726c29d023afe0f", "filename": "src/test/run-make/simd-ffi/simd.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -12,7 +12,7 @@\n #![crate_type = \"lib\"]\n // we can compile to a variety of platforms, because we don't need\n // cross-compiled standard libraries.\n-#![feature(no_core)]\n+#![feature(no_core, optin_builtin_traits)]\n #![no_core]\n \n #![feature(repr_simd, simd_ffi, link_llvm_intrinsics, lang_items)]\n@@ -78,3 +78,7 @@ pub trait Copy { }\n pub mod marker {\n     pub use Copy;\n }\n+\n+#[lang = \"freeze\"]\n+trait Freeze {}\n+impl Freeze for .. {}"}, {"sha": "af24c3b460b2e844d43123eb9aaf9f6725967996", "filename": "src/test/run-make/target-specs/foo.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, no_core)]\n+#![feature(lang_items, no_core, optin_builtin_traits)]\n #![no_core]\n \n #[lang=\"copy\"]\n@@ -17,6 +17,10 @@ trait Copy { }\n #[lang=\"sized\"]\n trait Sized { }\n \n+#[lang = \"freeze\"]\n+trait Freeze {}\n+impl Freeze for .. {}\n+\n #[lang=\"start\"]\n fn start(_main: *const u8, _argc: isize, _argv: *const *const u8) -> isize { 0 }\n "}, {"sha": "0b9a3594502b00bc0dcbaa04f9672a6a0e6ecffb", "filename": "src/test/run-pass/align-struct.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frun-pass%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frun-pass%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-struct.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,196 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+\n+use std::mem;\n+\n+// Raising alignment\n+#[repr(align(16))]\n+struct Align16(i32);\n+\n+// Lowering has no effect\n+#[repr(align(1))]\n+struct Align1(i32);\n+\n+// Multiple attributes take the max\n+#[repr(align(4))]\n+#[repr(align(16))]\n+#[repr(align(8))]\n+struct AlignMany(i32);\n+\n+// Raising alignment may not alter size.\n+#[repr(align(8))]\n+#[allow(dead_code)]\n+struct Align8Many {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: u8,\n+}\n+\n+enum Enum {\n+    #[allow(dead_code)]\n+    A(i32),\n+    B(Align16)\n+}\n+\n+// Nested alignment - use `#[repr(C)]` to suppress field reordering for sizeof test\n+#[repr(C)]\n+struct Nested {\n+    a: i32,\n+    b: i32,\n+    c: Align16,\n+    d: i8,\n+}\n+\n+#[repr(packed)]\n+struct Packed(i32);\n+\n+#[repr(align(16))]\n+struct AlignContainsPacked {\n+    a: Packed,\n+    b: Packed,\n+}\n+\n+impl Align16 {\n+    // return aligned type\n+    pub fn new(i: i32) -> Align16 {\n+        Align16(i)\n+    }\n+    // pass aligned type\n+    pub fn consume(a: Align16) -> i32 {\n+        a.0\n+    }\n+}\n+\n+const CONST_ALIGN16: Align16 = Align16(7);\n+static STATIC_ALIGN16: Align16 = Align16(8);\n+\n+// Check the actual address is aligned\n+fn is_aligned_to<T>(p: &T, align: usize) -> bool {\n+    let addr = p as *const T as usize;\n+    (addr & (align - 1)) == 0\n+}\n+\n+pub fn main() {\n+    // check alignment and size by type and value\n+    assert_eq!(mem::align_of::<Align16>(), 16);\n+    assert_eq!(mem::size_of::<Align16>(), 16);\n+\n+    let a = Align16(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // lowering should have no effect\n+    assert_eq!(mem::align_of::<Align1>(), 4);\n+    assert_eq!(mem::size_of::<Align1>(), 4);\n+    let a = Align1(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 4);\n+    assert_eq!(mem::size_of_val(&a), 4);\n+    assert!(is_aligned_to(&a, 4));\n+\n+    // when multiple attributes are specified the max should be used\n+    assert_eq!(mem::align_of::<AlignMany>(), 16);\n+    assert_eq!(mem::size_of::<AlignMany>(), 16);\n+    let a = AlignMany(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // raising alignment should not reduce size\n+    assert_eq!(mem::align_of::<Align8Many>(), 8);\n+    assert_eq!(mem::size_of::<Align8Many>(), 16);\n+    let a = Align8Many { a: 1, b: 2, c: 3, d: 4 };\n+    assert_eq!(a.a, 1);\n+    assert_eq!(mem::align_of_val(&a), 8);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 8));\n+\n+    // return type\n+    let a = Align16::new(1);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert_eq!(a.0, 1);\n+    assert!(is_aligned_to(&a, 16));\n+    assert_eq!(Align16::consume(a), 1);\n+\n+    // check const alignment, size and value\n+    assert_eq!(mem::align_of_val(&CONST_ALIGN16), 16);\n+    assert_eq!(mem::size_of_val(&CONST_ALIGN16), 16);\n+    assert_eq!(CONST_ALIGN16.0, 7);\n+    assert!(is_aligned_to(&CONST_ALIGN16, 16));\n+\n+    // check global static alignment, size and value\n+    assert_eq!(mem::align_of_val(&STATIC_ALIGN16), 16);\n+    assert_eq!(mem::size_of_val(&STATIC_ALIGN16), 16);\n+    assert_eq!(STATIC_ALIGN16.0, 8);\n+    assert!(is_aligned_to(&STATIC_ALIGN16, 16));\n+\n+    // Note that the size of Nested may change if struct field re-ordering is enabled\n+    assert_eq!(mem::align_of::<Nested>(), 16);\n+    assert_eq!(mem::size_of::<Nested>(), 48);\n+    let a = Nested{ a: 1, b: 2, c: Align16(3), d: 4};\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.b), 4);\n+    assert_eq!(mem::align_of_val(&a.c), 16);\n+    assert_eq!(mem::size_of_val(&a), 48);\n+    assert!(is_aligned_to(&a, 16));\n+    // check the correct fields are indexed\n+    assert_eq!(a.a, 1);\n+    assert_eq!(a.b, 2);\n+    assert_eq!(a.c.0, 3);\n+    assert_eq!(a.d, 4);\n+\n+    // enum should be aligned to max alignment\n+    assert_eq!(mem::align_of::<Enum>(), 16);\n+    assert_eq!(mem::align_of_val(&Enum::B(Align16(0))), 16);\n+    let e = Enum::B(Align16(15));\n+    match e {\n+        Enum::B(ref a) => {\n+            assert_eq!(a.0, 15);\n+            assert_eq!(mem::align_of_val(a), 16);\n+            assert_eq!(mem::size_of_val(a), 16);\n+        },\n+        _ => ()\n+    }\n+    assert!(is_aligned_to(&e, 16));\n+\n+    // arrays of aligned elements should also be aligned\n+    assert_eq!(mem::align_of::<[Align16;2]>(), 16);\n+    assert_eq!(mem::size_of::<[Align16;2]>(), 32);\n+\n+    let a = [Align16(0), Align16(1)];\n+    assert_eq!(mem::align_of_val(&a[0]), 16);\n+    assert_eq!(mem::align_of_val(&a[1]), 16);\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // check heap value is aligned\n+    assert_eq!(mem::align_of_val(Box::new(Align16(0)).as_ref()), 16);\n+\n+    // check heap array is aligned\n+    let a = vec!(Align16(0), Align16(1));\n+    assert_eq!(mem::align_of_val(&a[0]), 16);\n+    assert_eq!(mem::align_of_val(&a[1]), 16);\n+\n+    assert_eq!(mem::align_of::<AlignContainsPacked>(), 16);\n+    assert_eq!(mem::size_of::<AlignContainsPacked>(), 16);\n+    let a = AlignContainsPacked { a: Packed(1), b: Packed(2) };\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.a), 1);\n+    assert_eq!(mem::align_of_val(&a.b), 1);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 16));\n+}"}, {"sha": "af974d501839b35cb76d8ac7c746c244e25d4b6a", "filename": "src/test/ui/compare-method/region-extra-2.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -4,12 +4,11 @@ error[E0276]: impl has stricter requirements than trait\n 15 |       fn renew<'b: 'a>(self) -> &'b mut [T];\n    |       -------------------------------------- definition of `renew` from trait\n ...\n-19 |       fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n-   |  _____^ starting here...\n+19 | /     fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n 20 | |         //~^ ERROR E0276\n 21 | |         &mut self[..]\n 22 | |     }\n-   | |_____^ ...ending here: impl has extra requirement `'a: 'b`\n+   | |_____^ impl has extra requirement `'a: 'b`\n \n error: aborting due to previous error\n "}, {"sha": "622e144c53a040447103654b7fb552c79d68c5b0", "filename": "src/test/ui/compare-method/traits-misc-mismatch-2.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -4,12 +4,11 @@ error[E0276]: impl has stricter requirements than trait\n 19 |       fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n    |       ------------------------------------------------------------------ definition of `zip` from trait\n ...\n-23 |       fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n-   |  _____^ starting here...\n+23 | /     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n 24 | |     //~^ ERROR E0276\n 25 | |         ZipIterator{a: self, b: other}\n 26 | |     }\n-   | |_____^ ...ending here: impl has extra requirement `U: Iterator<B>`\n+   | |_____^ impl has extra requirement `U: Iterator<B>`\n \n error: aborting due to previous error\n "}, {"sha": "8e8773eba3e222feb5c31bbe4f2029a69ef5df5d", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -2,17 +2,17 @@ error: missing `fn`, `type`, or `const` for impl-item declaration\n   --> $DIR/issue-40006.rs:11:9\n    |\n 11 |   impl X {\n-   |  _________^ starting here...\n+   |  _________^\n 12 | |     Y\n-   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: missing `fn`, `type`, or `const` for trait-item declaration\n   --> $DIR/issue-40006.rs:17:10\n    |\n 17 |   trait X {\n-   |  __________^ starting here...\n+   |  __________^\n 18 | |     X() {}\n-   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: expected `[`, found `#`\n   --> $DIR/issue-40006.rs:19:17\n@@ -24,17 +24,17 @@ error: missing `fn`, `type`, or `const` for trait-item declaration\n   --> $DIR/issue-40006.rs:19:21\n    |\n 19 |       fn xxx() { ### }\n-   |  _____________________^ starting here...\n+   |  _____________________^\n 20 | |     L = M;\n-   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: missing `fn`, `type`, or `const` for trait-item declaration\n   --> $DIR/issue-40006.rs:20:11\n    |\n 20 |       L = M;\n-   |  ___________^ starting here...\n+   |  ___________^\n 21 | |     Z = { 2 + 3 };\n-   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `;`\n   --> $DIR/issue-40006.rs:21:18"}, {"sha": "2c788e952edbfd455b29645f875bdded8cf4eedd", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,26 +1,24 @@\n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:32:1\n    |\n-32 |   impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n-   |  _^ starting here...\n+32 | / impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n 33 | |     //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n 34 | |\n 35 | |     // (unsafe to access self.1  due to #[may_dangle] on A)\n 36 | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n 37 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:38:1\n    |\n-38 |   impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n-   |  _^ starting here...\n+38 | / impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n 39 | |     //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n 40 | |\n 41 | |     // (unsafe to access self.1 due to #[may_dangle] on 'a)\n 42 | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n 43 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b51b683a1ac3a5de798a8e3feaea1d315159574d", "filename": "src/test/ui/issue-37311-type-length-limit/issue-37311.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-37311-type-length-limit%2Fissue-37311.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,11 +1,10 @@\n error: reached the type-length limit while instantiating `<T as Foo><(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(), &()), &(&()...`\n   --> $DIR/issue-37311.rs:23:5\n    |\n-23 |       fn recurse(&self) {\n-   |  _____^ starting here...\n+23 | /     fn recurse(&self) {\n 24 | |         (self, self).recurse();\n 25 | |     }\n-   | |_____^ ...ending here\n+   | |_____^\n    |\n    = note: consider adding a `#![type_length_limit=\"2097152\"]` attribute to your crate\n "}, {"sha": "cf272b63128e8a104f366212646ecac2af4cb3f1", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,18 +8,18 @@ note: ...the reference is valid for the lifetime 'a as defined on the body at 11\n   --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n    |\n 11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-   |  ____________________________________________^ starting here...\n+   |  ____________________________________________^\n 12 | |     if x > y { x } else { y }\n 13 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the body at 11:43\n   --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n    |\n 11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-   |  ____________________________________________^ starting here...\n+   |  ____________________________________________^\n 12 | |     if x > y { x } else { y }\n 13 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "6e03e66dd258f18c017e63f504d9d13ca13d006e", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -10,18 +10,18 @@ note: the anonymous lifetime #2 defined on the body at 15:51...\n   --> $DIR/ex2a-push-one-existing-name.rs:15:52\n    |\n 15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-   |  ____________________________________________________^ starting here...\n+   |  ____________________________________________________^\n 16 | |     x.push(y);\n 17 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...does not necessarily outlive the lifetime 'a as defined on the body at 15:51\n   --> $DIR/ex2a-push-one-existing-name.rs:15:52\n    |\n 15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-   |  ____________________________________________________^ starting here...\n+   |  ____________________________________________________^\n 16 | |     x.push(y);\n 17 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "028f54ce97871d98251e85a182af34ec3a441428", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -10,18 +10,18 @@ note: the anonymous lifetime #3 defined on the body at 15:43...\n   --> $DIR/ex2b-push-no-existing-names.rs:15:44\n    |\n 15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-   |  ____________________________________________^ starting here...\n+   |  ____________________________________________^\n 16 | |     x.push(y);\n 17 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 15:43\n   --> $DIR/ex2b-push-no-existing-names.rs:15:44\n    |\n 15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-   |  ____________________________________________^ starting here...\n+   |  ____________________________________________^\n 16 | |     x.push(y);\n 17 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "4621214419e42c157666ddd4e72e9af0aa7f7aab", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,11 +8,11 @@ note: first, the lifetime cannot outlive the lifetime 'c as defined on the body\n   --> $DIR/ex2c-push-inference-variable.rs:15:67\n    |\n 15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^ starting here...\n+   |  ___________________________________________________________________^\n 16 | |     let z = Ref { data: y.data };\n 17 | |     x.push(z);\n 18 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...so that reference does not outlive borrowed content\n   --> $DIR/ex2c-push-inference-variable.rs:16:25\n    |\n@@ -22,11 +22,11 @@ note: but, the lifetime must be valid for the lifetime 'b as defined on the body\n   --> $DIR/ex2c-push-inference-variable.rs:15:67\n    |\n 15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^ starting here...\n+   |  ___________________________________________________________________^\n 16 | |     let z = Ref { data: y.data };\n 17 | |     x.push(z);\n 18 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...so that expression is assignable (expected Ref<'b, _>, found Ref<'_, _>)\n   --> $DIR/ex2c-push-inference-variable.rs:17:12\n    |"}, {"sha": "a69694fdc2e5bb7cdbde99f8b763724fd3fa4baf", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,12 +8,12 @@ note: first, the lifetime cannot outlive the lifetime 'c as defined on the body\n   --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n    |\n 15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^ starting here...\n+   |  ___________________________________________________________________^\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     a.push(b);\n 19 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...so that reference does not outlive borrowed content\n   --> $DIR/ex2d-push-inference-variable-2.rs:17:25\n    |\n@@ -23,12 +23,12 @@ note: but, the lifetime must be valid for the lifetime 'b as defined on the body\n   --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n    |\n 15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^ starting here...\n+   |  ___________________________________________________________________^\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     a.push(b);\n 19 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n   --> $DIR/ex2d-push-inference-variable-2.rs:16:33\n    |"}, {"sha": "eff15bb794b76a8f602b3afdca71fffea5713f43", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -8,12 +8,12 @@ note: first, the lifetime cannot outlive the lifetime 'c as defined on the body\n   --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n    |\n 15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^ starting here...\n+   |  ___________________________________________________________________^\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     Vec::push(a, b);\n 19 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...so that reference does not outlive borrowed content\n   --> $DIR/ex2e-push-inference-variable-3.rs:17:25\n    |\n@@ -23,12 +23,12 @@ note: but, the lifetime must be valid for the lifetime 'b as defined on the body\n   --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n    |\n 15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^ starting here...\n+   |  ___________________________________________________________________^\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     Vec::push(a, b);\n 19 | | }\n-   | |_^ ...ending here\n+   | |_^\n note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n   --> $DIR/ex2e-push-inference-variable-3.rs:16:33\n    |"}, {"sha": "36bdec8d43afef1b9ca5fba171743cca1963002b", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -37,31 +37,29 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:42:5\n    |\n-42 |       X {\n-   |  _____^ starting here...\n+42 | /     X {\n 43 | |         x: X {\n 44 | |             x: \"\".to_string(),\n 45 | |             y: 2,\n 46 | |         },\n 47 | |         y: 3,\n 48 | |     }\n-   | |_____^ ...ending here: expected struct `std::string::String`, found integral variable\n+   | |_____^ expected struct `std::string::String`, found integral variable\n    |\n    = note: expected type `X<X<_, std::string::String>, std::string::String>`\n               found type `X<X<_, {integer}>, {integer}>`\n \n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:52:5\n    |\n-52 |       X {\n-   |  _____^ starting here...\n+52 | /     X {\n 53 | |         x: X {\n 54 | |             x: \"\".to_string(),\n 55 | |             y: 2,\n 56 | |         },\n 57 | |         y: \"\".to_string(),\n 58 | |     }\n-   | |_____^ ...ending here: expected struct `std::string::String`, found integral variable\n+   | |_____^ expected struct `std::string::String`, found integral variable\n    |\n    = note: expected type `X<X<_, std::string::String>, _>`\n               found type `X<X<_, {integer}>, _>`"}, {"sha": "c8941fbf950734c021621508ef1ef3129a95af14", "filename": "src/test/ui/mismatched_types/main.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -2,9 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/main.rs:12:18\n    |\n 12 |       let x: u32 = (\n-   |  __________________^ starting here...\n+   |  __________________^\n 13 | |     );\n-   | |_____^ ...ending here: expected u32, found ()\n+   | |_____^ expected u32, found ()\n    |\n    = note: expected type `u32`\n               found type `()`"}, {"sha": "503ce5618d486db165587ec6ccd283399e0ac5f2", "filename": "src/test/ui/missing-items/m2.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fmissing-items%2Fm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fmissing-items%2Fm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing-items%2Fm2.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -3,10 +3,9 @@ error: main function not found\n error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `method`\n   --> $DIR/m2.rs:20:1\n    |\n-20 |   impl m1::X for X {\n-   |  _^ starting here...\n+20 | / impl m1::X for X {\n 21 | | }\n-   | |_^ ...ending here: missing `CONSTANT`, `Type`, `method` in implementation\n+   | |_^ missing `CONSTANT`, `Type`, `method` in implementation\n    |\n    = note: `CONSTANT` from trait: `const CONSTANT: u32;`\n    = note: `Type` from trait: `type Type;`"}, {"sha": "e9b43145de469706b199292371e4fa0be7542ede", "filename": "src/test/ui/print_type_sizes/repr-align.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how padding is handled: alignment\n+// requirements can lead to the introduction of padding, either before\n+// fields or at the end of the structure as a whole.\n+//\n+// It avoids using u64/i64 because on some targets that is only 4-byte\n+// aligned (while on most it is 8-byte aligned) and so the resulting\n+// padding and overall computed sizes can be quite different.\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+#![allow(dead_code)]\n+\n+#[repr(align(16))]\n+#[derive(Default)]\n+struct A(i32);\n+\n+enum E {\n+    A(i32),\n+    B(A)\n+}\n+\n+#[derive(Default)]\n+struct S {\n+    a: i32,\n+    b: i32,\n+    c: A,\n+    d: i8,\n+}\n+\n+fn main() {\n+    let _s: S = Default::default();\n+}"}, {"sha": "7df12f040b15d4d24dbfa071ccc2853649b43e0a", "filename": "src/test/ui/print_type_sizes/repr-align.stdout", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,16 @@\n+print-type-size type: `E`: 32 bytes, alignment: 16 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `A`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `B`: 28 bytes\n+print-type-size         padding: 12 bytes\n+print-type-size         field `.0`: 16 bytes, alignment: 16 bytes\n+print-type-size type: `S`: 32 bytes, alignment: 16 bytes\n+print-type-size     field `.c`: 16 bytes\n+print-type-size     field `.a`: 4 bytes\n+print-type-size     field `.b`: 4 bytes\n+print-type-size     field `.d`: 1 bytes\n+print-type-size     end padding: 7 bytes\n+print-type-size type: `A`: 16 bytes, alignment: 16 bytes\n+print-type-size     field `.0`: 4 bytes\n+print-type-size     end padding: 12 bytes"}, {"sha": "bc3122bf71c0e21056a40d31e75e4a41f6e032ed", "filename": "src/test/ui/span/coerce-suggestions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -32,7 +32,6 @@ fn main() {\n     //~| NOTE types differ in mutability\n     //~| NOTE expected type `&mut std::string::String`\n     //~| NOTE found type `&std::string::String`\n-    //~| HELP try with `&mut y`\n     test2(&y);\n     //~^ ERROR E0308\n     //~| NOTE types differ in mutability"}, {"sha": "220b2f471da9ad7aef33e4d22a67ab811adbb778", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -18,11 +18,7 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `&str`\n               found type `std::string::String`\n-   = help: here are some functions which might fulfill your needs:\n-           - .as_str()\n-           - .trim()\n-           - .trim_left()\n-           - .trim_right()\n+   = help: try with `&String::new()`\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:30:10\n@@ -34,18 +30,18 @@ error[E0308]: mismatched types\n               found type `&std::string::String`\n \n error[E0308]: mismatched types\n-  --> $DIR/coerce-suggestions.rs:36:11\n+  --> $DIR/coerce-suggestions.rs:35:11\n    |\n-36 |     test2(&y);\n+35 |     test2(&y);\n    |           ^^ types differ in mutability\n    |\n    = note: expected type `&mut i32`\n               found type `&std::string::String`\n \n error[E0308]: mismatched types\n-  --> $DIR/coerce-suggestions.rs:42:9\n+  --> $DIR/coerce-suggestions.rs:41:9\n    |\n-42 |     f = box f;\n+41 |     f = box f;\n    |         ^^^^^ cyclic type of infinite size\n    |\n    = note: expected type `_`"}, {"sha": "ae290b3b11aa79c5df19475fbd03aaab7ed839b1", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -19,15 +19,14 @@ error[E0046]: not all trait items implemented, missing: `bar`\n 16 |       fn bar(&self);\n    |       -------------- `bar` from trait\n ...\n-22 |   impl Foo for FooConstForMethod {\n-   |  _^ starting here...\n+22 | / impl Foo for FooConstForMethod {\n 23 | |     //~^ ERROR E0046\n 24 | |     //~| NOTE missing `bar` in implementation\n 25 | |     const bar: u64 = 1;\n ...  |\n 28 | |     const MY_CONST: u32 = 1;\n 29 | | }\n-   | |_^ ...ending here: missing `bar` in implementation\n+   | |_^ missing `bar` in implementation\n \n error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:37:5\n@@ -44,15 +43,14 @@ error[E0046]: not all trait items implemented, missing: `MY_CONST`\n 17 |       const MY_CONST: u32;\n    |       -------------------- `MY_CONST` from trait\n ...\n-33 |   impl Foo for FooMethodForConst {\n-   |  _^ starting here...\n+33 | / impl Foo for FooMethodForConst {\n 34 | |     //~^ ERROR E0046\n 35 | |     //~| NOTE missing `MY_CONST` in implementation\n 36 | |     fn bar(&self) {}\n ...  |\n 39 | |     //~| NOTE does not match trait\n 40 | | }\n-   | |_^ ...ending here: missing `MY_CONST` in implementation\n+   | |_^ missing `MY_CONST` in implementation\n \n error[E0325]: item `bar` is an associated type, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:47:5\n@@ -69,23 +67,21 @@ error[E0046]: not all trait items implemented, missing: `bar`\n 16 |       fn bar(&self);\n    |       -------------- `bar` from trait\n ...\n-44 |   impl Foo for FooTypeForMethod {\n-   |  _^ starting here...\n+44 | / impl Foo for FooTypeForMethod {\n 45 | |     //~^ ERROR E0046\n 46 | |     //~| NOTE missing `bar` in implementation\n 47 | |     type bar = u64;\n ...  |\n 50 | |     const MY_CONST: u32 = 1;\n 51 | | }\n-   | |_^ ...ending here: missing `bar` in implementation\n+   | |_^ missing `bar` in implementation\n \n error[E0046]: not all trait items implemented, missing: `fmt`\n   --> $DIR/impl-wrong-item-for-trait.rs:53:1\n    |\n-53 |   impl Debug for FooTypeForMethod {\n-   |  _^ starting here...\n+53 | / impl Debug for FooTypeForMethod {\n 54 | | }\n-   | |_^ ...ending here: missing `fmt` in implementation\n+   | |_^ missing `fmt` in implementation\n    |\n    = note: `fmt` from trait: `fn(&Self, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>`\n "}, {"sha": "d9f4bacce35ae0650c9d88c39f58329dab187dcc", "filename": "src/test/ui/span/issue-23729.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,15 +1,14 @@\n error[E0046]: not all trait items implemented, missing: `Item`\n   --> $DIR/issue-23729.rs:20:9\n    |\n-20 |           impl Iterator for Recurrence {\n-   |  _________^ starting here...\n+20 | /         impl Iterator for Recurrence {\n 21 | |             //~^ ERROR E0046\n 22 | |             //~| NOTE missing `Item` in implementation\n 23 | |             //~| NOTE `Item` from trait: `type Item;`\n ...  |\n 36 | |             }\n 37 | |         }\n-   | |_________^ ...ending here: missing `Item` in implementation\n+   | |_________^ missing `Item` in implementation\n    |\n    = note: `Item` from trait: `type Item;`\n "}, {"sha": "3127af157a62bbb8184673b6398e6f4993db4230", "filename": "src/test/ui/span/issue-23827.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,15 +1,14 @@\n error[E0046]: not all trait items implemented, missing: `Output`\n   --> $DIR/issue-23827.rs:36:1\n    |\n-36 |   impl<C: Component> FnOnce<(C,)> for Prototype {\n-   |  _^ starting here...\n+36 | / impl<C: Component> FnOnce<(C,)> for Prototype {\n 37 | |     //~^ ERROR E0046\n 38 | |     //~| NOTE missing `Output` in implementation\n 39 | |     //~| NOTE `Output` from trait: `type Output;`\n ...  |\n 42 | |     }\n 43 | | }\n-   | |_^ ...ending here: missing `Output` in implementation\n+   | |_^ missing `Output` in implementation\n    |\n    = note: `Output` from trait: `type Output;`\n "}, {"sha": "71ab82d98b809abee614d08c740e37a5266d8ee6", "filename": "src/test/ui/span/issue-24356.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,14 +1,13 @@\n error[E0046]: not all trait items implemented, missing: `Target`\n   --> $DIR/issue-24356.rs:30:9\n    |\n-30 |           impl Deref for Thing {\n-   |  _________^ starting here...\n+30 | /         impl Deref for Thing {\n 31 | |             //~^ ERROR E0046\n 32 | |             //~| NOTE missing `Target` in implementation\n 33 | |             //~| NOTE `Target` from trait: `type Target;`\n 34 | |             fn deref(&self) -> i8 { self.0 }\n 35 | |         }\n-   | |_________^ ...ending here: missing `Target` in implementation\n+   | |_________^ missing `Target` in implementation\n    |\n    = note: `Target` from trait: `type Target;`\n "}, {"sha": "93aa502ee153133293c80fbe183df6fb63b61580", "filename": "src/test/ui/span/issue-33884.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-33884.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-33884.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-33884.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::net::TcpListener;\n+use std::net::TcpStream;\n+use std::io::{self, Read, Write};\n+\n+fn handle_client(stream: TcpStream) -> io::Result<()> {\n+    stream.write_fmt(format!(\"message received\"))\n+}\n+\n+fn main() {\n+    if let Ok(listener) = TcpListener::bind(\"127.0.0.1:8080\") {\n+        for incoming in listener.incoming() {\n+            if let Ok(stream) = incoming {\n+                handle_client(stream);\n+            }\n+        }\n+    }\n+}"}, {"sha": "2a874181c7ad9a03332c073bbde569fce15ebc76", "filename": "src/test/ui/span/issue-33884.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-33884.rs:16:22\n+   |\n+16 |     stream.write_fmt(format!(\"message received\"))\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::fmt::Arguments`, found struct `std::string::String`\n+   |\n+   = note: expected type `std::fmt::Arguments<'_>`\n+              found type `std::string::String`\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to previous error\n+"}, {"sha": "8b813220d789de781b21f5dc635f3aa882cb2003", "filename": "src/test/ui/span/issue-7575.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -38,11 +38,10 @@ error: no method named `fff` found for type `Myisize` in the current scope\n note: candidate #1 is defined in an impl for the type `Myisize`\n   --> $DIR/issue-7575.rs:51:5\n    |\n-51 |       fn fff(i: isize) -> isize { //~ NOTE candidate\n-   |  _____^ starting here...\n+51 | /     fn fff(i: isize) -> isize { //~ NOTE candidate\n 52 | |         i\n 53 | |     }\n-   | |_____^ ...ending here\n+   | |_____^\n \n error: no method named `is_str` found for type `T` in the current scope\n   --> $DIR/issue-7575.rs:85:7\n@@ -54,11 +53,10 @@ error: no method named `is_str` found for type `T` in the current scope\n note: candidate #1 is defined in the trait `ManyImplTrait`\n   --> $DIR/issue-7575.rs:57:5\n    |\n-57 |       fn is_str() -> bool { //~ NOTE candidate\n-   |  _____^ starting here...\n+57 | /     fn is_str() -> bool { //~ NOTE candidate\n 58 | |         false\n 59 | |     }\n-   | |_____^ ...ending here\n+   | |_____^\n    = help: to disambiguate the method call, write `ManyImplTrait::is_str(t)` instead\n    = help: items from traits can only be used if the trait is implemented and in scope; the following trait defines an item `is_str`, perhaps you need to implement it:\n    = help: candidate #1: `ManyImplTrait`"}, {"sha": "f4998e08907a387f55b897ab80f5cc47e203d540", "filename": "src/test/ui/span/lint-unused-unsafe.stderr", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Flint-unused-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Flint-unused-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Flint-unused-unsafe.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -49,68 +49,62 @@ note: because it's nested under this `unsafe` fn\n error: unnecessary `unsafe` block\n   --> $DIR/lint-unused-unsafe.rs:33:9\n    |\n-33 |           unsafe {                         //~ ERROR: unnecessary `unsafe` block\n-   |  _________^ starting here...\n+33 | /         unsafe {                         //~ ERROR: unnecessary `unsafe` block\n 34 | |             unsf()\n 35 | |         }\n-   | |_________^ ...ending here: unnecessary `unsafe` block\n+   | |_________^ unnecessary `unsafe` block\n    |\n note: because it's nested under this `unsafe` block\n   --> $DIR/lint-unused-unsafe.rs:32:5\n    |\n-32 |       unsafe {                             // don't put the warning here\n-   |  _____^ starting here...\n+32 | /     unsafe {                             // don't put the warning here\n 33 | |         unsafe {                         //~ ERROR: unnecessary `unsafe` block\n 34 | |             unsf()\n 35 | |         }\n 36 | |     }\n-   | |_____^ ...ending here\n+   | |_____^\n \n error: unnecessary `unsafe` block\n   --> $DIR/lint-unused-unsafe.rs:39:5\n    |\n-39 |       unsafe {                             //~ ERROR: unnecessary `unsafe` block\n-   |  _____^ starting here...\n+39 | /     unsafe {                             //~ ERROR: unnecessary `unsafe` block\n 40 | |         unsafe {                         //~ ERROR: unnecessary `unsafe` block\n 41 | |             unsf()\n 42 | |         }\n 43 | |     }\n-   | |_____^ ...ending here: unnecessary `unsafe` block\n+   | |_____^ unnecessary `unsafe` block\n    |\n note: because it's nested under this `unsafe` fn\n   --> $DIR/lint-unused-unsafe.rs:38:1\n    |\n-38 |   unsafe fn bad7() {\n-   |  _^ starting here...\n+38 | / unsafe fn bad7() {\n 39 | |     unsafe {                             //~ ERROR: unnecessary `unsafe` block\n 40 | |         unsafe {                         //~ ERROR: unnecessary `unsafe` block\n 41 | |             unsf()\n 42 | |         }\n 43 | |     }\n 44 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error: unnecessary `unsafe` block\n   --> $DIR/lint-unused-unsafe.rs:40:9\n    |\n-40 |           unsafe {                         //~ ERROR: unnecessary `unsafe` block\n-   |  _________^ starting here...\n+40 | /         unsafe {                         //~ ERROR: unnecessary `unsafe` block\n 41 | |             unsf()\n 42 | |         }\n-   | |_________^ ...ending here: unnecessary `unsafe` block\n+   | |_________^ unnecessary `unsafe` block\n    |\n note: because it's nested under this `unsafe` fn\n   --> $DIR/lint-unused-unsafe.rs:38:1\n    |\n-38 |   unsafe fn bad7() {\n-   |  _^ starting here...\n+38 | / unsafe fn bad7() {\n 39 | |     unsafe {                             //~ ERROR: unnecessary `unsafe` block\n 40 | |         unsafe {                         //~ ERROR: unnecessary `unsafe` block\n 41 | |             unsf()\n 42 | |         }\n 43 | |     }\n 44 | | }\n-   | |_^ ...ending here\n+   | |_^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "9c6816e736313c534e6bc6df1579a47e9bfcbcce", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,14 +1,13 @@\n error[E0072]: recursive type `ListNode` has infinite size\n   --> $DIR/multiline-span-E0072.rs:12:1\n    |\n-12 |   struct\n-   |  _^ starting here...\n+12 | / struct\n 13 | | ListNode\n 14 | | {\n 15 | |     head: u8,\n 16 | |     tail: Option<ListNode>,\n 17 | | }\n-   | |_^ ...ending here: recursive type has infinite size\n+   | |_^ recursive type has infinite size\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n "}, {"sha": "843c1e811d578393ea375cc42338d38a773e7749", "filename": "src/test/ui/span/multiline-span-simple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -2,12 +2,12 @@ error[E0277]: the trait bound `u32: std::ops::Add<()>` is not satisfied\n   --> $DIR/multiline-span-simple.rs:23:9\n    |\n 23 |       foo(1 as u32 +\n-   |  _________^ starting here...\n+   |  _________^\n 24 | |\n 25 | |         bar(x,\n 26 | |\n 27 | |             y),\n-   | |______________^ ...ending here: the trait `std::ops::Add<()>` is not implemented for `u32`\n+   | |______________^ the trait `std::ops::Add<()>` is not implemented for `u32`\n    |\n    = note: no implementation for `u32 + ()`\n "}, {"sha": "7a76799889b97385d114fe863b94ed0573acc925", "filename": "src/test/ui/type-check/issue-40294.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,15 +1,14 @@\n error[E0282]: type annotations needed\n   --> $DIR/issue-40294.rs:15:1\n    |\n-15 |   fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n-   |  _^ starting here...\n+15 | / fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n 16 | |     where &'a T : Foo,\n 17 | |           &'b T : Foo\n 18 | | {\n 19 | |     x.foo();\n 20 | |     y.foo();\n 21 | | }\n-   | |_^ ...ending here: cannot infer type for `&'a T`\n+   | |_^ cannot infer type for `&'a T`\n \n error: aborting due to previous error\n "}, {"sha": "a8cb30da43513944b842a7946d06f1730d287374", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -81,6 +81,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"s390x-unknown-linux-gnu\",\n     \"sparc64-unknown-linux-gnu\",\n     \"wasm32-unknown-emscripten\",\n+    \"x86_64-linux-android\",\n     \"x86_64-apple-darwin\",\n     \"x86_64-apple-ios\",\n     \"x86_64-pc-windows-gnu\","}]}