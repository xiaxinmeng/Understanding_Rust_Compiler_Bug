{"sha": "737db5b49a47593529395d2d9225ca2eaa684634", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczN2RiNWI0OWE0NzU5MzUyOTM5NWQyZDkyMjVjYTJlYWE2ODQ2MzQ=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-02-12T01:42:45Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-02-12T01:42:45Z"}, "message": "Merge pull request #1812 from killerswan/indexing2\n\n(core::str) Fixing index and rindex", "tree": {"sha": "f7c0923b454f2f856d79c9deec181f1fb200e6ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c0923b454f2f856d79c9deec181f1fb200e6ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/737db5b49a47593529395d2d9225ca2eaa684634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/737db5b49a47593529395d2d9225ca2eaa684634", "html_url": "https://github.com/rust-lang/rust/commit/737db5b49a47593529395d2d9225ca2eaa684634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/737db5b49a47593529395d2d9225ca2eaa684634/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c82a0d7c3c0c0fda158102af7bc5af2823df2f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/c82a0d7c3c0c0fda158102af7bc5af2823df2f06", "html_url": "https://github.com/rust-lang/rust/commit/c82a0d7c3c0c0fda158102af7bc5af2823df2f06"}, {"sha": "207bb3d2df92f896145b3f2ef8aa5ca5cea00104", "url": "https://api.github.com/repos/rust-lang/rust/commits/207bb3d2df92f896145b3f2ef8aa5ca5cea00104", "html_url": "https://github.com/rust-lang/rust/commit/207bb3d2df92f896145b3f2ef8aa5ca5cea00104"}], "stats": {"total": 238, "additions": 151, "deletions": 87}, "files": [{"sha": "ac1727ffdb7c871c9bbbbb755f23b0e14496894b", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -651,25 +651,27 @@ fn cmd_install(c: cargo) unsafe {\n \n     if str::starts_with(target, \"uuid:\") {\n         let uuid = rest(target, 5u);\n-        let idx = str::index(uuid, '/' as u8);\n-        if idx != -1 {\n-            let source = str::unsafe::slice_bytes(uuid, 0u, idx as uint);\n-            uuid = str::unsafe::slice_bytes(uuid, idx as uint + 1u,\n-                                      str::byte_len(uuid));\n-            install_uuid_specific(c, wd, source, uuid);\n-        } else {\n-            install_uuid(c, wd, uuid);\n+        alt str::index(uuid, '/') {\n+            option::some(idx) {\n+               let source = str::slice(uuid, 0u, idx);\n+               uuid = str::slice(uuid, idx + 1u, str::char_len(uuid));\n+               install_uuid_specific(c, wd, source, uuid);\n+            }\n+            option::none {\n+               install_uuid(c, wd, uuid);\n+            }\n         }\n     } else {\n         let name = target;\n-        let idx = str::index(name, '/' as u8);\n-        if idx != -1 {\n-            let source = str::unsafe::slice_bytes(name, 0u, idx as uint);\n-            name = str::unsafe::slice_bytes(name, idx as uint + 1u,\n-                                      str::byte_len(name));\n-            install_named_specific(c, wd, source, name);\n-        } else {\n-            install_named(c, wd, name);\n+        alt str::index(name, '/') {\n+            option::some(idx) {\n+               let source = str::slice(name, 0u, idx);\n+               name = str::slice(name, idx + 1u, str::char_len(name));\n+               install_named_specific(c, wd, source, name);\n+            }\n+            option::none {\n+               install_named(c, wd, name);\n+            }\n         }\n     }\n }"}, {"sha": "5fa7841c97246c67618d70af90be0a65b106c32b", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -109,14 +109,16 @@ mod write {\n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n     fn mk_intermediate_name(output_path: str, extension: str) -> str unsafe {\n-        let dot_pos = str::index(output_path, '.' as u8);\n-        let stem;\n-        if dot_pos < 0 {\n-            stem = output_path;\n-        } else { stem = str::unsafe::slice_bytes(output_path, 0u,\n-                                                 dot_pos as uint); }\n+        let stem = alt str::index(output_path, '.') {\n+                       option::some(dot_pos) {\n+                           str::slice(output_path, 0u, dot_pos)\n+                       }\n+                       option::none { output_path }\n+                   };\n+\n         ret stem + \".\" + extension;\n     }\n+\n     fn run_passes(sess: session, llmod: ModuleRef, output: str) {\n         let opts = sess.opts;\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }"}, {"sha": "cb2590e195188f66d95d9632a3a0a5f12d010450", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -119,16 +119,13 @@ fn get_line(fm: filemap, line: int) -> str unsafe {\n     let end: uint;\n     if line as uint < vec::len(fm.lines) - 1u {\n         end = fm.lines[line + 1].byte - fm.start_pos.byte;\n+        ret str::unsafe::slice_bytes(*fm.src, begin, end);\n     } else {\n         // If we're not done parsing the file, we're at the limit of what's\n         // parsed. If we just slice the rest of the string, we'll print out\n         // the remainder of the file, which is undesirable.\n-        end = str::byte_len(*fm.src);\n-        let rest = str::unsafe::slice_bytes(*fm.src, begin, end);\n-        let newline = str::index(rest, '\\n' as u8);\n-        if newline != -1 { end = begin + (newline as uint); }\n+        ret str::splitn_char(*fm.src, '\\n', 1u)[0];\n     }\n-    ret str::unsafe::slice_bytes(*fm.src, begin, end);\n }\n \n fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)"}, {"sha": "9790ec02ff45b74518a682d27c59ca72c8fc5967", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -283,10 +283,9 @@ fn check_variants_T<T: copy>(\n     }\n }\n \n-fn last_part(filename: str) -> str unsafe {\n-  let ix = str::rindex(filename, 47u8 /* '/' */);\n-  assert ix >= 0;\n-  str::unsafe::slice_bytes(filename, ix as uint + 1u, str::byte_len(filename) - 3u)\n+fn last_part(filename: str) -> str {\n+  let ix = option::get(str::rindex(filename, '/'));\n+  str::slice(filename, ix + 1u, str::char_len(filename) - 3u)\n }\n \n enum happiness { passed, cleanly_rejected(str), known_bug(str), failed(str), }"}, {"sha": "ca7bb819443b6fb5d05c8681a68c9ae37d3f7b27", "filename": "src/libcore/str.rs", "status": "modified", "additions": 96, "deletions": 33, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -253,15 +253,12 @@ Function: pop_char\n Remove the final character from a string and return it.\n \n Failure:\n-\n If the string does not contain any characters.\n */\n fn pop_char(&s: str) -> char unsafe {\n     let end = byte_len(s);\n-    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n-    assert (end > 0u);\n-    let ch = char_at(s, end - 1u);\n-    s = unsafe::slice_bytes(s, 0u, end - 1u);\n+    let {ch:ch, prev:end} = char_range_at_reverse(s, end);\n+    s = unsafe::slice_bytes(s, 0u, end);\n     ret ch;\n }\n \n@@ -868,32 +865,50 @@ fn lines_iter(ss: str, ff: fn(&&str)) {\n Section: Searching\n */\n \n-/*\n-Function: index\n+// Function: index\n+//\n+// Returns the index of the first matching char\n+// (as option some/none)\n+fn index(ss: str, cc: char) -> option<uint> {\n+    let bii = 0u;\n+    let cii = 0u;\n+    let len = byte_len(ss);\n+    while bii < len {\n+        let {ch, next} = char_range_at(ss, bii);\n \n-Returns the index of the first matching byte. Returns -1 if\n-no match is found.\n+        // found here?\n+        if ch == cc {\n+            ret option::some(cii);\n+        }\n \n-FIXME: UTF-8\n-*/\n-fn index(s: str, c: u8) -> int {\n-    let i: int = 0;\n-    for k: u8 in s { if k == c { ret i; } i += 1; }\n-    ret -1;\n-}\n+        cii += 1u;\n+        bii = next;\n+    }\n \n-/*\n-Function: rindex\n+    // wasn't found\n+    ret option::none;\n+}\n \n-Returns the index of the last matching byte. Returns -1\n-if no match is found.\n+// Function: rindex\n+//\n+// Returns the index of the first matching char\n+// (as option some/none)\n+fn rindex(ss: str, cc: char) -> option<uint> {\n+    let bii = byte_len(ss);\n+    let cii = char_len(ss);\n+    while bii > 0u {\n+        let {ch, prev} = char_range_at_reverse(ss, bii);\n+        cii -= 1u;\n+        bii = prev;\n+\n+        // found here?\n+        if ch == cc {\n+            ret option::some(cii);\n+        }\n+    }\n \n-FIXME: UTF-8\n-*/\n-fn rindex(s: str, c: u8) -> int {\n-    let n: int = byte_len(s) as int;\n-    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n-    ret n;\n+    // wasn't found\n+    ret option::none;\n }\n \n /*\n@@ -1233,6 +1248,25 @@ Pluck a character out of a string\n */\n fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n+// Function: char_range_at_reverse\n+//\n+// Given a byte position and a str, return the previous char and its position\n+// This function can be used to iterate over a unicode string in reverse.\n+fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n+    let prev = start;\n+\n+    // while there is a previous byte == 10......\n+    while prev > 0u && ss[prev - 1u] & 192u8 == tag_cont_u8 {\n+        prev -= 1u;\n+    }\n+\n+    // now refer to the initial byte of previous char\n+    prev -= 1u;\n+\n+    let ch = char_at(ss, prev);\n+    ret {ch:ch, prev:prev};\n+}\n+\n /*\n Function: substr_all\n \n@@ -1442,13 +1476,42 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_index_and_rindex() {\n-        assert (index(\"hello\", 'e' as u8) == 1);\n-        assert (index(\"hello\", 'o' as u8) == 4);\n-        assert (index(\"hello\", 'z' as u8) == -1);\n-        assert (rindex(\"hello\", 'l' as u8) == 3);\n-        assert (rindex(\"hello\", 'h' as u8) == 0);\n-        assert (rindex(\"hello\", 'z' as u8) == -1);\n+    fn test_index() {\n+        assert ( index(\"hello\", 'h') == option::some(0u));\n+        assert ( index(\"hello\", 'e') == option::some(1u));\n+        assert ( index(\"hello\", 'o') == option::some(4u));\n+        assert ( index(\"hello\", 'z') == option::none);\n+    }\n+\n+    #[test]\n+    fn test_rindex() {\n+        assert (rindex(\"hello\", 'l') == option::some(3u));\n+        assert (rindex(\"hello\", 'o') == option::some(4u));\n+        assert (rindex(\"hello\", 'h') == option::some(0u));\n+        assert (rindex(\"hello\", 'z') == option::none);\n+    }\n+\n+    #[test]\n+    fn test_pop_char() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let cc = pop_char(data);\n+        assert \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n+        assert '\u534e' == cc;\n+    }\n+\n+    #[test]\n+    fn test_pop_char_2() {\n+        let data2 = \"\u534e\";\n+        let cc2 = pop_char(data2);\n+        assert \"\" == data2;\n+        assert '\u534e' == cc2;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_pop_char_fail() {\n+        let data = \"\";\n+        let _cc3 = pop_char(data);\n     }\n \n     #[test]"}, {"sha": "de4789fdd3996bc0636bad2b88ae3761742bdf36", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -32,6 +32,22 @@ A path or fragment of a filesystem path\n */\n type path = str;\n \n+fn splitDirnameBasename (pp: path) -> {dirname: str, basename: str} {\n+    let ii;\n+    alt str::rindex(pp, os_fs::path_sep) {\n+        option::some(xx) { ii = xx; }\n+        option::none {\n+            alt str::rindex(pp, os_fs::alt_path_sep) {\n+                option::some(xx) { ii = xx; }\n+                option::none { ret {dirname: \".\", basename: pp}; }\n+            }\n+        }\n+    }\n+\n+    ret {dirname: str::slice(pp, 0u, ii),\n+         basename: str::slice(pp, ii + 1u, str::char_len(pp))};\n+}\n+\n /*\n Function: dirname\n \n@@ -43,13 +59,8 @@ The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n \n If the path is not prefixed with a directory, then \".\" is returned.\n */\n-fn dirname(p: path) -> path unsafe {\n-    let i: int = str::rindex(p, os_fs::path_sep as u8);\n-    if i == -1 {\n-        i = str::rindex(p, os_fs::alt_path_sep as u8);\n-        if i == -1 { ret \".\"; }\n-    }\n-    ret str::unsafe::slice_bytes(p, 0u, i as uint);\n+fn dirname(pp: path) -> path {\n+    ret splitDirnameBasename(pp).dirname;\n }\n \n /*\n@@ -63,18 +74,10 @@ path separators in the path then the returned path is identical to\n the provided path. If an empty path is provided or the path ends\n with a path separator then an empty path is returned.\n */\n-fn basename(p: path) -> path unsafe {\n-    let i: int = str::rindex(p, os_fs::path_sep as u8);\n-    if i == -1 {\n-        i = str::rindex(p, os_fs::alt_path_sep as u8);\n-        if i == -1 { ret p; }\n-    }\n-    let len = str::byte_len(p);\n-    if (i + 1) as uint >= len { ret p; }\n-    ret str::unsafe::slice_bytes(p, (i + 1) as uint, len);\n+fn basename(pp: path) -> path {\n+    ret splitDirnameBasename(pp).basename;\n }\n \n-\n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n /*\n Function: connect"}, {"sha": "8288501defc31bf5ecb47b80b8aef9d3659ec0d2", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/737db5b49a47593529395d2d9225ca2eaa684634/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737db5b49a47593529395d2d9225ca2eaa684634/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=737db5b49a47593529395d2d9225ca2eaa684634", "patch": "@@ -230,16 +230,14 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n             let i_arg = option::none::<str>;\n             if cur[1] == '-' as u8 {\n                 let tail = str::unsafe::slice_bytes(cur, 2u, curlen);\n-                let eq = str::index(tail, '=' as u8);\n-                if eq == -1 {\n+                let tail_eq = str::splitn_char(tail, '=', 1u);\n+                if vec::len(tail_eq) <= 1u {\n                     names = [long(tail)];\n                 } else {\n                     names =\n-                        [long(str::unsafe::slice_bytes(tail,0u,eq as uint))];\n+                        [long(tail_eq[0])];\n                     i_arg =\n-                        option::some::<str>(str::unsafe::slice_bytes(tail,\n-                                                       (eq as uint) + 1u,\n-                                                       curlen - 2u));\n+                        option::some::<str>(tail_eq[1]);\n                 }\n             } else {\n                 let j = 1u;"}]}