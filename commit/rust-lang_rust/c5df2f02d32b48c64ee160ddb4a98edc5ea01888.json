{"sha": "c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "node_id": "C_kwDOAAsO6NoAKGM1ZGYyZjAyZDMyYjQ4YzY0ZWUxNjBkZGI0YTk4ZWRjNWVhMDE4ODg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-21T16:42:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-21T16:42:02Z"}, "message": "Rollup merge of #98707 - joboet:fuchsia_locks, r=m-ou-se\n\nstd: use futex-based locks on Fuchsia\n\nThis switches `Condvar` and `RwLock` to the futex-based implementation currently used on Linux and some BSDs. Additionally, `Mutex` now has its own, priority-inheriting implementation based on the mutex in Fuchsia's `libsync`. It differs from the original in that it panics instead of aborting when reentrant locking is detected.\n\n````@rustbot```` ping fuchsia\nr? ````@m-ou-se````", "tree": {"sha": "160795284b8793c639a504b5bad86addd5dc30a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/160795284b8793c639a504b5bad86addd5dc30a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi2YHaCRBK7hj4Ov3rIwAAid8IAEyO5zw9tHIc5e8JYYCA93ae\nii6PpupyMc//6RvylkBIklgmi1XtYywaF8fH7O9j2RWYe2jEBJYePlQpdbMNKX8v\n+o5+sU+TD/eXtQ2pA5rnmqzNP998Q+EAxxFg7HRqE0PGtQrHYe36/hdqZm6fh5Gw\nORqHljz1WPuQrIDnCDxtcBmC8lhQq4ugT1ebLRUVHRRO2c8xusDbSAJlJ7NePwZJ\nX/4N7Q50Mk20ggxa9wzQIaRuisKRkp1wPApJHnSEPP9Kts6Q6Zdj01r8vVV2K93N\n0dWkVzQ6Koot/e1sdjmyRD7ObpaR68Vkjx2N6B7M5f7wxHi/+lhN0JR1Uh46aSQ=\n=7ggv\n-----END PGP SIGNATURE-----\n", "payload": "tree 160795284b8793c639a504b5bad86addd5dc30a7\nparent 1673f1450eeaf4a5452e086db0fe2ae274a0144f\nparent 8ba02f18b813aa8ea2599979567797bbb9dc3ecb\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1658421722 +0200\ncommitter GitHub <noreply@github.com> 1658421722 +0200\n\nRollup merge of #98707 - joboet:fuchsia_locks, r=m-ou-se\n\nstd: use futex-based locks on Fuchsia\n\nThis switches `Condvar` and `RwLock` to the futex-based implementation currently used on Linux and some BSDs. Additionally, `Mutex` now has its own, priority-inheriting implementation based on the mutex in Fuchsia's `libsync`. It differs from the original in that it panics instead of aborting when reentrant locking is detected.\n\n````@rustbot```` ping fuchsia\nr? ````@m-ou-se````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "html_url": "https://github.com/rust-lang/rust/commit/c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1673f1450eeaf4a5452e086db0fe2ae274a0144f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1673f1450eeaf4a5452e086db0fe2ae274a0144f", "html_url": "https://github.com/rust-lang/rust/commit/1673f1450eeaf4a5452e086db0fe2ae274a0144f"}, {"sha": "8ba02f18b813aa8ea2599979567797bbb9dc3ecb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba02f18b813aa8ea2599979567797bbb9dc3ecb", "html_url": "https://github.com/rust-lang/rust/commit/8ba02f18b813aa8ea2599979567797bbb9dc3ecb"}], "stats": {"total": 320, "additions": 256, "deletions": 64}, "files": [{"sha": "8d5b540212a17c9be272c66d14f6b84a96049c44", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "patch": "@@ -240,25 +240,34 @@ pub fn futex_wake_all(futex: &AtomicU32) {\n }\n \n #[cfg(target_os = \"fuchsia\")]\n-mod zircon {\n-    type zx_time_t = i64;\n-    type zx_futex_t = crate::sync::atomic::AtomicU32;\n-    type zx_handle_t = u32;\n-    type zx_status_t = i32;\n+pub mod zircon {\n+    pub type zx_futex_t = crate::sync::atomic::AtomicU32;\n+    pub type zx_handle_t = u32;\n+    pub type zx_status_t = i32;\n+    pub type zx_time_t = i64;\n \n     pub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n-    pub const ZX_ERR_TIMED_OUT: zx_status_t = -21;\n+\n     pub const ZX_TIME_INFINITE: zx_time_t = zx_time_t::MAX;\n \n+    pub const ZX_OK: zx_status_t = 0;\n+    pub const ZX_ERR_INVALID_ARGS: zx_status_t = -10;\n+    pub const ZX_ERR_BAD_HANDLE: zx_status_t = -11;\n+    pub const ZX_ERR_WRONG_TYPE: zx_status_t = -12;\n+    pub const ZX_ERR_BAD_STATE: zx_status_t = -20;\n+    pub const ZX_ERR_TIMED_OUT: zx_status_t = -21;\n+\n     extern \"C\" {\n+        pub fn zx_clock_get_monotonic() -> zx_time_t;\n         pub fn zx_futex_wait(\n             value_ptr: *const zx_futex_t,\n             current_value: zx_futex_t,\n             new_futex_owner: zx_handle_t,\n             deadline: zx_time_t,\n         ) -> zx_status_t;\n         pub fn zx_futex_wake(value_ptr: *const zx_futex_t, wake_count: u32) -> zx_status_t;\n-        pub fn zx_clock_get_monotonic() -> zx_time_t;\n+        pub fn zx_futex_wake_single_owner(value_ptr: *const zx_futex_t) -> zx_status_t;\n+        pub fn zx_thread_self() -> zx_handle_t;\n     }\n }\n \n@@ -287,3 +296,8 @@ pub fn futex_wake(futex: &AtomicU32) -> bool {\n     unsafe { zircon::zx_futex_wake(futex, 1) };\n     false\n }\n+\n+#[cfg(target_os = \"fuchsia\")]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    unsafe { zircon::zx_futex_wake(futex, u32::MAX) };\n+}"}, {"sha": "ce427599c3bddc9ace0a1add4647dd8d51521a82", "filename": "library/std/src/sys/unix/locks/fuchsia_mutex.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs?ref=c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "patch": "@@ -0,0 +1,165 @@\n+//! A priority inheriting mutex for Fuchsia.\n+//!\n+//! This is a port of the [mutex in Fuchsia's libsync]. Contrary to the original,\n+//! it does not abort the process when reentrant locking is detected, but deadlocks.\n+//!\n+//! Priority inheritance is achieved by storing the owning thread's handle in an\n+//! atomic variable. Fuchsia's futex operations support setting an owner thread\n+//! for a futex, which can boost that thread's priority while the futex is waited\n+//! upon.\n+//!\n+//! libsync is licenced under the following BSD-style licence:\n+//!\n+//! Copyright 2016 The Fuchsia Authors.\n+//!\n+//! Redistribution and use in source and binary forms, with or without\n+//! modification, are permitted provided that the following conditions are\n+//! met:\n+//!\n+//!    * Redistributions of source code must retain the above copyright\n+//!      notice, this list of conditions and the following disclaimer.\n+//!    * Redistributions in binary form must reproduce the above\n+//!      copyright notice, this list of conditions and the following\n+//!      disclaimer in the documentation and/or other materials provided\n+//!      with the distribution.\n+//!\n+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//! \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+//! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+//! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+//! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+//! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+//! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+//! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+//! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+//! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//!\n+//! [mutex in Fuchsia's libsync]: https://cs.opensource.google/fuchsia/fuchsia/+/main:zircon/system/ulib/sync/mutex.c\n+\n+use crate::sync::atomic::{\n+    AtomicU32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::zircon::{\n+    zx_futex_wait, zx_futex_wake_single_owner, zx_handle_t, zx_thread_self, ZX_ERR_BAD_HANDLE,\n+    ZX_ERR_BAD_STATE, ZX_ERR_INVALID_ARGS, ZX_ERR_TIMED_OUT, ZX_ERR_WRONG_TYPE, ZX_OK,\n+    ZX_TIME_INFINITE,\n+};\n+\n+// The lowest two bits of a `zx_handle_t` are always set, so the lowest bit is used to mark the\n+// mutex as contested by clearing it.\n+const CONTESTED_BIT: u32 = 1;\n+// This can never be a valid `zx_handle_t`.\n+const UNLOCKED: u32 = 0;\n+\n+pub type MovableMutex = Mutex;\n+\n+pub struct Mutex {\n+    futex: AtomicU32,\n+}\n+\n+#[inline]\n+fn to_state(owner: zx_handle_t) -> u32 {\n+    owner\n+}\n+\n+#[inline]\n+fn to_owner(state: u32) -> zx_handle_t {\n+    state | CONTESTED_BIT\n+}\n+\n+#[inline]\n+fn is_contested(state: u32) -> bool {\n+    state & CONTESTED_BIT == 0\n+}\n+\n+#[inline]\n+fn mark_contested(state: u32) -> u32 {\n+    state & !CONTESTED_BIT\n+}\n+\n+impl Mutex {\n+    #[inline]\n+    pub const fn new() -> Mutex {\n+        Mutex { futex: AtomicU32::new(UNLOCKED) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let thread_self = zx_thread_self();\n+        self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed).is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let thread_self = zx_thread_self();\n+        if let Err(state) =\n+            self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed)\n+        {\n+            self.lock_contested(state, thread_self);\n+        }\n+    }\n+\n+    #[cold]\n+    fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n+        let owned_state = mark_contested(to_state(thread_self));\n+        loop {\n+            // Mark the mutex as contested if it is not already.\n+            let contested = mark_contested(state);\n+            if is_contested(state)\n+                || self.futex.compare_exchange(state, contested, Relaxed, Relaxed).is_ok()\n+            {\n+                // The mutex has been marked as contested, wait for the state to change.\n+                unsafe {\n+                    match zx_futex_wait(\n+                        &self.futex,\n+                        AtomicU32::new(contested),\n+                        to_owner(state),\n+                        ZX_TIME_INFINITE,\n+                    ) {\n+                        ZX_OK | ZX_ERR_BAD_STATE | ZX_ERR_TIMED_OUT => (),\n+                        // Note that if a thread handle is reused after its associated thread\n+                        // exits without unlocking the mutex, an arbitrary thread's priority\n+                        // could be boosted by the wait, but there is currently no way to\n+                        // prevent that.\n+                        ZX_ERR_INVALID_ARGS | ZX_ERR_BAD_HANDLE | ZX_ERR_WRONG_TYPE => {\n+                            panic!(\n+                                \"either the current thread is trying to lock a mutex it has\n+                                already locked, or the previous owner did not unlock the mutex\n+                                before exiting\"\n+                            )\n+                        }\n+                        error => panic!(\"unexpected error in zx_futex_wait: {error}\"),\n+                    }\n+                }\n+            }\n+\n+            // The state has changed or a wakeup occured, try to lock the mutex.\n+            match self.futex.compare_exchange(UNLOCKED, owned_state, Acquire, Relaxed) {\n+                Ok(_) => return,\n+                Err(updated) => state = updated,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        if is_contested(self.futex.swap(UNLOCKED, Release)) {\n+            // The woken thread will mark the mutex as contested again,\n+            // and return here, waking until there are no waiters left,\n+            // in which case this is a noop.\n+            self.wake();\n+        }\n+    }\n+\n+    #[cold]\n+    fn wake(&self) {\n+        unsafe {\n+            zx_futex_wake_single_owner(&self.futex);\n+        }\n+    }\n+}"}, {"sha": "c0576c17880e1127f94add57997e2c9862c33b68", "filename": "library/std/src/sys/unix/locks/futex_condvar.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs?ref=c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "patch": "@@ -0,0 +1,58 @@\n+use super::Mutex;\n+use crate::sync::atomic::{AtomicU32, Ordering::Relaxed};\n+use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+use crate::time::Duration;\n+\n+pub type MovableCondvar = Condvar;\n+\n+pub struct Condvar {\n+    // The value of this atomic is simply incremented on every notification.\n+    // This is used by `.wait()` to not miss any notifications after\n+    // unlocking the mutex and before waiting for notifications.\n+    futex: AtomicU32,\n+}\n+\n+impl Condvar {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { futex: AtomicU32::new(0) }\n+    }\n+\n+    // All the memory orderings here are `Relaxed`,\n+    // because synchronization is done by unlocking and locking the mutex.\n+\n+    pub unsafe fn notify_one(&self) {\n+        self.futex.fetch_add(1, Relaxed);\n+        futex_wake(&self.futex);\n+    }\n+\n+    pub unsafe fn notify_all(&self) {\n+        self.futex.fetch_add(1, Relaxed);\n+        futex_wake_all(&self.futex);\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        self.wait_optional_timeout(mutex, None);\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, timeout: Duration) -> bool {\n+        self.wait_optional_timeout(mutex, Some(timeout))\n+    }\n+\n+    unsafe fn wait_optional_timeout(&self, mutex: &Mutex, timeout: Option<Duration>) -> bool {\n+        // Examine the notification counter _before_ we unlock the mutex.\n+        let futex_value = self.futex.load(Relaxed);\n+\n+        // Unlock the mutex before going to sleep.\n+        mutex.unlock();\n+\n+        // Wait, but only if there hasn't been any\n+        // notification since we unlocked the mutex.\n+        let r = futex_wait(&self.futex, futex_value, timeout);\n+\n+        // Lock the mutex again.\n+        mutex.lock();\n+\n+        r\n+    }\n+}"}, {"sha": "99ba86e5f996dce0bb445c5e12c99d494b441fcf", "filename": "library/std/src/sys/unix/locks/futex_mutex.rs", "status": "renamed", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs?ref=c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "patch": "@@ -2,11 +2,9 @@ use crate::sync::atomic::{\n     AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n-use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n-use crate::time::Duration;\n+use crate::sys::futex::{futex_wait, futex_wake};\n \n pub type MovableMutex = Mutex;\n-pub type MovableCondvar = Condvar;\n \n pub struct Mutex {\n     /// 0: unlocked\n@@ -101,55 +99,3 @@ impl Mutex {\n         futex_wake(&self.futex);\n     }\n }\n-\n-pub struct Condvar {\n-    // The value of this atomic is simply incremented on every notification.\n-    // This is used by `.wait()` to not miss any notifications after\n-    // unlocking the mutex and before waiting for notifications.\n-    futex: AtomicU32,\n-}\n-\n-impl Condvar {\n-    #[inline]\n-    pub const fn new() -> Self {\n-        Self { futex: AtomicU32::new(0) }\n-    }\n-\n-    // All the memory orderings here are `Relaxed`,\n-    // because synchronization is done by unlocking and locking the mutex.\n-\n-    pub unsafe fn notify_one(&self) {\n-        self.futex.fetch_add(1, Relaxed);\n-        futex_wake(&self.futex);\n-    }\n-\n-    pub unsafe fn notify_all(&self) {\n-        self.futex.fetch_add(1, Relaxed);\n-        futex_wake_all(&self.futex);\n-    }\n-\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.wait_optional_timeout(mutex, None);\n-    }\n-\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, timeout: Duration) -> bool {\n-        self.wait_optional_timeout(mutex, Some(timeout))\n-    }\n-\n-    unsafe fn wait_optional_timeout(&self, mutex: &Mutex, timeout: Option<Duration>) -> bool {\n-        // Examine the notification counter _before_ we unlock the mutex.\n-        let futex_value = self.futex.load(Relaxed);\n-\n-        // Unlock the mutex before going to sleep.\n-        mutex.unlock();\n-\n-        // Wait, but only if there hasn't been any\n-        // notification since we unlocked the mutex.\n-        let r = futex_wait(&self.futex, futex_value, timeout);\n-\n-        // Lock the mutex again.\n-        mutex.lock();\n-\n-        r\n-    }\n-}", "previous_filename": "library/std/src/sys/unix/locks/futex.rs"}, {"sha": "f5f92f693583003d2cc590fb802a73905b1b3b5f", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5df2f02d32b48c64ee160ddb4a98edc5ea01888/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=c5df2f02d32b48c64ee160ddb4a98edc5ea01888", "patch": "@@ -7,10 +7,19 @@ cfg_if::cfg_if! {\n         target_os = \"openbsd\",\n         target_os = \"dragonfly\",\n     ))] {\n-        mod futex;\n+        mod futex_mutex;\n         mod futex_rwlock;\n-        pub(crate) use futex::{Mutex, MovableMutex, MovableCondvar};\n+        mod futex_condvar;\n+        pub(crate) use futex_mutex::{Mutex, MovableMutex};\n         pub(crate) use futex_rwlock::{RwLock, MovableRwLock};\n+        pub(crate) use futex_condvar::MovableCondvar;\n+    } else if #[cfg(target_os = \"fuchsia\")] {\n+        mod fuchsia_mutex;\n+        mod futex_rwlock;\n+        mod futex_condvar;\n+        pub(crate) use fuchsia_mutex::{Mutex, MovableMutex};\n+        pub(crate) use futex_rwlock::{RwLock, MovableRwLock};\n+        pub(crate) use futex_condvar::MovableCondvar;\n     } else {\n         mod pthread_mutex;\n         mod pthread_rwlock;"}]}