{"sha": "f83c45e3671a47100275aa3aff65e6436a716000", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4M2M0NWUzNjcxYTQ3MTAwMjc1YWEzYWZmNjVlNjQzNmE3MTYwMDA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-17T06:01:01Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-17T06:08:40Z"}, "message": "Turn invalid panics into Results and rename fns.", "tree": {"sha": "8f58b8485a310ca23011c1de48dff5570ea9b4ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f58b8485a310ca23011c1de48dff5570ea9b4ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83c45e3671a47100275aa3aff65e6436a716000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83c45e3671a47100275aa3aff65e6436a716000", "html_url": "https://github.com/rust-lang/rust/commit/f83c45e3671a47100275aa3aff65e6436a716000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83c45e3671a47100275aa3aff65e6436a716000/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33f97feafbac2a3dc85f210d13a93af42f905f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/33f97feafbac2a3dc85f210d13a93af42f905f3f", "html_url": "https://github.com/rust-lang/rust/commit/33f97feafbac2a3dc85f210d13a93af42f905f3f"}], "stats": {"total": 172, "additions": 82, "deletions": 90}, "files": [{"sha": "b50684283c8402ea1c245c09e70b3bfae0e66aa3", "filename": "src/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=f83c45e3671a47100275aa3aff65e6436a716000", "patch": "@@ -17,14 +17,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         use value::PrimValKind::*;\n         match kind {\n-            F32 => self.cast_float(val.to_f32() as f64, dest_ty),\n-            F64 => self.cast_float(val.to_f64(), dest_ty),\n+            F32 => self.cast_float(val.to_f32()? as f64, dest_ty),\n+            F64 => self.cast_float(val.to_f64()?, dest_ty),\n \n             I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits() as i64, dest_ty),\n \n             Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits(), dest_ty, false),\n \n-            FnPtr | Ptr => self.cast_ptr(val.to_ptr(), dest_ty),\n+            FnPtr | Ptr => self.cast_ptr(val.to_ptr()?, dest_ty),\n         }\n     }\n "}, {"sha": "1ff526654cafd15dcaff66397368803fcf3e2d26", "filename": "src/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f83c45e3671a47100275aa3aff65e6436a716000/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c45e3671a47100275aa3aff65e6436a716000/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=f83c45e3671a47100275aa3aff65e6436a716000", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n-                let n = self.value_to_primval(n_ptr, usize)?.to_u64();\n+                let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n                 assert!(n < len);\n                 let ptr = base_ptr.offset(n * elem_size);\n                 (ptr, LvalueExtra::None)"}, {"sha": "4ef1ee86ce0ecd1415d9ad3e56e89519361bde4e", "filename": "src/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f83c45e3671a47100275aa3aff65e6436a716000/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c45e3671a47100275aa3aff65e6436a716000/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=f83c45e3671a47100275aa3aff65e6436a716000", "patch": "@@ -142,8 +142,8 @@ pub fn binary_op<'tcx>(\n     // If the pointers are into the same allocation, fall through to the more general match\n     // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n     // in this case.\n-    let left_ptr = left.to_ptr();\n-    let right_ptr = right.to_ptr();\n+    let left_ptr = left.to_ptr()?;\n+    let right_ptr = right.to_ptr()?;\n     if left_ptr.alloc_id != right_ptr.alloc_id {\n         return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n     }"}, {"sha": "1ae6ade00097225216ea30b49dc95c9649824559", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=f83c45e3671a47100275aa3aff65e6436a716000", "patch": "@@ -45,14 +45,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64();\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64()?;\n                 let new_ptr = ptr.signed_offset(offset);\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n             \"assume\" => {\n                 let bool = self.tcx.types.bool;\n-                let cond = self.value_to_primval(arg_vals[0], bool)?.try_as_bool()?;\n+                let cond = self.value_to_primval(arg_vals[0], bool)?.to_bool()?;\n                 if !cond { return Err(EvalError::AssumptionNotHeld); }\n             }\n \n@@ -152,7 +152,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_align = self.type_align(elem_ty)?;\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n-                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64();\n+                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 self.memory.copy(src, dest, count * elem_size, elem_align)?;\n             }\n \n@@ -180,12 +180,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr_ty = self.tcx.mk_mut_ptr(ty);\n                 let lvalue = match self.follow_by_ref_value(arg_vals[0], ptr_ty)? {\n                     Value::ByRef(_) => bug!(\"follow_by_ref_value returned ByRef\"),\n-                    Value::ByVal(value) => Lvalue::from_ptr(value.to_ptr()),\n+                    Value::ByVal(value) => Lvalue::from_ptr(value.to_ptr()?),\n                     Value::ByValPair(ptr, extra) => Lvalue::Ptr {\n-                        ptr: ptr.to_ptr(),\n+                        ptr: ptr.to_ptr()?,\n                         extra: match self.tcx.struct_tail(ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.try_as_uint()?),\n+                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n                             _ => bug!(\"invalid fat pointer type: {}\", ptr_ty),\n                         },\n                     },\n@@ -204,12 +204,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"fabsf32\" => {\n-                let f = self.value_to_primval(arg_vals[2], f32)?.to_f32();\n+                let f = self.value_to_primval(arg_vals[2], f32)?.to_f32()?;\n                 self.write_primval(dest, PrimVal::from_f32(f.abs()), dest_ty)?;\n             }\n \n             \"fabsf64\" => {\n-                let f = self.value_to_primval(arg_vals[2], f64)?.to_f64();\n+                let f = self.value_to_primval(arg_vals[2], f64)?.to_f64()?;\n                 self.write_primval(dest, PrimVal::from_f64(f.abs()), dest_ty)?;\n             }\n \n@@ -288,7 +288,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let pointee_ty = substs.type_at(0);\n                 // FIXME: assuming here that type size is < i64::max_value()\n                 let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64();\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64()?;\n \n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.signed_offset(offset * pointee_size);\n@@ -308,24 +308,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"powif32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32();\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64();\n+                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64()?;\n                 self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)), dest_ty)?;\n             }\n \n             \"powif64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64();\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64();\n+                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64()?;\n                 self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)), dest_ty)?;\n             }\n \n             \"sqrtf32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32();\n+                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n                 self.write_primval(dest, PrimVal::from_f32(f.sqrt()), dest_ty)?;\n             }\n \n             \"sqrtf64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64();\n+                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n                 self.write_primval(dest, PrimVal::from_f64(f.sqrt()), dest_ty)?;\n             }\n "}, {"sha": "7a67f56debf537bcf5ed9a51d86050605c2c3824", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=f83c45e3671a47100275aa3aff65e6436a716000", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Goto { target } => self.goto_block(target),\n \n             If { ref cond, targets: (then_target, else_target) } => {\n-                let cond_val = self.eval_operand_to_primval(cond)?.try_as_bool()?;\n+                let cond_val = self.eval_operand_to_primval(cond)?.to_bool()?;\n                 self.goto_block(if cond_val { then_target } else { else_target });\n             }\n \n@@ -88,7 +88,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n-                        let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr();\n+                        let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n                         let (def_id, substs, abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         let bare_sig = self.tcx.erase_late_bound_regions_and_normalize(&bare_fn_ty.sig);\n                         let bare_sig = self.tcx.erase_regions(&bare_sig);\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n-                let cond_val = self.eval_operand_to_primval(cond)?.try_as_bool()?;\n+                let cond_val = self.eval_operand_to_primval(cond)?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n@@ -141,10 +141,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let span = terminator.source_info.span;\n                             let len = self.eval_operand_to_primval(len)\n                                 .expect(\"can't eval len\")\n-                                .to_u64();\n+                                .to_u64()?;\n                             let index = self.eval_operand_to_primval(index)\n                                 .expect(\"can't eval index\")\n-                                .to_u64();\n+                                .to_u64()?;\n                             Err(EvalError::ArrayIndexOutOfBounds(span, len, index))\n                         },\n                         mir::AssertMessage::Math(ref err) =>\n@@ -333,32 +333,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match &link_name[..] {\n             \"__rust_allocate\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64();\n-                let align = self.value_to_primval(args[1], usize)?.to_u64();\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let ptr = self.memory.allocate(size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n             \"__rust_deallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n                 // FIXME: insert sanity check for size and align?\n-                let _old_size = self.value_to_primval(args[1], usize)?.to_u64();\n-                let _align = self.value_to_primval(args[2], usize)?.to_u64();\n+                let _old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let _align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 self.memory.deallocate(ptr)?;\n             },\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n-                let size = self.value_to_primval(args[2], usize)?.to_u64();\n-                let align = self.value_to_primval(args[3], usize)?.to_u64();\n+                let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n             \"memcmp\" => {\n                 let left = args[0].read_ptr(&self.memory)?;\n                 let right = args[1].read_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64();\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -377,13 +377,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"memchr\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64() as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64();\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64);\n-                    self.write_value(Value::ByVal(PrimVal::from_ptr(new_ptr)), dest, dest_ty)?;\n+                    self.write_value(Value::ByVal(PrimVal::Ptr(new_ptr)), dest, dest_ty)?;\n                 } else {\n-                    self.write_value(Value::ByVal(PrimVal::new(0)), dest, dest_ty)?;\n+                    self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n                 }\n             }\n \n@@ -393,12 +393,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     info!(\"ignored env var request for `{:?}`\", ::std::str::from_utf8(name));\n                 }\n-                self.write_value(Value::ByVal(PrimVal::new(0)), dest, dest_ty)?;\n+                self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n             }\n \n             // unix panic code inside libstd will read the return value of this function\n             \"pthread_rwlock_rdlock\" => {\n-                self.write_primval(dest, PrimVal::new(0), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             }\n \n             link_name if link_name.starts_with(\"pthread_\") => {\n@@ -594,14 +594,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n                     Value::ByVal(ptr) => {\n                         assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.to_ptr();\n+                        let contents_ptr = ptr.to_ptr()?;\n                         self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n                     },\n                     Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.to_ptr();\n+                        let ptr = prim_ptr.to_ptr()?;\n                         let extra = match self.tcx.struct_tail(contents_ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.try_as_uint()?),\n+                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n                             _ => bug!(\"invalid fat pointer type: {}\", ty),\n                         };\n                         self.drop("}, {"sha": "797723ecca65a60ed590d64cd9faf8c46f85e19a", "filename": "src/value.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c45e3671a47100275aa3aff65e6436a716000/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=f83c45e3671a47100275aa3aff65e6436a716000", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n-            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.to_ptr()),\n+            ByVal(ptr) | ByValPair(ptr, _) => ptr.to_ptr(),\n         }\n     }\n \n@@ -94,7 +94,7 @@ impl<'a, 'tcx: 'a> Value {\n                 Ok((ptr, vtable))\n             }\n \n-            ByValPair(ptr, vtable) => Ok((ptr.to_ptr(), vtable.to_ptr())),\n+            ByValPair(ptr, vtable) => Ok((ptr.to_ptr()?, vtable.to_ptr()?)),\n \n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n@@ -109,18 +109,18 @@ impl<'a, 'tcx: 'a> Value {\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {\n-                Ok((ptr.to_ptr(), val.try_as_uint()?))\n+                Ok((ptr.to_ptr()?, val.to_u64()?))\n             },\n             _ => unimplemented!(),\n         }\n     }\n }\n \n-impl PrimVal {\n+impl<'tcx> PrimVal {\n     // FIXME(solson): Remove this. It's a temporary function to aid refactoring, but it shouldn't\n     // stick around with this name.\n-    pub fn bits(&self) -> u64 {\n-        match *self {\n+    pub fn bits(self) -> u64 {\n+        match self {\n             PrimVal::Bytes(b) => b,\n             PrimVal::Ptr(p) => p.offset,\n             PrimVal::Undef => panic!(\".bits()() on PrimVal::Undef\"),\n@@ -129,20 +129,20 @@ impl PrimVal {\n \n     // FIXME(solson): Remove this. It's a temporary function to aid refactoring, but it shouldn't\n     // stick around with this name.\n-    pub fn relocation(&self) -> Option<AllocId> {\n-        if let PrimVal::Ptr(ref p) = *self {\n+    pub fn relocation(self) -> Option<AllocId> {\n+        if let PrimVal::Ptr(ref p) = self {\n             Some(p.alloc_id)\n         } else {\n             None\n         }\n     }\n \n-    pub fn from_bool(b: bool) -> Self {\n-        PrimVal::Bytes(b as u64)\n+    pub fn from_uint(n: u64) -> Self {\n+        PrimVal::Bytes(n)\n     }\n \n-    pub fn from_char(c: char) -> Self {\n-        PrimVal::Bytes(c as u64)\n+    pub fn from_int(n: i64) -> Self {\n+        PrimVal::Bytes(n as u64)\n     }\n \n     pub fn from_f32(f: f32) -> Self {\n@@ -153,56 +153,48 @@ impl PrimVal {\n         PrimVal::Bytes(f64_to_bits(f))\n     }\n \n-    pub fn from_uint(n: u64) -> Self {\n-        PrimVal::Bytes(n)\n-    }\n-\n-    pub fn from_int(n: i64) -> Self {\n-        PrimVal::Bytes(n as u64)\n+    pub fn from_bool(b: bool) -> Self {\n+        PrimVal::Bytes(b as u64)\n     }\n \n-    pub fn to_f32(self) -> f32 {\n-        assert!(self.relocation().is_none());\n-        bits_to_f32(self.bits())\n+    pub fn from_char(c: char) -> Self {\n+        PrimVal::Bytes(c as u64)\n     }\n \n-    pub fn to_f64(self) -> f64 {\n-        assert!(self.relocation().is_none());\n-        bits_to_f64(self.bits())\n+    fn to_bytes(self) -> EvalResult<'tcx, u64> {\n+        match self {\n+            PrimVal::Bytes(b) => Ok(b),\n+            PrimVal::Ptr(p) => p.to_int(),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n     }\n \n-    pub fn to_ptr(self) -> Pointer {\n-        self.relocation().map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits())\n-        }).unwrap_or_else(|| Pointer::from_int(self.bits()))\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+        match self {\n+            PrimVal::Bytes(b) => Ok(Pointer::from_int(b)),\n+            PrimVal::Ptr(p) => Ok(p),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n     }\n \n-    pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n-        self.to_ptr().to_int()\n+    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n+        self.to_bytes()\n     }\n \n-    pub fn to_u64(self) -> u64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as u64;\n-        }\n-        self.bits()\n+    pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n+        self.to_bytes().map(|b| b as i64)\n     }\n \n-    pub fn to_i64(self) -> i64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as i64;\n-        }\n-        self.bits() as i64\n+    pub fn to_f32(self) -> EvalResult<'tcx, f32> {\n+        self.to_bytes().map(bits_to_f32)\n     }\n \n-    pub fn try_as_ptr(self) -> Option<Pointer> {\n-        self.relocation().map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits())\n-        })\n+    pub fn to_f64(self) -> EvalResult<'tcx, f64> {\n+        self.to_bytes().map(bits_to_f64)\n     }\n \n-    pub fn try_as_bool<'tcx>(self) -> EvalResult<'tcx, bool> {\n-        match self.bits() {\n+    pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n+        match self.to_bytes()? {\n             0 => Ok(false),\n             1 => Ok(true),\n             _ => Err(EvalError::InvalidBool),"}]}