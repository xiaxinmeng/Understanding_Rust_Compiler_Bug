{"sha": "bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZGZhMWNlMWQ3Mjc1YmJkYjg5ZWNiMTE2YmY3NjVmMTliMjA0ZTE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T01:05:00Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc_typeck: use Substs::from_generics instead of manually building them.", "tree": {"sha": "6fea15f842ff937a62fa85d5250e2e75b8ca094e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fea15f842ff937a62fa85d5250e2e75b8ca094e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "html_url": "https://github.com/rust-lang/rust/commit/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b25f08512eab11aec151d8f718fca0d8840d0c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b25f08512eab11aec151d8f718fca0d8840d0c0", "html_url": "https://github.com/rust-lang/rust/commit/4b25f08512eab11aec151d8f718fca0d8840d0c0"}], "stats": {"total": 835, "additions": 300, "deletions": 535}, "files": [{"sha": "1e360cd43da12db63d6ed60ab6ceacebe61266d5", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "patch": "@@ -1234,13 +1234,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(ty_var_id)\n     }\n \n-    pub fn region_vars_for_defs(&self,\n-                                span: Span,\n-                                defs: &[ty::RegionParameterDef])\n-                                -> Vec<ty::Region> {\n-        defs.iter().map(|def| self.region_var_for_def(span, def)).collect()\n-    }\n-\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_generics(&self,"}, {"sha": "11ca012fdedaba329a27aa118a23d183476a6d29", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 154, "deletions": 225, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "patch": "@@ -55,7 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use rustc::ty::subst::{TypeSpace, SelfSpace, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -350,64 +350,77 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         param_mode: PathParamMode,\n         decl_generics: &ty::Generics<'tcx>,\n         item_segment: &hir::PathSegment)\n-        -> Substs<'tcx>\n+        -> &'tcx Substs<'tcx>\n     {\n         let tcx = self.tcx();\n \n-        // ast_path_substs() is only called to convert paths that are\n-        // known to refer to traits, types, or structs. In these cases,\n-        // all type parameters defined for the item being referenced will\n-        // be in the TypeSpace or SelfSpace.\n-        //\n-        // Note: in the case of traits, the self parameter is also\n-        // defined, but we don't currently create a `type_param_def` for\n-        // `Self` because it is implicit.\n-        assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n-        assert!(decl_generics.types.all(|d| d.space != FnSpace));\n-\n-        let (regions, types, assoc_bindings) = match item_segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                self.convert_angle_bracketed_parameters(rscope, span, decl_generics, data)\n-            }\n+        match item_segment.parameters {\n+            hir::AngleBracketedParameters(_) => {}\n             hir::ParenthesizedParameters(..) => {\n                 struct_span_err!(tcx.sess, span, E0214,\n                           \"parenthesized parameters may only be used with a trait\")\n                     .span_label(span, &format!(\"only traits may use parentheses\"))\n                     .emit();\n \n-                let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-                (Substs::empty(),\n-                 ty_param_defs.iter().map(|_| tcx.types.err).collect(),\n-                 vec![])\n+                return tcx.mk_substs(Substs::from_generics(decl_generics, |_, _| {\n+                    ty::ReStatic\n+                }, |_, _| {\n+                    tcx.types.err\n+                }));\n             }\n-        };\n+        }\n+\n+        let (substs, assoc_bindings) =\n+            self.create_substs_for_ast_path(rscope,\n+                                            span,\n+                                            param_mode,\n+                                            decl_generics,\n+                                            &item_segment.parameters,\n+                                            None);\n \n         assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n \n-        self.create_substs_for_ast_path(span,\n-                                        param_mode,\n-                                        decl_generics,\n-                                        None,\n-                                        types,\n-                                        regions)\n+        substs\n     }\n \n-    fn create_region_substs(&self,\n+    /// Given the type/region arguments provided to some path (along with\n+    /// an implicit Self, if this is a trait reference) returns the complete\n+    /// set of substitutions. This may involve applying defaulted type parameters.\n+    ///\n+    /// Note that the type listing given here is *exactly* what the user provided.\n+    fn create_substs_for_ast_path(&self,\n         rscope: &RegionScope,\n         span: Span,\n+        param_mode: PathParamMode,\n         decl_generics: &ty::Generics<'tcx>,\n-        regions_provided: Vec<ty::Region>)\n-        -> Substs<'tcx>\n+        parameters: &hir::PathParameters,\n+        self_ty: Option<Ty<'tcx>>)\n+        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n         let tcx = self.tcx();\n \n+        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n+               parameters={:?})\",\n+               decl_generics, self_ty, parameters);\n+\n+        let (lifetimes, num_types_provided) = match *parameters {\n+            hir::AngleBracketedParameters(ref data) => {\n+                if param_mode == PathParamMode::Optional && data.types.is_empty() {\n+                    (&data.lifetimes[..], None)\n+                } else {\n+                    (&data.lifetimes[..], Some(data.types.len()))\n+                }\n+            }\n+            hir::ParenthesizedParameters(_) => (&[][..], Some(1))\n+        };\n+\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n-        let supplied_num_region_params = regions_provided.len();\n+        let supplied_num_region_params = lifetimes.len();\n         let regions = if expected_num_region_params == supplied_num_region_params {\n-            regions_provided\n+            lifetimes.iter().map(|l| ast_region_to_region(tcx, l)).collect()\n         } else {\n             let anon_regions =\n                 rscope.anon_regions(span, expected_num_region_params);\n@@ -423,176 +436,111 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 Err(_) => (0..expected_num_region_params).map(|_| ty::ReStatic).collect()\n             }\n         };\n-        Substs::new_type(vec![], regions)\n-    }\n \n-    /// Given the type/region arguments provided to some path (along with\n-    /// an implicit Self, if this is a trait reference) returns the complete\n-    /// set of substitutions. This may involve applying defaulted type parameters.\n-    ///\n-    /// Note that the type listing given here is *exactly* what the user provided.\n-    ///\n-    /// The `region_substs` should be the result of `create_region_substs`\n-    /// -- that is, a substitution with no types but the correct number of\n-    /// regions.\n-    fn create_substs_for_ast_path(&self,\n-        span: Span,\n-        param_mode: PathParamMode,\n-        decl_generics: &ty::Generics<'tcx>,\n-        self_ty: Option<Ty<'tcx>>,\n-        types_provided: Vec<Ty<'tcx>>,\n-        region_substs: Substs<'tcx>)\n-        -> Substs<'tcx>\n-    {\n-        let tcx = self.tcx();\n+        // If a self-type was declared, one should be provided.\n+        assert_eq!(decl_generics.types.get_self().is_some(), self_ty.is_some());\n \n-        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n-               types_provided={:?}, region_substs={:?})\",\n-               decl_generics, self_ty, types_provided,\n-               region_substs);\n-\n-        assert_eq!(region_substs.regions.len(TypeSpace), decl_generics.regions.len(TypeSpace));\n-        assert!(region_substs.types.is_empty());\n-\n-        // Convert the type parameters supplied by the user.\n-        let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-        let formal_ty_param_count = ty_param_defs.len();\n-        let required_ty_param_count = ty_param_defs.iter()\n-                                                   .take_while(|x| x.default.is_none())\n-                                                   .count();\n-\n-        let mut type_substs = self.get_type_substs_for_defs(span,\n-                                                            types_provided,\n-                                                            param_mode,\n-                                                            ty_param_defs,\n-                                                            region_substs.clone(),\n-                                                            self_ty);\n-\n-        let supplied_ty_param_count = type_substs.len();\n-        check_type_argument_count(self.tcx(), span, supplied_ty_param_count,\n-                                  required_ty_param_count, formal_ty_param_count);\n-\n-        if supplied_ty_param_count < required_ty_param_count {\n-            while type_substs.len() < required_ty_param_count {\n-                type_substs.push(tcx.types.err);\n-            }\n-        } else if supplied_ty_param_count > formal_ty_param_count {\n-            type_substs.truncate(formal_ty_param_count);\n+        // Check the number of type parameters supplied by the user.\n+        if let Some(num_provided) = num_types_provided {\n+            let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n+            check_type_argument_count(tcx, span, num_provided, ty_param_defs);\n         }\n-        assert!(type_substs.len() >= required_ty_param_count &&\n-                type_substs.len() <= formal_ty_param_count);\n \n-        let mut substs = region_substs;\n+        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n+        let default_needs_object_self = |p: &ty::TypeParameterDef<'tcx>| {\n+            if let Some(ref default) = p.default {\n+                if is_object && default.has_self_ty() {\n+                    // There is no suitable inference default for a type parameter\n+                    // that references self, in an object type.\n+                    return true;\n+                }\n+            }\n \n-        // If a self-type was declared, one should be provided.\n-        assert_eq!(decl_generics.types.get_self().is_some(), self_ty.is_some());\n-        substs.types.extend(SelfSpace, self_ty.into_iter());\n-        substs.types.extend(TypeSpace, type_substs.into_iter());\n+            false\n+        };\n+\n+        let mut output_assoc_binding = None;\n+        let substs = Substs::from_generics(decl_generics, |def, _| {\n+            assert_eq!(def.space, TypeSpace);\n+            regions[def.index as usize]\n+        }, |def, substs| {\n+            assert!(def.space == SelfSpace || def.space == TypeSpace);\n+            let i = def.index as usize;\n+            if def.space == SelfSpace {\n+                // Self, which must have been provided.\n+                assert_eq!(i, 0);\n+                self_ty.expect(\"Self type parameter missing\")\n+            } else if num_types_provided.map_or(false, |n| i < n) {\n+                // A provided type parameter.\n+                match *parameters {\n+                    hir::AngleBracketedParameters(ref data) => {\n+                        self.ast_ty_arg_to_ty(rscope, Some(def), substs, &data.types[i])\n+                    }\n+                    hir::ParenthesizedParameters(ref data) => {\n+                        assert_eq!(i, 0);\n+                        let (ty, assoc) =\n+                            self.convert_parenthesized_parameters(rscope, substs, data);\n+                        output_assoc_binding = Some(assoc);\n+                        ty\n+                    }\n+                }\n+            } else if num_types_provided.is_none() {\n+                // No type parameters were provided, we can infer all.\n+                let ty_var = if !default_needs_object_self(def) {\n+                    self.ty_infer_for_def(def, substs, span)\n+                } else {\n+                    self.ty_infer(span)\n+                };\n+                ty_var\n+            } else if let Some(default) = def.default {\n+                // No type parameter provided, but a default exists.\n \n-        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n-        let actual_supplied_ty_param_count = substs.types.len(TypeSpace);\n-        for param in &ty_param_defs[actual_supplied_ty_param_count..] {\n-            let default = if let Some(default) = param.default {\n                 // If we are converting an object type, then the\n                 // `Self` parameter is unknown. However, some of the\n                 // other type parameters may reference `Self` in their\n                 // defaults. This will lead to an ICE if we are not\n                 // careful!\n-                if is_object && default.has_self_ty() {\n+                if default_needs_object_self(def) {\n                     span_err!(tcx.sess, span, E0393,\n                               \"the type parameter `{}` must be explicitly specified \\\n                                in an object type because its default value `{}` references \\\n                                the type `Self`\",\n-                              param.name,\n+                              def.name,\n                               default);\n                     tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    default.subst_spanned(tcx, &substs, Some(span))\n+                    default.subst_spanned(tcx, substs, Some(span))\n                 }\n             } else {\n-                span_bug!(span, \"extra parameter without default\");\n-            };\n-            substs.types.push(TypeSpace, default);\n-        }\n-\n-        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n-               decl_generics, self_ty, substs);\n-\n-        substs\n-    }\n-\n-    /// Returns types_provided if it is not empty, otherwise populating the\n-    /// type parameters with inference variables as appropriate.\n-    fn get_type_substs_for_defs(&self,\n-                                span: Span,\n-                                types_provided: Vec<Ty<'tcx>>,\n-                                param_mode: PathParamMode,\n-                                ty_param_defs: &[ty::TypeParameterDef<'tcx>],\n-                                mut substs: Substs<'tcx>,\n-                                self_ty: Option<Ty<'tcx>>)\n-                                -> Vec<Ty<'tcx>>\n-    {\n-        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n-        let use_default = |p: &ty::TypeParameterDef<'tcx>| {\n-            if let Some(ref default) = p.default {\n-                if is_object && default.has_self_ty() {\n-                    // There is no suitable inference default for a type parameter\n-                    // that references self, in an object type.\n-                    return false;\n-                }\n+                // We've already errored above about the mismatch.\n+                tcx.types.err\n             }\n+        });\n \n-            true\n+        let assoc_bindings = match *parameters {\n+            hir::AngleBracketedParameters(ref data) => {\n+                data.bindings.iter().map(|b| {\n+                    ConvertedBinding {\n+                        item_name: b.name,\n+                        ty: self.ast_ty_to_ty(rscope, &b.ty),\n+                        span: b.span\n+                    }\n+                }).collect()\n+            }\n+            hir::ParenthesizedParameters(ref data) => {\n+                vec![output_assoc_binding.unwrap_or_else(|| {\n+                    // This is an error condition, but we should\n+                    // get the associated type binding anyway.\n+                    self.convert_parenthesized_parameters(rscope, &substs, data).1\n+                })]\n+            }\n         };\n \n-        if param_mode == PathParamMode::Optional && types_provided.is_empty() {\n-            ty_param_defs.iter().map(|def| {\n-                let ty_var = if use_default(def) {\n-                    self.ty_infer_for_def(def, &substs, span)\n-                } else {\n-                    self.ty_infer(span)\n-                };\n-                substs.types.push(def.space, ty_var);\n-                ty_var\n-            }).collect()\n-        } else {\n-            types_provided\n-        }\n-    }\n+        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n+               decl_generics, self_ty, substs);\n \n-    fn convert_angle_bracketed_parameters(&self,\n-                                          rscope: &RegionScope,\n-                                          span: Span,\n-                                          decl_generics: &ty::Generics<'tcx>,\n-                                          data: &hir::AngleBracketedParameterData)\n-                                          -> (Substs<'tcx>,\n-                                              Vec<Ty<'tcx>>,\n-                                              Vec<ConvertedBinding<'tcx>>)\n-    {\n-        let regions: Vec<_> =\n-            data.lifetimes.iter()\n-                          .map(|l| ast_region_to_region(self.tcx(), l))\n-                          .collect();\n-\n-        let region_substs =\n-            self.create_region_substs(rscope, span, decl_generics, regions);\n-\n-        let types: Vec<_> =\n-            data.types.iter()\n-                      .enumerate()\n-                      .map(|(i,t)| self.ast_ty_arg_to_ty(rscope, decl_generics,\n-                                                         i, &region_substs, t))\n-                      .collect();\n-\n-        let assoc_bindings: Vec<_> =\n-            data.bindings.iter()\n-                         .map(|b| ConvertedBinding { item_name: b.name,\n-                                                     ty: self.ast_ty_to_ty(rscope, &b.ty),\n-                                                     span: b.span })\n-                         .collect();\n-\n-        (region_substs, types, assoc_bindings)\n+        (tcx.mk_substs(substs), assoc_bindings)\n     }\n \n     /// Returns the appropriate lifetime to use for any output lifetimes\n@@ -657,29 +605,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn convert_parenthesized_parameters(&self,\n                                         rscope: &RegionScope,\n-                                        span: Span,\n-                                        decl_generics: &ty::Generics<'tcx>,\n+                                        region_substs: &Substs<'tcx>,\n                                         data: &hir::ParenthesizedParameterData)\n-                                        -> (Substs<'tcx>,\n-                                            Vec<Ty<'tcx>>,\n-                                            Vec<ConvertedBinding<'tcx>>)\n+                                        -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n-        let region_substs =\n-            self.create_region_substs(rscope, span, decl_generics, Vec::new());\n-\n         let anon_scope = rscope.anon_type_scope();\n         let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n-        let inputs =\n-            data.inputs.iter()\n-                       .map(|a_t| self.ast_ty_arg_to_ty(&binding_rscope, decl_generics,\n-                                                        0, &region_substs, a_t))\n-                       .collect::<Vec<Ty<'tcx>>>();\n-\n+        let inputs: Vec<_> = data.inputs.iter().map(|a_t| {\n+            self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n+        }).collect();\n         let input_params = vec![String::new(); inputs.len()];\n         let implied_output_region = self.find_implied_output_region(&inputs, input_params);\n \n-        let input_ty = self.tcx().mk_tup(inputs);\n-\n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n                 (self.convert_ty_with_lifetime_elision(implied_output_region,\n@@ -698,7 +635,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             span: output_span\n         };\n \n-        (region_substs, vec![input_ty], vec![output_binding])\n+        (self.tcx().mk_tup(inputs), output_binding)\n     }\n \n     pub fn instantiate_poly_trait_ref(&self,\n@@ -838,8 +775,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        let (regions, types, assoc_bindings) = match trait_segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n+        match trait_segment.parameters {\n+            hir::AngleBracketedParameters(_) => {\n                 // For now, require that parenthetical notation be used\n                 // only with `Fn()` etc.\n                 if !self.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n@@ -850,10 +787,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         type parameters is subject to change. \\\n                         Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\");\n                 }\n-\n-                self.convert_angle_bracketed_parameters(rscope, span, &trait_def.generics, data)\n             }\n-            hir::ParenthesizedParameters(ref data) => {\n+            hir::ParenthesizedParameters(_) => {\n                 // For now, require that parenthetical notation be used\n                 // only with `Fn()` etc.\n                 if !self.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n@@ -862,19 +797,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                      \"\\\n                         parenthetical notation is only stable when used with `Fn`-family traits\");\n                 }\n-\n-                self.convert_parenthesized_parameters(rscope, span, &trait_def.generics, data)\n             }\n-        };\n-\n-        let substs = self.create_substs_for_ast_path(span,\n-                                                     param_mode,\n-                                                     &trait_def.generics,\n-                                                     Some(self_ty),\n-                                                     types,\n-                                                     regions);\n+        }\n \n-        (self.tcx().mk_substs(substs), assoc_bindings)\n+        self.create_substs_for_ast_path(rscope,\n+                                        span,\n+                                        param_mode,\n+                                        &trait_def.generics,\n+                                        &trait_segment.parameters,\n+                                        Some(self_ty))\n     }\n \n     fn ast_type_binding_to_poly_projection_predicate(\n@@ -1000,7 +931,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             return self.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n         }\n \n-        decl_ty.subst(self.tcx(), &substs)\n+        decl_ty.subst(self.tcx(), substs)\n     }\n \n     fn ast_ty_to_object_trait_ref(&self,\n@@ -1473,24 +1404,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// # Parameters\n     ///\n     /// * `this`, `rscope`: the surrounding context\n-    /// * `decl_generics`: the generics of the struct/enum/trait declaration being\n-    ///   referenced\n-    /// * `index`: the index of the type parameter being instantiated from the list\n-    ///   (we assume it is in the `TypeSpace`)\n+    /// * `def`: the type parameter being instantiated (if available)\n     /// * `region_substs`: a partial substitution consisting of\n     ///   only the region type parameters being supplied to this type.\n     /// * `ast_ty`: the ast representation of the type being supplied\n-    pub fn ast_ty_arg_to_ty(&self,\n-                            rscope: &RegionScope,\n-                            decl_generics: &ty::Generics<'tcx>,\n-                            index: usize,\n-                            region_substs: &Substs<'tcx>,\n-                            ast_ty: &hir::Ty)\n-                            -> Ty<'tcx>\n+    fn ast_ty_arg_to_ty(&self,\n+                        rscope: &RegionScope,\n+                        def: Option<&ty::TypeParameterDef<'tcx>>,\n+                        region_substs: &Substs<'tcx>,\n+                        ast_ty: &hir::Ty)\n+                        -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n \n-        if let Some(def) = decl_generics.types.opt_get(TypeSpace, index) {\n+        if let Some(def) = def {\n             let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n             let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n             self.ast_ty_to_ty(rscope1, ast_ty)\n@@ -2194,7 +2121,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                             let parameters = &segments[segments.len() - 1].parameters;\n                             if !parameters.types().is_empty() {\n                                 check_type_argument_count(tcx, b.trait_ref.path.span,\n-                                                          parameters.types().len(), 0, 0);\n+                                                          parameters.types().len(), &[]);\n                             }\n                             if !parameters.lifetimes().is_empty() {\n                                 report_lifetime_number_error(tcx, b.trait_ref.path.span,\n@@ -2225,7 +2152,9 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n-                             required: usize, accepted: usize) {\n+                             ty_param_defs: &[ty::TypeParameterDef]) {\n+    let accepted = ty_param_defs.len();\n+    let required = ty_param_defs.iter().take_while(|x| x.default.is_none()) .count();\n     if supplied < required {\n         let expected = if required < accepted {\n             \"expected at least\""}, {"sha": "c41bb1930d4583288fcc1e9a48f23f447e8e0236", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 144, "deletions": 301, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "patch": "@@ -88,7 +88,7 @@ use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use rustc::ty::subst::{self, Subst, Substs};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n@@ -1702,7 +1702,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      PathParamMode::Optional,\n                                                      &type_scheme.generics,\n                                                      path.segments.last().unwrap());\n-        let substs = self.tcx.mk_substs(substs);\n         debug!(\"instantiate_type_path: ty={:?} substs={:?}\", &type_scheme.ty, substs);\n         let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n         let cause = traits::ObligationCause::new(path.span, self.body_id,\n@@ -4158,7 +4157,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!segments.is_empty());\n \n         let mut ufcs_associated = None;\n-        let mut segment_spaces: Vec<_>;\n+        let mut type_segment = None;\n+        let mut fn_segment = None;\n         match def {\n             // Case 1 and 1b. Reference to a *type* or *enum variant*.\n             Def::SelfTy(..) |\n@@ -4172,40 +4172,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::TyParam(..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                segment_spaces = vec![None; segments.len() - 1];\n-                segment_spaces.push(Some(subst::TypeSpace));\n+                type_segment = segments.last();\n             }\n \n             // Case 2. Reference to a top-level value.\n             Def::Fn(..) |\n             Def::Const(..) |\n             Def::Static(..) => {\n-                segment_spaces = vec![None; segments.len() - 1];\n-                segment_spaces.push(Some(subst::FnSpace));\n-            }\n-\n-            // Case 3. Reference to a method.\n-            Def::Method(def_id) => {\n-                let container = self.tcx.impl_or_trait_item(def_id).container();\n-                match container {\n-                    ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n-                    }\n-                    ty::ImplContainer(_) => {}\n-                }\n-\n-                if segments.len() >= 2 {\n-                    segment_spaces = vec![None; segments.len() - 2];\n-                    segment_spaces.push(Some(subst::TypeSpace));\n-                    segment_spaces.push(Some(subst::FnSpace));\n-                } else {\n-                    // `<T>::method` will end up here, and so can `T::method`.\n-                    let self_ty = opt_self_ty.expect(\"UFCS sugared method missing Self\");\n-                    segment_spaces = vec![Some(subst::FnSpace)];\n-                    ufcs_associated = Some((container, self_ty));\n-                }\n+                fn_segment = segments.last();\n             }\n \n+            // Case 3. Reference to a method or associated const.\n+            Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 let container = self.tcx.impl_or_trait_item(def_id).container();\n                 match container {\n@@ -4216,15 +4194,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if segments.len() >= 2 {\n-                    segment_spaces = vec![None; segments.len() - 2];\n-                    segment_spaces.push(Some(subst::TypeSpace));\n-                    segment_spaces.push(None);\n+                    type_segment = Some(&segments[segments.len() - 2]);\n                 } else {\n-                    // `<T>::CONST` will end up here, and so can `T::CONST`.\n-                    let self_ty = opt_self_ty.expect(\"UFCS sugared const missing Self\");\n-                    segment_spaces = vec![None];\n+                    // `<T>::assoc` will end up here, and so can `T::assoc`.\n+                    let self_ty = opt_self_ty.expect(\"UFCS sugared assoc missing Self\");\n                     ufcs_associated = Some((container, self_ty));\n                 }\n+                fn_segment = segments.last();\n             }\n \n             // Other cases. Various nonsense that really shouldn't show up\n@@ -4234,71 +4210,105 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::ForeignMod(..) |\n             Def::Local(..) |\n             Def::Label(..) |\n-            Def::Upvar(..) => {\n-                segment_spaces = vec![None; segments.len()];\n-            }\n+            Def::Upvar(..) => {}\n \n             Def::Err => {\n                 self.set_tainted_by_errors();\n-                segment_spaces = vec![None; segments.len()];\n             }\n         }\n-        assert_eq!(segment_spaces.len(), segments.len());\n \n         // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n         // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n         // type parameters are not mandatory.\n         let require_type_space = opt_self_ty.is_some() && ufcs_associated.is_none();\n \n-        debug!(\"segment_spaces={:?}\", segment_spaces);\n-\n-        // Next, examine the definition, and determine how many type\n-        // parameters we expect from each space.\n-        let type_defs = &type_scheme.generics.types;\n-        let region_defs = &type_scheme.generics.regions;\n+        debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n \n         // Now that we have categorized what space the parameters for each\n         // segment belong to, let's sort out the parameters that the user\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n-        let mut substs = Substs::empty();\n-        for (&opt_space, segment) in segment_spaces.iter().zip(segments) {\n-            if let Some(space) = opt_space {\n-                self.push_explicit_parameters_from_segment_to_substs(space,\n-                                                                     span,\n-                                                                     type_defs,\n-                                                                     region_defs,\n-                                                                     segment,\n-                                                                     &mut substs);\n-            } else {\n-                self.tcx.prohibit_type_params(slice::ref_slice(segment));\n-            }\n-        }\n-        if let Some(self_ty) = opt_self_ty {\n-            if type_defs.len(subst::SelfSpace) == 1 {\n-                substs.types.push(subst::SelfSpace, self_ty);\n-            }\n-        }\n+        let poly_segments = type_segment.is_some() as usize +\n+                            fn_segment.is_some() as usize;\n+        self.tcx.prohibit_type_params(&segments[..segments.len() - poly_segments]);\n \n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        for &space in &[subst::SelfSpace, subst::TypeSpace, subst::FnSpace] {\n-            self.adjust_type_parameters(span, space, type_defs,\n-                                        require_type_space, &mut substs);\n-            assert_eq!(substs.types.len(space), type_defs.len(space));\n+        self.check_path_parameter_count(subst::TypeSpace,\n+                                        span,\n+                                        &type_scheme.generics,\n+                                        !require_type_space,\n+                                        &mut type_segment);\n+        self.check_path_parameter_count(subst::FnSpace,\n+                                        span,\n+                                        &type_scheme.generics,\n+                                        true,\n+                                        &mut fn_segment);\n+\n+        let substs = Substs::from_generics(&type_scheme.generics, |def, _| {\n+            let i = def.index as usize;\n+            let segment = match def.space {\n+                subst::SelfSpace => None,\n+                subst::TypeSpace => type_segment,\n+                subst::FnSpace => fn_segment\n+            };\n+            let lifetimes = match segment.map(|s| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => &data.lifetimes[..],\n+                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n+                None => &[]\n+            };\n \n-            self.adjust_region_parameters(span, space, region_defs, &mut substs);\n-            assert_eq!(substs.regions.len(space), region_defs.len(space));\n-        }\n+            if let Some(ast_lifetime) = lifetimes.get(i) {\n+                ast_region_to_region(self.tcx, ast_lifetime)\n+            } else {\n+                self.region_var_for_def(span, def)\n+            }\n+        }, |def, substs| {\n+            let i = def.index as usize;\n+            let segment = match def.space {\n+                subst::SelfSpace => None,\n+                subst::TypeSpace => type_segment,\n+                subst::FnSpace => fn_segment\n+            };\n+            let types = match segment.map(|s| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => &data.types[..],\n+                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n+                None => &[]\n+            };\n+            let can_omit = def.space != subst::TypeSpace || !require_type_space;\n+            let default = if can_omit && types.len() == 0 {\n+                def.default\n+            } else {\n+                None\n+            };\n+\n+            if def.space == subst::SelfSpace && opt_self_ty.is_some() {\n+                // Self, which has been provided.\n+                assert_eq!(i, 0);\n+                opt_self_ty.unwrap()\n+            } else if let Some(ast_ty) = types.get(i) {\n+                // A provided type parameter.\n+                self.to_ty(ast_ty)\n+            } else if let Some(default) = default {\n+                // No type parameter provided, but a default exists.\n+                default.subst_spanned(self.tcx, substs, Some(span))\n+            } else {\n+                // No type parameters were provided, we can infer all.\n+                // This can also be reached in some error cases:\n+                // We prefer to use inference variables instead of\n+                // TyError to let type inference recover somewhat.\n+                self.type_var_for_def(span, def, substs)\n+            }\n+        });\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n         let substs = self.tcx.mk_substs(substs);\n-        assert!(!substs.has_regions_escaping_depth(0));\n+        assert!(!substs.has_escaping_regions());\n         assert!(!type_scheme.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n@@ -4349,246 +4359,79 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty_substituted\n     }\n \n-    /// Finds the parameters that the user provided and adds them to `substs`. If too many\n-    /// parameters are provided, then reports an error and clears the output vector.\n-    ///\n-    /// We clear the output vector because that will cause the `adjust_XXX_parameters()` later to\n-    /// use inference variables. This seems less likely to lead to derived errors.\n-    ///\n-    /// Note that we *do not* check for *too few* parameters here. Due to the presence of defaults\n-    /// etc that is more complicated. I wanted however to do the reporting of *too many* parameters\n-    /// here because we can easily use the precise span of the N+1'th parameter.\n-    fn push_explicit_parameters_from_segment_to_substs(&self,\n-        space: subst::ParamSpace,\n-        span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n-        segment: &hir::PathSegment,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        match segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                self.push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n-                    space, type_defs, region_defs, data, substs);\n-            }\n-\n-            hir::ParenthesizedParameters(ref data) => {\n-                span_err!(self.tcx.sess, span, E0238,\n-                    \"parenthesized parameters may only be used with a trait\");\n-                self.push_explicit_parenthesized_parameters_from_segment_to_substs(\n-                    space, span, type_defs, data, substs);\n-            }\n-        }\n-    }\n-\n-    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(&self,\n-        space: subst::ParamSpace,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n-        data: &hir::AngleBracketedParameterData,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        {\n-            let type_count = type_defs.len(space);\n-            assert_eq!(substs.types.len(space), 0);\n-            for (i, typ) in data.types.iter().enumerate() {\n-                let t = self.to_ty(&typ);\n-                if i < type_count {\n-                    substs.types.push(space, t);\n-                } else if i == type_count {\n-                    struct_span_err!(self.tcx.sess, typ.span, E0087,\n-                                     \"too many type parameters provided: \\\n-                                      expected at most {} parameter{}, \\\n-                                      found {} parameter{}\",\n-                                     type_count,\n-                                     if type_count == 1 {\"\"} else {\"s\"},\n-                                     data.types.len(),\n-                                     if data.types.len() == 1 {\"\"} else {\"s\"})\n-                        .span_label(typ.span , &format!(\"expected {} parameter{}\",\n-                                    type_count,\n-                                    if type_count == 1 {\"\"} else {\"s\"})).emit();\n-                    substs.types.truncate(space, 0);\n-                    break;\n-                }\n+    /// Report errors if the provided parameters are too few or too many.\n+    fn check_path_parameter_count(&self,\n+                                  space: subst::ParamSpace,\n+                                  span: Span,\n+                                  generics: &ty::Generics<'tcx>,\n+                                  can_omit: bool,\n+                                  segment: &mut Option<&hir::PathSegment>) {\n+        let (lifetimes, types, bindings) = match segment.map(|s| &s.parameters) {\n+            Some(&hir::AngleBracketedParameters(ref data)) => {\n+                (&data.lifetimes[..], &data.types[..], &data.bindings[..])\n             }\n-        }\n-\n-        if !data.bindings.is_empty() {\n-            span_err!(self.tcx.sess, data.bindings[0].span, E0182,\n-                      \"unexpected binding of associated item in expression path \\\n-                       (only allowed in type paths)\");\n-        }\n-\n-        {\n-            let region_count = region_defs.len(space);\n-            assert_eq!(substs.regions.len(space), 0);\n-            for (i, lifetime) in data.lifetimes.iter().enumerate() {\n-                let r = ast_region_to_region(self.tcx, lifetime);\n-                if i < region_count {\n-                    substs.regions.push(space, r);\n-                } else if i == region_count {\n-                    span_err!(self.tcx.sess, lifetime.span, E0088,\n-                        \"too many lifetime parameters provided: \\\n-                         expected {} parameter{}, found {} parameter{}\",\n-                        region_count,\n-                        if region_count == 1 {\"\"} else {\"s\"},\n-                        data.lifetimes.len(),\n-                        if data.lifetimes.len() == 1 {\"\"} else {\"s\"});\n-                    substs.regions.truncate(space, 0);\n-                    break;\n-                }\n+            Some(&hir::ParenthesizedParameters(_)) => {\n+                span_bug!(span, \"parenthesized parameters cannot appear in ExprPath\");\n             }\n-        }\n-    }\n-\n-    /// As with\n-    /// `push_explicit_angle_bracketed_parameters_from_segment_to_substs`,\n-    /// but intended for `Foo(A,B) -> C` form. This expands to\n-    /// roughly the same thing as `Foo<(A,B),C>`. One important\n-    /// difference has to do with the treatment of anonymous\n-    /// regions, which are translated into bound regions (NYI).\n-    fn push_explicit_parenthesized_parameters_from_segment_to_substs(&self,\n-        space: subst::ParamSpace,\n-        span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        data: &hir::ParenthesizedParameterData,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        let type_count = type_defs.len(space);\n-        if type_count < 2 {\n-            span_err!(self.tcx.sess, span, E0167,\n-                      \"parenthesized form always supplies 2 type parameters, \\\n-                      but only {} parameter(s) were expected\",\n-                      type_count);\n-        }\n-\n-        let input_tys: Vec<Ty> =\n-            data.inputs.iter().map(|ty| self.to_ty(&ty)).collect();\n-\n-        let tuple_ty = self.tcx.mk_tup(input_tys);\n-\n-        if type_count >= 1 {\n-            substs.types.push(space, tuple_ty);\n-        }\n-\n-        let output_ty: Option<Ty> =\n-            data.output.as_ref().map(|ty| self.to_ty(&ty));\n-\n-        let output_ty =\n-            output_ty.unwrap_or(self.tcx.mk_nil());\n+            None => (&[][..], &[][..], &[][..])\n+        };\n \n-        if type_count >= 2 {\n-            substs.types.push(space, output_ty);\n-        }\n-    }\n+        let count = |n| {\n+            format!(\"{} parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n+        };\n \n-    fn adjust_type_parameters(&self,\n-        span: Span,\n-        space: ParamSpace,\n-        defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        require_type_space: bool,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        let provided_len = substs.types.len(space);\n-        let desired = defs.get_slice(space);\n-        let required_len = desired.iter()\n-                              .take_while(|d| d.default.is_none())\n-                              .count();\n-\n-        debug!(\"adjust_type_parameters(space={:?}, \\\n-               provided_len={}, \\\n-               desired_len={}, \\\n-               required_len={})\",\n-               space,\n-               provided_len,\n-               desired.len(),\n-               required_len);\n-\n-        // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n-        assert!(provided_len <= desired.len());\n-\n-        // Nothing specified at all: supply inference variables for\n-        // everything.\n-        if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n-            substs.types.replace(space, Vec::new());\n-            for def in desired {\n-                let ty_var = self.type_var_for_def(span, def, substs);\n-                substs.types.push(def.space, ty_var);\n-            }\n-            return;\n+        // Check provided lifetime parameters.\n+        let lifetime_defs = generics.regions.get_slice(space);\n+        if lifetimes.len() > lifetime_defs.len() {\n+            let span = lifetimes[lifetime_defs.len()].span;\n+            span_err!(self.tcx.sess, span, E0088,\n+                      \"too many lifetime parameters provided: \\\n+                       expected {}, found {}\",\n+                      count(lifetime_defs.len()),\n+                      count(lifetimes.len()));\n+        } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n+            span_err!(self.tcx.sess, span, E0090,\n+                      \"too few lifetime parameters provided: \\\n+                       expected {}, found {}\",\n+                      count(lifetime_defs.len()),\n+                      count(lifetimes.len()));\n         }\n \n-        // Too few parameters specified: report an error and use Err\n-        // for everything.\n-        if provided_len < required_len {\n+        // Check provided type parameters.\n+        let type_defs = generics.types.get_slice(space);\n+        let required_len = type_defs.iter()\n+                                    .take_while(|d| d.default.is_none())\n+                                    .count();\n+        if types.len() > type_defs.len() {\n+            let span = types[type_defs.len()].span;\n+            struct_span_err!(self.tcx.sess, span, E0087,\n+                             \"too many type parameters provided: \\\n+                              expected at most {}, found {}\",\n+                             count(type_defs.len()),\n+                             count(types.len()))\n+                .span_label(span, &format!(\"expected {}\",\n+                            count(type_defs.len()))).emit();\n+\n+            // To prevent derived errors to accumulate due to extra\n+            // type parameters, we force instantiate_value_path to\n+            // use inference variables instead of the provided types.\n+            *segment = None;\n+        } else if !(can_omit && types.len() == 0) && types.len() < required_len {\n             let qualifier =\n-                if desired.len() != required_len { \"at least \" } else { \"\" };\n+                if type_defs.len() != required_len { \"at least \" } else { \"\" };\n             span_err!(self.tcx.sess, span, E0089,\n-                \"too few type parameters provided: expected {}{} parameter{}, \\\n-                 found {} parameter{}\",\n-                qualifier, required_len,\n-                if required_len == 1 {\"\"} else {\"s\"},\n-                provided_len,\n-                if provided_len == 1 {\"\"} else {\"s\"});\n-            substs.types.replace(space, vec![self.tcx.types.err; desired.len()]);\n-            return;\n-        }\n-\n-        // Otherwise, add in any optional parameters that the user\n-        // omitted. The case of *too many* parameters is handled\n-        // already by\n-        // push_explicit_parameters_from_segment_to_substs(). Note\n-        // that the *default* type are expressed in terms of all prior\n-        // parameters, so we have to substitute as we go with the\n-        // partial substitution that we have built up.\n-        for i in provided_len..desired.len() {\n-            let default = desired[i].default.unwrap();\n-            let default = default.subst_spanned(self.tcx, substs, Some(span));\n-            substs.types.push(space, default);\n-        }\n-        assert_eq!(substs.types.len(space), desired.len());\n-\n-        debug!(\"Final substs: {:?}\", substs);\n-    }\n-\n-    fn adjust_region_parameters(&self,\n-        span: Span,\n-        space: ParamSpace,\n-        defs: &VecPerParamSpace<ty::RegionParameterDef>,\n-        substs: &mut Substs)\n-    {\n-        let provided_len = substs.regions.len(space);\n-        let desired = defs.get_slice(space);\n-\n-        // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n-        assert!(provided_len <= desired.len());\n-\n-        // If nothing was provided, just use inference variables.\n-        if provided_len == 0 {\n-            substs.regions.replace(\n-                space,\n-                self.region_vars_for_defs(span, desired));\n-            return;\n+                      \"too few type parameters provided: \\\n+                       expected {}{}, found {}\",\n+                      qualifier,\n+                      count(required_len),\n+                      count(types.len()));\n         }\n \n-        // If just the right number were provided, everybody is happy.\n-        if provided_len == desired.len() {\n-            return;\n+        if !bindings.is_empty() {\n+            span_err!(self.tcx.sess, bindings[0].span, E0182,\n+                      \"unexpected binding of associated item in expression path \\\n+                       (only allowed in type paths)\");\n         }\n-\n-        // Otherwise, too few were provided. Report an error and then\n-        // use inference variables.\n-        span_err!(self.tcx.sess, span, E0090,\n-            \"too few lifetime parameters provided: expected {} parameter{}, \\\n-             found {} parameter{}\",\n-            desired.len(),\n-            if desired.len() == 1 {\"\"} else {\"s\"},\n-            provided_len,\n-            if provided_len == 1 {\"\"} else {\"s\"});\n-\n-        substs.regions.replace(\n-            space,\n-            self.region_vars_for_defs(span, desired));\n     }\n \n     fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)"}, {"sha": "fe1cb3d6badcd06dc97ba5f9f834ed5fa73d02ee", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "patch": "@@ -4018,7 +4018,7 @@ register_diagnostics! {\n //  E0141,\n //  E0159, // use of trait `{}` as struct constructor\n //  E0163, // merged into E0071\n-    E0167,\n+//  E0167,\n //  E0168,\n //  E0173, // manual implementations of unboxed closure traits are experimental\n //  E0174,\n@@ -4053,7 +4053,7 @@ register_diagnostics! {\n //  E0235, // structure constructor specifies a structure of type but\n //  E0236, // no lang item for range syntax\n //  E0237, // no lang item for range syntax\n-    E0238, // parenthesized parameters may only be used with a trait\n+//  E0238, // parenthesized parameters may only be used with a trait\n //  E0239, // `next` method of `Iterator` trait has unexpected type\n //  E0240,\n //  E0241,"}]}