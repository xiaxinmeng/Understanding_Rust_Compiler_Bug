{"sha": "50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZWM2YmQyYzNjNDcyZWExNDBlZDYwZGUzOGRkNTBjNjcyZmM4MGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-04T19:33:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-04T19:33:08Z"}, "message": "new cap clause syntax", "tree": {"sha": "dd040e82e0eba8038dd06424091b6fc575f720aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd040e82e0eba8038dd06424091b6fc575f720aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "html_url": "https://github.com/rust-lang/rust/commit/50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "html_url": "https://github.com/rust-lang/rust/commit/8affc78e8a0e420e1755a34fc7f5e4021c512e9d"}], "stats": {"total": 801, "additions": 444, "deletions": 357}, "files": [{"sha": "594748e2eb9501bcc64f00f90579774e3ef6b147", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -154,11 +154,11 @@ fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     alt e {\n       // https://github.com/mozilla/rust/issues/652\n-      ast::expr_if(_, _, _) { false }\n+      ast::expr_if(*) { false }\n       ast::expr_block(_) { false }\n \n       // expr_call is also missing a constraint\n-      ast::expr_fn_block(_, _) { false }\n+      ast::expr_fn_block(*) { false }\n \n       _ { true }\n     }"}, {"sha": "cddb1346c019a2866a80791a6f04c50ebd9c0d4f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -1096,6 +1096,14 @@ impl extensions<T> for [T] {\n     #[inline]\n     fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n     #[doc = \"\n+    Apply a function to the index and value of each element in the vector\n+    and return the results\n+    \"]\n+    fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n+        let mut i = 0u;\n+        self.map { |e| i += 1u; f(i - 1u, e) }\n+    }\n+    #[doc = \"\n     Apply a function to each element of a vector and return a concatenation\n     of each result vector\n     \"]"}, {"sha": "12e29bcc3ece366daf7d519c7ed4630719f47d96", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -311,8 +311,8 @@ enum expr_ {\n        (implicit) condition is always true. */\n     expr_loop(blk),\n     expr_alt(@expr, [arm], alt_mode),\n-    expr_fn(proto, fn_decl, blk, @capture_clause),\n-    expr_fn_block(fn_decl, blk),\n+    expr_fn(proto, fn_decl, blk, capture_clause),\n+    expr_fn_block(fn_decl, blk, capture_clause),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n     // sanely type this (a function returning nil on the inside but bool on\n     // the outside).\n@@ -356,15 +356,13 @@ enum expr_ {\n #[auto_serialize]\n type capture_item = {\n     id: int,\n+    is_move: bool,\n     name: ident, // Currently, can only capture a local var.\n     span: span\n };\n \n #[auto_serialize]\n-type capture_clause = {\n-    copies: [@capture_item],\n-    moves: [@capture_item]\n-};\n+type capture_clause = [capture_item];\n \n /*\n // Says whether this is a block the user marked as"}, {"sha": "5ebaee71339f1fa12810abdc4fc10331230487fc", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -456,8 +456,9 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n               expr_fn(proto, fold_fn_decl(decl, fld),\n                       fld.fold_block(body), captures)\n           }\n-          expr_fn_block(decl, body) {\n-            expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body))\n+          expr_fn_block(decl, body, captures) {\n+            expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body),\n+                          captures)\n           }\n           expr_block(blk) { expr_block(fld.fold_block(blk)) }\n           expr_move(el, er) {"}, {"sha": "0432faecba05f3a49653042601c8f55907afd189", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 139, "deletions": 99, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -398,25 +398,51 @@ fn parse_arg_mode(p: parser) -> ast::mode {\n     } else { ast::infer(p.get_id()) }\n }\n \n-fn parse_arg(p: parser) -> ast::arg {\n+fn parse_capture_item_or(\n+    p: parser,\n+    parse_arg_fn: fn() -> arg_or_capture_item) -> arg_or_capture_item {\n+\n+    fn parse_capture_item(p: parser, is_move: bool) -> ast::capture_item {\n+        let id = p.get_id();\n+        let sp = mk_sp(p.span.lo, p.span.hi);\n+        let ident = parse_ident(p);\n+        {id: id, is_move: is_move, name: ident, span: sp}\n+    }\n+\n+    if eat_keyword(p, \"move\") {\n+        either::right(parse_capture_item(p, true))\n+    } else if eat_keyword(p, \"copy\") {\n+        either::right(parse_capture_item(p, false))\n+    } else {\n+        parse_arg_fn()\n+    }\n+}\n+\n+fn parse_arg(p: parser) -> arg_or_capture_item {\n     let m = parse_arg_mode(p);\n     let i = parse_value_ident(p);\n     expect(p, token::COLON);\n     let t = parse_ty(p, false);\n-    ret {mode: m, ty: t, ident: i, id: p.get_id()};\n+    either::left({mode: m, ty: t, ident: i, id: p.get_id()})\n }\n \n-fn parse_fn_block_arg(p: parser) -> ast::arg {\n-    let m = parse_arg_mode(p);\n-    let i = parse_value_ident(p);\n-    let t = if eat(p, token::COLON) {\n-                parse_ty(p, false)\n-            } else {\n-                @{id: p.get_id(),\n-                  node: ast::ty_infer,\n-                  span: mk_sp(p.span.lo, p.span.hi)}\n-            };\n-    ret {mode: m, ty: t, ident: i, id: p.get_id()};\n+fn parse_arg_or_capture_item(p: parser) -> arg_or_capture_item {\n+    parse_capture_item_or(p) {|| parse_arg(p) }\n+}\n+\n+fn parse_fn_block_arg(p: parser) -> arg_or_capture_item {\n+    parse_capture_item_or(p) {||\n+        let m = parse_arg_mode(p);\n+        let i = parse_value_ident(p);\n+        let t = if eat(p, token::COLON) {\n+                    parse_ty(p, false)\n+                } else {\n+                    @{id: p.get_id(),\n+                      node: ast::ty_infer,\n+                      span: mk_sp(p.span.lo, p.span.hi)}\n+                };\n+        either::left({mode: m, ty: t, ident: i, id: p.get_id()})\n+    }\n }\n \n fn maybe_parse_dollar_mac(p: parser) -> option<ast::mac_> {\n@@ -1149,74 +1175,27 @@ fn parse_if_expr(p: parser) -> @ast::expr {\n     }\n }\n \n-// Parses:\n-//\n-//   CC := [copy ID*; move ID*]\n-//\n-// where any part is optional and trailing ; is permitted.\n-fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n-    fn expect_opt_trailing_semi(p: parser) {\n-        if !eat(p, token::SEMI) {\n-            if p.token != token::RBRACKET {\n-                p.fatal(\"expecting ; or ]\");\n-            }\n-        }\n-    }\n-\n-    fn eat_ident_list(p: parser) -> [@ast::capture_item] {\n-        let mut res = [];\n-        loop {\n-            alt p.token {\n-              token::IDENT(_, _) {\n-                let id = p.get_id();\n-                let sp = mk_sp(p.span.lo, p.span.hi);\n-                let ident = parse_ident(p);\n-                res += [@{id:id, name:ident, span:sp}];\n-                if !eat(p, token::COMMA) {\n-                    ret res;\n-                }\n-              }\n-\n-              _ { ret res; }\n-            }\n-        };\n-    }\n-\n-    let mut copies = [];\n-    let mut moves = [];\n+fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n+    let lo = p.last_span.lo;\n \n-    if eat(p, token::LBRACKET) {\n-        while !eat(p, token::RBRACKET) {\n-            if eat_keyword(p, \"copy\") {\n-                copies += eat_ident_list(p);\n-                expect_opt_trailing_semi(p);\n-            } else if eat_keyword(p, \"move\") {\n-                moves += eat_ident_list(p);\n-                expect_opt_trailing_semi(p);\n-            } else {\n-                let s: str = \"expecting send, copy, or move clause\";\n-                p.fatal(s);\n-            }\n-        }\n-    }\n+    let cc_old = parse_old_skool_capture_clause(p);\n \n-    ret @{copies: copies, moves: moves};\n-}\n+    // if we want to allow fn expression argument types to be inferred in the\n+    // future, just have to change parse_arg to parse_fn_block_arg.\n+    let (decl, capture_clause) =\n+        parse_fn_decl(p, ast::impure_fn, parse_arg_or_capture_item);\n \n-fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n-    let lo = p.last_span.lo;\n-    let capture_clause = parse_capture_clause(p);\n-    let decl = parse_fn_decl(p, ast::impure_fn);\n     let body = parse_block(p);\n     ret mk_expr(p, lo, body.span.hi,\n-                ast::expr_fn(proto, decl, body, capture_clause));\n+                ast::expr_fn(proto, decl, body, capture_clause + cc_old));\n }\n \n fn parse_fn_block_expr(p: parser) -> @ast::expr {\n     let lo = p.last_span.lo;\n-    let decl = parse_fn_block_decl(p);\n+    let (decl, captures) = parse_fn_block_decl(p);\n     let body = parse_block_tail(p, lo, ast::default_blk);\n-    ret mk_expr(p, lo, body.span.hi, ast::expr_fn_block(decl, body));\n+    ret mk_expr(p, lo, body.span.hi,\n+                ast::expr_fn_block(decl, body, captures));\n }\n \n fn parse_else_expr(p: parser) -> @ast::expr {\n@@ -1699,46 +1678,107 @@ fn parse_ty_params(p: parser) -> [ast::ty_param] {\n     } else { [] }\n }\n \n-fn parse_fn_decl(p: parser, purity: ast::purity)\n-    -> ast::fn_decl {\n-    let inputs: ast::spanned<[ast::arg]> =\n+// FIXME Remove after snapshot\n+fn parse_old_skool_capture_clause(p: parser) -> ast::capture_clause {\n+    fn expect_opt_trailing_semi(p: parser) {\n+        if !eat(p, token::SEMI) {\n+            if p.token != token::RBRACKET {\n+                p.fatal(\"expecting ; or ]\");\n+            }\n+        }\n+    }\n+\n+    fn eat_ident_list(p: parser, is_move: bool) -> [ast::capture_item] {\n+        let mut res = [];\n+        loop {\n+            alt p.token {\n+              token::IDENT(_, _) {\n+                let id = p.get_id();\n+                let sp = mk_sp(p.span.lo, p.span.hi);\n+                let ident = parse_ident(p);\n+                res += [{id:id, is_move: is_move, name:ident, span:sp}];\n+                if !eat(p, token::COMMA) {\n+                    ret res;\n+                }\n+              }\n+\n+              _ { ret res; }\n+            }\n+        };\n+    }\n+\n+    let mut cap_items = [];\n+\n+    if eat(p, token::LBRACKET) {\n+        while !eat(p, token::RBRACKET) {\n+            if eat_keyword(p, \"copy\") {\n+                cap_items += eat_ident_list(p, false);\n+                expect_opt_trailing_semi(p);\n+            } else if eat_keyword(p, \"move\") {\n+                cap_items += eat_ident_list(p, true);\n+                expect_opt_trailing_semi(p);\n+            } else {\n+                let s: str = \"expecting send, copy, or move clause\";\n+                p.fatal(s);\n+            }\n+        }\n+    }\n+\n+    ret cap_items;\n+}\n+\n+type arg_or_capture_item = either<ast::arg, ast::capture_item>;\n+\n+\n+fn parse_fn_decl(p: parser, purity: ast::purity,\n+                 parse_arg_fn: fn(parser) -> arg_or_capture_item)\n+    -> (ast::fn_decl, ast::capture_clause) {\n+\n+    let args_or_capture_items: [arg_or_capture_item] =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n-                  parse_arg, p);\n+                  parse_arg_fn, p).node;\n+\n+    let inputs = either::lefts(args_or_capture_items);\n+    let capture_clause = either::rights(args_or_capture_items);\n+\n     // Use the args list to translate each bound variable\n     // mentioned in a constraint to an arg index.\n     // Seems weird to do this in the parser, but I'm not sure how else to.\n     let mut constrs = [];\n     if p.token == token::COLON {\n         p.bump();\n-        constrs = parse_constrs({|x| parse_ty_constr(inputs.node, x) }, p);\n+        constrs = parse_constrs({|x| parse_ty_constr(inputs, x) }, p);\n     }\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n-    ret {inputs: inputs.node,\n-         output: ret_ty,\n-         purity: purity,\n-         cf: ret_style,\n-         constraints: constrs};\n+    ret ({inputs: inputs,\n+          output: ret_ty,\n+          purity: purity,\n+          cf: ret_style,\n+          constraints: constrs}, capture_clause);\n }\n \n-fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n-    let inputs = if eat(p, token::OROR) {\n-                     []\n-                 } else {\n-                     parse_seq(token::BINOP(token::OR),\n-                               token::BINOP(token::OR),\n-                               seq_sep(token::COMMA),\n-                               parse_fn_block_arg, p).node\n-                 };\n+fn parse_fn_block_decl(p: parser) -> (ast::fn_decl, ast::capture_clause) {\n+    let inputs_captures = {\n+        if eat(p, token::OROR) {\n+            []\n+        } else {\n+            parse_seq(token::BINOP(token::OR),\n+                      token::BINOP(token::OR),\n+                      seq_sep(token::COMMA),\n+                      parse_fn_block_arg, p).node\n+        }\n+    };\n     let output = if eat(p, token::RARROW) {\n                      parse_ty(p, false)\n                  } else {\n                      @{id: p.get_id(), node: ast::ty_infer, span: p.span}\n                  };\n-    ret {inputs: inputs,\n-         output: output,\n-         purity: ast::impure_fn,\n-         cf: ast::return_val,\n-         constraints: []};\n+    ret ({inputs: either::lefts(inputs_captures),\n+          output: output,\n+          purity: ast::impure_fn,\n+          cf: ast::return_val,\n+          constraints: []},\n+         either::rights(inputs_captures));\n }\n \n fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n@@ -1760,7 +1800,7 @@ fn parse_item_fn(p: parser, purity: ast::purity,\n                  attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, purity);\n+    let (decl, _) = parse_fn_decl(p, purity, parse_arg);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n     let attrs = attrs + inner_attrs;\n     ret mk_item(p, lo, body.span.hi, t.ident,\n@@ -1785,7 +1825,7 @@ fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n     let lo = p.span.lo, pur = parse_fn_purity(p);\n     let ident = parse_method_name(p);\n     let tps = parse_ty_params(p);\n-    let decl = parse_fn_decl(p, pur);\n+    let (decl, _) = parse_fn_decl(p, pur, parse_arg);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n     let attrs = attrs + inner_attrs;\n     @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n@@ -1969,7 +2009,7 @@ fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n         let lo = p.last_span.lo;\n         // Can ctors have attrs?\n             // result type is always the type of the class\n-        let decl_ = parse_fn_decl(p, ast::impure_fn);\n+        let (decl_, _) = parse_fn_decl(p, ast::impure_fn, parse_arg);\n         let decl = {output: @{id: p.get_id(),\n                       node: ast::ty_path(class_name_with_tps, p.get_id()),\n                       span: decl_.output.span}\n@@ -2048,7 +2088,7 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n                         purity: ast::purity) -> @ast::native_item {\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, purity);\n+    let (decl, _) = parse_fn_decl(p, purity, parse_arg);\n     let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,"}, {"sha": "6e5730412655a42fa3a78d982b32828ec4bf2fc6", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 38, "deletions": 57, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -519,7 +519,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           hardbreak_if_not_bol(s);\n           maybe_print_comment(s, ctor.span.lo);\n           head(s, \"new\");\n-          print_fn_args_and_ret(s, ctor.node.dec);\n+          print_fn_args_and_ret(s, ctor.node.dec, []);\n           space(s.s);\n           print_block(s, ctor.node.body);\n           for items.each {|ci|\n@@ -1018,18 +1018,17 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         word(s.s, proto_to_str(proto));\n-        print_cap_clause(s, *cap_clause);\n-        print_fn_args_and_ret(s, decl);\n+        print_fn_args_and_ret(s, decl, cap_clause);\n         space(s.s);\n         print_block(s, body);\n       }\n-      ast::expr_fn_block(decl, body) {\n+      ast::expr_fn_block(decl, body, cap_clause) {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         word(s.s, \"{\");\n-        print_fn_block_args(s, decl);\n+        print_fn_block_args(s, decl, cap_clause);\n         print_possibly_embedded_block(s, body, block_block_fn, indent_unit);\n       }\n       ast::expr_loop_body(body) {\n@@ -1319,46 +1318,27 @@ fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n-    print_fn_args_and_ret(s, decl);\n+    print_fn_args_and_ret(s, decl, []);\n }\n \n-fn print_cap_clause(s: ps, cap_clause: ast::capture_clause) {\n-    fn print_cap_item(s: ps, &&cap_item: @ast::capture_item) {\n-        word(s.s, cap_item.name);\n-    }\n-\n-    let has_copies = vec::is_not_empty(cap_clause.copies);\n-    let has_moves = vec::is_not_empty(cap_clause.moves);\n-    if !has_copies && !has_moves { ret; }\n-\n-    word(s.s, \"[\");\n-\n-    if has_copies {\n-        word_nbsp(s, \"copy\");\n-        commasep(s, inconsistent, cap_clause.copies, print_cap_item);\n-        if has_moves {\n-            word_space(s, \";\");\n+fn print_fn_args(s: ps, decl: ast::fn_decl,\n+                 cap_items: [ast::capture_item]) {\n+    commasep(s, inconsistent, decl.inputs, print_arg);\n+    if cap_items.is_not_empty() {\n+        let mut first = decl.inputs.is_empty();\n+        for cap_items.each { |cap_item|\n+            if first { first = false; } else { word_space(s, \",\"); }\n+            if cap_item.is_move { word_nbsp(s, \"move\") }\n+            else { word_nbsp(s, \"copy\") }\n+            word(s.s, cap_item.name);\n         }\n     }\n-\n-    if has_moves {\n-        word_nbsp(s, \"move\");\n-        commasep(s, inconsistent, cap_clause.moves, print_cap_item);\n-    }\n-\n-    word(s.s, \"]\");\n }\n \n-fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl) {\n+fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n+                         cap_items: [ast::capture_item]) {\n     popen(s);\n-    fn print_arg(s: ps, x: ast::arg) {\n-        ibox(s, indent_unit);\n-        print_arg_mode(s, x.mode);\n-        word_space(s, x.ident + \":\");\n-        print_type(s, x.ty);\n-        end(s);\n-    }\n-    commasep(s, inconsistent, decl.inputs, print_arg);\n+    print_fn_args(s, decl, cap_items);\n     pclose(s);\n     word(s.s, constrs_str(decl.constraints, {|c|\n         ast_fn_constr_to_str(decl, c)\n@@ -1372,19 +1352,10 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl) {\n     }\n }\n \n-fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n+fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n+                       cap_items: [ast::capture_item]) {\n     word(s.s, \"|\");\n-    fn print_arg(s: ps, x: ast::arg) {\n-        ibox(s, indent_unit);\n-        print_arg_mode(s, x.mode);\n-        word(s.s, x.ident);\n-        if x.ty.node != ast::ty_infer {\n-            word_space(s, \":\");\n-            print_type(s, x.ty);\n-        }\n-        end(s);\n-    }\n-    commasep(s, inconsistent, decl.inputs, print_arg);\n+    print_fn_args(s, decl, cap_items);\n     word(s.s, \"|\");\n     if decl.output.node != ast::ty_infer {\n         space_if_not_bol(s);\n@@ -1541,6 +1512,23 @@ fn print_mt(s: ps, mt: ast::mt) {\n     print_type(s, mt.ty);\n }\n \n+fn print_arg(s: ps, input: ast::arg) {\n+    ibox(s, indent_unit);\n+    print_arg_mode(s, input.mode);\n+    alt input.ty.node {\n+      ast::ty_infer {\n+        word(s.s, input.ident);\n+      }\n+      _ {\n+        if str::len(input.ident) > 0u {\n+            word_space(s, input.ident + \":\");\n+        }\n+        print_type(s, input.ty);\n+      }\n+    }\n+    end(s);\n+}\n+\n fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                decl: ast::fn_decl, id: option<ast::ident>,\n                tps: option<[ast::ty_param]>) {\n@@ -1550,13 +1538,6 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     alt tps { some(tps) { print_type_params(s, tps); } _ { } }\n     zerobreak(s.s);\n     popen(s);\n-    fn print_arg(s: ps, input: ast::arg) {\n-        print_arg_mode(s, input.mode);\n-        if str::len(input.ident) > 0u {\n-            word_space(s, input.ident + \":\");\n-        }\n-        print_type(s, input.ty);\n-    }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n     maybe_print_comment(s, decl.output.span.lo);"}, {"sha": "2cac7f53e839969e51fc90e59993e8690af96ec6", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -384,7 +384,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_fn(proto, decl, body, _) {\n         v.visit_fn(fk_anon(proto), decl, body, ex.span, ex.id, e, v);\n       }\n-      expr_fn_block(decl, body) {\n+      expr_fn_block(decl, body, _) {\n         v.visit_fn(fk_fn_block, decl, body, ex.span, ex.id, e, v);\n       }\n       expr_block(b) { v.visit_block(b, e, v); }"}, {"sha": "c23c6d5a9978cd912b8fa18d57292cdfd4a9b7ad", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -365,15 +365,10 @@ fn mk_test_wrapper(cx: test_ctxt,\n         rules: ast::default_blk\n     });\n \n-    let wrapper_capture: @ast::capture_clause = @{\n-        copies: [],\n-        moves: []\n-    };\n-\n     let wrapper_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n         node: ast::expr_fn(ast::proto_bare, wrapper_decl,\n-                           wrapper_body, wrapper_capture),\n+                           wrapper_body, []),\n         span: span\n     };\n "}, {"sha": "444947c471bb90e573e4a187f30874702f019a18", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -182,8 +182,8 @@ fn cant_copy(cx: ctx, b: binding) -> bool {\n fn local_id_for_args(cx: ctx, args: [@ast::expr]) -> uint {\n     for vec::each(args) {|arg|\n         alt arg.node {\n-          ast::expr_fn_block(decl, _) | ast::expr_fn(_, decl, _, _) |\n-          ast::expr_loop_body(@{node: ast::expr_fn_block(decl, _), _}) {\n+          ast::expr_fn_block(decl, _, _) | ast::expr_fn(_, decl, _, _) |\n+          ast::expr_loop_body(@{node: ast::expr_fn_block(decl, _, _), _}) {\n             if decl.inputs.len() > 0u {\n                 ret local_id_of_node(cx, decl.inputs[0].id);\n             }\n@@ -216,7 +216,7 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n           ast::by_ref | ast::by_val | ast::by_move | ast::by_copy {}\n         }\n         alt arg.node {\n-          ast::expr_fn_block(_, _) { blocks += [arg]; }\n+          ast::expr_fn_block(*) { blocks += [arg]; }\n           ast::expr_loop_body(b) { blocks += [b]; }\n           _ {\n             let root_var = path_def_id(*cx, root.ex);\n@@ -267,7 +267,7 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n                 let mut_alias =\n                     (ast::by_mutbl_ref == ty::arg_mode(cx.tcx, arg_t));\n                 alt args[i].node {\n-                  ast::expr_fn_block(_, _) | ast::expr_loop_body(_) {}\n+                  ast::expr_fn_block(*) | ast::expr_loop_body(_) {}\n                   _ {\n                     if i != j && ty_can_unsafely_include(\n                         *cx, unsafe_ty, arg_t.ty, mut_alias) &&\n@@ -306,7 +306,7 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n         let inner_sc = {bs: bindings + sc.bs, invalid: sc.invalid};\n         for blocks.each {|blk|\n             alt check blk.node {\n-              ast::expr_fn_block(_, body) {\n+              ast::expr_fn_block(_, body, _) {\n                 v.visit_block(body, inner_sc, v);\n               }\n             }"}, {"sha": "745469d0148ffb12b20257e5290680cd7fd8433f", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -36,7 +36,7 @@ fn check_capture_clause(tcx: ty::ctxt,\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let seen_defs = map::int_hash();\n \n-    let check_capture_item = fn@(&&cap_item: @ast::capture_item) {\n+    let check_capture_item = fn@(cap_item: ast::capture_item) {\n         let cap_def = tcx.def_map.get(cap_item.id);\n         if !vec::any(*freevars, {|fv| fv.def == cap_def}) {\n             tcx.sess.span_warn(\n@@ -54,36 +54,19 @@ fn check_capture_clause(tcx: ty::ctxt,\n         }\n     };\n \n-    let check_not_upvar = fn@(&&cap_item: @ast::capture_item) {\n-        alt tcx.def_map.get(cap_item.id) {\n-          ast::def_upvar(_, _, _) {\n-            tcx.sess.span_err(\n-                cap_item.span,\n-                #fmt(\"upvars (like '%s') cannot be moved into a closure\",\n-                     cap_item.name));\n-          }\n-          _ {}\n-        }\n-    };\n-\n-    let check_block_captures = fn@(v: [@ast::capture_item]) {\n-        if check vec::is_not_empty(v) {\n-            let cap_item0 = vec::head(v);\n+    alt fn_proto {\n+      ast::proto_any | ast::proto_block {\n+        if vec::is_not_empty(cap_clause) {\n+            let cap_item0 = vec::head(cap_clause);\n             tcx.sess.span_err(\n                 cap_item0.span,\n                 \"cannot capture values explicitly with a block closure\");\n         }\n-    };\n-\n-    alt fn_proto {\n-      ast::proto_any | ast::proto_block {\n-        check_block_captures(cap_clause.copies);\n-        check_block_captures(cap_clause.moves);\n       }\n       ast::proto_bare | ast::proto_box | ast::proto_uniq {\n-        vec::iter(cap_clause.copies, check_capture_item);\n-        vec::iter(cap_clause.moves, check_capture_item);\n-        vec::iter(cap_clause.moves, check_not_upvar);\n+        for cap_clause.each { |cap_item|\n+            check_capture_item(cap_item);\n+        }\n       }\n     }\n }\n@@ -95,24 +78,31 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let cap_map = map::int_hash();\n \n-    vec::iter(cap_clause.copies) { |cap_item|\n-        let cap_def = tcx.def_map.get(cap_item.id);\n-        let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n-        if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n-            cap_map.insert(cap_def_id, { def:cap_def, mode:cap_copy });\n-        }\n-    }\n+    // first add entries for anything explicitly named in the cap clause\n \n-    vec::iter(cap_clause.moves) { |cap_item|\n+    for cap_clause.each { |cap_item|\n         let cap_def = tcx.def_map.get(cap_item.id);\n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n-        if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n-            cap_map.insert(cap_def_id, { def:cap_def, mode:cap_move });\n+        if cap_item.is_move {\n+            // if we are moving the value in, but it's not actually used,\n+            // must drop it.\n+            if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+                cap_map.insert(cap_def_id, { def:cap_def, mode:cap_move });\n+            } else {\n+                cap_map.insert(cap_def_id, { def:cap_def, mode:cap_drop });\n+            }\n         } else {\n-            cap_map.insert(cap_def_id, { def:cap_def, mode:cap_drop });\n+            // if we are copying the value in, but it's not actually used,\n+            // just ignore it.\n+            if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+                cap_map.insert(cap_def_id, { def:cap_def, mode:cap_copy });\n+            }\n         }\n     }\n \n+    // now go through anything that is referenced but was not explicitly\n+    // named and add that\n+\n     let implicit_mode = alt fn_proto {\n       ast::proto_any | ast::proto_block { cap_ref }\n       ast::proto_bare | ast::proto_box | ast::proto_uniq { cap_copy }"}, {"sha": "99dadb5922a8086e0100cbc7a0ba5c4a6a09431c", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -21,10 +21,10 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n               expr_fn(_, _, _, _) {\n                 visit::visit_expr(e, {in_loop: false, can_ret: true}, v);\n               }\n-              expr_fn_block(_, b) {\n+              expr_fn_block(_, b, _) {\n                 v.visit_block(b, {in_loop: false, can_ret: false}, v);\n               }\n-              expr_loop_body(@{node: expr_fn_block(_, b), _}) {\n+              expr_loop_body(@{node: expr_fn_block(_, b, _), _}) {\n                 let blk = is_blockish(ty::ty_fn_proto(ty::expr_ty(tcx, e)));\n                 v.visit_block(b, {in_loop: true, can_ret: blk}, v);\n               }"}, {"sha": "df6a718de1d4828145d1a17f9640b37be5d1caa4", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -40,12 +40,12 @@ fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n \n     let walk_expr = fn@(expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             alt expr.node {\n-              ast::expr_fn(proto, decl, _, captures) {\n+              ast::expr_fn(proto, decl, _, _) {\n                 if proto != ast::proto_bare {\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }\n-              ast::expr_fn_block(_, _) {\n+              ast::expr_fn_block(_, _, _) {\n                 visit::visit_expr(expr, depth + 1, v);\n               }\n               ast::expr_path(path) {"}, {"sha": "672629577d956a03cd03c3483acd61c804255060", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -117,16 +117,14 @@ fn check_fn_cap_clause(cx: ctx,\n     });\n     //log(\"freevar_ids\", freevar_ids);\n     with_appropriate_checker(cx, id) { |checker|\n-        let check_var = fn@(&&cap_item: @capture_item) {\n+        for cap_clause.each { |cap_item|\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n             if !vec::contains(freevar_ids, cap_def_id) {\n                 let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n                 checker(cx, ty, cap_item.span);\n             }\n-        };\n-        vec::iter(cap_clause.copies, check_var);\n-        vec::iter(cap_clause.moves, check_var);\n+        }\n     }\n }\n \n@@ -227,8 +225,8 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             }\n         }\n       }\n-      expr_fn(_, _, _, cap_clause) {\n-        check_fn_cap_clause(cx, e.id, *cap_clause);\n+      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n+        check_fn_cap_clause(cx, e.id, cap_clause);\n       }\n       _ { }\n     }"}, {"sha": "1364118730a9b480d9720235567e8c5b49d7b964", "filename": "src/rustc/middle/last_use.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -154,12 +154,15 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         v.visit_expr(dest, cx, v);\n         clear_if_path(cx, dest, v, true);\n       }\n+      expr_fn_block(_, _, cap_clause) |\n       expr_fn(_, _, _, cap_clause) {\n         // n.b.: safe to ignore copies, as if they are unused\n         // then they are ignored, otherwise they will show up\n         // as freevars in the body.\n-        vec::iter(cap_clause.moves) {|ci|\n-            clear_def_if_local(cx, cx.def_map.get(ci.id), false);\n+        for cap_clause.each { |ci|\n+            if ci.is_move {\n+                clear_def_if_local(cx, cx.def_map.get(ci.id), false);\n+            }\n         }\n         visit::visit_expr(ex, cx, v);\n       }\n@@ -169,7 +172,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n         vec::iter2(args, arg_ts) {|arg, arg_t|\n             alt arg.node {\n-              expr_fn(_, _, _, _) | expr_fn_block(_, _)\n+              expr_fn(*) | expr_fn_block(*)\n               if is_blockish(ty::ty_fn_proto(arg_t.ty)) {\n                 fns += [arg];\n               }"}, {"sha": "572d1c234deccab84b05a83c137b4e3c3f551227", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -199,14 +199,17 @@ fn visit_expr(ex: @expr, &&cx: @ctx, v: visit::vt<@ctx>) {\n       expr_assign(dest, src) | expr_assign_op(_, dest, src) {\n         check_lval(cx, dest, msg_assign);\n       }\n-      expr_fn(_, _, _, cap) {\n-        for cap.moves.each {|moved|\n-            let def = cx.tcx.def_map.get(moved.id);\n-            alt is_illegal_to_modify_def(cx, def, msg_move_out) {\n-              some(name) { mk_err(cx, moved.span, msg_move_out, moved.name); }\n-              _ { }\n+      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n+        for cap_clause.each { |cap_item|\n+            if cap_item.is_move {\n+                let def = cx.tcx.def_map.get(cap_item.id);\n+                alt is_illegal_to_modify_def(cx, def, msg_move_out) {\n+                  some(name) { mk_err(cx, cap_item.span,\n+                                      msg_move_out, name); }\n+                  _ { }\n+                }\n+                cx.mutbl_map.insert(ast_util::def_id_of_def(def).node, ());\n             }\n-            cx.mutbl_map.insert(ast_util::def_id_of_def(def).node, ());\n         }\n       }\n       _ { }"}, {"sha": "87ba22fc8bb870d5c8af39a30c9e9649ba16032f", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -286,7 +286,7 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, expr.id);\n     alt expr.node {\n-      ast::expr_fn(_, _, _, _) | ast::expr_fn_block(_, _) {\n+      ast::expr_fn(*) | ast::expr_fn_block(*) {\n         let new_cx = {parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }"}, {"sha": "379c5c66ab89ee00f4553cee65d20ac99018010c", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -390,7 +390,7 @@ fn check_unused_imports(e: @env, level: lint::level) {\n     };\n }\n \n-fn resolve_capture_item(e: @env, sc: scopes, &&cap_item: @ast::capture_item) {\n+fn resolve_capture_item(e: @env, sc: scopes, cap_item: ast::capture_item) {\n     let dcur = lookup_in_scope_strict(\n         *e, sc, cap_item.span, cap_item.name, ns_val);\n     maybe_insert(e, cap_item.id, dcur);\n@@ -453,10 +453,11 @@ fn resolve_names(e: @env, c: @ast::crate) {\n             maybe_insert(e, exp.id,\n                          lookup_path_strict(*e, sc, exp.span, p, ns_val));\n           }\n-          ast::expr_fn(_, _, _, cap_clause) {\n-            let rci = bind resolve_capture_item(e, sc, _);\n-            vec::iter(cap_clause.copies, rci);\n-            vec::iter(cap_clause.moves, rci);\n+          ast::expr_fn(_, _, _, cap_clause) |\n+          ast::expr_fn_block(_, _, cap_clause) {\n+            for cap_clause.each { |ci|\n+                resolve_capture_item(e, sc, ci);\n+            }\n           }\n           _ { }\n         }"}, {"sha": "6c1b81a371d3f224e17c895261aed9a3c0c2233f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -2544,11 +2544,11 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n                    dest: dest) -> block {\n     alt check e.node {\n-      ast::expr_loop_body(b@@{node: ast::expr_fn_block(decl, body), _}) {\n+      ast::expr_loop_body(b@@{node: ast::expr_fn_block(decl, body, cap), _}) {\n         alt check ty::get(expr_ty(bcx, e)).struct {\n           ty::ty_fn({proto, _}) {\n             closure::trans_expr_fn(bcx, proto, decl, body, e.span, b.id,\n-                                   {copies: [], moves: []}, some(ret_flag),\n+                                   cap, some(ret_flag),\n                                    dest)\n           }\n         }\n@@ -2800,7 +2800,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n     -> block {\n     let ret_in_loop = alt args {\n       arg_exprs(args) { args.len() > 0u && alt vec::last(args).node {\n-        ast::expr_loop_body(@{node: ast::expr_fn_block(_, body), _}) {\n+        ast::expr_loop_body(@{node: ast::expr_fn_block(_, body, _), _}) {\n           body_contains_ret(body)\n         }\n         _ { false }\n@@ -3166,15 +3166,15 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       ast::expr_addr_of(_, x) { ret trans_addr_of(bcx, x, dest); }\n       ast::expr_fn(proto, decl, body, cap_clause) {\n         ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n-                                   *cap_clause, none, dest);\n+                                   cap_clause, none, dest);\n       }\n-      ast::expr_fn_block(decl, body) {\n+      ast::expr_fn_block(decl, body, cap_clause) {\n         alt check ty::get(expr_ty(bcx, e)).struct {\n           ty::ty_fn({proto, _}) {\n             #debug(\"translating fn_block %s with type %s\",\n                    expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n             ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n-                                       {copies: [], moves: []}, none, dest);\n+                                       cap_clause, none, dest);\n           }\n         }\n       }"}, {"sha": "44f66f7a70e902a8a2bee7a5f41fb10f29c65866", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -772,7 +772,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n           ast::expr_fn(_, decl, _, _) {\n             (dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n-          ast::expr_fn_block(decl, _) {\n+          ast::expr_fn_block(decl, _, _) {\n             (dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n           _ { fcx.ccx.sess.span_bug(expr.span, \"create_function: \\"}, {"sha": "3ec11d5b0c43b3a35ea707c8732c30a91d586126", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -160,7 +160,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n             }\n         }\n       }\n-      expr_fn(_, _, _, _) | expr_fn_block(_, _) {\n+      expr_fn(*) | expr_fn_block(*) {\n         alt ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n           proto_bare | proto_any | proto_uniq {}\n           proto_box | proto_block {"}, {"sha": "196b891850e96645b81a96453dfbe754e1cc16c9", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -340,24 +340,21 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_log(_, lvl, arg) {\n         find_pre_post_exprs(fcx, [lvl, arg], e.id);\n       }\n-      expr_fn(_, _, _, cap_clause) {\n+      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n         find_pre_post_expr_fn_upvars(fcx, e);\n \n-        let use_cap_item = fn@(&&cap_item: @capture_item) {\n+        for cap_clause.each { |cap_item|\n             let d = local_node_id_to_local_def_id(fcx, cap_item.id);\n             option::iter(d, { |id| use_var(fcx, id) });\n-        };\n-        vec::iter(cap_clause.copies, use_cap_item);\n-        vec::iter(cap_clause.moves, use_cap_item);\n+        }\n \n-        vec::iter(cap_clause.moves) { |cap_item|\n-            log(debug, (\"forget_in_postcond: \", cap_item));\n-            forget_in_postcond(fcx, e.id, cap_item.id);\n+        for cap_clause.each { |cap_item|\n+            if cap_item.is_move {\n+                log(debug, (\"forget_in_postcond: \", cap_item));\n+                forget_in_postcond(fcx, e.id, cap_item.id);\n+            }\n         }\n       }\n-      expr_fn_block(_, _) {\n-        find_pre_post_expr_fn_upvars(fcx, e);\n-      }\n       expr_block(b) {\n         find_pre_post_block(fcx, b);\n         let p = block_pp(fcx.ccx, b);"}, {"sha": "8397fa879cfa6e8056d00e9d1074c611b1689eb0", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -363,8 +363,10 @@ fn find_pre_post_state_cap_clause(fcx: fn_ctxt, e_id: node_id,\n     let ccx = fcx.ccx;\n     let pres_changed = set_prestate_ann(ccx, e_id, pres);\n     let post = tritv_clone(pres);\n-    vec::iter(cap_clause.moves) { |cap_item|\n-        forget_in_poststate(fcx, post, cap_item.id);\n+    for cap_clause.each { |cap_item|\n+        if cap_item.is_move {\n+            forget_in_poststate(fcx, post, cap_item.id);\n+        }\n     }\n     ret set_poststate_ann(ccx, e_id, post) || pres_changed;\n }\n@@ -418,9 +420,11 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_lit(l) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_fn(_, _, _, cap_clause) {\n-        ret find_pre_post_state_cap_clause(fcx, e.id, pres, *cap_clause);\n+        ret find_pre_post_state_cap_clause(fcx, e.id, pres, cap_clause);\n+      }\n+      expr_fn_block(_, _, cap_clause) {\n+        ret find_pre_post_state_cap_clause(fcx, e.id, pres, cap_clause);\n       }\n-      expr_fn_block(_, _) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_block(b) {\n         ret find_pre_post_state_block(fcx, pres, b) |\n                 set_prestate_ann(fcx.ccx, e.id, pres) |"}, {"sha": "81e3207821524610a640fcc22afd2063c845137e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 123, "deletions": 65, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -275,7 +275,8 @@ fn instantiate_path(fcx: @fn_ctxt,\n     fcx.write_ty_substs(id, tpt.ty, substs);\n }\n \n-// Type tests\n+// Resolves `typ` by a single level if `typ` is a type variable.  If no\n+// resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     alt infer::resolve_shallow(fcx.infcx, tp, false) {\n       result::ok(t_s) if !ty::type_is_var(t_s) { ret t_s; }\n@@ -286,7 +287,6 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     }\n }\n \n-\n // Returns the one-level-deep structure of the given type.\n fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n     ty::get(structurally_resolved_type(fcx, sp, typ)).struct\n@@ -689,7 +689,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ty::mk_rec(tcx, flds)\n       }\n       ast::ty_fn(proto, decl) {\n-        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl))\n+        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl, none))\n       }\n       ast::ty_path(path, id) {\n         let a_def = alt tcx.def_map.find(id) {\n@@ -777,7 +777,13 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n       }\n       ast::ty_infer {\n-        self.ty_infer(ast_ty.span)\n+        // ty_infer should only appear as the type of arguments or return\n+        // values in a fn_expr, or as the type of local variables.  Both of\n+        // these cases are handled specially and should not descend into this\n+        // routine.\n+        self.tcx().sess.span_bug(\n+            ast_ty.span,\n+            \"found `ty_infer` in unexpected place\");\n       }\n       ast::ty_mac(_) {\n         tcx.sess.span_bug(ast_ty.span,\n@@ -850,7 +856,8 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_fn(decl, tps, _) {\n         let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare, decl);\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n+                                 decl, none);\n         let tpt = {bounds: bounds,\n                    rp: ast::rp_none, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n@@ -884,7 +891,8 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_res(decl, tps, _, _, _, rp) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t_arg = ty_of_arg(ccx, type_rscope(rp), decl.inputs[0]);\n+        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n+                              decl.inputs[0], none);\n         let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n         let t_res = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n@@ -1027,47 +1035,76 @@ fn replace_bound_regions(\n }\n \n fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, a: ast::arg) -> ty::arg {\n+    self: AC, rscope: RS, a: ast::arg,\n+    expected_ty: option<ty::arg>) -> ty::arg {\n+\n+    let ty = alt a.ty.node {\n+      ast::ty_infer if expected_ty.is_some() {expected_ty.get().ty}\n+      ast::ty_infer {self.ty_infer(a.ty.span)}\n+      _ {ast_ty_to_ty(self, rscope, a.ty)}\n+    };\n \n-    fn arg_mode(tcx: ty::ctxt, m: ast::mode, ty: ty::t) -> ast::mode {\n-        alt m {\n+    let mode = {\n+        alt a.mode {\n+          ast::infer(_) if expected_ty.is_some() {\n+            result::get(ty::unify_mode(self.tcx(), a.mode,\n+                                       expected_ty.get().mode))\n+          }\n           ast::infer(_) {\n             alt ty::get(ty).struct {\n               // If the type is not specified, then this must be a fn expr.\n               // Leave the mode as infer(_), it will get inferred based\n               // on constraints elsewhere.\n-              ty::ty_var(_) { m }\n+              ty::ty_var(_) {a.mode}\n \n               // If the type is known, then use the default for that type.\n               // Here we unify m and the default.  This should update the\n               // tables in tcx but should never fail, because nothing else\n               // will have been unified with m yet:\n               _ {\n                 let m1 = ast::expl(ty::default_arg_mode_for_ty(ty));\n-                result::get(ty::unify_mode(tcx, m, m1))\n+                result::get(ty::unify_mode(self.tcx(), a.mode, m1))\n               }\n             }\n           }\n-          ast::expl(_) { m }\n+          ast::expl(_) {a.mode}\n         }\n-    }\n+    };\n \n-    let ty = ast_ty_to_ty(self, rscope, a.ty);\n-    let mode = arg_mode(self.tcx(), a.mode, ty);\n     {mode: mode, ty: ty}\n }\n+\n+type expected_tys = option<{inputs: [ty::arg],\n+                            output: ty::t}>;\n+\n fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n     self: AC, rscope: RS,\n     proto: ast::proto,\n-    decl: ast::fn_decl) -> ty::fn_ty {\n+    decl: ast::fn_decl,\n+    expected_tys: expected_tys) -> ty::fn_ty {\n \n     #debug[\"ty_of_fn_decl\"];\n     indent {||\n         // new region names that appear inside of the fn decl are bound to\n         // that function type\n         let rb = in_binding_rscope(rscope);\n-        let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(self, rb, a) };\n-        let output_ty = ast_ty_to_ty(self, rb, decl.output);\n+\n+        let input_tys = decl.inputs.mapi { |i, a|\n+            let expected_arg_ty = expected_tys.chain { |e|\n+                // no guarantee that the correct number of expected args\n+                // were supplied\n+                if i < e.inputs.len() {some(e.inputs[i])} else {none}\n+            };\n+            ty_of_arg(self, rb, a, expected_arg_ty)\n+        };\n+\n+        let expected_ret_ty = expected_tys.map { |e| e.output };\n+        let output_ty = alt decl.output.node {\n+          ast::ty_infer if expected_ret_ty.is_some() {expected_ret_ty.get()}\n+          ast::ty_infer {self.ty_infer(decl.output.span)}\n+          _ {ast_ty_to_ty(self, rb, decl.output)}\n+        };\n+\n         let out_constrs = vec::map(decl.constraints) {|constr|\n             ty::ast_constr_to_constr(self.tcx(), constr)\n         };\n@@ -1083,7 +1120,7 @@ fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(ccx, rb, a) };\n+    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n     let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n@@ -1135,7 +1172,8 @@ fn ty_of_method(ccx: @crate_ctxt,\n                 rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, m.tps),\n-     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, m.decl),\n+     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n+                        m.decl, none),\n      purity: m.decl.purity,\n      privacy: m.privacy}\n }\n@@ -1145,7 +1183,8 @@ fn ty_of_ty_method(self: @crate_ctxt,\n                    rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, m.decl),\n+     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n+                        m.decl, none),\n      // assume public, because this is only invoked on iface methods\n      purity: m.decl.purity, privacy: ast::pub}\n }\n@@ -1649,7 +1688,8 @@ mod collect {\n           ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n             let {bounds, substs} = mk_substs(ccx, tps, rp);\n             let def_id = local_def(it.id);\n-            let t_arg = ty_of_arg(ccx, type_rscope(rp), decl.inputs[0]);\n+            let t_arg = ty_of_arg(ccx, type_rscope(rp),\n+                                  decl.inputs[0], none);\n             let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n \n             let t_ctor = ty::mk_fn(tcx, {\n@@ -1691,7 +1731,8 @@ mod collect {\n                           ty_of_fn_decl(ccx,\n                                         empty_rscope,\n                                         ast::proto_any,\n-                                        ctor.node.dec));\n+                                        ctor.node.dec,\n+                                        none));\n             write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n             tcx.tcache.insert(local_def(ctor.node.id),\n                               {bounds: tpt.bounds,\n@@ -1961,7 +2002,7 @@ mod writeback {\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n         alt e.node {\n           ast::expr_fn(_, decl, _, _) |\n-          ast::expr_fn_block(decl, _) {\n+          ast::expr_fn_block(decl, _, _) {\n             vec::iter(decl.inputs) {|input|\n                 let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n \n@@ -2902,35 +2943,6 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n     }\n }\n \n-fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n-                              expr: @ast::expr,\n-                              proto: ast::proto,\n-                              decl: ast::fn_decl,\n-                              body: ast::blk,\n-                              is_loop_body: bool,\n-                              unifier: fn()) {\n-    let tcx = fcx.ccx.tcx;\n-    let fty = ty::mk_fn(tcx, ty_of_fn_decl(fcx, fcx, proto, decl));\n-\n-    #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n-           expr_to_str(expr), fcx.ty_to_str(fty));\n-\n-    fcx.write_ty(expr.id, fty);\n-\n-    // Unify the type of the function with the expected type before we\n-    // typecheck the body so that we have more information about the\n-    // argument types in the body. This is needed to make binops and\n-    // record projection work on type inferred arguments.\n-    unifier();\n-\n-    let ret_ty = ty::ty_fn_ret(fty);\n-    let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n-\n-    check_fn(fcx.ccx, proto, decl, body, expr.id,\n-             ret_ty, arg_tys, is_loop_body, some(fcx),\n-             fcx.self_ty);\n-}\n-\n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n                            expected: option<ty::t>,\n@@ -2999,7 +3011,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 alt a_opt {\n                   some(a) {\n                     let is_block = alt a.node {\n-                      ast::expr_fn_block(_, _) { true }\n+                      ast::expr_fn_block(*) { true }\n                       _ { false }\n                     };\n                     if is_block == check_blocks {\n@@ -3227,6 +3239,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n         }\n     }\n+\n+    // Resolves `expected` by a single level if it is a variable and passes it\n+    // through the `unpack` function.  It there is no expected type or\n+    // resolution is not possible (e.g., no constraints yet present), just\n+    // returns `none`.\n     fn unpack_expected<O: copy>(fcx: @fn_ctxt, expected: option<ty::t>,\n                                 unpack: fn(ty::sty) -> option<O>)\n         -> option<O> {\n@@ -3241,6 +3258,42 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n     }\n \n+    fn check_expr_fn(fcx: @fn_ctxt,\n+                     expr: @ast::expr,\n+                     proto: ast::proto,\n+                     decl: ast::fn_decl,\n+                     body: ast::blk,\n+                     is_loop_body: bool,\n+                     expected: option<ty::t>) {\n+        let tcx = fcx.ccx.tcx;\n+\n+        let expected_tys = unpack_expected(fcx, expected) { |sty|\n+            alt sty {\n+              ty::ty_fn(fn_ty) {some({inputs:fn_ty.inputs,\n+                                      output:fn_ty.output})}\n+              _ {none}\n+            }\n+        };\n+\n+        // construct the function type\n+        let fty = ty::mk_fn(tcx,\n+                            ty_of_fn_decl(fcx, fcx, proto, decl,\n+                                          expected_tys));\n+\n+        #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n+               expr_to_str(expr), fcx.ty_to_str(fty));\n+\n+        fcx.write_ty(expr.id, fty);\n+\n+        let ret_ty = ty::ty_fn_ret(fty);\n+        let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n+\n+        check_fn(fcx.ccx, proto, decl, body, expr.id,\n+                 ret_ty, arg_tys, is_loop_body, some(fcx),\n+                 fcx.self_ty);\n+    }\n+\n+\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n@@ -3510,20 +3563,25 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         fcx.write_ty(id, result_ty);\n       }\n-      ast::expr_fn(proto, decl, body, captures) {\n-        check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   false, unifier);\n-        capture::check_capture_clause(tcx, expr.id, proto, *captures);\n+      ast::expr_fn(proto, decl, body, cap_clause) {\n+        check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n+        capture::check_capture_clause(tcx, expr.id, proto, cap_clause);\n       }\n-      ast::expr_fn_block(decl, body) {\n+      ast::expr_fn_block(decl, body, cap_clause) {\n         // Take the prototype from the expected type, but default to block:\n         let proto = unpack_expected(fcx, expected, {|sty|\n             alt sty { ty::ty_fn({proto, _}) { some(proto) } _ { none } }\n         }).get_default(ast::proto_box);\n-        check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   false, unifier);\n+        check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n+        capture::check_capture_clause(tcx, expr.id, proto, cap_clause);\n       }\n       ast::expr_loop_body(b) {\n+        // a loop body is the special argument to a `for` loop.  We know that\n+        // there will be an expected type in this context because it can only\n+        // appear in the context of a call, so we get the expected type of the\n+        // parameter. The catch here is that we need to validate two things:\n+        // 1. a closure that returns a bool is expected\n+        // 2. the cloure that was given returns unit\n         let expected_sty = unpack_expected(fcx, expected, {|x|some(x)}).get();\n         let (inner_ty, proto) = alt expected_sty {\n           ty::ty_fn(fty) {\n@@ -3544,10 +3602,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n         };\n         alt check b.node {\n-          ast::expr_fn_block(decl, body) {\n-            check_expr_fn_with_unifier(fcx, b, proto, decl, body, true) {||\n-                demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-            }\n+          ast::expr_fn_block(decl, body, cap_clause) {\n+            check_expr_fn(fcx, b, proto, decl, body, true, some(inner_ty));\n+            demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n+            capture::check_capture_clause(tcx, b.id, proto, cap_clause);\n           }\n         }\n         let block_ty = structurally_resolved_type("}, {"sha": "80af3229bc4057847a8a925c92ab6979d2eae4e8", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -130,18 +130,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    alt ty::type_def_id(typ) {\n-      some(def_id) {\n-        let cs = ast_map::path_to_str(ty::item_path(cx, def_id));\n-        ret alt ty::get(typ).struct {\n-          ty_enum(_, substs) | ty_res(_, _, substs) | ty_class(_, substs) |\n-          ty_iface(_, substs) {\n-            parameterized(cx, cs, substs.self_r, substs.tps)\n-          }\n-          _ { cs }\n-        };\n-      }\n-      none { /* fallthrough */}\n+    for ty::type_def_id(typ).each { |def_id|\n+        // note that this typedef cannot have type parameters\n+        ret ast_map::path_to_str(ty::item_path(cx, def_id));\n     }\n \n     // pretty print the structural type representation:"}, {"sha": "c10fb806af4f05e487ab28ede459709841cf2d24", "filename": "src/test/compile-fail/cap-clause-move-upvar.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -1,8 +1,7 @@\n-// error-pattern:upvars (like 'x') cannot be moved into a closure\n fn main() {\n     let x = 5;\n-    let _y = fn~[move x]() -> int {\n-        let _z = fn~[move x]() -> int { x };\n+    let _y = fn~(move x) -> int {\n+        let _z = fn~(move x) -> int { x }; //! ERROR moving out of upvar\n         22\n     };\n }"}, {"sha": "941535ef0f1829a2cd9a6dd293f929a009750ae0", "filename": "src/test/compile-fail/pptypedef.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -0,0 +1,8 @@\n+type foo = option<int>;\n+\n+fn bar(_t: foo) {}\n+\n+fn main() {\n+    // we used to print foo<int>:\n+    bar(some(3u)); //! ERROR mismatched types: expected `foo`\n+}\n\\ No newline at end of file"}, {"sha": "510bef1cae07dd5bf61b593059e64f6720e19183", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -4,7 +4,6 @@ fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     // Earlier versions of our type checker accepted this:\n     vec::iter(v) {|&&inner: [T]|\n         //!^ ERROR values differ in mutability\n-        //!^^ ERROR values differ in mutability\n         r += inner;\n     }\n "}, {"sha": "b17ea3fa68e5e640a530fef9da4038fa5085c3ea", "filename": "src/test/pretty/cap-clause.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fpretty%2Fcap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Fpretty%2Fcap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fcap-clause.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -4,14 +4,14 @@ fn main() {\n     let x = 1;\n     let y = 2;\n     let z = 3;\n-    let l1 = fn@[copy x]() -> int { x + y };\n-    let l2 = fn@[copy x; move y]() -> int { x + y };\n-    let l3 = fn@[move z]() -> int { z };\n+    let l1 = fn@(w: int, copy x) -> int { w + x + y };\n+    let l2 = fn@(w: int, copy x, move y) -> int { w + x + y };\n+    let l3 = fn@(w: int, move z) -> int { w + z };\n \n     let x = 1;\n     let y = 2;\n     let z = 3;\n-    let s1 = fn~[copy x]() -> int { x + y };\n-    let s2 = fn~[copy x; move y]() -> int { x + y };\n-    let s3 = fn~[move z]() -> int { z };\n+    let s1 = fn~(copy x) -> int { x + y };\n+    let s2 = fn~(copy x, move y) -> int { x + y };\n+    let s3 = fn~(move z) -> int { z };\n }"}, {"sha": "c2e0f4b58dd70b0dd07df3a916c8d3533289474f", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -1,16 +1,29 @@\n fn main() {\n     let x = ~1;\n     let y = ptr::addr_of(*x) as uint;\n-\n-    let lam_copy = fn@[copy x]() -> uint { ptr::addr_of(*x) as uint };\n-    let lam_move = fn@[move x]() -> uint { ptr::addr_of(*x) as uint };\n+    let lam_copy = fn@(copy x) -> uint { ptr::addr_of(*x) as uint };\n+    let lam_move = fn@(move x) -> uint { ptr::addr_of(*x) as uint };\n     assert lam_copy() != y;\n     assert lam_move() == y;\n \n     let x = ~2;\n     let y = ptr::addr_of(*x) as uint;\n-    let snd_copy = fn~[copy x]() -> uint { ptr::addr_of(*x) as uint };\n-    let snd_move = fn~[move x]() -> uint { ptr::addr_of(*x) as uint };\n+    let lam_copy: fn@() -> uint = { |copy x| ptr::addr_of(*x) as uint };\n+    let lam_move: fn@() -> uint = { |move x| ptr::addr_of(*x) as uint };\n+    assert lam_copy() != y;\n+    assert lam_move() == y;\n+\n+    let x = ~3;\n+    let y = ptr::addr_of(*x) as uint;\n+    let snd_copy = fn~(copy x) -> uint { ptr::addr_of(*x) as uint };\n+    let snd_move = fn~(move x) -> uint { ptr::addr_of(*x) as uint };\n     assert snd_copy() != y;\n     assert snd_move() == y;\n+\n+    let x = ~4;\n+    let y = ptr::addr_of(*x) as uint;\n+    let lam_copy: fn~() -> uint = { |copy x| ptr::addr_of(*x) as uint };\n+    let lam_move: fn~() -> uint = { |move x| ptr::addr_of(*x) as uint };\n+    assert lam_copy() != y;\n+    assert lam_move() == y;\n }"}, {"sha": "08fca191abd2dc00925e833257ebd223eabc8130", "filename": "src/test/run-pass/cap-clause-not-used.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -1,5 +1,5 @@\n // error-pattern: warning: Captured variable 'y' not used in closure\n fn main() {\n     let x = 5;\n-    let _y = fn~[copy x]() { };\n+    let _y = fn~(copy x) { };\n }"}, {"sha": "fc5425f24e911e30f29555836a8c76119ce48373", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ec6bd2c3c472ea140ed60de38dd50c672fc80a/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=50ec6bd2c3c472ea140ed60de38dd50c672fc80a", "patch": "@@ -3,7 +3,7 @@\n fn foo() -> fn@() -> int {\n     let k = ~22;\n     let _u = {a: k};\n-    ret fn@[move k]() -> int { 22 };\n+    ret fn@(move k) -> int { 22 };\n }\n \n fn main() {"}]}