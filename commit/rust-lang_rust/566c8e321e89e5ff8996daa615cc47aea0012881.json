{"sha": "566c8e321e89e5ff8996daa615cc47aea0012881", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NmM4ZTMyMWU4OWU1ZmY4OTk2ZGFhNjE1Y2M0N2FlYTAwMTI4ODE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T15:56:38Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T15:56:38Z"}, "message": "migrate enums to new id", "tree": {"sha": "58c2f4741b9305e840d41eb35eb8f4e7d5761fe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58c2f4741b9305e840d41eb35eb8f4e7d5761fe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/566c8e321e89e5ff8996daa615cc47aea0012881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/566c8e321e89e5ff8996daa615cc47aea0012881", "html_url": "https://github.com/rust-lang/rust/commit/566c8e321e89e5ff8996daa615cc47aea0012881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/566c8e321e89e5ff8996daa615cc47aea0012881/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cefc5cbb4a95d2a473ea656efe603bef979b5c49", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefc5cbb4a95d2a473ea656efe603bef979b5c49", "html_url": "https://github.com/rust-lang/rust/commit/cefc5cbb4a95d2a473ea656efe603bef979b5c49"}], "stats": {"total": 334, "additions": 191, "deletions": 143}, "files": [{"sha": "baf853a3a478e7f47ba23c2e3749bfef00fd12c2", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -13,7 +13,7 @@ use crate::{\n     HirDatabase, DefKind,\n     SourceItemId,\n     type_ref::TypeRef,\n-    ids::{StructLoc},\n+    ids::{StructLoc, EnumLoc},\n };\n \n impl Struct {\n@@ -33,6 +33,19 @@ impl Struct {\n     }\n }\n \n+impl Enum {\n+    pub(crate) fn from_ast(\n+        db: &impl HirDatabase,\n+        module: Module,\n+        file_id: HirFileId,\n+        ast: &ast::EnumDef,\n+    ) -> Enum {\n+        let loc: EnumLoc = EnumLoc::from_ast(db, module, file_id, ast);\n+        let id = loc.id(db);\n+        Enum { id }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n     pub(crate) name: Option<Name>,\n@@ -55,20 +68,20 @@ impl StructData {\n \n fn get_def_id(\n     db: &impl HirDatabase,\n-    same_file_loc: &DefLoc,\n+    module: Module,\n+    file_id: HirFileId,\n     node: &SyntaxNode,\n     expected_kind: DefKind,\n ) -> DefId {\n-    let file_id = same_file_loc.source_item_id.file_id;\n     let file_items = db.file_items(file_id);\n \n     let item_id = file_items.id_of(file_id, node);\n     let source_item_id = SourceItemId {\n+        file_id,\n         item_id: Some(item_id),\n-        ..same_file_loc.source_item_id\n     };\n     let loc = DefLoc {\n-        module: same_file_loc.module,\n+        module,\n         kind: expected_kind,\n         source_item_id,\n     };\n@@ -87,27 +100,30 @@ impl EnumData {\n         EnumData { name, variants }\n     }\n \n-    pub(crate) fn enum_data_query(db: &impl HirDatabase, def_id: DefId) -> Arc<EnumData> {\n-        let def_loc = def_id.loc(db);\n-        assert!(def_loc.kind == DefKind::Enum);\n-        let syntax = db.file_item(def_loc.source_item_id);\n-        let enum_def = ast::EnumDef::cast(&syntax).expect(\"enum def should point to EnumDef node\");\n+    pub(crate) fn enum_data_query(db: &impl HirDatabase, e: Enum) -> Arc<EnumData> {\n+        let (file_id, enum_def) = e.source(db);\n+        let module = e.module(db);\n         let variants = if let Some(vl) = enum_def.variant_list() {\n             vl.variants()\n                 .filter_map(|variant_def| {\n                     let name = variant_def.name().map(|n| n.as_name());\n \n                     name.map(|n| {\n-                        let def_id =\n-                            get_def_id(db, &def_loc, variant_def.syntax(), DefKind::EnumVariant);\n+                        let def_id = get_def_id(\n+                            db,\n+                            module,\n+                            file_id,\n+                            variant_def.syntax(),\n+                            DefKind::EnumVariant,\n+                        );\n                         (n, EnumVariant::new(def_id))\n                     })\n                 })\n                 .collect()\n         } else {\n             Vec::new()\n         };\n-        Arc::new(EnumData::new(enum_def, variants))\n+        Arc::new(EnumData::new(&*enum_def, variants))\n     }\n }\n \n@@ -139,14 +155,10 @@ impl EnumVariantData {\n         let syntax = db.file_item(def_loc.source_item_id);\n         let variant_def = ast::EnumVariant::cast(&syntax)\n             .expect(\"enum variant def should point to EnumVariant node\");\n-        let enum_node = syntax\n-            .parent()\n-            .expect(\"enum variant should have enum variant list ancestor\")\n-            .parent()\n-            .expect(\"enum variant list should have enum ancestor\");\n-        let enum_def_id = get_def_id(db, &def_loc, enum_node, DefKind::Enum);\n-\n-        Arc::new(EnumVariantData::new(variant_def, Enum::new(enum_def_id)))\n+        let enum_def = variant_def.parent_enum();\n+        let e = Enum::from_ast(db, def_loc.module, def_loc.source_item_id.file_id, enum_def);\n+\n+        Arc::new(EnumVariantData::new(variant_def, e))\n     }\n }\n "}, {"sha": "0a96d6f6d38da2165723a59defc0f5e134810528", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     code_model_impl::def_id_to_ast,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n-    ids::{FunctionId, StructId},\n+    ids::{FunctionId, StructId, EnumId},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -69,30 +69,37 @@ pub enum ModuleDef {\n     Module(Module),\n     Function(Function),\n     Struct(Struct),\n+    Enum(Enum),\n     Def(DefId),\n }\n+//FIXME: change to from\n+impl From<Module> for ModuleDef {\n+    fn from(it: Module) -> ModuleDef {\n+        ModuleDef::Module(it)\n+    }\n+}\n \n-impl Into<ModuleDef> for Module {\n-    fn into(self) -> ModuleDef {\n-        ModuleDef::Module(self)\n+impl From<Function> for ModuleDef {\n+    fn from(it: Function) -> ModuleDef {\n+        ModuleDef::Function(it)\n     }\n }\n \n-impl Into<ModuleDef> for Function {\n-    fn into(self) -> ModuleDef {\n-        ModuleDef::Function(self)\n+impl From<Struct> for ModuleDef {\n+    fn from(it: Struct) -> ModuleDef {\n+        ModuleDef::Struct(it)\n     }\n }\n \n-impl Into<ModuleDef> for Struct {\n-    fn into(self) -> ModuleDef {\n-        ModuleDef::Struct(self)\n+impl From<Enum> for ModuleDef {\n+    fn from(it: Enum) -> ModuleDef {\n+        ModuleDef::Enum(it)\n     }\n }\n \n-impl Into<ModuleDef> for DefId {\n-    fn into(self) -> ModuleDef {\n-        ModuleDef::Def(self)\n+impl From<DefId> for ModuleDef {\n+    fn from(it: DefId) -> ModuleDef {\n+        ModuleDef::Def(it)\n     }\n }\n \n@@ -249,34 +256,30 @@ impl Docs for Struct {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Enum {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: EnumId,\n }\n \n impl Enum {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        Enum { def_id }\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.loc(db).module\n     }\n \n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.enum_data(self.def_id).name.clone()\n+        db.enum_data(*self).name.clone()\n     }\n \n     pub fn variants(&self, db: &impl HirDatabase) -> Vec<(Name, EnumVariant)> {\n-        db.enum_data(self.def_id).variants.clone()\n+        db.enum_data(*self).variants.clone()\n     }\n \n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.loc(db).source(db)\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id.into())\n+        db.generic_params((*self).into())\n     }\n }\n "}, {"sha": "4ea649770ed4e7800b911eab3ad98b7d94114e8a", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{ast, SyntaxNode, TreeArc};\n \n use crate::{\n     Module, ModuleSource, Problem, ModuleDef,\n-    Crate, Name, Path, PathKind, PerNs, Def,\n+    Crate, Name, Path, PathKind, PerNs,\n     module_tree::ModuleId,\n     nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n@@ -135,31 +135,25 @@ impl Module {\n                         None => PerNs::none(),\n                     }\n                 }\n-                ModuleDef::Function(_) | ModuleDef::Struct(_) => PerNs::none(),\n-                ModuleDef::Def(def) => {\n-                    match def.resolve(db) {\n-                        Def::Enum(e) => {\n-                            // enum variant\n-                            let matching_variant = e\n-                                .variants(db)\n-                                .into_iter()\n-                                .find(|(n, _variant)| n == &segment.name);\n-\n-                            match matching_variant {\n-                                Some((_n, variant)) => {\n-                                    PerNs::both(variant.def_id().into(), e.def_id().into())\n-                                }\n-                                None => PerNs::none(),\n-                            }\n-                        }\n-                        _ => {\n-                            // could be an inherent method call in UFCS form\n-                            // (`Struct::method`), or some other kind of associated\n-                            // item... Which we currently don't handle (TODO)\n-                            PerNs::none()\n-                        }\n+                ModuleDef::Enum(e) => {\n+                    // enum variant\n+                    let matching_variant = e\n+                        .variants(db)\n+                        .into_iter()\n+                        .find(|(n, _variant)| n == &segment.name);\n+\n+                    match matching_variant {\n+                        Some((_n, variant)) => PerNs::both(variant.def_id().into(), (*e).into()),\n+                        None => PerNs::none(),\n                     }\n                 }\n+                ModuleDef::Function(_) | ModuleDef::Struct(_) => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated\n+                    // item... Which we currently don't handle (TODO)\n+                    PerNs::none()\n+                }\n+                ModuleDef::Def(_) => PerNs::none(),\n             };\n         }\n         curr_per_ns"}, {"sha": "34e41017b9b5aa7f23a1ce8600e4d6356f11cf0a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -8,7 +8,7 @@ use crate::{\n     SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n     Function, FnSignature, FnScopes,\n-    Struct,\n+    Struct, Enum,\n     macros::MacroExpansion,\n     module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n@@ -30,10 +30,10 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn fn_scopes(&self, func: Function) -> Arc<FnScopes>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n-    fn struct_data(&self, struct_: Struct) -> Arc<StructData>;\n+    fn struct_data(&self, s: Struct) -> Arc<StructData>;\n \n     #[salsa::invoke(crate::adt::EnumData::enum_data_query)]\n-    fn enum_data(&self, def_id: DefId) -> Arc<EnumData>;\n+    fn enum_data(&self, e: Enum) -> Arc<EnumData>;\n \n     #[salsa::invoke(crate::adt::EnumVariantData::enum_variant_data_query)]\n     fn enum_variant_data(&self, def_id: DefId) -> Arc<EnumVariantData>;"}, {"sha": "df23871c76a281ffa4dd8da3ce07861b9fb27738", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n \n use ra_syntax::ast::{self, AstNode, NameOwner, TypeParamsOwner};\n \n-use crate::{db::HirDatabase, DefId, Name, AsName, Function, Struct};\n+use crate::{db::HirDatabase, DefId, Name, AsName, Function, Struct, Enum};\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -26,6 +26,7 @@ pub struct GenericParams {\n pub enum GenericDef {\n     Function(Function),\n     Struct(Struct),\n+    Enum(Enum),\n     Def(DefId),\n }\n \n@@ -36,8 +37,14 @@ impl From<Function> for GenericDef {\n }\n \n impl From<Struct> for GenericDef {\n-    fn from(func: Struct) -> GenericDef {\n-        GenericDef::Struct(func)\n+    fn from(s: Struct) -> GenericDef {\n+        GenericDef::Struct(s)\n+    }\n+}\n+\n+impl From<Enum> for GenericDef {\n+    fn from(e: Enum) -> GenericDef {\n+        GenericDef::Enum(e)\n     }\n }\n \n@@ -54,30 +61,27 @@ impl GenericParams {\n     ) -> Arc<GenericParams> {\n         let mut generics = GenericParams::default();\n         match def {\n-            GenericDef::Function(func) => {\n-                let (_, fn_def) = func.source(db);\n-                if let Some(type_param_list) = fn_def.type_param_list() {\n-                    generics.fill(type_param_list)\n-                }\n-            }\n-            GenericDef::Struct(s) => {\n-                let (_, struct_def) = s.source(db);\n-                if let Some(type_param_list) = struct_def.type_param_list() {\n-                    generics.fill(type_param_list)\n-                }\n-            }\n+            GenericDef::Function(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Struct(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Enum(it) => generics.fill(&*it.source(db).1),\n             GenericDef::Def(def_id) => {\n                 let (_file_id, node) = def_id.source(db);\n                 if let Some(type_param_list) = node.children().find_map(ast::TypeParamList::cast) {\n-                    generics.fill(type_param_list)\n+                    generics.fill_params(type_param_list)\n                 }\n             }\n         }\n \n         Arc::new(generics)\n     }\n \n-    fn fill(&mut self, params: &ast::TypeParamList) {\n+    fn fill(&mut self, node: &impl TypeParamsOwner) {\n+        if let Some(params) = node.type_param_list() {\n+            self.fill_params(params)\n+        }\n+    }\n+\n+    fn fill_params(&mut self, params: &ast::TypeParamList) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param\n                 .name()"}, {"sha": "332cec9c86bdc1cd72160201f764cc3e1ead1557", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    HirDatabase, Def, Enum, EnumVariant, Crate,\n+    HirDatabase, Def, EnumVariant, Crate,\n     Module, Trait, Type, Static, Const,\n };\n \n@@ -247,25 +247,22 @@ pub struct DefLoc {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum DefKind {\n-    Struct,\n-    Enum,\n     EnumVariant,\n     Const,\n     Static,\n     Trait,\n     Type,\n     Item,\n-\n-    /// The constructor of a struct. E.g. if we have `struct Foo(usize)`, the\n-    /// name `Foo` needs to resolve to different types depending on whether we\n-    /// are in the types or values namespace: As a type, `Foo` of course refers\n-    /// to the struct `Foo`; as a value, `Foo` is a callable type with signature\n-    /// `(usize) -> Foo`. The cleanest approach to handle this seems to be to\n-    /// have different defs in the two namespaces.\n-    ///\n-    /// rustc does the same; note that it even creates a struct constructor if\n-    /// the struct isn't a tuple struct (see `CtorKind::Fictive` in rustc).\n-    StructCtor,\n+    // /// The constructor of a struct. E.g. if we have `struct Foo(usize)`, the\n+    // /// name `Foo` needs to resolve to different types depending on whether we\n+    // /// are in the types or values namespace: As a type, `Foo` of course refers\n+    // /// to the struct `Foo`; as a value, `Foo` is a callable type with signature\n+    // /// `(usize) -> Foo`. The cleanest approach to handle this seems to be to\n+    // /// have different defs in the two namespaces.\n+    // ///\n+    // /// rustc does the same; note that it even creates a struct constructor if\n+    // /// the struct isn't a tuple struct (see `CtorKind::Fictive` in rustc).\n+    // StructCtor,\n }\n \n impl DefId {\n@@ -276,8 +273,6 @@ impl DefId {\n     pub fn resolve(self, db: &impl HirDatabase) -> Def {\n         let loc = self.loc(db);\n         match loc.kind {\n-            DefKind::Struct => unreachable!(),\n-            DefKind::Enum => Def::Enum(Enum::new(self)),\n             DefKind::EnumVariant => Def::EnumVariant(EnumVariant::new(self)),\n             DefKind::Const => {\n                 let def = Const::new(self);\n@@ -295,8 +290,6 @@ impl DefId {\n                 let def = Type::new(self);\n                 Def::Type(def)\n             }\n-\n-            DefKind::StructCtor => Def::Item,\n             DefKind::Item => Def::Item,\n         }\n     }"}, {"sha": "435804e2d00628eb90dce0542989f496597db2d8", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -10,7 +10,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     SourceItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n     HirFileId, MacroCallLoc, AsName, PerNs, DefKind, DefLoc, Function,\n-    ModuleDef, Module, Struct,\n+    ModuleDef, Module, Struct, Enum,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -155,7 +155,14 @@ impl LoweredModule {\n                 }\n                 return;\n             }\n-            ast::ModuleItemKind::EnumDef(it) => it.name(),\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let e = Enum::from_ast(db, module, file_id, it);\n+                    let e: ModuleDef = e.into();\n+                    self.declarations.insert(name.as_name(), PerNs::types(e));\n+                }\n+                return;\n+            }\n             ast::ModuleItemKind::FnDef(it) => {\n                 if let Some(name) = it.name() {\n                     let func = Function::from_ast(db, module, file_id, it);\n@@ -233,8 +240,8 @@ impl DefKind {\n     fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n         match kind {\n             SyntaxKind::FN_DEF => unreachable!(),\n-            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n-            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n+            SyntaxKind::STRUCT_DEF => unreachable!(),\n+            SyntaxKind::ENUM_DEF => unreachable!(),\n             SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Trait),\n             SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Type),\n             SyntaxKind::CONST_DEF => PerNs::values(DefKind::Const),"}, {"sha": "6a5f4fae64cb0eaa884a5a64d454f4bf09f713a2", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -166,27 +166,28 @@ impl Substs {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AdtDef {\n     Struct(Struct),\n-    Def(DefId), // Enum\n+    Enum(Enum),\n }\n \n impl From<Struct> for AdtDef {\n-    fn from(struct_: Struct) -> AdtDef {\n-        AdtDef::Struct(struct_)\n+    fn from(s: Struct) -> AdtDef {\n+        AdtDef::Struct(s)\n     }\n }\n \n-impl From<DefId> for AdtDef {\n-    fn from(def_id: DefId) -> AdtDef {\n-        AdtDef::Def(def_id)\n+impl From<Enum> for AdtDef {\n+    fn from(e: Enum) -> AdtDef {\n+        AdtDef::Enum(e)\n     }\n }\n \n impl AdtDef {\n     fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n         match self {\n-            AdtDef::Struct(s) => s.module(db).krate(db),\n-            AdtDef::Def(def_id) => def_id.krate(db),\n+            AdtDef::Struct(s) => s.module(db),\n+            AdtDef::Enum(e) => e.module(db),\n         }\n+        .krate(db)\n     }\n }\n \n@@ -408,14 +409,16 @@ impl Ty {\n         }\n \n         // Resolve in module (in type namespace)\n-        let resolved = match module.resolve_path(db, path).take_types() {\n-            Some(ModuleDef::Def(r)) => r.into(),\n-            Some(ModuleDef::Function(f)) => f.into(),\n-            Some(ModuleDef::Struct(s)) => s.into(),\n-            None | Some(ModuleDef::Module(_)) => return Ty::Unknown,\n+        let typable: TypableDef = match module\n+            .resolve_path(db, path)\n+            .take_types()\n+            .and_then(|it| it.into())\n+        {\n+            None => return Ty::Unknown,\n+            Some(it) => it,\n         };\n-        let ty = db.type_for_def(resolved);\n-        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, resolved);\n+        let ty = db.type_for_def(typable);\n+        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, typable);\n         ty.apply_substs(substs)\n     }\n \n@@ -438,9 +441,8 @@ impl Ty {\n         let (def_generics, segment) = match resolved {\n             TypableDef::Function(func) => (func.generic_params(db), last),\n             TypableDef::Struct(s) => (s.generic_params(db), last),\n+            TypableDef::Enum(e) => (e.generic_params(db), last),\n             TypableDef::Def(def_id) => match def_id.resolve(db) {\n-                Def::Struct(s) => (s.generic_params(db), last),\n-                Def::Enum(e) => (e.generic_params(db), last),\n                 Def::Trait(t) => (t.generic_params(db), last),\n                 Def::EnumVariant(ev) => {\n                     // the generic args for an enum variant may be either specified\n@@ -680,7 +682,7 @@ fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n     Ty::Adt {\n-        def_id: s.def_id().into(),\n+        def_id: s.into(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n         substs: make_substs(&generics),\n     }\n@@ -696,6 +698,7 @@ pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> T\n pub enum TypableDef {\n     Function(Function),\n     Struct(Struct),\n+    Enum(Enum),\n     Def(DefId),\n }\n \n@@ -706,8 +709,14 @@ impl From<Function> for TypableDef {\n }\n \n impl From<Struct> for TypableDef {\n-    fn from(struct_: Struct) -> TypableDef {\n-        TypableDef::Struct(struct_)\n+    fn from(s: Struct) -> TypableDef {\n+        TypableDef::Struct(s)\n+    }\n+}\n+\n+impl From<Enum> for TypableDef {\n+    fn from(e: Enum) -> TypableDef {\n+        TypableDef::Enum(e)\n     }\n }\n \n@@ -717,10 +726,24 @@ impl From<DefId> for TypableDef {\n     }\n }\n \n+impl From<ModuleDef> for Option<TypableDef> {\n+    fn from(def: ModuleDef) -> Option<TypableDef> {\n+        let res = match def {\n+            ModuleDef::Def(r) => r.into(),\n+            ModuleDef::Function(f) => f.into(),\n+            ModuleDef::Struct(s) => s.into(),\n+            ModuleDef::Enum(e) => e.into(),\n+            ModuleDef::Module(_) => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n     match def {\n         TypableDef::Function(f) => type_for_fn(db, f),\n         TypableDef::Struct(s) => type_for_struct(db, s),\n+        TypableDef::Enum(e) => type_for_enum(db, e),\n         TypableDef::Def(def_id) => match def_id.resolve(db) {\n             Def::Enum(e) => type_for_enum(db, e),\n             Def::EnumVariant(ev) => type_for_enum_variant(db, ev),\n@@ -1134,12 +1157,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let typable = match self.module.resolve_path(self.db, &path).take_values()? {\n-            ModuleDef::Def(it) => it.into(),\n-            ModuleDef::Function(func) => func.into(),\n-            ModuleDef::Struct(s) => s.into(),\n-            ModuleDef::Module(_) => return None,\n-        };\n+        let typable: Option<TypableDef> = self\n+            .module\n+            .resolve_path(self.db, &path)\n+            .take_values()?\n+            .into();\n+        let typable = typable?;\n         let ty = self.db.type_for_def(typable);\n         let ty = self.insert_type_vars(ty);\n         Some(ty)\n@@ -1150,11 +1173,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n-        let def = match self.module.resolve_path(self.db, &path).take_types() {\n-            Some(ModuleDef::Def(def_id)) => def_id.into(),\n-            Some(ModuleDef::Function(func)) => func.into(),\n-            Some(ModuleDef::Struct(s)) => s.into(),\n-            None | Some(ModuleDef::Module(_)) => return (Ty::Unknown, None),\n+        let typable: Option<TypableDef> = self\n+            .module\n+            .resolve_path(self.db, &path)\n+            .take_types()\n+            .and_then(|it| it.into());\n+        let def = match typable {\n+            None => return (Ty::Unknown, None),\n+            Some(it) => it,\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n         // TODO provide generics of function\n@@ -1182,6 +1208,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(s.into()))\n             }\n+            TypableDef::Enum(_) => (Ty::Unknown, None),\n         }\n     }\n \n@@ -1300,6 +1327,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ModuleDef::Def(it) => Some(it.into()),\n                     ModuleDef::Function(func) => Some(func.into()),\n                     ModuleDef::Struct(s) => Some(s.into()),\n+                    ModuleDef::Enum(e) => Some(e.into()),\n                     ModuleDef::Module(_) => None,\n                 })\n                 .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),"}, {"sha": "fd65264b27478e2b8afb0ee5c08ae948ddae9595", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566c8e321e89e5ff8996daa615cc47aea0012881/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=566c8e321e89e5ff8996daa615cc47aea0012881", "patch": "@@ -430,6 +430,13 @@ impl StructDef {\n }\n \n impl EnumVariant {\n+    pub fn parent_enum(&self) -> &EnumDef {\n+        self.syntax()\n+            .parent()\n+            .and_then(|it| it.parent())\n+            .and_then(EnumDef::cast)\n+            .expect(\"EnumVariants are always nested in Enums\")\n+    }\n     pub fn flavor(&self) -> StructFlavor {\n         StructFlavor::from_node(self)\n     }"}]}