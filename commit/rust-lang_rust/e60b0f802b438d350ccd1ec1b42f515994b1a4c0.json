{"sha": "e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MGIwZjgwMmI0MzhkMzUwY2NkMWVjMWI0MmY1MTU5OTRiMWE0YzA=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-01-15T18:28:34Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-01-19T00:41:50Z"}, "message": "Refactor CodegenUnit size estimates", "tree": {"sha": "2b2b0fc5c840ed23d246525709e401aa12a979e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b2b0fc5c840ed23d246525709e401aa12a979e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "html_url": "https://github.com/rust-lang/rust/commit/e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "html_url": "https://github.com/rust-lang/rust/commit/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4"}], "stats": {"total": 94, "additions": 50, "deletions": 44}, "files": [{"sha": "bbef045a305a554840cfe441e77213272090518a", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast::NodeId;\n use syntax::symbol::InternedString;\n-use ty::Instance;\n+use ty::{Instance, TyCtxt};\n use util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n@@ -25,6 +25,22 @@ pub enum MonoItem<'tcx> {\n     GlobalAsm(NodeId),\n }\n \n+impl<'tcx> MonoItem<'tcx> {\n+    pub fn size_estimate<'a>(&self, tcx: &TyCtxt<'a, 'tcx, 'tcx>) -> usize {\n+        match *self {\n+            MonoItem::Fn(instance) => {\n+                // Estimate the size of a function based on how many statements\n+                // it contains.\n+                let mir = tcx.instance_mir(instance.def);\n+                mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n+            },\n+            // Conservatively estimate the size of a static declaration\n+            // or assembly to be 1.\n+            MonoItem::Static(_) | MonoItem::GlobalAsm(_) => 1,\n+        }\n+    }\n+}\n+\n impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                            hcx: &mut StableHashingContext<'tcx>,\n@@ -52,6 +68,7 @@ pub struct CodegenUnit<'tcx> {\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n+    size_estimate: Option<usize>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -101,6 +118,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         CodegenUnit {\n             name: name,\n             items: FxHashMap(),\n+            size_estimate: None,\n         }\n     }\n \n@@ -131,6 +149,25 @@ impl<'tcx> CodegenUnit<'tcx> {\n         let hash = hash & ((1u128 << 80) - 1);\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n+\n+    pub fn estimate_size<'a>(&mut self, tcx: &TyCtxt<'a, 'tcx, 'tcx>) {\n+        // Estimate the size of a codegen unit as (approximately) the number of MIR\n+        // statements it corresponds to.\n+        self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n+    }\n+\n+    pub fn size_estimate(&self) -> usize {\n+        // Should only be called if `estimate_size` has previously been called.\n+        assert!(self.size_estimate.is_some());\n+        self.size_estimate.unwrap()\n+    }\n+\n+    pub fn modify_size_estimate(&mut self, delta: usize) {\n+        assert!(self.size_estimate.is_some());\n+        if let Some(size_estimate) = self.size_estimate {\n+            self.size_estimate = Some(size_estimate + delta);\n+        }\n+    }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n@@ -140,6 +177,7 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n         let CodegenUnit {\n             ref items,\n             name,\n+            ..\n         } = *self;\n \n         name.hash_stable(hcx, hasher);"}, {"sha": "4150f9f95485bde1a82ab2c6f57bca0aae7f4d9e", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "patch": "@@ -110,7 +110,7 @@ use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use std::collections::hash_map::{HashMap, Entry};\n+use std::collections::hash_map::Entry;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use rustc::mir::mono::MonoItem;\n@@ -225,12 +225,14 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut initial_partitioning = place_root_translation_items(tcx,\n                                                                 trans_items);\n \n+    initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n+\n     debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(tcx, &mut initial_partitioning, count, &tcx.crate_name.as_str());\n+        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -242,6 +244,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                             inlining_map);\n \n+    post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n+\n     debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n@@ -405,8 +409,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn merge_codegen_units<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize,\n                              crate_name: &str) {\n     assert!(target_cgu_count >= 1);\n@@ -423,51 +426,16 @@ fn merge_codegen_units<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // the stable sort below will keep everything nice and deterministic.\n     codegen_units.sort_by_key(|cgu| cgu.name().clone());\n \n-    // Estimate the size of a codegen unit as (approximately) the number of MIR\n-    // statements it corresponds to.\n-    fn codegen_unit_size_estimate<'a, 'tcx>(cgu: &CodegenUnit<'tcx>,\n-                                            mono_item_sizes: &HashMap<MonoItem, usize>)\n-                                            -> usize {\n-        cgu.items().keys().map(|mi| mono_item_sizes.get(mi).unwrap()).sum()\n-    }\n-\n-    fn mono_item_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         item: &MonoItem<'tcx>)\n-                                         -> usize {\n-        match item {\n-            MonoItem::Fn(instance) => {\n-                // Estimate the size of a function based on how many statements\n-                // it contains.\n-                let mir = tcx.instance_mir(instance.def);\n-                mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n-            },\n-            // Conservatively estimate the size of a static declaration\n-            // or assembly to be 1.\n-            MonoItem::Static(_) | MonoItem::GlobalAsm(_) => 1,\n-        }\n-    }\n-\n-    // Since `sort_by_key` currently recomputes the keys for each comparison,\n-    // we can save unnecessary recomputations by storing size estimates for\n-    // each `MonoItem`. Storing estimates for `CodegenUnit` might be preferable,\n-    // but its structure makes it awkward to use as a key and additionally their\n-    // sizes change as the merging occurs, requiring the map to be updated.\n-    let mut sizes: HashMap<MonoItem, usize> = HashMap::new();\n-    for mis in codegen_units.iter().map(|cgu| cgu.items().keys()) {\n-        mis.for_each(|mi| {\n-            sizes.entry(*mi).or_insert_with(|| mono_item_size_estimate(tcx, mi));\n-        });\n-    }\n-\n     // Merge the two smallest codegen units until the target size is reached.\n     // Note that \"size\" is estimated here rather inaccurately as the number of\n     // translation items in a given unit. This could be improved on.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n-        codegen_units.sort_by_key(|cgu| usize::MAX - codegen_unit_size_estimate(cgu, &sizes));\n+        codegen_units.sort_by_key(|cgu| usize::MAX - cgu.size_estimate());\n         let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n         for (k, v) in smallest.items_mut().drain() {\n             second_smallest.items_mut().insert(k, v);\n         }"}, {"sha": "e03b6ee794d67d64ee578a6ba39a953436554786", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60b0f802b438d350ccd1ec1b42f515994b1a4c0/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e60b0f802b438d350ccd1ec1b42f515994b1a4c0", "patch": "@@ -79,7 +79,7 @@ use std::ffi::CString;\n use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n-use std::i32;\n+use std::{i32, usize};\n use std::iter;\n use std::sync::mpsc;\n use syntax_pos::Span;\n@@ -829,7 +829,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // account the size of each TransItem.\n     let codegen_units = {\n         let mut codegen_units = codegen_units;\n-        codegen_units.sort_by_key(|cgu| -(cgu.items().len() as isize));\n+        codegen_units.sort_by_key(|cgu| usize::MAX - cgu.size_estimate());\n         codegen_units\n     };\n "}]}