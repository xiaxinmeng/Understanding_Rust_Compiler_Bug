{"sha": "a21d82438b72a0394a670b6bfe95e3e62ee08802", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMWQ4MjQzOGI3MmEwMzk0YTY3MGI2YmZlOTVlM2U2MmVlMDg4MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-02T04:39:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-02T04:39:02Z"}, "message": "Auto merge of #57202 - matthewjasper:nll-typeck-promoteds, r=pnkfelix\n\nInclude bounds from promoted constants in NLL\n\nPreviously a promoted function wouldn't have its bound propagated out to\nthe main function body.\n\nWhen we visit a promoted, we now type check the MIR of the promoted\nand transfer any lifetime constraints to back to the main function's MIR.\n\nFixes #57170\n\nr? @nikomatsakis", "tree": {"sha": "bd26f65431b76f3432fdbcbfc24d9836b2e83763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd26f65431b76f3432fdbcbfc24d9836b2e83763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a21d82438b72a0394a670b6bfe95e3e62ee08802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a21d82438b72a0394a670b6bfe95e3e62ee08802", "html_url": "https://github.com/rust-lang/rust/commit/a21d82438b72a0394a670b6bfe95e3e62ee08802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a21d82438b72a0394a670b6bfe95e3e62ee08802/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d987b46bd7e81eb761a06252efb35b6d932a62f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d987b46bd7e81eb761a06252efb35b6d932a62f5", "html_url": "https://github.com/rust-lang/rust/commit/d987b46bd7e81eb761a06252efb35b6d932a62f5"}, {"sha": "3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "html_url": "https://github.com/rust-lang/rust/commit/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be"}], "stats": {"total": 266, "additions": 229, "deletions": 37}, "files": [{"sha": "f0d3a0d2986e53bda4a3ae1b9e3aae5a0bc1c37d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -1357,7 +1357,6 @@ pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n     fn apply_requirements(\n         &self,\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-        location: Location,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>>;\n@@ -1388,13 +1387,12 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     fn apply_requirements(\n         &self,\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-        location: Location,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>> {\n         debug!(\n-            \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n-            location, closure_def_id, closure_substs\n+            \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n+            closure_def_id, closure_substs\n         );\n \n         // Extract the values of the free regions in `closure_substs`"}, {"sha": "c4491778162f43ff66a6b258da102dc7105687ba", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -154,10 +154,10 @@ impl<N: Idx> LivenessValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n+    crate fn new(elements: Rc<RegionValueElements>) -> Self {\n         Self {\n-            elements: elements.clone(),\n             points: SparseBitMatrix::new(elements.num_points),\n+            elements: elements,\n         }\n     }\n "}, {"sha": "0a0a88e694260c19dfa6ec995913d99e0fb10717", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -47,6 +47,14 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n+    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n+        for promoted in mir.promoted.iter_mut() {\n+            self.visit_mir(promoted);\n+        }\n+\n+        self.super_mir(mir);\n+    }\n+\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n "}, {"sha": "9fa3bf5524739ef17d97ba6a7782b2f56cbd2d45", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 110, "deletions": 28, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -39,13 +39,14 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef, UnpackedKind, UserSubsts};\n use rustc::ty::{\n     self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserType,\n-    CanonicalUserTypeAnnotation, UserTypeAnnotationIndex,\n+    CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    UserTypeAnnotationIndex,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::layout::VariantIdx;\n use std::rc::Rc;\n-use std::{fmt, iter};\n+use std::{fmt, iter, mem};\n use syntax_pos::{Span, DUMMY_SP};\n \n macro_rules! span_mirbug {\n@@ -124,7 +125,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     let mut constraints = MirTypeckRegionConstraints {\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n-        liveness_constraints: LivenessValues::new(elements),\n+        liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: ConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n@@ -253,7 +254,7 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'b Mir<'tcx>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -283,7 +284,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n-                let annotation = &self.mir.user_type_annotations[annotation_index];\n+                let annotation = &self.cx.user_type_annotations[annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n@@ -385,7 +386,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n }\n \n impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'b Mir<'tcx>) -> Self {\n         TypeVerifier {\n             mir,\n             mir_def_id: cx.mir_def_id,\n@@ -454,19 +455,31 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n-            Place::Base(PlaceBase::Promoted(box (_index, sty))) => {\n+            Place::Base(PlaceBase::Promoted(box (index, sty))) => {\n                 let sty = self.sanitize_type(place, sty);\n-                // FIXME -- promoted MIR return types reference\n-                // various \"free regions\" (e.g., scopes and things)\n-                // that they ought not to do. We have to figure out\n-                // how best to handle that -- probably we want treat\n-                // promoted MIR much like closures, renumbering all\n-                // their free regions and propagating constraints\n-                // upwards. We have the same acyclic guarantees, so\n-                // that should be possible. But for now, ignore them.\n-                //\n-                // let promoted_mir = &self.mir.promoted[index];\n-                // promoted_mir.return_ty()\n+\n+                if !self.errors_reported {\n+                    let promoted_mir = &self.mir.promoted[index];\n+                    self.sanitize_promoted(promoted_mir, location);\n+\n+                    let promoted_ty = promoted_mir.return_ty();\n+\n+                    if let Err(terr) = self.cx.eq_types(\n+                        sty,\n+                        promoted_ty,\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            place,\n+                            \"bad promoted type ({:?}: {:?}): {:?}\",\n+                            promoted_ty,\n+                            sty,\n+                            terr\n+                        );\n+                    };\n+                }\n                 PlaceTy::Ty { ty: sty }\n             }\n             Place::Base(PlaceBase::Static(box Static { def_id, ty: sty })) => {\n@@ -533,6 +546,72 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         place_ty\n     }\n \n+    fn sanitize_promoted(&mut self, promoted_mir: &'b Mir<'tcx>, location: Location) {\n+        // Determine the constraints from the promoted MIR by running the type\n+        // checker on the promoted MIR, then transfer the constraints back to\n+        // the main MIR, changing the locations to the provided location.\n+\n+        let parent_mir = mem::replace(&mut self.mir, promoted_mir);\n+\n+        let all_facts = &mut None;\n+        let mut constraints = Default::default();\n+        let mut closure_bounds = Default::default();\n+        if let Some(ref mut bcx) = self.cx.borrowck_context {\n+            // Don't try to add borrow_region facts for the promoted MIR\n+            mem::swap(bcx.all_facts, all_facts);\n+\n+            // Use a new sets of constraints and closure bounds so that we can\n+            // modify their locations.\n+            mem::swap(&mut bcx.constraints.outlives_constraints, &mut constraints);\n+            mem::swap(&mut bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n+        };\n+\n+        self.visit_mir(promoted_mir);\n+\n+        if !self.errors_reported {\n+            // if verifier failed, don't do further checks to avoid ICEs\n+            self.cx.typeck_mir(promoted_mir);\n+        }\n+\n+        self.mir = parent_mir;\n+        // Merge the outlives constraints back in, at the given location.\n+        if let Some(ref mut base_bcx) = self.cx.borrowck_context {\n+            mem::swap(base_bcx.all_facts, all_facts);\n+            mem::swap(&mut base_bcx.constraints.outlives_constraints, &mut constraints);\n+            mem::swap(&mut base_bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n+\n+            let locations = location.to_locations();\n+            for constraint in constraints.iter() {\n+                let mut constraint = *constraint;\n+                constraint.locations = locations;\n+                if let ConstraintCategory::Return\n+                    | ConstraintCategory::UseAsConst\n+                    | ConstraintCategory::UseAsStatic = constraint.category\n+                {\n+                    // \"Returning\" from a promoted is an assigment to a\n+                    // temporary from the user's point of view.\n+                    constraint.category = ConstraintCategory::Boring;\n+                }\n+                base_bcx.constraints.outlives_constraints.push(constraint)\n+            }\n+\n+            if !closure_bounds.is_empty() {\n+                let combined_bounds_mapping = closure_bounds\n+                    .into_iter()\n+                    .flat_map(|(_, value)| value)\n+                    .collect();\n+                let existing = base_bcx\n+                    .constraints\n+                    .closure_bounds_mapping\n+                    .insert(location, combined_bounds_mapping);\n+                assert!(\n+                    existing.is_none(),\n+                    \"Multiple promoteds/closures at the same location.\"\n+                );\n+            }\n+        }\n+    }\n+\n     fn sanitize_projection(\n         &mut self,\n         base: PlaceTy<'tcx>,\n@@ -738,7 +817,9 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n-    mir: &'a Mir<'tcx>,\n+    /// User type annotations are shared between the main MIR and the MIR of\n+    /// all of the promoted items.\n+    user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n     mir_def_id: DefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -893,8 +974,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n-            mir,\n             mir_def_id,\n+            user_type_annotations: &mir.user_type_annotations,\n             param_env,\n             region_bound_pairs,\n             implicit_region_bound,\n@@ -910,9 +991,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn check_user_type_annotations(&mut self) {\n         debug!(\n             \"check_user_type_annotations: user_type_annotations={:?}\",\n-             self.mir.user_type_annotations\n+             self.user_type_annotations\n         );\n-        for user_annotation in &self.mir.user_type_annotations {\n+        for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let (annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n                 span, user_ty\n@@ -1095,7 +1176,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        let annotated_type = self.mir.user_type_annotations[user_ty.base].inferred_ty;\n+        let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n         let tcx = self.infcx.tcx;\n@@ -1281,7 +1362,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n-                        let annotation = &mir.user_type_annotations[annotation_index];\n+                        let annotation = &self.user_type_annotations[annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n@@ -1340,7 +1421,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n-                    let annotation = &mir.user_type_annotations[projection.base];\n+                    let annotation = &self.user_type_annotations[projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1998,7 +2079,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                self.add_reborrow_constraint(location, region, borrowed_place);\n+                self.add_reborrow_constraint(mir, location, region, borrowed_place);\n             }\n \n             // FIXME: These other cases have to be implemented in future PRs\n@@ -2097,6 +2178,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// - `borrowed_place`: the place `P` being borrowed\n     fn add_reborrow_constraint(\n         &mut self,\n+        mir: &Mir<'tcx>,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n         borrowed_place: &Place<'tcx>,\n@@ -2146,7 +2228,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             match *elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                    let base_ty = base.ty(mir, tcx).to_ty(tcx);\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n@@ -2275,7 +2357,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) -> ty::InstantiatedPredicates<'tcx> {\n         if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n             let closure_constraints =\n-                closure_region_requirements.apply_requirements(tcx, location, def_id, substs);\n+                closure_region_requirements.apply_requirements(tcx, def_id, substs);\n \n             if let Some(ref mut borrowck_context) = self.borrowck_context {\n                 let bounds_mapping = closure_constraints"}, {"sha": "ececd6fccd84bc75dedc371a24f1e7ca864eff3a", "filename": "src/test/ui/nll/issue-48697.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fissue-48697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fissue-48697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48697.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -1,14 +1,12 @@\n // Regression test for #48697\n \n-// compile-pass\n-\n #![feature(nll)]\n \n fn foo(x: &i32) -> &i32 {\n     let z = 4;\n     let f = &|y| y;\n     let k = f(&z);\n-    f(x)\n+    f(x) //~ cannot return value referencing local variable\n }\n \n fn main() {}"}, {"sha": "16b46c15b90b61ff9bba2cc268a59c8dec2de249", "filename": "src/test/ui/nll/issue-48697.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fissue-48697.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fissue-48697.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48697.stderr?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,11 @@\n+error[E0515]: cannot return value referencing local variable `z`\n+  --> $DIR/issue-48697.rs:9:5\n+   |\n+LL |     let k = f(&z);\n+   |               -- `z` is borrowed here\n+LL |     f(x) //~ cannot return value referencing local variable\n+   |     ^^^^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "59b21cf9ac2a9c9cab61ebf11351e0077e3932e8", "filename": "src/test/ui/nll/promoted-bounds.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,27 @@\n+#![feature(nll)]\n+\n+fn shorten_lifetime<'a, 'b, 'min>(a: &'a i32, b: &'b i32) -> &'min i32\n+where\n+    'a: 'min,\n+    'b: 'min,\n+{\n+    if *a < *b {\n+        &a\n+    } else {\n+        &b\n+    }\n+}\n+\n+fn main() {\n+    let promoted_fn_item_ref = &shorten_lifetime;\n+\n+    let a = &5;\n+    let ptr = {\n+        let l = 3;\n+        let b = &l; //~ ERROR does not live long enough\n+        let c = promoted_fn_item_ref(a, b);\n+        c\n+    };\n+\n+    println!(\"ptr = {:?}\", ptr);\n+}"}, {"sha": "9798f238fc4d01290dae78ea50dd903e4d3bbb71", "filename": "src/test/ui/nll/promoted-bounds.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.stderr?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `l` does not live long enough\n+  --> $DIR/promoted-bounds.rs:21:17\n+   |\n+LL |     let ptr = {\n+   |         --- borrow later stored here\n+LL |         let l = 3;\n+LL |         let b = &l; //~ ERROR does not live long enough\n+   |                 ^^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `l` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "7b3bbad4c1e0c5e8113e72f9afdf3436228851a5", "filename": "src/test/ui/nll/promoted-closure-pair.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,12 @@\n+// Check that we handle multiple closures in the same promoted constant.\n+\n+#![feature(nll)]\n+\n+fn foo() -> &'static i32 {\n+    let z = 0;\n+    let p = &(|y| y, |y| y);\n+    p.0(&z);\n+    p.1(&z)         //~ ERROR cannot return\n+}\n+\n+fn main() {}"}, {"sha": "5f4a6037668b5abee869053a78e9c0e4b0b38340", "filename": "src/test/ui/nll/promoted-closure-pair.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.stderr?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `z`\n+  --> $DIR/promoted-closure-pair.rs:9:5\n+   |\n+LL |     p.1(&z)         //~ ERROR cannot return\n+   |     ^^^^--^\n+   |     |   |\n+   |     |   `z` is borrowed here\n+   |     returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "fa2d2fb81183dc32ae7f3e322e2e8a70bd4c175e", "filename": "src/test/ui/nll/user-annotations/promoted-annotation.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.rs?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,12 @@\n+// Test that type annotations are checked in promoted constants correctly.\n+\n+#![feature(nll)]\n+\n+fn foo<'a>() {\n+    let x = 0;\n+    let f = &drop::<&'a i32>;\n+    f(&x);\n+    //~^ ERROR `x` does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "144af1e0ec120c8ee50828b895fcfbaada3d1519", "filename": "src/test/ui/nll/user-annotations/promoted-annotation.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a21d82438b72a0394a670b6bfe95e3e62ee08802/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.stderr?ref=a21d82438b72a0394a670b6bfe95e3e62ee08802", "patch": "@@ -0,0 +1,17 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/promoted-annotation.rs:8:7\n+   |\n+LL | fn foo<'a>() {\n+   |        -- lifetime `'a` defined here\n+LL |     let x = 0;\n+LL |     let f = &drop::<&'a i32>;\n+   |             ---------------- assignment requires that `x` is borrowed for `'a`\n+LL |     f(&x);\n+   |       ^^ borrowed value does not live long enough\n+LL |     //~^ ERROR `x` does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}