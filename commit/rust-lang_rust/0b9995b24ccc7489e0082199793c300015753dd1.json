{"sha": "0b9995b24ccc7489e0082199793c300015753dd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiOTk5NWIyNGNjYzc0ODllMDA4MjE5OTc5M2MzMDAwMTU3NTNkZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-10T02:18:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-10T02:18:10Z"}, "message": "Auto merge of #31618 - alexcrichton:no-thread-spawns, r=brson\n\nOptimize some functions in std::process\n\n* Be sure that `read_to_end` gets directed towards `read_to_end_uninitialized` for all handles\n* When spawning a child that guaranteed doesn't need a stdin, don't actually create a stdin pipe for that process, instead just redirect it to /dev/null\n* When calling `wait_with_output`, don't spawn threads to read out the pipes of the child. Instead drain all pipes on the calling thread and *then* wait on the process.\n\nFunctionally, it is intended that nothing changes as part of this PR\n\n---\n\nNote that this was the same as #31613, and even after that it turned out that fixing Windows was easier than I thought! To copy a comment from over there:\n\n> As some rationale for this as well, it's always bothered me that we've spawned threads in the standard library for this (seems a bit overkill), and I've also been curious lately as to our why our build times for Windows are so much higher than Unix (on the buildbots we have). I have done basically 0 investigation into why, but I figured it can't help to try to optimize Command::output which I believe is called quite a few times during the test suite.", "tree": {"sha": "92c841b3b585d37877a5d92facfb74b0bae6eabd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92c841b3b585d37877a5d92facfb74b0bae6eabd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b9995b24ccc7489e0082199793c300015753dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9995b24ccc7489e0082199793c300015753dd1", "html_url": "https://github.com/rust-lang/rust/commit/0b9995b24ccc7489e0082199793c300015753dd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b9995b24ccc7489e0082199793c300015753dd1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc62db802f9cb19606d3bfa4c4df0d0bc438543b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc62db802f9cb19606d3bfa4c4df0d0bc438543b", "html_url": "https://github.com/rust-lang/rust/commit/cc62db802f9cb19606d3bfa4c4df0d0bc438543b"}, {"sha": "7c3038f82477491e20c6f80c0139ddb1f1b912ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3038f82477491e20c6f80c0139ddb1f1b912ca", "html_url": "https://github.com/rust-lang/rust/commit/7c3038f82477491e20c6f80c0139ddb1f1b912ca"}], "stats": {"total": 662, "additions": 609, "deletions": 53}, "files": [{"sha": "2278a549559c38872b4338cb002ecc2a80d860dc", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -1 +1 @@\n-Subproject commit e19309c8b4e8bbd11f4d84dfffd75e3d1ac477fe\n+Subproject commit 2278a549559c38872b4338cb002ecc2a80d860dc"}, {"sha": "6b88d498b1041666fdd26e07e59ea0ddae099122", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -22,7 +22,6 @@ use ffi::OsString;\n use io::{self, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs as fs_imp;\n-use sys_common::io::read_to_end_uninitialized;\n use sys_common::{AsInnerMut, FromInner, AsInner, IntoInner};\n use vec::Vec;\n use time::SystemTime;\n@@ -351,7 +350,7 @@ impl Read for File {\n         self.inner.read(buf)\n     }\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        unsafe { read_to_end_uninitialized(self, buf) }\n+        self.inner.read_to_end(buf)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -372,6 +371,9 @@ impl<'a> Read for &'a File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.inner.read_to_end(buf)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a File {"}, {"sha": "25309a785c45a3e08b25ea25ac759db63ffa81d1", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -18,7 +18,6 @@ use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n-use sys_common::io::{read_to_end_uninitialized};\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use thread::LocalKeyState;\n \n@@ -78,6 +77,9 @@ fn stderr_raw() -> io::Result<StderrRaw> { stdio::Stderr::new().map(StderrRaw) }\n \n impl Read for StdinRaw {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n }\n impl Write for StdoutRaw {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n@@ -116,6 +118,12 @@ impl<R: io::Read> io::Read for Maybe<R> {\n             Maybe::Fake => Ok(0)\n         }\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        match *self {\n+            Maybe::Real(ref mut r) => handle_ebadf(r.read_to_end(buf), 0),\n+            Maybe::Fake => Ok(0)\n+        }\n+    }\n }\n \n fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n@@ -294,7 +302,7 @@ impl<'a> Read for StdinLock<'a> {\n         self.inner.read(buf)\n     }\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        unsafe { read_to_end_uninitialized(self, buf) }\n+        self.inner.read_to_end(buf)\n     }\n }\n "}, {"sha": "414696413f49488b9ca26094e1c9c29598b36763", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -14,7 +14,6 @@ use io::prelude::*;\n use fmt;\n use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n-use sys_common::io::read_to_end_uninitialized;\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n@@ -269,7 +268,7 @@ impl TcpStream {\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        unsafe { read_to_end_uninitialized(self, buf) }\n+        self.0.read_to_end(buf)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -281,7 +280,7 @@ impl Write for TcpStream {\n impl<'a> Read for &'a TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        unsafe { read_to_end_uninitialized(self, buf) }\n+        self.0.read_to_end(buf)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5813d82a315a6bb17d371157ad2bef357e5f118c", "filename": "src/libstd/process.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -20,10 +20,9 @@ use fmt;\n use io;\n use path::Path;\n use str;\n-use sys::pipe::AnonPipe;\n+use sys::pipe::{read2, AnonPipe};\n use sys::process as imp;\n use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n-use thread::{self, JoinHandle};\n \n /// Representation of a running or exited child process.\n ///\n@@ -134,6 +133,9 @@ impl Read for ChildStdout {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.inner.read_to_end(buf)\n+    }\n }\n \n impl AsInner<AnonPipe> for ChildStdout {\n@@ -161,6 +163,9 @@ impl Read for ChildStderr {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.inner.read_to_end(buf)\n+    }\n }\n \n impl AsInner<AnonPipe> for ChildStderr {\n@@ -289,7 +294,7 @@ impl Command {\n     /// By default, stdin, stdout and stderr are inherited from the parent.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        self.inner.spawn(imp::Stdio::Inherit).map(Child::from_inner)\n+        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -312,7 +317,7 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.inner.spawn(imp::Stdio::MakePipe).map(Child::from_inner)\n+        self.inner.spawn(imp::Stdio::MakePipe, false).map(Child::from_inner)\n             .and_then(|p| p.wait_with_output())\n     }\n \n@@ -334,7 +339,8 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn status(&mut self) -> io::Result<ExitStatus> {\n-        self.spawn().and_then(|mut p| p.wait())\n+        self.inner.spawn(imp::Stdio::Inherit, false).map(Child::from_inner)\n+                  .and_then(|mut p| p.wait())\n     }\n }\n \n@@ -496,24 +502,29 @@ impl Child {\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait_with_output(mut self) -> io::Result<Output> {\n         drop(self.stdin.take());\n-        fn read<R>(mut input: R) -> JoinHandle<io::Result<Vec<u8>>>\n-            where R: Read + Send + 'static\n-        {\n-            thread::spawn(move || {\n-                let mut ret = Vec::new();\n-                input.read_to_end(&mut ret).map(|_| ret)\n-            })\n+\n+        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n+        match (self.stdout.take(), self.stderr.take()) {\n+            (None, None) => {}\n+            (Some(mut out), None) => {\n+                let res = out.read_to_end(&mut stdout);\n+                res.unwrap();\n+            }\n+            (None, Some(mut err)) => {\n+                let res = err.read_to_end(&mut stderr);\n+                res.unwrap();\n+            }\n+            (Some(out), Some(err)) => {\n+                let res = read2(out.inner, &mut stdout, err.inner, &mut stderr);\n+                res.unwrap();\n+            }\n         }\n-        let stdout = self.stdout.take().map(read);\n-        let stderr = self.stderr.take().map(read);\n-        let status = try!(self.wait());\n-        let stdout = stdout.and_then(|t| t.join().unwrap().ok());\n-        let stderr = stderr.and_then(|t| t.join().unwrap().ok());\n \n+        let status = try!(self.wait());\n         Ok(Output {\n             status: status,\n-            stdout: stdout.unwrap_or(Vec::new()),\n-            stderr: stderr.unwrap_or(Vec::new()),\n+            stdout: stdout,\n+            stderr: stderr,\n         })\n     }\n }"}, {"sha": "aa92e5be1140330943ec870f855f74f2ae0250c8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -225,6 +225,10 @@ impl TcpStream {\n         self.inner.read(buf)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.inner.read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = try!(cvt(unsafe {"}, {"sha": "8ec073858fd2115eb6aaf32773e9d03f586da1f4", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,12 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io;\n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n+use prelude::v1::*;\n+\n+use io::{self, Read};\n use libc::{self, c_int, size_t, c_void};\n use mem;\n+use sync::atomic::{AtomicBool, Ordering};\n use sys::cvt;\n use sys_common::AsInner;\n-use sync::atomic::{AtomicBool, Ordering};\n+use sys_common::io::read_to_end_uninitialized;\n \n pub struct FileDesc {\n     fd: c_int,\n@@ -42,6 +47,11 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = try!(cvt(unsafe {\n             libc::write(self.fd,\n@@ -67,6 +77,20 @@ impl FileDesc {\n         }\n     }\n \n+    pub fn set_nonblocking(&self, nonblocking: bool) {\n+        unsafe {\n+            let previous = libc::fcntl(self.fd, libc::F_GETFL);\n+            debug_assert!(previous != -1);\n+            let new = if nonblocking {\n+                previous | libc::O_NONBLOCK\n+            } else {\n+                previous & !libc::O_NONBLOCK\n+            };\n+            let ret = libc::fcntl(self.fd, libc::F_SETFL, new);\n+            debug_assert!(ret != -1);\n+        }\n+    }\n+\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n@@ -118,6 +142,16 @@ impl FileDesc {\n     }\n }\n \n+impl<'a> Read for &'a FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n+}\n+\n impl AsInner<c_int> for FileDesc {\n     fn as_inner(&self) -> &c_int { &self.fd }\n }"}, {"sha": "3985a07470e0dc4def49786863c7daf6ad474c84", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -486,6 +486,10 @@ impl File {\n         self.0.read(buf)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }"}, {"sha": "acf501d5fda88a8d6c0eeee4f4225e1cc7bbfea7", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -116,6 +116,10 @@ impl Socket {\n         self.0.read(buf)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {"}, {"sha": "e5cb37610011b42496490e2514c63eb098f8d3da", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n+use cmp;\n use io;\n use libc::{self, c_int};\n+use mem;\n use sys::cvt_r;\n use sys::fd::FileDesc;\n \n@@ -57,10 +61,65 @@ impl AnonPipe {\n         self.0.read(buf)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n     pub fn fd(&self) -> &FileDesc { &self.0 }\n     pub fn into_fd(self) -> FileDesc { self.0 }\n }\n+\n+pub fn read2(p1: AnonPipe,\n+             v1: &mut Vec<u8>,\n+             p2: AnonPipe,\n+             v2: &mut Vec<u8>) -> io::Result<()> {\n+    // Set both pipes into nonblocking mode as we're gonna be reading from both\n+    // in the `select` loop below, and we wouldn't want one to block the other!\n+    let p1 = p1.into_fd();\n+    let p2 = p2.into_fd();\n+    p1.set_nonblocking(true);\n+    p2.set_nonblocking(true);\n+\n+    let max = cmp::max(p1.raw(), p2.raw());\n+    loop {\n+        // wait for either pipe to become readable using `select`\n+        try!(cvt_r(|| unsafe {\n+            let mut read: libc::fd_set = mem::zeroed();\n+            libc::FD_SET(p1.raw(), &mut read);\n+            libc::FD_SET(p2.raw(), &mut read);\n+            libc::select(max + 1, &mut read, 0 as *mut _, 0 as *mut _,\n+                         0 as *mut _)\n+        }));\n+\n+        // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+        // EAGAIN. If we hit EOF, then this will happen because the underlying\n+        // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+        // this case we flip the other fd back into blocking mode and read\n+        // whatever's leftover on that file descriptor.\n+        let read = |fd: &FileDesc, dst: &mut Vec<u8>| {\n+            match fd.read_to_end(dst) {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n+                       e.raw_os_error() == Some(libc::EAGAIN) {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        };\n+        if try!(read(&p1, v1)) {\n+            p2.set_nonblocking(false);\n+            return p2.read_to_end(v2).map(|_| ());\n+        }\n+        if try!(read(&p2, v2)) {\n+            p1.set_nonblocking(false);\n+            return p1.read_to_end(v1).map(|_| ());\n+        }\n+    }\n+}"}, {"sha": "47b0ff42f932274169413b5658df890fef60aea5", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -216,7 +216,7 @@ impl Command {\n         self.stderr = Some(stderr);\n     }\n \n-    pub fn spawn(&mut self, default: Stdio)\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n@@ -225,7 +225,7 @@ impl Command {\n                                       \"nul byte found in provided data\"));\n         }\n \n-        let (ours, theirs) = try!(self.setup_io(default));\n+        let (ours, theirs) = try!(self.setup_io(default, needs_stdin));\n         let (input, output) = try!(sys::pipe::anon_pipe());\n \n         let pid = unsafe {\n@@ -298,7 +298,7 @@ impl Command {\n                                   \"nul byte found in provided data\")\n         }\n \n-        match self.setup_io(default) {\n+        match self.setup_io(default, true) {\n             Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n             Err(e) => e,\n         }\n@@ -408,8 +408,11 @@ impl Command {\n     }\n \n \n-    fn setup_io(&self, default: Stdio) -> io::Result<(StdioPipes, ChildPipes)> {\n-        let stdin = self.stdin.as_ref().unwrap_or(&default);\n+    fn setup_io(&self, default: Stdio, needs_stdin: bool)\n+                -> io::Result<(StdioPipes, ChildPipes)> {\n+        let null = Stdio::Null;\n+        let default_stdin = if needs_stdin {&default} else {&null};\n+        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let (their_stdin, our_stdin) = try!(stdin.to_child_stdio(true));\n@@ -648,7 +651,7 @@ mod tests {\n             cmd.stdin(Stdio::MakePipe);\n             cmd.stdout(Stdio::MakePipe);\n \n-            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null));\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n "}, {"sha": "37d1d9a969ed8d7a435a0fdf4b9818938348a1cf", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use io;\n use libc;\n use sys::fd::FileDesc;\n@@ -25,6 +27,13 @@ impl Stdin {\n         fd.into_raw();\n         ret\n     }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let ret = fd.read_to_end(buf);\n+        fd.into_raw();\n+        ret\n+    }\n }\n \n impl Stdout {"}, {"sha": "002ffc7c8685a7a7a48b619f0955d01688132409", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(bad_style)]\n #![cfg_attr(test, allow(dead_code))]\n+#![unstable(issue = \"0\", feature = \"windows_c\")]\n \n use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort,};\n use os::raw::{c_char, c_ulonglong};\n@@ -181,13 +182,15 @@ pub const ERROR_PATH_NOT_FOUND: DWORD = 3;\n pub const ERROR_ACCESS_DENIED: DWORD = 5;\n pub const ERROR_INVALID_HANDLE: DWORD = 6;\n pub const ERROR_NO_MORE_FILES: DWORD = 18;\n+pub const ERROR_HANDLE_EOF: DWORD = 38;\n pub const ERROR_BROKEN_PIPE: DWORD = 109;\n pub const ERROR_CALL_NOT_IMPLEMENTED: DWORD = 120;\n pub const ERROR_INSUFFICIENT_BUFFER: DWORD = 122;\n pub const ERROR_ALREADY_EXISTS: DWORD = 183;\n pub const ERROR_NO_DATA: DWORD = 232;\n pub const ERROR_ENVVAR_NOT_FOUND: DWORD = 203;\n pub const ERROR_OPERATION_ABORTED: DWORD = 995;\n+pub const ERROR_IO_PENDING: DWORD = 997;\n pub const ERROR_TIMEOUT: DWORD = 0x5B4;\n \n pub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n@@ -292,6 +295,14 @@ pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n                                     EXCEPTION_TARGET_UNWIND |\n                                     EXCEPTION_COLLIDED_UNWIND;\n \n+pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n+pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n+pub const FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\n+pub const PIPE_WAIT: DWORD = 0x00000000;\n+pub const PIPE_TYPE_BYTE: DWORD = 0x00000000;\n+pub const PIPE_REJECT_REMOTE_CLIENTS: DWORD = 0x00000008;\n+pub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -913,10 +924,6 @@ extern \"system\" {\n                            nOutBufferSize: DWORD,\n                            lpBytesReturned: LPDWORD,\n                            lpOverlapped: LPOVERLAPPED) -> BOOL;\n-    pub fn CreatePipe(hReadPipe: LPHANDLE,\n-                      hWritePipe: LPHANDLE,\n-                      lpPipeAttributes: LPSECURITY_ATTRIBUTES,\n-                      nSize: DWORD) -> BOOL;\n     pub fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n                         dwStackSize: SIZE_T,\n                         lpStartAddress: extern \"system\" fn(*mut c_void)\n@@ -1129,6 +1136,29 @@ extern \"system\" {\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n     pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n+\n+    pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCWSTR) -> HANDLE;\n+    pub fn WaitForMultipleObjects(nCount: DWORD,\n+                                  lpHandles: *const HANDLE,\n+                                  bWaitAll: BOOL,\n+                                  dwMilliseconds: DWORD) -> DWORD;\n+    pub fn CreateNamedPipeW(lpName: LPCWSTR,\n+                            dwOpenMode: DWORD,\n+                            dwPipeMode: DWORD,\n+                            nMaxInstances: DWORD,\n+                            nOutBufferSize: DWORD,\n+                            nInBufferSize: DWORD,\n+                            nDefaultTimeOut: DWORD,\n+                            lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n+                            -> HANDLE;\n+    pub fn CancelIo(handle: HANDLE) -> BOOL;\n+    pub fn GetOverlappedResult(hFile: HANDLE,\n+                               lpOverlapped: LPOVERLAPPED,\n+                               lpNumberOfBytesTransferred: LPDWORD,\n+                               bWait: BOOL) -> BOOL;\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "624fef097fcc5c365f7ded97bf1e7b60c83b634d", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n use io::prelude::*;\n use os::windows::prelude::*;\n \n@@ -312,6 +313,10 @@ impl File {\n         self.handle.read(buf)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.handle.read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.handle.write(buf)\n     }"}, {"sha": "1396d670902bb6c32a9936d74bcdd6279f1bd549", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,14 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(issue = \"0\", feature = \"windows_handle\")]\n+\n+use prelude::v1::*;\n+\n use cmp;\n-use io::ErrorKind;\n+use io::{ErrorKind, Read};\n use io;\n use mem;\n use ops::Deref;\n use ptr;\n use sys::c;\n use sys::cvt;\n+use sys_common::io::read_to_end_uninitialized;\n use u32;\n \n /// An owned container for `HANDLE` object, closing them on Drop.\n@@ -39,6 +44,20 @@ impl Handle {\n         Handle(RawHandle::new(handle))\n     }\n \n+    pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n+        unsafe {\n+            let event = c::CreateEventW(0 as *mut _,\n+                                        manual as c::BOOL,\n+                                        init as c::BOOL,\n+                                        0 as *const _);\n+            if event.is_null() {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                Ok(Handle::new(event))\n+            }\n+        }\n+    }\n+\n     pub fn into_raw(self) -> c::HANDLE {\n         let ret = self.raw();\n         mem::forget(self);\n@@ -87,6 +106,64 @@ impl RawHandle {\n         }\n     }\n \n+    pub unsafe fn read_overlapped(&self,\n+                                  buf: &mut [u8],\n+                                  overlapped: *mut c::OVERLAPPED)\n+                                  -> io::Result<Option<usize>> {\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let mut amt = 0;\n+        let res = cvt({\n+            c::ReadFile(self.0, buf.as_ptr() as c::LPVOID,\n+                        len, &mut amt, overlapped)\n+        });\n+        match res {\n+            Ok(_) => Ok(Some(amt as usize)),\n+            Err(e) => {\n+                if e.raw_os_error() == Some(c::ERROR_IO_PENDING as i32) {\n+                    Ok(None)\n+                } else if e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32) {\n+                    Ok(Some(0))\n+                } else {\n+                    Err(e)\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn overlapped_result(&self,\n+                             overlapped: *mut c::OVERLAPPED,\n+                             wait: bool) -> io::Result<usize> {\n+        unsafe {\n+            let mut bytes = 0;\n+            let wait = if wait {c::TRUE} else {c::FALSE};\n+            let res = cvt({\n+                c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait)\n+            });\n+            match res {\n+                Ok(_) => Ok(bytes as usize),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) ||\n+                       e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32) {\n+                        Ok(0)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn cancel_io(&self) -> io::Result<()> {\n+        unsafe {\n+            cvt(c::CancelIo(self.raw())).map(|_| ())\n+        }\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n         // WriteFile takes a DWORD (u32) for the length so it only supports\n@@ -111,3 +188,13 @@ impl RawHandle {\n         Ok(Handle::new(ret))\n     }\n }\n+\n+impl<'a> Read for &'a RawHandle {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n+}"}, {"sha": "bb3c79c5a84fd0a76a707495f8dbf1b2f73c1b21", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(issue = \"0\", feature = \"windows_net\")]\n+\n+use prelude::v1::*;\n+\n use cmp;\n-use io;\n+use io::{self, Read};\n use libc::{c_int, c_void, c_ulong};\n use mem;\n use net::{SocketAddr, Shutdown};\n@@ -20,6 +24,7 @@ use sync::Once;\n use sys::c;\n use sys;\n use sys_common::{self, AsInner, FromInner, IntoInner};\n+use sys_common::io::read_to_end_uninitialized;\n use sys_common::net;\n use time::Duration;\n \n@@ -142,6 +147,11 @@ impl Socket {\n         }\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>,\n                        kind: c_int) -> io::Result<()> {\n         let timeout = match dur {\n@@ -206,6 +216,17 @@ impl Socket {\n     }\n }\n \n+#[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]\n+impl<'a> Read for &'a Socket {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n+}\n+\n impl Drop for Socket {\n     fn drop(&mut self) {\n         let _ = unsafe { c::closesocket(self.0) };"}, {"sha": "fbe38d76e9571e95ed52ab5138367b5e958bf293", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 265, "deletions": 10, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,10 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+use os::windows::prelude::*;\n+\n+use ffi::OsStr;\n+use path::Path;\n use io;\n-use ptr;\n-use sys::cvt;\n+use mem;\n+use rand::{self, Rng};\n+use slice;\n use sys::c;\n+use sys::fs::{File, OpenOptions};\n use sys::handle::Handle;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -23,14 +30,76 @@ pub struct AnonPipe {\n }\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    let mut reader = c::INVALID_HANDLE_VALUE;\n-    let mut writer = c::INVALID_HANDLE_VALUE;\n-    try!(cvt(unsafe {\n-        c::CreatePipe(&mut reader, &mut writer, ptr::null_mut(), 0)\n-    }));\n-    let reader = Handle::new(reader);\n-    let writer = Handle::new(writer);\n-    Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer }))\n+    // Note that we specifically do *not* use `CreatePipe` here because\n+    // unfortunately the anonymous pipes returned do not support overlapped\n+    // operations.\n+    //\n+    // Instead, we create a \"hopefully unique\" name and create a named pipe\n+    // which has overlapped operations enabled.\n+    //\n+    // Once we do this, we connect do it as usual via `CreateFileW`, and then we\n+    // return those reader/writer halves.\n+    unsafe {\n+        let reader;\n+        let mut name;\n+        let mut tries = 0;\n+        loop {\n+            tries += 1;\n+            let key: u64 = rand::thread_rng().gen();\n+            name = format!(r\"\\\\.\\pipe\\__rust_anonymous_pipe1__.{}.{}\",\n+                           c::GetCurrentProcessId(),\n+                           key);\n+            let wide_name = OsStr::new(&name)\n+                                  .encode_wide()\n+                                  .chain(Some(0))\n+                                  .collect::<Vec<_>>();\n+\n+            let handle = c::CreateNamedPipeW(wide_name.as_ptr(),\n+                                             c::PIPE_ACCESS_INBOUND |\n+                                              c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n+                                              c::FILE_FLAG_OVERLAPPED,\n+                                             c::PIPE_TYPE_BYTE |\n+                                              c::PIPE_READMODE_BYTE |\n+                                              c::PIPE_WAIT |\n+                                              c::PIPE_REJECT_REMOTE_CLIENTS,\n+                                             1,\n+                                             4096,\n+                                             4096,\n+                                             0,\n+                                             0 as *mut _);\n+\n+            // We pass the FILE_FLAG_FIRST_PIPE_INSTANCE flag above, and we're\n+            // also just doing a best effort at selecting a unique name. If\n+            // ERROR_ACCESS_DENIED is returned then it could mean that we\n+            // accidentally conflicted with an already existing pipe, so we try\n+            // again.\n+            //\n+            // Don't try again too much though as this could also perhaps be a\n+            // legit error.\n+            if handle == c::INVALID_HANDLE_VALUE {\n+                let err = io::Error::last_os_error();\n+                if tries < 10 &&\n+                   err.raw_os_error() == Some(c::ERROR_ACCESS_DENIED as i32) {\n+                    continue\n+                }\n+                return Err(err)\n+            }\n+            reader = Handle::new(handle);\n+            break\n+        }\n+\n+        // Connect to the named pipe we just created in write-only mode (also\n+        // overlapped for async I/O below).\n+        let mut opts = OpenOptions::new();\n+        opts.write(true);\n+        opts.read(false);\n+        opts.share_mode(0);\n+        opts.attributes(c::FILE_FLAG_OVERLAPPED);\n+        let writer = try!(File::open(Path::new(&name), &opts));\n+        let writer = AnonPipe { inner: writer.into_handle() };\n+\n+        Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer.into_handle() }))\n+    }\n }\n \n impl AnonPipe {\n@@ -41,7 +110,193 @@ impl AnonPipe {\n         self.inner.read(buf)\n     }\n \n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.inner.read_to_end(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(buf)\n     }\n }\n+\n+pub fn read2(p1: AnonPipe,\n+             v1: &mut Vec<u8>,\n+             p2: AnonPipe,\n+             v2: &mut Vec<u8>) -> io::Result<()> {\n+    let p1 = p1.into_handle();\n+    let p2 = p2.into_handle();\n+\n+    let mut p1 = try!(AsyncPipe::new(p1, v1));\n+    let mut p2 = try!(AsyncPipe::new(p2, v2));\n+    let objs = [p1.event.raw(), p2.event.raw()];\n+\n+    // In a loop we wait for either pipe's scheduled read operation to complete.\n+    // If the operation completes with 0 bytes, that means EOF was reached, in\n+    // which case we just finish out the other pipe entirely.\n+    //\n+    // Note that overlapped I/O is in general super unsafe because we have to\n+    // be careful to ensure that all pointers in play are valid for the entire\n+    // duration of the I/O operation (where tons of operations can also fail).\n+    // The destructor for `AsyncPipe` ends up taking care of most of this.\n+    loop {\n+        let res = unsafe {\n+            c::WaitForMultipleObjects(2, objs.as_ptr(), c::FALSE, c::INFINITE)\n+        };\n+        if res == c::WAIT_OBJECT_0 {\n+            if !try!(p1.result()) || !try!(p1.schedule_read()) {\n+                return p2.finish()\n+            }\n+        } else if res == c::WAIT_OBJECT_0 + 1 {\n+            if !try!(p2.result()) || !try!(p2.schedule_read()) {\n+                return p1.finish()\n+            }\n+        } else {\n+            return Err(io::Error::last_os_error())\n+        }\n+    }\n+}\n+\n+struct AsyncPipe<'a> {\n+    pipe: Handle,\n+    event: Handle,\n+    overlapped: Box<c::OVERLAPPED>, // needs a stable address\n+    dst: &'a mut Vec<u8>,\n+    state: State,\n+}\n+\n+#[derive(PartialEq, Debug)]\n+enum State {\n+    NotReading,\n+    Reading,\n+    Read(usize),\n+}\n+\n+impl<'a> AsyncPipe<'a> {\n+    fn new(pipe: Handle, dst: &'a mut Vec<u8>) -> io::Result<AsyncPipe<'a>> {\n+        // Create an event which we'll use to coordinate our overlapped\n+        // opreations, this event will be used in WaitForMultipleObjects\n+        // and passed as part of the OVERLAPPED handle.\n+        //\n+        // Note that we do a somewhat clever thing here by flagging the\n+        // event as being manually reset and setting it initially to the\n+        // signaled state. This means that we'll naturally fall through the\n+        // WaitForMultipleObjects call above for pipes created initially,\n+        // and the only time an even will go back to \"unset\" will be once an\n+        // I/O operation is successfully scheduled (what we want).\n+        let event = try!(Handle::new_event(true, true));\n+        let mut overlapped: Box<c::OVERLAPPED> = unsafe {\n+            Box::new(mem::zeroed())\n+        };\n+        overlapped.hEvent = event.raw();\n+        Ok(AsyncPipe {\n+            pipe: pipe,\n+            overlapped: overlapped,\n+            event: event,\n+            dst: dst,\n+            state: State::NotReading,\n+        })\n+    }\n+\n+    /// Executes an overlapped read operation.\n+    ///\n+    /// Must not currently be reading, and returns whether the pipe is currently\n+    /// at EOF or not. If the pipe is not at EOF then `result()` must be called\n+    /// to complete the read later on (may block), but if the pipe is at EOF\n+    /// then `result()` should not be called as it will just block forever.\n+    fn schedule_read(&mut self) -> io::Result<bool> {\n+        assert_eq!(self.state, State::NotReading);\n+        let amt = unsafe {\n+            let slice = slice_to_end(self.dst);\n+            try!(self.pipe.read_overlapped(slice, &mut *self.overlapped))\n+        };\n+\n+        // If this read finished immediately then our overlapped event will\n+        // remain signaled (it was signaled coming in here) and we'll progress\n+        // down to the method below.\n+        //\n+        // Otherwise the I/O operation is scheduled and the system set our event\n+        // to not signaled, so we flag ourselves into the reading state and move\n+        // on.\n+        self.state = match amt {\n+            Some(0) => return Ok(false),\n+            Some(amt) => State::Read(amt),\n+            None => State::Reading,\n+        };\n+        Ok(true)\n+    }\n+\n+    /// Wait for the result of the overlapped operation previously executed.\n+    ///\n+    /// Takes a parameter `wait` which indicates if this pipe is currently being\n+    /// read whether the function should block waiting for the read to complete.\n+    ///\n+    /// Return values:\n+    ///\n+    /// * `true` - finished any pending read and the pipe is not at EOF (keep\n+    ///            going)\n+    /// * `false` - finished any pending read and pipe is at EOF (stop issuing\n+    ///             reads)\n+    fn result(&mut self) -> io::Result<bool> {\n+        let amt = match self.state {\n+            State::NotReading => return Ok(true),\n+            State::Reading => {\n+                try!(self.pipe.overlapped_result(&mut *self.overlapped, true))\n+            }\n+            State::Read(amt) => amt,\n+        };\n+        self.state = State::NotReading;\n+        unsafe {\n+            let len = self.dst.len();\n+            self.dst.set_len(len + amt);\n+        }\n+        Ok(amt != 0)\n+    }\n+\n+    /// Finishes out reading this pipe entirely.\n+    ///\n+    /// Waits for any pending and schedule read, and then calls `read_to_end`\n+    /// if necessary to read all the remaining information.\n+    fn finish(&mut self) -> io::Result<()> {\n+        while try!(self.result()) && try!(self.schedule_read()) {\n+            // ...\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a> Drop for AsyncPipe<'a> {\n+    fn drop(&mut self) {\n+        match self.state {\n+            State::Reading => {}\n+            _ => return,\n+        }\n+\n+        // If we have a pending read operation, then we have to make sure that\n+        // it's *done* before we actually drop this type. The kernel requires\n+        // that the `OVERLAPPED` and buffer pointers are valid for the entire\n+        // I/O operation.\n+        //\n+        // To do that, we call `CancelIo` to cancel any pending operation, and\n+        // if that succeeds we wait for the overlapped result.\n+        //\n+        // If anything here fails, there's not really much we can do, so we leak\n+        // the buffer/OVERLAPPED pointers to ensure we're at least memory safe.\n+        if self.pipe.cancel_io().is_err() || self.result().is_err() {\n+            let buf = mem::replace(self.dst, Vec::new());\n+            let overlapped = Box::new(unsafe { mem::zeroed() });\n+            let overlapped = mem::replace(&mut self.overlapped, overlapped);\n+            mem::forget((buf, overlapped));\n+        }\n+    }\n+}\n+\n+unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n+    if v.capacity() == 0 {\n+        v.reserve(16);\n+    }\n+    if v.capacity() == v.len() {\n+        v.reserve(1);\n+    }\n+    slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n+                              v.capacity() - v.len())\n+}"}, {"sha": "524c932eed439488e4936d8fe2409c2113c65dd8", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -123,7 +123,7 @@ impl Command {\n         self.stderr = Some(stderr);\n     }\n \n-    pub fn spawn(&mut self, default: Stdio)\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n         // To have the spawning semantics of unix/windows stay the same, we need\n         // to read the *child's* PATH if one is provided. See #15149 for more\n@@ -181,7 +181,9 @@ impl Command {\n             stdout: None,\n             stderr: None,\n         };\n-        let stdin = self.stdin.as_ref().unwrap_or(&default);\n+        let null = Stdio::Null;\n+        let default_stdin = if needs_stdin {&default} else {&null};\n+        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let stdin = try!(stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin));"}, {"sha": "5883904c21d729c92e14c786628424faed0ef4b8", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(issue = \"0\", feature = \"windows_stdio\")]\n+\n use prelude::v1::*;\n use io::prelude::*;\n \n@@ -18,6 +20,7 @@ use sync::Mutex;\n use sys::c;\n use sys::cvt;\n use sys::handle::Handle;\n+use sys_common::io::read_to_end_uninitialized;\n \n pub struct NoClose(Option<Handle>);\n \n@@ -113,6 +116,22 @@ impl Stdin {\n         // MemReader shouldn't error here since we just filled it\n         utf8.read(buf)\n     }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+}\n+\n+#[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]\n+impl<'a> Read for &'a Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n \n impl Stdout {"}]}