{"sha": "c1d2d83ca3b5155468ab96b09a7c54568449b137", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZDJkODNjYTNiNTE1NTQ2OGFiOTZiMDlhN2M1NDU2ODQ0OWIxMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-01T15:36:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-01T15:36:13Z"}, "message": "Auto merge of #58754 - ljedrz:I_hate_NodeIds, r=Zoxc\n\nRemove NodeId from more HIR nodes\n\nThe next iteration of HirIdification (#57578).\n\nRemoves `NodeId` from:\n\n- [x] `Stmt`\n- [x] `Local`\n- [x] `Field`\n- [x] `AnonConst`\n- [x] `TraitItem`\n- [x] `ImplItem`\n- [x] `TypeBinding`\n- [x] `Arg`\n- [x] `TraitRef`\n- [x] `VisibilityKind`\n\nIt will most probably break clippy again; I'd appreciate a **delegate** again if/when it is good to go so I can attach a clippy fix later.\n\nr? @Zoxc", "tree": {"sha": "ae9151d39740e0ee72b9f4532d3091abe2294282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae9151d39740e0ee72b9f4532d3091abe2294282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d2d83ca3b5155468ab96b09a7c54568449b137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d2d83ca3b5155468ab96b09a7c54568449b137", "html_url": "https://github.com/rust-lang/rust/commit/c1d2d83ca3b5155468ab96b09a7c54568449b137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d2d83ca3b5155468ab96b09a7c54568449b137/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17add2498f20bb5a638a65c53407c72ac11becf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/17add2498f20bb5a638a65c53407c72ac11becf6", "html_url": "https://github.com/rust-lang/rust/commit/17add2498f20bb5a638a65c53407c72ac11becf6"}, {"sha": "9cd184590847ae20f3e49c3f23d8118632011872", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd184590847ae20f3e49c3f23d8118632011872", "html_url": "https://github.com/rust-lang/rust/commit/9cd184590847ae20f3e49c3f23d8118632011872"}], "stats": {"total": 797, "additions": 368, "deletions": 429}, "files": [{"sha": "0aeac8cc440ec95d17c4ed6d9ac46172ca45c7a3", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -878,7 +878,6 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n-        id: _,\n         hir_id: _,\n         ident,\n         ref vis,\n@@ -1106,7 +1105,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n-    if let VisibilityKind::Restricted { ref path, id: _, hir_id } = vis.node {\n+    if let VisibilityKind::Restricted { ref path, hir_id } = vis.node {\n         visitor.visit_id(hir_id);\n         visitor.visit_path(path, hir_id)\n     }"}, {"sha": "a97ea7da7f19cbf3d175a03322039e34ddad38ff", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -1151,10 +1151,9 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_binding(&mut self, b: &TypeBinding,\n                         itctx: ImplTraitContext<'_>) -> hir::TypeBinding {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(b.id);\n \n         hir::TypeBinding {\n-            id: node_id,\n             hir_id,\n             ident: b.ident,\n             ty: self.lower_ty(&b.ty, itctx),\n@@ -1982,14 +1981,13 @@ impl<'a> LoweringContext<'a> {\n                     let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                     hir::Ty { node: hir::TyKind::Tup(tys), hir_id, span }\n                 };\n-                let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n \n                 (\n                     hir::GenericArgs {\n                         args: hir_vec![GenericArg::Type(mk_tup(this, inputs, span))],\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n-                                id: node_id,\n                                 hir_id,\n                                 ident: Ident::from_str(FN_OUTPUT_NAME),\n                                 ty: output\n@@ -2008,7 +2006,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[hir::ItemId; 1]>) {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(l.id);\n         let mut ids = SmallVec::<[hir::ItemId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n             if let Some(ref ty) = l.ty {\n@@ -2018,7 +2016,6 @@ impl<'a> LoweringContext<'a> {\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n         (hir::Local {\n-            id: node_id,\n             hir_id,\n             ty: l.ty\n                 .as_ref()\n@@ -2045,9 +2042,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(arg.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(arg.id);\n         hir::Arg {\n-            id: node_id,\n             hir_id,\n             pat: self.lower_pat(&arg.pat),\n         }\n@@ -2327,13 +2323,12 @@ impl<'a> LoweringContext<'a> {\n             };\n \n             // \"<Output = T>\"\n-            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n             let future_params = P(hir::GenericArgs {\n                 args: hir_vec![],\n                 bindings: hir_vec![hir::TypeBinding {\n                     ident: Ident::from_str(FN_OUTPUT_NAME),\n                     ty: output_ty,\n-                    id: node_id,\n                     hir_id,\n                     span,\n                 }],\n@@ -2343,13 +2338,12 @@ impl<'a> LoweringContext<'a> {\n             let future_path =\n                 this.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n \n-            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n             let mut bounds = vec![\n                 hir::GenericBound::Trait(\n                     hir::PolyTraitRef {\n                         trait_ref: hir::TraitRef {\n                             path: future_path,\n-                            ref_id: node_id,\n                             hir_ref_id: hir_id,\n                         },\n                         bound_generic_params: hir_vec![],\n@@ -2719,10 +2713,9 @@ impl<'a> LoweringContext<'a> {\n             hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n         };\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.ref_id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(p.ref_id);\n         hir::TraitRef {\n             path,\n-            ref_id: node_id,\n             hir_ref_id: hir_id,\n         }\n     }\n@@ -2768,10 +2761,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Field {\n-            id: node_id,\n             hir_id,\n             ident: f.ident,\n             expr: P(self.lower_expr(&f.expr)),\n@@ -3123,12 +3115,11 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n+                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                                 let id = this.next_id();\n                                 let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n                                     path,\n-                                    id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n                             }\n@@ -3230,12 +3221,11 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n+                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                                 let id = this.next_id();\n                                 let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n                                     path: path,\n-                                    id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n                             }\n@@ -3353,7 +3343,6 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::TraitItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n@@ -3429,7 +3418,6 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::ImplItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n@@ -3813,9 +3801,8 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n         self.with_new_scopes(|this| {\n-            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(c.id);\n+            let LoweredNodeId { node_id: _, hir_id } = this.lower_node_id(c.id);\n             hir::AnonConst {\n-                id: node_id,\n                 hir_id,\n                 body: this.lower_body(None, |this| this.lower_expr(&c.value)),\n             }\n@@ -4427,9 +4414,8 @@ impl<'a> LoweringContext<'a> {\n                         ThinVec::new(),\n                     ))\n                 };\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                 let match_stmt = hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Expr(match_expr),\n                     span: head_sp,\n@@ -4456,9 +4442,8 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                 let body_stmt = hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Expr(body_expr),\n                     span: body.span,\n@@ -4639,21 +4624,19 @@ impl<'a> LoweringContext<'a> {\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n-                        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         hir::Stmt {\n-                            id: node_id,\n                             hir_id,\n                             node: hir::StmtKind::Item(item_id),\n                             span: s.span,\n                         }\n                     })\n                     .collect();\n                 ids.push({\n-                    let LoweredNodeId { node_id, hir_id } = self.lower_node_id(s.id);\n+                    let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(s.id);\n \n                     hir::Stmt {\n-                        id: node_id,\n                         hir_id,\n                         node: hir::StmtKind::Local(P(l)),\n                         span: s.span,\n@@ -4667,12 +4650,11 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_item_id(it)\n                     .into_iter()\n                     .map(|item_id| {\n-                        let LoweredNodeId { node_id, hir_id } = id.take()\n+                        let LoweredNodeId { node_id: _, hir_id } = id.take()\n                           .map(|id| self.lower_node_id(id))\n                           .unwrap_or_else(|| self.next_id());\n \n                         hir::Stmt {\n-                            id: node_id,\n                             hir_id,\n                             node: hir::StmtKind::Item(item_id),\n                             span: s.span,\n@@ -4681,20 +4663,18 @@ impl<'a> LoweringContext<'a> {\n                     .collect();\n             }\n             StmtKind::Expr(ref e) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(s.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(s.id);\n \n                 hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Expr(P(self.lower_expr(e))),\n                     span: s.span,\n                 }\n             },\n             StmtKind::Semi(ref e) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(s.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(s.id);\n \n                 hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Semi(P(self.lower_expr(e))),\n                     span: s.span,\n@@ -4739,7 +4719,6 @@ impl<'a> LoweringContext<'a> {\n                         ParamMode::Explicit,\n                         explicit_owner,\n                     )),\n-                    id: lowered_id.node_id,\n                     hir_id: lowered_id.hir_id,\n                 }\n             },\n@@ -4809,10 +4788,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Field {\n-            id: node_id,\n             hir_id,\n             ident,\n             span,\n@@ -4912,22 +4890,20 @@ impl<'a> LoweringContext<'a> {\n         pat: P<hir::Pat>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         let local = hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n-            id: node_id,\n             hir_id,\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         hir::Stmt {\n-            id: node_id,\n             hir_id,\n             node: hir::StmtKind::Local(P(local)),\n             span: sp\n@@ -5075,7 +5051,6 @@ impl<'a> LoweringContext<'a> {\n                             bound_generic_params: hir::HirVec::new(),\n                             trait_ref: hir::TraitRef {\n                                 path: path.and_then(|path| path),\n-                                ref_id: id.node_id,\n                                 hir_ref_id: id.hir_id,\n                             },\n                             span,"}, {"sha": "0425d5a5023849e6eff623bb1a2a9c805f118825", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n-                         self.definitions.opt_def_index(ti.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&ti.hir_id]).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n             this.insert(ti.span, ti.hir_id, Node::TraitItem(ti));\n \n@@ -398,7 +398,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n         debug_assert_eq!(ii.hir_id.owner,\n-                         self.definitions.opt_def_index(ii.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&ii.hir_id]).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n             this.insert(ii.span, ii.hir_id, Node::ImplItem(ii));\n "}, {"sha": "66e814f06609cf636ee94bd4623360528da63c92", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -349,15 +349,15 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::TraitItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n                     TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n                 }\n             }\n             Node::ImplItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n@@ -387,7 +387,7 @@ impl<'hir> Map<'hir> {\n             Node::Block(_) |\n             Node::Crate => None,\n             Node::Local(local) => {\n-                Some(Def::Local(local.id))\n+                Some(Def::Local(self.hir_to_node_id(local.hir_id)))\n             }\n             Node::MacroDef(macro_def) => {\n                 Some(Def::Macro(self.local_def_id_from_hir_id(macro_def.hir_id),"}, {"sha": "3ba4efba9186cad8425e8fa587162966995b53bc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -1162,15 +1162,14 @@ impl UnOp {\n /// A statement.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub node: StmtKind,\n     pub span: Span,\n }\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"stmt({}: {})\", self.id,\n+        write!(f, \"stmt({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_stmt(self)))\n     }\n }\n@@ -1208,7 +1207,6 @@ pub struct Local {\n     pub ty: Option<P<Ty>>,\n     /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n@@ -1231,7 +1229,6 @@ pub enum Guard {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub ident: Ident,\n     pub expr: P<Expr>,\n@@ -1325,7 +1322,6 @@ impl BodyOwnerKind {\n /// explicit discriminant values for enum variants.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct AnonConst {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub body: BodyId,\n }\n@@ -1672,7 +1668,6 @@ pub struct TraitItemId {\n /// signature) or provided (meaning it has a default implementation).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItem {\n-    pub id: NodeId,\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n@@ -1715,7 +1710,6 @@ pub struct ImplItemId {\n /// Represents anything within an `impl` block\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n-    pub id: NodeId,\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub vis: Visibility,\n@@ -1743,7 +1737,6 @@ pub enum ImplItemKind {\n // Bind a type to an associated type: `A=Foo`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeBinding {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub ident: Ident,\n     pub ty: P<Ty>,\n@@ -1859,7 +1852,6 @@ pub struct InlineAsm {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arg {\n     pub pat: P<Pat>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n }\n \n@@ -2070,7 +2062,6 @@ pub enum UseKind {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n-    pub ref_id: NodeId,\n     pub hir_ref_id: HirId,\n }\n \n@@ -2105,7 +2096,7 @@ pub type Visibility = Spanned<VisibilityKind>;\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n-    Restricted { path: P<Path>, id: NodeId, hir_id: HirId },\n+    Restricted { path: P<Path>, hir_id: HirId },\n     Inherited,\n }\n "}, {"sha": "28e9403e9dba2313a1606da3bf40a903ed84b82f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -25,7 +25,7 @@ pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n     Block(&'a hir::Block),\n     Item(&'a hir::Item),\n-    SubItem(ast::NodeId),\n+    SubItem(hir::HirId),\n     Expr(&'a hir::Expr),\n     Pat(&'a hir::Pat),\n }\n@@ -927,7 +927,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n-        self.ann.pre(self, AnnNode::SubItem(ti.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ti.hir_id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n@@ -959,11 +959,11 @@ impl<'a> State<'a> {\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ti.id))\n+        self.ann.post(self, AnnNode::SubItem(ti.hir_id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n-        self.ann.pre(self, AnnNode::SubItem(ii.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ii.hir_id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n@@ -989,7 +989,7 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ii.ident, Some(bounds), None)?;\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ii.id))\n+        self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {"}, {"sha": "af1cce5e354545eba6188386568c892de07771b0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -294,7 +294,6 @@ impl_stable_hash_for!(struct hir::MethodSig {\n });\n \n impl_stable_hash_for!(struct hir::TypeBinding {\n-    id,\n     hir_id,\n     ident -> (ident.name),\n     ty,\n@@ -386,8 +385,7 @@ impl_stable_hash_for!(enum hir::ImplicitSelfKind {\n });\n \n impl_stable_hash_for!(struct hir::TraitRef {\n-    // Don't hash the ref_id. It is tracked via the thing it is used to access\n-    ref_id -> _,\n+    // Don't hash the hir_ref_id. It is tracked via the thing it is used to access\n     hir_ref_id -> _,\n     path,\n });\n@@ -495,7 +493,6 @@ impl_stable_hash_for!(enum hir::UnOp {\n });\n \n impl_stable_hash_for!(struct hir::Stmt {\n-    id,\n     hir_id,\n     node,\n     span,\n@@ -506,7 +503,6 @@ impl_stable_hash_for!(struct hir::Local {\n     pat,\n     ty,\n     init,\n-    id,\n     hir_id,\n     span,\n     attrs,\n@@ -525,7 +521,6 @@ impl_stable_hash_for!(enum hir::Guard {\n });\n \n impl_stable_hash_for!(struct hir::Field {\n-    id -> _,\n     hir_id -> _,\n     ident,\n     expr,\n@@ -549,7 +544,6 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n });\n \n impl_stable_hash_for!(struct hir::AnonConst {\n-    id,\n     hir_id,\n     body\n });\n@@ -673,7 +667,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n-            id: _,\n             hir_id: _,\n             ident,\n             ref attrs,\n@@ -708,7 +701,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n-            id: _,\n             hir_id: _,\n             ident,\n             ref vis,\n@@ -756,9 +748,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n             hir::VisibilityKind::Crate(sugar) => {\n                 sugar.hash_stable(hcx, hasher);\n             }\n-            hir::VisibilityKind::Restricted { ref path, id, hir_id } => {\n+            hir::VisibilityKind::Restricted { ref path, hir_id } => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    id.hash_stable(hcx, hasher);\n                     hir_id.hash_stable(hcx, hasher);\n                 });\n                 path.hash_stable(hcx, hasher);\n@@ -962,7 +953,6 @@ impl_stable_hash_for!(enum hir::StmtKind {\n \n impl_stable_hash_for!(struct hir::Arg {\n     pat,\n-    id,\n     hir_id\n });\n "}, {"sha": "9761ee313533fe446b3b2410996e798f676e4e88", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -729,8 +729,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n         match span {\n             Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, msg),\n             None => {\n-                let node_id = self.tcx.hir().hir_to_node_id(hir_id); // FIXME(@ljedrz): remove later\n-                self.tcx.struct_lint_node(lint, node_id, msg)\n+                self.tcx.struct_lint_node(lint, hir_id, msg)\n             },\n         }\n     }\n@@ -793,11 +792,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         run_lints!(self, exit_lint_attrs, attrs);\n     }\n \n-    fn with_param_env<F>(&mut self, id: ast::NodeId, f: F)\n+    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id(id));\n+        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id_from_hir_id(id));\n         f(self);\n         self.param_env = old_param_env;\n     }\n@@ -841,7 +840,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = it.node.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.id, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n                 run_lints!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 run_lints!(cx, check_item_post, it);\n@@ -852,7 +851,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.id, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n                 run_lints!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n                 run_lints!(cx, check_foreign_item_post, it);\n@@ -983,7 +982,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.id, |cx| {\n+            cx.with_param_env(trait_item.hir_id, |cx| {\n                 run_lints!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n                 run_lints!(cx, check_trait_item_post, trait_item);\n@@ -996,7 +995,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.id, |cx| {\n+            cx.with_param_env(impl_item.hir_id, |cx| {\n                 run_lints!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 run_lints!(cx, check_impl_item_post, impl_item);"}, {"sha": "3b607127d8628a1afedba18529ed986edb1cd59a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -26,8 +26,8 @@ use syntax_pos;\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            node_id: ast::NodeId) -> bool {\n-    match tcx.hir().find(node_id) {\n+                            hir_id: hir::HirId) -> bool {\n+    match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n@@ -39,33 +39,33 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    live_symbols: FxHashSet<ast::NodeId>,\n+    live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n-    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n+    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            if should_explore(self.tcx, node_id) ||\n-               self.struct_constructors.contains_key(&node_id) {\n-                self.worklist.push(node_id);\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            if should_explore(self.tcx, hir_id) ||\n+               self.struct_constructors.contains_key(&hir_id) {\n+                self.worklist.push(hir_id);\n             }\n-            self.live_symbols.insert(node_id);\n+            self.live_symbols.insert(hir_id);\n         }\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            debug_assert!(!should_explore(self.tcx, node_id));\n-            self.live_symbols.insert(node_id);\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            debug_assert!(!should_explore(self.tcx, hir_id));\n+            self.live_symbols.insert(hir_id);\n         }\n     }\n \n@@ -136,7 +136,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find(id) {\n+            if let Some(node) = self.tcx.hir().find_by_hir_id(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         let live_fields = def.fields().iter().filter(|f| {\n             has_repr_c || inherited_pub_visibility || f.vis.node.is_pub()\n         });\n-        self.live_symbols.extend(live_fields.map(|f| f.id));\n+        self.live_symbols.extend(live_fields.map(|f| f.hir_id));\n \n         intravisit::walk_struct_def(self, def);\n     }\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n }\n \n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n-                                    id: ast::NodeId,\n+                                    id: hir::HirId,\n                                     attrs: &[ast::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n@@ -306,7 +306,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n         return true;\n     }\n \n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n@@ -333,25 +333,25 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder<'k, 'tcx: 'k> {\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'k, 'tcx, 'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n-    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n+    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                               item.id,\n+                                                               item.hir_id,\n                                                                &item.attrs);\n         if allow_dead_code {\n-            self.worklist.push(item.id);\n+            self.worklist.push(item.hir_id);\n         }\n         match item.node {\n             hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter()\n-                                                      .map(|variant| variant.node.data.id()));\n+                                                      .map(|variant| variant.node.data.hir_id()));\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n@@ -360,9 +360,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n                         hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                                trait_item.id,\n+                                                                trait_item.hir_id,\n                                                                 &trait_item.attrs) {\n-                                self.worklist.push(trait_item.id);\n+                                self.worklist.push(trait_item.hir_id);\n                             }\n                         }\n                         _ => {}\n@@ -374,14 +374,14 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                             impl_item.id,\n+                                                             impl_item.hir_id,\n                                                              &impl_item.attrs) {\n-                        self.worklist.push(impl_item_ref.id.node_id);\n+                        self.worklist.push(self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id));\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n-                self.struct_constructors.insert(variant_data.id(), item.id);\n+                self.struct_constructors.insert(variant_data.hir_id(), item.hir_id);\n             }\n             _ => ()\n         }\n@@ -400,16 +400,16 @@ fn create_and_seed_worklist<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n-) -> (Vec<ast::NodeId>, FxHashMap<ast::NodeId, ast::NodeId>) {\n+) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n-            Some(id)\n+            Some(tcx.hir().node_to_hir_id(id))\n         } else {\n             None\n         }\n     }).chain(\n         // Seed entry point\n-        tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_node_id(def_id).unwrap())\n+        tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id).unwrap())\n     ).collect::<Vec<_>>();\n \n     // Seed implemented trait items\n@@ -427,7 +427,7 @@ fn create_and_seed_worklist<'a, 'tcx>(\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> FxHashSet<ast::NodeId> {\n+                       -> FxHashSet<hir::HirId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -446,7 +446,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: FxHashSet<ast::NodeId>,\n+    live_symbols: FxHashSet<hir::HirId>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n@@ -461,33 +461,33 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n-        should_warn && !self.symbol_is_live(item.id)\n+        should_warn && !self.symbol_is_live(item.hir_id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n-            && !self.symbol_is_live(field.id)\n+            && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.id())\n+        !self.symbol_is_live(variant.data.hir_id())\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                 variant.data.id(),\n+                                                 variant.data.hir_id(),\n                                                  &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n-        !self.symbol_is_live(fi.id)\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n+        !self.symbol_is_live(fi.hir_id)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id, &fi.attrs)\n     }\n \n-    // id := node id of an item's definition.\n+    // id := HIR id of an item's definition.\n     fn symbol_is_live(\n         &mut self,\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     ) -> bool {\n         if self.live_symbols.contains(&id) {\n             return true;\n@@ -496,12 +496,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir().local_def_id(id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_node_id) = self.tcx.hir().as_local_node_id(item_did) {\n-                    if self.live_symbols.contains(&item_node_id) {\n+                if let Some(item_hir_id) = self.tcx.hir().as_local_hir_id(item_did) {\n+                    if self.live_symbols.contains(&item_hir_id) {\n                         return true;\n                     }\n                 }\n@@ -511,18 +511,18 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn warn_dead_code(&mut self,\n-                      id: ast::NodeId,\n+                      id: hir::HirId,\n                       span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str,\n                       participle: &str) {\n         if !name.as_str().starts_with(\"_\") {\n             self.tcx\n-                .lint_node(lint::builtin::DEAD_CODE,\n-                           id,\n-                           span,\n-                           &format!(\"{} is never {}: `{}`\",\n-                                    node_type, participle, name));\n+                .lint_hir(lint::builtin::DEAD_CODE,\n+                          id,\n+                          span,\n+                          &format!(\"{} is never {}: `{}`\",\n+                                   node_type, participle, name));\n         }\n     }\n }\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 _ => \"used\"\n             };\n             self.warn_dead_code(\n-                item.id,\n+                item.hir_id,\n                 span,\n                 item.ident.name,\n                 item.node.descriptive_variant(),\n@@ -572,7 +572,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.ident.name,\n+            self.warn_dead_code(variant.node.data.hir_id(), variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);\n@@ -581,24 +581,24 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if self.should_warn_about_foreign_item(fi) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident.name,\n+            self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name,\n                                 fi.node.descriptive_variant(), \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n-            self.warn_dead_code(field.id, field.span, field.ident.name, \"field\", \"used\");\n+            self.warn_dead_code(field.hir_id, field.span, field.ident.name, \"field\", \"used\");\n         }\n         intravisit::walk_struct_field(self, field);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id) {\n-                    self.warn_dead_code(impl_item.id,\n+                if !self.symbol_is_live(impl_item.hir_id) {\n+                    self.warn_dead_code(impl_item.hir_id,\n                                         impl_item.span,\n                                         impl_item.ident.name,\n                                         \"associated const\",\n@@ -607,9 +607,10 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id) {\n+                if !self.symbol_is_live(impl_item.hir_id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n-                    self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n+                    self.warn_dead_code(impl_item.hir_id, span, impl_item.ident.name, \"method\",\n+                        \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "cffbc2eaa40ce7a2168b90e35d817d9daf14bb87", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -48,7 +48,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.id));\n+    let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }"}, {"sha": "dd44e19bc7df9c371b84f3065ed2dac6986ca117", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -781,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent(trait_item.id)),\n+                    Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent(impl_item.id)),\n+                    Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -1685,7 +1685,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n-        parent_id: Option<ast::NodeId>,\n+        parent_id: Option<hir::HirId>,\n         decl: &'tcx hir::FnDecl,\n         generics: &'tcx hir::Generics,\n         walk: F,\n@@ -1697,7 +1697,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item(parent_id);\n+            let parent = self.tcx.hir().expect_item_by_hir_id(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }"}, {"sha": "3c1b49e2dde6c29740d9a16210b718b71201315e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -13,7 +13,6 @@ use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n-use syntax::ast;\n use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -356,7 +355,8 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n+        let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(\n+            self.tcx.hir().get_parent_item(ii.hir_id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n         }\n@@ -922,8 +922,8 @@ fn unnecessary_stable_feature_lint<'a, 'tcx>(\n     feature: Symbol,\n     since: Symbol\n ) {\n-    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-        ast::CRATE_NODE_ID,\n+    tcx.lint_hir(lint::builtin::STABLE_FEATURES,\n+        hir::CRATE_HIR_ID,\n         span,\n         &format!(\"the feature `{}` has been stable since {} and no longer requires \\\n                   an attribute to enable\", feature, since));"}, {"sha": "a2924cb993fbf6f2039b5eeeb1e07663c3ea5a8b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -334,9 +334,9 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n                         FutureCompatOverlapErrorKind::Issue33140 =>\n                             lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n                     };\n-                    tcx.struct_span_lint_node(\n+                    tcx.struct_span_lint_hir(\n                         lint,\n-                        tcx.hir().as_local_node_id(impl_def_id).unwrap(),\n+                        tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n                         impl_span,\n                         &msg)\n                 } else {"}, {"sha": "1983dfbd4b7d16f06ae37b07deb8741d5b073e75", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -65,7 +65,7 @@ use std::sync::mpsc;\n use std::sync::Arc;\n use std::marker::PhantomData;\n use rustc_target::spec::abi;\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::edition::Edition;\n@@ -2836,14 +2836,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n     }\n \n-    pub fn lint_node<S: Into<MultiSpan>>(self,\n-                                         lint: &'static Lint,\n-                                         id: NodeId,\n-                                         span: S,\n-                                         msg: &str) {\n-        self.struct_span_lint_node(lint, id, span.into(), msg).emit()\n-    }\n-\n     pub fn lint_hir_note<S: Into<MultiSpan>>(self,\n                                              lint: &'static Lint,\n                                              hir_id: HirId,\n@@ -2866,7 +2858,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.emit()\n     }\n \n-    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: NodeId)\n+    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: hir::HirId)\n         -> (lint::Level, lint::LintSource)\n     {\n         // Right now we insert a `with_ignore` node in the dep graph here to\n@@ -2880,11 +2872,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.dep_graph.with_ignore(|| {\n             let sets = self.lint_levels(LOCAL_CRATE);\n             loop {\n-                let hir_id = self.hir().definitions().node_to_hir_id(id);\n-                if let Some(pair) = sets.level_and_source(lint, hir_id, self.sess) {\n+                if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n                     return pair\n                 }\n-                let next = self.hir().get_parent_node(id);\n+                let next = self.hir().get_parent_node_by_hir_id(id);\n                 if next == id {\n                     bug!(\"lint traversal reached the root of the crate\");\n                 }\n@@ -2900,23 +2891,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                     msg: &str)\n         -> DiagnosticBuilder<'tcx>\n     {\n-        let node_id = self.hir().hir_to_node_id(hir_id);\n-        let (level, src) = self.lint_level_at_node(lint, node_id);\n-        lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n-    }\n-\n-    pub fn struct_span_lint_node<S: Into<MultiSpan>>(self,\n-                                                     lint: &'static Lint,\n-                                                     id: NodeId,\n-                                                     span: S,\n-                                                     msg: &str)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n-        let (level, src) = self.lint_level_at_node(lint, id);\n+        let (level, src) = self.lint_level_at_node(lint, hir_id);\n         lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n     }\n \n-    pub fn struct_lint_node(self, lint: &'static Lint, id: NodeId, msg: &str)\n+    pub fn struct_lint_node(self, lint: &'static Lint, id: HirId, msg: &str)\n         -> DiagnosticBuilder<'tcx>\n     {\n         let (level, src) = self.lint_level_at_node(lint, id);"}, {"sha": "c495268154664ee7a4987030b5c5b87cc6f856aa", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -6,7 +6,6 @@\n \n use rustc::hir;\n use rustc::ty::TyCtxt;\n-use syntax::ast;\n \n use rustc_mir::monomorphize::Instance;\n \n@@ -33,9 +32,9 @@ struct SymbolNamesTest<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n-                     node_id: ast::NodeId) {\n+                     hir_id: hir::HirId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(node_id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n@@ -56,14 +55,14 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n \n impl<'a, 'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.process_attrs(item.id);\n+        self.process_attrs(item.hir_id);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.process_attrs(trait_item.id);\n+        self.process_attrs(trait_item.hir_id);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.process_attrs(impl_item.id);\n+        self.process_attrs(impl_item.hir_id);\n     }\n }"}, {"sha": "1f69d617c83b71949f40dcfc468e24a64d62fb0a", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -69,7 +69,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             let mut visitor = IfThisChanged { tcx,\n                                             if_this_changed: vec![],\n                                             then_this_would_need: vec![] };\n-            visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir().krate().attrs);\n+            visitor.process_attrs(hir::CRATE_HIR_ID, &tcx.hir().krate().attrs);\n             tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n@@ -87,7 +87,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n type Sources = Vec<(Span, DefId, DepNode)>;\n-type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode)>;\n+type Targets = Vec<(Span, ast::Name, hir::HirId, DepNode)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -110,8 +110,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         value\n     }\n \n-    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id(node_id);\n+    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id);\n         for attr in attrs {\n             if attr.check_name(ATTR_IF_THIS_CHANGED) {\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 };\n                 self.then_this_would_need.push((attr.span,\n                                                 dep_node_interned.unwrap(),\n-                                                node_id,\n+                                                hir_id,\n                                                 dep_node));\n             }\n         }\n@@ -164,22 +164,22 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.process_attrs(item.id, &item.attrs);\n+        self.process_attrs(item.hir_id, &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.process_attrs(trait_item.id, &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.process_attrs(impl_item.id, &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.process_attrs(s.id, &s.attrs);\n+        self.process_attrs(s.hir_id, &s.attrs);\n         intravisit::walk_struct_field(self, s);\n     }\n }"}, {"sha": "2794b6c556ff24652aa081903f5f0fdbac9a67c7", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -241,7 +241,7 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n-    fn assertion_maybe(&mut self, item_id: ast::NodeId, attr: &Attribute)\n+    fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute)\n         -> Option<Assertion>\n     {\n         let is_clean = if attr.check_name(ATTR_DIRTY) {\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n \n     /// Gets the \"auto\" assertion on pre-validated attr, along with the `except` labels.\n-    fn assertion_auto(&mut self, item_id: ast::NodeId, attr: &Attribute, is_clean: bool)\n+    fn assertion_auto(&mut self, item_id: hir::HirId, attr: &Attribute, is_clean: bool)\n         -> Assertion\n     {\n         let (name, mut auto) = self.auto_labels(item_id, attr);\n@@ -321,8 +321,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n-    fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n-        let node = self.tcx.hir().get(item_id);\n+    fn auto_labels(&mut self, item_id: hir::HirId, attr: &Attribute) -> (&'static str, Labels) {\n+        let node = self.tcx.hir().get_by_hir_id(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.node {\n@@ -499,8 +499,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(item_id);\n+    fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n@@ -519,15 +519,15 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.check_item(item.id, item.span);\n+        self.check_item(item.hir_id, item.span);\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n-        self.check_item(item.id, item.span);\n+        self.check_item(item.hir_id, item.span);\n     }\n \n     fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n-        self.check_item(item.id, item.span);\n+        self.check_item(item.hir_id, item.span);\n     }\n }\n "}, {"sha": "4d484a64f47df3fc9df1e44490f4e800582b700d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -324,7 +324,7 @@ pub struct MissingDoc {\n     doc_hidden_stack: Vec<bool>,\n \n     /// Private traits or trait items that leaked through. Don't check their methods.\n-    private_traits: FxHashSet<ast::NodeId>,\n+    private_traits: FxHashSet<hir::HirId>,\n }\n \n fn has_doc(attr: &ast::Attribute) -> bool {\n@@ -361,7 +361,7 @@ impl MissingDoc {\n \n     fn check_missing_docs_attrs(&self,\n                                 cx: &LateContext<'_, '_>,\n-                                id: Option<ast::NodeId>,\n+                                id: Option<hir::HirId>,\n                                 attrs: &[ast::Attribute],\n                                 sp: Span,\n                                 desc: &'static str) {\n@@ -380,7 +380,8 @@ impl MissingDoc {\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a NodeId).\n         if let Some(id) = id {\n-            if !cx.access_levels.is_exported(id) {\n+            let node_id = cx.tcx.hir().hir_to_node_id(id);\n+            if !cx.access_levels.is_exported(node_id) {\n                 return;\n             }\n         }\n@@ -444,9 +445,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n-                    self.private_traits.insert(it.id);\n+                    self.private_traits.insert(it.hir_id);\n                     for trait_item_ref in trait_item_refs {\n-                        self.private_traits.insert(trait_item_ref.id.node_id);\n+                        let hir_id = cx.tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n+                        self.private_traits.insert(hir_id);\n                     }\n                     return;\n                 }\n@@ -462,7 +464,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n-                                    self.private_traits.insert(impl_item_ref.id.node_id);\n+                                    let hir_id = cx.tcx.hir().node_to_hir_id(\n+                                        impl_item_ref.id.node_id);\n+                                    self.private_traits.insert(hir_id);\n                                 }\n                             }\n                         }\n@@ -476,11 +480,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n+        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem) {\n-        if self.private_traits.contains(&trait_item.id) {\n+        if self.private_traits.contains(&trait_item.hir_id) {\n             return;\n         }\n \n@@ -491,7 +495,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         };\n \n         self.check_missing_docs_attrs(cx,\n-                                      Some(trait_item.id),\n+                                      Some(trait_item.hir_id),\n                                       &trait_item.attrs,\n                                       trait_item.span,\n                                       desc);\n@@ -510,7 +514,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Existential(_) => \"an associated existential type\",\n         };\n         self.check_missing_docs_attrs(cx,\n-                                      Some(impl_item.id),\n+                                      Some(impl_item.hir_id),\n                                       &impl_item.attrs,\n                                       impl_item.span,\n                                       desc);\n@@ -519,7 +523,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx,\n-                                          Some(sf.id),\n+                                          Some(sf.hir_id),\n                                           &sf.attrs,\n                                           sf.span,\n                                           \"a struct field\")\n@@ -528,7 +532,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.data.id()),\n+                                      Some(v.node.data.hir_id()),\n                                       &v.node.attrs,\n                                       v.span,\n                                       \"a variant\");\n@@ -1108,11 +1112,12 @@ impl LintPass for UnreachablePub {\n }\n \n impl UnreachablePub {\n-    fn perform_lint(&self, cx: &LateContext<'_, '_>, what: &str, id: ast::NodeId,\n+    fn perform_lint(&self, cx: &LateContext<'_, '_>, what: &str, id: hir::HirId,\n                     vis: &hir::Visibility, span: Span, exportable: bool) {\n         let mut applicability = Applicability::MachineApplicable;\n+        let node_id = cx.tcx.hir().hir_to_node_id(id);\n         match vis.node {\n-            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n+            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(node_id) => {\n                 if span.ctxt().outer().expn_info().is_some() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n@@ -1144,20 +1149,20 @@ impl UnreachablePub {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        self.perform_lint(cx, \"item\", item.id, &item.vis, item.span, true);\n+        self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, foreign_item: &hir::ForeignItem) {\n-        self.perform_lint(cx, \"item\", foreign_item.id, &foreign_item.vis,\n+        self.perform_lint(cx, \"item\", foreign_item.hir_id, &foreign_item.vis,\n                           foreign_item.span, true);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField) {\n-        self.perform_lint(cx, \"field\", field.id, &field.vis, field.span, false);\n+        self.perform_lint(cx, \"field\", field.hir_id, &field.vis, field.span, false);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem) {\n-        self.perform_lint(cx, \"item\", impl_item.id, &impl_item.vis, impl_item.span, false);\n+        self.perform_lint(cx, \"item\", impl_item.hir_id, &impl_item.vis, impl_item.span, false);\n     }\n }\n "}, {"sha": "b4a71b887dc37a629fd73d5aa89218d160914c3e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -1667,7 +1667,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_variant(self, v, g, id);\n \n         if let Some(ref discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir().local_def_id(discr.id);\n+            let def_id = self.index.tcx.hir().local_def_id_from_hir_id(discr.hir_id);\n             self.index.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n         }\n     }\n@@ -1719,7 +1719,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n             hir::TyKind::Array(_, ref length) => {\n-                let def_id = self.tcx.hir().local_def_id(length.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(length.hir_id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n             }\n             _ => {}"}, {"sha": "0751af9b12affe41a2868170cbeb9e566bc153a8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -560,7 +560,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let def_id = cx.tcx.hir().local_def_id(count.id);\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(count.hir_id);\n             let substs = InternalSubsts::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let instance = ty::Instance::resolve(\n                 cx.tcx.global_tcx(),"}, {"sha": "0f151cd688df9792182c9dc46f222a62420f7444", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -346,9 +346,9 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 NotUseful => {\n                     match source {\n                         hir::MatchSource::IfLetDesugar { .. } => {\n-                            cx.tcx.lint_node(\n+                            cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                hir_pat.id,\n+                                hir_pat.hir_id,\n                                 pat.span,\n                                 \"irrefutable if-let pattern\",\n                             );\n@@ -359,16 +359,16 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             match arm_index {\n                                 // The arm with the user-specified pattern.\n                                 0 => {\n-                                    cx.tcx.lint_node(\n+                                    cx.tcx.lint_hir(\n                                         lint::builtin::UNREACHABLE_PATTERNS,\n-                                        hir_pat.id, pat.span,\n+                                        hir_pat.hir_id, pat.span,\n                                         \"unreachable pattern\");\n                                 },\n                                 // The arm with the wildcard pattern.\n                                 1 => {\n-                                    cx.tcx.lint_node(\n+                                    cx.tcx.lint_hir(\n                                         lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                        hir_pat.id,\n+                                        hir_pat.hir_id,\n                                         pat.span,\n                                         \"irrefutable while-let pattern\",\n                                     );\n@@ -379,9 +379,9 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n                         hir::MatchSource::ForLoopDesugar |\n                         hir::MatchSource::Normal => {\n-                            let mut err = cx.tcx.struct_span_lint_node(\n+                            let mut err = cx.tcx.struct_span_lint_hir(\n                                 lint::builtin::UNREACHABLE_PATTERNS,\n-                                hir_pat.id,\n+                                hir_pat.hir_id,\n                                 pat.span,\n                                 \"unreachable pattern\",\n                             );"}, {"sha": "d5f2e7a7275e8e54a580880fd5c1bdffa1d8381a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -955,8 +955,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n         let kind = match cv.ty.sty {\n             ty::Float(_) => {\n-                let id = self.tcx.hir().hir_to_node_id(id);\n-                self.tcx.lint_node(\n+                self.tcx.lint_hir(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n                     span,"}, {"sha": "bfc977c28cd3944af30ce32cda1438906cd1990d", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -129,12 +129,12 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // no break */ }`) shouldn't be linted unless it actually\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n-        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir().span(node_id));\n-        let mut db = tcx.struct_span_lint_node(UNCONDITIONAL_RECURSION,\n-                                                node_id,\n-                                                sp,\n-                                                \"function cannot return without recursing\");\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let sp = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(hir_id));\n+        let mut db = tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION,\n+                                              hir_id,\n+                                              sp,\n+                                              \"function cannot return without recursing\");\n         db.span_label(sp, \"cannot return without recursing\");\n         // offer some help to the programmer.\n         for location in &self_call_locations {"}, {"sha": "a58c69f636d41886292ff989d06282289bfad361", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -1006,7 +1006,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n-                let def_id = self.tcx.hir().local_def_id(ii.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(ii.hir_id);\n                 self.push_if_root(def_id);\n             }\n             _ => { /* Nothing to do here */ }"}, {"sha": "a8816720b28bd6f4dfa8b2868ddba4482954513d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -553,10 +553,8 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n }\n \n fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let lint_node_id = match tcx.hir().as_local_node_id(def_id) {\n-        Some(node_id) => node_id,\n-        None => bug!(\"checking unsafety for non-local def id {:?}\", def_id)\n-    };\n+    let lint_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap_or_else(||\n+        bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n     // FIXME: when we make this a hard error, this should have its\n     // own error code.\n@@ -567,10 +565,10 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n         \"#[derive] can't be used on a #[repr(packed)] struct that \\\n          does not derive Copy (error E0133)\".to_string()\n     };\n-    tcx.lint_node(SAFE_PACKED_BORROWS,\n-                  lint_node_id,\n-                  tcx.def_span(def_id),\n-                  &message);\n+    tcx.lint_hir(SAFE_PACKED_BORROWS,\n+                 lint_hir_id,\n+                 tcx.def_span(def_id),\n+                 &message);\n }\n \n /// Returns the `HirId` for an enclosing scope that is also `unsafe`."}, {"sha": "9febe6af5b1fc1814bb087ef0109fbca7d9baf7b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -603,10 +603,10 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         .unwrap()\n                         .source_info\n                         .span;\n-                    let node_id = self\n+                    let hir_id = self\n                         .tcx\n                         .hir()\n-                        .as_local_node_id(self.source.def_id())\n+                        .as_local_hir_id(self.source.def_id())\n                         .expect(\"some part of a failing const eval must be local\");\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     let msg = match msg {\n@@ -643,9 +643,9 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         // Need proper const propagator for these\n                         _ => return,\n                     };\n-                    self.tcx.lint_node(\n+                    self.tcx.lint_hir(\n                         ::rustc::lint::builtin::CONST_ERR,\n-                        node_id,\n+                        hir_id,\n                         span,\n                         &msg,\n                     );"}, {"sha": "4a73f86ef6fe9dd25e08afef0215a8cac8962724", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -290,10 +290,10 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         node_id: ast::NodeId,\n+                         hir_id: hir::HirId,\n                          empty_tables: &'a ty::TypeckTables<'tcx>)\n                          -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(node_id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n@@ -841,22 +841,22 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = mem::replace(&mut self.current_item, item.id);\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n         self.tables = orig_tables;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -1114,7 +1114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n@@ -1123,14 +1123,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -1318,7 +1318,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                      match impl_item.node {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n-                                             self.access_levels.is_reachable(impl_item.id)\n+                                             let node_id = self.tcx.hir().hir_to_node_id(\n+                                                impl_item.hir_id);\n+                                             self.access_levels.is_reachable(node_id)\n                                          }\n                                          hir::ImplItemKind::Existential(..) |\n                                          hir::ImplItemKind::Type(_) => false,\n@@ -1340,10 +1342,11 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n+                                let node_id = self.tcx.hir().hir_to_node_id(impl_item.hir_id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&impl_item.id, &impl_item.vis) =>\n+                                        if self.item_is_public(&node_id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1495,7 +1498,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    item_id: ast::NodeId,\n+    item_id: hir::HirId,\n     item_def_id: DefId,\n     span: Span,\n     /// The visitor checks that each component type is at least this visible.\n@@ -1539,17 +1542,17 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         if self.leaks_private_dep(def_id) {\n-            self.tcx.lint_node(lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n-                               self.item_id,\n-                               self.span,\n-                               &format!(\"{} `{}` from private dependency '{}' in public \\\n-                                         interface\", kind, descr,\n-                                         self.tcx.crate_name(def_id.krate)));\n+            self.tcx.lint_hir(lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n+                              self.item_id,\n+                              self.span,\n+                              &format!(\"{} `{}` from private dependency '{}' in public \\\n+                                        interface\", kind, descr,\n+                                        self.tcx.crate_name(def_id.krate)));\n \n         }\n \n-        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n-            Some(node_id) => node_id,\n+        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n+            Some(hir_id) => hir_id,\n             None => return false,\n         };\n \n@@ -1567,8 +1570,8 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n                 err.emit();\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n-                self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC, node_id, self.span,\n-                                   &format!(\"{} (error {})\", msg, err_code));\n+                self.tcx.lint_hir(lint::builtin::PRIVATE_IN_PUBLIC, hir_id, self.span,\n+                                  &format!(\"{} (error {})\", msg, err_code));\n             }\n \n         }\n@@ -1604,20 +1607,20 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    fn check(&self, item_id: ast::NodeId, required_visibility: ty::Visibility)\n+    fn check(&self, item_id: hir::HirId, required_visibility: ty::Visibility)\n              -> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         let mut has_old_errors = false;\n \n         // Slow path taken only if there any errors in the crate.\n         for &id in self.old_error_set {\n             // Walk up the nodes until we find `item_id` (or we hit a root).\n-            let mut id = self.tcx.hir().hir_to_node_id(id);\n+            let mut id = id;\n             loop {\n                 if id == item_id {\n                     has_old_errors = true;\n                     break;\n                 }\n-                let parent = self.tcx.hir().get_parent_node(id);\n+                let parent = self.tcx.hir().get_parent_node_by_hir_id(id);\n                 if parent == id {\n                     break;\n                 }\n@@ -1632,8 +1635,8 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n             item_id,\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n-            span: self.tcx.hir().span(item_id),\n+            item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n+            span: self.tcx.hir().span_by_hir_id(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,\n@@ -1642,9 +1645,9 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&self, node_id: ast::NodeId, assoc_item_kind: AssociatedItemKind,\n+    fn check_trait_or_impl_item(&self, hir_id: hir::HirId, assoc_item_kind: AssociatedItemKind,\n                                 defaultness: hir::Defaultness, vis: ty::Visibility) {\n-        let mut check = self.check(node_id, vis);\n+        let mut check = self.check(hir_id, vis);\n \n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssociatedItemKind::Const | AssociatedItemKind::Method { .. } => (true, false),\n@@ -1682,48 +1685,49 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of these items have inherited publicity.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n-                self.check(item.id, item_visibility).generics().predicates().ty();\n+                self.check(item.hir_id, item_visibility).generics().predicates().ty();\n             }\n             hir::ItemKind::Existential(..) => {\n                 // `ty()` for existential types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n-                    self.check_trait_or_impl_item(trait_item_ref.id.node_id, trait_item_ref.kind,\n+                    let hir_id = tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n+                    self.check_trait_or_impl_item(hir_id, trait_item_ref.kind,\n                                                   trait_item_ref.defaultness, item_visibility);\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n                     for field in variant.node.data.fields() {\n-                        self.check(field.id, item_visibility).ty();\n+                        self.check(field.hir_id, item_visibility).ty();\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n-                    self.check(foreign_item.id, vis).generics().predicates().ty();\n+                    self.check(foreign_item.hir_id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n                     let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n-                    self.check(field.id, min(item_visibility, field_visibility, tcx)).ty();\n+                    self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n             // An inherent impl is public when its type is public\n@@ -1732,15 +1736,16 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n-                self.check(item.id, impl_vis).generics().predicates();\n+                self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n                     let impl_item_vis = if trait_ref.is_none() {\n                         min(ty::Visibility::from_hir(&impl_item.vis, item.id, tcx), impl_vis, tcx)\n                     } else {\n                         impl_vis\n                     };\n-                    self.check_trait_or_impl_item(impl_item_ref.id.node_id, impl_item_ref.kind,\n+                    let hir_id = tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n+                    self.check_trait_or_impl_item(hir_id, impl_item_ref.kind,\n                                                   impl_item_ref.defaultness, impl_item_vis);\n                 }\n             }"}, {"sha": "44883d438a1e52eddbe93a724df59185e8e1d3dd", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -612,8 +612,8 @@ struct ClauseDumper<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n-    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id(node_id);\n+    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n         for attr in attrs {\n             let mut clauses = None;\n \n@@ -655,22 +655,22 @@ impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.process_attrs(item.id, &item.attrs);\n+        self.process_attrs(item.hir_id, &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.process_attrs(trait_item.id, &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.process_attrs(impl_item.id, &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.process_attrs(s.id, &s.attrs);\n+        self.process_attrs(s.hir_id, &s.attrs);\n         intravisit::walk_struct_field(self, s);\n     }\n }"}, {"sha": "5dbcf908020b0505a6b3c33014bd8220fb946719", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -718,7 +718,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n-                    trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n+                    trait_ref.hir_ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n             // okay to ignore Err because of ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n@@ -802,7 +802,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n     fn ast_type_binding_to_poly_projection_predicate(\n         &self,\n-        ref_id: ast::NodeId,\n+        hir_ref_id: hir::HirId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>,\n         speculative: bool,\n@@ -874,7 +874,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                           binding.item_name, binding.span)\n         }?;\n \n-        let hir_ref_id = self.tcx().hir().node_to_hir_id(ref_id);\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident(binding.item_name, candidate.def_id(), hir_ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n@@ -1798,7 +1797,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length_def_id = tcx.hir().local_def_id(length.id);\n+                let length_def_id = tcx.hir().local_def_id_from_hir_id(length.hir_id);\n                 let substs = InternalSubsts::identity_for_item(tcx, length_def_id);\n                 let length = ty::LazyConst::Unevaluated(length_def_id, substs);\n                 let length = tcx.mk_lazy_const(length);"}, {"sha": "e27672842dbc1d70a20302ecb3b0fd78b21eae85", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype_pat(pat.span, expected, rhs_ty, match_discrim_span);\n                 common_type\n             }\n-            PatKind::Binding(ba, var_id, _, _, ref sub) => {\n+            PatKind::Binding(ba, _, var_id, _, ref sub) => {\n                 let bm = if ba == hir::BindingAnnotation::Unannotated {\n                     def_bm\n                 } else {\n@@ -239,7 +239,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .pat_binding_modes_mut()\n                     .insert(pat.hir_id, bm);\n                 debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let local_ty = self.local_ty(pat.span, pat.id).decl_ty;\n+                let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n                 match bm {\n                     ty::BindByReference(mutbl) => {\n                         // if the binding is like\n@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                if var_id != pat.id {\n+                if var_id != pat.hir_id {\n                     let vt = self.local_ty(pat.span, var_id).decl_ty;\n                     self.demand_eqtype_pat(pat.span, vt, local_ty, match_discrim_span);\n                 }"}, {"sha": "80ffe441561013c5553f9ac483d9532c0b64046f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -137,7 +137,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap, NodeMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -194,7 +194,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     tables: MaybeInProgressTables<'a, 'tcx>,\n \n-    locals: RefCell<NodeMap<LocalTy<'tcx>>>,\n+    locals: RefCell<HirIdMap<LocalTy<'tcx>>>,\n \n     fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n@@ -943,7 +943,7 @@ struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n-    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n+    fn assign(&mut self, span: Span, nid: hir::HirId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n@@ -994,19 +994,19 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n             },\n             None => None,\n         };\n-        self.assign(local.span, local.id, local_ty);\n+        self.assign(local.span, local.hir_id, local_ty);\n \n         debug!(\"Local variable {:?} is assigned type {}\",\n                local.pat,\n                self.fcx.ty_to_string(\n-                   self.fcx.locals.borrow().get(&local.id).unwrap().clone().decl_ty));\n+                   self.fcx.locals.borrow().get(&local.hir_id).unwrap().clone().decl_ty));\n         intravisit::walk_local(self, local);\n     }\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         if let PatKind::Binding(_, _, _, ident, _) = p.node {\n-            let var_ty = self.assign(p.span, p.id, None);\n+            let var_ty = self.assign(p.span, p.hir_id, None);\n \n             if !self.fcx.tcx.features().unsized_locals {\n                 self.fcx.require_type_is_sized(var_ty, p.span,\n@@ -1016,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                    ident,\n                    self.fcx.ty_to_string(\n-                       self.fcx.locals.borrow().get(&p.id).unwrap().clone().decl_ty),\n+                       self.fcx.locals.borrow().get(&p.hir_id).unwrap().clone().decl_ty),\n                    var_ty);\n         }\n         intravisit::walk_pat(self, p);\n@@ -1554,7 +1554,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items() {\n-        let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.id));\n+        let ty_impl_item = tcx.associated_item(\n+            tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n                        tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n@@ -1870,7 +1871,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for v in vs {\n         if let Some(ref e) = v.node.disr_expr {\n-            tcx.typeck_tables_of(tcx.hir().local_def_id(e.id));\n+            tcx.typeck_tables_of(tcx.hir().local_def_id_from_hir_id(e.hir_id));\n         }\n     }\n \n@@ -2124,10 +2125,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         format!(\"{:?}\", self_ptr)\n     }\n \n-    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> LocalTy<'tcx> {\n+    pub fn local_ty(&self, span: Span, nid: hir::HirId) -> LocalTy<'tcx> {\n         self.locals.borrow().get(&nid).cloned().unwrap_or_else(||\n             span_bug!(span, \"no type for local variable {}\",\n-                      self.tcx.hir().node_to_string(nid))\n+                      self.tcx.hir().hir_to_string(nid))\n         )\n     }\n \n@@ -4552,7 +4553,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_array(element_ty, args.len() as u64)\n             }\n             ExprKind::Repeat(ref element, ref count) => {\n-                let count_def_id = tcx.hir().local_def_id(count.id);\n+                let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n                 let param_env = ty::ParamEnv::empty();\n                 let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n                 let instance = ty::Instance::resolve(\n@@ -4805,7 +4806,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // See #44848.\n         let ref_bindings = local.pat.contains_explicit_ref_binding();\n \n-        let local_ty = self.local_ty(init.span, local.id).revealed_ty;\n+        let local_ty = self.local_ty(init.span, local.hir_id).revealed_ty;\n         if let Some(m) = ref_bindings {\n             // Somewhat subtle: if we have a `ref` binding in the pattern,\n             // we want to avoid introducing coercions for the RHS. This is\n@@ -4824,7 +4825,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local) {\n-        let t = self.local_ty(local.span, local.id).decl_ty;\n+        let t = self.local_ty(local.span, local.hir_id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n         if let Some(ref init) = local.init {\n@@ -5378,7 +5379,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let ty = self.local_ty(span, nid).decl_ty;\n+                let hid = self.tcx.hir().node_to_hir_id(nid);\n+                let ty = self.local_ty(span, hid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(hir_id, ty);\n                 return (ty, def);"}, {"sha": "b7c862a89a1b4d8cc29f3bb2e3c6370c650294a5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -108,14 +108,14 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n             check_item_fn(tcx, item);\n         }\n         hir::ItemKind::Static(ref ty, ..) => {\n-            check_item_type(tcx, item.id, ty.span, false);\n+            check_item_type(tcx, item.hir_id, ty.span, false);\n         }\n         hir::ItemKind::Const(ref ty, ..) => {\n-            check_item_type(tcx, item.id, ty.span, false);\n+            check_item_type(tcx, item.hir_id, ty.span, false);\n         }\n         hir::ItemKind::ForeignMod(ref module) => for it in module.items.iter() {\n             if let hir::ForeignItemKind::Static(ref ty, ..) = it.node {\n-                check_item_type(tcx, it.id, ty.span, true);\n+                check_item_type(tcx, it.hir_id, ty.span, true);\n             }\n         },\n         hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n@@ -157,7 +157,7 @@ pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n         hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n         _ => None\n     };\n-    check_associated_item(tcx, trait_item.id, trait_item.span, method_sig);\n+    check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n@@ -168,18 +168,18 @@ pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n         hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n         _ => None\n     };\n-    check_associated_item(tcx, impl_item.id, impl_item.span, method_sig);\n+    check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   item_id: ast::NodeId,\n+                                   item_id: hir::HirId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n-        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n+        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id_from_hir_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n             ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n@@ -220,16 +220,15 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n                             -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-    for_id(tcx, item.id, item.span)\n+    for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n+fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: hir::HirId, span: Span)\n                           -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-    let def_id = tcx.hir().local_def_id(id);\n-    let hir_id = tcx.hir().node_to_hir_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n-        id: hir_id,\n+        id,\n         span,\n         param_env: tcx.param_env(def_id),\n     }\n@@ -339,14 +338,14 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n \n fn check_item_type<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    item_id: ast::NodeId,\n+    item_id: hir::HirId,\n     ty_span: Span,\n     allow_foreign_ty: bool,\n ) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n+        let ty = gcx.type_of(gcx.hir().local_def_id_from_hir_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;\n@@ -1025,13 +1024,13 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let def_id = self.tcx.hir().local_def_id(trait_item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        let def_id = self.tcx.hir().local_def_id(impl_item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n         self.tcx.ensure().check_impl_item_well_formed(def_id);\n     }\n }"}, {"sha": "5981d9bb66bfca81017017746321923d38667a79", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -287,7 +287,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n         intravisit::walk_local(self, l);\n-        let var_ty = self.fcx.local_ty(l.span, l.id).decl_ty;\n+        let var_ty = self.fcx.local_ty(l.span, l.hir_id).decl_ty;\n         let var_ty = self.resolve(&var_ty, &l.span);\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }"}, {"sha": "4c6d7710009bf9dd502c5b7931c571f8021c6b44", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -34,7 +34,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n             return;\n         }\n         if let hir::ItemKind::Use(ref path, _) = item.node {\n-            self.check_import(item.id, path.span);\n+            self.check_import(item.hir_id, path.span);\n         }\n     }\n \n@@ -51,14 +51,13 @@ struct CheckVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n-    fn check_import(&self, id: ast::NodeId, span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(id);\n+    fn check_import(&self, id: hir::HirId, span: Span) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n         if !self.tcx.maybe_unused_trait_import(def_id) {\n             return;\n         }\n \n-        let import_def_id = self.tcx.hir().local_def_id(id);\n-        if self.used_trait_imports.contains(&import_def_id) {\n+        if self.used_trait_imports.contains(&def_id) {\n             return;\n         }\n \n@@ -67,7 +66,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n         } else {\n             \"unused import\".to_owned()\n         };\n-        self.tcx.lint_node(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n+        self.tcx.lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n     }\n }\n \n@@ -121,8 +120,8 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n     });\n \n     for extern_crate in &crates_to_lint {\n-        let id = tcx.hir().as_local_node_id(extern_crate.def_id).unwrap();\n-        let item = tcx.hir().expect_item(id);\n+        let id = tcx.hir().as_local_hir_id(extern_crate.def_id).unwrap();\n+        let item = tcx.hir().expect_item_by_hir_id(id);\n \n         // If the crate is fully unused, we suggest removing it altogether.\n         // We do this in any edition.\n@@ -135,7 +134,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n                     .map(|attr| attr.span)\n                     .fold(span, |acc, attr_span| acc.to(attr_span));\n \n-                tcx.struct_span_lint_node(lint, id, span, msg)\n+                tcx.struct_span_lint_hir(lint, id, span, msg)\n                     .span_suggestion_short(\n                         span_with_attrs,\n                         \"remove it\",\n@@ -177,7 +176,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             None => format!(\"use {};\", item.ident.name),\n         };\n         let replacement = visibility_qualified(&item.vis, base_replacement);\n-        tcx.struct_span_lint_node(lint, id, extern_crate.span, msg)\n+        tcx.struct_span_lint_hir(lint, id, extern_crate.span, msg)\n             .span_suggestion_short(\n                 extern_crate.span,\n                 &help,"}, {"sha": "a51f45a6ff8f3e30785723838b6672e7784e8cb1", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -36,11 +36,11 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let node_id = self.tcx.hir().as_local_node_id(impl1);\n-                    let mut err = if used_to_be_allowed && node_id.is_some() {\n-                        self.tcx.struct_span_lint_node(\n+                    let hir_id = self.tcx.hir().as_local_hir_id(impl1);\n+                    let mut err = if used_to_be_allowed && hir_id.is_some() {\n+                        self.tcx.struct_span_lint_hir(\n                             lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                            node_id.unwrap(),\n+                            hir_id.unwrap(),\n                             self.tcx.span_of_impl(item1).unwrap(),\n                             &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n                         )"}, {"sha": "16102ad4cde30703d8715138d4bfcc32651fabaf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -152,12 +152,12 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        convert_trait_item(self.tcx, trait_item.id);\n+        convert_trait_item(self.tcx, trait_item.hir_id);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        convert_impl_item(self.tcx, impl_item.id);\n+        convert_impl_item(self.tcx, impl_item.hir_id);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n }\n@@ -479,9 +479,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     }\n }\n \n-fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast::NodeId) {\n-    let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n-    let def_id = tcx.hir().local_def_id(trait_item.id);\n+fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir::HirId) {\n+    let trait_item = tcx.hir().expect_trait_item_by_hir_id(trait_item_id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n \n     match trait_item.node {\n@@ -500,12 +500,12 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast:\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::NodeId) {\n-    let def_id = tcx.hir().local_def_id(impl_item_id);\n+fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::HirId) {\n+    let def_id = tcx.hir().local_def_id_from_hir_id(impl_item_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n-    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item(impl_item_id).node {\n+    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item_by_hir_id(impl_item_id).node {\n         tcx.fn_sig(def_id);\n     }\n }\n@@ -532,7 +532,7 @@ fn convert_enum_variant_types<'a, 'tcx>(\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n             if let Some(ref e) = variant.node.disr_expr {\n-                let expr_did = tcx.hir().local_def_id(e.id);\n+                let expr_did = tcx.hir().local_def_id_from_hir_id(e.hir_id);\n                 def.eval_explicit_discr(tcx, expr_did)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n@@ -637,7 +637,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                         let did = tcx.hir().local_def_id(v.node.data.id());\n                         let discr = if let Some(ref e) = v.node.disr_expr {\n                             distance_from_explicit = 0;\n-                            ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.id))\n+                            ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n                         } else {\n                             ty::VariantDiscr::Relative(distance_from_explicit)\n                         };\n@@ -1142,11 +1142,11 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     use rustc::hir::*;\n \n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir().get(node_id) {\n+    match tcx.hir().get_by_hir_id(hir_id) {\n         Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1166,7 +1166,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n             ImplItemKind::Existential(_) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir().get_parent_did(node_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did_by_hir_id(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1176,7 +1176,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n             ImplItemKind::Type(ref ty) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir().get_parent_did(node_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did_by_hir_id(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1259,7 +1259,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_did(node_id))\n+                tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id))\n             }\n             VariantData::Tuple(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1274,7 +1274,6 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => {\n             if gen.is_some() {\n-                let hir_id = tcx.hir().node_to_hir_id(node_id);\n                 return tcx.typeck_tables_of(def_id).node_type(hir_id);\n             }\n \n@@ -1285,7 +1284,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(node_id)) {\n+        Node::AnonConst(_) => match tcx.hir().get_by_hir_id(\n+            tcx.hir().get_parent_node_by_hir_id(hir_id))\n+        {\n             Node::Ty(&hir::Ty {\n                 node: hir::TyKind::Array(_, ref constant),\n                 ..\n@@ -1297,7 +1298,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             | Node::Expr(&hir::Expr {\n                 node: ExprKind::Repeat(_, ref constant),\n                 ..\n-            }) if constant.id == node_id =>\n+            }) if constant.hir_id == hir_id =>\n             {\n                 tcx.types.usize\n             }\n@@ -1309,9 +1310,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                         ..\n                     },\n                 ..\n-            }) if e.id == node_id =>\n+            }) if e.hir_id == hir_id =>\n             {\n-                tcx.adt_def(tcx.hir().get_parent_did(node_id))\n+                tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n                     .repr\n                     .discr_type()\n                     .to_ty(tcx)\n@@ -1484,15 +1485,15 @@ fn find_existential_constraints<'a, 'tcx>(\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n-            let def_id = self.tcx.hir().local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             // the existential type itself or its children are not within its reveal scope\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n-            let def_id = self.tcx.hir().local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -2062,7 +2063,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n             };\n \n             let assoc_ty =\n-                tcx.mk_projection(tcx.hir().local_def_id(trait_item.id), self_trait_ref.substs);\n+                tcx.mk_projection(tcx.hir().local_def_id_from_hir_id(trait_item.hir_id),\n+                    self_trait_ref.substs);\n \n             let bounds = compute_bounds(\n                 &ItemCtxt::new(tcx, def_id),"}, {"sha": "a918113b1fc0b44ac02c8ab8fe1dbbb85ea8536d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -386,8 +386,8 @@ pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait:\n     // In case there are any projections etc, find the \"environment\"\n     // def-id that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n-    let env_node_id = tcx.hir().get_parent(hir_trait.ref_id);\n-    let env_def_id = tcx.hir().local_def_id(env_node_id);\n+    let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n+    let env_def_id = tcx.hir().local_def_id_from_hir_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut projections = Vec::new();\n     let (principal, _) = astconv::AstConv::instantiate_poly_trait_ref_inner("}, {"sha": "d8d93b462a900b4328285b0594c0304636a83114", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -6,7 +6,6 @@\n use hir::def_id::DefId;\n use rustc::ty::subst::{UnpackedKind, SubstsRef};\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -72,31 +71,31 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n-                self.visit_node_helper(item.id);\n+                self.visit_node_helper(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.visit_node_helper(struct_def.id());\n+                    self.visit_node_helper(struct_def.hir_id());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.visit_node_helper(item.id);\n+                self.visit_node_helper(item.hir_id);\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.id());\n+                        self.visit_node_helper(variant.node.data.hir_id());\n                     }\n                 }\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.visit_node_helper(item.id);\n+                self.visit_node_helper(item.hir_id);\n             }\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n-                        self.visit_node_helper(foreign_item.id);\n+                        self.visit_node_helper(foreign_item.hir_id);\n                     }\n                 }\n             }\n@@ -107,21 +106,21 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(..) = trait_item.node {\n-            self.visit_node_helper(trait_item.id);\n+            self.visit_node_helper(trait_item.hir_id);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         if let hir::ImplItemKind::Method(..) = impl_item.node {\n-            self.visit_node_helper(impl_item.id);\n+            self.visit_node_helper(impl_item.hir_id);\n         }\n     }\n }\n \n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn visit_node_helper(&mut self, id: ast::NodeId) {\n+    fn visit_node_helper(&mut self, id: hir::HirId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n         self.build_constraints_for_item(def_id);\n     }\n \n@@ -138,7 +137,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).sty {\n@@ -356,7 +355,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_node_id(def_id) {\n+        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_hir_id(def_id) {\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {\n             (None, Some(self.tcx().variances_of(def_id)))"}, {"sha": "cec33ba87dea46de47c7e912ac29657f6b274de6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let solutions = &self.solutions;\n         self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n-            let def_id = tcx.hir().local_def_id(id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(id);\n             let generics = tcx.generics_of(def_id);\n \n             let mut variances = solutions[start..start+generics.count()].to_vec();"}, {"sha": "e564a8658fcaba8a4fde306acfe1a25331b0d326", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -12,10 +12,9 @@\n use arena::TypedArena;\n use rustc::ty::{self, TyCtxt};\n use std::fmt;\n-use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use crate::util::nodemap::NodeMap;\n+use crate::util::nodemap::HirIdMap;\n \n use self::VarianceTerm::*;\n \n@@ -55,11 +54,11 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n     // variance.\n-    pub lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n+    pub lang_items: Vec<(hir::HirId, Vec<ty::Variance>)>,\n \n     // Maps from the node id of an item to the first inferred index\n     // used for its type & region parameters.\n-    pub inferred_starts: NodeMap<InferredIndex>,\n+    pub inferred_starts: HirIdMap<InferredIndex>,\n \n     // Maps from an InferredIndex to the term for that variable.\n     pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n@@ -86,7 +85,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     terms_cx\n }\n \n-fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n+fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n     let lang_items = tcx.lang_items();\n     let all = vec![\n         (lang_items.phantom_data(), vec![ty::Covariant]),\n@@ -96,14 +95,14 @@ fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(ast::NodeId, Vec<ty::Variance>)>\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n        .filter(|&(ref d,_)| d.is_some())\n        .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-       .filter_map(|(d, v)| tcx.hir().as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n+       .filter_map(|(d, v)| tcx.hir().as_local_hir_id(d).map(|n| (n, v))) // (HirId, Variance)\n        .collect()\n }\n \n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n-    fn add_inferreds_for_item(&mut self, id: ast::NodeId) {\n+    fn add_inferreds_for_item(&mut self, id: hir::HirId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n         let count = tcx.generics_of(def_id).count();\n \n         if count == 0 {\n@@ -134,31 +133,31 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n-                self.add_inferreds_for_item(item.id);\n+                self.add_inferreds_for_item(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.add_inferreds_for_item(struct_def.id());\n+                    self.add_inferreds_for_item(struct_def.hir_id());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.add_inferreds_for_item(item.id);\n+                self.add_inferreds_for_item(item.hir_id);\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.id());\n+                        self.add_inferreds_for_item(variant.node.data.hir_id());\n                     }\n                 }\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.add_inferreds_for_item(item.id);\n+                self.add_inferreds_for_item(item.hir_id);\n             }\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n-                        self.add_inferreds_for_item(foreign_item.id);\n+                        self.add_inferreds_for_item(foreign_item.hir_id);\n                     }\n                 }\n             }\n@@ -169,13 +168,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(..) = trait_item.node {\n-            self.add_inferreds_for_item(trait_item.id);\n+            self.add_inferreds_for_item(trait_item.hir_id);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         if let hir::ImplItemKind::Method(..) = impl_item.node {\n-            self.add_inferreds_for_item(impl_item.id);\n+            self.add_inferreds_for_item(impl_item.hir_id);\n         }\n     }\n }"}, {"sha": "d07a4579ad5c3b20b73402846a7578e084a60133", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -115,7 +115,6 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         if result.is_auto() {\n             let trait_ = hir::TraitRef {\n                 path: get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait),\n-                ref_id: ast::DUMMY_NODE_ID,\n                 hir_ref_id: hir::DUMMY_HIR_ID,\n             };\n "}, {"sha": "5a13490eeccf23b8e4a52348d6df065393ee5645", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -123,7 +123,6 @@ impl<'a, 'tcx, 'rcx> BlanketImplFinder <'a, 'tcx, 'rcx> {\n                             path: get_path_for_type(infcx.tcx,\n                                                     trait_def_id,\n                                                     hir::def::Def::Trait),\n-                            ref_id: ast::DUMMY_NODE_ID,\n                             hir_ref_id: hir::DUMMY_HIR_ID,\n                         };\n                         let provided_trait_methods ="}, {"sha": "d88d0dab4f0ebb5bfd2950eba7e1621ce1fb9a70", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -2022,14 +2022,15 @@ impl Clean<Item> for hir::TraitItem {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n+        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: local_did,\n             visibility: None,\n-            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n+            stability: get_stability(cx, local_did),\n+            deprecation: get_deprecation(cx, local_did),\n             inner,\n         }\n     }\n@@ -2054,14 +2055,15 @@ impl Clean<Item> for hir::ImplItem {\n                 generics: Generics::default(),\n             }, true),\n         };\n+        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: local_did,\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n+            stability: get_stability(cx, local_did),\n+            deprecation: get_deprecation(cx, local_did),\n             inner,\n         }\n     }\n@@ -2531,7 +2533,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n             TyKind::Array(ref ty, ref length) => {\n-                let def_id = cx.tcx.hir().local_def_id(length.id);\n+                let def_id = cx.tcx.hir().local_def_id_from_hir_id(length.hir_id);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n                 let cid = GlobalId {"}, {"sha": "25c86b24c187b6eba04fd4989a727c694fc1a430", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -473,9 +473,9 @@ fn resolution_failure(\n ) {\n     let sp = span_of_attrs(attrs);\n \n-    let mut diag = cx.tcx.struct_span_lint_node(\n+    let mut diag = cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-        NodeId::from_u32(0),\n+        hir::CRATE_HIR_ID,\n         sp,\n         &format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str),\n     );"}, {"sha": "d6f3585a04f336728fc8fa29d11492b34efd2e4d", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d2d83ca3b5155468ab96b09a7c54568449b137/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=c1d2d83ca3b5155468ab96b09a7c54568449b137", "patch": "@@ -1,12 +1,12 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n-use syntax::ast::NodeId;\n use syntax_pos::{DUMMY_SP, Span};\n use std::ops::Range;\n \n@@ -312,18 +312,18 @@ pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a>(\n \n     if find_testable_code(&dox, &mut tests, ErrorCodes::No).is_ok() {\n         if check_missing_code == true && tests.found_tests == 0 {\n-            let mut diag = cx.tcx.struct_span_lint_node(\n+            let mut diag = cx.tcx.struct_span_lint_hir(\n                 lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-                NodeId::from_u32(0),\n+                hir::CRATE_HIR_ID,\n                 span_of_attrs(&item.attrs),\n                 \"Missing code example in this documentation\");\n             diag.emit();\n         } else if check_missing_code == false &&\n                   tests.found_tests > 0 &&\n                   !cx.renderinfo.borrow().access_levels.is_doc_reachable(item.def_id) {\n-            let mut diag = cx.tcx.struct_span_lint_node(\n+            let mut diag = cx.tcx.struct_span_lint_hir(\n                 lint::builtin::PRIVATE_DOC_TESTS,\n-                NodeId::from_u32(0),\n+                hir::CRATE_HIR_ID,\n                 span_of_attrs(&item.attrs),\n                 \"Documentation test in private item\");\n             diag.emit();"}]}