{"sha": "d08b443fffb1181d8d45ae5d061412f202dd4118", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOGI0NDNmZmZiMTE4MWQ4ZDQ1YWU1ZDA2MTQxMmYyMDJkZDQxMTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-02T23:24:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-03T00:35:33Z"}, "message": "Revert \"Use different syntax for checks that matter to typestate\"\n\nThis reverts commit aa25f22f197682de3b18fc4c8ba068d1feda220f. It broke stage2, not sure why yet.", "tree": {"sha": "ad75b4e4fc9407aa1201f9068012f30664d17b64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad75b4e4fc9407aa1201f9068012f30664d17b64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08b443fffb1181d8d45ae5d061412f202dd4118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08b443fffb1181d8d45ae5d061412f202dd4118", "html_url": "https://github.com/rust-lang/rust/commit/d08b443fffb1181d8d45ae5d061412f202dd4118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08b443fffb1181d8d45ae5d061412f202dd4118/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764de078e7c4baaf0a1f426e7ac4d834c2ea8797", "url": "https://api.github.com/repos/rust-lang/rust/commits/764de078e7c4baaf0a1f426e7ac4d834c2ea8797", "html_url": "https://github.com/rust-lang/rust/commit/764de078e7c4baaf0a1f426e7ac4d834c2ea8797"}], "stats": {"total": 2495, "additions": 1239, "deletions": 1256}, "files": [{"sha": "6b232e7eba7edaa3e5cb2f7a1dfc25becf498a2b", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -199,14 +199,6 @@ and parse_stmts_including_none (ps:pstate) : Ast.stmt array =\n           bump ps;\n           expect ps SEMI;\n           [| span ps apos (lexpos ps) Ast.STMT_cont |]\n-      | ASSERT ->\n-          bump ps;\n-          let (stmts, expr) =\n-             ctxt \"stmts: check value\" parse_expr ps\n-          in\n-              expect ps SEMI;\n-              spans ps stmts apos (Ast.STMT_check_expr expr)\n-(* leaving check as it is; adding assert as a synonym for the \"old\" check *)\n       | CHECK ->\n           bump ps;\n           begin"}, {"sha": "b375b874b89d259d405728ddea71d9bc26c75b7a", "filename": "src/boot/fe/lexer.mll", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -92,7 +92,6 @@\n \n                 (\"type\", TYPE);\n                 (\"check\", CHECK);\n-                (\"assert\", ASSERT); \n                 (\"claim\", CLAIM);\n                 (\"prove\", PROVE);\n "}, {"sha": "0b1579839847c00f3f66c0976315e6f55eff91a7", "filename": "src/boot/fe/token.ml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -77,7 +77,6 @@ type token =\n   (* Type and type-state keywords *)\n   | TYPE\n   | CHECK\n-  | ASSERT\n   | CLAIM\n   | PROVE\n \n@@ -238,7 +237,6 @@ let rec string_of_tok t =\n     (* Type and type-state keywords *)\n     | TYPE       -> \"type\"\n     | CHECK      -> \"check\"\n-    | ASSERT     -> \"assert\"\n     | CLAIM      -> \"claim\"\n     | PROVE      -> \"prove\"\n "}, {"sha": "2fd13194e50375fe9093de822711ed5726c91d26", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -283,10 +283,7 @@ tag expr_ {\n     expr_put(option.t[@expr], ann);\n     expr_be(@expr, ann);\n     expr_log(int, @expr, ann);\n-/* just an assert, no significance to typestate */\n-    expr_assert(@expr, ann);\n-/* preds that typestate is aware of */\n-    expr_check(@expr, ann);\n+    expr_check_expr(@expr, ann);\n     expr_port(ann);\n     expr_chan(@expr, ann);\n }"}, {"sha": "f48d47c90be608f93122e422f6ab2e536c043793", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -93,7 +93,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('c') { ret ty.mk_char(st.tcx); }\n         case ('s') { ret ty.mk_str(st.tcx); }\n         case ('t') {\n-            assert (next(st) as char == '[');\n+            check(next(st) as char == '[');\n             auto def = parse_def(st, sd);\n             let vec[ty.t] params = vec();\n             while (peek(st) as char != ']') {\n@@ -108,7 +108,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('P') { ret ty.mk_port(st.tcx, parse_ty(st, sd)); }\n         case ('C') { ret ty.mk_chan(st.tcx, parse_ty(st, sd)); }\n         case ('T') {\n-            assert (next(st) as char == '[');\n+            check(next(st) as char == '[');\n             let vec[ty.mt] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_mt(st, sd));\n@@ -117,7 +117,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n             ret ty.mk_tup(st.tcx, params);\n         }\n         case ('R') {\n-            assert (next(st) as char == '[');\n+            check(next(st) as char == '[');\n             let vec[ty.field] fields = vec();\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n@@ -149,7 +149,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n             ret ty.mk_native_fn(st.tcx,abi,func._0,func._1);\n         }\n         case ('O') {\n-            assert (next(st) as char == '[');\n+            check(next(st) as char == '[');\n             let vec[ty.method] methods = vec();\n             while (peek(st) as char != ']') {\n                 auto proto;\n@@ -175,9 +175,9 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('Y') { ret ty.mk_type(st.tcx); }\n         case ('#') {\n             auto pos = parse_hex(st);\n-            assert (next(st) as char == ':');\n+            check (next(st) as char == ':');\n             auto len = parse_hex(st);\n-            assert (next(st) as char == '#');\n+            check (next(st) as char == '#');\n             alt (st.tcx.rcache.find(tup(st.crate,pos,len))) {\n                 case (some[ty.t](?tt)) { ret tt; }\n                 case (none[ty.t]) {\n@@ -245,7 +245,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n-    assert (next(st) as char == '[');\n+    check(next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n     while (peek(st) as char != ']') {\n         auto mode = ast.val;"}, {"sha": "3659af1c655e2708a8c9aad56e3fe889b60e6d09", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -127,7 +127,6 @@ fn keyword_table() -> std.map.hashmap[str, token.token] {\n \n     keywords.insert(\"type\", token.TYPE);\n     keywords.insert(\"check\", token.CHECK);\n-    keywords.insert(\"assert\", token.ASSERT);\n     keywords.insert(\"claim\", token.CLAIM);\n     keywords.insert(\"prove\", token.PROVE);\n \n@@ -529,7 +528,7 @@ fn scan_numeric_escape(reader rdr) -> char {\n \n     auto n_hex_digits = 0;\n \n-    assert (rdr.curr() == '\\\\');\n+    check (rdr.curr() == '\\\\');\n \n     alt (rdr.next()) {\n         case ('x') { n_hex_digits = 2; }"}, {"sha": "fdd41cf0ff702784691f925ccbf8b09415cb9816", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -621,7 +621,7 @@ fn parse_path(parser p, greed g) -> ast.path {\n                 if (p.peek() == token.DOT) {\n                     if (g == GREEDY) {\n                         p.bump();\n-                        assert (is_ident(p.peek()));\n+                        check (is_ident(p.peek()));\n                     } else {\n                         more = false;\n                     }\n@@ -816,22 +816,19 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n             ex = ast.expr_log(0, e, ast.ann_none);\n         }\n \n-        case (token.ASSERT) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            auto hi = e.span.hi;\n-            ex = ast.expr_assert(e, ast.ann_none);\n-        }\n-\n         case (token.CHECK) {\n             p.bump();\n-            /* Should be a predicate (pure boolean function) applied to \n-             arguments that are all either slot variables or literals.\n-            but the typechecker enforces that. */\n-            auto e = parse_expr(p);\n-            auto hi = e.span.hi;\n-            ex = ast.expr_check(e, ast.ann_none);\n-        } \n+            alt (p.peek()) {\n+                case (token.LPAREN) {\n+                    auto e = parse_expr(p);\n+                    auto hi = e.span.hi;\n+                    ex = ast.expr_check_expr(e, ast.ann_none);\n+                }\n+                case (_) {\n+                    p.get_session().unimpl(\"constraint-check stmt\");\n+                }\n+            }\n+        }\n \n         case (token.RET) {\n             p.bump();\n@@ -940,7 +937,7 @@ fn expand_syntax_ext(parser p, ast.span sp,\n                      &ast.path path, vec[@ast.expr] args,\n                      option.t[str] body) -> ast.expr_ {\n \n-    assert (_vec.len[ast.ident](path.node.idents) > 0u);\n+    check (_vec.len[ast.ident](path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n     if (_str.eq(extname, \"fmt\")) {\n         auto expanded = extfmt.expand_syntax_ext(args, body);\n@@ -1676,8 +1673,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_put(_,_))        { ret true; }\n                 case (ast.expr_be(_,_))         { ret true; }\n                 case (ast.expr_log(_,_,_))        { ret true; }\n-                case (ast.expr_check(_,_)) { ret true; }\n-                case (ast.expr_assert(_,_)) { ret true; }\n+                case (ast.expr_check_expr(_,_)) { ret true; }\n             }\n         }\n         // We should not be calling this on a cdir.\n@@ -2161,24 +2157,24 @@ fn parse_item(parser p) -> @ast.item {\n \n     alt (p.peek()) {\n         case (token.CONST) {\n-            assert (lyr == ast.layer_value);\n+            check (lyr == ast.layer_value);\n             ret parse_item_const(p);\n         }\n \n         case (token.FN) {\n-            assert (lyr == ast.layer_value);\n+            check (lyr == ast.layer_value);\n             ret parse_item_fn_or_iter(p);\n         }\n         case (token.ITER) {\n-            assert (lyr == ast.layer_value);\n+            check (lyr == ast.layer_value);\n             ret parse_item_fn_or_iter(p);\n         }\n         case (token.MOD) {\n-            assert (lyr == ast.layer_value);\n+            check (lyr == ast.layer_value);\n             ret parse_item_mod(p);\n         }\n         case (token.NATIVE) {\n-            assert (lyr == ast.layer_value);\n+            check (lyr == ast.layer_value);\n             ret parse_item_native_mod(p);\n         }\n         case (token.TYPE) {"}, {"sha": "f367bcc6835a26b32ea397f6a7f054bfb3b56ae2", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -89,7 +89,6 @@ tag token {\n \n     /* Type and type-state keywords */\n     TYPE;\n-    ASSERT;\n     CHECK;\n     CLAIM;\n     PROVE;\n@@ -259,7 +258,6 @@ fn to_str(token t) -> str {\n \n         /* Type and type-state keywords */\n         case (TYPE) { ret \"type\"; }\n-        case (ASSERT) { ret \"assert\"; }\n         case (CHECK) { ret \"check\"; }\n         case (CLAIM) { ret \"claim\"; }\n         case (PROVE) { ret \"prove\"; }"}, {"sha": "41ec1836d18d2bd82df6a709a0365347b89ac732", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -861,46 +861,46 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n \n     /* Terminators */\n     fn RetVoid()  -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildRetVoid(B);\n     }\n \n     fn Ret(ValueRef V) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildRet(B, V);\n     }\n \n     fn AggregateRet(vec[ValueRef] RetVals) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildAggregateRet(B,\n                                        _vec.buf[ValueRef](RetVals),\n                                        _vec.len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildBr(B, Dest);\n     }\n \n     fn CondBr(ValueRef If, BasicBlockRef Then,\n               BasicBlockRef Else) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildCondBr(B, If, Then, Else);\n     }\n \n     fn Switch(ValueRef V, BasicBlockRef Else, uint NumCases) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildSwitch(B, V, Else, NumCases);\n     }\n \n     fn IndirectBr(ValueRef Addr, uint NumDests) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n@@ -909,7 +909,7 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n               vec[ValueRef] Args,\n               BasicBlockRef Then,\n               BasicBlockRef Catch) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildInvoke(B, Fn,\n                                  _vec.buf[ValueRef](Args),\n@@ -919,353 +919,353 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     }\n \n     fn Unwind() -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildUnwind(B);\n     }\n \n     fn Unreachable() -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildUnreachable(B);\n     }\n \n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildUDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildURem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildShl(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildLShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildAShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildAnd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildOr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildXor(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWNeg(B, V, _str.buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFNeg(B, V, _str.buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildNot(B, V, _str.buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildMalloc(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildAlloca(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFree(B, PointerVal);\n     }\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildLoad(B, PointerVal, _str.buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildStore(B, Val, Ptr);\n     }\n \n     fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildGEP(B, Pointer,\n                               _vec.buf[ValueRef](Indices),\n                               _vec.len[ValueRef](Indices),\n                               _str.buf(\"\"));\n     }\n \n     fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildInBoundsGEP(B, Pointer,\n                                       _vec.buf[ValueRef](Indices),\n                                       _vec.len[ValueRef](Indices),\n                                       _str.buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, _str.buf(\"\"));\n     }\n \n     fn GlobalString(sbuf Str) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildGlobalString(B, Str, _str.buf(\"\"));\n     }\n \n     fn GlobalStringPtr(sbuf Str) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildGlobalStringPtr(B, Str, _str.buf(\"\"));\n     }\n \n     /* Casts */\n     fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildTrunc(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildZExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPToUI(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPToSI(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildUIToFP(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSIToFP(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildCast(B, Op, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildPointerCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildIntCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n \n     /* Comparisons */\n     fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n \n     /* Miscellaneous instructions */\n     fn Phi(TypeRef Ty, vec[ValueRef] vals,\n            vec[BasicBlockRef] bbs) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         auto phi = llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n-        assert (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n                              _vec.buf[ValueRef](vals),\n                              _vec.buf[BasicBlockRef](bbs),\n@@ -1276,23 +1276,23 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     fn AddIncomingToPhi(ValueRef phi,\n                         vec[ValueRef] vals,\n                         vec[BasicBlockRef] bbs) {\n-        assert (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n                              _vec.buf[ValueRef](vals),\n                              _vec.buf[BasicBlockRef](bbs),\n                              _vec.len[ValueRef](vals));\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildCall(B, Fn,\n                                _vec.buf[ValueRef](Args),\n                                _vec.len[ValueRef](Args),\n                                _str.buf(\"\"));\n     }\n \n     fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         auto v = llvm.LLVMBuildCall(B, Fn,\n                                     _vec.buf[ValueRef](Args),\n                                     _vec.len[ValueRef](Args),\n@@ -1302,65 +1302,65 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     }\n \n     fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildSelect(B, If, Then, Else, _str.buf(\"\"));\n     }\n \n     fn VAArg(ValueRef List, TypeRef Ty) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildVAArg(B, List, Ty, _str.buf(\"\"));\n     }\n \n     fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildExtractElement(B, VecVal, Index, _str.buf(\"\"));\n     }\n \n     fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n                      ValueRef Index) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n                                         _str.buf(\"\"));\n     }\n \n     fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, _str.buf(\"\"));\n     }\n \n     fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildExtractValue(B, AggVal, Index, _str.buf(\"\"));\n     }\n \n     fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n                    uint Index) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, _str.buf(\"\"));\n     }\n \n     fn IsNull(ValueRef Val) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildIsNull(B, Val, _str.buf(\"\"));\n     }\n \n     fn IsNotNull(ValueRef Val) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildIsNotNull(B, Val, _str.buf(\"\"));\n     }\n \n     fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Trap() -> ValueRef {\n-        assert (!*terminated);\n+        check (!*terminated);\n         let BasicBlockRef BB = llvm.LLVMGetInsertBlock(B);\n         let ValueRef FN = llvm.LLVMGetBasicBlockParent(BB);\n         let ModuleRef M = llvm.LLVMGetGlobalParent(FN);\n         let ValueRef T = llvm.LLVMGetNamedFunction(M, _str.buf(\"llvm.trap\"));\n-        assert (T as int != 0);\n+        check (T as int != 0);\n         let vec[ValueRef] Args = vec();\n         ret llvm.LLVMBuildCall(B, T,\n                                _vec.buf[ValueRef](Args),\n@@ -1391,8 +1391,8 @@ state obj type_names(std.map.hashmap[TypeRef, str] type_names,\n                     std.map.hashmap[str, TypeRef] named_types) {\n \n     fn associate(str s, TypeRef t) {\n-        assert (!named_types.contains_key(s));\n-        assert (!type_names.contains_key(t));\n+        check (!named_types.contains_key(s));\n+        check (!type_names.contains_key(t));\n         type_names.insert(t, s);\n         named_types.insert(s, t);\n     }"}, {"sha": "a0f3bc93f955d846eeb49917b46d4164193624fa", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -196,10 +196,7 @@ type ast_fold[ENV] =\n          @expr e, ann a) -> @expr)                fold_expr_log,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_check,\n-\n-     (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_assert,\n+         @expr e, ann a) -> @expr)                fold_expr_check_expr,\n \n      (fn(&ENV e, &span sp,\n          ann a) -> @expr)                         fold_expr_port,\n@@ -799,16 +796,10 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_log(env_, e.span, l, ee, t2);\n         }\n \n-        case (ast.expr_check(?x, ?t)) {\n+        case (ast.expr_check_expr(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_check(env_, e.span, ee, t2);\n-        }\n-\n-        case (ast.expr_assert(?x, ?t)) {\n-            auto ee = fold_expr(env_, fld, x);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_assert(env_, e.span, ee, t2);\n+            ret fld.fold_expr_check_expr(env_, e.span, ee, t2);\n         }\n \n         case (ast.expr_port(?t)) {\n@@ -1389,14 +1380,9 @@ fn identity_fold_expr_log[ENV](&ENV e, &span sp, int lvl, @expr x,\n     ret @respan(sp, ast.expr_log(lvl, x, a));\n }\n \n-fn identity_fold_expr_check[ENV](&ENV e, &span sp, @expr x, ann a)\n-    -> @expr {\n-    ret @respan(sp, ast.expr_check(x, a));\n-}\n-\n-fn identity_fold_expr_assert[ENV](&ENV e, &span sp, @expr x, ann a)\n+fn identity_fold_expr_check_expr[ENV](&ENV e, &span sp, @expr x, ann a)\n     -> @expr {\n-    ret @respan(sp, ast.expr_check(x, a));\n+    ret @respan(sp, ast.expr_check_expr(x, a));\n }\n \n fn identity_fold_expr_port[ENV](&ENV e, &span sp, ann a) -> @expr {\n@@ -1690,11 +1676,8 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_put    = bind identity_fold_expr_put[ENV](_,_,_,_),\n          fold_expr_be     = bind identity_fold_expr_be[ENV](_,_,_,_),\n          fold_expr_log    = bind identity_fold_expr_log[ENV](_,_,_,_,_),\n-         fold_expr_check\n-         = bind identity_fold_expr_check[ENV](_,_,_,_),\n-         fold_expr_assert\n-         = bind identity_fold_expr_assert[ENV](_,_,_,_),\n-              \n+         fold_expr_check_expr\n+         = bind identity_fold_expr_check_expr[ENV](_,_,_,_),\n          fold_expr_port   = bind identity_fold_expr_port[ENV](_,_,_),\n          fold_expr_chan   = bind identity_fold_expr_chan[ENV](_,_,_,_),\n "}, {"sha": "806f38b52528126f221f03896834f12cb5f8a1b5", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -63,7 +63,7 @@ mod Encode {\n     );\n \n     fn ty_str(@ctxt cx, ty.t t) -> str {\n-        assert (! cx.use_abbrevs);\n+        check (! cx.use_abbrevs);\n         auto sw = io.string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();"}, {"sha": "d75a6db09d9ab5c3e8f19e07f758e03900a2262c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -662,7 +662,7 @@ fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n                   ann a) -> @ast.expr {\n     auto n_idents = _vec.len[ast.ident](p.node.idents);\n-    assert (n_idents != 0u);\n+    check (n_idents != 0u);\n \n     auto index = new_def_hash[def_wrap]();\n     auto d = find_final_def(e, index, sp, p.node.idents, ns_value,"}, {"sha": "d4ba3073bbbe8e09dacf090f42e785296c9e1134", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -586,7 +586,7 @@ fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(cx.tcx, arg.ty)) {\n-            assert (arg.mode == ast.alias);\n+            check (arg.mode == ast.alias);\n             atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n             let TypeRef t;\n@@ -632,7 +632,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some[TypeRef](?t)) {\n-            assert (t as int != 0);\n+            check (t as int != 0);\n             atys += vec(t);\n         }\n         case (_) {\n@@ -800,7 +800,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n         case (ty.ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n \n-    assert (llty as int != 0);\n+    check (llty as int != 0);\n     llvm.LLVMAddTypeName(cx.llmod,\n                          _str.buf(ty.ty_to_short_str(cx.tcx,\n                                                      cx.type_abbrevs, t)),\n@@ -1355,7 +1355,7 @@ fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n fn GEP_tup_like(@block_ctxt cx, ty.t t,\n                 ValueRef base, vec[int] ixs) -> result {\n \n-    assert (ty.type_is_tup_like(cx.fcx.lcx.ccx.tcx, t));\n+    check (ty.type_is_tup_like(cx.fcx.lcx.ccx.tcx, t));\n \n     // It might be a static-known type. Handle this.\n \n@@ -1393,17 +1393,17 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n         // and the latter would only be meaningful if we supported non-0\n         // values for the 0th index (we don't).\n \n-        assert (len > 1u);\n+        check (len > 1u);\n \n         if (n == 0u) {\n             // Since we're starting from a value that's a pointer to a\n             // *single* structure, the first index (in GEP-ese) should just be\n             // 0, to yield the pointee.\n-            assert (ixs.(n) == 0);\n+            check (ixs.(n) == 0);\n             ret split_type(ccx, t, ixs, n+1u);\n         }\n \n-        assert (n < len);\n+        check (n < len);\n \n         let int ix = ixs.(n);\n         let vec[ty.t] prefix = vec();\n@@ -1618,8 +1618,8 @@ fn get_tydesc(&@block_ctxt cx, ty.t t, bool escapes) -> result {\n         let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n         auto tys = linearize_ty_params(cx, t);\n \n-        assert (n_params == _vec.len[uint](tys._0));\n-        assert (n_params == _vec.len[ValueRef](tys._1));\n+        check (n_params == _vec.len[uint](tys._0));\n+        check (n_params == _vec.len[ValueRef](tys._1));\n \n         auto root = get_static_tydesc(cx, t, tys._0).tydesc;\n \n@@ -2348,7 +2348,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n         ret creader.get_tag_variants(cx.sess, cx.tcx, id);\n     }\n \n-    assert (cx.items.contains_key(id));\n+    check (cx.items.contains_key(id));\n     alt (cx.items.get(id).node) {\n         case (ast.item_tag(_, ?variants, _, _, _)) {\n             let vec[variant_info] result = vec();\n@@ -3367,7 +3367,7 @@ fn join_results(@block_ctxt parent_cx,\n             // No incoming edges are live, so we're in dead-code-land.\n             // Arbitrarily pick the first dead edge, since the caller\n             // is just going to propagate it outward.\n-            assert (_vec.len[result](ins) >= 1u);\n+            check (_vec.len[result](ins) >= 1u);\n             ret ins.(0);\n         }\n \n@@ -3995,7 +3995,7 @@ fn lval_generic_fn(@block_ctxt cx,\n     auto lv;\n     if (cx.fcx.lcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n         // Internal reference.\n-        assert (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id));\n+        check (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id));\n         lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id));\n     } else {\n         // External reference.\n@@ -4038,7 +4038,7 @@ fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n     alt (lcx.ccx.discrims.find(vid)) {\n         case (none[ValueRef]) {\n             // It's an external discriminant that we haven't seen yet.\n-            assert (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n+            check (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n             auto sym = creader.get_symbol(lcx.ccx.sess, vid);\n             auto gvar = llvm.LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n                                            _str.buf(sym));\n@@ -4060,7 +4060,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 case (ast.def_arg(?did)) {\n                     alt (cx.fcx.llargs.find(did)) {\n                         case (none[ValueRef]) {\n-                            assert (cx.fcx.llupvars.contains_key(did));\n+                            check (cx.fcx.llupvars.contains_key(did));\n                             ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                         }\n                         case (some[ValueRef](?llval)) {\n@@ -4071,7 +4071,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 case (ast.def_local(?did)) {\n                     alt (cx.fcx.lllocals.find(did)) {\n                         case (none[ValueRef]) {\n-                            assert (cx.fcx.llupvars.contains_key(did));\n+                            check (cx.fcx.llupvars.contains_key(did));\n                             ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                         }\n                         case (some[ValueRef](?llval)) {\n@@ -4080,11 +4080,11 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     }\n                 }\n                 case (ast.def_binding(?did)) {\n-                    assert (cx.fcx.lllocals.contains_key(did));\n+                    check (cx.fcx.lllocals.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.lllocals.get(did));\n                 }\n                 case (ast.def_obj_field(?did)) {\n-                    assert (cx.fcx.llobjfields.contains_key(did));\n+                    check (cx.fcx.llobjfields.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n@@ -4136,7 +4136,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_const(?did)) {\n                     // TODO: externals\n-                    assert (cx.fcx.lcx.ccx.consts.contains_key(did));\n+                    check (cx.fcx.lcx.ccx.consts.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n                 }\n                 case (ast.def_native_fn(?did)) {\n@@ -4275,7 +4275,7 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n             ret trans_index(cx, e.span, base, idx, ann);\n         }\n         case (ast.expr_unary(?unop, ?base, ?ann)) {\n-            assert (unop == ast.deref);\n+            check (unop == ast.deref);\n \n             auto sub = trans_expr(cx, base);\n             auto val = sub.bcx.build.GEP(sub.val,\n@@ -4439,7 +4439,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                     }\n                 } else if (ty.type_contains_params(cx.ccx.tcx,\n                                                    out_arg.ty)) {\n-                    assert (out_arg.mode == ast.alias);\n+                    check (out_arg.mode == ast.alias);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n \n@@ -4452,7 +4452,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n \n                 if (ty.type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n-                    assert (out_arg.mode == ast.alias);\n+                    check (out_arg.mode == ast.alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n                 }\n@@ -5142,7 +5142,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n         case (ast.expr_assign(?dst, ?src, ?ann)) {\n             auto lhs_res = trans_lval(cx, dst);\n-            assert (lhs_res.is_mem);\n+            check (lhs_res.is_mem);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n@@ -5153,7 +5153,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         case (ast.expr_assign_op(?op, ?dst, ?src, ?ann)) {\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n-            assert (lhs_res.is_mem);\n+            check (lhs_res.is_mem);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             if (ty.type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n                 alt (op) {\n@@ -5210,11 +5210,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_log(lvl, cx, a);\n         }\n \n-        case (ast.expr_assert(?a, _)) {\n-            ret trans_check_expr(cx, a);\n-        }\n-\n-        case (ast.expr_check(?a, _)) {\n+        case (ast.expr_check_expr(?a, _)) {\n             ret trans_check_expr(cx, a);\n         }\n \n@@ -5535,7 +5531,7 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n fn trans_be(@block_ctxt cx, @ast.expr e) -> result {\n     // FIXME: This should be a typestate precondition\n-    assert (ast.is_call_expr(e));\n+    check (ast.is_call_expr(e));\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n     ret trans_ret(cx, some(e));\n@@ -5631,7 +5627,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     auto bcx = cx;\n     auto data = trans_lval(bcx, lhs);\n-    assert (data.is_mem);\n+    check (data.is_mem);\n     bcx = data.res.bcx;\n     auto unit_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n \n@@ -5663,7 +5659,7 @@ fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n fn init_local(@block_ctxt cx, @ast.local local) -> result {\n \n     // Make a note to drop this slot on the way out.\n-    assert (cx.fcx.lllocals.contains_key(local.id));\n+    check (cx.fcx.lllocals.contains_key(local.id));\n     auto llptr = cx.fcx.lllocals.get(local.id);\n     auto ty = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n     auto bcx = cx;\n@@ -5779,7 +5775,7 @@ fn trans_block_cleanups(@block_ctxt cx,\n     auto bcx = cx;\n \n     if (cleanup_cx.kind == NON_SCOPE_BLOCK) {\n-        assert (_vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n+        check (_vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n     }\n \n     auto i = _vec.len[cleanup](cleanup_cx.cleanups);\n@@ -6000,7 +5996,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n             auto i = 0u;\n             for (ast.ty_param tp in ty_params) {\n                 auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-                assert (llarg as int != 0);\n+                check (llarg as int != 0);\n                 cx.lltydescs += vec(llarg);\n                 arg_n += 1u;\n                 i += 1u;\n@@ -6010,14 +6006,14 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n \n     if (proto == ast.proto_iter) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-        assert (llarg as int != 0);\n+        check (llarg as int != 0);\n         cx.lliterbody = some[ValueRef](llarg);\n         arg_n += 1u;\n     }\n \n     for (ast.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-        assert (llarg as int != 0);\n+        check (llarg as int != 0);\n         cx.llargs.insert(arg.id, llarg);\n         arg_n += 1u;\n     }\n@@ -6455,7 +6451,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n                            id=varg.id));\n     }\n \n-    assert (cx.ccx.item_ids.contains_key(variant.node.id));\n+    check (cx.ccx.item_ids.contains_key(variant.node.id));\n     let ValueRef llfndecl = cx.ccx.item_ids.get(variant.node.id);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n@@ -6722,7 +6718,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n             for each (uint i in _uint.range(0u, num_ty_param)) {\n                 auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n                 fcx.lltydescs += vec(llarg);\n-                assert (llarg as int != 0);\n+                check (llarg as int != 0);\n                 call_args += vec(vp2i(bcx, llarg));\n                 arg_n += 1u;\n             }\n@@ -6788,7 +6784,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n \n         for (ty.arg arg in args) {\n             auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n-            assert (llarg as int != 0);\n+            check (llarg as int != 0);\n             push_arg(bcx, call_args, llarg, arg.ty, arg.mode);\n             if (arg.mode == ast.val) {\n                 drop_args += vec(tup(llarg, arg.ty));"}, {"sha": "83befefc701227145c761afd283235c7adf19e88", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 67, "deletions": 120, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -895,7 +895,7 @@ fn type_is_tup_like(ctxt cx, t ty) -> bool {\n }\n \n fn get_element_type(ctxt cx, t ty, uint i) -> t {\n-    assert (type_is_tup_like(cx, ty));\n+    check (type_is_tup_like(cx, ty));\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             ret mts.(i).ty;\n@@ -1785,117 +1785,50 @@ fn pat_ty(ctxt cx, @ast.pat pat) -> t {\n     fail;   // not reached\n }\n \n-fn expr_ann(&@ast.expr e) -> ast.ann {\n-    alt(e.node) {\n-        case (ast.expr_vec(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_tup(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_rec(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_call(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_bind(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_binary(_,_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_unary(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_lit(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_cast(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_if(_,_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_while(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_for(_,_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_for_each(_,_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_do_while(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_alt(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_block(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_assign(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_assign_op(_,_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_send(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_recv(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_field(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_index(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_path(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_ext(_,_,_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_fail(?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_ret(_,?a)) {\n-            ret a; \n-        }\n-        case (ast.expr_put(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_be(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_log(_,_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_assert(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_check(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_port(?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_chan(_,?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_break(?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_cont(?a)) {\n-            ret a;\n-        }\n-        case (ast.expr_self_method(_, ?a)) {\n-            ret a;\n-        }\n+fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n+    alt (expr.node) {\n+        case (ast.expr_vec(_, _, ?ann))       { ret some[ast.ann](ann); }\n+        case (ast.expr_tup(_, ?ann))          { ret some[ast.ann](ann); }\n+        case (ast.expr_rec(_, _, ?ann))       { ret some[ast.ann](ann); }\n+        case (ast.expr_bind(_, _, ?ann))      { ret some[ast.ann](ann); }\n+        case (ast.expr_call(_, _, ?ann))      { ret some[ast.ann](ann); }\n+        case (ast.expr_self_method(_, ?ann))  { ret some[ast.ann](ann); }\n+        case (ast.expr_spawn(_, _, _, _, ?ann))\n+                                              { ret some[ast.ann](ann); }\n+        case (ast.expr_binary(_, _, _, ?ann)) { ret some[ast.ann](ann); }\n+        case (ast.expr_unary(_, _, ?ann))     { ret some[ast.ann](ann); }\n+        case (ast.expr_lit(_, ?ann))          { ret some[ast.ann](ann); }\n+        case (ast.expr_cast(_, _, ?ann))      { ret some[ast.ann](ann); }\n+        case (ast.expr_if(_, _, _, ?ann))     { ret some[ast.ann](ann); }\n+        case (ast.expr_for(_, _, _, ?ann))    { ret some[ast.ann](ann); }\n+        case (ast.expr_for_each(_, _, _, ?ann))\n+                                              { ret some[ast.ann](ann); }\n+        case (ast.expr_while(_, _, ?ann))     { ret some[ast.ann](ann); }\n+        case (ast.expr_do_while(_, _, ?ann))  { ret some[ast.ann](ann); }\n+        case (ast.expr_alt(_, _, ?ann))       { ret some[ast.ann](ann); }\n+        case (ast.expr_block(_, ?ann))        { ret some[ast.ann](ann); }\n+        case (ast.expr_assign(_, _, ?ann))    { ret some[ast.ann](ann); }\n+        case (ast.expr_assign_op(_, _, _, ?ann))\n+                                              { ret some[ast.ann](ann); }\n+        case (ast.expr_field(_, _, ?ann))     { ret some[ast.ann](ann); }\n+        case (ast.expr_index(_, _, ?ann))     { ret some[ast.ann](ann); }\n+        case (ast.expr_path(_, _, ?ann))      { ret some[ast.ann](ann); }\n+        case (ast.expr_ext(_, _, _, _, ?ann)) { ret some[ast.ann](ann); }\n+        case (ast.expr_port(?ann))            { ret some[ast.ann](ann); }\n+        case (ast.expr_chan(_, ?ann))         { ret some[ast.ann](ann); }\n+        case (ast.expr_send(_, _, ?ann))      { ret some[ast.ann](ann); }\n+        case (ast.expr_recv(_, _, ?ann))      { ret some[ast.ann](ann); }\n+\n+        case (ast.expr_fail(_))               { ret none[ast.ann]; }\n+        case (ast.expr_break(_))              { ret none[ast.ann]; }\n+        case (ast.expr_cont(_))               { ret none[ast.ann]; }\n+        case (ast.expr_log(_,_,_))            { ret none[ast.ann]; }\n+        case (ast.expr_check_expr(_,_))       { ret none[ast.ann]; }\n+        case (ast.expr_ret(_,_))              { ret none[ast.ann]; }\n+        case (ast.expr_put(_,_))              { ret none[ast.ann]; }\n+        case (ast.expr_be(_,_))               { ret none[ast.ann]; }\n     }\n+    fail;\n }\n \n // Returns the type of an expression as a monotype.\n@@ -1905,21 +1838,35 @@ fn expr_ann(&@ast.expr e) -> ast.ann {\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n fn expr_ty(ctxt cx, @ast.expr expr) -> t {\n-    { ret ann_to_monotype(cx, expr_ann(expr)); }\n+    alt (expr_ann(expr)) {\n+        case (none[ast.ann])     { ret mk_nil(cx); }\n+        case (some[ast.ann](?a)) { ret ann_to_monotype(cx, a); }\n+    }\n }\n \n fn expr_ty_params_and_ty(ctxt cx, @ast.expr expr) -> tup(vec[t], t) {\n-    auto a = expr_ann(expr);\n-\n-    ret tup(ann_to_type_params(a), ann_to_type(a));\n+    alt (expr_ann(expr)) {\n+        case (none[ast.ann]) {\n+            let vec[t] tps = vec();\n+            ret tup(tps, mk_nil(cx));\n+        }\n+        case (some[ast.ann](?a)) {\n+            ret tup(ann_to_type_params(a), ann_to_type(a));\n+        }\n+    }\n }\n \n fn expr_has_ty_params(@ast.expr expr) -> bool {\n     // FIXME: Rewrite using complex patterns when they're trustworthy.\n     alt (expr_ann(expr)) {\n-        case (ast.ann_none) { fail; }\n-        case (ast.ann_type(_, ?tps_opt, _)) {\n-            ret !option.is_none[vec[t]](tps_opt);\n+        case (none[ast.ann]) { fail; }\n+        case (some[ast.ann](?a)) {\n+            alt (a) {\n+                case (ast.ann_none) { fail; }\n+                case (ast.ann_type(_, ?tps_opt, _)) {\n+                    ret !option.is_none[vec[t]](tps_opt);\n+                }\n+            }\n         }\n     }\n }\n@@ -2286,7 +2233,7 @@ mod Unify {\n                         if (actual_n < vlen) {\n                             cx.types.(actual_n) += vec(expected);\n                         } else {\n-                            assert (actual_n == vlen);\n+                            check (actual_n == vlen);\n                             cx.types += vec(mutable vec(expected));\n                         }\n                     }\n@@ -2654,7 +2601,7 @@ mod Unify {\n                 if (expected_n < vlen) {\n                     cx.types.(expected_n) += vec(actual);\n                 } else {\n-                    assert (expected_n == vlen);\n+                    check (expected_n == vlen);\n                     cx.types += vec(mutable vec(actual));\n                 }\n                 ret ures_ok(expected);"}, {"sha": "3354fe46ad96390445045a3c2f04b7d7103546fd", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -110,7 +110,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n         -> ty_param_count_and_ty {\n     alt (defn) {\n         case (ast.def_arg(?id)) {\n-            // assert (fcx.locals.contains_key(id));\n+            // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_local(?id)) {\n@@ -122,7 +122,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n             ret tup(0u, t);\n         }\n         case (ast.def_obj_field(?id)) {\n-            // assert (fcx.locals.contains_key(id));\n+            // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n@@ -142,7 +142,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n                                     fcx.ccx.type_cache, vid);\n         }\n         case (ast.def_binding(?id)) {\n-            // assert (fcx.locals.contains_key(id));\n+            // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n@@ -298,7 +298,7 @@ fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n-            assert (def != none[ast.def]);\n+            check (def != none[ast.def]);\n             alt (option.get[ast.def](def)) {\n                 case (ast.def_ty(?id)) {\n                     typ = instantiate(tcx, getter, id, path.node.types);\n@@ -411,7 +411,7 @@ mod Collect {\n             ret creader.get_type(cx.sess, cx.tcx, id);\n         }\n \n-        // assert (cx.id_to_ty_item.contains_key(id));\n+        // check (cx.id_to_ty_item.contains_key(id));\n \n         auto it = cx.id_to_ty_item.get(id);\n         auto tpt;\n@@ -672,7 +672,7 @@ mod Collect {\n     fn fold_item_const(&@env e, &span sp, ast.ident i,\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n-        // assert (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -681,7 +681,7 @@ mod Collect {\n     fn fold_item_fn(&@env e, &span sp, ast.ident i,\n                     &ast._fn f, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        // assert (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -690,7 +690,7 @@ mod Collect {\n     fn fold_native_item_fn(&@env e, &span sp, ast.ident i, option.t[str] ln,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n-        // assert (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n                                        triv_ann(typ));\n@@ -721,7 +721,7 @@ mod Collect {\n     fn fold_item_obj(&@env e, &span sp, ast.ident i,\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n                     ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n-        // assert (e.cx.type_cache.contains_key(odid.ctor));\n+        // check (e.cx.type_cache.contains_key(odid.ctor));\n         auto t = e.cx.type_cache.get(odid.ctor)._1;\n         let vec[method] meth_tys = get_ctor_obj_methods(e, t);\n         let vec[@ast.method] methods = vec();\n@@ -777,7 +777,7 @@ mod Collect {\n     fn fold_item_ty(&@env e, &span sp, ast.ident i,\n                     @ast.ty t, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        // assert (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -1214,7 +1214,7 @@ mod Pushdown {\n                             case (none[@ast.expr]) {\n                                 auto i = 0u;\n                                 for (ast.field field_0 in fields_0) {\n-                                    assert (_str.eq(field_0.ident,\n+                                    check (_str.eq(field_0.ident,\n                                                    field_mts.(i).ident));\n                                     auto e_1 =\n                                         pushdown_expr(fcx,\n@@ -1409,8 +1409,7 @@ mod Pushdown {\n             case (ast.expr_ret(_,_)) { e_1 = e.node; }\n             case (ast.expr_put(_,_)) { e_1 = e.node; }\n             case (ast.expr_be(_,_))  { e_1 = e.node; }\n-            case (ast.expr_check(_,_)) { e_1 = e.node; }\n-            case (ast.expr_assert(_,_)) { e_1 = e.node; }\n+            case (ast.expr_check_expr(_,_)) { e_1 = e.node; }\n \n             case (ast.expr_port(?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n@@ -1840,7 +1839,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = ty.mk_nil(fcx.ccx.tcx);\n-            assert (defopt != none[ast.def]);\n+            check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n \n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n@@ -1940,7 +1939,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_be(?e, _)) {\n             /* FIXME: prove instead of check */\n-            assert (ast.is_call_expr(e));\n+            check (ast.is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -1954,25 +1953,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                          plain_ann(fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_check(?e, _)) {\n-            /* FIXME */\n-        /* presumably, here is where we should check that e is\n-         actually a call to a predicate, where all the arguments\n-        are literals or slot variables? */\n+        case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n             Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n                           expr_ty(fcx.ccx.tcx, expr_t));\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_check(expr_t,\n-                                                plain_ann(fcx.ccx.tcx)));\n-        }\n-\n-        case (ast.expr_assert(?e, _)) {\n-            auto expr_t = check_expr(fcx, e);\n-            Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n-                          expr_ty(fcx.ccx.tcx, expr_t));\n-            ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_assert(expr_t,\n+                (expr.span, ast.expr_check_expr(expr_t,\n                                                 plain_ann(fcx.ccx.tcx)));\n         }\n "}, {"sha": "d08ae82d603d71e1ff8883e4524669fe04989af9", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 254, "deletions": 152, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -55,8 +55,7 @@ import front.ast.expr_put;\n import front.ast.expr_port;\n import front.ast.expr_chan;\n import front.ast.expr_be;\n-import front.ast.expr_check;\n-import front.ast.expr_assert;\n+import front.ast.expr_check_expr;\n import front.ast.expr_cast;\n import front.ast.expr_for;\n import front.ast.expr_for_each;\n@@ -148,7 +147,8 @@ import util.typestate_ann.clone;\n import middle.ty;\n import middle.ty.ann_to_type;\n import middle.ty.arg;\n-import middle.ty.expr_ann;\n+import middle.ty.block_ty;\n+import middle.ty.expr_ty;\n import middle.ty.ty_to_str;\n \n import pretty.pprust.print_block;\n@@ -293,11 +293,11 @@ type fn_info      = std.map.hashmap[def_id, var_info];\n type fn_info_map = std.map.hashmap[def_id, fn_info];\n  \n fn bit_num(def_id v, fn_info m) -> uint {\n-  assert (m.contains_key(v));\n+  check (m.contains_key(v));\n   ret m.get(v)._0;\n }\n fn get_fn_info(fn_info_map fm, def_id did) -> fn_info {\n-    assert (fm.contains_key(did));\n+    check (fm.contains_key(did));\n     ret fm.get(did);\n }\n \n@@ -389,6 +389,116 @@ fn mk_f_to_fn_info(@ast.crate c) -> fn_info_map {\n   ret res;\n }\n /**** Helpers ****/\n+fn expr_ann(&expr e) -> ann {\n+  alt(e.node) {\n+    case (ast.expr_vec(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_tup(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_rec(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_call(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_bind(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_binary(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_unary(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_lit(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_cast(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_if(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_while(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_for(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_for_each(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_do_while(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_alt(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_block(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_assign(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_assign_op(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_send(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_recv(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_field(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_index(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_path(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_ext(_,_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_fail(?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_ret(_,?a)) {\n+      ret a; \n+    }\n+    case (ast.expr_put(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_be(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_log(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_check_expr(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_port(?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_chan(_,?a)) {\n+      ret a;\n+    }\n+    case (expr_break(?a)) {\n+        ret a;\n+    }\n+    case (expr_cont(?a)) {\n+        ret a;\n+    }\n+    case (expr_self_method(_, ?a)) {\n+        ret a;\n+    }\n+  }\n+}\n+\n fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n   alt (a) {\n     case (ann_none)         { ret empty_ann(nv); }\n@@ -422,7 +532,7 @@ fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n           fail;\n       }\n       case (ann_type(_,_,?t)) {\n-          assert (! is_none[@ts_ann](t));\n+          check (! is_none[@ts_ann](t));\n           ret get[@ts_ann](t);\n       }\n   }\n@@ -447,7 +557,7 @@ fn stmt_to_ann(&stmt s) -> option.t[@ts_ann] {\n }\n \n /* fails if e has no annotation */\n-fn expr_states(@expr e) -> pre_and_post_state {\n+fn expr_states(&expr e) -> pre_and_post_state {\n   alt (expr_ann(e)) {\n     case (ann_none) {\n       log_err \"expr_pp: the impossible happened (no annotation)\";\n@@ -468,7 +578,7 @@ fn expr_states(@expr e) -> pre_and_post_state {\n }\n \n /* fails if e has no annotation */\n-fn expr_pp(@expr e) -> pre_and_post {\n+fn expr_pp(&expr e) -> pre_and_post {\n   alt (expr_ann(e)) {\n     case (ann_none) {\n       log_err \"expr_pp: the impossible happened (no annotation)\";\n@@ -554,19 +664,19 @@ fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n }\n \n \n-fn expr_precond(@expr e) -> precond {\n+fn expr_precond(&expr e) -> precond {\n   ret (expr_pp(e)).precondition;\n }\n \n-fn expr_postcond(@expr e) -> postcond {\n+fn expr_postcond(&expr e) -> postcond {\n   ret (expr_pp(e)).postcondition;\n }\n \n-fn expr_prestate(@expr e) -> prestate {\n+fn expr_prestate(&expr e) -> prestate {\n   ret (expr_states(e)).prestate;\n }\n \n-fn expr_poststate(@expr e) -> poststate {\n+fn expr_poststate(&expr e) -> poststate {\n   ret (expr_states(e)).poststate;\n }\n \n@@ -627,7 +737,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n \n   if (sz >= 1u) {\n     auto first   = pps.(0);\n-    assert (pps_len(first) == num_vars);\n+    check (pps_len(first) == num_vars);\n     let precond rest = seq_preconds(enclosing,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n@@ -687,7 +797,7 @@ fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n }\n \n fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n-  assert (len[postcond](pcs) > 0u);\n+  check (len[postcond](pcs) > 0u);\n \n   ret intersect_postconds_go(bitv.clone(pcs.(0)), pcs);\n }\n@@ -716,7 +826,7 @@ fn find_pre_post_state_native_mod(&native_mod m) -> bool {\n  \n fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n     fn do_a_method(fn_info_map fm, &@method m) -> () {\n-        assert (fm.contains_key(m.node.id));\n+        check(fm.contains_key(m.node.id));\n         find_pre_post_fn(fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(fm,_);\n@@ -726,7 +836,7 @@ fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n \n fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n     fn do_a_method(fn_info_map fm, &@method m) -> bool {\n-        assert (fm.contains_key(m.node.id));\n+        check(fm.contains_key(m.node.id));\n         ret find_pre_post_state_fn(fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(fm,_);\n@@ -739,10 +849,10 @@ fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n-        find_pre_post_expr(fm, enclosing, e);\n+        find_pre_post_expr(fm, enclosing, *e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      assert (fm.contains_key(di));\n+      check (fm.contains_key(di));\n       find_pre_post_fn(fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n@@ -773,14 +883,14 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n \n     fn do_one(fn_info_map fm, fn_info enclosing,\n               &@expr e) -> () {\n-        find_pre_post_expr(fm, enclosing, e);\n+        find_pre_post_expr(fm, enclosing, *e);\n     }\n     auto f = bind do_one(fm, enclosing, _);\n \n     _vec.map[@expr, ()](f, args);\n \n     fn get_pp(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n+        ret expr_pp(*e);\n     }\n     auto g = get_pp;\n     auto pps = _vec.map[@expr, pre_and_post](g, args);\n@@ -794,31 +904,31 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n \n fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n      &@expr index, &block body, &ann a) -> () {\n-    find_pre_post_expr(fm, enclosing, index);\n+    find_pre_post_expr(fm, enclosing, *index);\n     find_pre_post_block(fm, enclosing, body);\n     auto loop_precond = declare_var(enclosing, decl_lhs(d),\n-           seq_preconds(enclosing, vec(expr_pp(index),\n-                                       block_pp(body))));\n+           seq_preconds(enclosing, vec(expr_pp(*index),\n+                                                   block_pp(body))));\n     auto loop_postcond = intersect_postconds\n-        (vec(expr_postcond(index), block_postcond(body)));\n+        (vec(expr_postcond(*index), block_postcond(body)));\n     set_pre_and_post(a, rec(precondition=loop_precond,\n                             postcondition=loop_postcond));\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n+fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n     auto num_local_vars = num_locals(enclosing);\n \n     fn do_rand_(fn_info_map fm, fn_info enclosing, &@expr e) -> () {\n-        find_pre_post_expr(fm, enclosing, e);\n+        find_pre_post_expr(fm, enclosing, *e);\n     }\n     fn pp_one(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n+        ret expr_pp(*e);\n     }\n     \n         log(\"find_pre_post_expr (num_locals =\" +\n              uistr(num_local_vars) + \"):\");\n-        log_expr(*e);\n+        log_expr(e);\n     \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n@@ -864,18 +974,18 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case(expr_log(_, ?arg, ?a)) {\n-            find_pre_post_expr(fm, enclosing, arg);\n-            set_pre_and_post(a, expr_pp(arg));\n+            find_pre_post_expr(fm, enclosing, *arg);\n+            set_pre_and_post(a, expr_pp(*arg));\n         }\n         case (expr_chan(?arg, ?a)) {\n-            find_pre_post_expr(fm, enclosing, arg);\n-            set_pre_and_post(a, expr_pp(arg));\n+            find_pre_post_expr(fm, enclosing, *arg);\n+            set_pre_and_post(a, expr_pp(*arg));\n         }\n         case(expr_put(?opt, ?a)) {\n             alt (opt) {\n                 case (some[@expr](?arg)) {\n-                    find_pre_post_expr(fm, enclosing, arg);\n-                    set_pre_and_post(a, expr_pp(arg));\n+                    find_pre_post_expr(fm, enclosing, *arg);\n+                    set_pre_and_post(a, expr_pp(*arg));\n                 }\n                 case (none[@expr]) {\n                     set_pre_and_post(a, empty_pre_post(num_local_vars));\n@@ -894,10 +1004,10 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, rhs);\n-                    set_pre_and_post(a, expr_pp(rhs));\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    set_pre_and_post(a, expr_pp(*rhs));\n                     log(\"gen:\");\n-                    log_expr(*e);\n+                    log_expr(e);\n                     gen(enclosing, a, d_id);\n                 }\n                 case (_) {\n@@ -910,10 +1020,10 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, rhs);\n-                    set_pre_and_post(a, expr_pp(rhs));\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    set_pre_and_post(a, expr_pp(*rhs));\n                     log(\"gen:\");\n-                    log_expr(*e);\n+                    log_expr(e);\n                     gen(enclosing, a, d_id);\n                 }\n                 case (_) {\n@@ -939,45 +1049,45 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                           postcondition=false_postcond(num_local_vars)));\n                 }\n                 case (some[@expr](?ret_val)) {\n-                    find_pre_post_expr(fm, enclosing, ret_val);\n+                    find_pre_post_expr(fm, enclosing, *ret_val);\n                     let pre_and_post pp =\n-                        rec(precondition=expr_precond(ret_val),\n+                        rec(precondition=expr_precond(*ret_val),\n                             postcondition=false_postcond(num_local_vars));\n                     set_pre_and_post(a, pp);\n                 }\n             }\n         }\n         case (expr_be(?e, ?a)) {\n-            find_pre_post_expr(fm, enclosing, e);\n-            set_pre_and_post(a, rec(precondition=expr_prestate(e),\n+            find_pre_post_expr(fm, enclosing, *e);\n+            set_pre_and_post(a, rec(precondition=expr_prestate(*e),\n                           postcondition=false_postcond(num_local_vars)));\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            find_pre_post_expr(fm, enclosing, antec);\n+            find_pre_post_expr(fm, enclosing, *antec);\n             find_pre_post_block(fm, enclosing, conseq);\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n                     auto precond_res = seq_preconds(enclosing,\n-                                                    vec(expr_pp(antec),\n+                                                    vec(expr_pp(*antec),\n                                                         block_pp(conseq)));\n                     set_pre_and_post(a, rec(precondition=precond_res,\n                                             postcondition=\n-                                            expr_poststate(antec)));\n+                                            expr_poststate(*antec)));\n                 }\n                 case (some[@expr](?altern)) {\n-                    find_pre_post_expr(fm, enclosing, altern);\n+                    find_pre_post_expr(fm, enclosing, *altern);\n                     auto precond_true_case =\n                         seq_preconds(enclosing,\n-                                     vec(expr_pp(antec), block_pp(conseq)));\n+                                     vec(expr_pp(*antec), block_pp(conseq)));\n                     auto postcond_true_case = union_postconds\n                         (num_local_vars,\n-                         vec(expr_postcond(antec), block_postcond(conseq)));\n+                         vec(expr_postcond(*antec), block_postcond(conseq)));\n                     auto precond_false_case = seq_preconds\n                         (enclosing,\n-                         vec(expr_pp(antec), expr_pp(altern)));\n+                         vec(expr_pp(*antec), expr_pp(*altern)));\n                     auto postcond_false_case = union_postconds\n                         (num_local_vars,\n-                         vec(expr_postcond(antec), expr_postcond(altern)));\n+                         vec(expr_postcond(*antec), expr_postcond(*altern)));\n                     auto precond_res = union_postconds\n                         (num_local_vars,\n                          vec(precond_true_case, precond_false_case));\n@@ -997,31 +1107,31 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n         }\n         case (expr_unary(_,?operand,?a)) {\n-            find_pre_post_expr(fm, enclosing, operand);\n-            set_pre_and_post(a, expr_pp(operand));\n+            find_pre_post_expr(fm, enclosing, *operand);\n+            set_pre_and_post(a, expr_pp(*operand));\n         }\n         case (expr_cast(?operand, _, ?a)) {\n-            find_pre_post_expr(fm, enclosing, operand);\n-            set_pre_and_post(a, expr_pp(operand));\n+            find_pre_post_expr(fm, enclosing, *operand);\n+            set_pre_and_post(a, expr_pp(*operand));\n         }\n         case (expr_while(?test, ?body, ?a)) {\n-            find_pre_post_expr(fm, enclosing, test);\n+            find_pre_post_expr(fm, enclosing, *test);\n             find_pre_post_block(fm, enclosing, body);\n             set_pre_and_post(a,\n               rec(precondition=\n                   seq_preconds(enclosing,\n-                                 vec(expr_pp(test), \n+                                 vec(expr_pp(*test), \n                                      block_pp(body))),\n                   postcondition=\n-                  intersect_postconds(vec(expr_postcond(test),\n+                  intersect_postconds(vec(expr_postcond(*test),\n                                           block_postcond(body)))));\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n             find_pre_post_block(fm, enclosing, body);\n-            find_pre_post_expr(fm, enclosing, test);\n+            find_pre_post_expr(fm, enclosing, *test);\n    \n             auto loop_postcond = union_postconds(num_local_vars,\n-                            vec(block_postcond(body), expr_postcond(test)));\n+                            vec(block_postcond(body), expr_postcond(*test)));\n             /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n             if (has_nonlocal_exits(body)) {\n@@ -1031,7 +1141,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, \n                              rec(precondition=seq_preconds(enclosing,\n                                              vec(block_pp(body),\n-                                                 expr_pp(test))),\n+                                                 expr_pp(*test))),\n                    postcondition=loop_postcond));\n         }\n         case (expr_for(?d, ?index, ?body, ?a)) {\n@@ -1044,7 +1154,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             find_pre_post_exprs(fm, enclosing, vec(e, sub), a);\n         }\n         case (expr_alt(?e, ?alts, ?a)) {\n-            find_pre_post_expr(fm, enclosing, e);\n+            find_pre_post_expr(fm, enclosing, *e);\n             fn do_an_alt(fn_info_map fm, fn_info enc, &arm an_alt)\n                 -> pre_and_post {\n                 find_pre_post_block(fm, enc, an_alt.block);\n@@ -1060,7 +1170,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n-            auto antec_pp = pp_clone(expr_pp(e)); \n+            auto antec_pp = pp_clone(expr_pp(*e)); \n             auto e_pp  = rec(precondition=empty_prestate(num_local_vars),\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, enclosing, _, _);\n@@ -1071,8 +1181,8 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, alts_overall_pp);\n         }\n         case (expr_field(?operator, _, ?a)) {\n-            find_pre_post_expr(fm, enclosing, operator);\n-            set_pre_and_post(a, expr_pp(operator));\n+            find_pre_post_expr(fm, enclosing, *operator);\n+            set_pre_and_post(a, expr_pp(*operator));\n         }\n         case (expr_fail(?a)) {\n             set_pre_and_post(a,\n@@ -1081,14 +1191,10 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                rec(precondition=empty_prestate(num_local_vars),\n                    postcondition=false_postcond(num_local_vars)));\n         }\n-        case (expr_assert(?p, ?a)) {\n-            find_pre_post_expr(fm, enclosing, p);\n-            set_pre_and_post(a, expr_pp(p));\n-        }\n-        case (expr_check(?p, ?a)) {\n+        case (expr_check_expr(?p, ?a)) {\n             /* will need to change when we support arbitrary predicates... */\n-            find_pre_post_expr(fm, enclosing, p);\n-            set_pre_and_post(a, expr_pp(p));\n+            find_pre_post_expr(fm, enclosing, *p);\n+            set_pre_and_post(a, expr_pp(*p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = _vec.cat_options[@expr](maybe_args);\n@@ -1105,29 +1211,29 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case (expr_ext(_, _, _, ?expanded, ?a)) {\n-            find_pre_post_expr(fm, enclosing, expanded);\n-            set_pre_and_post(a, expr_pp(expanded));\n+            find_pre_post_expr(fm, enclosing, *expanded);\n+            set_pre_and_post(a, expr_pp(*expanded));\n         }\n     }\n }\n \n fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n-  assert (enclosing.contains_key(id));\n+  check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n   ret set_in_postcond(i, (ann_to_ts_ann_fail_more(a)).conditions);\n }\n \n fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n    -> prestate {\n-    assert (enclosing.contains_key(id));\n+    check(enclosing.contains_key(id));\n     let uint i = (enclosing.get(id))._0;\n     auto res = clone(pre);\n     relax_prestate(i, res);\n     ret res;\n }\n \n fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n-  assert (enclosing.contains_key(id));\n+  check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n \n   ret set_in_poststate(i, (ann_to_ts_ann_fail_more(a)).states);\n@@ -1145,8 +1251,8 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n             case(ast.decl_local(?alocal)) {\n                 alt(alocal.init) {\n                     case(some[ast.initializer](?an_init)) {\n-                        find_pre_post_expr(fm, enclosing, an_init.expr);\n-                        auto rhs_pp = expr_pp(an_init.expr);\n+                        find_pre_post_expr(fm, enclosing, *an_init.expr);\n+                        auto rhs_pp = expr_pp(*an_init.expr);\n                         set_pre_and_post(alocal.ann, rhs_pp);\n \n                         /* Inherit ann from initializer, and add var being\n@@ -1175,8 +1281,8 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n         }\n     }\n     case(stmt_expr(?e,?a)) {\n-        find_pre_post_expr(fm, enclosing, e);\n-        set_pre_and_post(a, expr_pp(e));\n+        find_pre_post_expr(fm, enclosing, *e);\n+        set_pre_and_post(a, expr_pp(*e));\n     }    \n   }\n }\n@@ -1212,7 +1318,7 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     \n     _vec.map[@stmt, ()](do_one, b.node.stmts);\n     fn do_inner_(fn_info_map fm, fn_info i, &@expr e) -> () {\n-        find_pre_post_expr(fm, i, e);\n+        find_pre_post_expr(fm, i, *e);\n     }\n     auto do_inner = bind do_inner_(fm, enclosing, _);\n     option.map[@expr, ()](do_inner, b.node.expr);\n@@ -1225,7 +1331,7 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     auto f = get_pp_stmt;\n     pps += _vec.map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n+        ret expr_pp(*e);\n     }\n     auto g = get_pp_expr;\n     plus_option[pre_and_post](pps,\n@@ -1257,7 +1363,7 @@ fn check_item_fn(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n     log(\"check_item_fn:\");\n     log_fn(f, i, ty_params);\n \n-  assert (fm.contains_key(id));\n+  check (fm.contains_key(id));\n   find_pre_post_fn(fm, fm.get(id), f);  \n \n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n@@ -1271,7 +1377,7 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n               empty_prestate(num_locals(enclosing)), e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      assert (fm.contains_key(di));\n+      check (fm.contains_key(di));\n       ret find_pre_post_state_fn(fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n@@ -1295,7 +1401,7 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n fn set_prestate_ann(@ann a, prestate pre) -> bool {\n   alt (*a) {\n     case (ann_type(_,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n+      check (! is_none[@ts_ann](ts_a));\n       ret set_prestate(get[@ts_ann](ts_a), pre);\n     }\n     case (ann_none) {\n@@ -1309,8 +1415,8 @@ fn set_prestate_ann(@ann a, prestate pre) -> bool {\n fn extend_prestate_ann(ann a, prestate pre) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n-      ret extend_prestate((get[@ts_ann](ts_a)).states.prestate, pre);\n+      check (! is_none[@ts_ann](ts_a));\n+      ret extend_prestate((*get[@ts_ann](ts_a)).states.prestate, pre);\n     }\n     case (ann_none) {\n       log(\"set_prestate_ann: expected an ann_type here\");\n@@ -1322,8 +1428,8 @@ fn extend_prestate_ann(ann a, prestate pre) -> bool {\n fn set_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n-      ret set_poststate(get[@ts_ann](ts_a), post);\n+      check (! is_none[@ts_ann](ts_a));\n+      ret set_poststate(*get[@ts_ann](ts_a), post);\n     }\n     case (ann_none) {\n       log(\"set_poststate_ann: expected an ann_type here\");\n@@ -1335,7 +1441,7 @@ fn set_poststate_ann(ann a, poststate post) -> bool {\n fn extend_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n+      check (! is_none[@ts_ann](ts_a));\n       ret extend_poststate((*get[@ts_ann](ts_a)).states.poststate, post);\n     }\n     case (ann_none) {\n@@ -1348,7 +1454,7 @@ fn extend_poststate_ann(ann a, poststate post) -> bool {\n fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n     alt (a) {\n         case (ann_type(_,_,?ts_a)) {\n-            assert (! is_none[@ts_ann](ts_a));\n+            check (! is_none[@ts_ann](ts_a));\n             auto t = *get[@ts_ann](ts_a);\n             /*  log(\"set_pre_and_post, old =\");\n             log_pp(t.conditions);\n@@ -1372,7 +1478,7 @@ fn seq_states(&fn_info_map fm, &fn_info enclosing,\n \n   for (@expr e in exprs) {\n     changed = find_pre_post_state_expr(fm, enclosing, post, e) || changed;\n-    post = expr_poststate(e);\n+    post = expr_poststate(*e);\n   }\n \n   ret tup(changed, post);\n@@ -1407,16 +1513,16 @@ fn find_pre_post_state_loop(fn_info_map fm, fn_info enclosing,\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n     changed = find_pre_post_state_block(fm, enclosing,\n-                expr_poststate(index), body) || changed;\n-    auto res_p = intersect_postconds(vec(expr_poststate(index),\n+                expr_poststate(*index), body) || changed;\n+    auto res_p = intersect_postconds(vec(expr_poststate(*index),\n                                          block_poststate(body)));\n   \n     changed = extend_poststate_ann(a, res_p) || changed;\n     ret changed;\n }\n \n fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n-                            &prestate pres, @expr e) -> bool {\n+                            &prestate pres, &@expr e) -> bool {\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n@@ -1434,20 +1540,20 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         || changed;\n       /* rands go left-to-right */\n       ret(find_pre_post_state_exprs(fm, enclosing,\n-                                    expr_poststate(operator), a, operands)\n+                                    expr_poststate(*operator), a, operands)\n           || changed);\n     }\n     case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operator);\n         ret(find_pre_post_state_exprs(fm, enclosing,\n-                 expr_poststate(operator), a, operands)\n+                 expr_poststate(*operator), a, operands)\n           || changed);\n     }\n     case (expr_bind(?operator, ?maybe_args, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n             || changed;\n         ret (find_pre_post_state_exprs(fm, enclosing,\n-          expr_poststate(operator), a, cat_options[@expr](maybe_args))\n+          expr_poststate(*operator), a, cat_options[@expr](maybe_args))\n             || changed);\n     }\n     case (expr_path(_,_,?a)) {\n@@ -1457,19 +1563,19 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         /* factor out the \"one exp\" pattern */\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n         ret changed;\n     }\n     case (expr_chan(?e, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n         ret changed;\n     }\n     case (expr_ext(_, _, _, ?expanded, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, expanded);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(expanded))\n+        changed = extend_poststate_ann(a, expr_poststate(*expanded))\n            || changed;\n         ret changed;\n     }\n@@ -1478,7 +1584,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n             case (some[@expr](?arg)) {\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, arg);\n                 changed = extend_prestate_ann(a, pres) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(arg))\n+                changed = extend_poststate_ann(a, expr_poststate(*arg))\n                     || changed;\n                 ret changed;\n             }\n@@ -1505,7 +1611,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n             case (some[@expr](?base)) {\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, base)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(base))\n+                changed = extend_poststate_ann(a, expr_poststate(*base))\n                     || changed;\n             }\n         }\n@@ -1520,7 +1626,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = pure_exp(a_lhs, pres) || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, d_id) || changed;\n             }\n@@ -1529,8 +1635,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n                     || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                     expr_poststate(*lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n                     || changed;\n             }\n         }\n@@ -1545,7 +1651,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = pure_exp(a_lhs, pres) || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, d_id) || changed;\n             }\n@@ -1554,8 +1660,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n                     || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                     expr_poststate(*lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n                     || changed;\n             }\n         }\n@@ -1585,17 +1691,17 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, antec)\n             || changed;\n         changed = find_pre_post_state_block(fm, enclosing,\n-          expr_poststate(antec), conseq) || changed;\n+          expr_poststate(*antec), conseq) || changed;\n         alt (maybe_alt) {\n             case (none[@expr]) {\n-                changed = extend_poststate_ann(a, expr_poststate(antec))\n+                changed = extend_poststate_ann(a, expr_poststate(*antec))\n                     || changed;\n             }\n             case (some[@expr](?altern)) {\n                 changed = find_pre_post_state_expr(fm, enclosing,\n-                   expr_poststate(antec), altern) || changed;\n+                   expr_poststate(*antec), altern) || changed;\n                 auto poststate_res = intersect_postconds\n-                    (vec(block_poststate(conseq), expr_poststate(altern)));\n+                    (vec(block_poststate(conseq), expr_poststate(*altern)));\n                 changed = extend_poststate_ann(a, poststate_res) || changed;\n             }\n         }\n@@ -1604,7 +1710,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         log(\"new prestate:\");\n         log_bitv(enclosing, pres);\n         log(\"new poststate:\");\n-        log_bitv(enclosing, expr_poststate(e));\n+        log_bitv(enclosing, expr_poststate(*e));\n \n         ret changed;\n     }\n@@ -1614,17 +1720,17 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n                     || changed;\n         changed = find_pre_post_state_expr(fm,\n-                    enclosing, expr_poststate(l), r) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n+                    enclosing, expr_poststate(*l), r) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n         ret changed;\n     }\n     case (expr_send(?l, ?r, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n                     || changed;\n         changed = find_pre_post_state_expr(fm,\n-                    enclosing, expr_poststate(l), r) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n+                    enclosing, expr_poststate(*l), r) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n         ret changed;\n     }\n     case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n@@ -1633,8 +1739,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n                     || changed;\n         changed = find_pre_post_state_expr(fm,\n-                    enclosing, expr_poststate(lhs), rhs) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n+                    enclosing, expr_poststate(*lhs), rhs) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*rhs)) || changed;\n         ret changed;\n     }\n     case (expr_while(?test, ?body, ?a)) {\n@@ -1650,9 +1756,9 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, test)\n             || changed;\n         changed = find_pre_post_state_block(fm, \n-                   enclosing, expr_poststate(test), body) || changed; \n+                   enclosing, expr_poststate(*test), body) || changed; \n         changed = extend_poststate_ann(a,\n-                    intersect_postconds(vec(expr_poststate(test),\n+                    intersect_postconds(vec(expr_poststate(*test),\n                                         block_poststate(body)))) || changed;\n         ret changed;\n     }\n@@ -1671,7 +1777,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n             changed = set_poststate_ann(a, pres) || changed;\n         }\n         else {\n-            changed = extend_poststate_ann(a, expr_poststate(test))\n+            changed = extend_poststate_ann(a, expr_poststate(*test))\n               || changed;\n         }\n \n@@ -1687,14 +1793,14 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = extend_prestate_ann(a, pres) || changed; \n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(e), sub) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(sub));\n+                     expr_poststate(*e), sub) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*sub));\n         ret changed;\n     }\n     case (expr_alt(?e, ?alts, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed; \n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-        auto e_post = expr_poststate(e);\n+        auto e_post = expr_poststate(*e);\n         auto a_post;\n         if (_vec.len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n@@ -1715,22 +1821,22 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     case (expr_field(?e,_,?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n         ret changed;\n     }\n     case (expr_unary(_,?operand,?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n           || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(operand))\n+        changed = extend_poststate_ann(a, expr_poststate(*operand))\n           || changed;\n         ret changed;\n     }\n     case (expr_cast(?operand, _, ?a)) {\n            changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n           || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(operand))\n+        changed = extend_poststate_ann(a, expr_poststate(*operand))\n           || changed;\n         ret changed;\n     }\n@@ -1739,15 +1845,14 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         /* if execution continues after fail, then everything is true! woo! */\n         changed = set_poststate_ann(a, false_postcond(num_local_vars))\n           || changed;\n+        /*        log_err(\"fail: poststate = \");\n+                  log_bitv(enclosing, expr_poststate(*e)); */\n         ret changed;\n     }\n-    case (expr_assert(?p, ?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-    case (expr_check(?p, ?a)) {\n+    case (expr_check_expr(?p, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing, pres, p) || changed;\n-        /* FIXME: update the postcondition to reflect that p holds */\n+        /* p is pure, so the poststate must be the same as the prestate */\n         changed = extend_poststate_ann(a, pres) || changed;\n         ret changed;\n     }\n@@ -1770,7 +1875,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @stmt s) -> bool {\n   auto changed = false;\n   auto stmt_ann_ = stmt_to_ann(*s);\n-  assert (!is_none[@ts_ann](stmt_ann_));\n+  check (!is_none[@ts_ann](stmt_ann_));\n   auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n               log(\"*At beginning: stmt = \");\n               log_stmt(*s);\n@@ -1792,7 +1897,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr\n                     (fm, enclosing, pres, an_init.expr) || changed;\n                 changed = extend_poststate(stmt_ann.states.poststate,\n-                                           expr_poststate(an_init.expr))\n+                                           expr_poststate(*an_init.expr))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, alocal.id) || changed;\n               log(\"Summary: stmt = \");\n@@ -1827,10 +1932,10 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n     }\n     case (stmt_expr(?e, _)) {\n       changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(e))\n+      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(*e))\n           || changed;\n       changed = extend_poststate(stmt_ann.states.poststate,\n-                                 expr_poststate(e)) || changed;\n+                                 expr_poststate(*e)) || changed;\n       /*\n                     log(\"Summary: stmt = \");\n               log_stmt(*s);\n@@ -1875,7 +1980,7 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n     case (none[@expr]) {}\n     case (some[@expr](?e)) {\n       changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-      post = expr_poststate(e);\n+      post = expr_poststate(*e);\n     }\n   }\n \n@@ -1933,13 +2038,13 @@ fn fixed_point_states(fn_info_map fm, fn_info f_info,\n   }\n }\n \n-fn check_states_expr(fn_info enclosing, @expr e) -> () {\n+fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let precond prec    = expr_precond(e);\n   let prestate pres   = expr_prestate(e);\n \n   if (!implies(pres, prec)) {\n       log_err(\"check_states_expr: Unsatisfied precondition constraint for \");\n-      log_expr_err(*e);\n+      log_expr_err(e);\n       log_err(\"Precondition: \");\n       log_bitv_err(enclosing, prec);\n       log_err(\"Prestate: \");\n@@ -1988,7 +2093,7 @@ fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n  \n   _vec.map[@stmt, ()](do_one, f.body.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> () {\n-    check_states_expr(i, e);\n+    check_states_expr(i, *e);\n   }\n   auto do_inner = bind do_inner_(enclosing, _);\n   option.map[@expr, ()](do_inner, f.body.node.expr);\n@@ -2011,7 +2116,7 @@ fn check_item_fn_state(&fn_info_map f_info_map, &span sp, ident i,\n                        ann a) -> @item {\n \n   /* Look up the var-to-bit-num map for this function */\n-  assert (f_info_map.contains_key(id));\n+  check(f_info_map.contains_key(id));\n   auto f_info = f_info_map.get(id);\n \n   check_fn_states(f_info_map, f_info, f);\n@@ -2021,7 +2126,7 @@ fn check_item_fn_state(&fn_info_map f_info_map, &span sp, ident i,\n }\n \n fn check_method_states(&fn_info_map f_info_map, @method m) -> () {\n-    assert (f_info_map.contains_key(m.node.id));\n+    check (f_info_map.contains_key(m.node.id));\n     auto f_info = f_info_map.get(m.node.id);\n     check_fn_states(f_info_map, f_info, m.node.meth);\n }\n@@ -2088,7 +2193,7 @@ fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n-    assert (fm.contains_key(id));\n+    check(fm.contains_key(id));\n     auto f_info = fm.get(id);\n \n     log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n@@ -2308,11 +2413,8 @@ fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n         case (expr_log(?n, ?e, ?a)) {\n             e1 = expr_log(n, annotate_expr(fm, e), a);\n         }\n-        case (expr_assert(?e, ?a)) {\n-            e1 = expr_assert(annotate_expr(fm, e), a);\n-        }\n-        case (expr_check(?e, ?a)) {\n-            e1 = expr_check(annotate_expr(fm, e), a);\n+        case (expr_check_expr(?e, ?a)) {\n+            e1 = expr_check_expr(annotate_expr(fm, e), a);\n         }\n         case (expr_port(_)) { /* no change */ }\n         case (expr_chan(?e, ?a)) {"}, {"sha": "dbc188b1d40661dfa8b3cabd57f5f91ffbaae781", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -392,10 +392,7 @@ fn walk_expr(&ast_visitor v, @ast.expr e) {\n         case (ast.expr_log(_,?x, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_check(?x, _)) {\n-            walk_expr(v, x);\n-        }\n-        case (ast.expr_assert(?x, _)) {\n+        case (ast.expr_check_expr(?x, _)) {\n             walk_expr(v, x);\n         }\n         case (ast.expr_port(_)) { }"}, {"sha": "e49ed34e948b1e9daf059139b4ff734596274105", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -661,18 +661,12 @@ fn print_expr(ps s, &@ast.expr expr) {\n             }\n             print_expr(s, expr);\n         }\n-        case (ast.expr_check(?expr,_)) {\n+        case (ast.expr_check_expr(?expr,_)) {\n             wrd1(s, \"check\");\n             popen_h(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast.expr_assert(?expr,_)) {\n-            wrd1(s, \"assert\");\n-            popen_h(s);\n-            print_expr(s, expr);\n-            pclose(s);\n-        }\n         case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n             wrd(s.s, \"#\");\n             print_path(s, path);"}, {"sha": "b7fbc3cc25d5858c2d00723756614c43f4b182b3", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -85,7 +85,7 @@ fn intersect(&precond p1, &precond p2) -> bool {\n \n fn pps_len(&pre_and_post p) -> uint {\n   // gratuitous check\n-  assert (p.precondition.nbits == p.postcondition.nbits);\n+  check (p.precondition.nbits == p.postcondition.nbits);\n   ret p.precondition.nbits;\n }\n \n@@ -129,7 +129,7 @@ fn set_prestate(@ts_ann a, &prestate p) -> bool {\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_poststate(@ts_ann a, &poststate p) -> bool {\n+fn set_poststate(&ts_ann a, &poststate p) -> bool {\n   ret bitv.copy(a.states.poststate, p);\n }\n "}, {"sha": "0d925d7d0249c20ac57c0834dff94bd185c05c97", "filename": "src/lib/Term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2FTerm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2FTerm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FTerm.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -35,7 +35,7 @@ fn color_supported() -> bool {\n }\n \n fn set_color(io.buf_writer writer, u8 first_char, u8 color) {\n-    assert (color < 16u8);\n+    check (color < 16u8);\n \n     esc(writer);\n     if (color >= 8u8) {"}, {"sha": "dfd2204d007a99e8adb95d4edee4d50e072d14b3", "filename": "src/lib/_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -27,7 +27,7 @@ iter range(int lo, int hi) -> int {\n \n fn to_str(int n, uint radix) -> str\n {\n-    assert (0u < radix && radix <= 16u);\n+    check (0u < radix && radix <= 16u);\n     if (n < 0) {\n         ret \"-\" + _uint.to_str((-n) as uint, radix);\n     } else {"}, {"sha": "44f14fb6e1cc34c7beb69ca115fe7d007d08597c", "filename": "src/lib/_str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -218,14 +218,14 @@ fn utf8_char_width(u8 b) -> uint {\n fn char_range_at(str s, uint i) -> tup(char, uint) {\n     auto b0 = s.(i);\n     auto w = utf8_char_width(b0);\n-    assert (w != 0u);\n+    check(w != 0u);\n     if (w == 1u) {ret tup(b0 as char, i + 1u);}\n     auto val = 0u;\n     auto end = i + w;\n     i += 1u;\n     while (i < end) {\n         auto byte = s.(i);\n-        assert (byte & 0xc0_u8 == tag_cont_u8);\n+        check(byte & 0xc0_u8 == tag_cont_u8);\n         val <<= 6u;\n         val += (byte & 0x3f_u8) as uint;\n         i += 1u;\n@@ -247,11 +247,11 @@ fn char_len(str s) -> uint {\n     auto total = byte_len(s);\n     while (i < total) {\n         auto chsize = utf8_char_width(s.(i));\n-        assert (chsize > 0u);\n+        check(chsize > 0u);\n         len += 1u;\n         i += chsize;\n     }\n-    assert (i == total);\n+    check(i == total);\n     ret len;\n }\n \n@@ -274,7 +274,7 @@ fn push_char(&mutable str s, char ch) {\n fn pop_char(&mutable str s) -> char {\n     auto end = byte_len(s);\n     while (end > 0u && s.(end - 1u) & 0xc0_u8 == tag_cont_u8) {end -= 1u;}\n-    assert (end > 0u);\n+    check(end > 0u);\n     auto ch = char_at(s, end - 1u);\n     s = substr(s, 0u, end - 1u);\n     ret ch;\n@@ -404,15 +404,15 @@ fn slice(str s, uint begin, uint end) -> str {\n \n fn shift_byte(&mutable str s) -> u8 {\n     auto len = byte_len(s);\n-    assert (len > 0u);\n+    check(len > 0u);\n     auto b = s.(0);\n     s = substr(s, 1u, len - 1u);\n     ret b;\n }\n \n fn pop_byte(&mutable str s) -> u8 {\n     auto len = byte_len(s);\n-    assert (len > 0u);\n+    check(len > 0u);\n     auto b = s.(len - 1u);\n     s = substr(s, 0u, len - 1u);\n     ret b;"}, {"sha": "97108c9082b64882d219288266f8ac202fe655e1", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -56,7 +56,7 @@ fn to_str(uint num, uint radix) -> str\n {\n     auto n = num;\n \n-    assert (0u < radix && radix <= 16u);\n+    check (0u < radix && radix <= 16u);\n     fn digit(uint n) -> char {\n         alt (n) {\n             case (0u) { ret '0'; }"}, {"sha": "126bf363052c00e4a89466a0cecbe6b020f22905", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -131,7 +131,7 @@ fn len_set[T](array[T] v, uint n) {\n }\n \n fn buf_off[T](array[T] v, uint offset) -> vbuf {\n-     assert (offset < len[T](v));\n+    check (offset < len[T](v));\n     ret rustrt.vec_buf[T](v, offset);\n }\n \n@@ -149,10 +149,9 @@ fn last[T](array[T] v) -> option.t[T] {\n }\n \n // Returns elements from [start..end) from v.\n-\n fn slice[T](array[T] v, uint start, uint end) -> vec[T] {\n-    assert (start <= end);\n-    assert (end <= len[T](v));\n+    check (start <= end);\n+    check (end <= len[T](v));\n     auto result = alloc[T](end - start);\n     let uint i = start;\n     while (i < end) {\n@@ -164,15 +163,15 @@ fn slice[T](array[T] v, uint start, uint end) -> vec[T] {\n \n fn shift[T](&mutable array[T] v) -> T {\n     auto ln = len[T](v);\n-    assert (ln > 0u);\n+    check(ln > 0u);\n     auto e = v.(0);\n     v = slice[T](v, 1u, ln);\n     ret e;\n }\n \n fn pop[T](&mutable array[T] v) -> T {\n     auto ln = len[T](v);\n-    assert (ln > 0u);\n+    check(ln > 0u);\n     ln -= 1u;\n     auto e = v.(ln);\n     v = slice[T](v, 0u, ln);"}, {"sha": "feb4296aa6efd09dfec0096af4eb309f28c21284", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -28,8 +28,8 @@ fn create(uint nbits, bool init) -> t {\n fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n     auto len = _vec.len[mutable uint](v1.storage);\n \n-    assert (_vec.len[mutable uint](v0.storage) == len);\n-    assert (v0.nbits == v1.nbits);\n+    check (_vec.len[mutable uint](v0.storage) == len);\n+    check (v0.nbits == v1.nbits);\n \n     auto changed = false;\n \n@@ -84,7 +84,7 @@ fn clone(t v) -> t {\n }\n \n fn get(&t v, uint i) -> bool {\n-    assert (i < v.nbits);\n+    check (i < v.nbits);\n \n     auto bits = uint_bits();\n \n@@ -129,7 +129,7 @@ fn difference(&t v0, &t v1) -> bool {\n }\n \n fn set(&t v, uint i, bool x) {\n-    assert (i < v.nbits);\n+    check (i < v.nbits);\n \n     auto bits = uint_bits();\n \n@@ -196,7 +196,7 @@ fn to_str(&t v) -> str {\n \n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n-    assert (v0.nbits == _vec.len[uint](v1));\n+    check (v0.nbits == _vec.len[uint](v1));\n     auto len = v0.nbits;\n     auto i = 0u;\n     while (i < len) {"}, {"sha": "776f82e99fe8fe9e4a303cedfc32d592224c65a4", "filename": "src/lib/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -28,7 +28,7 @@ fn create[T]() -> t[T] {\n      * elsewhere.\n      */\n     fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-        assert (nelts == _vec.len[cell[T]](elts));\n+        check (nelts == _vec.len[cell[T]](elts));\n \n         fn fill[T](uint i, uint nelts, uint lo,\n                    vec[cell[T]] old) -> cell[T] {"}, {"sha": "f73ad4fc6474362c35e2ec07b04de756fb22ad24", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -99,7 +99,7 @@ fn doc_data(doc d) -> vec[u8] {\n \n fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n     auto sz = size;\n-    assert (sz <= 4u);\n+    check (sz <= 4u);\n     auto val = 0u;\n     auto pos = start;\n     while (sz > 0u) {"}, {"sha": "774ce11324cbc8c963e593ef7f0f3ec8e01cddec", "filename": "src/lib/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -10,7 +10,7 @@ type path = str;\n \n fn dirname(path p) -> path {\n     auto sep = path_sep();\n-    assert (_str.byte_len(sep) == 1u);\n+    check (_str.byte_len(sep) == 1u);\n     let int i = _str.rindex(p, sep.(0));\n     if (i == -1) {\n         ret p;"}, {"sha": "4c1bf2dfb2b120e15009398b2cd34220e198fc8c", "filename": "src/lib/io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -72,7 +72,7 @@ state obj FILE_buf_reader(os.libc.FILE f, bool must_close) {\n         ret os.libc.feof(f) != 0;\n     }\n     fn seek(int offset, seek_style whence) {\n-        assert (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        check (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n     fn tell() -> uint {\n         ret os.libc.ftell(f) as uint;\n@@ -101,14 +101,14 @@ state obj new_reader(buf_reader rdr) {\n         if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n         auto b0 = c0 as u8;\n         auto w = _str.utf8_char_width(b0);\n-        assert (w > 0u);\n+        check(w > 0u);\n         if (w == 1u) {ret b0 as char;}\n         auto val = 0u;\n         while (w > 1u) {\n             w -= 1u;\n             auto next = rdr.read_byte();\n-            assert (next > -1);\n-            assert (next & 0xc0 == 0x80);\n+            check(next > -1);\n+            check(next & 0xc0 == 0x80);\n             val <<= 6u;\n             val += (next & 0x3f) as uint;\n         }\n@@ -279,7 +279,7 @@ state obj FILE_writer(os.libc.FILE f, bool must_close) {\n     }\n \n     fn seek(int offset, seek_style whence) {\n-        assert (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        check(os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n \n     fn tell() -> uint {"}, {"sha": "d5230e9ae09c4290979f4a404b460d8d59370b77", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -66,7 +66,7 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n+    check(os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n@@ -76,7 +76,7 @@ fn fd_FILE(int fd) -> libc.FILE {\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    assert (os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n+    check(os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n     ret status.(0);\n }\n "}, {"sha": "b0980bc5225810a0cb0a34a4fd4cdc448439c280", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -63,7 +63,7 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n+    check(os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n@@ -73,7 +73,7 @@ fn fd_FILE(int fd) -> libc.FILE {\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    assert (os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n+    check(os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n     ret status.(0);\n }\n "}, {"sha": "03115fc7d331b67b94e2eb3e8c47aaae9156c0c3", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ native \"rust\" mod rustrt {\n fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n   auto dir = os.libc.opendir(_str.buf(path));\n-  assert (dir as uint != 0u);\n+  check (dir as uint != 0u);\n   let vec[str] result = vec();\n   while (true) {\n     auto ent = os.libc.readdir(dir);"}, {"sha": "3866be1e04cfeb7d52b0b61fa25f650c7bb00af1", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -43,7 +43,7 @@ fn mk_sha1() -> sha1 {\n \n     fn add_input(&sha1state st, &vec[u8] msg) {\n         // FIXME: Should be typestate precondition\n-        assert (!st.computed);\n+        check (!st.computed);\n \n         for (u8 element in msg) {\n             st.msg_block.(st.msg_block_idx) = element;\n@@ -67,7 +67,7 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(&sha1state st) {\n \n         // FIXME: Make precondition\n-        assert (_vec.len[mutable u32](st.h) == digest_buf_len);\n+        check (_vec.len[mutable u32](st.h) == digest_buf_len);\n \n         // Constants\n         auto k = vec(0x5A827999u32,\n@@ -192,7 +192,7 @@ fn mk_sha1() -> sha1 {\n      */\n     fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n-        assert (_vec.len[mutable u8](st.msg_block) == msg_block_len);\n+        check (_vec.len[mutable u8](st.msg_block) == msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -236,7 +236,7 @@ fn mk_sha1() -> sha1 {\n \n         fn reset() {\n             // FIXME: Should be typestate precondition\n-            assert (_vec.len[mutable u32](st.h) == digest_buf_len);\n+            check (_vec.len[mutable u32](st.h) == digest_buf_len);\n \n             st.len_low = 0u32;\n             st.len_high = 0u32;"}, {"sha": "a2940d8de55ea507f252067afcf8015f44332863", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -53,7 +53,7 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (os.libc._pipe(_vec.buf[mutable int](fds), 1024u,\n+    check(os.libc._pipe(_vec.buf[mutable int](fds), 1024u,\n                         libc_constants.O_BINARY()) == 0);\n     ret tup(fds.(0), fds.(1));\n }"}, {"sha": "e8c9cf71bcbee00274442a9439263761ffa801ff", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -2,5 +2,5 @@\n // error-pattern:1 == 2\n \n fn main() {\n-   assert (1 == 2);\n+   check (1 == 2);\n }"}, {"sha": "7def7c11d0a221d2f7618170518d9d63189bdac5", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,7 +4,7 @@\n // error-pattern:1 == 2\n \n fn child() {\n-  assert (1 == 2);\n+  check (1 == 2);\n }\n \n fn main() {"}, {"sha": "4388cb3ac802e5d7bc101fdce9e540d09d9f8b2a", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,12 +6,12 @@\n fn main() {\n   let str s = \"hello\";\n   let int x = 0;\n-  assert (s.(x) == (0x68 as u8));\n+  check (s.(x) == (0x68 as u8));\n \n   // NB: at the moment a string always has a trailing NULL,\n   // so the largest index value on the string above is 5, not\n   // 4. Possibly change this.\n \n   // Bounds-check failure.\n-  assert (s.(x + 6) == (0x0 as u8));\n+  check (s.(x + 6) == (0x0 as u8));\n }"}, {"sha": "961da730e3bdaa0a22df41317880e3abe9eb0096", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,7 +6,7 @@\n fn main() {\n   let vec[int] v = vec(10);\n   let int x = 0;\n-  assert (v.(x) == 10);\n+  check (v.(x) == 10);\n   // Bounds-check failure.\n-  assert (v.(x + 2) == 20);\n+  check (v.(x + 2) == 20);\n }"}, {"sha": "a230d1be7ff7613f7065341883cc7e33b8f08874", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,7 +6,7 @@\n fn main() {\n   let vec[int] v = vec(10, 20);\n   let int x = 0;\n-  assert (v.(x) == 10);\n+  check (v.(x) == 10);\n   // Bounds-check failure.\n-  assert (v.(x-1) == 20);\n+  check (v.(x-1) == 20);\n }"}, {"sha": "4ee2c12bec25d957f95fcc92e3576df03310ec72", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -21,12 +21,12 @@ fn foo(str s) {\n   }\n \n   log _str.refcount(s);\n-  assert (_str.refcount(s) == const_refcount);\n+  check (_str.refcount(s) == const_refcount);\n }\n \n fn main() {\n   let str s = \"hi\";     // ref up\n   foo(s);               // ref up then down\n   log _str.refcount(s);\n-  assert (_str.refcount(s) == const_refcount);\n+  check (_str.refcount(s) == const_refcount);\n }"}, {"sha": "91190260bb10f53bd54bd62a194250ded909879d", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -12,6 +12,6 @@ fn altlit(int f) -> int {\n }\n \n fn main() {\n-  assert (altlit(10) == 20);\n-  assert (altlit(11) == 22);\n+  check (altlit(10) == 20);\n+  check (altlit(11) == 22);\n }"}, {"sha": "68013dfe303a772823b5822630b1bdb9405c6b93", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -32,8 +32,8 @@ fn main() {\n   let color gray = rgb(127, 127, 127);\n   let color clear = rgba(50, 150, 250, 0);\n   let color red = hsl(0, 255, 255);\n-  assert (process(gray) == 127);\n-  assert (process(clear) == 0);\n-  assert (process(red) == 255);\n+  check (process(gray) == 127);\n+  check (process(clear) == 0);\n+  check (process(red) == 255);\n }\n "}, {"sha": "7587b0050ad379203f69be645f6e5fd4963cedac", "filename": "src/test/run-pass/arith-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-0.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,5 +1,5 @@\n fn main() -> () {\n     let int a = 10;\n     log a;\n-    assert (a * (a - 1) == 90);\n+    check (a * (a - 1) == 90);\n }\n\\ No newline at end of file"}, {"sha": "bac6a055e80e1905d1a40f9469fbb2c8e796cf1c", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,22 +1,22 @@\n fn main() -> () {\n     let int i32_a = 10;\n-    assert (i32_a == 10);\n-    assert (i32_a - 10 == 0);\n-    assert (i32_a / 10 == 1);\n-    assert (i32_a - 20 == -10);\n-    assert (i32_a << 10 == 10240);\n-    assert (i32_a << 16 == 655360);\n-    assert (i32_a * 16 == 160);\n-    assert (i32_a * i32_a * i32_a == 1000);\n-    assert (i32_a * i32_a * i32_a * i32_a == 10000);\n-    assert (((i32_a * i32_a) / i32_a) * i32_a == 100);\n-    assert (i32_a * (i32_a - 1) << 2 + i32_a == 368640);\n+    check(i32_a == 10);\n+    check(i32_a - 10 == 0);\n+    check(i32_a / 10 == 1);\n+    check(i32_a - 20 == -10);\n+    check(i32_a << 10 == 10240);\n+    check(i32_a << 16 == 655360);\n+    check(i32_a * 16 == 160);\n+    check(i32_a * i32_a * i32_a == 1000);\n+    check(i32_a * i32_a * i32_a * i32_a == 10000);\n+    check(((i32_a * i32_a) / i32_a) * i32_a == 100);\n+    check(i32_a * (i32_a - 1) << 2 + i32_a == 368640);\n \n     let int i32_b = 0x10101010;\n-    assert (i32_b + 1 - 1 == i32_b);\n-    assert (i32_b << 1 == i32_b << 1);\n-    assert (i32_b >> 1 == i32_b >> 1);\n-    assert ((i32_b & (i32_b << 1)) == 0);\n+    check(i32_b + 1 - 1 == i32_b);\n+    check(i32_b << 1 == i32_b << 1);\n+    check(i32_b >> 1 == i32_b >> 1);\n+    check((i32_b & (i32_b << 1)) == 0);\n     log ((i32_b | (i32_b << 1)));\n-    assert ((i32_b | (i32_b << 1)) == 0x30303030);\n+    check((i32_b | (i32_b << 1)) == 0x30303030);\n }\n\\ No newline at end of file"}, {"sha": "33a740c84fce6ffd6df35c09eeaef486fdca5725", "filename": "src/test/run-pass/arith-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,5 +1,5 @@\n fn main() -> () {\n     let int i32_c = 0x10101010;\n-    assert (i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3) == \n+    check (i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3) == \n            i32_c + (((i32_c * 2) / 3) * 2) + (i32_c - (7 % 3)));\n }\n\\ No newline at end of file"}, {"sha": "748ff6b7da32bb724b4f9a72a2a17c0c98ab6f88", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -2,24 +2,24 @@\n // Unsigned integer operations\n \n fn main() {\n-  assert (0u8 < 255u8);\n-  assert (0u8 <= 255u8);\n-  assert (255u8 > 0u8);\n-  assert (255u8 >= 0u8);\n-  assert (250u8 / 10u8 == 25u8);\n-  assert (255u8 % 10u8 == 5u8);\n-  assert (0u16 < 60000u16);\n-  assert (0u16 <= 60000u16);\n-  assert (60000u16 > 0u16);\n-  assert (60000u16 >= 0u16);\n-  assert (60000u16 / 10u16 == 6000u16);\n-  assert (60005u16 % 10u16 == 5u16);\n-  assert (0u32 < 4000000000u32);\n-  assert (0u32 <= 4000000000u32);\n-  assert (4000000000u32 > 0u32);\n-  assert (4000000000u32 >= 0u32);\n-  assert (4000000000u32 / 10u32 == 400000000u32);\n-  assert (4000000005u32 % 10u32 == 5u32);\n+  check (0u8 < 255u8);\n+  check (0u8 <= 255u8);\n+  check (255u8 > 0u8);\n+  check (255u8 >= 0u8);\n+  check (250u8 / 10u8 == 25u8);\n+  check (255u8 % 10u8 == 5u8);\n+  check (0u16 < 60000u16);\n+  check (0u16 <= 60000u16);\n+  check (60000u16 > 0u16);\n+  check (60000u16 >= 0u16);\n+  check (60000u16 / 10u16 == 6000u16);\n+  check (60005u16 % 10u16 == 5u16);\n+  check (0u32 < 4000000000u32);\n+  check (0u32 <= 4000000000u32);\n+  check (4000000000u32 > 0u32);\n+  check (4000000000u32 >= 0u32);\n+  check (4000000000u32 / 10u32 == 400000000u32);\n+  check (4000000005u32 % 10u32 == 5u32);\n \n   // 64-bit numbers have some flakiness yet. Not tested\n }"}, {"sha": "956a7eb440b55cb07fb1025795691cf400f660b7", "filename": "src/test/run-pass/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,11 +8,11 @@ fn main() {\n   let clam b = rec(x=@10, y=@20);\n   let int z = a.x + b.y;\n   log z;\n-  assert (z == 21);\n+  check (z == 21);\n \n   let fish forty = tup(@40);\n   let fish two = tup(@2);\n   let int answer = forty._0 + two._0;\n   log answer;\n-  assert (answer == 42);\n+  check (answer == 42);\n }"}, {"sha": "c3fc2e7c3613744d3e10ac66bc6aed016b482bad", "filename": "src/test/run-pass/bind-exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-exterior.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,5 +4,5 @@ fn foo(@int a, @int b) -> int {\n \n fn main() {\n   auto f1 = bind foo(@10, @12);\n-  assert (f1() == 22);\n+  check(f1() == 22);\n }"}, {"sha": "2d164e07e058c51fc9c83745bfcff2cca28482b2", "filename": "src/test/run-pass/bind-interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-interior.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,5 +7,5 @@ fn f(int n) -> int {\n fn main() {\n   let fn() -> int g = bind f(10);\n   let int i = g();\n-  assert (i == 10);\n+  check(i == 10);\n }"}, {"sha": "8780b22a002d891b38f591cd86bb2264d24e71e4", "filename": "src/test/run-pass/bind-obj-ctor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   auto ctor1 = bind simple(_, 2);\n   auto obj1 = ctor0(2);\n   auto obj2 = ctor1(1);\n-  assert (obj0.sum() == 3);\n-  assert (obj1.sum() == 3);\n-  assert (obj2.sum() == 3);\n+  check (obj0.sum() == 3);\n+  check (obj1.sum() == 3);\n+  check (obj2.sum() == 3);\n }"}, {"sha": "be6e1b24e133e70402749234a0a473082f40b1f5", "filename": "src/test/run-pass/bind-thunk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-thunk.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,5 +7,5 @@ fn f() -> int {\n fn main() {\n   let fn() -> int g = bind f();\n   let int i = g();\n-  assert (i == 42);\n+  check(i == 42);\n }"}, {"sha": "fbd6e78d797bd7ecb6bfc664b4e2bf2f071f1519", "filename": "src/test/run-pass/bind-trivial.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-trivial.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,5 +7,5 @@ fn f(int n) -> int {\n fn main() {\n   let fn(int) -> int g = bind f(_);\n   let int i = g(42);\n-  assert (i == 42);\n+  check(i == 42);\n }"}, {"sha": "36b58a9172632a71d05f61c89b4c2b508bb7690c", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,14 +8,14 @@ fn main() {\n   a = a ^ b;\n   log a;\n   log b;\n-  assert (b == 1);\n-  assert (a == 2);\n+  check (b == 1);\n+  check (a == 2);\n \n-  assert (~(0xf0) & 0xff == 0xf);\n-  assert (0xf0 | 0xf == 0xff);\n-  assert (0xf << 4 == 0xf0);\n-  assert (0xf0 >> 4 == 0xf);\n-  assert (-16 >>> 2 == -4);\n-  assert (0b1010_1010 | 0b0101_0101 == 0xff);\n+  check (~(0xf0) & 0xff == 0xf);\n+  check (0xf0 | 0xf == 0xff);\n+  check (0xf << 4 == 0xf0);\n+  check (0xf0 >> 4 == 0xf);\n+  check (-16 >>> 2 == -4);\n+  check (0b1010_1010 | 0b0101_0101 == 0xff);\n }\n "}, {"sha": "ba70bdb1318dc27e84e641d346c80de2d4bedcae", "filename": "src/test/run-pass/bool-not.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbool-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbool-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool-not.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -2,14 +2,14 @@\n \n fn main() {\n   if (!false) {\n-    assert (true);\n+    check (true);\n   } else {\n-    assert (false);\n+    check (false);\n   }\n \n   if (!true) {\n-    assert (false);\n+    check (false);\n   } else {\n-    assert (true);\n+    check (true);\n   }\n }"}, {"sha": "619790d796512d3ff381c92136d5c53a7e0eac61", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,6 +1,6 @@\n // xfail-boot\n fn main() {\n-  assert (@1 < @3);\n-  assert (@@\"hello \" > @@\"hello\");\n-  assert (@@@\"hello\" != @@@\"there\");\n+  check (@1 < @3);\n+  check (@@\"hello \" > @@\"hello\");\n+  check (@@@\"hello\" != @@@\"there\");\n }\n\\ No newline at end of file"}, {"sha": "d0ad615b2e61cffa31e9a89d005a5c66bb8d373d", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,5 +6,5 @@ fn main() {\n   let int foo = 17;\n   let box[int] bfoo = tup(@foo);\n   log \"see what's in our box\";\n-  assert (unbox[int](bfoo) == foo);\n+  check (unbox[int](bfoo) == foo);\n }"}, {"sha": "ffcd9ec5946281d3d081524fc6d8dd8bf12a9288", "filename": "src/test/run-pass/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n   let @int x = @10;\n-  assert ((*x) == 10);\n+  check ((*x) == 10);\n }"}, {"sha": "48c3b091f08b0233ce7570d3440a6b234bacd6c8", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,35 +6,35 @@ fn main() {\n     i += 1;\n     if (i == 10) { break; }\n   }\n-  assert (i == 10);\n+  check(i == 10);\n \n   do {\n     i += 1;\n     if (i == 20) { break; }\n   } while (i < 30);\n-  assert (i == 20);\n+  check(i == 20);\n \n   for (int x in vec(1, 2, 3, 4, 5, 6)) {\n     if (x == 3) { break; }\n-    assert (x <= 3);\n+    check(x <= 3);\n   }\n \n   i = 0;\n   while (i < 10) {\n     i += 1;\n     if (i % 2 == 0) { cont; }\n-    assert (i % 2 != 0);\n+    check(i % 2 != 0);\n   }\n \n   i = 0;\n   do {\n     i += 1;\n     if (i % 2 == 0) { cont; }\n-    assert (i % 2 != 0);\n+    check(i % 2 != 0);\n   } while (i < 10);\n \n   for (int x in vec(1, 2, 3, 4, 5, 6)) {\n     if (x % 2 == 0) { cont; }\n-    assert (x % 2 != 0);\n+    check(x % 2 != 0);\n   }\n }"}, {"sha": "e04ad62939d213da5d6bd988b7034bdad50ed939", "filename": "src/test/run-pass/cast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,14 +3,14 @@\n \n fn main() {\n   let int i = 'Q' as int;\n-  assert (i == 0x51);\n+  check (i == 0x51);\n   let u32 u = i as u32;\n-  assert (u == (0x51 as u32));\n-  assert (u == ('Q' as u32));\n-  assert ((i as u8) == ('Q' as u8));\n-  assert (((i as u8) as i8) == (('Q' as u8) as i8));\n-  assert ((0x51 as char) == 'Q');\n+  check (u == (0x51 as u32));\n+  check (u == ('Q' as u32));\n+  check ((i as u8) == ('Q' as u8));\n+  check (((i as u8) as i8) == (('Q' as u8) as i8));\n+  check ((0x51 as char) == 'Q');\n \n-  assert (true == (1 as bool));\n-  assert ((0 as u32) == (false as u32));\n+  check (true == (1 as bool));\n+  check ((0 as u32) == (false as u32));\n }"}, {"sha": "123f2eb26c42ea017a405d1ed2627a5be7c3fabc", "filename": "src/test/run-pass/char.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchar.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,12 +1,12 @@\n fn main() {\n     let char c = 'x';\n     let char d = 'x';\n-    assert (c == 'x');\n-    assert ('x' == c);\n-    assert (c == c);\n-    assert (c == d);\n-    assert (d == c);\n-    assert (d == 'x');\n-    assert ('x' == d);\n+    check(c == 'x');\n+    check('x' == c);\n+    check(c == c);\n+    check(c == d);\n+    check(d == c);\n+    check (d == 'x');\n+    check('x' == d);\n }\n "}, {"sha": "e97c409d50f3b9d653dd42bab0a639a46c657667", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,8 +1,8 @@\n // xfail-boot\n // xfail-stage0\n fn f(@rec(int a, int b) x) {\n-  assert (x.a == 10);\n-  assert (x.b == 12);\n+  check (x.a == 10);\n+  check (x.b == 12);\n }\n \n fn main() {"}, {"sha": "2bca62488dc933a5b2e4a7df1a14b40f7368d8a8", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,7 +8,7 @@ fn main() {\n   y <- p;\n   log \"received\";\n   log y;\n-  assert (y == 10);\n+  check (y == 10);\n }\n \n fn child(chan[int] c) {"}, {"sha": "5630d2e278dd91c07988f879ea959e0d5c68ddb2", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,9 +6,9 @@ fn main() {\n \n   ch <| 10;\n   let int i <- po;\n-  assert (i == 10);\n+  check (i == 10);\n \n   ch <| 11;\n   auto j <- po;\n-  assert (j == 11);\n+  check (j == 11);\n }"}, {"sha": "5131c42b0fe001b5dc8a62f125251076066fdcf8", "filename": "src/test/run-pass/deep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fdeep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fdeep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeep.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -10,5 +10,5 @@ fn f(int x) -> int {\n }\n \n fn main() {\n-  assert (f(5000) == 5000);\n+  check (f(5000) == 5000);\n }"}, {"sha": "cfa0fbe9c1776ed1fc81e87cf4a13ff0409b106c", "filename": "src/test/run-pass/div-mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiv-mod.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,15 +3,15 @@\n fn main() {\n   let int x = 15;\n   let int y = 5;\n-  assert (x / 5 == 3);\n-  assert (x / 4 == 3);\n-  assert (x / 3 == 5);\n-  assert (x / y == 3);\n-  assert (15 / y == 3);\n+  check(x / 5 == 3);\n+  check(x / 4 == 3);\n+  check(x / 3 == 5);\n+  check(x / y == 3);\n+  check(15 / y == 3);\n \n-  assert (x % 5 == 0);\n-  assert (x % 4 == 3);\n-  assert (x % 3 == 0);\n-  assert (x % y == 0);\n-  assert (15 % y == 0);\n+  check(x % 5 == 0);\n+  check(x % 4 == 3);\n+  check(x % 3 == 0);\n+  check(x % y == 0);\n+  check(15 % y == 0);\n }"}, {"sha": "d9e5b8690250f452f1c7b398831dbeddd9fee70d", "filename": "src/test/run-pass/else-if.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Felse-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Felse-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Felse-if.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,42 +1,42 @@\n fn main() {\n   if (1 == 2) {\n-    assert (false);\n+    check(false);\n   } else if (2 == 3) {\n-    assert (false);\n+    check(false);\n   } else if (3 == 4) {\n-    assert (false);\n+    check(false);\n   } else {\n-    assert (true);\n+    check(true);\n   }\n \n \n   if (1 == 2) {\n-    assert (false);\n+    check(false);\n   } else if (2 == 2) {\n-    assert (true);\n+    check(true);\n   }\n \n   if (1 == 2) {\n-    assert (false);\n+    check(false);\n   } else if (2 == 2) {\n     if (1 == 1) {\n-      assert (true);\n+      check(true);\n     } else {\n       if (2 == 1) {\n-        assert (false);\n+        check(false);\n       } else {\n-        assert (false);\n+        check(false);\n       }\n     }\n   }\n \n   if (1 == 2) {\n-    assert (false);\n+    check(false);\n   } else {\n     if (1 == 2) {\n-      assert (false);\n+      check(false);\n     } else {\n-      assert (true);\n+      check(true);\n     }\n   }\n }"}, {"sha": "2e7846f36c337ffa1bd2aa72a419d165a5135229", "filename": "src/test/run-pass/expr-alt-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn test_box() {\n       @100\n     }\n   };\n-  assert (*res == 100);\n+  check (*res == 100);\n }\n \n fn test_str() {\n@@ -18,7 +18,7 @@ fn test_str() {\n       \"happy\"\n     }\n   };\n-  assert (res == \"happy\");\n+  check (res == \"happy\");\n }\n \n fn main() {"}, {"sha": "8ff67f0ff3b704066968262541e18f6524e242b8", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn test_generic[T](@T expected, &compare[T] eq) {\n       expected\n     }\n   };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_box() {"}, {"sha": "7928ffede554514a02e324c184de26f45061cbe9", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn test_generic[T](&T expected, &compare[T] eq) {\n       expected\n     }\n   };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_vec() {"}, {"sha": "6668105955d9d8330d720bae66cb5b8acc43c35c", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn test_generic[T](&T expected, &compare[T] eq) {\n       expected\n     }\n   };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_bool() {"}, {"sha": "31406969d87c40fd5a92def4223b7ef525f8e3cf", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn test_rec() {\n       rec(i = 100)\n     }\n   };\n-  assert (res == rec(i = 100));\n+  check (res == rec(i = 100));\n }\n \n fn test_tag() {\n@@ -26,7 +26,7 @@ fn test_tag() {\n       sad\n     }\n   };\n-  assert (res == happy);\n+  check (res == happy);\n }\n \n fn main() {"}, {"sha": "4c10a7d9e292697dc007ec40146180fe3c2f6479", "filename": "src/test/run-pass/expr-alt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -12,7 +12,7 @@ fn test_basic() {\n       false\n     }\n   };\n-  assert (res);\n+  check (res);\n \n   res = alt(false) {\n     case (true) {\n@@ -22,7 +22,7 @@ fn test_basic() {\n       true\n     }\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn test_inferrence() {\n@@ -34,7 +34,7 @@ fn test_inferrence() {\n       false\n     }\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn test_alt_as_alt_head() {\n@@ -47,7 +47,7 @@ fn test_alt_as_alt_head() {\n       true\n     }\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn test_alt_as_block_result() {\n@@ -66,7 +66,7 @@ fn test_alt_as_block_result() {\n       }\n     }\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn main() {"}, {"sha": "e8ab62091a59da412ab813010a22862ffa0297dd", "filename": "src/test/run-pass/expr-block-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     @100\n   };\n \n-  assert (*x == 100);\n+  check (*x == 100);\n }"}, {"sha": "eb0357d9e89bab5901fabfb74b6b0adf6dee5732", "filename": "src/test/run-pass/expr-block-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,7 +6,7 @@ fn test_fn() {\n     ret 10;\n   }\n   let t res = { ten };\n-  assert (res() == 10);\n+  check (res() == 10);\n }\n \n fn main() {"}, {"sha": "57487fd617d06dddbba092b6ac76937bb0bbf280", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(@T t1, @T t2) -> bool;\n \n fn test_generic[T](@T expected, &compare[T] eq) {\n   let @T actual = { expected };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_box() {"}, {"sha": "3b1e44791a074c4a3cc8c686338cafb64b6b2c25", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &compare[T] eq) {\n   let T actual = { expected };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_vec() {"}, {"sha": "ded3b6207045b7b3a1530df3f755129ba021fbd9", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,7 +7,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &compare[T] eq) {\n   let T actual = { expected };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_bool() {"}, {"sha": "ecc6f04a3402970b33c39f27aafa3316c27f0db0", "filename": "src/test/run-pass/expr-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,12 +5,12 @@\n \n fn test_basic() {\n   let bool res = { true };\n-  assert (res);\n+  check (res);\n }\n \n fn test_rec() {\n   auto res = { rec(v1 = 10, v2 = 20) };\n-  assert (res.v2 == 20);\n+  check (res.v2 == 20);\n }\n \n fn test_filled_with_stuff() {\n@@ -21,7 +21,7 @@ fn test_filled_with_stuff() {\n     }\n     a\n   };\n-  assert (res == 10);\n+  check (res == 10);\n }\n \n fn main() {"}, {"sha": "a629c9c9bc4644f03b25ce9a507f4701c600e57c", "filename": "src/test/run-pass/expr-if-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,12 +5,12 @@\n \n fn test_box() {\n   auto res = if (true) { @100 } else { @101 };\n-  assert (*res == 100);\n+  check (*res == 100);\n }\n \n fn test_str() {\n   auto res = if (true) { \"happy\" } else { \"sad\" };\n-  assert (res == \"happy\");\n+  check (res == \"happy\");\n }\n \n fn main() {"}, {"sha": "32aea8bb72f159ad0de33bbc92e48a139ff8d23a", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(@T t1, @T t2) -> bool;\n \n fn test_generic[T](@T expected, @T not_expected, &compare[T] eq) {\n   let @T actual = if (true) { expected } else { not_expected };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_box() {"}, {"sha": "d414d6d104de7109c97d9ce55ecbcb5b15b97824", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &T not_expected, &compare[T] eq) {\n   let T actual = if (true) { expected } else { not_expected };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_vec() {"}, {"sha": "0a0db2ddfde31fe8866c5405f9fa4c4d8335b7b1", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,7 +7,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &T not_expected, &compare[T] eq) {\n   let T actual = if (true) { expected } else { not_expected };\n-  assert (eq(expected, actual));\n+  check (eq(expected, actual));\n }\n \n fn test_bool() {"}, {"sha": "df20a3bae603079835b3e05a4836d1674e613512", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@\n \n fn test_rec() {\n   auto res = if (true) { rec(i = 100) } else { rec(i = 101) };\n-  assert (res == rec(i = 100));\n+  check (res == rec(i = 100));\n }\n \n fn test_tag() {\n@@ -15,7 +15,7 @@ fn test_tag() {\n   }\n \n   auto res = if (true) { happy } else { sad };\n-  assert (res == happy);\n+  check (res == happy);\n }\n \n fn main() {"}, {"sha": "7c99f2ea82e1c284ddf3c9ea58e9be54ee09dd76", "filename": "src/test/run-pass/expr-if.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexpr-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,12 +5,12 @@\n \n fn test_if() {\n   let bool res = if (true) { true } else { false };\n-  assert (res);\n+  check (res);\n }\n \n fn test_else() {\n   let bool res = if (false) { false } else { true };\n-  assert (res);\n+  check (res);\n }\n \n fn test_elseif1() {\n@@ -21,7 +21,7 @@ fn test_elseif1() {\n   } else {\n     false\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn test_elseif2() {\n@@ -32,7 +32,7 @@ fn test_elseif2() {\n   } else {\n     false\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn test_elseif3() {\n@@ -43,12 +43,12 @@ fn test_elseif3() {\n   } else {\n     true\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn test_inferrence() {\n   auto res = if (true) { true } else { false };\n-  assert (res);\n+  check (res);\n }\n \n fn test_if_as_if_condition() {\n@@ -57,14 +57,14 @@ fn test_if_as_if_condition() {\n   } else {\n     false\n   };\n-  assert (res1);\n+  check (res1);\n \n   auto res2 = if (if (true) { false } else { true }) {\n     false\n   } else {\n     true\n   };\n-  assert (res2);\n+  check (res2);\n }\n \n fn test_if_as_block_result() {\n@@ -77,7 +77,7 @@ fn test_if_as_block_result() {\n   } else {\n     false\n   };\n-  assert (res);\n+  check (res);\n }\n \n fn main() {"}, {"sha": "f09ee8234e35dc235453871881756758ba7a243d", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,16 +3,16 @@\n type point = rec(int x, int y, mutable int z);\n \n fn f(@point p) {\n-  assert (p.z == 12);\n+  check (p.z == 12);\n   p.z = 13;\n-  assert (p.z == 13);\n+  check (p.z == 13);\n }\n \n fn main() {\n   let point a = rec(x=10, y=11, mutable z=12);\n   let @point b = @a;\n-  assert (b.z == 12);\n+  check (b.z == 12);\n   f(b);\n-  assert (a.z == 12);\n-  assert (b.z == 13);\n+  check (a.z == 12);\n+  check (b.z == 13);\n }"}, {"sha": "91cf099c3acb09e51cdf79c6a3a486bfe2d96002", "filename": "src/test/run-pass/fact.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffact.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -15,7 +15,7 @@ fn f(int x) -> int {\n   }\n }\n fn main () {\n-  assert (f(5) == 120);\n+  check (f(5) == 120);\n   // log \"all done\";\n }\n "}, {"sha": "9cc3a8ca9cd31a5bab77ac3cc88a43398af0da0b", "filename": "src/test/run-pass/float2.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffloat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffloat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -12,13 +12,13 @@ fn main() {\n   auto j = 3.1e+9;\n   auto k = 3.2e-10;\n  \n-  assert (a == b);\n-  assert (c < b);\n-  assert (c == d);\n-  assert (e < g);\n-  assert (f < h);\n-  assert (g == 1000000.0f32);\n-  assert (h == i);\n-  assert (j > k);\n-  assert (k < a);\n+  check(a == b);\n+  check(c < b);\n+  check(c == d);\n+  check(e < g);\n+  check(f < h);\n+  check(g == 1000000.0f32);\n+  check(h == i);\n+  check(j > k);\n+  check(k < a);\n }\n\\ No newline at end of file"}, {"sha": "10b0fb7766a60aa063eabd5cad05ef433fa127de", "filename": "src/test/run-pass/floatlits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffloatlits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffloatlits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloatlits.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,9 +1,9 @@\n // xfail-boot\n fn main() {\n   auto f = 4.999999999999;\n-  assert (f > 4.90);\n-  assert (f < 5.0);\n+  check (f > 4.90);\n+  check (f < 5.0);\n   auto g = 4.90000000001e-10;\n-  assert (g > 5e-11);\n-  assert (g < 5e-9);\n+  check(g > 5e-11);\n+  check(g < 5e-9);\n }\n\\ No newline at end of file"}, {"sha": "d25405d8c6e57090832600402cb9f61e462b8034", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -28,12 +28,12 @@ fn main() {\n         }\n     }\n \n-    assert (a.(0) == 0);\n-    assert (a.(1) == 1);\n-    assert (a.(2) == 10);\n-    assert (a.(3) == 11);\n-    assert (a.(4) == 100);\n-    assert (a.(5) == 101);\n-    assert (a.(6) == 110);\n-    assert (a.(7) == 111);\n+    check (a.(0) == 0);\n+    check (a.(1) == 1);\n+    check (a.(2) == 10);\n+    check (a.(3) == 11);\n+    check (a.(4) == 100);\n+    check (a.(5) == 101);\n+    check (a.(6) == 110);\n+    check (a.(7) == 111);\n }"}, {"sha": "a655f59101988944da2bcd039a9546410859f730", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -16,8 +16,8 @@ fn main() {\n         }\n     }\n \n-    assert (a.(0) == 0);\n-    assert (a.(1) == 1);\n-    assert (a.(2) == 10);\n-    assert (a.(3) == 11);\n+    check (a.(0) == 0);\n+    check (a.(1) == 1);\n+    check (a.(2) == 10);\n+    check (a.(3) == 11);\n }"}, {"sha": "43d8b5c33a897c81de8127973792d464600e32ad", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -14,9 +14,9 @@ fn main() {\n   for each (tup(int,int) p in pairs()) {\n       log p._0;\n       log p._1;\n-      assert (p._0 + 10 == i);\n+      check (p._0 + 10 == i);\n       i += 1;\n       j = p._1;\n     }\n-  assert (j == 45);\n+  check(j == 45);\n }\n\\ No newline at end of file"}, {"sha": "efc6e8ca7025c8c933002888648e67b168bf77a2", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn main() {\n   }\n   log \"sum\";\n   log sum;\n-  assert (sum == 45);\n+  check (sum == 45);\n }\n \n iter first_ten() -> int {"}, {"sha": "59446b4a771eb8edaa268b7967b9c23b88c7b2c6", "filename": "src/test/run-pass/fun-call-variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -13,7 +13,7 @@ fn main() {\n   let int a = direct(3); // direct\n   //let int b = ho(direct); // indirect unbound\n   let int c = ho(bind direct(_)); // indirect bound\n-  //assert (a == b);\n-  //assert (b == c);\n+  //check(a == b);\n+  //check(b == c);\n }\n "}, {"sha": "10c2cf40505504b43815d84c4e4a176ed2917d0d", "filename": "src/test/run-pass/fun-indirect-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,5 +7,5 @@ fn f() -> int {\n fn main() {\n   let fn() -> int g = f;\n   let int i = g();\n-  assert (i == 42);\n+  check(i == 42);\n }"}, {"sha": "377e0fb2b8d143a757689b0a42fd31d49e842d78", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   auto expected = @100;\n   auto actual = id[@int](expected);\n   log *actual;\n-  assert (*expected == *actual);\n+  check (*expected == *actual);\n }\n\\ No newline at end of file"}, {"sha": "3975867ac29a32f13781f9bbeab80695c162d8e3", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ fn id[T](&T t) -> T {\n \n fn main() {\n   auto t = tup(1,2,3,4,5,6,7);\n-  assert (t._5 == 6);\n+  check (t._5 == 6);\n   auto f0 = bind id[tup(int,int,int,int,int,int,int)](t);\n-  assert (f0()._5 == 6);\n+  check (f0()._5 == 6);\n }"}, {"sha": "ef1275e3cecd6ebae893c7201dcfe5ccbe078f50", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,7 +4,7 @@ fn id[T](&T t) -> T {\n \n fn main() {\n   auto t = tup(1,2,3,4,5,6,7);\n-  assert (t._5 == 6);\n+  check (t._5 == 6);\n   auto f1 = bind id[tup(int,int,int,int,int,int,int)](_);\n-  assert (f1(t)._5 == 6);\n+  check (f1(t)._5 == 6);\n }"}, {"sha": "856f3aff8e6e069ed4bc4e37d89ef307042fceb3", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,5 +4,5 @@ fn box[T](&tup(T,T,T) x) -> @tup(T,T,T) {\n \n fn main() {\n   let @tup(int,int,int) x = box[int](tup(1,2,3));\n-  assert (x._1 == 2);\n+  check (x._1 == 2);\n }\n\\ No newline at end of file"}, {"sha": "54c3f9564ecf006d825ba146effa08ae108b7a65", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -12,6 +12,6 @@ fn main() {\n   auto b = f[int](10);\n   log b._0;\n   log b._1;\n-  assert (b._0 == 10);\n-  assert (b._1 == 10);\n+  check (b._0 == 10);\n+  check (b._1 == 10);\n }"}, {"sha": "0ec7020cdaddaf75f62da5108fc6be393c77b31d", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,6 +8,6 @@ fn main() {\n   let int foo = 17;\n   let tupbox[int] tbfoo = tuplift[int](foo);\n   let recbox[int] rbfoo = reclift[int](foo);\n-  assert (tbfoo._0 == foo);\n-  assert (rbfoo.x == foo);\n+  check (tbfoo._0 == foo);\n+  check (rbfoo.x == foo);\n }"}, {"sha": "4398670f15e9a9256f932fc8d061616daf346f94", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,5 +9,5 @@ fn id[T](&T x) -> T {\n fn main() {\n   let int x = 42;\n   let int y = id(x);\n-  assert (x == y);\n+  check (x == y);\n }"}, {"sha": "238ef2d1aea2a663f9432a79e0a5fec9a9ef5831", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -17,16 +17,16 @@ fn main() {\n \n    y = id[int](x);\n    log y;\n-   assert (x == y);\n+   check (x == y);\n \n    b = id[char](a);\n    log b;\n-   assert (a == b);\n+   check (a == b);\n \n    q = id[triple](p);\n    x = p._2;\n    y = q._2;\n    log y;\n-   assert (x == y);\n+   check (x == y);\n \n }"}, {"sha": "2a50ccd2bb175cd9dad662f4985af9f47445c492", "filename": "src/test/run-pass/generic-obj-with-derived-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   log h.get()._0;\n   log h.get()._1;\n   log h.get()._2;\n-  assert (h.get()._0 == (1 as u8));\n-  assert (h.get()._1 == (2 as u8));\n-  assert (h.get()._2 == (3 as u8));\n+  check (h.get()._0 == (1 as u8));\n+  check (h.get()._1 == (2 as u8));\n+  check (h.get()._2 == (3 as u8));\n }"}, {"sha": "ced9140fc60bb777839b6edc4183639ef62b925c", "filename": "src/test/run-pass/generic-obj.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -21,8 +21,8 @@ fn main() {\n   log b.get(0);\n   log b.get(1);\n   log b.get(2);\n-  assert (b.get(0) == 1);\n-  assert (b.get(1) == 2);\n-  assert (b.get(2) == 3);\n+  check (b.get(0) == 1);\n+  check (b.get(1) == 2);\n+  check (b.get(2) == 3);\n   b.take2(0);\n }"}, {"sha": "9b19eec7388e3d5f9a8699e5746abc0a225b0105", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -10,7 +10,7 @@ fn altfoo[T](&foo[T] f) {\n       hit = true;\n     }\n   }\n-  assert (hit);\n+  check (hit);\n }\n \n fn main() {"}, {"sha": "090a050404a92849670cf3c0d47ece2ae97e83f8", "filename": "src/test/run-pass/generic-tag-values.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn main() {\n   alt (nop) {\n     case (some[int](?n)) {\n       log n;\n-      assert (n == 5);\n+      check (n == 5);\n     }\n   }\n \n@@ -18,8 +18,8 @@ fn main() {\n     case (some[tup(int, int)](?t)) {\n       log t._0;\n       log t._1;\n-      assert (t._0 == 17);\n-      assert (t._1 == 42);\n+      check (t._0 == 17);\n+      check (t._1 == 42);\n     }\n   }\n }"}, {"sha": "98401ecc1c5ee8d9da18bd05c56cf554988b66bd", "filename": "src/test/run-pass/generic-temporary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ fn mk() -> int {\n \n fn chk(&int a) {\n   log a;\n-  assert (a == 1);\n+  check (a == 1);\n }\n \n fn apply[T](fn() -> T produce, fn(&T) consume) {"}, {"sha": "c387ef1928dc119d80799bbd4ed8cf8bdc41f19c", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,6 +6,6 @@ fn get_third[T](&tup(T,T,T) t) -> T {\n \n fn main() {\n   log get_third(tup(1,2,3));\n-  assert (get_third(tup(1,2,3)) == 3);\n-  assert (get_third(tup(5u8,6u8,7u8)) == 7u8);\n+  check (get_third(tup(1,2,3)) == 3);\n+  check (get_third(tup(5u8,6u8,7u8)) == 7u8);\n }\n\\ No newline at end of file"}, {"sha": "6638cebfeeaf76497c20a6f1714da18af3d8cd82", "filename": "src/test/run-pass/generic-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,6 +1,6 @@\n type pair[T] = tup(T,T);\n fn main() {\n   let pair[int] x = tup(10,12);\n-  assert (x._0 == 10);\n-  assert (x._1 == 12);\n+  check (x._0 == 10);\n+  check (x._1 == 12);\n }"}, {"sha": "3f00acb1ff86b42874eb08a7ab12fc931c64e9aa", "filename": "src/test/run-pass/i32-sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi32-sub.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     let i32 x = -400_i32;\n     x = 0_i32 - x;\n-    assert (x == 400_i32);\n+    check(x == 400_i32);\n }\n "}, {"sha": "fb387d316c52f026291422204622f883fae2750a", "filename": "src/test/run-pass/i8-incr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi8-incr.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,5 +5,5 @@ fn main() {\n   let i8 y = -12i8;\n   x = x + 1i8;\n   x = x - 1i8;\n-  assert (x == y);\n+  check(x == y);\n }"}, {"sha": "fe7d147c30c1d87030db86a5b919247e13b19a5d", "filename": "src/test/run-pass/integral-indexing.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,19 +4,19 @@ fn main() {\n \n   let vec[int] v = vec(0, 1, 2, 3, 4, 5);\n   let str s = \"abcdef\";\n-  assert (v.(3u) == 3);\n-  assert (v.(3u8) == 3);\n-  assert (v.(3i8) == 3);\n-  assert (v.(3u32) == 3);\n-  assert (v.(3i32) == 3);\n+  check (v.(3u) == 3);\n+  check (v.(3u8) == 3);\n+  check (v.(3i8) == 3);\n+  check (v.(3u32) == 3);\n+  check (v.(3i32) == 3);\n \n   log v.(3u8);\n \n-  assert (s.(3u) == 'd' as u8);\n-  assert (s.(3u8) == 'd' as u8);\n-  assert (s.(3i8) == 'd' as u8);\n-  assert (s.(3u32) == 'd' as u8);\n-  assert (s.(3i32) == 'd' as u8);\n+  check (s.(3u) == 'd' as u8);\n+  check (s.(3u8) == 'd' as u8);\n+  check (s.(3i8) == 'd' as u8);\n+  check (s.(3u32) == 'd' as u8);\n+  check (s.(3i32) == 'd' as u8);\n \n   log s.(3u8);\n }\n\\ No newline at end of file"}, {"sha": "ade7c51c6ab02b510147ad8ff0b2cf070940a09b", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,5 +1,5 @@\n iter range(int a, int b) -> int {\n-  assert (a < b);\n+  check (a < b);\n \n   let int i = a;\n   while (i < b) {"}, {"sha": "fe0ffe6b21b991964411b906f2d97018e35c49f9", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,22 +1,22 @@\n fn incr(& mutable int x) -> bool {\n   x += 1;\n-  assert (false);\n+  check (false);\n   ret false;\n }\n \n fn main() {\n \n   auto x = (1 == 2) || (3 == 3);\n-  assert (x);\n+  check (x);\n \n   let int y = 10;\n   log x || incr(y);\n-  assert (y == 10);\n+  check (y == 10);\n \n   if (true && x) {\n-    assert (true);\n+    check (true);\n   } else {\n-    assert (false);\n+    check (false);\n   }\n \n }\n\\ No newline at end of file"}, {"sha": "6face271eed222ed11d8d71fa6275974dfb00fd0", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -10,13 +10,13 @@ fn main() {\n   y <- p;\n   log \"received 1\";\n   log y;\n-  assert (y == 10);\n+  check (y == 10);\n \n   spawn child(c);\n   y <- p;\n   log \"received 2\";\n   log y;\n-  assert (y == 10);\n+  check (y == 10);\n }\n \n fn child(chan[int] c) {"}, {"sha": "162e8b13293f34a24ae5d86051c9246215cc9310", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,29 +9,29 @@ fn test_0_elements() {\n   act = bitv.create(0u, false);\n   exp = _vec.init_elt[uint](0u, 0u);\n   // FIXME: why can't I write vec[uint]()?\n-  assert (bitv.eq_vec(act, exp));\n+  check (bitv.eq_vec(act, exp));\n }\n \n fn test_1_element() {\n   auto act;\n \n   act = bitv.create(1u, false);\n-  assert (bitv.eq_vec(act, vec(0u)));\n+  check (bitv.eq_vec(act, vec(0u)));\n \n   act = bitv.create(1u, true);\n-  assert (bitv.eq_vec(act, vec(1u)));\n+  check (bitv.eq_vec(act, vec(1u)));\n }\n \n fn test_10_elements() {\n   auto act;\n \n   // all 0\n   act = bitv.create(10u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n   act = bitv.create(10u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n   act = bitv.create(10u, false);\n@@ -40,7 +40,7 @@ fn test_10_elements() {\n   bitv.set(act, 2u, true);\n   bitv.set(act, 3u, true);\n   bitv.set(act, 4u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n   act = bitv.create(10u, false);\n@@ -49,30 +49,30 @@ fn test_10_elements() {\n   bitv.set(act, 7u, true);\n   bitv.set(act, 8u, true);\n   bitv.set(act, 9u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n   act = bitv.create(10u, false);\n   bitv.set(act, 0u, true);\n   bitv.set(act, 3u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 9u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n+  check (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n }\n \n fn test_31_elements() {\n   auto act;\n \n   // all 0\n   act = bitv.create(31u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n   act = bitv.create(31u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -87,7 +87,7 @@ fn test_31_elements() {\n   bitv.set(act, 5u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 7u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -102,7 +102,7 @@ fn test_31_elements() {\n   bitv.set(act, 21u, true);\n   bitv.set(act, 22u, true);\n   bitv.set(act, 23u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -116,7 +116,7 @@ fn test_31_elements() {\n   bitv.set(act, 28u, true);\n   bitv.set(act, 29u, true);\n   bitv.set(act, 30u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -126,7 +126,7 @@ fn test_31_elements() {\n   bitv.set(act, 3u, true);\n   bitv.set(act, 17u, true);\n   bitv.set(act, 30u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n@@ -137,14 +137,14 @@ fn test_32_elements() {\n \n   // all 0\n   act = bitv.create(32u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n   act = bitv.create(32u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -159,7 +159,7 @@ fn test_32_elements() {\n   bitv.set(act, 5u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 7u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -174,7 +174,7 @@ fn test_32_elements() {\n   bitv.set(act, 21u, true);\n   bitv.set(act, 22u, true);\n   bitv.set(act, 23u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -189,7 +189,7 @@ fn test_32_elements() {\n   bitv.set(act, 29u, true);\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -200,7 +200,7 @@ fn test_32_elements() {\n   bitv.set(act, 17u, true);\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n@@ -211,15 +211,15 @@ fn test_33_elements() {\n \n   // all 0\n   act = bitv.create(33u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // all 1\n   act = bitv.create(33u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n@@ -235,7 +235,7 @@ fn test_33_elements() {\n   bitv.set(act, 5u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 7u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n@@ -251,7 +251,7 @@ fn test_33_elements() {\n   bitv.set(act, 21u, true);\n   bitv.set(act, 22u, true);\n   bitv.set(act, 23u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n@@ -267,7 +267,7 @@ fn test_33_elements() {\n   bitv.set(act, 29u, true);\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n@@ -280,7 +280,7 @@ fn test_33_elements() {\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n   bitv.set(act, 32u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,"}, {"sha": "10f5e727110cff7ed67073dca5f3cde53a571065", "filename": "src/test/run-pass/lib-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-box.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,9 +4,9 @@ import std.Box;\n fn main() {\n     auto x = @3;\n     auto y = @3;\n-    assert (Box.ptr_eq[int](x, x));\n-    assert (Box.ptr_eq[int](y, y));\n-    assert (!Box.ptr_eq[int](x, y));\n-    assert (!Box.ptr_eq[int](y, x));\n+    check (Box.ptr_eq[int](x, x));\n+    check (Box.ptr_eq[int](y, y));\n+    check (!Box.ptr_eq[int](x, y));\n+    check (!Box.ptr_eq[int](y, x));\n }\n "}, {"sha": "9fd177eaf9601f11236b032c919837ef55133e69", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,125 +5,125 @@ import std.deque;\n \n fn test_simple() {\n   let deque.t[int] d = deque.create[int]();\n-  assert (d.size() == 0u);\n+  check (d.size() == 0u);\n   d.add_front(17);\n   d.add_front(42);\n   d.add_back(137);\n-  assert (d.size() == 3u);\n+  check (d.size() == 3u);\n   d.add_back(137);\n-  assert (d.size() == 4u);\n+  check (d.size() == 4u);\n \n   log d.peek_front();\n-  assert (d.peek_front() == 42);\n+  check (d.peek_front() == 42);\n \n   log d.peek_back();\n-  assert (d.peek_back() == 137);\n+  check (d.peek_back() == 137);\n \n   let int i = d.pop_front();\n   log i;\n-  assert (i == 42);\n+  check (i == 42);\n \n   i = d.pop_back();\n   log i;\n-  assert (i == 137);\n+  check (i == 137);\n \n   i = d.pop_back();\n   log i;\n-  assert (i == 137);\n+  check (i == 137);\n \n   i = d.pop_back();\n   log i;\n-  assert (i == 17);\n+  check (i == 17);\n \n-  assert (d.size() == 0u);\n+  check (d.size() == 0u);\n   d.add_back(3);\n-  assert (d.size() == 1u);\n+  check (d.size() == 1u);\n   d.add_front(2);\n-  assert (d.size() == 2u);\n+  check (d.size() == 2u);\n   d.add_back(4);\n-  assert (d.size() == 3u);\n+  check (d.size() == 3u);\n   d.add_front(1);\n-  assert (d.size() == 4u);\n+  check (d.size() == 4u);\n \n   log d.get(0);\n   log d.get(1);\n   log d.get(2);\n   log d.get(3);\n \n-  assert (d.get(0) == 1);\n-  assert (d.get(1) == 2);\n-  assert (d.get(2) == 3);\n-  assert (d.get(3) == 4);\n+  check (d.get(0) == 1);\n+  check (d.get(1) == 2);\n+  check (d.get(2) == 3);\n+  check (d.get(3) == 4);\n }\n \n fn test_boxes(@int a, @int b, @int c, @int d) {\n   let deque.t[@int] deq = deque.create[@int]();\n-  assert (deq.size() == 0u);\n+  check (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);\n   deq.add_back(c);\n-  assert (deq.size() == 3u);\n+  check (deq.size() == 3u);\n   deq.add_back(d);\n-  assert (deq.size() == 4u);\n+  check (deq.size() == 4u);\n \n-  assert (deq.peek_front() == b);\n-  assert (deq.peek_back() == d);\n+  check (deq.peek_front() == b);\n+  check (deq.peek_back() == d);\n \n-  assert (deq.pop_front() == b);\n-  assert (deq.pop_back() == d);\n-  assert (deq.pop_back() == c);\n-  assert (deq.pop_back() == a);\n+  check (deq.pop_front() == b);\n+  check (deq.pop_back() == d);\n+  check (deq.pop_back() == c);\n+  check (deq.pop_back() == a);\n \n-  assert (deq.size() == 0u);\n+  check (deq.size() == 0u);\n   deq.add_back(c);\n-  assert (deq.size() == 1u);\n+  check (deq.size() == 1u);\n   deq.add_front(b);\n-  assert (deq.size() == 2u);\n+  check (deq.size() == 2u);\n   deq.add_back(d);\n-  assert (deq.size() == 3u);\n+  check (deq.size() == 3u);\n   deq.add_front(a);\n-  assert (deq.size() == 4u);\n+  check (deq.size() == 4u);\n \n-  assert (deq.get(0) == a);\n-  assert (deq.get(1) == b);\n-  assert (deq.get(2) == c);\n-  assert (deq.get(3) == d);\n+  check (deq.get(0) == a);\n+  check (deq.get(1) == b);\n+  check (deq.get(2) == c);\n+  check (deq.get(3) == d);\n }\n \n type eqfn[T] = fn(&T a, &T b) -> bool;\n \n fn test_parameterized[T](eqfn[T] e, &T a, &T b, &T c, &T d) {\n   let deque.t[T] deq = deque.create[T]();\n-  assert (deq.size() == 0u);\n+  check (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);\n   deq.add_back(c);\n-  assert (deq.size() == 3u);\n+  check (deq.size() == 3u);\n   deq.add_back(d);\n-  assert (deq.size() == 4u);\n+  check (deq.size() == 4u);\n \n-  assert (e(deq.peek_front(), b));\n-  assert (e(deq.peek_back(), d));\n+  check (e(deq.peek_front(), b));\n+  check (e(deq.peek_back(), d));\n \n-  assert (e(deq.pop_front(), b));\n-  assert (e(deq.pop_back(), d));\n-  assert (e(deq.pop_back(), c));\n-  assert (e(deq.pop_back(), a));\n+  check (e(deq.pop_front(), b));\n+  check (e(deq.pop_back(), d));\n+  check (e(deq.pop_back(), c));\n+  check (e(deq.pop_back(), a));\n \n-  assert (deq.size() == 0u);\n+  check (deq.size() == 0u);\n   deq.add_back(c);\n-  assert (deq.size() == 1u);\n+  check (deq.size() == 1u);\n   deq.add_front(b);\n-  assert (deq.size() == 2u);\n+  check (deq.size() == 2u);\n   deq.add_back(d);\n-  assert (deq.size() == 3u);\n+  check (deq.size() == 3u);\n   deq.add_front(a);\n-  assert (deq.size() == 4u);\n+  check (deq.size() == 4u);\n \n-  assert (e(deq.get(0), a));\n-  assert (e(deq.get(1), b));\n-  assert (e(deq.get(2), c));\n-  assert (e(deq.get(3), d));\n+  check (e(deq.get(0), a));\n+  check (e(deq.get(1), b));\n+  check (e(deq.get(2), c));\n+  check (e(deq.get(3), d));\n }\n \n tag taggy {"}, {"sha": "2e85abf6509f23ac9589c25fe55989a0c6f2e312", "filename": "src/test/run-pass/lib-int.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,22 +4,22 @@ import std._int;\n import std._str.eq;\n \n fn test_to_str() {\n-  assert (eq(_int.to_str(0, 10u), \"0\"));\n-  assert (eq(_int.to_str(1, 10u), \"1\"));\n-  assert (eq(_int.to_str(-1, 10u), \"-1\"));\n-  assert (eq(_int.to_str(255, 16u), \"ff\"));\n-  assert (eq(_int.to_str(100, 10u), \"100\"));\n+  check (eq(_int.to_str(0, 10u), \"0\"));\n+  check (eq(_int.to_str(1, 10u), \"1\"));\n+  check (eq(_int.to_str(-1, 10u), \"-1\"));\n+  check (eq(_int.to_str(255, 16u), \"ff\"));\n+  check (eq(_int.to_str(100, 10u), \"100\"));\n }\n \n fn test_pow() {\n-  assert (_int.pow(0, 0u) == 1);\n-  assert (_int.pow(0, 1u) == 0);\n-  assert (_int.pow(0, 2u) == 0);\n-  assert (_int.pow(-1, 0u) == -1);\n-  assert (_int.pow(1, 0u) == 1);\n-  assert (_int.pow(-3, 2u) == 9);\n-  assert (_int.pow(-3, 3u) == -27);\n-  assert (_int.pow(4, 9u) == 262144);\n+  check (_int.pow(0, 0u) == 1);\n+  check (_int.pow(0, 1u) == 0);\n+  check (_int.pow(0, 2u) == 0);\n+  check (_int.pow(-1, 0u) == -1);\n+  check (_int.pow(1, 0u) == 1);\n+  check (_int.pow(-3, 2u) == 9);\n+  check (_int.pow(-3, 3u) == -27);\n+  check (_int.pow(4, 9u) == 262144);\n }\n \n fn main() {"}, {"sha": "7102c91e36e32cdac1e7ed967295d3991c7ec9f0", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -20,7 +20,7 @@ fn test_simple(str tmpfilebase) {\n   let io.reader inp = io.file_reader(tmpfile);\n   let str frood2 = inp.read_c_str();\n   log frood2;\n-  assert (_str.eq(frood, frood2));\n+  check (_str.eq(frood, frood2));\n }\n \n fn main(vec[str] argv) {"}, {"sha": "4c8afa7d547a3dd570c29e7fcd1c5fe5abc50f85", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -28,19 +28,19 @@ fn test_simple() {\n   let map.hashmap[uint, uint] hm_uu = map.mk_hashmap[uint, uint](hasher_uint,\n                                                                  eqer_uint);\n \n-  assert (hm_uu.insert(10u, 12u));\n-  assert (hm_uu.insert(11u, 13u));\n-  assert (hm_uu.insert(12u, 14u));\n+  check (hm_uu.insert(10u, 12u));\n+  check (hm_uu.insert(11u, 13u));\n+  check (hm_uu.insert(12u, 14u));\n \n-  assert (hm_uu.get(11u) == 13u);\n-  assert (hm_uu.get(12u) == 14u);\n-  assert (hm_uu.get(10u) == 12u);\n+  check (hm_uu.get(11u) == 13u);\n+  check (hm_uu.get(12u) == 14u);\n+  check (hm_uu.get(10u) == 12u);\n \n-  assert (!hm_uu.insert(12u, 14u));\n-  assert (hm_uu.get(12u) == 14u);\n+  check (!hm_uu.insert(12u, 14u));\n+  check (hm_uu.get(12u) == 14u);\n \n-  assert (!hm_uu.insert(12u, 12u));\n-  assert (hm_uu.get(12u) == 12u);\n+  check (!hm_uu.insert(12u, 12u));\n+  check (hm_uu.get(12u) == 12u);\n \n \n   let str ten = \"ten\";\n@@ -51,61 +51,61 @@ fn test_simple() {\n \n   let map.hashmap[str, uint] hm_su = map.mk_hashmap[str, uint](hasher_str,\n                                                                eqer_str);\n-  assert (hm_su.insert(\"ten\", 12u));\n-  assert (hm_su.insert(eleven, 13u));\n-  assert (hm_su.insert(\"twelve\", 14u));\n+  check (hm_su.insert(\"ten\", 12u));\n+  check (hm_su.insert(eleven, 13u));\n+  check (hm_su.insert(\"twelve\", 14u));\n \n-  assert (hm_su.get(eleven) == 13u);\n+  check (hm_su.get(eleven) == 13u);\n \n-  assert (hm_su.get(\"eleven\") == 13u);\n-  assert (hm_su.get(\"twelve\") == 14u);\n-  assert (hm_su.get(\"ten\") == 12u);\n+  check (hm_su.get(\"eleven\") == 13u);\n+  check (hm_su.get(\"twelve\") == 14u);\n+  check (hm_su.get(\"ten\") == 12u);\n \n-  assert (!hm_su.insert(\"twelve\", 14u));\n-  assert (hm_su.get(\"twelve\") == 14u);\n+  check (!hm_su.insert(\"twelve\", 14u));\n+  check (hm_su.get(\"twelve\") == 14u);\n \n-  assert (!hm_su.insert(\"twelve\", 12u));\n-  assert (hm_su.get(\"twelve\") == 12u);\n+  check (!hm_su.insert(\"twelve\", 12u));\n+  check (hm_su.get(\"twelve\") == 12u);\n \n \n   log \"uint -> str\";\n \n   let map.hashmap[uint, str] hm_us = map.mk_hashmap[uint, str](hasher_uint,\n                                                                eqer_uint);\n \n-  assert (hm_us.insert(10u, \"twelve\"));\n-  assert (hm_us.insert(11u, \"thirteen\"));\n-  assert (hm_us.insert(12u, \"fourteen\"));\n+  check (hm_us.insert(10u, \"twelve\"));\n+  check (hm_us.insert(11u, \"thirteen\"));\n+  check (hm_us.insert(12u, \"fourteen\"));\n \n-  assert (_str.eq(hm_us.get(11u), \"thirteen\"));\n-  assert (_str.eq(hm_us.get(12u), \"fourteen\"));\n-  assert (_str.eq(hm_us.get(10u), \"twelve\"));\n+  check (_str.eq(hm_us.get(11u), \"thirteen\"));\n+  check (_str.eq(hm_us.get(12u), \"fourteen\"));\n+  check (_str.eq(hm_us.get(10u), \"twelve\"));\n \n-  assert (!hm_us.insert(12u, \"fourteen\"));\n-  assert (_str.eq(hm_us.get(12u), \"fourteen\"));\n+  check (!hm_us.insert(12u, \"fourteen\"));\n+  check (_str.eq(hm_us.get(12u), \"fourteen\"));\n \n-  assert (!hm_us.insert(12u, \"twelve\"));\n-  assert (_str.eq(hm_us.get(12u), \"twelve\"));\n+  check (!hm_us.insert(12u, \"twelve\"));\n+  check (_str.eq(hm_us.get(12u), \"twelve\"));\n \n \n   log \"str -> str\";\n \n   let map.hashmap[str, str] hm_ss = map.mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n-  assert (hm_ss.insert(ten, \"twelve\"));\n-  assert (hm_ss.insert(eleven, \"thirteen\"));\n-  assert (hm_ss.insert(twelve, \"fourteen\"));\n+  check (hm_ss.insert(ten, \"twelve\"));\n+  check (hm_ss.insert(eleven, \"thirteen\"));\n+  check (hm_ss.insert(twelve, \"fourteen\"));\n \n-  assert (_str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-  assert (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-  assert (_str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n+  check (_str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n+  check (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  check (_str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n \n-  assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-  assert (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  check (!hm_ss.insert(\"twelve\", \"fourteen\"));\n+  check (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n \n-  assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-  assert (_str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+  check (!hm_ss.insert(\"twelve\", \"twelve\"));\n+  check (_str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n \n   log \"*** finished test_simple\";\n }\n@@ -135,7 +135,7 @@ fn test_growth() {\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm_uu.insert(i, i * i));\n+    check (hm_uu.insert(i, i * i));\n     log \"inserting \" + _uint.to_str(i, 10u)\n       + \" -> \" + _uint.to_str(i * i, 10u);\n     i += 1u;\n@@ -147,12 +147,12 @@ fn test_growth() {\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm_uu.get(i), 10u);\n-    assert (hm_uu.get(i) == i * i);\n+    check (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n-  assert (hm_uu.insert(num_to_insert, 17u));\n-  assert (hm_uu.get(num_to_insert) == 17u);\n+  check (hm_uu.insert(num_to_insert, 17u));\n+  check (hm_uu.get(num_to_insert) == 17u);\n \n   log \"-----\";\n \n@@ -162,7 +162,7 @@ fn test_growth() {\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm_uu.get(i), 10u);\n-    assert (hm_uu.get(i) == i * i);\n+    check (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n@@ -176,7 +176,7 @@ fn test_growth() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm_ss.insert(_uint.to_str(i, 2u), _uint.to_str(i * i, 2u)));\n+    check (hm_ss.insert(_uint.to_str(i, 2u), _uint.to_str(i * i, 2u)));\n     log \"inserting \\\"\" + _uint.to_str(i, 2u)\n       + \"\\\" -> \\\"\" + _uint.to_str(i * i, 2u) + \"\\\"\";\n     i += 1u;\n@@ -191,15 +191,15 @@ fn test_growth() {\n       + \"\\\") = \\\"\"\n       + hm_ss.get(_uint.to_str(i, 2u)) + \"\\\"\";\n \n-    assert (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n+    check (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n                    _uint.to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n-  assert (hm_ss.insert(_uint.to_str(num_to_insert, 2u),\n+  check (hm_ss.insert(_uint.to_str(num_to_insert, 2u),\n                       _uint.to_str(17u, 2u)));\n \n-  assert (_str.eq(hm_ss.get(_uint.to_str(num_to_insert, 2u)),\n+  check (_str.eq(hm_ss.get(_uint.to_str(num_to_insert, 2u)),\n                  _uint.to_str(17u, 2u)));\n \n   log \"-----\";\n@@ -210,7 +210,7 @@ fn test_growth() {\n   while (i < num_to_insert) {\n     log \"get(\\\"\" + _uint.to_str(i, 2u) + \"\\\") = \\\"\"\n       + hm_ss.get(_uint.to_str(i, 2u)) + \"\\\"\";\n-    assert (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n+    check (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n                    _uint.to_str(i * i, 2u)));\n     i += 1u;\n   }\n@@ -230,23 +230,23 @@ fn test_removal() {\n     ret (u / 2u) * 2u;\n   }\n \n-  assert (hash(0u) == hash(1u));\n-  assert (hash(2u) == hash(3u));\n-  assert (hash(0u) != hash(2u));\n+  check (hash(0u) == hash(1u));\n+  check (hash(2u) == hash(3u));\n+  check (hash(0u) != hash(2u));\n \n   let map.hashfn[uint] hasher = hash;\n   let map.eqfn[uint] eqer = eq;\n   let map.hashmap[uint, uint] hm = map.mk_hashmap[uint, uint](hasher, eqer);\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm.insert(i, i * i));\n+    check (hm.insert(i, i * i));\n     log \"inserting \" + _uint.to_str(i, 10u)\n       + \" -> \" + _uint.to_str(i * i, 10u);\n     i += 1u;\n   }\n \n-  assert (hm.size() == num_to_insert);\n+  check (hm.size() == num_to_insert);\n \n   log \"-----\";\n   log \"removing evens\";\n@@ -260,7 +260,7 @@ fn test_removal() {\n     let util.option[uint] v = hm.remove(i);\n     alt (v) {\n       case (util.some[uint](u)) {\n-        assert (u == (i * i));\n+        check (u == (i * i));\n       }\n       case (util.none[uint]()) { fail; }\n     }\n@@ -273,15 +273,15 @@ fn test_removal() {\n     i += 2u;\n   }\n \n-  assert (hm.size() == (num_to_insert / 2u));\n+  check (hm.size() == (num_to_insert / 2u));\n \n   log \"-----\";\n \n   i = 1u;\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    assert (hm.get(i) == i * i);\n+    check (hm.get(i) == i * i);\n     i += 2u;\n   }\n \n@@ -296,29 +296,29 @@ fn test_removal() {\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    assert (hm.get(i) == i * i);\n+    check (hm.get(i) == i * i);\n     i += 2u;\n   }\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm.insert(i, i * i));\n+    check (hm.insert(i, i * i));\n     log \"inserting \" + _uint.to_str(i, 10u)\n       + \" -> \" + _uint.to_str(i * i, 10u);\n     i += 2u;\n   }\n \n-  assert (hm.size() == num_to_insert);\n+  check (hm.size() == num_to_insert);\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    assert (hm.get(i) == i * i);\n+    check (hm.get(i) == i * i);\n     i += 1u;\n   }\n \n@@ -329,13 +329,13 @@ fn test_removal() {\n \n   log \"-----\";\n \n-  assert (hm.size() == num_to_insert);\n+  check (hm.size() == num_to_insert);\n \n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    assert (hm.get(i) == i * i);\n+    check (hm.get(i) == i * i);\n     i += 1u;\n   }\n "}, {"sha": "57e3cdc856b6d95b9e1d80d0522495044c7af5e4", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -69,13 +69,13 @@ fn main() {\n     auto tests = fips_180_1_tests + wikipedia_tests;\n \n     fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n-        assert (_vec.len[u8](v0) == _vec.len[u8](v1));\n+        check (_vec.len[u8](v0) == _vec.len[u8](v1));\n         auto len = _vec.len[u8](v0);\n         auto i = 0u;\n         while (i < len) {\n             auto a = v0.(i);\n             auto b = v1.(i);\n-            assert (a == b);\n+            check (a == b);\n             i += 1u;\n         }\n     }"}, {"sha": "e2c3465cdfd47f23a4036f6ce7e2b2a9ac9ff903", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -10,7 +10,7 @@ fn check_sort(vec[int] v1, vec[int] v2) {\n   auto i = 0u;\n   while (i < len) {\n     log v3.(i);\n-    assert (v3.(i) == v2.(i));\n+    check (v3.(i) == v2.(i));\n     i += 1u;\n   }\n }"}, {"sha": "bd5cb036a699fb4fd1a74f442321cbc5c205efe3", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,8 +8,8 @@ fn main() {\n     auto s = \"hello\";\n     auto sb = _str.rustrt.str_buf(s);\n     auto s_cstr = _str.rustrt.str_from_cstr(sb);\n-    assert (_str.eq(s_cstr, s));\n+    check (_str.eq(s_cstr, s));\n     auto s_buf = _str.rustrt.str_from_buf(sb, 5u);\n-    assert (_str.eq(s_buf, s));\n+    check (_str.eq(s_buf, s));\n }\n "}, {"sha": "835c08a20f68e5d07f4b3a5dba63098644c98461", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -2,22 +2,22 @@ use std;\n import std._str;\n \n fn test_bytes_len() {\n-  assert (_str.byte_len(\"\") == 0u);\n-  assert (_str.byte_len(\"hello world\") == 11u);\n-  assert (_str.byte_len(\"\\x63\") == 1u);\n-  assert (_str.byte_len(\"\\xa2\") == 2u);\n-  assert (_str.byte_len(\"\\u03c0\") == 2u);\n-  assert (_str.byte_len(\"\\u2620\") == 3u);\n-  assert (_str.byte_len(\"\\U0001d11e\") == 4u);\n+  check (_str.byte_len(\"\") == 0u);\n+  check (_str.byte_len(\"hello world\") == 11u);\n+  check (_str.byte_len(\"\\x63\") == 1u);\n+  check (_str.byte_len(\"\\xa2\") == 2u);\n+  check (_str.byte_len(\"\\u03c0\") == 2u);\n+  check (_str.byte_len(\"\\u2620\") == 3u);\n+  check (_str.byte_len(\"\\U0001d11e\") == 4u);\n }\n \n fn test_index_and_rindex() {\n-  assert (_str.index(\"hello\", 'e' as u8) == 1);\n-  assert (_str.index(\"hello\", 'o' as u8) == 4);\n-  assert (_str.index(\"hello\", 'z' as u8) == -1);\n-  assert (_str.rindex(\"hello\", 'l' as u8) == 3);\n-  assert (_str.rindex(\"hello\", 'h' as u8) == 0);\n-  assert (_str.rindex(\"hello\", 'z' as u8) == -1);\n+  check(_str.index(\"hello\", 'e' as u8) == 1);\n+  check(_str.index(\"hello\", 'o' as u8) == 4);\n+  check(_str.index(\"hello\", 'z' as u8) == -1);\n+  check(_str.rindex(\"hello\", 'l' as u8) == 3);\n+  check(_str.rindex(\"hello\", 'h' as u8) == 0);\n+  check(_str.rindex(\"hello\", 'z' as u8) == -1);\n }\n \n fn test_split() {\n@@ -30,7 +30,7 @@ fn test_split() {\n       log z;\n     }\n     log \"comparing: \" + v.(i) + \" vs. \" + k;\n-    assert (_str.eq(v.(i), k));\n+    check(_str.eq(v.(i), k));\n   }\n   t(\"abc.hello.there\", '.', 0, \"abc\");\n   t(\"abc.hello.there\", '.', 1, \"hello\");\n@@ -46,7 +46,7 @@ fn test_find() {\n     let int j = _str.find(haystack,needle);\n     log \"searched for \" + needle;\n     log j;\n-    assert (i == j);\n+    check (i == j);\n   }\n   t(\"this is a simple\", \"is a\", 5);\n   t(\"this is a simple\", \"is z\", -1);\n@@ -57,7 +57,7 @@ fn test_find() {\n \n fn test_substr() {\n   fn t(&str a, &str b, int start) {\n-    assert (_str.eq(_str.substr(a, start as uint,\n+    check(_str.eq(_str.substr(a, start as uint,\n                               _str.byte_len(b)), b));\n   }\n \n@@ -68,7 +68,7 @@ fn test_substr() {\n \n fn test_concat() {\n   fn t(&vec[str] v, &str s) {\n-    assert (_str.eq(_str.concat(v), s));\n+    check(_str.eq(_str.concat(v), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \"youknowI'mnogood\");\n@@ -79,7 +79,7 @@ fn test_concat() {\n \n fn test_connect() {\n   fn t(&vec[str] v, &str sep, &str s) {\n-    assert (_str.eq(_str.connect(v, sep), s));\n+    check(_str.eq(_str.connect(v, sep), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \" \", \"you know I'm no good\");\n@@ -95,7 +95,7 @@ fn test_to_upper() {\n   auto input = \"abcDEF\" + unicode + \"xyz:.;\";\n   auto expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n   auto actual = _str.to_upper(input);\n-  assert (_str.eq(expected, actual));\n+  check (_str.eq(expected, actual));\n }\n \n "}, {"sha": "356ca374092c2be02202933a1b2307c5cec4d3d6", "filename": "src/test/run-pass/lib-uint.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-uint.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,44 +4,44 @@ use std;\n import std._uint;\n \n fn main() {\n-  assert (_uint.next_power_of_two(0u) == 0u);\n-  assert (_uint.next_power_of_two(1u) == 1u);\n-  assert (_uint.next_power_of_two(2u) == 2u);\n-  assert (_uint.next_power_of_two(3u) == 4u);\n-  assert (_uint.next_power_of_two(4u) == 4u);\n-  assert (_uint.next_power_of_two(5u) == 8u);\n-  assert (_uint.next_power_of_two(6u) == 8u);\n-  assert (_uint.next_power_of_two(7u) == 8u);\n-  assert (_uint.next_power_of_two(8u) == 8u);\n-  assert (_uint.next_power_of_two(9u) == 16u);\n-  assert (_uint.next_power_of_two(10u) == 16u);\n-  assert (_uint.next_power_of_two(11u) == 16u);\n-  assert (_uint.next_power_of_two(12u) == 16u);\n-  assert (_uint.next_power_of_two(13u) == 16u);\n-  assert (_uint.next_power_of_two(14u) == 16u);\n-  assert (_uint.next_power_of_two(15u) == 16u);\n-  assert (_uint.next_power_of_two(16u) == 16u);\n-  assert (_uint.next_power_of_two(17u) == 32u);\n-  assert (_uint.next_power_of_two(18u) == 32u);\n-  assert (_uint.next_power_of_two(19u) == 32u);\n-  assert (_uint.next_power_of_two(20u) == 32u);\n-  assert (_uint.next_power_of_two(21u) == 32u);\n-  assert (_uint.next_power_of_two(22u) == 32u);\n-  assert (_uint.next_power_of_two(23u) == 32u);\n-  assert (_uint.next_power_of_two(24u) == 32u);\n-  assert (_uint.next_power_of_two(25u) == 32u);\n-  assert (_uint.next_power_of_two(26u) == 32u);\n-  assert (_uint.next_power_of_two(27u) == 32u);\n-  assert (_uint.next_power_of_two(28u) == 32u);\n-  assert (_uint.next_power_of_two(29u) == 32u);\n-  assert (_uint.next_power_of_two(30u) == 32u);\n-  assert (_uint.next_power_of_two(31u) == 32u);\n-  assert (_uint.next_power_of_two(32u) == 32u);\n-  assert (_uint.next_power_of_two(33u) == 64u);\n-  assert (_uint.next_power_of_two(34u) == 64u);\n-  assert (_uint.next_power_of_two(35u) == 64u);\n-  assert (_uint.next_power_of_two(36u) == 64u);\n-  assert (_uint.next_power_of_two(37u) == 64u);\n-  assert (_uint.next_power_of_two(38u) == 64u);\n-  assert (_uint.next_power_of_two(39u) == 64u);\n+  check (_uint.next_power_of_two(0u) == 0u);\n+  check (_uint.next_power_of_two(1u) == 1u);\n+  check (_uint.next_power_of_two(2u) == 2u);\n+  check (_uint.next_power_of_two(3u) == 4u);\n+  check (_uint.next_power_of_two(4u) == 4u);\n+  check (_uint.next_power_of_two(5u) == 8u);\n+  check (_uint.next_power_of_two(6u) == 8u);\n+  check (_uint.next_power_of_two(7u) == 8u);\n+  check (_uint.next_power_of_two(8u) == 8u);\n+  check (_uint.next_power_of_two(9u) == 16u);\n+  check (_uint.next_power_of_two(10u) == 16u);\n+  check (_uint.next_power_of_two(11u) == 16u);\n+  check (_uint.next_power_of_two(12u) == 16u);\n+  check (_uint.next_power_of_two(13u) == 16u);\n+  check (_uint.next_power_of_two(14u) == 16u);\n+  check (_uint.next_power_of_two(15u) == 16u);\n+  check (_uint.next_power_of_two(16u) == 16u);\n+  check (_uint.next_power_of_two(17u) == 32u);\n+  check (_uint.next_power_of_two(18u) == 32u);\n+  check (_uint.next_power_of_two(19u) == 32u);\n+  check (_uint.next_power_of_two(20u) == 32u);\n+  check (_uint.next_power_of_two(21u) == 32u);\n+  check (_uint.next_power_of_two(22u) == 32u);\n+  check (_uint.next_power_of_two(23u) == 32u);\n+  check (_uint.next_power_of_two(24u) == 32u);\n+  check (_uint.next_power_of_two(25u) == 32u);\n+  check (_uint.next_power_of_two(26u) == 32u);\n+  check (_uint.next_power_of_two(27u) == 32u);\n+  check (_uint.next_power_of_two(28u) == 32u);\n+  check (_uint.next_power_of_two(29u) == 32u);\n+  check (_uint.next_power_of_two(30u) == 32u);\n+  check (_uint.next_power_of_two(31u) == 32u);\n+  check (_uint.next_power_of_two(32u) == 32u);\n+  check (_uint.next_power_of_two(33u) == 64u);\n+  check (_uint.next_power_of_two(34u) == 64u);\n+  check (_uint.next_power_of_two(35u) == 64u);\n+  check (_uint.next_power_of_two(36u) == 64u);\n+  check (_uint.next_power_of_two(37u) == 64u);\n+  check (_uint.next_power_of_two(38u) == 64u);\n+  check (_uint.next_power_of_two(39u) == 64u);\n }"}, {"sha": "1d6b61a1900e3d630a56771fadc4cb36327db0e4", "filename": "src/test/run-pass/lib-vec-str-conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -21,14 +21,14 @@ fn test_simple() {\n   let uint n1 = _str.byte_len(s1);\n   let uint n2 = _vec.len[u8](v);\n \n-  assert (n1 == n2);\n+  check (n1 == n2);\n \n   while (i < n1) {\n     let u8 a = s1.(i);\n     let u8 b = s2.(i);\n     log a;\n     log b;\n-    assert (a == b);\n+    check (a == b);\n     i += 1u;\n   }\n "}, {"sha": "4d6166483bcf2cbec936c67b9a014ad832db1535", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -2,10 +2,10 @@ use std;\n \n fn test_init_elt() {\n   let vec[uint] v = std._vec.init_elt[uint](5u, 3u);\n-  assert (std._vec.len[uint](v) == 3u);\n-  assert (v.(0) == 5u);\n-  assert (v.(1) == 5u);\n-  assert (v.(2) == 5u);\n+  check (std._vec.len[uint](v) == 3u);\n+  check (v.(0) == 5u);\n+  check (v.(1) == 5u);\n+  check (v.(2) == 5u);\n }\n \n fn id(uint x) -> uint {\n@@ -14,20 +14,20 @@ fn id(uint x) -> uint {\n fn test_init_fn() {\n   let fn(uint)->uint op = id;\n   let vec[uint] v = std._vec.init_fn[uint](op, 5u);\n-  assert (std._vec.len[uint](v) == 5u);\n-  assert (v.(0) == 0u);\n-  assert (v.(1) == 1u);\n-  assert (v.(2) == 2u);\n-  assert (v.(3) == 3u);\n-  assert (v.(4) == 4u);\n+  check (std._vec.len[uint](v) == 5u);\n+  check (v.(0) == 0u);\n+  check (v.(1) == 1u);\n+  check (v.(2) == 2u);\n+  check (v.(3) == 3u);\n+  check (v.(4) == 4u);\n }\n \n fn test_slice() {\n   let vec[int] v = vec(1,2,3,4,5);\n   auto v2 = std._vec.slice[int](v, 2u, 4u);\n-  assert (std._vec.len[int](v2) == 2u);\n-  assert (v2.(0) == 3);\n-  assert (v2.(1) == 4);\n+  check (std._vec.len[int](v2) == 2u);\n+  check (v2.(0) == 3);\n+  check (v2.(1) == 4);\n }\n \n fn test_map() {\n@@ -37,7 +37,7 @@ fn test_map() {\n   let vec[int] s = std._vec.map[int, int](op, v);\n   let int i = 0;\n   while (i < 5) {\n-    assert (v.(i) * v.(i) == s.(i));\n+    check (v.(i) * v.(i) == s.(i));\n     i += 1;\n   }\n }\n@@ -51,7 +51,7 @@ fn test_map2() {\n \n   auto i = 0;\n   while (i < 5) {\n-    assert (v0.(i) * v1.(i) == u.(i));\n+    check (v0.(i) * v1.(i) == u.(i));\n     i += 1;\n   }\n }"}, {"sha": "2b517f78fe3de79a16ab62875ef29fbdc7e26a6a", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,30 +6,30 @@ fn main() {\n     y += i;\n   }\n   log y;\n-  assert (y == 6);\n+  check (y == 6);\n \n   auto s = \"hello there\";\n   let int i = 0;\n   for (u8 c in s) {\n     if (i == 0) {\n-      assert (c == ('h' as u8));\n+      check (c == ('h' as u8));\n     }\n     if (i == 1) {\n-      assert (c == ('e' as u8));\n+      check (c == ('e' as u8));\n     }\n     if (i == 2) {\n-      assert (c == ('l' as u8));\n+      check (c == ('l' as u8));\n     }\n     if (i == 3) {\n-      assert (c == ('l' as u8));\n+      check (c == ('l' as u8));\n     }\n     if (i == 4) {\n-      assert (c == ('o' as u8));\n+      check (c == ('o' as u8));\n     }\n     // ...\n     i += 1;\n     log i;\n     log c;\n   }\n-  assert (i == 11);\n+  check(i == 11);\n }"}, {"sha": "f83ab4fb6a328f1037a7a067e9b198d06103fa73", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -19,5 +19,5 @@ fn main() {\n   let int y <- p;\n   log \"transmission complete\";\n   log y;\n-  assert (y == 500);\n+  check (y == 500);\n }"}, {"sha": "887fb39125eef28d8b5ca28f70d544008f87bf78", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -13,5 +13,5 @@ fn main() {\n   grow(v);\n   auto len = std._vec.len[int](v);\n   log len;\n-  assert (len == (3 as uint));\n+  check (len == (3 as uint));\n }"}, {"sha": "19c2c074f9d7cb5fc0b5749430606c03b267e653", "filename": "src/test/run-pass/native-opaque-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,5 +3,5 @@ native mod libc {\n }\n \n fn main() {\n-  assert (true);\n+  check (true);\n }"}, {"sha": "6e0dac37b8fe62f3708323192c7430a6a5dae552", "filename": "src/test/run-pass/obj-as.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-as.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -15,10 +15,10 @@ type small = obj {\n fn main() {\n \n   let big b = big();\n-  assert (b.one() == 1);\n-  assert (b.two() == 2);\n-  assert (b.three() == 3);\n+  check (b.one() == 1);\n+  check (b.two() == 2);\n+  check (b.three() == 3);\n \n   let small s = b as small;\n-  assert (s.one() == 1);\n+  check (s.one() == 1);\n }\n\\ No newline at end of file"}, {"sha": "167b15fbaeec403c65107c87219d6668e4504e22", "filename": "src/test/run-pass/obj-dtor-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -14,5 +14,5 @@ fn main() {\n   {\n     auto x = foo(mbox);\n   }\n-  assert ((*mbox) == 11);\n+  check ((*mbox) == 11);\n }\n\\ No newline at end of file"}, {"sha": "3d633e725eb92b4bab6dccc3e4b9279433af5ebf", "filename": "src/test/run-pass/obj-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -29,6 +29,6 @@ fn main() {\n   log \"parent waiting for shutdown\";\n   i <- p;\n   log \"received int\";\n-  assert (i == 10);\n+  check (i == 10);\n   log \"int is OK, child-dtor ran as expected\";\n }\n\\ No newline at end of file"}, {"sha": "f777b56c15a1551eda841711cbc98394d1fe6685", "filename": "src/test/run-pass/obj-self-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-3.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -19,11 +19,11 @@ fn main() {\n   let int i = 0;\n \n   i = a.m1(i);\n-  assert (i == 1);\n+  check (i == 1);\n   i = a.m2(i);\n-  assert (i == 2);\n+  check (i == 2);\n   i = a.m3(i);\n-  assert (i == 4);\n+  check (i == 4);\n }\n \n "}, {"sha": "85143c7924dd60077e123dc9c72f3a29361f6f2f", "filename": "src/test/run-pass/obj-with-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,5 +7,5 @@ fn main() {\n   }\n   auto b = buf(vec(1 as u8, 2 as u8, 3 as u8));\n   log b.get(1);\n-  assert (b.get(1) == (2 as u8));\n+  check (b.get(1) == (2 as u8));\n }"}, {"sha": "d99ebb0449a3187c2e81594df52b1e77f0810a00", "filename": "src/test/run-pass/opeq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fopeq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fopeq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fopeq.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,18 +5,18 @@ fn main() {\n \n   x *= 2;\n   log x;\n-  assert (x == 2);\n+  check (x == 2);\n \n   x += 3;\n   log x;\n-  assert (x == 5);\n+  check (x == 5);\n \n   x *= x;\n   log x;\n-  assert (x == 25);\n+  check (x == 25);\n \n   x /= 5;\n   log x;\n-  assert (x == 5);\n+  check (x == 5);\n }\n "}, {"sha": "2c028eba627c6ea93ee731fd4b874e041bf8e764", "filename": "src/test/run-pass/operator-associativity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-associativity.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,4 +1,4 @@\n // Testcase for issue #130, operator associativity.\n fn main() -> () {\n-  assert ((3 * 5 / 2) == 7);\n+  check ((3 * 5 / 2) == 7);\n }"}, {"sha": "15fa142a77a5a76acc3331965dd42b15a5c17cf3", "filename": "src/test/run-pass/readalias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Freadalias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Freadalias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freadalias.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,7 +3,7 @@\n type point = rec(int x, int y, int z);\n \n fn f(&point p) {\n-  assert (p.z == 12);\n+  check (p.z == 12);\n }\n \n fn main() {"}, {"sha": "db81278b35c7b63c7a47d7d3ab6ad2ed3209404b", "filename": "src/test/run-pass/rec-extend.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frec-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frec-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-extend.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,12 +8,12 @@ fn main() {\n   let point right = rec(x=origin.x + 10 with origin);\n   let point up = rec(y=origin.y + 10 with origin);\n \n-  assert (origin.x == 0);\n-  assert (origin.y == 0);\n+  check(origin.x == 0);\n+  check(origin.y == 0);\n \n-  assert (right.x == 10);\n-  assert (right.y == 0);\n+  check(right.x == 10);\n+  check(right.y == 0);\n \n-  assert (up.x == 0);\n-  assert (up.y == 10);\n+  check(up.x == 0);\n+  check(up.y == 10);\n }"}, {"sha": "e25439a974daa1aa5e6da4b1b75fb49d33f38c89", "filename": "src/test/run-pass/rec-tup.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frec-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frec-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-tup.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,22 +4,22 @@ type point = rec(int x, int y);\n type rect = tup(point, point);\n \n fn f(rect r, int x1, int y1, int x2, int y2) {\n-  assert (r._0.x == x1);\n-  assert (r._0.y == y1);\n-  assert (r._1.x == x2);\n-  assert (r._1.y == y2);\n+  check (r._0.x == x1);\n+  check (r._0.y == y1);\n+  check (r._1.x == x2);\n+  check (r._1.y == y2);\n }\n \n fn main() {\n   let rect r = tup( rec(x=10, y=20),\n                     rec(x=11, y=22) );\n-  assert (r._0.x == 10);\n-  assert (r._0.y == 20);\n-  assert (r._1.x == 11);\n-  assert (r._1.y == 22);\n+  check (r._0.x == 10);\n+  check (r._0.y == 20);\n+  check (r._1.x == 11);\n+  check (r._1.y == 22);\n   let rect r2 = r;\n   let int x = r2._0.x;\n-  assert (x == 10);\n+  check (x == 10);\n   f(r, 10, 20, 11, 22);\n   f(r2, 10, 20, 11, 22);\n }"}, {"sha": "0f6b7d79196ab3641a468dc6f73709a71a588910", "filename": "src/test/run-pass/rec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,21 +3,21 @@\n type rect = rec(int x, int y, int w, int h);\n \n fn f(rect r, int x, int y, int w, int h) {\n-  assert (r.x == x);\n-  assert (r.y == y);\n-  assert (r.w == w);\n-  assert (r.h == h);\n+  check (r.x == x);\n+  check (r.y == y);\n+  check (r.w == w);\n+  check (r.h == h);\n }\n \n fn main() {\n   let rect r = rec(x=10, y=20, w=100, h=200);\n-  assert (r.x == 10);\n-  assert (r.y == 20);\n-  assert (r.w == 100);\n-  assert (r.h == 200);\n+  check (r.x == 10);\n+  check (r.y == 20);\n+  check (r.w == 100);\n+  check (r.h == 200);\n   let rect r2 = r;\n   let int x = r2.x;\n-  assert (x == 10);\n+  check (x == 10);\n   f(r, 10, 20, 100, 200);\n   f(r2, 10, 20, 100, 200);\n }"}, {"sha": "e5c3da1b88f21972df30ca96893c4389ba71bba7", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -74,9 +74,9 @@ fn test_rotate() {\n         mychan <| val;\n \n         auto x <- myport;\n-        assert (x.val1 == i as u32);\n-        assert (x.val2 == i as u32);\n-        assert (x.val3 == i as u32);\n+        check (x.val1 == i as u32);\n+        check (x.val2 == i as u32);\n+        check (x.val3 == i as u32);\n     }\n }\n \n@@ -96,9 +96,9 @@ fn test_rotate_grow() {\n \n         for each (uint i in _uint.range(0u, 10u)) {\n             auto x <- myport;\n-            assert (x.val1 == i as u32);\n-            assert (x.val2 == i as u32);\n-            assert (x.val3 == i as u32);\n+            check (x.val1 == i as u32);\n+            check (x.val2 == i as u32);\n+            check (x.val3 == i as u32);\n         }\n     }\n }"}, {"sha": "e8bc4788c9a59e64a9f77fc95fb877043cb005fe", "filename": "src/test/run-pass/seq-compare.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,16 +1,16 @@\n // xfail-boot\n fn main() {\n-  assert (\"hello\" < \"hellr\");\n-  assert (\"hello \" > \"hello\");\n-  assert (\"hello\" != \"there\");\n+  check (\"hello\" < \"hellr\");\n+  check (\"hello \" > \"hello\");\n+  check (\"hello\" != \"there\");\n \n-  assert (vec(1,2,3,4) > vec(1,2,3));\n-  assert (vec(1,2,3) < vec(1,2,3,4));\n-  assert (vec(1,2,4,4) > vec(1,2,3,4));\n-  assert (vec(1,2,3,4) < vec(1,2,4,4));\n-  assert (vec(1,2,3) <= vec(1,2,3));\n-  assert (vec(1,2,3) <= vec(1,2,3,3));\n-  assert (vec(1,2,3,4) > vec(1,2,3));\n-  assert (vec(1,2,3) == vec(1,2,3));\n-  assert (vec(1,2,3) != vec(1,1,3));\n+  check (vec(1,2,3,4) > vec(1,2,3));\n+  check (vec(1,2,3) < vec(1,2,3,4));\n+  check (vec(1,2,4,4) > vec(1,2,3,4));\n+  check (vec(1,2,3,4) < vec(1,2,4,4));\n+  check (vec(1,2,3) <= vec(1,2,3));\n+  check (vec(1,2,3) <= vec(1,2,3,3));\n+  check (vec(1,2,3,4) > vec(1,2,3));\n+  check (vec(1,2,3) == vec(1,2,3));\n+  check (vec(1,2,3) != vec(1,1,3));\n }"}, {"sha": "c1d96cc3debee5e453521dee215d62da88e6f02b", "filename": "src/test/run-pass/stateful-obj.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstateful-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstateful-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstateful-obj.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -14,10 +14,10 @@ obj counter(mutable int x) {\n \n fn main() {\n   auto y = counter(0);\n-  assert (y.hello() == 12345);\n+  check (y.hello() == 12345);\n   log y.get();\n   y.incr();\n   y.incr();\n   log y.get();\n-  assert (y.get() == 2);\n+  check (y.get() == 2);\n }"}, {"sha": "da4ca07fc26a28c02d3936d0ea1143a6e6e9dd83", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -7,7 +7,7 @@ fn test1() {\n   let str s = \"hello\";\n   s += \"world\";\n   log s;\n-  assert (s.(9) == ('d' as u8));\n+  check(s.(9) == ('d' as u8));\n }\n \n fn test2() {\n@@ -20,8 +20,8 @@ fn test2() {\n   log a;\n   log b;\n \n-  assert (_str.eq(a, \"abcABCabc\"));\n-  assert (_str.eq(b, \"ABCabcABC\"));\n+  check (_str.eq(a, \"abcABCabc\"));\n+  check (_str.eq(b, \"ABCabcABC\"));\n }\n \n fn main() {"}, {"sha": "c906a23ef6b008b03b0a47bcef045e1d8790301c", "filename": "src/test/run-pass/str-concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-concat.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,5 +5,5 @@ fn main() {\n   let str b = \"world\";\n   let str s = a + b;\n   log s;\n-  assert (s.(9) == ('d' as u8));\n+  check(s.(9) == ('d' as u8));\n }"}, {"sha": "06bc8b74621c56305b8e9b8410e706981ec34fc2", "filename": "src/test/run-pass/str-growth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-growth.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,14 +1,14 @@\n fn main() {\n     auto s = \"a\";\n     s += \"b\";\n-    assert (s.(0) == ('a' as u8));\n-    assert (s.(1) == ('b' as u8));\n+    check (s.(0) == ('a' as u8));\n+    check (s.(1) == ('b' as u8));\n \n     s += \"c\";\n     s += \"d\";\n-    assert (s.(0) == ('a' as u8));\n-    assert (s.(1) == ('b' as u8));\n-    assert (s.(2) == ('c' as u8));\n-    assert (s.(3) == ('d' as u8));\n+    check (s.(0) == ('a' as u8));\n+    check (s.(1) == ('b' as u8));\n+    check (s.(2) == ('c' as u8));\n+    check (s.(3) == ('d' as u8));\n }\n "}, {"sha": "9793799a97c7a8477f5a1413acdc14846ff2254f", "filename": "src/test/run-pass/str-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-idx.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,5 +3,5 @@ fn main() {\n   auto s = \"hello\";\n   let u8 c = s.(4);\n   log c;\n-  assert (c == (0x6f as u8));\n+  check (c == (0x6f as u8));\n }"}, {"sha": "3049faec6b6b817c151db132f8259a83bdbdb3e9", "filename": "src/test/run-pass/structured-compare-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,6 +4,6 @@ tag taggy {\n }\n \n fn main() {\n-    assert (bar <= bar);\n+    check (bar <= bar);\n }\n "}, {"sha": "fed4b1837303a8345898820847cfa0d833d5248f", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,15 +6,15 @@ tag foo {\n fn main() {\n   auto a = tup(1,2,3);\n   auto b = tup(1,2,3);\n-  assert (a == b);\n-  assert (a != tup(1,2,4));\n-  assert (a < tup(1,2,4));\n-  assert (a <= tup(1,2,4));\n-  assert (tup(1,2,4) > a);\n-  assert (tup(1,2,4) >= a);\n+  check (a == b);\n+  check (a != tup(1,2,4));\n+  check (a < tup(1,2,4));\n+  check (a <= tup(1,2,4));\n+  check (tup(1,2,4) > a);\n+  check (tup(1,2,4) >= a);\n   auto x = large;\n   auto y = small;\n-  assert (x != y);\n-  assert (x == large);\n-  assert (x != small);\n+  check (x != y);\n+  check (x == large);\n+  check (x != small);\n }\n\\ No newline at end of file"}, {"sha": "82b3e658a63786f997a3d2e9aebd17ac257159d4", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,7 +6,7 @@ import std._str;\n fn test(str actual, str expected) {\n   log actual;\n   log expected;\n-  assert (_str.eq(actual, expected));\n+  check (_str.eq(actual, expected));\n }\n \n fn main() {"}, {"sha": "e3f89a7f262f47076b86646d66f5cbfe35ef260f", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,7 +9,7 @@ fn f() {\n   auto x = red(1,2);\n   auto y = green;\n   // FIXME: needs structural equality test working.\n-  // assert (x != y);\n+  // check (x != y);\n }\n \n fn main() {"}, {"sha": "795a105ad92721b449fc6ba1f41d3c4c33f3fd41", "filename": "src/test/run-pass/tail-cps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-cps.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n fn checktrue(bool res) -> bool {\n-  assert (res);\n+  check(res);\n   ret true;\n }\n "}, {"sha": "345a322eb171a8ed11ef7115394b3f4d78d42646", "filename": "src/test/run-pass/tail-direct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftail-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftail-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-direct.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n fn main() {\n-  assert (even(42));\n-  assert (odd(45));\n+  check(even(42));\n+  check(odd(45));\n }\n \n fn even(int n) -> bool {"}, {"sha": "e1473548122c9132e800823afbdb9609dc627bb3", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -16,5 +16,5 @@ fn test05() {\n     let int value <- po;\n     value <- po;\n     value <- po;\n-    assert (value == 30);\n+    check(value == 30);\n }"}, {"sha": "16c4b93b8db58790cff85b419f8f2e0633f88efd", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -14,9 +14,9 @@ fn test_rec() {\n   let r r1;\n   r1 <- po;\n \n-  assert (r1.val0 == 0);\n-  assert (r1.val1 == 1u8);\n-  assert (r1.val2 == '2');\n+  check (r1.val0 == 0);\n+  check (r1.val1 == 1u8);\n+  check (r1.val2 == '2');\n }\n \n fn test_vec() {\n@@ -29,9 +29,9 @@ fn test_vec() {\n   let vec[int] v1;\n   v1 <- po;\n \n-  assert (v1.(0) == 0);\n-  assert (v1.(1) == 1);\n-  assert (v1.(2) == 2);\n+  check (v1.(0) == 0);\n+  check (v1.(1) == 1);\n+  check (v1.(2) == 2);\n }\n \n fn test_str() {\n@@ -44,10 +44,10 @@ fn test_str() {\n   let str s1;\n   s1 <- po;\n \n-  assert (s1.(0) as u8 == 't' as u8);\n-  assert (s1.(1) as u8 == 'e' as u8);\n-  assert (s1.(2) as u8 == 's' as u8);\n-  assert (s1.(3) as u8 == 't' as u8);\n+  check (s1.(0) as u8 == 't' as u8);\n+  check (s1.(1) as u8 == 'e' as u8);\n+  check (s1.(2) as u8 == 's' as u8);\n+  check (s1.(3) as u8 == 't' as u8);\n }\n \n fn test_tup() {\n@@ -62,9 +62,9 @@ fn test_tup() {\n   let t t1;\n   t1 <- po;\n \n-  assert (t0._0 == 0);\n-  assert (t0._1 == 1u8);\n-  assert (t0._2 == '2');\n+  check (t0._0 == 0);\n+  check (t0._1 == 1u8);\n+  check (t0._2 == '2');\n }\n \n fn test_tag() {\n@@ -84,11 +84,11 @@ fn test_tag() {\n   let t t1;\n \n   t1 <- po;\n-  assert (t1 == tag1);\n+  check (t1 == tag1);\n   t1 <- po;\n-  assert (t1 == tag2(10));\n+  check (t1 == tag2(10));\n   t1 <- po;\n-  assert (t1 == tag3(10, 11u8, 'A'));\n+  check (t1 == tag3(10, 11u8, 'A'));\n }\n \n fn test_chan() {\n@@ -109,7 +109,7 @@ fn test_chan() {\n   let int i;\n   i <- po0;\n \n-  assert (i == 10);\n+  check (i == 10);\n }\n \n fn main() {"}, {"sha": "712557212c1ff0d64dd05aee64c7bfc1ab011fd2", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -58,7 +58,7 @@ fn test00(bool is_multithreaded) {\n     }\n     \n     log \"Completed: Final number is: \";\n-    // assert (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) * \n+    // check (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) * \n     //       number_of_messages));\n-    assert (sum == 480);\n+    check (sum == 480);\n }"}, {"sha": "121a9e6e1345cf2c7591feef9f597c3527d72ca7", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -28,5 +28,5 @@ fn test00() {\n     r <- p; sum += r; log (r);\n     r <- p; sum += r; log (r);\n     \n-    assert (sum == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);\n+    check (sum == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);\n }\n\\ No newline at end of file"}, {"sha": "d0f3994effb2db3ecd5db2fa72b43e07a913a994", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -21,5 +21,5 @@ fn test00() {\n         i += 1;\n     }\n     \n-    assert (sum == ((number_of_messages * (number_of_messages - 1)) / 2));\n+    check (sum == ((number_of_messages * (number_of_messages - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "74b40a9098af86df6b28b6da5a9412fe4a4df6f5", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -32,7 +32,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    assert (sum == 1998000);\n-    // assert (sum == 4 * ((number_of_messages * \n+    check (sum == 1998000);\n+    // check (sum == 4 * ((number_of_messages * \n     //                   (number_of_messages - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "b5b95db9605f2b2f380b93411bdbd9be5075c88c", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -40,6 +40,6 @@ fn test00() {\n     join t2;\n     join t3;\n     \n-    assert (sum == (((number_of_messages * 4) * \n+    check (sum == (((number_of_messages * 4) * \n                    ((number_of_messages * 4) - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "a3876bdae5ab52781d84851120b0ed7bee548386", "filename": "src/test/run-pass/task-comm-8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -41,6 +41,6 @@ fn test00() {\n     join t2;\n     join t3;\n     \n-    assert (sum == (((number_of_messages * 4) * \n+    check (sum == (((number_of_messages * 4) * \n                    ((number_of_messages * 4) - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "a9ac1688cd25b4a6b15c43181d7850e1524150bb", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -29,5 +29,5 @@ fn test00() {\n             \n     join t0;\n     \n-    assert (sum == (number_of_messages * (number_of_messages - 1)) / 2);\n+    check (sum == (number_of_messages * (number_of_messages - 1)) / 2);\n }\n\\ No newline at end of file"}, {"sha": "aae788a5128c49450db5518162f9b746d7a56558", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -14,5 +14,5 @@ fn main() {\n   let () n;\n   n <- po;\n \n-  assert (n == ());\n+  check (n == ());\n }"}, {"sha": "0a91b98abdf8ed1a4230cfb3f86b6ae2ea79426c", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -58,7 +58,7 @@ fn test00(bool is_multithreaded) {\n     }\n     \n     log \"Completed: Final number is: \";\n-    assert (sum == number_of_messages * \n+    check (sum == number_of_messages * \n            (number_of_tasks * number_of_tasks + number_of_tasks) / 2);\n }\n "}, {"sha": "234066460eff3366cdf54bc7edd6a4c700435b54", "filename": "src/test/run-pass/tup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftup.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,17 +3,17 @@\n type point = tup(int, int);\n \n fn f(point p, int x, int y) {\n-  assert (p._0 == x);\n-  assert (p._1 == y);\n+  check (p._0 == x);\n+  check (p._1 == y);\n }\n \n fn main() {\n   let point p = tup(10, 20);\n-  assert (p._0 == 10);\n-  assert (p._1 == 20);\n+  check (p._0 == 10);\n+  check (p._1 == 20);\n   let point p2 = p;\n   let int x = p2._0;\n-  assert (x == 10);\n+  check (x == 10);\n   f(p, 10, 20);\n   f(p2, 10, 20);\n }"}, {"sha": "67b8b57871ff69d64e61b4215ebbc3a8f0823d5d", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,17 +5,17 @@ import size_of = std.sys.rustrt.size_of;\n use std;\n \n fn main() {\n-  assert (size_of[u8]() == (1 as uint));\n-  assert (size_of[u32]() == (4 as uint));\n-  assert (size_of[char]() == (4 as uint));\n-  assert (size_of[i8]() == (1 as uint));\n-  assert (size_of[i32]() == (4 as uint));\n-  assert (size_of[tup(u8,i8)]() == (2 as uint));\n-  assert (size_of[tup(u8,i8,u8)]() == (3 as uint));\n+  check (size_of[u8]() == (1 as uint));\n+  check (size_of[u32]() == (4 as uint));\n+  check (size_of[char]() == (4 as uint));\n+  check (size_of[i8]() == (1 as uint));\n+  check (size_of[i32]() == (4 as uint));\n+  check (size_of[tup(u8,i8)]() == (2 as uint));\n+  check (size_of[tup(u8,i8,u8)]() == (3 as uint));\n   // Alignment causes padding before the char and the u32.\n-  assert (size_of[tup(u8,i8,tup(char,u8),u32)]() == (16 as uint));\n-  assert (size_of[int]() == size_of[uint]());\n-  assert (size_of[tup(int,())]() == size_of[int]());\n-  assert (size_of[tup(int,(),())]() == size_of[int]());\n-  assert (size_of[int]() == size_of[rec(int x)]());\n+  check (size_of[tup(u8,i8,tup(char,u8),u32)]() == (16 as uint));\n+  check (size_of[int]() == size_of[uint]());\n+  check (size_of[tup(int,())]() == size_of[int]());\n+  check (size_of[tup(int,(),())]() == size_of[int]());\n+  check (size_of[int]() == size_of[rec(int x)]());\n }"}, {"sha": "1ff511aa6bb0c191350eba9b095bb8bd90d8897c", "filename": "src/test/run-pass/u32-decr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fu32-decr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fu32-decr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu32-decr.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     let u32 word = (200000u32);\n     word = word - (1u32);\n-    assert (word == (199999u32));\n+    check(word == (199999u32));\n }\n "}, {"sha": "f89325fc45f3a3f16fd841b162bff09fc90a9065", "filename": "src/test/run-pass/u8-incr-decr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   let u8 y = 35u8;  // 0x23\n   x = x + (7u8);    // 0x7\n   y = y - (9u8);    // 0x9\n-  assert (x == y);\n+  check(x == y);\n }"}, {"sha": "602d83c66c5c83aca16b6daa90bd54eb3d61a335", "filename": "src/test/run-pass/u8-incr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fu8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fu8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu8-incr.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ fn main() {\n   let u8 y = 12u8;\n   x = x + (1u8);\n   x = x - (1u8);\n-  assert (x == y);\n+  check(x == y);\n   // x = 14u8;\n   // x = x + 1u8;\n }"}, {"sha": "68f5fa9f680032ad367f2f696add750c9df21fd2", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,14 +6,14 @@ fn main() {\n   let char y_diaeresis = '\u00ff'; // 0xff\n   let char pi = '\u03a0';          // 0x3a0\n \n-  assert ((yen as int) == 0xa5);\n-  assert ((c_cedilla as int) == 0xe7);\n-  assert ((thorn as int) == 0xfe);\n-  assert ((y_diaeresis as int) == 0xff);\n-  assert ((pi as int) == 0x3a0);\n+  check ((yen as int) == 0xa5);\n+  check ((c_cedilla as int) == 0xe7);\n+  check ((thorn as int) == 0xfe);\n+  check ((y_diaeresis as int) == 0xff);\n+  check ((pi as int) == 0x3a0);\n \n-  assert ((pi as int) == ('\\u03a0' as int));\n-  assert (('\\x0a' as int) == ('\\n' as int));\n+  check ((pi as int) == ('\\u03a0' as int));\n+  check (('\\x0a' as int) == ('\\n' as int));\n \n   let str bhutan = \"\u0f60\u0f56\u0fb2\u0f74\u0f42\u0f0b\u0f61\u0f74\u0f63\u0f0d\";\n   let str japan = \"\u65e5\u672c\";\n@@ -28,7 +28,7 @@ fn main() {\n   let str austria_e = \"\\u00d6sterreich\";\n \n   let char oo = '\u00d6';\n-  assert ((oo as int) == 0xd6);\n+  check ((oo as int) == 0xd6);\n \n   fn check_str_eq(str a, str b) {\n     let int i = 0;\n@@ -37,7 +37,7 @@ fn main() {\n       log ab;\n       let u8 bb = b.(i);\n       log bb;\n-      assert (ab == bb);\n+      check(ab == bb);\n       i += 1;\n     }\n   }"}, {"sha": "08671093edfb75b1b905b37d40915e76c8d16b26", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,25 +9,25 @@ fn main() {\n   let vec[char] chs = vec('e', '\u00e9', '\u20ac', 0x10000 as char);\n   let str s = _str.from_chars(chs);\n \n-  assert (_str.byte_len(s) == 10u);\n-  assert (_str.char_len(s) == 4u);\n-  assert (_vec.len[char](_str.to_chars(s)) == 4u);\n-  assert (_str.eq(_str.from_chars(_str.to_chars(s)), s));\n-  assert (_str.char_at(s, 0u) == 'e');\n-  assert (_str.char_at(s, 1u) == '\u00e9');\n+  check(_str.byte_len(s) == 10u);\n+  check(_str.char_len(s) == 4u);\n+  check(_vec.len[char](_str.to_chars(s)) == 4u);\n+  check(_str.eq(_str.from_chars(_str.to_chars(s)), s));\n+  check(_str.char_at(s, 0u) == 'e');\n+  check(_str.char_at(s, 1u) == '\u00e9');\n \n-  assert (_str.is_utf8(_str.bytes(s)));\n-  assert (!_str.is_utf8(vec(0x80_u8)));\n-  assert (!_str.is_utf8(vec(0xc0_u8)));\n-  assert (!_str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n+  check(_str.is_utf8(_str.bytes(s)));\n+  check(!_str.is_utf8(vec(0x80_u8)));\n+  check(!_str.is_utf8(vec(0xc0_u8)));\n+  check(!_str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n \n   auto stack = \"a\u00d7c\u20ac\";\n-  assert (_str.pop_char(stack) == '\u20ac');\n-  assert (_str.pop_char(stack) == 'c');\n+  check(_str.pop_char(stack) == '\u20ac');\n+  check(_str.pop_char(stack) == 'c');\n   _str.push_char(stack, 'u');\n-  assert (_str.eq(stack, \"a\u00d7u\"));\n-  assert (_str.shift_char(stack) == 'a');\n-  assert (_str.shift_char(stack) == '\u00d7');\n+  check(_str.eq(stack, \"a\u00d7u\"));\n+  check(_str.shift_char(stack) == 'a');\n+  check(_str.shift_char(stack) == '\u00d7');\n   _str.unshift_char(stack, '\u00df');\n-  assert (_str.eq(stack, \"\u00dfu\"));\n+  check(_str.eq(stack, \"\u00dfu\"));\n }"}, {"sha": "0f9f56dd9541b834793b699628ed110147c4cd2f", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -15,9 +15,9 @@ fn fast_growth() {\n   v += vec(6,7,8,9,0);\n \n   log v.(9);\n-  assert (v.(0) == 1);\n-  assert (v.(7) == 8);\n-  assert (v.(9) == 0);\n+  check(v.(0) == 1);\n+  check(v.(7) == 8);\n+  check(v.(9) == 0);\n }\n \n fn slow_growth() {\n@@ -26,7 +26,7 @@ fn slow_growth() {\n   v += vec(17);\n \n   log v.(0);\n-  assert (v.(0) == 17);\n+  check (v.(0) == 17);\n }\n \n fn slow_growth2_helper(str s) {   // ref up: s\n@@ -52,29 +52,29 @@ fn slow_growth2_helper(str s) {   // ref up: s\n     let acc a = acc(v);           // ref up: a, v\n \n     log _vec.refcount[str](v);\n-    assert (_vec.refcount[str](v) == 2u);\n+    check (_vec.refcount[str](v) == 2u);\n \n     a.add(s);                     // ref up: mumble, s.  ref down: v\n \n     log _vec.refcount[str](v);\n     log _str.refcount(s);\n     log _str.refcount(mumble);\n \n-    assert (_vec.refcount[str](v) == 1u);\n-    assert (_str.refcount(s) == const_refcount);\n-    assert (_str.refcount(mumble) == const_refcount);\n+    check (_vec.refcount[str](v) == 1u);\n+    check (_str.refcount(s) == const_refcount);\n+    check (_str.refcount(mumble) == const_refcount);\n \n     log v.(0);\n     log _vec.len[str](v);\n-    assert (_str.eq(v.(0), mumble));\n-    assert (_vec.len[str](v) == 1u);\n+    check (_str.eq(v.(0), mumble));\n+    check (_vec.len[str](v) == 1u);\n   }                               // ref down: a, mumble, s, v\n \n   log _str.refcount(s);\n   log _str.refcount(mumble);\n \n-  assert (_str.refcount(s) == const_refcount);\n-  assert (_str.refcount(mumble) == const_refcount);\n+  check (_str.refcount(s) == const_refcount);\n+  check (_str.refcount(mumble) == const_refcount);\n \n   log mumble;\n   log ss;\n@@ -84,7 +84,7 @@ fn slow_growth2() {\n   let str s = \"hi\";               // ref up: s\n   slow_growth2_helper(s);\n   log _str.refcount(s);\n-  assert (_str.refcount(s) == const_refcount);\n+  check (_str.refcount(s) == const_refcount);\n }\n \n fn main() {"}, {"sha": "b6c52c3e08d7404656bd4ded8042eb8af0009040", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -5,7 +5,7 @@ fn main() {\n   let vec[int] b = vec(6,7,8,9,0);\n   let vec[int] v = a + b;\n   log v.(9);\n-  assert (v.(0) == 1);\n-  assert (v.(7) == 8);\n-  assert (v.(9) == 0);\n+  check(v.(0) == 1);\n+  check(v.(7) == 8);\n+  check(v.(9) == 0);\n }"}, {"sha": "fe2070306d5205efb80f2c035090108988ec3967", "filename": "src/test/run-pass/vec-growth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-growth.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,10 +4,10 @@ fn main() {\n     v += vec(3);\n     v += vec(4);\n     v += vec(5);\n-    assert (v.(0) == 1);\n-    assert (v.(1) == 2);\n-    assert (v.(2) == 3);\n-    assert (v.(3) == 4);\n-    assert (v.(4) == 5);\n+    check (v.(0) == 1);\n+    check (v.(1) == 2);\n+    check (v.(2) == 3);\n+    check (v.(3) == 4);\n+    check (v.(4) == 5);\n }\n "}, {"sha": "788489362fdc7e8d9fea93c5d89856009960edd8", "filename": "src/test/run-pass/vec-ref-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     log_err _vec.refcount[int](v);\n     log_err _vec.refcount[int](v);\n     log_err _vec.refcount[int](v);\n-    assert (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n-    assert (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n+    check (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n+    check (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n }\n "}, {"sha": "5517414230899055bab3cbc6accc81013175854a", "filename": "src/test/run-pass/vec-slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -4,6 +4,6 @@\n fn main() {\n   let vec[int] v = vec(1,2,3,4,5);\n   auto v2 = v.(1,2);\n-  assert (v2.(0) == 2);\n-  assert (v2.(1) == 3);\n+  check (v2.(0) == 2);\n+  check (v2.(1) == 3);\n }\n\\ No newline at end of file"}, {"sha": "67a41eabcf6e29a288726234f7d3961afd00fa04", "filename": "src/test/run-pass/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -2,12 +2,12 @@\n \n fn main() {\n   let vec[int] v = vec(10, 20);\n-  assert (v.(0) == 10);\n-  assert (v.(1) == 20);\n+  check (v.(0) == 10);\n+  check (v.(1) == 20);\n   let int x = 0;\n-  assert (v.(x) == 10);\n-  assert (v.(x + 1) == 20);\n+  check (v.(x) == 10);\n+  check (v.(x + 1) == 20);\n   x = x + 1;\n-  assert (v.(x) == 20);\n-  assert (v.(x-1) == 10);\n+  check (v.(x) == 20);\n+  check (v.(x-1) == 10);\n }"}, {"sha": "0e27f252ebb310e69e4cf3a7834d44fccef790f7", "filename": "src/test/run-pass/while-with-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -11,5 +11,5 @@ fn main() {\n       break; \n     }\n   }\n-  assert (i == 95);\n+  check(i == 95);\n }"}, {"sha": "8bf8140f315805566e42599cbe3c3a4f3960d9df", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08b443fffb1181d8d45ae5d061412f202dd4118/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=d08b443fffb1181d8d45ae5d061412f202dd4118", "patch": "@@ -9,5 +9,5 @@ fn f(& mutable point p) {\n fn main() {\n   let point x = rec(x=10, y=11, mutable z=12);\n   f(x);\n-  assert (x.z == 13);\n+  check (x.z == 13);\n }"}]}