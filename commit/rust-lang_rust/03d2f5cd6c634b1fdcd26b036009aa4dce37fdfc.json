{"sha": "03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZDJmNWNkNmM2MzRiMWZkY2QyNmIwMzYwMDlhYTRkY2UzN2ZkZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-22T07:26:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-22T07:26:58Z"}, "message": "Auto merge of #69332 - nnethercote:revert-u8to64_le-changes, r=michaelwoerister\n\nRevert `u8to64_le` changes from #68914.\n\n`SipHasher128`'s `u8to64_le` function was simplified in #68914.\nUnfortunately, the new version is slower, because it introduces `memcpy`\ncalls with non-statically-known lengths.\n\nThis commit reverts the change, and adds an explanatory comment (which\nis also added to `libcore/hash/sip.rs`). This barely affects\n`SipHasher128`'s speed because it doesn't use `u8to64_le` much, but it\ndoes result in `SipHasher128` once again being consistent with\n`libcore/hash/sip.rs`.\n\nr? @michaelwoerister", "tree": {"sha": "276884fec5a6f84d9fdf190a5f4babafe8a28d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/276884fec5a6f84d9fdf190a5f4babafe8a28d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc", "html_url": "https://github.com/rust-lang/rust/commit/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "html_url": "https://github.com/rust-lang/rust/commit/87e494c4cdf3f4f39d25ca008173f80688b8eb3d"}, {"sha": "100ff5a25666a1903113ecff0dc63ad84e5bdff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/100ff5a25666a1903113ecff0dc63ad84e5bdff7", "html_url": "https://github.com/rust-lang/rust/commit/100ff5a25666a1903113ecff0dc63ad84e5bdff7"}], "stats": {"total": 59, "additions": 46, "deletions": 13}, "files": [{"sha": "c4fbd9dbadaeab583543a35a56584e5ad29150d4", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc", "patch": "@@ -121,7 +121,9 @@ macro_rules! load_int_le {\n     }};\n }\n \n-/// Loads an u64 using up to 7 bytes of a byte slice.\n+/// Loads a u64 using up to 7 bytes of a byte slice. It looks clumsy but the\n+/// `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed\n+/// sizes and avoid calling `memcpy`, which is good for speed.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "af0e9f79fe1201cf8c9e554e576f9cf722c791eb", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=03d2f5cd6c634b1fdcd26b036009aa4dce37fdfc", "patch": "@@ -51,17 +51,48 @@ macro_rules! compress {\n     }};\n }\n \n-/// Loads up to 8 bytes from a byte-slice into a little-endian u64.\n-#[inline]\n-fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n-    assert!(len <= 8 && start + len <= buf.len());\n+/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) => {{\n+        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+        let mut data = 0 as $int_ty;\n+        ptr::copy_nonoverlapping(\n+            $buf.get_unchecked($i),\n+            &mut data as *mut _ as *mut u8,\n+            mem::size_of::<$int_ty>(),\n+        );\n+        data.to_le()\n+    }};\n+}\n \n-    let mut out = 0u64;\n-    unsafe {\n-        let out_ptr = &mut out as *mut _ as *mut u8;\n-        ptr::copy_nonoverlapping(buf.as_ptr().offset(start as isize), out_ptr, len);\n+/// Loads a u64 using up to 7 bytes of a byte slice. It looks clumsy but the\n+/// `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed\n+/// sizes and avoid calling `memcpy`, which is good for speed.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n     }\n-    out.to_le()\n+    debug_assert_eq!(i, len);\n+    out\n }\n \n impl SipHasher128 {\n@@ -243,7 +274,7 @@ impl Hasher for SipHasher128 {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n-            self.tail |= u8to64_le(msg, 0, cmp::min(length, needed)) << (8 * self.ntail);\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n                 self.ntail += length;\n                 return;\n@@ -261,7 +292,7 @@ impl Hasher for SipHasher128 {\n \n         let mut i = needed;\n         while i < len - left {\n-            let mi = u8to64_le(msg, i, 8);\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n \n             self.state.v3 ^= mi;\n             Sip24Rounds::c_rounds(&mut self.state);\n@@ -270,7 +301,7 @@ impl Hasher for SipHasher128 {\n             i += 8;\n         }\n \n-        self.tail = u8to64_le(msg, i, left);\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n         self.ntail = left;\n     }\n "}]}