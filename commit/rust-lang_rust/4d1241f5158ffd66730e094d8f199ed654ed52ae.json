{"sha": "4d1241f5158ffd66730e094d8f199ed654ed52ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMTI0MWY1MTU4ZmZkNjY3MzBlMDk0ZDhmMTk5ZWQ2NTRlZDUyYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-10T10:47:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-10T10:47:39Z"}, "message": "Auto merge of #69012 - Dylan-DPC:rollup-13qn0fq, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #68694 (Reduce the number of `RefCell`s in `InferCtxt`.)\n - #68966 (Improve performance of coherence checks)\n - #68976 (Make `num::NonZeroX::new` an unstable `const fn`)\n - #68992 (Correctly parse `mut a @ b`)\n - #69005 (Small graphviz improvements for the new dataflow framework)\n - #69006 (parser: Keep current and previous tokens precisely)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "911cdc3247d263b7f8364c275ebc04a2eb867e64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/911cdc3247d263b7f8364c275ebc04a2eb867e64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d1241f5158ffd66730e094d8f199ed654ed52ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1241f5158ffd66730e094d8f199ed654ed52ae", "html_url": "https://github.com/rust-lang/rust/commit/4d1241f5158ffd66730e094d8f199ed654ed52ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d1241f5158ffd66730e094d8f199ed654ed52ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "840bdc349d2885a5173269b653025192969cfebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/840bdc349d2885a5173269b653025192969cfebc", "html_url": "https://github.com/rust-lang/rust/commit/840bdc349d2885a5173269b653025192969cfebc"}, {"sha": "18c6d39b5500909f38da7b76d1c51d54300c535e", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c6d39b5500909f38da7b76d1c51d54300c535e", "html_url": "https://github.com/rust-lang/rust/commit/18c6d39b5500909f38da7b76d1c51d54300c535e"}], "stats": {"total": 1051, "additions": 606, "deletions": 445}, "files": [{"sha": "3ae8f0f7870c1a6bccad5bcbd63eb3d16b34d45f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -69,8 +69,9 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n \n                 /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n+                #[rustc_const_unstable(feature = \"const_nonzero_int_methods\", issue = \"53718\")]\n                 #[inline]\n-                pub fn new(n: $Int) -> Option<Self> {\n+                pub const fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n                         // SAFETY: we just checked that there's no `0`\n                         Some(unsafe { Self(n) })"}, {"sha": "a53e0012ca2210eee77bffc2b381eb3f90acf82b", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -597,6 +597,8 @@ pub enum RenderOption {\n     NoNodeLabels,\n     NoEdgeStyles,\n     NoNodeStyles,\n+\n+    Monospace,\n }\n \n /// Returns vec holding all the default render options.\n@@ -626,6 +628,14 @@ where\n     W: Write,\n {\n     writeln!(w, \"digraph {} {{\", g.graph_id().as_slice())?;\n+\n+    // Global graph properties\n+    if options.contains(&RenderOption::Monospace) {\n+        writeln!(w, r#\"    graph[fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    node[fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    edge[fontname=\"monospace\"];\"#)?;\n+    }\n+\n     for n in g.nodes().iter() {\n         write!(w, \"    \")?;\n         let id = g.node_id(n);"}, {"sha": "85fafa349151e42c339c3453daac54d8989cc294", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -317,7 +317,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 let r = self\n                     .infcx\n                     .unwrap()\n-                    .borrow_region_constraints()\n+                    .inner\n+                    .borrow_mut()\n+                    .unwrap_region_constraints()\n                     .opportunistic_resolve_var(self.tcx, vid);\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n@@ -621,7 +623,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n \n     /// Returns the universe in which `vid` is defined.\n     fn region_var_universe(&self, vid: ty::RegionVid) -> ty::UniverseIndex {\n-        self.infcx.unwrap().borrow_region_constraints().var_universe(vid)\n+        self.infcx.unwrap().inner.borrow_mut().unwrap_region_constraints().var_universe(vid)\n     }\n \n     /// Creates a canonical variable (with the given `info`)"}, {"sha": "9eb961255c29518ba5c2b8a369cdee92b3f9d1bd", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -74,8 +74,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         match (&a.kind, &b.kind) {\n             // Relate integral variables to other types\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n-                self.int_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .int_unification_table\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n@@ -95,8 +96,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n \n             // Relate floating-point variables to other types\n             (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n-                self.float_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .float_unification_table\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n@@ -131,8 +133,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             return Ok(a);\n         }\n \n-        let a = replace_if_possible(self.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(self.const_unification_table.borrow_mut(), b);\n+        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, a);\n+        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, b);\n \n         let a_is_expected = relation.a_is_expected();\n \n@@ -141,8 +143,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),\n                 ty::ConstKind::Infer(InferConst::Var(b_vid)),\n             ) => {\n-                self.const_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .const_unification_table\n                     .unify_var_var(a_vid, b_vid)\n                     .map_err(|e| const_unification_error(a_is_expected, e))?;\n                 return Ok(a);\n@@ -174,8 +177,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::ConstVid<'tcx>,\n         value: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        self.const_unification_table\n+        self.inner\n             .borrow_mut()\n+            .const_unification_table\n             .unify_var_value(\n                 vid,\n                 ConstVarValue {\n@@ -196,8 +200,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::IntVid,\n         val: ty::IntVarValue,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.int_unification_table\n+        self.inner\n             .borrow_mut()\n+            .int_unification_table\n             .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n@@ -212,8 +217,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::FloatVid,\n         val: ast::FloatTy,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.float_unification_table\n+        self.inner\n             .borrow_mut()\n+            .float_unification_table\n             .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n@@ -260,7 +266,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_unknown());\n+        debug_assert!(self.infcx.inner.borrow_mut().type_variables.probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -280,7 +286,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n             a_ty, dir, b_vid, b_ty\n         );\n-        self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n+        self.infcx.inner.borrow_mut().type_variables.instantiate(b_vid, b_ty);\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(\n@@ -338,7 +344,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n \n-        let for_universe = match self.infcx.type_variables.borrow_mut().probe(for_vid) {\n+        let for_universe = match self.infcx.inner.borrow_mut().type_variables.probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n                 panic!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n             }\n@@ -350,7 +356,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n             for_universe,\n             ambient_variance,\n             needs_wf: false,\n@@ -502,17 +508,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // us from creating infinitely sized types.\n         match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n-                let vid = variables.root_var(vid);\n-                let sub_vid = variables.sub_root_var(vid);\n+                let vid = self.infcx.inner.borrow_mut().type_variables.root_var(vid);\n+                let sub_vid = self.infcx.inner.borrow_mut().type_variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n                     Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n-                    match variables.probe(vid) {\n+                    let probe = self.infcx.inner.borrow_mut().type_variables.probe(vid);\n+                    match probe {\n                         TypeVariableValue::Known { value: u } => {\n-                            drop(variables);\n                             debug!(\"generalize: known value {:?}\", u);\n                             self.relate(&u, &u)\n                         }\n@@ -536,8 +541,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 ty::Covariant | ty::Contravariant => (),\n                             }\n \n-                            let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(self.for_universe, false, origin);\n+                            let origin =\n+                                *self.infcx.inner.borrow_mut().type_variables.var_origin(vid);\n+                            let new_var_id = self.infcx.inner.borrow_mut().type_variables.new_var(\n+                                self.for_universe,\n+                                false,\n+                                origin,\n+                            );\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n@@ -612,7 +622,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n         match c.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n                     ConstVariableValue::Known { value: u } => self.relate(&u, &u),"}, {"sha": "018bbe035431e9e4f1cc84d2bff67eee000884b6", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -72,14 +72,14 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n-                infcx.type_variables.borrow_mut().equate(a_id, b_id);\n+                infcx.inner.borrow_mut().type_variables.equate(a_id, b_id);\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n@@ -105,7 +105,12 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         let origin = Subtype(box self.fields.trace.clone());\n-        self.fields.infcx.borrow_region_constraints().make_eqregion(origin, a, b);\n+        self.fields\n+            .infcx\n+            .inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .make_eqregion(origin, a, b);\n         Ok(a)\n     }\n "}, {"sha": "0d7fce7eac6c528c834bd180cc654151a067489b", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -47,9 +47,12 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n                 if ty.walk().any(|inner_ty| {\n                     inner_ty == self.target_ty\n                         || match (&inner_ty.kind, &self.target_ty.kind) {\n-                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n-                                self.infcx.type_variables.borrow_mut().sub_unified(a_vid, b_vid)\n-                            }\n+                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n+                                .infcx\n+                                .inner\n+                                .borrow_mut()\n+                                .type_variables\n+                                .sub_unified(a_vid, b_vid),\n                             _ => false,\n                         }\n                 }) {\n@@ -166,7 +169,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n-            let ty_vars = self.type_variables.borrow();\n+            let ty_vars = &self.inner.borrow().type_variables;\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n                 let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n@@ -224,7 +227,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-            let ty_vars = self.type_variables.borrow();\n+            let ty_vars = &self.inner.borrow().type_variables;\n             let getter = move |ty_vid| {\n                 let var_origin = ty_vars.var_origin(ty_vid);\n                 if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {"}, {"sha": "0190989267bb459e9d8819b8747b09eb9f2c7894", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -154,14 +154,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n+                let opt_ty = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n                 self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n                 self.infcx\n-                    .int_unification_table\n+                    .inner\n                     .borrow_mut()\n+                    .int_unification_table\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n@@ -170,8 +171,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n             ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n                 self.infcx\n-                    .float_unification_table\n+                    .inner\n                     .borrow_mut()\n+                    .float_unification_table\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n@@ -225,8 +227,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n-                let opt_ct =\n-                    self.infcx.const_unification_table.borrow_mut().probe_value(v).val.known();\n+                let opt_ct = self\n+                    .infcx\n+                    .inner\n+                    .borrow_mut()\n+                    .const_unification_table\n+                    .probe_value(v)\n+                    .val\n+                    .known();\n                 return self.freshen_const(\n                     opt_ct,\n                     ty::InferConst::Var(v),"}, {"sha": "d0b7bb32b9815cdd46806a4c94a12729db86f39a", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -8,11 +8,10 @@ use super::{ConstVariableOrigin, RegionVariableOrigin};\n use rustc_data_structures::unify as ut;\n use ut::UnifyKey;\n \n-use std::cell::RefMut;\n use std::ops::Range;\n \n fn const_vars_since_snapshot<'tcx>(\n-    mut table: RefMut<'_, ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>>,\n+    table: &mut ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>,\n     snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n ) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n     let range = table.vars_since_snapshot(snapshot);\n@@ -82,23 +81,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // going to be popped, so we will have to\n                     // eliminate any references to them.\n \n-                    let type_vars = self\n-                        .type_variables\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.type_snapshot);\n-                    let int_vars = self\n-                        .int_unification_table\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.int_snapshot);\n-                    let float_vars = self\n-                        .float_unification_table\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.float_snapshot);\n-                    let region_vars = self\n-                        .borrow_region_constraints()\n+                    let mut inner = self.inner.borrow_mut();\n+                    let type_vars =\n+                        inner.type_variables.vars_since_snapshot(&snapshot.type_snapshot);\n+                    let int_vars =\n+                        inner.int_unification_table.vars_since_snapshot(&snapshot.int_snapshot);\n+                    let float_vars =\n+                        inner.float_unification_table.vars_since_snapshot(&snapshot.float_snapshot);\n+                    let region_vars = inner\n+                        .unwrap_region_constraints()\n                         .vars_since_snapshot(&snapshot.region_constraints_snapshot);\n                     let const_vars = const_vars_since_snapshot(\n-                        self.const_unification_table.borrow_mut(),\n+                        &mut inner.const_unification_table,\n                         &snapshot.const_snapshot,\n                     );\n \n@@ -166,7 +160,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     // variables to their binding anyhow, we know\n                     // that it is unbound, so we can just return\n                     // it.\n-                    debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_unknown());\n+                    debug_assert!(\n+                        self.infcx.inner.borrow_mut().type_variables.probe(vid).is_unknown()\n+                    );\n                     ty\n                 }\n             }"}, {"sha": "6ef92132bc7034f19b0b9ce06d422ff41ebe5170", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -66,7 +66,12 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(box self.fields.trace.clone());\n-        Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n+            self.tcx(),\n+            origin,\n+            a,\n+            b,\n+        ))\n     }\n \n     fn consts("}, {"sha": "1b0f399ca33927058263aea7fbada44bb57f2e69", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return Ok(());\n         }\n \n-        self.borrow_region_constraints().leak_check(\n+        self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,\n             placeholder_map,"}, {"sha": "df475af1151aaea7abd54da33a63879197ebe1fd", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -56,8 +56,8 @@ where\n     }\n \n     let infcx = this.infcx();\n-    let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-    let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+    let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+    let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n     match (&a.kind, &b.kind) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to"}, {"sha": "6a699f803c7b84124084d5edc723694f99688fd3", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -66,7 +66,12 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(box self.fields.trace.clone());\n-        Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n+            self.tcx(),\n+            origin,\n+            a,\n+            b,\n+        ))\n     }\n \n     fn consts("}, {"sha": "be58de996a5dec2cb21626592728798ba1fdbdc8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 181, "deletions": 155, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -29,7 +29,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n-use std::cell::{Cell, Ref, RefCell, RefMut};\n+use std::cell::{Cell, Ref, RefCell};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n@@ -105,6 +105,89 @@ impl SuppressRegionErrors {\n     }\n }\n \n+/// This type contains all the things within `InferCtxt` that sit within a\n+/// `RefCell` and are involved with taking/rolling back snapshots. Snapshot\n+/// operations are hot enough that we want only one call to `borrow_mut` per\n+/// call to `start_snapshot` and `rollback_to`.\n+pub struct InferCtxtInner<'tcx> {\n+    /// Cache for projections. This cache is snapshotted along with the infcx.\n+    ///\n+    /// Public so that `traits::project` can use it.\n+    pub projection_cache: traits::ProjectionCache<'tcx>,\n+\n+    /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n+    /// that might instantiate a general type variable have an order,\n+    /// represented by its upper and lower bounds.\n+    type_variables: type_variable::TypeVariableTable<'tcx>,\n+\n+    /// Map from const parameter variable to the kind of const it represents.\n+    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+\n+    /// Map from integral variable to the kind of integer it represents.\n+    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n+\n+    /// Map from floating variable to the kind of float it represents.\n+    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n+\n+    /// Tracks the set of region variables and the constraints between them.\n+    /// This is initially `Some(_)` but when\n+    /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n+    /// -- further attempts to perform unification, etc., may fail if new\n+    /// region constraints would've been added.\n+    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n+\n+    /// A set of constraints that regionck must validate. Each\n+    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// outlive the lifetime 'a\". These constraints derive from\n+    /// instantiated type parameters. So if you had a struct defined\n+    /// like\n+    ///\n+    ///     struct Foo<T:'static> { ... }\n+    ///\n+    /// then in some expression `let x = Foo { ... }` it will\n+    /// instantiate the type parameter `T` with a fresh type `$0`. At\n+    /// the same time, it will record a region obligation of\n+    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// can't generally check these things right away because we have\n+    /// to wait until types are resolved.)\n+    ///\n+    /// These are stored in a map keyed to the id of the innermost\n+    /// enclosing fn body / static initializer expression. This is\n+    /// because the location where the obligation was incurred can be\n+    /// relevant with respect to which sublifetime assumptions are in\n+    /// place. The reason that we store under the fn-id, and not\n+    /// something more fine-grained, is so that it is easier for\n+    /// regionck to be sure that it has found *all* the region\n+    /// obligations (otherwise, it's easy to fail to walk to a\n+    /// particular node-id).\n+    ///\n+    /// Before running `resolve_regions_and_report_errors`, the creator\n+    /// of the inference context is expected to invoke\n+    /// `process_region_obligations` (defined in `self::region_obligations`)\n+    /// for each body-id in this map, which will process the\n+    /// obligations within. This is expected to be done 'late enough'\n+    /// that all type inference variables have been bound and so forth.\n+    pub region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+}\n+\n+impl<'tcx> InferCtxtInner<'tcx> {\n+    fn new() -> InferCtxtInner<'tcx> {\n+        InferCtxtInner {\n+            projection_cache: Default::default(),\n+            type_variables: type_variable::TypeVariableTable::new(),\n+            const_unification_table: ut::UnificationTable::new(),\n+            int_unification_table: ut::UnificationTable::new(),\n+            float_unification_table: ut::UnificationTable::new(),\n+            region_constraints: Some(RegionConstraintCollector::new()),\n+            region_obligations: vec![],\n+        }\n+    }\n+\n+    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n+        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -114,16 +197,7 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// and for error reporting logic to read arbitrary node types.\n     pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n \n-    /// Cache for projections. This cache is snapshotted along with the\n-    /// infcx.\n-    ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n-\n-    /// We instantiate `UnificationTable` with `bounds<Ty>` because the\n-    /// types that might instantiate a general type variable have an\n-    /// order, represented by its upper and lower bounds.\n-    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n+    pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n     /// If set, this flag causes us to skip the 'leak check' during\n     /// higher-ranked subtyping operations. This flag is a temporary one used\n@@ -132,22 +206,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// when entering a snapshot.\n     skip_leak_check: Cell<bool>,\n \n-    /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n-\n-    /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n-\n-    /// Map from floating variable to the kind of float it represents\n-    float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n-\n-    /// Tracks the set of region variables and the constraints between\n-    /// them.  This is initially `Some(_)` but when\n-    /// `resolve_regions_and_report_errors` is invoked, this gets set\n-    /// to `None` -- further attempts to perform unification etc may\n-    /// fail if new region constraints would've been added.\n-    region_constraints: RefCell<Option<RegionConstraintCollector<'tcx>>>,\n-\n     /// Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n \n@@ -189,39 +247,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n-    /// outlive the lifetime 'a\". These constraints derive from\n-    /// instantiated type parameters. So if you had a struct defined\n-    /// like\n-    ///\n-    ///     struct Foo<T:'static> { ... }\n-    ///\n-    /// then in some expression `let x = Foo { ... }` it will\n-    /// instantiate the type parameter `T` with a fresh type `$0`. At\n-    /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n-    /// can't generally check these things right away because we have\n-    /// to wait until types are resolved.)\n-    ///\n-    /// These are stored in a map keyed to the id of the innermost\n-    /// enclosing fn body / static initializer expression. This is\n-    /// because the location where the obligation was incurred can be\n-    /// relevant with respect to which sublifetime assumptions are in\n-    /// place. The reason that we store under the fn-id, and not\n-    /// something more fine-grained, is so that it is easier for\n-    /// regionck to be sure that it has found *all* the region\n-    /// obligations (otherwise, it's easy to fail to walk to a\n-    /// particular node-id).\n-    ///\n-    /// Before running `resolve_regions_and_report_errors`, the creator\n-    /// of the inference context is expected to invoke\n-    /// `process_region_obligations` (defined in `self::region_obligations`)\n-    /// for each body-id in this map, which will process the\n-    /// obligations within. This is expected to be done 'late enough'\n-    /// that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n-\n     /// What is the innermost universe we have created? Starts out as\n     /// `UniverseIndex::root()` but grows from there as we enter\n     /// universal quantifiers.\n@@ -543,12 +568,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n-                projection_cache: Default::default(),\n-                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-                const_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+                inner: RefCell::new(InferCtxtInner::new()),\n                 lexical_region_resolutions: RefCell::new(None),\n                 selection_cache: Default::default(),\n                 evaluation_cache: Default::default(),\n@@ -558,7 +578,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n                 err_count_on_creation: tcx.sess.err_count(),\n                 in_snapshot: Cell::new(false),\n                 skip_leak_check: Cell::new(false),\n-                region_obligations: RefCell::new(vec![]),\n                 universe: Cell::new(ty::UniverseIndex::ROOT),\n             })\n         })\n@@ -616,7 +635,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n         match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n             _ => false,\n         }\n     }\n@@ -630,14 +649,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -648,28 +667,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n-        let mut type_variables = self.type_variables.borrow_mut();\n-        let mut int_unification_table = self.int_unification_table.borrow_mut();\n-        let mut float_unification_table = self.float_unification_table.borrow_mut();\n+        let mut inner = self.inner.borrow_mut();\n         // FIXME(const_generics): should there be an equivalent function for const variables?\n \n-        type_variables\n+        let mut vars: Vec<Ty<'_>> = inner\n+            .type_variables\n             .unsolved_variables()\n             .into_iter()\n             .map(|t| self.tcx.mk_ty_var(t))\n-            .chain(\n-                (0..int_unification_table.len())\n-                    .map(|i| ty::IntVid { index: i as u32 })\n-                    .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v)),\n-            )\n-            .chain(\n-                (0..float_unification_table.len())\n-                    .map(|i| ty::FloatVid { index: i as u32 })\n-                    .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v)),\n-            )\n-            .collect()\n+            .collect();\n+        vars.extend(\n+            (0..inner.int_unification_table.len())\n+                .map(|i| ty::IntVid { index: i as u32 })\n+                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_int_var(v)),\n+        );\n+        vars.extend(\n+            (0..inner.float_unification_table.len())\n+                .map(|i| ty::FloatVid { index: i as u32 })\n+                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_float_var(v)),\n+        );\n+        vars\n     }\n \n     fn combine_fields(\n@@ -719,14 +738,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let in_snapshot = self.in_snapshot.get();\n         self.in_snapshot.set(true);\n \n+        let mut inner = self.inner.borrow_mut();\n         CombinedSnapshot {\n-            projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n-            type_snapshot: self.type_variables.borrow_mut().snapshot(),\n-            const_snapshot: self.const_unification_table.borrow_mut().snapshot(),\n-            int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n-            float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n-            region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n-            region_obligations_snapshot: self.region_obligations.borrow().len(),\n+            projection_cache_snapshot: inner.projection_cache.snapshot(),\n+            type_snapshot: inner.type_variables.snapshot(),\n+            const_snapshot: inner.const_unification_table.snapshot(),\n+            int_snapshot: inner.int_unification_table.snapshot(),\n+            float_snapshot: inner.float_unification_table.snapshot(),\n+            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n+            region_obligations_snapshot: inner.region_obligations.len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n             was_skip_leak_check: self.skip_leak_check.get(),\n@@ -756,13 +776,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.universe.set(universe);\n         self.skip_leak_check.set(was_skip_leak_check);\n \n-        self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n-        self.const_unification_table.borrow_mut().rollback_to(const_snapshot);\n-        self.int_unification_table.borrow_mut().rollback_to(int_snapshot);\n-        self.float_unification_table.borrow_mut().rollback_to(float_snapshot);\n-        self.region_obligations.borrow_mut().truncate(region_obligations_snapshot);\n-        self.borrow_region_constraints().rollback_to(region_constraints_snapshot);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.rollback_to(projection_cache_snapshot);\n+        inner.type_variables.rollback_to(type_snapshot);\n+        inner.const_unification_table.rollback_to(const_snapshot);\n+        inner.int_unification_table.rollback_to(int_snapshot);\n+        inner.float_unification_table.rollback_to(float_snapshot);\n+        inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n+        inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n@@ -784,12 +805,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.in_snapshot.set(was_in_snapshot);\n         self.skip_leak_check.set(was_skip_leak_check);\n \n-        self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().commit(type_snapshot);\n-        self.const_unification_table.borrow_mut().commit(const_snapshot);\n-        self.int_unification_table.borrow_mut().commit(int_snapshot);\n-        self.float_unification_table.borrow_mut().commit(float_snapshot);\n-        self.borrow_region_constraints().commit(region_constraints_snapshot);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.commit(projection_cache_snapshot);\n+        inner.type_variables.commit(type_snapshot);\n+        inner.const_unification_table.commit(const_snapshot);\n+        inner.int_unification_table.commit(int_snapshot);\n+        inner.float_unification_table.commit(float_snapshot);\n+        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -859,12 +881,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         snapshot: &CombinedSnapshot<'a, 'tcx>,\n     ) -> Option<bool> {\n-        self.borrow_region_constraints()\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n             .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n     }\n \n     pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.borrow_region_constraints().add_given(sub, sup);\n+        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n     }\n \n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n@@ -900,7 +924,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         b: ty::Region<'tcx>,\n     ) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);\n     }\n \n     /// Require that the region `r` be equal to one of the regions in\n@@ -914,7 +938,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n         debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n-        self.borrow_region_constraints().member_constraint(\n+        self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n             opaque_type_def_id,\n             definition_span,\n             hidden_ty,\n@@ -978,7 +1002,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.type_variables.borrow_mut().new_var(self.universe(), diverging, origin)\n+        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -990,7 +1014,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.type_variables.borrow_mut().new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n@@ -1013,29 +1037,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         universe: ty::UniverseIndex,\n     ) -> &'tcx ty::Const<'tcx> {\n         let vid = self\n-            .const_unification_table\n+            .inner\n             .borrow_mut()\n+            .const_unification_table\n             .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n         self.tcx.mk_const_var(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n+        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n             origin,\n             val: ConstVariableValue::Unknown { universe: self.universe() },\n         })\n     }\n \n     fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table.borrow_mut().new_key(None)\n+        self.inner.borrow_mut().int_unification_table.new_key(None)\n     }\n \n     pub fn next_int_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_int_var(self.next_int_var_id())\n     }\n \n     fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table.borrow_mut().new_key(None)\n+        self.inner.borrow_mut().float_unification_table.new_key(None)\n     }\n \n     pub fn next_float_var(&self) -> Ty<'tcx> {\n@@ -1057,7 +1082,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: RegionVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> ty::Region<'tcx> {\n-        let region_var = self.borrow_region_constraints().new_region_var(universe, origin);\n+        let region_var =\n+            self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n@@ -1067,12 +1093,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// placeholders, however, it will return the universe which which\n     /// they are associated.\n     fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n-        self.borrow_region_constraints().universe(r)\n+        self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n     }\n \n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().num_region_vars()\n+        self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n@@ -1105,7 +1131,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.type_variables.borrow_mut().new_var(\n+                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n                     self.universe(),\n                     false,\n                     TypeVariableOrigin {\n@@ -1125,7 +1151,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     span,\n                 };\n                 let const_var_id =\n-                    self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n+                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n@@ -1179,9 +1205,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         suppress: SuppressRegionErrors,\n     ) {\n         assert!(\n-            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n+            self.inner.borrow().region_obligations\n         );\n \n         let region_rels = &RegionRelations::new(\n@@ -1191,8 +1217,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             outlives_env.free_region_map(),\n         );\n         let (var_infos, data) = self\n-            .region_constraints\n+            .inner\n             .borrow_mut()\n+            .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n@@ -1224,12 +1251,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n         assert!(\n-            self.region_obligations.borrow().is_empty(),\n+            self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n+            self.inner.borrow().region_obligations\n         );\n \n-        self.borrow_region_constraints().take_and_reset_data()\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n     }\n \n     /// Gives temporary access to the region constraint data.\n@@ -1238,8 +1265,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n     ) -> R {\n-        let region_constraints = self.borrow_region_constraints();\n-        op(region_constraints.data())\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n     }\n \n     /// Takes ownership of the list of variable regions. This implies\n@@ -1249,8 +1276,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// of the set of region variables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n         let (var_infos, data) = self\n-            .region_constraints\n+            .inner\n             .borrow_mut()\n+            .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n@@ -1276,7 +1304,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n         use self::type_variable::TypeVariableValue;\n \n-        match self.type_variables.borrow_mut().probe(vid) {\n+        match self.inner.borrow_mut().type_variables.probe(vid) {\n             TypeVariableValue::Known { value } => Ok(value),\n             TypeVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1299,7 +1327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.type_variables.borrow_mut().root_var(var)\n+        self.inner.borrow_mut().type_variables.root_var(var)\n     }\n \n     /// Where possible, replaces type/const variables in\n@@ -1337,7 +1365,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         vid: ty::ConstVid<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.const_unification_table.borrow_mut().probe_value(vid).val {\n+        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1434,7 +1462,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n \n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn type_is_copy_modulo_regions(\n@@ -1509,19 +1540,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         InferOk { value, obligations }\n     }\n \n-    pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n-            c.as_mut().expect(\"region constraints already solved\")\n-        })\n-    }\n-\n     /// Clears the selection, evaluation, and projection caches. This is useful when\n     /// repeatedly attempting to select an `Obligation` while changing only\n     /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n-        self.projection_cache.borrow_mut().clear();\n+        self.inner.borrow_mut().projection_cache.clear();\n     }\n \n     fn universe(&self) -> ty::UniverseIndex {\n@@ -1562,27 +1587,27 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.infcx\n-                    .type_variables\n-                    .borrow_mut()\n-                    .probe(v)\n-                    .known()\n-                    .map(|t| self.fold_ty(t))\n-                    .unwrap_or(typ)\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.infcx.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n                 .infcx\n-                .int_unification_table\n+                .inner\n                 .borrow_mut()\n+                .int_unification_table\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.infcx.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n                 .infcx\n-                .float_unification_table\n+                .inner\n                 .borrow_mut()\n+                .float_unification_table\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.infcx.tcx))\n                 .unwrap_or(typ),\n@@ -1603,7 +1628,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n \n                 // If `inlined_probe` returns a `Known` value its `kind` never\n                 // matches `infer`.\n-                match self.infcx.type_variables.borrow_mut().inlined_probe(v) {\n+                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1613,15 +1638,15 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // If inlined_probe_value returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n                 // `ty::Infer(_)`.\n-                self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v).is_some()\n+                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n             ty::FloatVar(v) => {\n                 // If inlined_probe_value returns a value it's always a\n                 // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.float_unification_table.borrow_mut().probe_value(v).is_some()\n+                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n             _ => unreachable!(),\n@@ -1641,8 +1666,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n             self.infcx\n-                .const_unification_table\n+                .inner\n                 .borrow_mut()\n+                .const_unification_table\n                 .probe_value(*vid)\n                 .val\n                 .known()"}, {"sha": "77e20e6ad8ff2c4cc1ebae0077bd640f056fc616", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -322,7 +322,7 @@ where\n         match value_ty.kind {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n-                self.infcx.type_variables.borrow_mut().equate(vid, value_vid);\n+                self.infcx.inner.borrow_mut().type_variables.equate(vid, value_vid);\n                 return Ok(value_ty);\n             }\n \n@@ -343,7 +343,7 @@ where\n             assert!(!generalized_ty.has_infer_types());\n         }\n \n-        self.infcx.type_variables.borrow_mut().instantiate(vid, generalized_ty);\n+        self.infcx.inner.borrow_mut().type_variables.instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -373,7 +373,7 @@ where\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n-            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n             universe,\n         };\n \n@@ -870,7 +870,7 @@ where\n             }\n \n             ty::Infer(ty::TyVar(vid)) => {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let variables = &mut self.infcx.inner.borrow_mut().type_variables;\n                 let vid = variables.root_var(vid);\n                 let sub_vid = variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n@@ -972,7 +972,7 @@ where\n                 bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n             }\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n                     Some(u) => self.relate(&u, &u),"}, {"sha": "17153ef97241b24da281f7cbc525392590c48971", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -82,7 +82,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"register_region_obligation(body_id={:?}, obligation={:?})\", body_id, obligation);\n \n-        self.region_obligations.borrow_mut().push((body_id, obligation));\n+        self.inner.borrow_mut().region_obligations.push((body_id, obligation));\n     }\n \n     pub fn register_region_obligation_with_cause(\n@@ -103,7 +103,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n     pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n-        ::std::mem::take(&mut *self.region_obligations.borrow_mut())\n+        ::std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n     /// Process the region obligations that must be proven (during"}, {"sha": "c9acd1cf4a1b319ed40434207b35c6ae0487c581", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -75,9 +75,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx>\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => {\n-                self.infcx.borrow_region_constraints().opportunistic_resolve_var(self.tcx(), rid)\n-            }\n+            ty::ReVar(rid) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .opportunistic_resolve_var(self.tcx(), rid),\n             _ => r,\n         }\n     }\n@@ -120,7 +123,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let ty_vars = self.infcx.type_variables.borrow();\n+                    let ty_vars = &self.infcx.inner.borrow().type_variables;\n                     if let TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n                         span,"}, {"sha": "ef4903358d5c96ca7fd44f4bb8edeb7d8701de67", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -80,8 +80,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -95,7 +95,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 // have to record in the `type_variables` tracker that\n                 // the two variables are equal modulo subtyping, which\n                 // is important to the occurs check later on.\n-                infcx.type_variables.borrow_mut().sub(a_vid, b_vid);\n+                infcx.inner.borrow_mut().type_variables.sub(a_vid, b_vid);\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n@@ -140,7 +140,12 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(box self.fields.trace.clone());\n-        self.fields.infcx.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.fields\n+            .infcx\n+            .inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .make_subregion(origin, a, b);\n \n         Ok(a)\n     }"}, {"sha": "e205453a48c535176a9cec03853151f2c41d9127", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::unify::{EqUnifyValue, NoError, UnificationTable, Unif\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n-use std::cell::RefMut;\n use std::cmp;\n use std::marker::PhantomData;\n \n@@ -214,7 +213,7 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n \n pub fn replace_if_possible(\n-    mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n+    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>>>,\n     c: &'tcx ty::Const<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {"}, {"sha": "425f14a5740d413babaac7131c858c04ee1ab183", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -647,7 +647,8 @@ rustc_queries! {\n         query trait_impls_of(key: DefId) -> &'tcx ty::trait_def::TraitImpls {\n             desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n         }\n-        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {\n+        query specialization_graph_of(key: DefId) -> &'tcx specialization_graph::Graph {\n+            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { true }\n         }\n         query is_object_safe(key: DefId) -> bool {"}, {"sha": "1255728de37b14958bb12f1c074b7ca22b9fe2e5", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -199,12 +199,22 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, e)\n             });\n \n-            let body_id_map: FxHashMap<_, _> =\n-                infcx.region_obligations.borrow().iter().map(|&(id, _)| (id, vec![])).collect();\n+            let body_id_map: FxHashMap<_, _> = infcx\n+                .inner\n+                .borrow()\n+                .region_obligations\n+                .iter()\n+                .map(|&(id, _)| (id, vec![]))\n+                .collect();\n \n             infcx.process_registered_region_obligations(&body_id_map, None, full_env);\n \n-            let region_data = infcx.borrow_region_constraints().region_constraint_data().clone();\n+            let region_data = infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .region_constraint_data()\n+                .clone();\n \n             let vid_to_region = self.map_vid_to_region(&region_data);\n "}, {"sha": "2a667b535508be2600d9fe36e90333994d506bc0", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -6,7 +6,6 @@\n \n use crate::infer::{CombinedSnapshot, InferOk};\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::IntercrateMode;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{self, Normalized, Obligation, ObligationCause, SelectionContext};\n use crate::ty::fold::TypeFoldable;\n@@ -27,7 +26,7 @@ enum InCrate {\n #[derive(Debug, Copy, Clone)]\n pub enum Conflict {\n     Upstream,\n-    Downstream { used_to_be_broken: bool },\n+    Downstream,\n }\n \n pub struct OverlapResult<'tcx> {\n@@ -53,7 +52,6 @@ pub fn overlapping_impls<F1, F2, R>(\n     tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n-    intercrate_mode: IntercrateMode,\n     skip_leak_check: SkipLeakCheck,\n     on_overlap: F1,\n     no_overlap: F2,\n@@ -65,13 +63,12 @@ where\n     debug!(\n         \"overlapping_impls(\\\n            impl1_def_id={:?}, \\\n-           impl2_def_id={:?},\n-           intercrate_mode={:?})\",\n-        impl1_def_id, impl2_def_id, intercrate_mode\n+           impl2_def_id={:?})\",\n+        impl1_def_id, impl2_def_id,\n     );\n \n     let overlaps = tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        let selcx = &mut SelectionContext::intercrate(&infcx);\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).is_some()\n     });\n \n@@ -83,7 +80,7 @@ where\n     // this time tracking intercrate ambuiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n     tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        let selcx = &mut SelectionContext::intercrate(&infcx);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n         on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).unwrap())\n     })\n@@ -202,15 +199,7 @@ pub fn trait_ref_is_knowable<'tcx>(\n     if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref.\n-\n-        // A trait can be implementable for a trait ref by both the current\n-        // crate and crates downstream of it. Older versions of rustc\n-        // were not aware of this, causing incoherence (issue #43355).\n-        let used_to_be_broken = orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok();\n-        if used_to_be_broken {\n-            debug!(\"trait_ref_is_knowable({:?}) - USED TO BE BROKEN\", trait_ref);\n-        }\n-        return Some(Conflict::Downstream { used_to_be_broken });\n+        return Some(Conflict::Downstream);\n     }\n \n     if trait_ref_is_local_or_fundamental(tcx, trait_ref) {"}, {"sha": "417b52c38a74d3fc23e3b74fa0ed1dee31060738", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -78,13 +78,6 @@ pub use self::chalk_fulfill::{\n \n pub use self::types::*;\n \n-/// Whether to enable bug compatibility with issue #43355.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum IntercrateMode {\n-    Issue43355,\n-    Fixed,\n-}\n-\n /// Whether to skip the leak check, as part of a future compatibility warning step.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum SkipLeakCheck {"}, {"sha": "5d9f4ddfd167eebb0e3fa022be98686a03be59b0", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -486,7 +486,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    let cache_result = infcx.projection_cache.borrow_mut().try_start(cache_key);\n+    let cache_result = infcx.inner.borrow_mut().projection_cache.try_start(cache_key);\n     match cache_result {\n         Ok(()) => {}\n         Err(ProjectionCacheEntry::Ambiguous) => {\n@@ -560,7 +560,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if infcx.unresolved_type_vars(&ty.value).is_none() {\n-                infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n+                infcx.inner.borrow_mut().projection_cache.complete_normalized(cache_key, &ty);\n             // No need to extend `obligations`.\n             } else {\n                 obligations.extend(ty.obligations);\n@@ -627,7 +627,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n+            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, cache_value);\n             obligations.extend(result.obligations);\n             Some(result.value)\n         }\n@@ -638,7 +638,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 projected_ty\n             );\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n+            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, result.clone());\n             // No need to extend `obligations`.\n             Some(result.value)\n         }\n@@ -647,7 +647,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 \"opt_normalize_projection_type: \\\n                  too many candidates\"\n             );\n-            infcx.projection_cache.borrow_mut().ambiguous(cache_key);\n+            infcx.inner.borrow_mut().projection_cache.ambiguous(cache_key);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -657,7 +657,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n-            infcx.projection_cache.borrow_mut().error(cache_key);\n+            infcx.inner.borrow_mut().projection_cache.error(cache_key);\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n             Some(result.value)"}, {"sha": "cfeb392f87f46848bae59021631c142757f717c7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -19,8 +19,8 @@ use super::DerivedObligationCause;\n use super::Selection;\n use super::SelectionResult;\n use super::TraitNotObjectSafe;\n+use super::TraitQueryMode;\n use super::{BuiltinDerivedObligation, ImplDerivedObligation, ObligationCauseCode};\n-use super::{IntercrateMode, TraitQueryMode};\n use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n@@ -80,7 +80,7 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: Option<IntercrateMode>,\n+    intercrate: bool,\n \n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n \n@@ -218,22 +218,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: None,\n+            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n-    pub fn intercrate(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n-        mode: IntercrateMode,\n-    ) -> SelectionContext<'cx, 'tcx> {\n-        debug!(\"intercrate({:?})\", mode);\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: Some(mode),\n+            intercrate: true,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n             query_mode: TraitQueryMode::Standard,\n@@ -248,7 +244,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: None,\n+            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n             query_mode: TraitQueryMode::Standard,\n@@ -263,7 +259,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: None,\n+            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n             query_mode,\n@@ -276,7 +272,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// false overflow results (#47139) and because it costs\n     /// computation time.\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n-        assert!(self.intercrate.is_some());\n+        assert!(self.intercrate);\n         assert!(self.intercrate_ambiguity_causes.is_none());\n         self.intercrate_ambiguity_causes = Some(vec![]);\n         debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n@@ -286,7 +282,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// was enabled and disables tracking at the same time. If\n     /// tracking is not enabled, just returns an empty vector.\n     pub fn take_intercrate_ambiguity_causes(&mut self) -> Vec<IntercrateAmbiguityCause> {\n-        assert!(self.intercrate.is_some());\n+        assert!(self.intercrate);\n         self.intercrate_ambiguity_causes.take().unwrap_or(vec![])\n     }\n \n@@ -513,7 +509,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some(key) =\n                             ProjectionCacheKey::from_poly_projection_predicate(self, data)\n                         {\n-                            self.infcx.projection_cache.borrow_mut().complete(key);\n+                            self.infcx.inner.borrow_mut().projection_cache.complete(key);\n                         }\n                         result\n                     }\n@@ -562,7 +558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\", obligation);\n \n-        if self.intercrate.is_none()\n+        if !self.intercrate\n             && obligation.is_global()\n             && obligation.param_env.caller_bounds.iter().all(|bound| bound.needs_subst())\n         {\n@@ -727,7 +723,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             stack.fresh_trait_ref.skip_binder().input_types().any(|ty| ty.is_fresh());\n         // This check was an imperfect workaround for a bug in the old\n         // intercrate mode; it should be removed when that goes away.\n-        if unbound_input_types && self.intercrate == Some(IntercrateMode::Issue43355) {\n+        if unbound_input_types && self.intercrate {\n             debug!(\n                 \"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                 stack.fresh_trait_ref\n@@ -1206,7 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Option<Conflict> {\n         debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n \n-        if !self.intercrate.is_some() {\n+        if !self.intercrate {\n             return None;\n         }\n \n@@ -1218,17 +1214,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // bound regions.\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n-        let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n-        if let (\n-            Some(Conflict::Downstream { used_to_be_broken: true }),\n-            Some(IntercrateMode::Issue43355),\n-        ) = (result, self.intercrate)\n-        {\n-            debug!(\"is_knowable: IGNORING conflict to be bug-compatible with #43355\");\n-            None\n-        } else {\n-            result\n-        }\n+        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n     }\n \n     /// Returns `true` if the global caches can be used.\n@@ -1249,7 +1235,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate, I don't think.\n-        if self.intercrate.is_some() {\n+        if self.intercrate {\n             return false;\n         }\n \n@@ -3305,7 +3291,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        if self.intercrate.is_none()\n+        if !self.intercrate\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {\n             debug!(\"match_impl: reservation impls only apply in intercrate mode\");"}, {"sha": "071b5277dd95db8c560d8b093d3c675c44a140d3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -332,14 +332,9 @@ pub(super) fn specialization_graph_provider(\n                 let impl_span =\n                     tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n                 let mut err = match used_to_be_allowed {\n-                    Some(FutureCompatOverlapErrorKind::Issue43355) | None => {\n-                        struct_span_err!(tcx.sess, impl_span, E0119, \"{}\", msg)\n-                    }\n+                    None => struct_span_err!(tcx.sess, impl_span, E0119, \"{}\", msg),\n                     Some(kind) => {\n                         let lint = match kind {\n-                            FutureCompatOverlapErrorKind::Issue43355 => {\n-                                unreachable!(\"converted to hard error above\")\n-                            }\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n                                 ORDER_DEPENDENT_TRAIT_OBJECTS\n                             }"}, {"sha": "ca7740199ec7dff635bbc79b303aac5b02e6a444", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -9,7 +9,6 @@ pub use rustc::traits::types::specialization_graph::*;\n \n #[derive(Copy, Clone, Debug)]\n pub enum FutureCompatOverlapErrorKind {\n-    Issue43355,\n     Issue33140,\n     LeakCheck,\n }\n@@ -107,16 +106,16 @@ impl<'tcx> Children {\n                 }\n             };\n \n+            let allowed_to_overlap =\n+                tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling);\n+\n             let (le, ge) = traits::overlapping_impls(\n                 tcx,\n                 possible_sibling,\n                 impl_def_id,\n-                traits::IntercrateMode::Issue43355,\n                 traits::SkipLeakCheck::default(),\n                 |overlap| {\n-                    if let Some(overlap_kind) =\n-                        tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n-                    {\n+                    if let Some(overlap_kind) = &allowed_to_overlap {\n                         match overlap_kind {\n                             ty::ImplOverlapKind::Permitted { marker: _ } => {}\n                             ty::ImplOverlapKind::Issue33140 => {\n@@ -154,31 +153,14 @@ impl<'tcx> Children {\n \n                 replace_children.push(possible_sibling);\n             } else {\n-                if let None = tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                    // do future-compat checks for overlap. Have issue #33140\n-                    // errors overwrite issue #43355 errors when both are present.\n-\n-                    traits::overlapping_impls(\n-                        tcx,\n-                        possible_sibling,\n-                        impl_def_id,\n-                        traits::IntercrateMode::Fixed,\n-                        traits::SkipLeakCheck::default(),\n-                        |overlap| {\n-                            last_lint = Some(FutureCompatOverlapError {\n-                                error: overlap_error(overlap),\n-                                kind: FutureCompatOverlapErrorKind::Issue43355,\n-                            });\n-                        },\n-                        || (),\n-                    );\n+                if let None = allowed_to_overlap {\n+                    // Do future-compat checks for overlap.\n \n                     if last_lint.is_none() {\n                         traits::overlapping_impls(\n                             tcx,\n                             possible_sibling,\n                             impl_def_id,\n-                            traits::IntercrateMode::Fixed,\n                             traits::SkipLeakCheck::Yes,\n                             |overlap| {\n                                 last_lint = Some(FutureCompatOverlapError {"}, {"sha": "718c1e9ae2043937e5e720528f6ffb63fcc99151", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -331,7 +331,7 @@ where\n     let mut buf = Vec::new();\n \n     let graphviz = graphviz::Formatter::new(body, def_id, results, &mut *formatter);\n-    dot::render(&graphviz, &mut buf)?;\n+    dot::render_opts(&graphviz, &mut buf, &[dot::RenderOption::Monospace])?;\n     fs::write(&path, buf)?;\n     Ok(())\n }"}, {"sha": "b805b13592f898e13933c4dd6dd3c35897901bbb", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -171,10 +171,19 @@ where\n         //   | | (on successful return)           | +_4        |\n         //   +-+----------------------------------+------------+\n \n-        write!(\n-            w,\n-            r#\"<table border=\"1\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"3\" sides=\"rb\">\"#,\n-        )?;\n+        // N.B., Some attributes (`align`, `balign`) are repeated on parent elements and their\n+        // children. This is because `xdot` seemed to have a hard time correctly propagating\n+        // attributes. Make sure to test the output before trying to remove the redundancy.\n+        // Notably, `align` was found to have no effect when applied only to <table>.\n+\n+        let table_fmt = concat!(\n+            \" border=\\\"1\\\"\",\n+            \" cellborder=\\\"1\\\"\",\n+            \" cellspacing=\\\"0\\\"\",\n+            \" cellpadding=\\\"3\\\"\",\n+            \" sides=\\\"rb\\\"\",\n+        );\n+        write!(w, r#\"<table{fmt}>\"#, fmt = table_fmt)?;\n \n         // A + B: Block header\n         if self.state_formatter.column_names().is_empty() {\n@@ -186,7 +195,7 @@ where\n         // C: Entry state\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n-        self.write_row_with_full_state(w, \"\", \"(on_entry)\")?;\n+        self.write_row_with_full_state(w, \"\", \"(on entry)\")?;\n \n         // D: Statement transfer functions\n         for (i, statement) in body[block].statements.iter().enumerate() {\n@@ -212,7 +221,7 @@ where\n             self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n                 write!(\n                     w,\n-                    r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                    r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n                     colspan = num_state_columns,\n                     fmt = fmt,\n                 )?;\n@@ -311,7 +320,9 @@ where\n         f: impl FnOnce(&mut Self, &mut W, &str) -> io::Result<()>,\n     ) -> io::Result<()> {\n         let bg = self.toggle_background();\n-        let fmt = format!(\"sides=\\\"tl\\\" {}\", bg.attr());\n+        let valign = if mir.starts_with(\"(on \") && mir != \"(on entry)\" { \"bottom\" } else { \"top\" };\n+\n+        let fmt = format!(\"valign=\\\"{}\\\" sides=\\\"tl\\\" {}\", valign, bg.attr());\n \n         write!(\n             w,\n@@ -345,7 +356,7 @@ where\n                 colspan = this.num_state_columns(),\n                 fmt = fmt,\n             )?;\n-            pretty_print_state_elems(w, analysis, state.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+            pretty_print_state_elems(w, analysis, state.iter(), \", \", LIMIT_30_ALIGN_1)?;\n             write!(w, \"}}</td>\")\n         })\n     }\n@@ -387,7 +398,6 @@ pub struct SimpleDiff<T: Idx> {\n }\n \n impl<T: Idx> SimpleDiff<T> {\n-    #![allow(unused)]\n     pub fn new(bits_per_block: usize) -> Self {\n         SimpleDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n     }\n@@ -417,8 +427,8 @@ where\n         }\n \n         self.prev_loc = location;\n-        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_before(location);\n+        write!(w, r#\"<td {fmt} balign=\"left\" align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_after(location);\n         let curr_state = results.get();\n         write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n         self.prev_state.overwrite(curr_state);\n@@ -434,7 +444,6 @@ pub struct TwoPhaseDiff<T: Idx> {\n }\n \n impl<T: Idx> TwoPhaseDiff<T> {\n-    #![allow(unused)]\n     pub fn new(bits_per_block: usize) -> Self {\n         TwoPhaseDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n     }\n@@ -445,7 +454,7 @@ where\n     A: Analysis<'tcx>,\n {\n     fn column_names(&self) -> &[&str] {\n-        &[\"ENTRY\", \" EXIT\"]\n+        &[\"BEFORE\", \" AFTER\"]\n     }\n \n     fn write_state_for_location(\n@@ -465,7 +474,7 @@ where\n \n         self.prev_loc = location;\n \n-        // Entry\n+        // Before\n \n         write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n         results.seek_before(location);\n@@ -474,7 +483,7 @@ where\n         self.prev_state.overwrite(curr_state);\n         write!(w, \"</td>\")?;\n \n-        // Exit\n+        // After\n \n         write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n         results.seek_after(location);\n@@ -492,7 +501,6 @@ pub struct BlockTransferFunc<'a, 'tcx, T: Idx> {\n }\n \n impl<T: Idx> BlockTransferFunc<'mir, 'tcx, T> {\n-    #![allow(unused)]\n     pub fn new(\n         body: &'mir mir::Body<'tcx>,\n         trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n@@ -527,12 +535,12 @@ where\n         for set in &[&block_trans.gen, &block_trans.kill] {\n             write!(\n                 w,\n-                r#\"<td {fmt} rowspan=\"{rowspan}\" align=\"center\">\"#,\n+                r#\"<td {fmt} rowspan=\"{rowspan}\" balign=\"left\" align=\"left\">\"#,\n                 fmt = fmt,\n                 rowspan = rowspan\n             )?;\n \n-            pretty_print_state_elems(&mut w, results.analysis(), set.iter(), \"\\n\", None)?;\n+            pretty_print_state_elems(&mut w, results.analysis(), set.iter(), BR_LEFT, None)?;\n             write!(w, \"</td>\")?;\n         }\n \n@@ -564,25 +572,28 @@ fn write_diff<A: Analysis<'tcx>>(\n \n     if !set.is_empty() {\n         write!(w, r#\"<font color=\"darkgreen\">+\"#)?;\n-        pretty_print_state_elems(w, analysis, set.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+        pretty_print_state_elems(w, analysis, set.iter(), \", \", LIMIT_30_ALIGN_1)?;\n         write!(w, r#\"</font>\"#)?;\n     }\n \n     if !set.is_empty() && !clear.is_empty() {\n-        write!(w, \"<br/>\")?;\n+        write!(w, \"{}\", BR_LEFT)?;\n     }\n \n     if !clear.is_empty() {\n         write!(w, r#\"<font color=\"red\">-\"#)?;\n-        pretty_print_state_elems(w, analysis, clear.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+        pretty_print_state_elems(w, analysis, clear.iter(), \", \", LIMIT_30_ALIGN_1)?;\n         write!(w, r#\"</font>\"#)?;\n     }\n \n     Ok(())\n }\n \n+const BR_LEFT: &'static str = r#\"<br align=\"left\"/>\"#;\n+const BR_LEFT_SPACE: &'static str = r#\"<br align=\"left\"/> \"#;\n+\n /// Line break policy that breaks at 40 characters and starts the next line with a single space.\n-const LIMIT_40_ALIGN_1: Option<LineBreak> = Some(LineBreak { sequence: \"<br/> \", limit: 40 });\n+const LIMIT_30_ALIGN_1: Option<LineBreak> = Some(LineBreak { sequence: BR_LEFT_SPACE, limit: 30 });\n \n struct LineBreak {\n     sequence: &'static str,\n@@ -613,25 +624,25 @@ where\n     let mut line_break_inserted = false;\n \n     for idx in elems {\n-        if first {\n-            first = false;\n-        } else {\n-            write!(w, \"{}\", sep)?;\n-            curr_line_width += sep_width;\n-        }\n-\n         buf.clear();\n         analysis.pretty_print_idx(&mut buf, idx)?;\n         let idx_str =\n             str::from_utf8(&buf).expect(\"Output of `pretty_print_idx` must be valid UTF-8\");\n         let escaped = dot::escape_html(idx_str);\n         let escaped_width = escaped.chars().count();\n \n-        if let Some(line_break) = &line_break {\n-            if curr_line_width + sep_width + escaped_width > line_break.limit {\n-                write!(w, \"{}\", line_break.sequence)?;\n-                line_break_inserted = true;\n-                curr_line_width = 0;\n+        if first {\n+            first = false;\n+        } else {\n+            write!(w, \"{}\", sep)?;\n+            curr_line_width += sep_width;\n+\n+            if let Some(line_break) = &line_break {\n+                if curr_line_width + sep_width + escaped_width > line_break.limit {\n+                    write!(w, \"{}\", line_break.sequence)?;\n+                    line_break_inserted = true;\n+                    curr_line_width = 0;\n+                }\n             }\n         }\n "}, {"sha": "7131eb1144e0669cae5f53c43b8b4f3d6746d7f7", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -95,23 +95,32 @@ enum PrevTokenKind {\n     Other,\n }\n \n-// NOTE: `Ident`s are handled by `common.rs`.\n-\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n     /// The current normalized token.\n     /// \"Normalized\" means that some interpolated tokens\n     /// (`$i: ident` and `$l: lifetime` meta-variables) are replaced\n     /// with non-interpolated identifier and lifetime tokens they refer to.\n-    /// Perhaps the normalized / non-normalized setup can be simplified somehow.\n+    /// Use span from this token if you need an isolated span.\n     pub token: Token,\n-    /// The span of the current non-normalized token.\n-    meta_var_span: Option<Span>,\n-    /// The span of the previous non-normalized token.\n-    pub prev_span: Span,\n-    /// The kind of the previous normalized token (in simplified form).\n+    /// The current non-normalized token if it's different from `token`.\n+    /// Preferable use is through the `unnormalized_token()` getter.\n+    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n+    unnormalized_token: Option<Token>,\n+    /// The previous normalized token.\n+    /// Use span from this token if you need an isolated span.\n+    prev_token: Token,\n+    /// The previous non-normalized token if it's different from `prev_token`.\n+    /// Preferable use is through the `unnormalized_prev_token()` getter.\n+    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n+    unnormalized_prev_token: Option<Token>,\n+    /// Equivalent to `prev_token.kind` in simplified form.\n+    /// FIXME: Remove in favor of `(unnormalized_)prev_token().kind`.\n     prev_token_kind: PrevTokenKind,\n+    /// Equivalent to `unnormalized_prev_token().span`.\n+    /// FIXME: Remove in favor of `(unnormalized_)prev_token().span`.\n+    pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n     pub(super) directory: Directory<'a>,\n@@ -384,9 +393,11 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            prev_span: DUMMY_SP,\n-            meta_var_span: None,\n+            unnormalized_token: None,\n+            prev_token: Token::dummy(),\n+            unnormalized_prev_token: None,\n             prev_token_kind: PrevTokenKind::Other,\n+            prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n@@ -427,6 +438,14 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n+    fn unnormalized_token(&self) -> &Token {\n+        self.unnormalized_token.as_ref().unwrap_or(&self.token)\n+    }\n+\n+    fn unnormalized_prev_token(&self) -> &Token {\n+        self.unnormalized_prev_token.as_ref().unwrap_or(&self.prev_token)\n+    }\n+\n     fn next_tok(&mut self) -> Token {\n         let mut next = if self.desugar_doc_comments {\n             self.token_cursor.next_desugared()\n@@ -435,7 +454,7 @@ impl<'a> Parser<'a> {\n         };\n         if next.span.is_dummy() {\n             // Tweak the location for better diagnostics, but keep syntactic context intact.\n-            next.span = self.prev_span.with_ctxt(next.span.ctxt());\n+            next.span = self.unnormalized_token().span.with_ctxt(next.span.ctxt());\n         }\n         next\n     }\n@@ -895,10 +914,13 @@ impl<'a> Parser<'a> {\n             self.span_bug(self.token.span, msg);\n         }\n \n-        self.prev_span = self.meta_var_span.take().unwrap_or(self.token.span);\n+        // Update the current and previous tokens.\n+        let next_token = self.next_tok();\n+        self.prev_token = mem::replace(&mut self.token, next_token);\n+        self.unnormalized_prev_token = self.unnormalized_token.take();\n \n-        // Record last token kind for possible error recovery.\n-        self.prev_token_kind = match self.token.kind {\n+        // Update fields derived from the previous token.\n+        self.prev_token_kind = match self.prev_token.kind {\n             token::DocComment(..) => PrevTokenKind::DocComment,\n             token::Comma => PrevTokenKind::Comma,\n             token::BinOp(token::Plus) => PrevTokenKind::Plus,\n@@ -908,22 +930,28 @@ impl<'a> Parser<'a> {\n             token::Ident(..) => PrevTokenKind::Ident,\n             _ => PrevTokenKind::Other,\n         };\n+        self.prev_span = self.unnormalized_prev_token().span;\n \n-        self.token = self.next_tok();\n         self.expected_tokens.clear();\n         // Check after each token.\n         self.process_potential_macro_variable();\n     }\n \n     /// Advances the parser using provided token as a next one. Use this when\n     /// consuming a part of a token. For example a single `<` from `<<`.\n+    /// FIXME: this function sets the previous token data to some semi-nonsensical values\n+    /// which kind of work because they are currently used in very limited ways in practice.\n+    /// Correct token kinds and spans need to be calculated instead.\n     fn bump_with(&mut self, next: TokenKind, span: Span) {\n-        self.prev_span = self.token.span.with_hi(span.lo());\n-        // It would be incorrect to record the kind of the current token, but\n-        // fortunately for tokens currently using `bump_with`, the\n-        // `prev_token_kind` will be of no use anyway.\n+        // Update the current and previous tokens.\n+        let next_token = Token::new(next, span);\n+        self.prev_token = mem::replace(&mut self.token, next_token);\n+        self.unnormalized_prev_token = self.unnormalized_token.take();\n+\n+        // Update fields derived from the previous token.\n         self.prev_token_kind = PrevTokenKind::Other;\n-        self.token = Token::new(next, span);\n+        self.prev_span = self.unnormalized_prev_token().span.with_hi(span.lo());\n+\n         self.expected_tokens.clear();\n     }\n \n@@ -1054,7 +1082,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn process_potential_macro_variable(&mut self) {\n-        self.token = match self.token.kind {\n+        let normalized_token = match self.token.kind {\n             token::Dollar\n                 if self.token.span.from_expansion() && self.look_ahead(1, |t| t.is_ident()) =>\n             {\n@@ -1071,7 +1099,6 @@ impl<'a> Parser<'a> {\n                 return;\n             }\n             token::Interpolated(ref nt) => {\n-                self.meta_var_span = Some(self.token.span);\n                 // Interpolated identifier and lifetime tokens are replaced with usual identifier\n                 // and lifetime tokens, so the former are never encountered during normal parsing.\n                 match **nt {\n@@ -1084,6 +1111,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => return,\n         };\n+        self.unnormalized_token = Some(mem::replace(&mut self.token, normalized_token));\n     }\n \n     /// Parses a single token tree from the input.\n@@ -1100,7 +1128,7 @@ impl<'a> Parser<'a> {\n             }\n             token::CloseDelim(_) | token::Eof => unreachable!(),\n             _ => {\n-                let token = self.token.take();\n+                let token = self.token.clone();\n                 self.bump();\n                 TokenTree::Token(token)\n             }"}, {"sha": "985185230f26ade50ec859ec0f491dfc888e72f3", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -542,11 +542,14 @@ impl<'a> Parser<'a> {\n             }\n \n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-                if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Not), ..) =\n-                    pat.kind\n-                {\n-                    *m = Mutability::Mut;\n+                if let PatKind::Ident(ref mut bm, ..) = pat.kind {\n+                    if let BindingMode::ByValue(ref mut m @ Mutability::Not) = bm {\n+                        *m = Mutability::Mut;\n+                    }\n                     self.0 = true;\n+                    // Don't recurse into the subpattern, mut on the outer\n+                    // binding doesn't affect the inner bindings.\n+                    return;\n                 }\n                 noop_visit_pat(pat, self);\n             }"}, {"sha": "761c06b70ee8bdb212d9a25a51500a8d4d831c45", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -134,7 +134,7 @@ impl<'a> Parser<'a> {\n             path\n         });\n \n-        let lo = self.meta_var_span.unwrap_or(self.token.span);\n+        let lo = self.unnormalized_token().span;\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.token.span.ctxt();\n         if self.eat(&token::ModSep) {"}, {"sha": "dc6018e80ea7eb9ec002108b21b4b962ac57414c", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -226,7 +226,9 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n         let b = match b {\n             &ty::ReVar(vid) => self\n                 .infcx\n-                .borrow_region_constraints()\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n                 .opportunistic_resolve_var(self.infcx.tcx, vid),\n \n             other => other,"}, {"sha": "1970b1e5c5deb06f8ab7c84ad7a0ac6f15eb9e4e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -18,14 +18,12 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n+    let lang_items = tcx.lang_items();\n     Checker { tcx, trait_def_id }\n-        .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n-        .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items().coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n-        .check(\n-            tcx.lang_items().dispatch_from_dyn_trait(),\n-            visit_implementation_of_dispatch_from_dyn,\n-        );\n+        .check(lang_items.drop_trait(), visit_implementation_of_drop)\n+        .check(lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(lang_items.coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n+        .check(lang_items.dispatch_from_dyn_trait(), visit_implementation_of_dispatch_from_dyn);\n }\n \n struct Checker<'tcx> {"}, {"sha": "ffea849c4f20942ffc0be97f8715f21af6314369", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -1,5 +1,5 @@\n use crate::namespace::Namespace;\n-use rustc::traits::{self, IntercrateMode, SkipLeakCheck};\n+use rustc::traits::{self, SkipLeakCheck};\n use rustc::ty::{AssocItem, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -93,7 +93,6 @@ impl InherentOverlapChecker<'tcx> {\n             self.tcx,\n             impl1_def_id,\n             impl2_def_id,\n-            IntercrateMode::Issue43355,\n             // We go ahead and just skip the leak check for\n             // inherent impls without warning.\n             SkipLeakCheck::Yes,"}, {"sha": "1526182576c315450f26896c9125b121c09a9436", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -10,45 +10,43 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::HirId;\n+use rustc_span::Span;\n \n mod builtin;\n mod inherent_impls;\n mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-fn check_impl(tcx: TyCtxt<'_>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id(hir_id);\n-\n-    // If there are no traits, then this implementation must have a\n-    // base type.\n-\n-    if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-        debug!(\n-            \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n-            trait_ref,\n-            tcx.def_path_str(impl_def_id)\n-        );\n+/// Obtains the span of just the impl header of `impl_def_id`.\n+fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Span {\n+    tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap())\n+}\n \n-        // Skip impls where one of the self type is an error type.\n-        // This occurs with e.g., resolve failures (#30589).\n-        if trait_ref.references_error() {\n-            return;\n-        }\n+fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {\n+    debug!(\n+        \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+        trait_ref,\n+        tcx.def_path_str(impl_def_id)\n+    );\n \n-        enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n+    // Skip impls where one of the self type is an error type.\n+    // This occurs with e.g., resolve failures (#30589).\n+    if trait_ref.references_error() {\n+        return;\n     }\n+\n+    enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n+    enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n }\n \n fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n-    let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n \n     // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n     if did == li.sized_trait() {\n+        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n             span,\n@@ -61,6 +59,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n     }\n \n     if did == li.unsize_trait() {\n+        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n             span,\n@@ -86,6 +85,8 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n     } else {\n         return; // everything OK\n     };\n+\n+    let span = impl_header_span(tcx, impl_def_id);\n     struct_span_err!(\n         tcx.sess,\n         span,\n@@ -109,7 +110,7 @@ fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt<'_>, impl_def_id: DefId, tr\n         return;\n     }\n \n-    let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+    let span = impl_header_span(tcx, impl_def_id);\n     struct_span_err!(tcx.sess, span, E0715, \"impls for marker traits cannot contain items\").emit();\n }\n \n@@ -129,12 +130,17 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n+    // Trigger building the specialization graph for the trait. This will detect and report any\n+    // overlap errors.\n+    tcx.specialization_graph_of(def_id);\n+\n     let impls = tcx.hir().trait_impls(def_id);\n-    for &impl_id in impls {\n-        check_impl(tcx, impl_id);\n-    }\n-    for &impl_id in impls {\n-        check_impl_overlap(tcx, impl_id);\n+    for &hir_id in impls {\n+        let impl_def_id = tcx.hir().local_def_id(hir_id);\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+\n+        check_impl(tcx, impl_def_id, trait_ref);\n+        check_object_overlap(tcx, impl_def_id, trait_ref);\n     }\n     builtin::check_trait(tcx, def_id);\n }\n@@ -152,24 +158,20 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n     tcx.ensure().crate_inherent_impls_overlap_check(LOCAL_CRATE);\n }\n \n-/// Overlap: no two impls for the same trait are implemented for the\n-/// same type. Likewise, no two inherent impls for a given type\n-/// constructor provide a method with the same name.\n-fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id(hir_id);\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+/// Checks whether an impl overlaps with the automatic `impl Trait for dyn Trait`.\n+fn check_object_overlap<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_def_id: DefId,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) {\n     let trait_def_id = trait_ref.def_id;\n \n     if trait_ref.references_error() {\n         debug!(\"coherence: skipping impl {:?} with error {:?}\", impl_def_id, trait_ref);\n         return;\n     }\n \n-    // Trigger building the specialization graph for the trait of this impl.\n-    // This will detect any overlap errors.\n-    tcx.specialization_graph_of(trait_def_id);\n-\n-    // check for overlap with the automatic `impl Trait for Trait`\n+    // check for overlap with the automatic `impl Trait for dyn Trait`\n     if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n@@ -194,17 +196,17 @@ fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n             } else {\n                 let mut supertrait_def_ids = traits::supertrait_def_ids(tcx, component_def_id);\n                 if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                    let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                    let span = impl_header_span(tcx, impl_def_id);\n                     struct_span_err!(\n                         tcx.sess,\n-                        sp,\n+                        span,\n                         E0371,\n                         \"the object type `{}` automatically implements the trait `{}`\",\n                         trait_ref.self_ty(),\n                         tcx.def_path_str(trait_def_id)\n                     )\n                     .span_label(\n-                        sp,\n+                        span,\n                         format!(\n                             \"`{}` automatically implements trait `{}`\",\n                             trait_ref.self_ty(),"}, {"sha": "71f997c54c6f23441951140f51a9105c1db566fb", "filename": "src/test/ui/coherence/coherence-inherited-assoc-ty-cycle-err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `Trait`\n+error[E0391]: cycle detected when building specialization graph of trait `Trait`\n   --> $DIR/coherence-inherited-assoc-ty-cycle-err.rs:8:1\n    |\n LL | trait Trait<T> { type Assoc; }\n    | ^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Trait`, completing the cycle\n+   = note: ...which again requires building specialization graph of trait `Trait`, completing the cycle\n note: cycle used when coherence checking all impls of trait `Trait`\n   --> $DIR/coherence-inherited-assoc-ty-cycle-err.rs:8:1\n    |"}, {"sha": "2160bad48074dc9117ad9c1ddc2bea2f4a904eaf", "filename": "src/test/ui/consts/const-nonzero.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fconsts%2Fconst-nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fconsts%2Fconst-nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-nonzero.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -1,9 +1,18 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// run-pass\n+\n+#![feature(const_nonzero_int_methods)]\n \n use std::num::NonZeroU8;\n \n const X: NonZeroU8 = unsafe { NonZeroU8::new_unchecked(5) };\n const Y: u8 = X.get();\n \n+const ZERO: Option<NonZeroU8> = NonZeroU8::new(0);\n+const ONE: Option<NonZeroU8> = NonZeroU8::new(1);\n+\n fn main() {\n+    assert_eq!(Y, 5);\n+\n+    assert!(ZERO.is_none());\n+    assert_eq!(ONE.unwrap().get(), 1);\n }"}, {"sha": "ec04b937b9ace73aba14a438058791a7c8a89bd1", "filename": "src/test/ui/parser/mbe_missing_right_paren.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.stderr?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -22,10 +22,10 @@ LL | macro_rules! abc(\u063c;\n    |                   ^\n \n error: unexpected end of macro invocation\n-  --> $DIR/mbe_missing_right_paren.rs:3:1\n+  --> $DIR/mbe_missing_right_paren.rs:3:19\n    |\n LL | macro_rules! abc(\u063c\n-   | ^^^^^^^^^^^^^^^^^^ missing tokens in macro arguments\n+   |                   ^ missing tokens in macro arguments\n \n error: aborting due to 3 previous errors\n "}, {"sha": "497d94a3db0d9547a55d838637ca254846c233b3", "filename": "src/test/ui/pattern/bindings-after-at/nested-binding-mode-lint.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-mode-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-mode-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-mode-lint.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(bindings_after_at)]\n+#![deny(unused_mut)]\n+\n+fn main() {\n+    let mut is_mut @ not_mut = 42;\n+    &mut is_mut;\n+    &not_mut;\n+    let not_mut @ mut is_mut = 42;\n+    &mut is_mut;\n+    &not_mut;\n+}"}, {"sha": "54f04117f7def61f7c772c2a04c8b3b0384e6cd4", "filename": "src/test/ui/pattern/bindings-after-at/nested-binding-modes-mut.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -0,0 +1,13 @@\n+#![feature(bindings_after_at)]\n+\n+fn main() {\n+    let mut is_mut @ not_mut = 42;\n+    &mut is_mut;\n+    &mut not_mut;\n+    //~^ ERROR cannot borrow\n+\n+    let not_mut @ mut is_mut = 42;\n+    &mut is_mut;\n+    &mut not_mut;\n+    //~^ ERROR cannot borrow\n+}"}, {"sha": "a8d5e4c4c69cc2b4d2a0bfeda57d01f60258dcbc", "filename": "src/test/ui/pattern/bindings-after-at/nested-binding-modes-mut.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.stderr?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -0,0 +1,21 @@\n+error[E0596]: cannot borrow `not_mut` as mutable, as it is not declared as mutable\n+  --> $DIR/nested-binding-modes-mut.rs:6:5\n+   |\n+LL |     let mut is_mut @ not_mut = 42;\n+   |                      ------- help: consider changing this to be mutable: `mut not_mut`\n+LL |     &mut is_mut;\n+LL |     &mut not_mut;\n+   |     ^^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `not_mut` as mutable, as it is not declared as mutable\n+  --> $DIR/nested-binding-modes-mut.rs:11:5\n+   |\n+LL |     let not_mut @ mut is_mut = 42;\n+   |         -------------------- help: consider changing this to be mutable: `mut not_mut`\n+LL |     &mut is_mut;\n+LL |     &mut not_mut;\n+   |     ^^^^^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "d5086aec93ec3bd4e978fe6661002746716e3a76", "filename": "src/test/ui/pattern/bindings-after-at/nested-binding-modes-ref.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-ref.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -0,0 +1,13 @@\n+#![feature(bindings_after_at)]\n+\n+fn main() {\n+    let ref is_ref @ is_val = 42;\n+    *is_ref;\n+    *is_val;\n+    //~^ ERROR cannot be dereferenced\n+\n+    let is_val @ ref is_ref = 42;\n+    *is_ref;\n+    *is_val;\n+    //~^ ERROR cannot be dereferenced\n+}"}, {"sha": "9cc928d214993b9d3d772266325fa05c205ada61", "filename": "src/test/ui/pattern/bindings-after-at/nested-binding-modes-ref.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-ref.stderr?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -0,0 +1,15 @@\n+error[E0614]: type `{integer}` cannot be dereferenced\n+  --> $DIR/nested-binding-modes-ref.rs:6:5\n+   |\n+LL |     *is_val;\n+   |     ^^^^^^^\n+\n+error[E0614]: type `{integer}` cannot be dereferenced\n+  --> $DIR/nested-binding-modes-ref.rs:11:5\n+   |\n+LL |     *is_val;\n+   |     ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0614`."}]}