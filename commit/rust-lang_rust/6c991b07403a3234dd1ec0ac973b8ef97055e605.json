{"sha": "6c991b07403a3234dd1ec0ac973b8ef97055e605", "node_id": "C_kwDOAAsO6NoAKDZjOTkxYjA3NDAzYTMyMzRkZDFlYzBhYzk3M2I4ZWY5NzA1NWU2MDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T21:14:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T21:14:44Z"}, "message": "Auto merge of #107000 - GuillaumeGomez:fix-items-in-doc-hidden-block, r=notriddle,petrochenkov\n\nFix handling of items inside a `doc(hidden)` block\n\nFixes #106373.\n\ncc `@aDotInTheVoid`\nr? `@notriddle`", "tree": {"sha": "e9fd955533d898249d8602ae2e2cc9b6040b264b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9fd955533d898249d8602ae2e2cc9b6040b264b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c991b07403a3234dd1ec0ac973b8ef97055e605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c991b07403a3234dd1ec0ac973b8ef97055e605", "html_url": "https://github.com/rust-lang/rust/commit/6c991b07403a3234dd1ec0ac973b8ef97055e605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c991b07403a3234dd1ec0ac973b8ef97055e605/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3126500f25114ba4e0ac3e76694dd45a22de56d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3126500f25114ba4e0ac3e76694dd45a22de56d", "html_url": "https://github.com/rust-lang/rust/commit/f3126500f25114ba4e0ac3e76694dd45a22de56d"}, {"sha": "ea844187b27fbcff521bcbcbe6615d51d0196fa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea844187b27fbcff521bcbcbe6615d51d0196fa2", "html_url": "https://github.com/rust-lang/rust/commit/ea844187b27fbcff521bcbcbe6615d51d0196fa2"}], "stats": {"total": 468, "additions": 357, "deletions": 111}, "files": [{"sha": "80493b100bb45cecf4271e01c6be350b655d150e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -2213,21 +2213,17 @@ fn clean_maybe_renamed_item<'tcx>(\n             get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n         }\n \n-        if !extra_attrs.is_empty() {\n+        let mut item = if !extra_attrs.is_empty() {\n             extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n             let attrs = Attributes::from_ast(&extra_attrs);\n             let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n \n-            vec![Item::from_def_id_and_attrs_and_parts(\n-                def_id,\n-                Some(name),\n-                kind,\n-                Box::new(attrs),\n-                cfg,\n-            )]\n+            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg)\n         } else {\n-            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n-        }\n+            Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n+        };\n+        item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n+        vec![item]\n     })\n }\n "}, {"sha": "54749e9a3171856b0ef735ac240fc0b21225de59", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -138,7 +138,7 @@ pub(super) fn write_shared(\n         Ok((ret, krates))\n     }\n \n-    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\</code> format,\n+    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\ </code> format,\n     /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n     ///\n     /// This forms the payload of files that look like this:"}, {"sha": "8c733ddefc0a5a1efe02dd3d95647f85533a297b", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 83, "deletions": 26, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -1,4 +1,6 @@\n //! Strip all doc(hidden) items from the output.\n+\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use std::mem;\n \n@@ -7,6 +9,7 @@ use crate::clean::{Item, ItemIdSet, NestedAttributesExt};\n use crate::core::DocContext;\n use crate::fold::{strip_item, DocFolder};\n use crate::passes::{ImplStripper, Pass};\n+use crate::visit_ast::inherits_doc_hidden;\n \n pub(crate) const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n@@ -21,7 +24,12 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n-        let mut stripper = Stripper { retained: &mut retained, update_retained: true };\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            update_retained: true,\n+            tcx: cx.tcx,\n+            is_in_hidden_item: false,\n+        };\n         stripper.fold_crate(krate)\n     };\n \n@@ -36,40 +44,89 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n     stripper.fold_crate(krate)\n }\n \n-struct Stripper<'a> {\n+struct Stripper<'a, 'tcx> {\n     retained: &'a mut ItemIdSet,\n     update_retained: bool,\n+    tcx: TyCtxt<'tcx>,\n+    is_in_hidden_item: bool,\n+}\n+\n+impl<'a, 'tcx> Stripper<'a, 'tcx> {\n+    fn set_is_in_hidden_item_and_fold(&mut self, is_in_hidden_item: bool, i: Item) -> Item {\n+        let prev = self.is_in_hidden_item;\n+        self.is_in_hidden_item |= is_in_hidden_item;\n+        let ret = self.fold_item_recur(i);\n+        self.is_in_hidden_item = prev;\n+        ret\n+    }\n+\n+    /// In case `i` is a non-hidden impl block, then we special-case it by changing the value\n+    /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n+    fn recurse_in_impl(&mut self, i: Item) -> Item {\n+        let prev = mem::replace(&mut self.is_in_hidden_item, false);\n+        let ret = self.fold_item_recur(i);\n+        self.is_in_hidden_item = prev;\n+        ret\n+    }\n }\n \n-impl<'a> DocFolder for Stripper<'a> {\n+impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n-            debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n-            // Use a dedicated hidden item for fields, variants, and modules.\n-            // We need to keep private fields and variants, so that the docs\n-            // can show a placeholder \"// some variants omitted\". We need to keep\n-            // private modules, because they can contain impl blocks, and impl\n-            // block privacy is inherited from the type and trait, not from the\n-            // module it's defined in. Both of these are marked \"stripped,\" and\n-            // not included in the final docs, but since they still have an effect\n-            // on the final doc, cannot be completely removed from the Clean IR.\n-            match *i.kind {\n-                clean::StructFieldItem(..) | clean::ModuleItem(..) | clean::VariantItem(..) => {\n-                    // We need to recurse into stripped modules to\n-                    // strip things like impl methods but when doing so\n-                    // we must not add any items to the `retained` set.\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = strip_item(self.fold_item_recur(i));\n-                    self.update_retained = old;\n-                    return Some(ret);\n-                }\n-                _ => return None,\n+        let has_doc_hidden = i.attrs.lists(sym::doc).has_word(sym::hidden);\n+        let is_impl = matches!(*i.kind, clean::ImplItem(..));\n+        let mut is_hidden = has_doc_hidden;\n+        if !is_impl {\n+            is_hidden = self.is_in_hidden_item || has_doc_hidden;\n+            if !is_hidden && i.inline_stmt_id.is_none() {\n+                // We don't need to check if it's coming from a reexport since the reexport itself was\n+                // already checked.\n+                is_hidden = i\n+                    .item_id\n+                    .as_def_id()\n+                    .and_then(|def_id| def_id.as_local())\n+                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n+                    .unwrap_or(false);\n             }\n-        } else {\n+        }\n+        if !is_hidden {\n             if self.update_retained {\n                 self.retained.insert(i.item_id);\n             }\n+            return Some(if is_impl {\n+                self.recurse_in_impl(i)\n+            } else {\n+                self.set_is_in_hidden_item_and_fold(false, i)\n+            });\n+        }\n+        debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n+        // Use a dedicated hidden item for fields, variants, and modules.\n+        // We need to keep private fields and variants, so that the docs\n+        // can show a placeholder \"// some variants omitted\". We need to keep\n+        // private modules, because they can contain impl blocks, and impl\n+        // block privacy is inherited from the type and trait, not from the\n+        // module it's defined in. Both of these are marked \"stripped,\" and\n+        // not included in the final docs, but since they still have an effect\n+        // on the final doc, cannot be completely removed from the Clean IR.\n+        match *i.kind {\n+            clean::StructFieldItem(..) | clean::ModuleItem(..) | clean::VariantItem(..) => {\n+                // We need to recurse into stripped modules to\n+                // strip things like impl methods but when doing so\n+                // we must not add any items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = strip_item(self.set_is_in_hidden_item_and_fold(true, i));\n+                self.update_retained = old;\n+                Some(ret)\n+            }\n+            _ => {\n+                let ret = self.set_is_in_hidden_item_and_fold(true, i);\n+                if has_doc_hidden {\n+                    // If the item itself has `#[doc(hidden)]`, then we simply remove it.\n+                    None\n+                } else {\n+                    // However if it's a \"descendant\" of a `#[doc(hidden)]` item, then we strip it.\n+                    Some(strip_item(ret))\n+                }\n+            }\n         }\n-        Some(self.fold_item_recur(i))\n     }\n }"}, {"sha": "088cb3f339492be74fc4e8091b5693f7e2427fdc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 138, "deletions": 66, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -5,7 +5,9 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LocalDefIdSet};\n+use rustc_hir::intravisit::{walk_item, Visitor};\n use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -53,39 +55,54 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: LocalDefId) -> bool {\n-    while let Some(id) = tcx.opt_local_parent(node) {\n-        node = id;\n-        if tcx.is_doc_hidden(node.to_def_id()) {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut def_id: LocalDefId) -> bool {\n+    let hir = tcx.hir();\n+    while let Some(id) = tcx.opt_local_parent(def_id) {\n+        def_id = id;\n+        if tcx.is_doc_hidden(def_id.to_def_id()) {\n             return true;\n+        } else if let Some(node) = hir.find_by_def_id(def_id) &&\n+            matches!(\n+                node,\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }),\n+            )\n+        {\n+            // `impl` blocks stand a bit on their own: unless they have `#[doc(hidden)]` directly\n+            // on them, they don't inherit it from the parent context.\n+            return false;\n         }\n     }\n     false\n }\n \n-// Also, is there some reason that this doesn't use the 'visit'\n-// framework from syntax?.\n-\n pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: LocalDefIdSet,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n     exact_paths: DefIdMap<Vec<Symbol>>,\n+    modules: Vec<Module<'tcx>>,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = LocalDefIdSet::default();\n         stack.insert(CRATE_DEF_ID);\n+        let om = Module::new(\n+            cx.tcx.crate_name(LOCAL_CRATE),\n+            CRATE_DEF_ID,\n+            cx.tcx.hir().root_module().spans.inner_span,\n+        );\n+\n         RustdocVisitor {\n             cx,\n             view_item_stack: stack,\n             inlining: false,\n             inside_public_path: true,\n             exact_paths: Default::default(),\n+            modules: vec![om],\n         }\n     }\n \n@@ -95,12 +112,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub(crate) fn visit(mut self) -> Module<'tcx> {\n-        let mut top_level_module = self.visit_mod_contents(\n-            CRATE_DEF_ID,\n-            self.cx.tcx.hir().root_module(),\n-            self.cx.tcx.crate_name(LOCAL_CRATE),\n-            None,\n-        );\n+        let root_module = self.cx.tcx.hir().root_module();\n+        self.visit_mod_contents(CRATE_DEF_ID, root_module);\n+\n+        let mut top_level_module = self.modules.pop().unwrap();\n \n         // `#[macro_export] macro_rules!` items are reexported at the top level of the\n         // crate, regardless of where they're defined. We want to document the\n@@ -115,15 +130,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // macro in the same module.\n         let mut inserted = FxHashSet::default();\n         for export in self.cx.tcx.module_reexports(CRATE_DEF_ID).unwrap_or(&[]) {\n-            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n-                if let Some(local_def_id) = def_id.as_local() {\n-                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n-                        if inserted.insert(def_id) {\n-                            let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                            top_level_module.items.push((item, None, None));\n-                        }\n-                    }\n-                }\n+            if let Res::Def(DefKind::Macro(_), def_id) = export.res &&\n+                let Some(local_def_id) = def_id.as_local() &&\n+                self.cx.tcx.has_attr(def_id, sym::macro_export) &&\n+                inserted.insert(def_id)\n+            {\n+                    let item = self.cx.tcx.hir().expect_item(local_def_id);\n+                    top_level_module.items.push((item, None, None));\n             }\n         }\n \n@@ -157,35 +170,34 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         top_level_module\n     }\n \n-    fn visit_mod_contents(\n-        &mut self,\n-        def_id: LocalDefId,\n-        m: &'tcx hir::Mod<'tcx>,\n-        name: Symbol,\n-        parent_id: Option<LocalDefId>,\n-    ) -> Module<'tcx> {\n-        let mut om = Module::new(name, def_id, m.spans.inner_span);\n+    /// This method will go through the given module items in two passes:\n+    /// 1. The items which are not glob imports/reexports.\n+    /// 2. The glob imports/reexports.\n+    fn visit_mod_contents(&mut self, def_id: LocalDefId, m: &'tcx hir::Mod<'tcx>) {\n+        debug!(\"Going through module {:?}\", m);\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= self.cx.tcx.local_visibility(def_id).is_public();\n+\n+        // Reimplementation of `walk_mod` because we need to do it in two passes (explanations in\n+        // the second loop):\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n-            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                continue;\n+            if !matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n+                self.visit_item(item);\n             }\n-            self.visit_item(item, None, &mut om, parent_id);\n         }\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             // To match the way import precedence works, visit glob imports last.\n             // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n             // imported items appear last, then they'll be the ones that get discarded.\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item, None, &mut om, parent_id);\n+                self.visit_item(item);\n             }\n         }\n         self.inside_public_path = orig_inside_public_path;\n-        om\n+        debug!(\"Leaving module {:?}\", m);\n     }\n \n     /// Tries to resolve the target of a `pub use` statement and inlines the\n@@ -203,7 +215,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         res: Res,\n         renamed: Option<Symbol>,\n         glob: bool,\n-        om: &mut Module<'tcx>,\n         please_inline: bool,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n@@ -213,33 +224,30 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let tcx = self.cx.tcx;\n-        let Some(res_did) = res.opt_def_id() else {\n+        let Some(ori_res_did) = res.opt_def_id() else {\n             return false;\n         };\n \n         let use_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n-            || tcx.is_doc_hidden(def_id.to_def_id());\n+            || use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n-        if !res_did.is_local() && !is_no_inline {\n-            crate::visit_lib::lib_embargo_visit_item(self.cx, res_did);\n+        if !ori_res_did.is_local() && !is_no_inline {\n+            crate::visit_lib::lib_embargo_visit_item(self.cx, ori_res_did);\n             return false;\n         }\n \n-        let Some(res_did) = res_did.as_local() else {\n+        let Some(res_did) = ori_res_did.as_local() else {\n             return false;\n         };\n \n-        let is_private = !self\n-            .cx\n-            .cache\n-            .effective_visibilities\n-            .is_directly_public(self.cx.tcx, res_did.to_def_id());\n+        let is_private =\n+            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n@@ -256,20 +264,20 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om, Some(def_id));\n+                    self.visit_item_inner(i, None, Some(def_id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om, Some(def_id));\n+                self.visit_item_inner(it, renamed, Some(def_id));\n                 self.inlining = prev;\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_foreign_item(it, renamed, om);\n+                self.visit_foreign_item_inner(it, renamed);\n                 self.inlining = prev;\n                 true\n             }\n@@ -279,18 +287,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    fn visit_item(\n+    #[inline]\n+    fn add_to_current_mod(\n         &mut self,\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n-        om: &mut Module<'tcx>,\n         parent_id: Option<LocalDefId>,\n     ) {\n+        self.modules.last_mut().unwrap().items.push((item, renamed, parent_id))\n+    }\n+\n+    fn visit_item_inner(\n+        &mut self,\n+        item: &'tcx hir::Item<'_>,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) -> bool {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n+        let tcx = self.cx.tcx;\n \n         let def_id = item.owner_id.to_def_id();\n-        let is_pub = self.cx.tcx.visibility(def_id).is_public();\n+        let is_pub = tcx.visibility(def_id).is_public();\n \n         if is_pub {\n             self.store_path(item.owner_id.to_def_id());\n@@ -299,8 +317,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         match item.kind {\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for item in items {\n-                    let item = self.cx.tcx.hir().foreign_item(item.id);\n-                    self.visit_foreign_item(item, None, om);\n+                    let item = tcx.hir().foreign_item(item.id);\n+                    self.visit_foreign_item_inner(item, None);\n                 }\n             }\n             // If we're inlining, skip private items or item reexported as \"_\".\n@@ -315,7 +333,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    let attrs = self.cx.tcx.hir().attrs(item.hir_id());\n+                    let attrs =\n+                        tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(item.owner_id.def_id));\n \n                     // If there was a private module in the current path then don't bother inlining\n                     // anything as it will probably be stripped anyway.\n@@ -333,14 +352,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             res,\n                             ident,\n                             is_glob,\n-                            om,\n                             please_inline,\n                         ) {\n                             continue;\n                         }\n                     }\n \n-                    om.items.push((item, renamed, parent_id))\n+                    self.add_to_current_mod(item, renamed, import_id);\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n@@ -357,14 +375,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 let def_id = item.owner_id.to_def_id();\n                 let is_macro_2_0 = !macro_def.macro_rules;\n-                let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n+                let nonexported = !tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    om.items.push((item, renamed, None));\n+                    self.add_to_current_mod(item, renamed, None);\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.owner_id.def_id, m, name, parent_id));\n+                self.enter_mod(item.owner_id.def_id, m, name);\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -375,33 +393,87 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed, parent_id)),\n+            | hir::ItemKind::TraitAlias(..) => {\n+                self.add_to_current_mod(item, renamed, import_id);\n+            }\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if name != kw::Underscore {\n-                    om.items.push((item, renamed, parent_id));\n+                    self.add_to_current_mod(item, renamed, import_id);\n                 }\n             }\n             hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {\n-                    om.items.push((item, None, None));\n+                    self.add_to_current_mod(item, None, None);\n                 }\n             }\n         }\n+        true\n     }\n \n-    fn visit_foreign_item(\n+    fn visit_foreign_item_inner(\n         &mut self,\n         item: &'tcx hir::ForeignItem<'_>,\n         renamed: Option<Symbol>,\n-        om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n         if !self.inlining || self.cx.tcx.visibility(item.owner_id).is_public() {\n-            om.foreigns.push((item, renamed));\n+            self.modules.last_mut().unwrap().foreigns.push((item, renamed));\n+        }\n+    }\n+\n+    /// This method will create a new module and push it onto the \"modules stack\" then call\n+    /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n+    /// add into the list of modules of the current module.\n+    fn enter_mod(&mut self, id: LocalDefId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n+        self.modules.push(Module::new(name, id, m.spans.inner_span));\n+\n+        self.visit_mod_contents(id, m);\n+\n+        let last = self.modules.pop().unwrap();\n+        self.modules.last_mut().unwrap().mods.push(last);\n+    }\n+}\n+\n+// We need to implement this visitor so it'll go everywhere and retrieve items we're interested in\n+// such as impl blocks in const blocks.\n+impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n+        if self.visit_item_inner(i, None, None) {\n+            walk_item(self, i);\n         }\n     }\n+\n+    fn visit_mod(&mut self, _: &hir::Mod<'tcx>, _: Span, _: hir::HirId) {\n+        // Handled in `visit_item_inner`\n+    }\n+\n+    fn visit_use(&mut self, _: &hir::UsePath<'tcx>, _: hir::HirId) {\n+        // Handled in `visit_item_inner`\n+    }\n+\n+    fn visit_path(&mut self, _: &hir::Path<'tcx>, _: hir::HirId) {\n+        // Handled in `visit_item_inner`\n+    }\n+\n+    fn visit_label(&mut self, _: &rustc_ast::Label) {\n+        // Unneeded.\n+    }\n+\n+    fn visit_infer(&mut self, _: &hir::InferArg) {\n+        // Unneeded.\n+    }\n+\n+    fn visit_lifetime(&mut self, _: &hir::Lifetime) {\n+        // Unneeded.\n+    }\n }"}, {"sha": "939da186fbcdb2dcac7b1f6b7f5dca4d7c280f32", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait-return.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -1,12 +1,10 @@\n-// check-pass\n // normalize-stderr-test: \"`.*`\" -> \"`DEF_ID`\"\n // normalize-stdout-test: \"`.*`\" -> \"`DEF_ID`\"\n // edition:2018\n \n pub async fn f() -> impl std::fmt::Debug {\n-    // rustdoc doesn't care that this is infinitely sized\n     #[derive(Debug)]\n-    enum E {\n+    enum E { //~ ERROR\n         This(E),\n         Unit,\n     }"}, {"sha": "aff7402bc91c65b931304009dae9a059fafe10b3", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait-return.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -0,0 +1,16 @@\n+error[E0072]: recursive type `DEF_ID` has infinite size\n+  --> $DIR/infinite-recursive-type-impl-trait-return.rs:7:5\n+   |\n+LL |     enum E {\n+   |     ^^^^^^\n+LL |         This(E),\n+   |              - recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `DEF_ID`) to break the cycle\n+   |\n+LL |         This(Box<E>),\n+   |              ++++ +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `DEF_ID`."}, {"sha": "ac51725749867cea7f7b979839320140378480d3", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -1,8 +1,5 @@\n-// check-pass\n-\n fn f() -> impl Sized {\n-    // rustdoc doesn't care that this is infinitely sized\n-    enum E {\n+    enum E { //~ ERROR\n         V(E),\n     }\n     unimplemented!()"}, {"sha": "a61577bd14afce57afb9e4adabdeb9329774a656", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -0,0 +1,16 @@\n+error[E0072]: recursive type `f::E` has infinite size\n+  --> $DIR/infinite-recursive-type-impl-trait.rs:2:5\n+   |\n+LL |     enum E {\n+   |     ^^^^^^\n+LL |         V(E),\n+   |           - recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL |         V(Box<E>),\n+   |           ++++ +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "834ba5231a1e1aee2709248c2512767c22e408b3", "filename": "tests/rustdoc/hidden-private.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc%2Fhidden-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc%2Fhidden-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fhidden-private.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -0,0 +1,50 @@\n+// This is a regression test for <https://github.com/rust-lang/rust/issues/106373>.\n+// It ensures that the items in the `doc(hidden)` const block don't show up in the\n+// generated docs.\n+\n+// compile-flags: --document-private-items\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @count - '//*[@class=\"item-table\"]//a[@class=\"struct\"]' 2\n+// @count - '//*[@class=\"item-table\"]//a[@class=\"trait\"]' 1\n+// @count - '//*[@class=\"item-table\"]//a[@class=\"macro\"]' 0\n+#[doc(hidden)]\n+const _: () = {\n+    macro_rules! stry {\n+        () => {};\n+    }\n+\n+    struct ShouldBeHidden;\n+\n+    // @has 'foo/struct.Foo.html'\n+    // @!has - '//*[@class=\"code-header\"]' 'impl Bar for Foo'\n+    #[doc(hidden)]\n+    impl Bar for Foo {\n+        fn bar(&self) {\n+            struct SHouldAlsoBeHidden;\n+        }\n+    }\n+\n+    // @has 'foo/struct.Private.html'\n+    // @has - '//*[@id=\"impl-Bar-for-Private\"]/*[@class=\"code-header\"]' 'impl Bar for Private'\n+    // @has - '//*[@id=\"method.bar\"]/*[@class=\"code-header\"]' 'fn bar(&self)'\n+    impl Bar for Private {\n+        fn bar(&self) {}\n+    }\n+\n+    // @has - '//*[@id=\"impl-Private\"]/*[@class=\"code-header\"]' 'impl Private'\n+    // @has - '//*[@id=\"method.tralala\"]/*[@class=\"code-header\"]' 'fn tralala()'\n+    impl Private {\n+        fn tralala() {}\n+    }\n+};\n+\n+\n+struct Private;\n+pub struct Foo;\n+\n+pub trait Bar {\n+    fn bar(&self);\n+}"}, {"sha": "b44e713524668d6dcdd11cd9b4f30be5b221f51a", "filename": "tests/rustdoc/impl-in-const-block.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc%2Fimpl-in-const-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc%2Fimpl-in-const-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fimpl-in-const-block.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -0,0 +1,43 @@\n+// Regression test for #83026.\n+// The goal of this test is to ensure that impl blocks inside\n+// const expressions are documented as well.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.A.html'\n+// @has - '//*[@id=\"method.new\"]/*[@class=\"code-header\"]' 'pub fn new() -> A'\n+// @has - '//*[@id=\"method.bar\"]/*[@class=\"code-header\"]' 'pub fn bar(&self)'\n+// @has - '//*[@id=\"method.woo\"]/*[@class=\"code-header\"]' 'pub fn woo(&self)'\n+// @has - '//*[@id=\"method.yoo\"]/*[@class=\"code-header\"]' 'pub fn yoo()'\n+// @has - '//*[@id=\"method.yuu\"]/*[@class=\"code-header\"]' 'pub fn yuu()'\n+pub struct A;\n+\n+const _: () = {\n+    impl A {\n+        const FOO: () = {\n+            impl A {\n+                pub fn woo(&self) {}\n+            }\n+        };\n+\n+        pub fn new() -> A {\n+            A\n+        }\n+    }\n+};\n+pub const X: () = {\n+    impl A {\n+        pub fn bar(&self) {}\n+    }\n+};\n+\n+fn foo() {\n+    impl A {\n+        pub fn yoo() {}\n+    }\n+    const _: () = {\n+        impl A {\n+            pub fn yuu() {}\n+        }\n+    };\n+}"}, {"sha": "5b7a76e1a7739403e4f66a8bda012e8f9413eb6d", "filename": "tests/rustdoc/redirect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc%2Fredirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c991b07403a3234dd1ec0ac973b8ef97055e605/tests%2Frustdoc%2Fredirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fredirect.rs?ref=6c991b07403a3234dd1ec0ac973b8ef97055e605", "patch": "@@ -9,9 +9,10 @@ pub trait Foo {}\n // @has redirect/index.html\n // @has - '//code' 'pub use reexp_stripped::Bar'\n // @has - '//code/a' 'Bar'\n+// @has - '//a[@href=\"../reexp_stripped/hidden/struct.Bar.html\"]' 'Bar'\n // @has reexp_stripped/hidden/struct.Bar.html\n-// @has - '//p/a' '../../reexp_stripped/struct.Bar.html'\n // @has 'reexp_stripped/struct.Bar.html'\n+// @has - '//a[@href=\"struct.Bar.html\"]' 'Bar'\n #[doc(no_inline)]\n pub use reexp_stripped::Bar;\n impl Foo for Bar {}"}]}