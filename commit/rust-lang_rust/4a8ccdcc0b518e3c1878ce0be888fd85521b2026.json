{"sha": "4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhOGNjZGNjMGI1MThlM2MxODc4Y2UwYmU4ODhmZDg1NTIxYjIwMjY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-05-19T23:45:58Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-05-19T23:47:23Z"}, "message": "Use a fixed-point iteration when breaking tokens\n\nSome tokens need to be broken in a loop until we reach\n'unbreakable' tokens.", "tree": {"sha": "d51dad07c7b6573596f6b35fc4847b474823663f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d51dad07c7b6573596f6b35fc4847b474823663f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl7EcBEACgkQtAh+UQ6Y\nsWS9OA/6A39RITeHoTCZRa5sPTYEmW/pZ13P9fpQQFgEG/ipD9aNRniI42d6nZuL\nTE7j+YzuOy3dTCIig0m8VPrtOs819k/66LtOgu4+HcWc8ICKclEnZ6Bny3euLhdA\nhDUFP3FVdOqkXHWCu/JXAvHbGUUGueu7H6nGrFJuWy0yCjqtlyBXcD8LuZ/INZa6\ntCpOyfpqzEUSFO8jFPFzhzXXP2CeVXqN+N/kk1tyaRP1zUnRJNR3Dh/72jhL9ZF1\nfKU7f4kyiv6WjvKeTyBP3hMabhUY92OGQ7eZ+Px+kX2FLdGRwNMqrACUpJsJED/A\nwNRgPMBXPdWsLgmdmmPf7T0GDHDKR6lCRFlnXfhIRvNYp/ABAlEhW2DBJTjpzNXw\nrAesysdz3ukhyLhwOkwFphvELnivqj3UtGU0E2y+qv0VHcfSPvIHyz3WC9Y/HCDD\nXuYLtAFUCDsbd3r/I2/c3Ao7CNW/z4qdm8CDcGYj4sxokIrUARUEmfzagndcjEPm\nopfl9gH02Oj4NHfbh/dRe5e18TqAI9ImSnzL9/fMWsRvVpJRowC5XLZnQ3SPhgT+\n/oE9ksq0BsmJ1ZO/OwvPZvNpRqzfF03yDCwao4BgGAqATNuD5MDNe8PPbzQ+Tx7h\nCL1u+K7IKpJVWMa94Bxgma6Xivoq4Ltamte82FRmD36Lqi6sQwE=\n=S/8i\n-----END PGP SIGNATURE-----", "payload": "tree d51dad07c7b6573596f6b35fc4847b474823663f\nparent 9b2b8a5afa833795b66267684615497c9547878d\nauthor Aaron Hill <aa1ronham@gmail.com> 1589931958 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1589932043 -0400\n\nUse a fixed-point iteration when breaking tokens\n\nSome tokens need to be broken in a loop until we reach\n'unbreakable' tokens.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "html_url": "https://github.com/rust-lang/rust/commit/4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b2b8a5afa833795b66267684615497c9547878d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2b8a5afa833795b66267684615497c9547878d", "html_url": "https://github.com/rust-lang/rust/commit/9b2b8a5afa833795b66267684615497c9547878d"}], "stats": {"total": 100, "additions": 77, "deletions": 23}, "files": [{"sha": "075aaa7e5bc013dd5b0d9744d6ec73efda73de18", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "patch": "@@ -21,6 +21,8 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n+use log::debug;\n+\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -358,14 +360,47 @@ impl TokenStream {\n         // leading to some tokens being 'glued' together in one stream but not\n         // the other. See #68489 for more details.\n         fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+            // In almost all cases, we should have either zero or one levels\n+            // of 'unglueing'. However, in some unusual cases, we may need\n+            // to iterate breaking tokens mutliple times. For example:\n+            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+            let mut token_trees: SmallVec<[_; 2]>;\n             if let TokenTree::Token(token) = &tree {\n-                if let Some((first, second)) = token.kind.break_two_token_op() {\n-                    return SmallVec::from_buf([TokenTree::Token(Token::new(first, DUMMY_SP)), TokenTree::Token(Token::new(second, DUMMY_SP))]).into_iter()\n+                let mut out = SmallVec::<[_; 2]>::new();\n+                out.push(token.clone());\n+                // Iterate to fixpoint:\n+                // * We start off with 'out' containing our initial token, and `temp` empty\n+                // * If we are able to break any tokens in `out`, then `out` will have\n+                //   at least one more element than 'temp', so we will try to break tokens\n+                //   again.\n+                // * If we cannot break any tokens in 'out', we are done\n+                loop {\n+                    let mut temp = SmallVec::<[_; 2]>::new();\n+                    let mut changed = false;\n+\n+                    for token in out.into_iter() {\n+                        if let Some((first, second)) = token.kind.break_two_token_op() {\n+                            temp.push(Token::new(first, DUMMY_SP));\n+                            temp.push(Token::new(second, DUMMY_SP));\n+                            changed = true;\n+                        } else {\n+                            temp.push(token);\n+                        }\n+                    }\n+                    out = temp;\n+                    if !changed {\n+                        break;\n+                    }\n+                }\n+                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                if token_trees.len() != 1 {\n+                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n                 }\n+            } else {\n+                token_trees = SmallVec::new();\n+                token_trees.push(tree);\n             }\n-            let mut vec = SmallVec::<[_; 2]>::new();\n-            vec.push(tree);\n-            vec.into_iter()\n+            token_trees.into_iter()\n         }\n \n         let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);"}, {"sha": "ce8b9ebb4f9d25250d22ccd3bf53099d621e994c", "filename": "src/test/ui/proc-macro/break-token-spans.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs?ref=4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:test-macros.rs\n+// Regression test for issues #68489 and #70987\n+// Tests that we properly break tokens in `probably_equal_for_proc_macro`\n+// See #72306\n+// \n+// Note that the weird spacing in this example is critical\n+// for testing the issue.\n+\n+extern crate test_macros;\n+\n+#[test_macros::recollect_attr]\n+fn repro() {\n+    f :: < Vec < _ > > ( ) ; //~ ERROR cannot find\n+    let a: Option<Option<u8>>= true; //~ ERROR mismatched\n+}\n+fn main() {}"}, {"sha": "caca973f252f7fe442d8d904a4eb26cdbbf4c9d4", "filename": "src/test/ui/proc-macro/break-token-spans.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdcc0b518e3c1878ce0be888fd85521b2026/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr?ref=4a8ccdcc0b518e3c1878ce0be888fd85521b2026", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/break-token-spans.rs:13:5\n+   |\n+LL |     f :: < Vec < _ > > ( ) ;\n+   |     ^ not found in this scope\n+\n+error[E0308]: mismatched types\n+  --> $DIR/break-token-spans.rs:14:32\n+   |\n+LL |     let a: Option<Option<u8>>= true;\n+   |            ------------------  ^^^^ expected enum `std::option::Option`, found `bool`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected enum `std::option::Option<std::option::Option<u8>>`\n+              found type `bool`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0425.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "a255955f38da069429b9fc058e5032fd330cbd65", "filename": "src/test/ui/proc-macro/turbo-proc-macro.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b2b8a5afa833795b66267684615497c9547878d/src%2Ftest%2Fui%2Fproc-macro%2Fturbo-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2b8a5afa833795b66267684615497c9547878d/src%2Ftest%2Fui%2Fproc-macro%2Fturbo-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fturbo-proc-macro.rs?ref=9b2b8a5afa833795b66267684615497c9547878d", "patch": "@@ -1,9 +0,0 @@\n-// aux-build:test-macros.rs\n-\n-extern crate test_macros;\n-\n-#[test_macros::recollect_attr]\n-fn repro() {\n-    f :: < Vec < _ > > ( ) ; //~ ERROR cannot find\n-}\n-fn main() {}"}, {"sha": "85c93b9345c370623fe65132d1736ea99b1dcd1f", "filename": "src/test/ui/proc-macro/turbo-proc-macro.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b2b8a5afa833795b66267684615497c9547878d/src%2Ftest%2Fui%2Fproc-macro%2Fturbo-proc-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2b8a5afa833795b66267684615497c9547878d/src%2Ftest%2Fui%2Fproc-macro%2Fturbo-proc-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fturbo-proc-macro.stderr?ref=9b2b8a5afa833795b66267684615497c9547878d", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find function `f` in this scope\n-  --> $DIR/turbo-proc-macro.rs:7:5\n-   |\n-LL |     f :: < Vec < _ > > ( ) ;\n-   |     ^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}]}