{"sha": "d49f27826388ae62467d2111f9e82a828c3e2ea8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OWYyNzgyNjM4OGFlNjI0NjdkMjExMWY5ZTgyYTgyOGMzZTJlYTg=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2017-07-23T13:30:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-05T16:19:33Z"}, "message": "Add hints when intercrate ambiguity causes overlap.", "tree": {"sha": "ee1c8d84b4c4a0038a96bf75b69f968860d8e753", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee1c8d84b4c4a0038a96bf75b69f968860d8e753"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d49f27826388ae62467d2111f9e82a828c3e2ea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d49f27826388ae62467d2111f9e82a828c3e2ea8", "html_url": "https://github.com/rust-lang/rust/commit/d49f27826388ae62467d2111f9e82a828c3e2ea8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d49f27826388ae62467d2111f9e82a828c3e2ea8/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "html_url": "https://github.com/rust-lang/rust/commit/2f1ef9ef1181298d46e79d5dde6bafeb6483926f"}], "stats": {"total": 117, "additions": 95, "deletions": 22}, "files": [{"sha": "b7120ab31f0e3d4bcc055f81e18ab7509c430994", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=d49f27826388ae62467d2111f9e82a828c3e2ea8", "patch": "@@ -13,6 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n+use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Subst;\n \n@@ -21,12 +22,17 @@ use infer::{InferCtxt, InferOk};\n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n+pub struct OverlapResult<'tcx> {\n+    pub impl_header: ty::ImplHeader<'tcx>,\n+    pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+}\n+\n /// If there are types that satisfy both impls, returns a suitably-freshened\n /// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n                                           impl1_def_id: DefId,\n                                           impl2_def_id: DefId)\n-                                          -> Option<ty::ImplHeader<'tcx>>\n+                                          -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -65,7 +71,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                             a_def_id: DefId,\n                             b_def_id: DefId)\n-                            -> Option<ty::ImplHeader<'tcx>>\n+                            -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n@@ -113,7 +119,10 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n         return None\n     }\n \n-    Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n+    Some(OverlapResult {\n+        impl_header: selcx.infcx().resolve_type_vars_if_possible(&a_impl_header),\n+        intercrate_ambiguity_causes: selcx.intercrate_ambiguity_causes().to_vec(),\n+    })\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "22c92776c5e4e01a9516a1bdfb2c6fd592abfa07", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d49f27826388ae62467d2111f9e82a828c3e2ea8", "patch": "@@ -28,9 +28,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub use self::coherence::orphan_check;\n-pub use self::coherence::overlapping_impls;\n-pub use self::coherence::OrphanCheckErr;\n+pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n@@ -39,6 +37,7 @@ pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n+pub use self::select::IntercrateAmbiguityCause;\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::util::elaborate_predicates;"}, {"sha": "6815cb8c55ebd060691edbb63ed304d7dc847371", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d49f27826388ae62467d2111f9e82a828c3e2ea8", "patch": "@@ -90,6 +90,14 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     intercrate: bool,\n \n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n+\n+    intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+}\n+\n+#[derive(Clone)]\n+pub enum IntercrateAmbiguityCause {\n+    DownstreamCrate(DefId),\n+    UpstreamCrateUpdate(DefId),\n }\n \n // A stack that walks back up the stack frame.\n@@ -380,6 +388,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             freshener: infcx.freshener(),\n             intercrate: false,\n             inferred_obligations: SnapshotVec::new(),\n+            intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n@@ -389,6 +398,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             freshener: infcx.freshener(),\n             intercrate: true,\n             inferred_obligations: SnapshotVec::new(),\n+            intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n@@ -404,6 +414,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n+    pub fn intercrate_ambiguity_causes(&self) -> &[IntercrateAmbiguityCause] {\n+        &self.intercrate_ambiguity_causes\n+    }\n+\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n@@ -757,6 +771,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if unbound_input_types && self.intercrate {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n+            // Heuristics: show the diagnostics when there are no candidates in crate.\n+            if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                    let did = stack.fresh_trait_ref.def_id();\n+                    self.intercrate_ambiguity_causes.push(\n+                        IntercrateAmbiguityCause::DownstreamCrate(did));\n+                }\n+            }\n             return EvaluatedToAmbig;\n         }\n         if unbound_input_types &&\n@@ -1003,6 +1025,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if !self.is_knowable(stack) {\n             debug!(\"coherence stage: not knowable\");\n+            // Heuristics: show the diagnostics when there are no candidates in crate.\n+            let candidate_set = self.assemble_candidates(stack)?;\n+            if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                let did = stack.obligation.predicate.def_id();\n+                self.intercrate_ambiguity_causes.push(\n+                    IntercrateAmbiguityCause::UpstreamCrateUpdate(did));\n+            }\n             return Ok(None);\n         }\n "}, {"sha": "50518d36e6145238532f4551edce01b2db1c6c69", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d49f27826388ae62467d2111f9e82a828c3e2ea8", "patch": "@@ -25,6 +25,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n+use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n@@ -36,6 +37,7 @@ pub struct OverlapError {\n     pub with_impl: DefId,\n     pub trait_desc: String,\n     pub self_desc: Option<String>,\n+    pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n }\n \n /// Given a subst for the requested impl, translate it to a subst\n@@ -337,6 +339,20 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                     }\n                 }\n \n+                for cause in &overlap.intercrate_ambiguity_causes {\n+                    match cause {\n+                        &IntercrateAmbiguityCause::DownstreamCrate(def_id) => {\n+                            err.note(&format!(\"downstream crates may implement {}\",\n+                                              tcx.item_path_str(def_id)));\n+                        }\n+                        &IntercrateAmbiguityCause::UpstreamCrateUpdate(def_id) => {\n+                            err.note(&format!(\"upstream crates may add new impl for {} \\\n+                                              in future versions\",\n+                                              tcx.item_path_str(def_id)));\n+                        }\n+                    }\n+                }\n+\n                 err.emit();\n             }\n         } else {"}, {"sha": "2640542ad10593366fd782c176dae7ed1eb04504", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=d49f27826388ae62467d2111f9e82a828c3e2ea8", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);\n-                if let Some(impl_header) = overlap {\n+                if let Some(overlap) = overlap {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n                     }\n@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Children {\n \n                     if le == ge {\n                         // overlap, but no specialization; error out\n-                        let trait_ref = impl_header.trait_ref.unwrap();\n+                        let trait_ref = overlap.impl_header.trait_ref.unwrap();\n                         let self_ty = trait_ref.self_ty();\n                         Err(OverlapError {\n                             with_impl: possible_sibling,\n@@ -135,7 +135,8 @@ impl<'a, 'gcx, 'tcx> Children {\n                                 Some(self_ty.to_string())\n                             } else {\n                                 None\n-                            }\n+                            },\n+                            intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n                         })\n                     } else {\n                         Ok((le, ge))"}, {"sha": "07de54233041c3578ea33769a37e5108a2754aaf", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49f27826388ae62467d2111f9e82a828c3e2ea8/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=d49f27826388ae62467d2111f9e82a828c3e2ea8", "patch": "@@ -12,6 +12,7 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits;\n+use rustc::traits::IntercrateAmbiguityCause;\n use rustc::ty::{self, TyCtxt};\n \n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -26,7 +27,8 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n+                                       overlap: traits::OverlapResult) {\n         #[derive(Copy, Clone, PartialEq)]\n         enum Namespace {\n             Type,\n@@ -50,16 +52,32 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    struct_span_err!(self.tcx.sess,\n-                                     self.tcx.span_of_impl(item1).unwrap(),\n-                                     E0592,\n-                                     \"duplicate definitions with name `{}`\",\n-                                     name)\n-                        .span_label(self.tcx.span_of_impl(item1).unwrap(),\n-                                    format!(\"duplicate definitions for `{}`\", name))\n-                        .span_label(self.tcx.span_of_impl(item2).unwrap(),\n-                                    format!(\"other definition for `{}`\", name))\n-                        .emit();\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   self.tcx.span_of_impl(item1).unwrap(),\n+                                                   E0592,\n+                                                   \"duplicate definitions with name `{}`\",\n+                                                   name);\n+\n+                    err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n+                                   format!(\"duplicate definitions for `{}`\", name));\n+                    err.span_label(self.tcx.span_of_impl(item2).unwrap(),\n+                                   format!(\"other definition for `{}`\", name));\n+\n+                    for cause in &overlap.intercrate_ambiguity_causes {\n+                        match cause {\n+                            &IntercrateAmbiguityCause::DownstreamCrate(def_id) => {\n+                                err.note(&format!(\"downstream crates may implement {}\",\n+                                                  self.tcx.item_path_str(def_id)));\n+                            }\n+                            &IntercrateAmbiguityCause::UpstreamCrateUpdate(def_id) => {\n+                                err.note(&format!(\"upstream crates may add new impl for {} \\\n+                                                  in future versions\",\n+                                                  self.tcx.item_path_str(def_id)));\n+                            }\n+                        }\n+                    }\n+\n+                    err.emit();\n                 }\n             }\n         }\n@@ -71,8 +89,9 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n                 self.tcx.infer_ctxt().enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    if let Some(overlap) =\n+                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap)\n                     }\n                 });\n             }"}]}