{"sha": "8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "node_id": "C_kwDOAAsO6NoAKDhiMjQwOWNkN2QwZWRkOGQyMTA0YTZkY2FlZWFmNWY5NWZmMmFlZTA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-08T11:38:14Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-08T19:45:59Z"}, "message": "Rename FnCtxt::associated_item.", "tree": {"sha": "bb96c8c93278ad30a8b9b1fd474307e2f98fff9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb96c8c93278ad30a8b9b1fd474307e2f98fff9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "html_url": "https://github.com/rust-lang/rust/commit/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1be6e2d6e9df7de641b554987f87c775c1e37d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/1be6e2d6e9df7de641b554987f87c775c1e37d18", "html_url": "https://github.com/rust-lang/rust/commit/1be6e2d6e9df7de641b554987f87c775c1e37d18"}], "stats": {"total": 59, "additions": 19, "deletions": 40}, "files": [{"sha": "96db025158fb81493458497800d95c2cf85a76b2", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "patch": "@@ -369,7 +369,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = match self.associated_item(trait_def_id, m_name, Namespace::ValueNS) {\n+        let method_item = match self.associated_value(trait_def_id, m_name) {\n             Some(method_item) => method_item,\n             None => {\n                 tcx.sess.delay_span_bug(\n@@ -538,15 +538,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Finds item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    pub fn associated_item(\n-        &self,\n-        def_id: DefId,\n-        item_name: Ident,\n-        ns: Namespace,\n-    ) -> Option<ty::AssocItem> {\n+    pub fn associated_value(&self, def_id: DefId, item_name: Ident) -> Option<ty::AssocItem> {\n         self.tcx\n             .associated_items(def_id)\n-            .find_by_name_and_namespace(self.tcx, item_name, ns, def_id)\n+            .find_by_name_and_namespace(self.tcx, item_name, Namespace::ValueNS, def_id)\n             .copied()\n     }\n }"}, {"sha": "b704ff8c7cb2a2546dfa35918602589e5850cd6b", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "patch": "@@ -1915,7 +1915,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .collect()\n             } else {\n                 self.fcx\n-                    .associated_item(def_id, name, Namespace::ValueNS)\n+                    .associated_value(def_id, name)\n                     .map_or_else(SmallVec::new, |x| SmallVec::from_buf([x]))\n             }\n         } else {"}, {"sha": "dfe020ba82aca948f423fcac83494ab7cb6ed64f", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8b2409cd7d0edd8d2104a6dcaeeaf5f95ff2aee0", "patch": "@@ -5,7 +5,6 @@ use crate::check::FnCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::Namespace;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n@@ -99,16 +98,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = match self\n-                            .associated_item(impl_did, item_name, Namespace::ValueNS)\n-                            .or_else(|| {\n-                                let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n-                                self.associated_item(\n-                                    impl_trait_ref.def_id,\n-                                    item_name,\n-                                    Namespace::ValueNS,\n-                                )\n-                            }) {\n+                        let item = match self.associated_value(impl_did, item_name).or_else(|| {\n+                            let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n+                            self.associated_value(impl_trait_ref.def_id, item_name)\n+                        }) {\n                             Some(item) => item,\n                             None => continue,\n                         };\n@@ -187,11 +180,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item =\n-                            match self.associated_item(trait_did, item_name, Namespace::ValueNS) {\n-                                Some(item) => item,\n-                                None => continue,\n-                            };\n+                        let item = match self.associated_value(trait_did, item_name) {\n+                            Some(item) => item,\n+                            None => continue,\n+                        };\n                         let item_span = self\n                             .tcx\n                             .sess\n@@ -271,16 +263,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Suggest clamping down the type if the method that is being attempted to\n                     // be used exists at all, and the type is an ambiguous numeric type\n                     // ({integer}/{float}).\n-                    let mut candidates = all_traits(self.tcx).into_iter().filter_map(|info| {\n-                        self.associated_item(info.def_id, item_name, Namespace::ValueNS)\n-                    });\n+                    let mut candidates = all_traits(self.tcx)\n+                        .into_iter()\n+                        .filter_map(|info| self.associated_value(info.def_id, item_name));\n                     // There are methods that are defined on the primitive types and won't be\n                     // found when exploring `all_traits`, but we also need them to be acurate on\n                     // our suggestions (#47759).\n                     let fund_assoc = |opt_def_id: Option<DefId>| {\n-                        opt_def_id\n-                            .and_then(|id| self.associated_item(id, item_name, Namespace::ValueNS))\n-                            .is_some()\n+                        opt_def_id.and_then(|id| self.associated_value(id, item_name)).is_some()\n                     };\n                     let lang_items = tcx.lang_items();\n                     let found_candidate = candidates.next().is_some()\n@@ -398,11 +388,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             .inherent_impls(adt_deref.did)\n                                             .iter()\n                                             .filter_map(|def_id| {\n-                                                self.associated_item(\n-                                                    *def_id,\n-                                                    item_name,\n-                                                    Namespace::ValueNS,\n-                                                )\n+                                                self.associated_value(*def_id, item_name)\n                                             })\n                                             .count()\n                                             >= 1\n@@ -515,9 +501,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 .iter()\n                                 .copied()\n                                 .filter(|def_id| {\n-                                    if let Some(assoc) =\n-                                        self.associated_item(*def_id, item_name, Namespace::ValueNS)\n-                                    {\n+                                    if let Some(assoc) = self.associated_value(*def_id, item_name) {\n                                         // Check for both mode is the same so we avoid suggesting\n                                         // incorrect associated item.\n                                         match (mode, assoc.fn_has_self_parameter, source) {\n@@ -1588,7 +1572,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }) && (type_is_local || info.def_id.is_local())\n                     && self\n-                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n+                        .associated_value(info.def_id, item_name)\n                         .filter(|item| {\n                             if let ty::AssocKind::Fn = item.kind {\n                                 let id = item"}]}