{"sha": "dd3f9eaceb17f5686f6377250cbe510b348af318", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkM2Y5ZWFjZWIxN2Y1Njg2ZjYzNzcyNTBjYmU1MTBiMzQ4YWYzMTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-27T09:43:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-27T09:43:08Z"}, "message": "Merge #5007\n\n5007: SSR: Allow matching within macro calls r=matklad a=davidlattimore\n\n#3186 \n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "f8e5b4a36265a1f7af8891cd1f2dae593275ef06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8e5b4a36265a1f7af8891cd1f2dae593275ef06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd3f9eaceb17f5686f6377250cbe510b348af318", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9xSsCRBK7hj4Ov3rIwAAdHIIAFWHGKeivAY0hUr3swsdSX9G\n0JQlX2z1bVqzu0QxjUYI/2rJpvG71gTi856De9dTUMQ6R247dnp+wUaRi4OXRUgA\nGiAAB6m3HxUqnK0dVaW6tCEGqN1aRlJN8ETcwZ9n/DkjRVpn8SXlXY3FrE72lTU0\nv05jn7j/MYjc/jQ3JX87sYWGOeO6v/i5EeBs/BxOOzsvu0zjIJPekHpCO+PY5d4z\nd81xFun3kHCnsAEJQ6xJHOojuumuvqGSuiWNn+9FYt6QvaQ7l226SIgI4TZ9SwR0\nc8qGrnac+VRliLMhDu58Xt5luQ5zL4Z8heWAt3woXbLbWWsWyGTPs4/jIWbY+4U=\n=wFYQ\n-----END PGP SIGNATURE-----\n", "payload": "tree f8e5b4a36265a1f7af8891cd1f2dae593275ef06\nparent 656cbc68a1f500510cd721cee2c3a515da53dc31\nparent fc46c12e3641c5dcd18f4b32f85b2d8f33000cf6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593250988 +0000\ncommitter GitHub <noreply@github.com> 1593250988 +0000\n\nMerge #5007\n\n5007: SSR: Allow matching within macro calls r=matklad a=davidlattimore\n\n#3186 \n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd3f9eaceb17f5686f6377250cbe510b348af318", "html_url": "https://github.com/rust-lang/rust/commit/dd3f9eaceb17f5686f6377250cbe510b348af318", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd3f9eaceb17f5686f6377250cbe510b348af318/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "656cbc68a1f500510cd721cee2c3a515da53dc31", "url": "https://api.github.com/repos/rust-lang/rust/commits/656cbc68a1f500510cd721cee2c3a515da53dc31", "html_url": "https://github.com/rust-lang/rust/commit/656cbc68a1f500510cd721cee2c3a515da53dc31"}, {"sha": "fc46c12e3641c5dcd18f4b32f85b2d8f33000cf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc46c12e3641c5dcd18f4b32f85b2d8f33000cf6", "html_url": "https://github.com/rust-lang/rust/commit/fc46c12e3641c5dcd18f4b32f85b2d8f33000cf6"}], "stats": {"total": 83, "additions": 80, "deletions": 3}, "files": [{"sha": "8f149e3db656a45b15ae74dac641e33fa9f9aa07", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f9eaceb17f5686f6377250cbe510b348af318/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f9eaceb17f5686f6377250cbe510b348af318/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=dd3f9eaceb17f5686f6377250cbe510b348af318", "patch": "@@ -12,7 +12,7 @@ mod tests;\n use crate::matching::Match;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{AstNode, SmolStr, SyntaxNode};\n+use ra_syntax::{ast, AstNode, SmolStr, SyntaxNode};\n use ra_text_edit::TextEdit;\n use rustc_hash::FxHashMap;\n \n@@ -107,6 +107,22 @@ impl<'db> MatchFinder<'db> {\n                 return;\n             }\n         }\n+        // If we've got a macro call, we already tried matching it pre-expansion, which is the only\n+        // way to match the whole macro, now try expanding it and matching the expansion.\n+        if let Some(macro_call) = ast::MacroCall::cast(code.clone()) {\n+            if let Some(expanded) = self.sema.expand(&macro_call) {\n+                if let Some(tt) = macro_call.token_tree() {\n+                    // When matching within a macro expansion, we only want to allow matches of\n+                    // nodes that originated entirely from within the token tree of the macro call.\n+                    // i.e. we don't want to match something that came from the macro itself.\n+                    self.find_matches(\n+                        &expanded,\n+                        &Some(self.sema.original_range(tt.syntax())),\n+                        matches_out,\n+                    );\n+                }\n+            }\n+        }\n         for child in code.children() {\n             self.find_matches(&child, restrict_range, matches_out);\n         }"}, {"sha": "85420ed3ca5d806034389245af33af734b0aab87", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f9eaceb17f5686f6377250cbe510b348af318/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f9eaceb17f5686f6377250cbe510b348af318/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=dd3f9eaceb17f5686f6377250cbe510b348af318", "patch": "@@ -343,7 +343,9 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n \n     /// Outside of token trees, a placeholder can only match a single AST node, whereas in a token\n-    /// tree it can match a sequence of tokens.\n+    /// tree it can match a sequence of tokens. Note, that this code will only be used when the\n+    /// pattern matches the macro invocation. For matches within the macro call, we'll already have\n+    /// expanded the macro.\n     fn attempt_match_token_tree(\n         &mut self,\n         match_inputs: &MatchInputs,"}, {"sha": "7a3141be8b901085401c684ddf8b9f92d6027d03", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f9eaceb17f5686f6377250cbe510b348af318/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f9eaceb17f5686f6377250cbe510b348af318/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=dd3f9eaceb17f5686f6377250cbe510b348af318", "patch": "@@ -209,6 +209,11 @@ fn assert_ssr_transform(rule: &str, input: &str, result: &str) {\n     assert_ssr_transforms(&[rule], input, result);\n }\n \n+fn normalize_code(code: &str) -> String {\n+    let (db, file_id) = single_file(code);\n+    db.file_text(file_id).to_string()\n+}\n+\n fn assert_ssr_transforms(rules: &[&str], input: &str, result: &str) {\n     let (db, file_id) = single_file(input);\n     let mut match_finder = MatchFinder::new(&db);\n@@ -217,8 +222,13 @@ fn assert_ssr_transforms(rules: &[&str], input: &str, result: &str) {\n         match_finder.add_rule(rule);\n     }\n     if let Some(edits) = match_finder.edits_for_file(file_id) {\n-        let mut after = input.to_string();\n+        // Note, db.file_text is not necessarily the same as `input`, since fixture parsing alters\n+        // stuff.\n+        let mut after = db.file_text(file_id).to_string();\n         edits.apply(&mut after);\n+        // Likewise, we need to make sure that whatever transformations fixture parsing applies,\n+        // also get appplied to our expected result.\n+        let result = normalize_code(result);\n         assert_eq!(after, result);\n     } else {\n         panic!(\"No edits were made\");\n@@ -355,6 +365,18 @@ fn match_nested_method_calls() {\n     );\n }\n \n+// Make sure that our node matching semantics don't differ within macro calls.\n+#[test]\n+fn match_nested_method_calls_with_macro_call() {\n+    assert_matches(\n+        \"$a.z().z().z()\",\n+        r#\"\n+            macro_rules! m1 { ($a:expr) => {$a}; }\n+            fn f() {m1!(h().i().j().z().z().z().d().e())}\"#,\n+        &[\"h().i().j().z().z().z()\"],\n+    );\n+}\n+\n #[test]\n fn match_complex_expr() {\n     let code = \"fn f() -> i32 {foo(bar(40, 2), 42)}\";\n@@ -547,3 +569,40 @@ fn multiple_rules() {\n         \"fn f() -> i32 {add_one(add(3, 2))}\",\n     )\n }\n+\n+#[test]\n+fn match_within_macro_invocation() {\n+    let code = r#\"\n+            macro_rules! foo {\n+                ($a:stmt; $b:expr) => {\n+                    $b\n+                };\n+            }\n+            struct A {}\n+            impl A {\n+                fn bar() {}\n+            }\n+            fn f1() {\n+                let aaa = A {};\n+                foo!(macro_ignores_this(); aaa.bar());\n+            }\n+        \"#;\n+    assert_matches(\"$a.bar()\", code, &[\"aaa.bar()\"]);\n+}\n+\n+#[test]\n+fn replace_within_macro_expansion() {\n+    assert_ssr_transform(\n+        \"$a.foo() ==>> bar($a)\",\n+        r#\"\n+            macro_rules! macro1 {\n+                ($a:expr) => {$a}\n+            }\n+            fn f() {macro1!(5.x().foo().o2())}\"#,\n+        r#\"\n+            macro_rules! macro1 {\n+                ($a:expr) => {$a}\n+            }\n+            fn f() {macro1!(bar(5.x()).o2())}\"#,\n+    )\n+}"}]}