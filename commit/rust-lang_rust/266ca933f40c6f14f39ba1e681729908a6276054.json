{"sha": "266ca933f40c6f14f39ba1e681729908a6276054", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NmNhOTMzZjQwYzZmMTRmMzliYTFlNjgxNzI5OTA4YTYyNzYwNTQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-20T09:10:27Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-20T09:10:27Z"}, "message": "Rustup to rustc 1.46.0-nightly (2d8bd9b74 2020-06-19)", "tree": {"sha": "e3ba097273ca99468d8817f9f6c4c017c1b83e48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ba097273ca99468d8817f9f6c4c017c1b83e48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266ca933f40c6f14f39ba1e681729908a6276054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266ca933f40c6f14f39ba1e681729908a6276054", "html_url": "https://github.com/rust-lang/rust/commit/266ca933f40c6f14f39ba1e681729908a6276054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266ca933f40c6f14f39ba1e681729908a6276054/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3086e44733499da24272640f73b7a0822e4b548a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3086e44733499da24272640f73b7a0822e4b548a", "html_url": "https://github.com/rust-lang/rust/commit/3086e44733499da24272640f73b7a0822e4b548a"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "a7e2f7c2d283a1c04638eb9b94a784fa5b883734", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/266ca933f40c6f14f39ba1e681729908a6276054/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/266ca933f40c6f14f39ba1e681729908a6276054/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=266ca933f40c6f14f39ba1e681729908a6276054", "patch": "@@ -1 +1 @@\n-nightly-2020-06-16\n+nightly-2020-06-20"}, {"sha": "ab7ae75a3658fa3f45d33a0477c17a511540e8d6", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/266ca933f40c6f14f39ba1e681729908a6276054/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ca933f40c6f14f39ba1e681729908a6276054/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=266ca933f40c6f14f39ba1e681729908a6276054", "patch": "@@ -340,11 +340,11 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                 bug!(\"shouldn't exist at trans {:?}\", bb_data.terminator());\n             }\n             TerminatorKind::Drop {\n-                location,\n+                place,\n                 target,\n                 unwind: _,\n             } => {\n-                let drop_place = trans_place(fx, *location);\n+                let drop_place = trans_place(fx, *place);\n                 crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n \n                 let target_block = fx.get_block(*target);"}, {"sha": "d15d74225716e7f7d1460bb891e74fa2c4d536b9", "filename": "src/discriminant.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/266ca933f40c6f14f39ba1e681729908a6276054/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ca933f40c6f14f39ba1e681729908a6276054/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=266ca933f40c6f14f39ba1e681729908a6276054", "patch": "@@ -1,6 +1,6 @@\n //! Adapted from https://github.com/rust-lang/rust/blob/d760df5aea483aae041c9a241e7acacf48f75035/src/librustc_codegen_ssa/mir/place.rs\n \n-use rustc_target::abi::{DiscriminantKind, Int, Variants};\n+use rustc_target::abi::{TagEncoding, Int, Variants};\n \n use crate::prelude::*;\n \n@@ -18,12 +18,12 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             assert_eq!(index, variant_index);\n         }\n         Variants::Multiple {\n-            discr: _,\n-            discr_index,\n-            discr_kind: DiscriminantKind::Tag,\n+            tag: _,\n+            tag_field,\n+            tag_encoding: TagEncoding::Direct,\n             variants: _,\n         } => {\n-            let ptr = place.place_field(fx, mir::Field::new(discr_index));\n+            let ptr = place.place_field(fx, mir::Field::new(tag_field));\n             let to = layout\n                 .ty\n                 .discriminant_for_variant(fx.tcx, variant_index)\n@@ -33,18 +33,18 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             ptr.write_cvalue(fx, discr);\n         }\n         Variants::Multiple {\n-            discr: _,\n-            discr_index,\n-            discr_kind:\n-                DiscriminantKind::Niche {\n+            tag: _,\n+            tag_field,\n+            tag_encoding:\n+                TagEncoding::Niche {\n                     dataful_variant,\n                     ref niche_variants,\n                     niche_start,\n                 },\n             variants: _,\n         } => {\n             if variant_index != dataful_variant {\n-                let niche = place.place_field(fx, mir::Field::new(discr_index));\n+                let niche = place.place_field(fx, mir::Field::new(tag_field));\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                 let niche_value = u128::from(niche_value).wrapping_add(niche_start);\n                 let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n@@ -69,7 +69,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         );\n     }\n \n-    let (discr_scalar, discr_index, discr_kind) = match &layout.variants {\n+    let (tag_scalar, tag_field, tag_encoding) = match &layout.variants {\n         Variants::Single { index } => {\n             let discr_val = layout\n                 .ty\n@@ -78,30 +78,30 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             return CValue::const_val(fx, dest_layout, discr_val);\n         }\n         Variants::Multiple {\n-            discr,\n-            discr_index,\n-            discr_kind,\n+            tag,\n+            tag_field,\n+            tag_encoding,\n             variants: _,\n-        } => (discr, *discr_index, discr_kind),\n+        } => (tag, *tag_field, tag_encoding),\n     };\n \n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n-    let encoded_discr = value.value_field(fx, mir::Field::new(discr_index));\n-    let encoded_discr = encoded_discr.load_scalar(fx);\n+    let tag = value.value_field(fx, mir::Field::new(tag_field));\n+    let tag = tag.load_scalar(fx);\n \n     // Decode the discriminant (specifically if it's niche-encoded).\n-    match *discr_kind {\n-        DiscriminantKind::Tag => {\n-            let signed = match discr_scalar.value {\n+    match *tag_encoding {\n+        TagEncoding::Direct => {\n+            let signed = match tag_scalar.value {\n                 Int(_, signed) => signed,\n                 _ => false,\n             };\n-            let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n-            return CValue::by_val(val, dest_layout);\n+            let val = clif_intcast(fx, tag, cast_to, signed);\n+            CValue::by_val(val, dest_layout)\n         }\n-        DiscriminantKind::Niche {\n+        TagEncoding::Niche {\n             dataful_variant,\n             ref niche_variants,\n             niche_start,\n@@ -119,12 +119,12 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             // that might not fit in the same type, on top of needing an extra\n             // comparison (see also the comment on `let niche_discr`).\n             let relative_discr = if niche_start == 0 {\n-                encoded_discr\n+                tag\n             } else {\n                 // FIXME handle niche_start > i64::MAX\n                 fx.bcx\n                     .ins()\n-                    .iadd_imm(encoded_discr, -i64::try_from(niche_start).unwrap())\n+                    .iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n             };\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n             let is_niche = {"}]}