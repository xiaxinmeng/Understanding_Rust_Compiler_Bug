{"sha": "e1d09766add86bcc32ebe02151273ccc4f699d10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZDA5NzY2YWRkODZiY2MzMmViZTAyMTUxMjczY2NjNGY2OTlkMTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:04:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:27:35Z"}, "message": "rollup merge of #20059: nick29581/self-impl\n\nr? @sfackler\n\ncloses #20000", "tree": {"sha": "9db69f914b689d7c3f176f5421a6102563f85dfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9db69f914b689d7c3f176f5421a6102563f85dfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1d09766add86bcc32ebe02151273ccc4f699d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d09766add86bcc32ebe02151273ccc4f699d10", "html_url": "https://github.com/rust-lang/rust/commit/e1d09766add86bcc32ebe02151273ccc4f699d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1d09766add86bcc32ebe02151273ccc4f699d10/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc1d818b836644b67e2027cc358aa8d86f85e287", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1d818b836644b67e2027cc358aa8d86f85e287", "html_url": "https://github.com/rust-lang/rust/commit/bc1d818b836644b67e2027cc358aa8d86f85e287"}, {"sha": "31f5ab3f0c59f65e6758fe5ffadb617a98dcd5b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/31f5ab3f0c59f65e6758fe5ffadb617a98dcd5b4", "html_url": "https://github.com/rust-lang/rust/commit/31f5ab3f0c59f65e6758fe5ffadb617a98dcd5b4"}], "stats": {"total": 95, "additions": 90, "deletions": 5}, "files": [{"sha": "aefbb2a1feab365e0d0629a76fb24feecf7731fe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d09766add86bcc32ebe02151273ccc4f699d10/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d09766add86bcc32ebe02151273ccc4f699d10/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e1d09766add86bcc32ebe02151273ccc4f699d10", "patch": "@@ -490,7 +490,7 @@ impl<'a> ExtCtxt<'a> {\n \n     /// Returns a `Folder` for deeply expanding all macros in a AST node.\n     pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n-        expand::MacroExpander { cx: self }\n+        expand::MacroExpander::new(self)\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])"}, {"sha": "b10ae7a09db17a7c518eeb557e2a6e37a8c412c7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e1d09766add86bcc32ebe02151273ccc4f699d10/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d09766add86bcc32ebe02151273ccc4f699d10/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e1d09766add86bcc32ebe02151273ccc4f699d10", "patch": "@@ -15,6 +15,7 @@ use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n use ast::{StmtExpr, StmtSemi};\n use ast::TokenTree;\n use ast;\n+use ast_util::path_to_ident;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n@@ -37,6 +38,30 @@ enum Either<L,R> {\n     Right(R)\n }\n \n+pub fn expand_type(t: P<ast::Ty>,\n+                   fld: &mut MacroExpander,\n+                   impl_ty: Option<P<ast::Ty>>)\n+                   -> P<ast::Ty> {\n+    debug!(\"expanding type {} with impl_ty {}\", t, impl_ty);\n+    let t = match (t.node.clone(), impl_ty) {\n+        // Expand uses of `Self` in impls to the concrete type.\n+        (ast::Ty_::TyPath(ref path, _), Some(ref impl_ty)) => {\n+            let path_as_ident = path_to_ident(path);\n+            // Note unhygenic comparison here. I think this is correct, since\n+            // even though `Self` is almost just a type parameter, the treatment\n+            // for this expansion is as if it were a keyword.\n+            if path_as_ident.is_some() &&\n+               path_as_ident.unwrap().name == token::special_idents::type_self.name {\n+                impl_ty.clone()\n+            } else {\n+                t\n+            }\n+        }\n+        _ => t\n+    };\n+    fold::noop_fold_ty(t, fld)\n+}\n+\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -1065,6 +1090,14 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n+    // The type of the impl currently being expanded.\n+    current_impl_type: Option<P<ast::Ty>>,\n+}\n+\n+impl<'a, 'b> MacroExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>) -> MacroExpander<'a, 'b> {\n+        MacroExpander { cx: cx, current_impl_type: None }\n+    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -1077,7 +1110,14 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        expand_item(item, self)\n+        let prev_type = self.current_impl_type.clone();\n+        if let ast::Item_::ItemImpl(_, _, _, ref ty, _) = item.node {\n+            self.current_impl_type = Some(ty.clone());\n+        }\n+\n+        let result = expand_item(item, self);\n+        self.current_impl_type = prev_type;\n+        result\n     }\n \n     fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n@@ -1100,6 +1140,11 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_method(method, self)\n     }\n \n+    fn fold_ty(&mut self, t: P<ast::Ty>) -> P<ast::Ty> {\n+        let impl_type = self.current_impl_type.clone();\n+        expand_type(t, self, impl_type)\n+    }\n+\n     fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n@@ -1144,9 +1189,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n-    let mut expander = MacroExpander {\n-        cx: &mut cx,\n-    };\n+    let mut expander = MacroExpander::new(&mut cx);\n \n     for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n         let name = format!(\"<{} macros>\", token::get_ident(crate_name))"}, {"sha": "3ece042aef0539089096f4209fc202a9fbfb1399", "filename": "src/test/run-pass/self-impl.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e1d09766add86bcc32ebe02151273ccc4f699d10/src%2Ftest%2Frun-pass%2Fself-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d09766add86bcc32ebe02151273ccc4f699d10/src%2Ftest%2Frun-pass%2Fself-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-impl.rs?ref=e1d09766add86bcc32ebe02151273ccc4f699d10", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can use `Self` types in impls in the expected way.\n+\n+struct Foo;\n+\n+// Test uses on inherant impl.\n+impl Foo {\n+    fn foo(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n+        Foo\n+    }\n+}\n+\n+// Test uses when implementing a trait and with a type parameter.\n+pub struct Baz<X> {\n+    pub f: X,\n+}\n+\n+trait Bar<X> {\n+    fn bar(x: Self, y: &Self, z: Box<Self>) -> Self;\n+}\n+\n+impl Bar<int> for Box<Baz<int>> {\n+    fn bar(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n+        box Baz { f: 42 }\n+    }\n+}\n+\n+fn main() {\n+    let _: Foo = Foo::foo(Foo, &Foo, box Foo);\n+    let _: Box<Baz<int>> = Bar::bar(box Baz { f: 42 },\n+                                    &box Baz { f: 42 },\n+                                    box box Baz { f: 42 });\n+}"}]}