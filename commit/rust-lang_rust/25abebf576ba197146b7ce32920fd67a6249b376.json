{"sha": "25abebf576ba197146b7ce32920fd67a6249b376", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YWJlYmY1NzZiYTE5NzE0NmI3Y2UzMjkyMGZkNjdhNjI0OWIzNzY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-10-10T01:58:33Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-10-10T01:58:33Z"}, "message": "Merge pull request #432 from nrc/long-tuple\n\nHandle multi-line return types and multi-line tuples", "tree": {"sha": "b83fe099a3d95c8dbf931f0e481532aadb625392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b83fe099a3d95c8dbf931f0e481532aadb625392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25abebf576ba197146b7ce32920fd67a6249b376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25abebf576ba197146b7ce32920fd67a6249b376", "html_url": "https://github.com/rust-lang/rust/commit/25abebf576ba197146b7ce32920fd67a6249b376", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25abebf576ba197146b7ce32920fd67a6249b376/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ea76983ce8bfc320c48ed55ce6cf53e212025e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ea76983ce8bfc320c48ed55ce6cf53e212025e", "html_url": "https://github.com/rust-lang/rust/commit/e9ea76983ce8bfc320c48ed55ce6cf53e212025e"}, {"sha": "aed558fce435924e6839f46c4cc0f021fe33f097", "url": "https://api.github.com/repos/rust-lang/rust/commits/aed558fce435924e6839f46c4cc0f021fe33f097", "html_url": "https://github.com/rust-lang/rust/commit/aed558fce435924e6839f46c4cc0f021fe33f097"}], "stats": {"total": 160, "additions": 114, "deletions": 46}, "files": [{"sha": "caf17257578bd4e532124f6499c637a23820b835", "filename": "src/items.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/25abebf576ba197146b7ce32920fd67a6249b376/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25abebf576ba197146b7ce32920fd67a6249b376/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=25abebf576ba197146b7ce32920fd67a6249b376", "patch": "@@ -149,7 +149,7 @@ impl<'a> FmtVisitor<'a> {\n                                                    false);\n \n                 match rewrite {\n-                    Some(new_fn) => {\n+                    Some((new_fn, _)) => {\n                         self.buffer.push_str(format_visibility(item.vis));\n                         self.buffer.push_str(&new_fn);\n                         self.buffer.push_str(\";\");\n@@ -202,21 +202,23 @@ impl<'a> FmtVisitor<'a> {\n                       -> Option<String> {\n         let mut newline_brace = self.newline_for_brace(&generics.where_clause);\n \n-        let mut result = try_opt!(self.rewrite_fn_base(indent,\n-                                                       ident,\n-                                                       fd,\n-                                                       explicit_self,\n-                                                       generics,\n-                                                       unsafety,\n-                                                       constness,\n-                                                       abi,\n-                                                       vis,\n-                                                       span,\n-                                                       newline_brace,\n-                                                       true));\n+        let (mut result, force_newline_brace) = try_opt!(self.rewrite_fn_base(indent,\n+                                                                              ident,\n+                                                                              fd,\n+                                                                              explicit_self,\n+                                                                              generics,\n+                                                                              unsafety,\n+                                                                              constness,\n+                                                                              abi,\n+                                                                              vis,\n+                                                                              span,\n+                                                                              newline_brace,\n+                                                                              true));\n \n         if self.config.fn_brace_style != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n             newline_brace = false;\n+        } else if force_newline_brace {\n+            newline_brace = true;\n         }\n \n         // Prepare for the function body by possibly adding a newline and\n@@ -243,6 +245,7 @@ impl<'a> FmtVisitor<'a> {\n         // Drop semicolon or it will be interpreted as comment\n         let span = codemap::mk_sp(span.lo, span.hi - BytePos(1));\n \n+        // FIXME: silly formatting of the `.0`.\n         let mut result = try_opt!(self.rewrite_fn_base(indent,\n                                                        ident,\n                                                        &sig.decl,\n@@ -254,14 +257,16 @@ impl<'a> FmtVisitor<'a> {\n                                                        ast::Visibility::Inherited,\n                                                        span,\n                                                        false,\n-                                                       false));\n+                                                       false))\n+                             .0;\n \n         // Re-attach semicolon\n         result.push(';');\n \n         Some(result)\n     }\n \n+    // Return type is (result, force_new_line_for_brace)\n     fn rewrite_fn_base(&mut self,\n                        indent: Indent,\n                        ident: ast::Ident,\n@@ -275,7 +280,8 @@ impl<'a> FmtVisitor<'a> {\n                        span: Span,\n                        newline_brace: bool,\n                        has_body: bool)\n-                       -> Option<String> {\n+                       -> Option<(String, bool)> {\n+        let mut force_new_line_for_brace = false;\n         // FIXME we'll lose any comments in between parts of the function decl, but anyone\n         // who comments there probably deserves what they get.\n \n@@ -311,13 +317,22 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&generics_str);\n \n         let context = self.get_context();\n+        // Note that if the width and indent really matter, we'll re-layout the\n+        // return type later anyway.\n         let ret_str = fd.output\n                         .rewrite(&context, self.config.max_width - indent.width(), indent)\n                         .unwrap();\n \n+        let multi_line_ret_str = ret_str.contains('\\n');\n+        let ret_str_len = if multi_line_ret_str {\n+            0\n+        } else {\n+            ret_str.len()\n+        };\n+\n         // Args.\n-        let (one_line_budget, multi_line_budget, mut arg_indent) =\n-            self.compute_budgets_for_args(&result, indent, ret_str.len(), newline_brace);\n+        let (mut one_line_budget, multi_line_budget, mut arg_indent) =\n+            self.compute_budgets_for_args(&result, indent, ret_str_len, newline_brace);\n \n         debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n                one_line_budget,\n@@ -343,6 +358,10 @@ impl<'a> FmtVisitor<'a> {\n             result.push('(');\n         }\n \n+        if multi_line_ret_str {\n+            one_line_budget = 0;\n+        }\n+\n         // A conservative estimation, to goal is to be over all parens in generics\n         let args_start = generics.ty_params\n                                  .last()\n@@ -371,23 +390,43 @@ impl<'a> FmtVisitor<'a> {\n             // over the max width, then put the return type on a new line.\n             // Unless we are formatting args like a block, in which case there\n             // should always be room for the return type.\n-            if (result.contains(\"\\n\") ||\n-                result.len() + indent.width() + ret_str.len() > self.config.max_width) &&\n-               self.config.fn_args_layout != StructLitStyle::Block {\n+            let ret_indent = if (result.contains(\"\\n\") || multi_line_ret_str ||\n+                                 result.len() + indent.width() + ret_str_len >\n+                                 self.config.max_width) &&\n+                                self.config.fn_args_layout != StructLitStyle::Block {\n                 let indent = match self.config.fn_return_indent {\n                     ReturnIndent::WithWhereClause => indent + 4,\n-                    // TODO: we might want to check that using the arg indent\n+                    // Aligning with non-existent args looks silly.\n+                    _ if arg_str.len() == 0 => {\n+                        force_new_line_for_brace = true;\n+                        indent + 4\n+                    }\n+                    // FIXME: we might want to check that using the arg indent\n                     // doesn't blow our budget, and if it does, then fallback to\n                     // the where clause indent.\n                     _ => arg_indent,\n                 };\n \n                 result.push('\\n');\n                 result.push_str(&indent.to_string(self.config));\n+                indent\n             } else {\n                 result.push(' ');\n+                Indent::new(indent.width(), result.len())\n+            };\n+\n+            if multi_line_ret_str {\n+                // Now that we know the proper indent and width, we need to\n+                // re-layout the return type.\n+\n+                let budget = try_opt!(self.config.max_width.checked_sub(ret_indent.width()));\n+                let ret_str = fd.output\n+                                .rewrite(&context, budget, ret_indent)\n+                                .unwrap();\n+                result.push_str(&ret_str);\n+            } else {\n+                result.push_str(&ret_str);\n             }\n-            result.push_str(&ret_str);\n \n             // Comment between return type and the end of the decl.\n             let snippet_lo = fd.output.span().hi;\n@@ -426,7 +465,7 @@ impl<'a> FmtVisitor<'a> {\n                                                                   span.hi));\n         result.push_str(&where_clause_str);\n \n-        Some(result)\n+        Some((result, force_new_line_for_brace))\n     }\n \n     fn rewrite_args(&self,\n@@ -463,7 +502,7 @@ impl<'a> FmtVisitor<'a> {\n             arg_items.push(ListItem::from_str(\"\"));\n         }\n \n-        // TODO(#21): if there are no args, there might still be a comment, but\n+        // FIXME(#21): if there are no args, there might still be a comment, but\n         // without spans for the comment or parens, there is no chance of\n         // getting it right. You also don't get to put a comment on self, unless\n         // it is explicit.\n@@ -559,7 +598,7 @@ impl<'a> FmtVisitor<'a> {\n             (0, max_space - used_space, new_indent)\n         } else {\n             // Whoops! bankrupt.\n-            // TODO: take evasive action, perhaps kill the indent or something.\n+            // FIXME: take evasive action, perhaps kill the indent or something.\n             panic!(\"in compute_budgets_for_args\");\n         }\n     }\n@@ -731,7 +770,7 @@ impl<'a> FmtVisitor<'a> {\n                 Some(result)\n             }\n             ast::VariantKind::StructVariantKind(ref struct_def) => {\n-                // TODO: Should limit the width, as we have a trailing comma\n+                // FIXME: Should limit the width, as we have a trailing comma\n                 self.format_struct(\"\",\n                                    field.node.name,\n                                    ast::Visibility::Inherited,\n@@ -968,7 +1007,7 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         let h_budget = self.config.max_width - generics_offset.width() - 2;\n-        // TODO: might need to insert a newline if the generics are really long.\n+        // FIXME: might need to insert a newline if the generics are really long.\n \n         // Strings for the generics.\n         let context = self.get_context();"}, {"sha": "c9cc24f18e1acd96b269acea1426bfe6b1f8e8fd", "filename": "src/lists.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25abebf576ba197146b7ce32920fd67a6249b376/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25abebf576ba197146b7ce32920fd67a6249b376/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=25abebf576ba197146b7ce32920fd67a6249b376", "patch": "@@ -78,12 +78,12 @@ pub fn format_item_list<I>(items: I,\n     list_helper(items, width, offset, config, ListTactic::HorizontalVertical)\n }\n \n-fn list_helper<I>(items: I,\n-                  width: usize,\n-                  offset: Indent,\n-                  config: &Config,\n-                  tactic: ListTactic)\n-                  -> Option<String>\n+pub fn list_helper<I>(items: I,\n+                      width: usize,\n+                      offset: Indent,\n+                      config: &Config,\n+                      tactic: ListTactic)\n+                      -> Option<String>\n     where I: Iterator<Item = ListItem>\n {\n     let item_vec: Vec<_> = items.collect();"}, {"sha": "a706f7ec4640250e3c73f38e27f509ea6a88be3e", "filename": "src/types.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25abebf576ba197146b7ce32920fd67a6249b376/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25abebf576ba197146b7ce32920fd67a6249b376/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=25abebf576ba197146b7ce32920fd67a6249b376", "patch": "@@ -13,7 +13,7 @@ use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n use Indent;\n-use lists::{format_item_list, itemize_list, format_fn_args};\n+use lists::{format_item_list, itemize_list, format_fn_args, list_helper, ListTactic};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after, format_mutability, wrap_str};\n \n@@ -475,19 +475,27 @@ impl Rewrite for ast::Ty {\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"({})\", ty_str))\n             }\n             ast::TyTup(ref tup_ret) => {\n-                let inner = if let [ref item] = &**tup_ret {\n-                    try_opt!(item.rewrite(context, width, offset)) + \",\"\n+                let budget = try_opt!(width.checked_sub(2));\n+                if tup_ret.is_empty() {\n+                    Some(\"()\".to_string())\n+                } else if let [ref item] = &**tup_ret {\n+                    let inner = try_opt!(item.rewrite(context, budget, offset + 1));\n+                    let ret = format!(\"({},)\", inner);\n+                    wrap_str(ret, context.config.max_width, budget, offset + 1)\n                 } else {\n-                    let rewrites: Option<Vec<_>>;\n-                    rewrites = tup_ret.iter()\n-                                      .map(|item| item.rewrite(context, width, offset))\n-                                      .collect();\n-\n-                    try_opt!(rewrites).join(\", \")\n-                };\n-\n-                let ret = format!(\"({})\", inner);\n-                wrap_str(ret, context.config.max_width, width, offset)\n+                    let items = itemize_list(context.codemap,\n+                                             tup_ret.iter(),\n+                                             \")\",\n+                                             |item| item.span.lo,\n+                                             |item| item.span.hi,\n+                                             |item| item.rewrite(context, budget, offset + 1),\n+                                             tup_ret[0].span.lo,\n+                                             self.span.hi);\n+\n+\n+                    list_helper(items, budget, offset + 1, context.config, ListTactic::Mixed)\n+                        .map(|s| format!(\"({})\", s))\n+                }\n             }\n             _ => wrap_str(pprust::ty_to_string(self),\n                           context.config.max_width,"}, {"sha": "4f47aff0544591c8e8732100b436b838617af2ab", "filename": "tests/source/multiple.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25abebf576ba197146b7ce32920fd67a6249b376/tests%2Fsource%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25abebf576ba197146b7ce32920fd67a6249b376/tests%2Fsource%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmultiple.rs?ref=25abebf576ba197146b7ce32920fd67a6249b376", "patch": "@@ -112,3 +112,13 @@ fn main() {\n            let s = expand(a\n     ,    \n     b); }\n+\n+fn deconstruct() -> (SocketAddr, Method, Headers,\n+                     RequestUri, HttpVersion,\n+                     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) {\n+}\n+\n+fn deconstruct(foo: Bar) -> (SocketAddr, Method, Headers,\n+                     RequestUri, HttpVersion,\n+                     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) {\n+}"}, {"sha": "d7f7a79f580b2790b88c2f80684062fd287863db", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25abebf576ba197146b7ce32920fd67a6249b376/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25abebf576ba197146b7ce32920fd67a6249b376/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=25abebf576ba197146b7ce32920fd67a6249b376", "patch": "@@ -141,3 +141,14 @@ fn main() {\n              abcd abcd\";\n     let s = expand(a, b);\n }\n+\n+fn deconstruct()\n+    -> (SocketAddr, Method, Headers, RequestUri, HttpVersion,\n+        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n+{\n+}\n+\n+fn deconstruct(foo: Bar)\n+               -> (SocketAddr, Method, Headers, RequestUri, HttpVersion,\n+                   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) {\n+}"}]}