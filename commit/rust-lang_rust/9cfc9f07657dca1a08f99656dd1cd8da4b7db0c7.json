{"sha": "9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZmM5ZjA3NjU3ZGNhMWEwOGY5OTY1NmRkMWNkOGRhNGI3ZGIwYzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-24T15:36:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "get rid of FinishStatic hack from stack clenaup; const_eval can do that itself", "tree": {"sha": "9ea45f33e3f5d060ea2a7361a2767326444cd63b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ea45f33e3f5d060ea2a7361a2767326444cd63b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "html_url": "https://github.com/rust-lang/rust/commit/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef96a60a4d6ad948f8ada532d2c0b039189a47e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef96a60a4d6ad948f8ada532d2c0b039189a47e0", "html_url": "https://github.com/rust-lang/rust/commit/ef96a60a4d6ad948f8ada532d2c0b039189a47e0"}], "stats": {"total": 70, "additions": 28, "deletions": 42}, "files": [{"sha": "3f0ab3b8f7cf2dff305b603fdf7b9f2312e0398c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "patch": "@@ -157,14 +157,6 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n-    let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n-    let is_static = tcx.is_static(cid.instance.def_id());\n-    let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n-        Mutability::Mutable\n-    } else {\n-        Mutability::Immutable\n-    };\n-    let cleanup = StackPopCleanup::FinishStatic(mutability);\n \n     let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n@@ -175,12 +167,22 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n         mir.span,\n         mir,\n         Place::Ptr(*ret),\n-        cleanup,\n+        StackPopCleanup::None { cleanup: false },\n     )?;\n \n     // The main interpreter loop.\n     ecx.run()?;\n \n+    // Intern the result\n+    let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n+    let is_static = tcx.is_static(cid.instance.def_id());\n+    let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n+        Mutability::Mutable\n+    } else {\n+        Mutability::Immutable\n+    };\n+    ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n+\n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret.into())\n }"}, {"sha": "dd908acec712584a02773bef24366bd0e4209267", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "patch": "@@ -32,7 +32,6 @@ use rustc::mir::interpret::{\n };\n \n use syntax::source_map::{self, Span};\n-use syntax::ast::Mutability;\n \n use super::{\n     Value, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n@@ -159,15 +158,14 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n \n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n-    /// The stackframe existed to compute the initial value of a static/constant.\n-    /// Call `M::intern_static` on the return value and all allocations it references\n-    /// when this is done.  Must have a valid pointer as return place.\n-    FinishStatic(Mutability),\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return).\n     Goto(Option<mir::BasicBlock>),\n-    /// Just do nohing: Used by Main and for the box_alloc hook in miri\n-    None,\n+    /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n+    /// `cleanup` says whether locals are deallocated.  Static computation\n+    /// wants them leaked to intern what they need (and just throw away\n+    /// the entire `ecx` when it is done).\n+    None { cleanup: bool },\n }\n \n // State of a local variable\n@@ -631,18 +629,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             \"tried to pop a stack frame, but there were none\",\n         );\n         match frame.return_to_block {\n-            StackPopCleanup::FinishStatic(mutability) => {\n-                let mplace = frame.return_place.to_mem_place();\n-                // to_ptr should be okay here; it is the responsibility of whoever pushed\n-                // this frame to make sure that this works.\n-                let ptr = mplace.ptr.to_ptr()?;\n-                assert_eq!(ptr.offset.bytes(), 0);\n-                self.memory.mark_static_initialized(ptr.alloc_id, mutability)?;\n-            }\n             StackPopCleanup::Goto(block) => {\n                 self.goto_block(block)?;\n             }\n-            StackPopCleanup::None => { }\n+            StackPopCleanup::None { cleanup } => {\n+                if !cleanup {\n+                    // Leak the locals\n+                    return Ok(());\n+                }\n+            }\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {"}, {"sha": "85c1ab4edcbd7123173f09dfe06952db9cbd9435", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "patch": "@@ -570,22 +570,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Reading and writing\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// mark an allocation pointed to by a static as static and initialized\n-    fn mark_inner_allocation_initialized(\n-        &mut self,\n-        alloc: AllocId,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        match self.alloc_map.contains_key(&alloc) {\n-            // already interned\n-            false => Ok(()),\n-            // this still needs work\n-            true => self.mark_static_initialized(alloc, mutability),\n-        }\n-    }\n-\n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initialized(\n+    pub fn intern_static(\n         &mut self,\n         alloc_id: AllocId,\n         mutability: Mutability,\n@@ -613,7 +599,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             // at references.  So whenever we follow a reference, we should likely\n             // assume immutability -- and we should make sure that the compiler\n             // does not permit code that would break this!\n-            self.mark_inner_allocation_initialized(alloc, mutability)?;\n+            if self.alloc_map.contains_key(&alloc) {\n+                // Not yet interned, so proceed recursively\n+                self.intern_static(alloc, mutability)?;\n+            }\n         }\n         Ok(())\n     }"}, {"sha": "6aea68907ecd10aa76194aa16659ac42aaea2820", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        self.memory.mark_static_initialized(\n+        self.memory.intern_static(\n             vtable.alloc_id,\n             Mutability::Immutable,\n         )?;"}]}