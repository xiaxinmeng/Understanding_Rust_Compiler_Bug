{"sha": "0f3c2933e05321f214616ae084d86f4081866f44", "node_id": "C_kwDOAAsO6NoAKDBmM2MyOTMzZTA1MzIxZjIxNDYxNmFlMDg0ZDg2ZjQwODE4NjZmNDQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-03-23T23:15:43Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-03-29T05:27:06Z"}, "message": "Add suggestion to borrow opaque Fn and FnMut instead of move", "tree": {"sha": "3d0d1b1b9460c0991ad8dbe4f2bcfd606efbf9c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d0d1b1b9460c0991ad8dbe4f2bcfd606efbf9c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f3c2933e05321f214616ae084d86f4081866f44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f3c2933e05321f214616ae084d86f4081866f44", "html_url": "https://github.com/rust-lang/rust/commit/0f3c2933e05321f214616ae084d86f4081866f44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f3c2933e05321f214616ae084d86f4081866f44/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad5b6f6b72091261ac421d1331b2350f628d1fcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad5b6f6b72091261ac421d1331b2350f628d1fcb", "html_url": "https://github.com/rust-lang/rust/commit/ad5b6f6b72091261ac421d1331b2350f628d1fcb"}], "stats": {"total": 177, "additions": 161, "deletions": 16}, "files": [{"sha": "8bf6ee57997265ccb24cc376043db8d951165831", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 90, "deletions": 13, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0f3c2933e05321f214616ae084d86f4081866f44/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3c2933e05321f214616ae084d86f4081866f44/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=0f3c2933e05321f214616ae084d86f4081866f44", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::mir::{\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n+use rustc_middle::ty::{self, subst::Subst, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span};\n@@ -276,22 +276,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            if needs_note {\n-                let opt_name =\n-                    self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n-                let note_msg = match opt_name {\n-                    Some(ref name) => format!(\"`{}`\", name),\n-                    None => \"value\".to_owned(),\n-                };\n+            let opt_name =\n+                self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n+            let note_msg = match opt_name {\n+                Some(ref name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+\n+            let tcx = self.infcx.tcx;\n+            let generics = tcx.generics_of(self.mir_def_id());\n \n-                // Try to find predicates on *generic params* that would allow copying `ty`\n-                let tcx = self.infcx.tcx;\n-                let generics = tcx.generics_of(self.mir_def_id());\n+            if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n+                // Suppress the next note, since we don't want to put more `Fn`-like bounds onto something that already has them\n+            } else if needs_note {\n                 if let Some(hir_generics) = tcx\n                     .typeck_root_def_id(self.mir_def_id().to_def_id())\n                     .as_local()\n                     .and_then(|def_id| tcx.hir().get_generics(def_id))\n                 {\n+                    // Try to find predicates on *generic params* that would allow copying `ty`\n                     let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n                         let mut fulfill_cx =\n                             <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n@@ -344,8 +347,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n \n                 let span = if let Some(local) = place.as_local() {\n-                    let decl = &self.body.local_decls[local];\n-                    Some(decl.source_info.span)\n+                    Some(self.body.local_decls[local].source_info.span)\n                 } else {\n                     None\n                 };\n@@ -373,6 +375,81 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_borrow_fn_like(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        ty: Ty<'tcx>,\n+        move_sites: &[MoveSite],\n+        value_name: &str,\n+    ) -> bool {\n+        let tcx = self.infcx.tcx;\n+\n+        // Find out if the predicates show that the type is a Fn or FnMut\n+        let find_fn_kind_from_did = |predicates: &[(ty::Predicate<'tcx>, Span)], substs| {\n+            predicates.iter().find_map(|(pred, _)| {\n+                let pred = if let Some(substs) = substs {\n+                    pred.subst(tcx, substs).kind().skip_binder()\n+                } else {\n+                    pred.kind().skip_binder()\n+                };\n+                if let ty::PredicateKind::Trait(pred) = pred && pred.self_ty() == ty {\n+                    if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n+                        return Some(hir::Mutability::Not);\n+                    } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n+                        return Some(hir::Mutability::Mut);\n+                    }\n+                }\n+                None\n+            })\n+        };\n+\n+        // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n+        // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n+        // These types seem reasonably opaque enough that they could be substituted with their\n+        // borrowed variants in a function body when we see a move error.\n+        let borrow_level = match ty.kind() {\n+            ty::Param(_) => find_fn_kind_from_did(\n+                tcx.explicit_predicates_of(self.mir_def_id().to_def_id()).predicates,\n+                None,\n+            ),\n+            ty::Opaque(did, substs) => {\n+                find_fn_kind_from_did(tcx.explicit_item_bounds(*did), Some(*substs))\n+            }\n+            ty::Closure(_, substs) => match substs.as_closure().kind() {\n+                ty::ClosureKind::Fn => Some(hir::Mutability::Not),\n+                ty::ClosureKind::FnMut => Some(hir::Mutability::Mut),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+\n+        let Some(borrow_level) = borrow_level else { return false; };\n+        let sugg = move_sites\n+            .iter()\n+            .map(|move_site| {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+                let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n+                let move_span = move_spans.args_or_use();\n+                let suggestion = if borrow_level == hir::Mutability::Mut {\n+                    \"&mut \".to_string()\n+                } else {\n+                    \"&\".to_string()\n+                };\n+                (move_span.shrink_to_lo(), suggestion)\n+            })\n+            .collect();\n+        err.multipart_suggestion_verbose(\n+            &format!(\n+                \"consider {}borrowing {value_name}\",\n+                if borrow_level == hir::Mutability::Mut { \"mutably \" } else { \"\" }\n+            ),\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+        true\n+    }\n+\n     pub(crate) fn report_move_out_while_borrowed(\n         &mut self,\n         location: Location,"}, {"sha": "adbbf4ee1a82fd2ab6f41d2b77c83d047b7c4973", "filename": "src/test/ui/moves/borrow-closures-instead-of-move.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0f3c2933e05321f214616ae084d86f4081866f44/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3c2933e05321f214616ae084d86f4081866f44/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.rs?ref=0f3c2933e05321f214616ae084d86f4081866f44", "patch": "@@ -0,0 +1,34 @@\n+fn takes_fn(f: impl Fn()) {\n+    loop {\n+        takes_fnonce(f);\n+        //~^ ERROR use of moved value\n+        //~| HELP consider borrowing\n+    }\n+}\n+\n+fn takes_fn_mut(m: impl FnMut()) {\n+    if maybe() {\n+        takes_fnonce(m);\n+        //~^ HELP consider mutably borrowing\n+    }\n+    takes_fnonce(m);\n+    //~^ ERROR use of moved value\n+}\n+\n+fn has_closure() {\n+    let mut x = 0;\n+    let closure = || {\n+        x += 1;\n+    };\n+    takes_fnonce(closure);\n+    closure();\n+}\n+\n+fn maybe() -> bool {\n+    false\n+}\n+\n+// Could also be Fn[Mut], here it doesn't matter\n+fn takes_fnonce(_: impl FnOnce()) {}\n+\n+fn main() {}"}, {"sha": "ff10d3c6006719a4b5369a5401e3ec3bc9998e1e", "filename": "src/test/ui/moves/borrow-closures-instead-of-move.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0f3c2933e05321f214616ae084d86f4081866f44/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f3c2933e05321f214616ae084d86f4081866f44/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr?ref=0f3c2933e05321f214616ae084d86f4081866f44", "patch": "@@ -0,0 +1,34 @@\n+error[E0382]: use of moved value: `f`\n+  --> $DIR/borrow-closures-instead-of-move.rs:3:22\n+   |\n+LL | fn takes_fn(f: impl Fn()) {\n+   |             - move occurs because `f` has type `impl Fn()`, which does not implement the `Copy` trait\n+LL |     loop {\n+LL |         takes_fnonce(f);\n+   |                      ^ value moved here, in previous iteration of loop\n+   |\n+help: consider borrowing `f`\n+   |\n+LL |         takes_fnonce(&f);\n+   |                      +\n+\n+error[E0382]: use of moved value: `m`\n+  --> $DIR/borrow-closures-instead-of-move.rs:14:18\n+   |\n+LL | fn takes_fn_mut(m: impl FnMut()) {\n+   |                 - move occurs because `m` has type `impl FnMut()`, which does not implement the `Copy` trait\n+LL |     if maybe() {\n+LL |         takes_fnonce(m);\n+   |                      - value moved here\n+...\n+LL |     takes_fnonce(m);\n+   |                  ^ value used here after move\n+   |\n+help: consider mutably borrowing `m`\n+   |\n+LL |         takes_fnonce(&mut m);\n+   |                      ++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "4759b45892cc40d3a614ab0b2c61532efba1073e", "filename": "src/test/ui/moves/moves-based-on-type-no-recursive-stack-closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f3c2933e05321f214616ae084d86f4081866f44/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f3c2933e05321f214616ae084d86f4081866f44/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr?ref=0f3c2933e05321f214616ae084d86f4081866f44", "patch": "@@ -17,10 +17,10 @@ LL |     let mut r = R {c: Box::new(f)};\n LL |     f(&mut r, false)\n    |     ^ value borrowed here after move\n    |\n-help: consider further restricting this bound\n+help: consider mutably borrowing `f`\n    |\n-LL | fn conspirator<F>(mut f: F) where F: FnMut(&mut R, bool) + Copy {\n-   |                                                          ++++++\n+LL |     let mut r = R {c: Box::new(&mut f)};\n+   |                                ++++\n \n error: aborting due to 2 previous errors\n "}]}