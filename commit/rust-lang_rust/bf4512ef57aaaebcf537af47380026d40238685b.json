{"sha": "bf4512ef57aaaebcf537af47380026d40238685b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNDUxMmVmNTdhYWFlYmNmNTM3YWY0NzM4MDAyNmQ0MDIzODY4NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-13T13:58:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-13T13:58:38Z"}, "message": "Auto merge of #7442 - camsteffen:format-args, r=xFrednet\n\nRefactor `format_args!` expansion parsing\n\nIntroduces `FormatExpn::parse` and `FormatArgsExpn::parse`. Motivated by rust-lang/rust#83302, so I only have to change Clippy in one place. Fixed an FP along the way.\n\nI also allowed `needless_bool` in macros because I often want to do `if_chain! { .. then { true } else { false } }`.\n\nchangelog: Fix false positive in `useless_format` when some text is appended or prepended to a single string with some useless formatting params\nchangelog: Allow `needless_bool` in macros", "tree": {"sha": "80cbc9e7e0e242d8253cd00a9428aab0d6cce902", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80cbc9e7e0e242d8253cd00a9428aab0d6cce902"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf4512ef57aaaebcf537af47380026d40238685b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4512ef57aaaebcf537af47380026d40238685b", "html_url": "https://github.com/rust-lang/rust/commit/bf4512ef57aaaebcf537af47380026d40238685b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf4512ef57aaaebcf537af47380026d40238685b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94d6be4c0a03d0149630bce7e6f373e327dd7471", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d6be4c0a03d0149630bce7e6f373e327dd7471", "html_url": "https://github.com/rust-lang/rust/commit/94d6be4c0a03d0149630bce7e6f373e327dd7471"}, {"sha": "306f9e843d5474eb2de6907b3ca6941dc918ea23", "url": "https://api.github.com/repos/rust-lang/rust/commits/306f9e843d5474eb2de6907b3ca6941dc918ea23", "html_url": "https://github.com/rust-lang/rust/commit/306f9e843d5474eb2de6907b3ca6941dc918ea23"}], "stats": {"total": 503, "additions": 238, "deletions": 265}, "files": [{"sha": "66724294804a8414d1dfbbda3ac5050051fc4349", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 36, "deletions": 81, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -1,9 +1,9 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::higher::FormatArgsExpn;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -34,29 +34,26 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, _, unwrap_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, _, [write_call], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if !unwrap_args.is_empty();\n-            if let ExprKind::MethodCall(write_fun, _, write_args, _) =\n-                unwrap_args[0].kind;\n+            if let ExprKind::MethodCall(write_fun, _, [write_recv, write_arg], _) = write_call.kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if !write_args.is_empty();\n-            if let Some(dest_name) = if match_function_call(cx, &write_args[0], &paths::STDOUT).is_some() {\n+            if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n-            } else if match_function_call(cx, &write_args[0], &paths::STDERR).is_some() {\n+            } else if match_function_call(cx, write_recv, &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None\n             };\n+            if let Some(format_args) = FormatArgsExpn::parse(write_arg);\n             then {\n-                let write_span = unwrap_args[0].span;\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n-                    if is_expn_of(write_span, \"writeln\").is_some() {\n+                    if is_expn_of(write_call.span, \"writeln\").is_some() {\n                         Some(\"writeln\")\n-                    } else if is_expn_of(write_span, \"write\").is_some() {\n+                    } else if is_expn_of(write_call.span, \"write\").is_some() {\n                         Some(\"write\")\n                     } else {\n                         None\n@@ -70,82 +67,40 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 // We need to remove the last trailing newline from the string because the\n                 // underlying `fmt::write` function doesn't know whether `println!` or `print!` was\n                 // used.\n-                if let Some(mut write_output) = write_output_string(write_args) {\n+                let (used, sugg_mac) = if let Some(macro_name) = calling_macro {\n+                    (\n+                        format!(\"{}!({}(), ...)\", macro_name, dest_name),\n+                        macro_name.replace(\"write\", \"print\"),\n+                    )\n+                } else {\n+                    (\n+                        format!(\"{}().write_fmt(...)\", dest_name),\n+                        \"print\".into(),\n+                    )\n+                };\n+                let msg = format!(\"use of `{}.unwrap()`\", used);\n+                if let [write_output] = *format_args.format_string_symbols {\n+                    let mut write_output = write_output.to_string();\n                     if write_output.ends_with('\\n') {\n                         write_output.pop();\n                     }\n \n-                    if let Some(macro_name) = calling_macro {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\n-                                \"use of `{}!({}(), ...).unwrap()`\",\n-                                macro_name,\n-                                dest_name\n-                            ),\n-                            \"try this\",\n-                            format!(\"{}{}!(\\\"{}\\\")\", prefix, macro_name.replace(\"write\", \"print\"), write_output.escape_default()),\n-                            Applicability::MachineApplicable\n-                        );\n-                    } else {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\"use of `{}().write_fmt(...).unwrap()`\", dest_name),\n-                            \"try this\",\n-                            format!(\"{}print!(\\\"{}\\\")\", prefix, write_output.escape_default()),\n-                            Applicability::MachineApplicable\n-                        );\n-                    }\n+                    let sugg = format!(\"{}{}!(\\\"{}\\\")\", prefix, sugg_mac, write_output.escape_default());\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXPLICIT_WRITE,\n+                        expr.span,\n+                        &msg,\n+                        \"try this\",\n+                        sugg,\n+                        Applicability::MachineApplicable\n+                    );\n                 } else {\n                     // We don't have a proper suggestion\n-                    if let Some(macro_name) = calling_macro {\n-                        span_lint(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\n-                                \"use of `{}!({}(), ...).unwrap()`. Consider using `{}{}!` instead\",\n-                                macro_name,\n-                                dest_name,\n-                                prefix,\n-                                macro_name.replace(\"write\", \"print\")\n-                            )\n-                        );\n-                    } else {\n-                        span_lint(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\"use of `{}().write_fmt(...).unwrap()`. Consider using `{}print!` instead\", dest_name, prefix),\n-                        );\n-                    }\n+                    let help = format!(\"consider using `{}{}!` instead\", prefix, sugg_mac);\n+                    span_lint_and_help(cx, EXPLICIT_WRITE, expr.span, &msg, None, &help);\n                 }\n-\n             }\n         }\n     }\n }\n-\n-// Extract the output string from the given `write_args`.\n-fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n-    if_chain! {\n-        // Obtain the string that should be printed\n-        if write_args.len() > 1;\n-        if let ExprKind::Call(_, output_args) = write_args[1].kind;\n-        if !output_args.is_empty();\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, output_string_expr) = output_args[0].kind;\n-        if let ExprKind::Array(string_exprs) = output_string_expr.kind;\n-        // we only want to provide an automatic suggestion for simple (non-format) strings\n-        if string_exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = string_exprs[0].kind;\n-        if let LitKind::Str(ref write_output, _) = lit.node;\n-        then {\n-            return Some(write_output.to_string())\n-        }\n-    }\n-    None\n-}"}, {"sha": "ca3490d8edad98c95df69f46abab20acf2335791", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 69, "deletions": 123, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -1,17 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::paths;\n-use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::FormatExpn;\n+use clippy_utils::last_path_segment;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_expn_of, last_path_segment, match_def_path, match_function_call};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, MatchSource, PatKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n+use rustc_span::symbol::kw;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `format!(\"string literal with no\n@@ -44,130 +43,78 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let span = match is_expn_of(expr.span, \"format\") {\n-            Some(s) if !s.from_expansion() => s,\n+        let FormatExpn { call_site, format_args } = match FormatExpn::parse(expr) {\n+            Some(e) if !e.call_site.from_expansion() => e,\n             _ => return,\n         };\n \n-        // Operate on the only argument of `alloc::fmt::format`.\n-        if let Some(sugg) = on_new_v1(cx, expr) {\n-            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n-        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n-            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n-        }\n-    }\n-}\n-\n-fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg: String) {\n-    let to_replace = span.source_callsite();\n-\n-    // The callsite span contains the statement semicolon for some reason.\n-    let snippet = snippet(cx, to_replace, \"..\");\n-    if snippet.ends_with(';') {\n-        sugg.push(';');\n-    }\n-\n-    span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |diag| {\n-        diag.span_suggestion(\n-            to_replace,\n-            help,\n-            sugg,\n-            Applicability::MachineApplicable, // snippet\n-        );\n-    });\n-}\n-\n-fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) -> Option<String> {\n-    if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, format_args) = expr.kind;\n-        if let ExprKind::Array(elems) = arms[0].body.kind;\n-        if elems.len() == 1;\n-        if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n-        // matches `core::fmt::Display::fmt`\n-        if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].kind;\n-        if let Some(did) = cx.qpath_res(qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n-        // check `(arg0,)` in match block\n-        if let PatKind::Tuple(pats, None) = arms[0].pat.kind;\n-        if pats.len() == 1;\n-        then {\n-            let ty = cx.typeck_results().pat_ty(pats[0]).peel_refs();\n-            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n-                return None;\n-            }\n-            if let ExprKind::Lit(ref lit) = format_args.kind {\n-                if let LitKind::Str(ref s, _) = lit.node {\n-                    return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+        let mut applicability = Applicability::MachineApplicable;\n+        if format_args.value_args.is_empty() {\n+            if_chain! {\n+                if let [e] = &*format_args.format_string_parts;\n+                if let ExprKind::Lit(lit) = &e.kind;\n+                if let Some(s_src) = snippet_opt(cx, lit.span);\n+                then {\n+                    // Simulate macro expansion, converting {{ and }} to { and }.\n+                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let sugg = format!(\"{}.to_string()\", s_expand);\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 }\n-            } else {\n-                let sugg = Sugg::hir(cx, format_args, \"<arg>\");\n-                if let ExprKind::MethodCall(path, _, _, _) = format_args.kind {\n-                    if path.ident.name == sym!(to_string) {\n-                        return Some(format!(\"{}\", sugg));\n-                    }\n-                } else if let ExprKind::Binary(..) = format_args.kind {\n-                    return Some(format!(\"{}\", sugg));\n+            }\n+        } else if let [value] = *format_args.value_args {\n+            if_chain! {\n+                if format_args.format_string_symbols == [kw::Empty];\n+                if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n+                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::string_type, adt.did),\n+                    ty::Str => true,\n+                    _ => false,\n+                };\n+                if format_args.args.iter().all(|e| is_display_arg(e));\n+                if format_args.fmt_expr.map_or(true, |e| check_unformatted(e));\n+                then {\n+                    let is_new_string = match value.kind {\n+                        ExprKind::Binary(..) => true,\n+                        ExprKind::MethodCall(path, ..) => path.ident.name.as_str() == \"to_string\",\n+                        _ => false,\n+                    };\n+                    let sugg = if is_new_string {\n+                        snippet_with_applicability(cx, value.span, \"..\", &mut applicability).into_owned()\n+                    } else {\n+                        let sugg = Sugg::hir_with_applicability(cx, value, \"<arg>\", &mut applicability);\n+                        format!(\"{}.to_string()\", sugg.maybe_par())\n+                    };\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 }\n-                return Some(format!(\"{}.to_string()\", sugg.maybe_par()));\n             }\n-        }\n+        };\n     }\n-    None\n }\n \n-fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n-    if_chain! {\n-        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n-        if args.len() == 2;\n-        // Argument 1 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n-        if let ExprKind::Array(pieces) = arr.kind;\n-        if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n-        if let LitKind::Str(ref s, _) = lit.node;\n-        // Argument 2 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n-        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n-        if arms.len() == 1;\n-        if let ExprKind::Tup(tup) = matchee.kind;\n-        then {\n-            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-            if tup.is_empty() {\n-                if let Some(s_src) = snippet_opt(cx, lit.span) {\n-                    // Simulate macro expansion, converting {{ and }} to { and }.\n-                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                    return Some(format!(\"{}.to_string()\", s_expand));\n-                }\n-            } else if s.as_str().is_empty() {\n-                return on_argumentv1_new(cx, &tup[0], arms);\n-            }\n-        }\n+fn span_useless_format(cx: &LateContext<'_>, span: Span, mut sugg: String, mut applicability: Applicability) {\n+    // The callsite span contains the statement semicolon for some reason.\n+    if snippet_with_applicability(cx, span, \"..\", &mut applicability).ends_with(';') {\n+        sugg.push(';');\n     }\n-    None\n+\n+    span_lint_and_sugg(\n+        cx,\n+        USELESS_FORMAT,\n+        span,\n+        \"useless use of `format!`\",\n+        \"consider using `.to_string()`\",\n+        sugg,\n+        applicability,\n+    );\n }\n \n-fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+fn is_display_arg(expr: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n-        if args.len() == 3;\n-        if check_unformatted(&args[2]);\n-        // Argument 1 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n-        if let ExprKind::Array(pieces) = arr.kind;\n-        if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n-        if let LitKind::Str(..) = lit.node;\n-        // Argument 2 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n-        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n-        if arms.len() == 1;\n-        if let ExprKind::Tup(tup) = matchee.kind;\n-        then {\n-            return on_argumentv1_new(cx, &tup[0], arms);\n-        }\n+        if let ExprKind::Call(_, [_, fmt]) = expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = fmt.kind;\n+        if let [.., t, _] = path.segments;\n+        if t.ident.name.as_str() == \"Display\";\n+        then { true } else { false }\n     }\n-    None\n }\n \n /// Checks if the expression matches\n@@ -184,10 +131,9 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n fn check_unformatted(expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-        if let ExprKind::Array(exprs) = expr.kind;\n-        if exprs.len() == 1;\n+        if let ExprKind::Array([expr]) = expr.kind;\n         // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, fields, _) = exprs[0].kind;\n+        if let ExprKind::Struct(_, fields, _) = expr.kind;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;"}, {"sha": "f8ee31a00df821ebc0e6f7834d666b3adb3a40d5", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 18, "deletions": 54, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_expn_of;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::higher::FormatExpn;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -94,27 +93,6 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         }\n     }\n \n-    fn generate_format_arg_snippet(\n-        cx: &LateContext<'_>,\n-        a: &hir::Expr<'_>,\n-        applicability: &mut Applicability,\n-    ) -> Vec<String> {\n-        if_chain! {\n-            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, format_arg) = a.kind;\n-            if let hir::ExprKind::Match(format_arg_expr, _, _) = format_arg.kind;\n-            if let hir::ExprKind::Tup(format_arg_expr_tup) = format_arg_expr.kind;\n-\n-            then {\n-                format_arg_expr_tup\n-                    .iter()\n-                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n-                    .collect()\n-            } else {\n-                unreachable!()\n-            }\n-        }\n-    }\n-\n     fn is_call(node: &hir::ExprKind<'_>) -> bool {\n         match node {\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n@@ -150,36 +128,22 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n     let mut applicability = Applicability::MachineApplicable;\n \n     //Special handling for `format!` as arg_root\n-    if_chain! {\n-        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n-        if block.stmts.len() == 1;\n-        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n-        if let Some(arg_root) = &local.init;\n-        if let hir::ExprKind::Call(inner_fun, inner_args) = arg_root.kind;\n-        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n-        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n-        then {\n-            let fmt_spec = &format_args[0];\n-            let fmt_args = &format_args[1];\n-\n-            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n-\n-            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n-\n-            let sugg = args.join(\", \");\n-\n-            span_lint_and_sugg(\n-                cx,\n-                EXPECT_FUN_CALL,\n-                span_replace_word,\n-                &format!(\"use of `{}` followed by a function call\", name),\n-                \"try this\",\n-                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n-                applicability,\n-            );\n-\n-            return;\n-        }\n+    if let Some(format_expn) = FormatExpn::parse(arg_root) {\n+        let span = match *format_expn.format_args.value_args {\n+            [] => format_expn.format_args.format_string_span,\n+            [.., last] => format_expn.format_args.format_string_span.to(last.span),\n+        };\n+        let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+        span_lint_and_sugg(\n+            cx,\n+            EXPECT_FUN_CALL,\n+            span_replace_word,\n+            &format!(\"use of `{}` followed by a function call\", name),\n+            \"try this\",\n+            format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+            applicability,\n+        );\n+        return;\n     }\n \n     let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);"}, {"sha": "780690548e52b7008d3ccd590a4592050e054161", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -71,6 +71,9 @@ declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n+        if e.span.from_expansion() {\n+            return;\n+        }\n         if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "5ffd88f41404814d336e51579117981f5029fe72", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -5,11 +5,11 @@\n \n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast;\n+use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n-use rustc_span::source_map::Span;\n+use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -266,3 +266,107 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n     }\n     None\n }\n+\n+/// A parsed `format!` expansion\n+pub struct FormatExpn<'tcx> {\n+    /// Span of `format!(..)`\n+    pub call_site: Span,\n+    /// Inner `format_args!` expansion\n+    pub format_args: FormatArgsExpn<'tcx>,\n+}\n+\n+impl FormatExpn<'tcx> {\n+    /// Parses an expanded `format!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExprKind::Block(block, _) = expr.kind;\n+            if let [stmt] = block.stmts;\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if let Some(init) = local.init;\n+            if let ExprKind::Call(_, [format_args]) = init.kind;\n+            let expn_data = expr.span.ctxt().outer_expn_data();\n+            if let ExpnKind::Macro { name: sym::format, .. } = expn_data.kind;\n+            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n+            then {\n+                Some(FormatExpn {\n+                    call_site: expn_data.call_site,\n+                    format_args,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+/// A parsed `format_args!` expansion\n+pub struct FormatArgsExpn<'tcx> {\n+    /// Span of the first argument, the format string\n+    pub format_string_span: Span,\n+    /// Values passed after the format string\n+    pub value_args: Vec<&'tcx Expr<'tcx>>,\n+\n+    /// String literal expressions which represent the format string split by \"{}\"\n+    pub format_string_parts: &'tcx [Expr<'tcx>],\n+    /// Symbols corresponding to [`format_string_parts`]\n+    pub format_string_symbols: Vec<Symbol>,\n+    /// Expressions like `ArgumentV1::new(arg0, Debug::fmt)`\n+    pub args: &'tcx [Expr<'tcx>],\n+    /// The final argument passed to `Arguments::new_v1_formatted`, if applicable\n+    pub fmt_expr: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl FormatArgsExpn<'tcx> {\n+    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExpnKind::Macro { name, .. } = expr.span.ctxt().outer_expn_data().kind;\n+            let name = name.as_str();\n+            if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n+            if let ExprKind::Call(_, args) = expr.kind;\n+            if let Some((strs_ref, args, fmt_expr)) = match args {\n+                // Arguments::new_v1\n+                [strs_ref, args] => Some((strs_ref, args, None)),\n+                // Arguments::new_v1_formatted\n+                [strs_ref, args, fmt_expr] => Some((strs_ref, args, Some(fmt_expr))),\n+                _ => None,\n+            };\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n+            if let ExprKind::Array(format_string_parts) = strs_arr.kind;\n+            if let Some(format_string_symbols) = format_string_parts\n+                .iter()\n+                .map(|e| {\n+                    if let ExprKind::Lit(lit) = &e.kind {\n+                        if let LitKind::Str(symbol, _style) = lit.node {\n+                            return Some(symbol);\n+                        }\n+                    }\n+                    None\n+                })\n+                .collect();\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n+            if let ExprKind::Match(args, [arm], _) = args.kind;\n+            if let ExprKind::Tup(value_args) = args.kind;\n+            if let Some(value_args) = value_args\n+                .iter()\n+                .map(|e| match e.kind {\n+                    ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                })\n+                .collect();\n+            if let ExprKind::Array(args) = arm.body.kind;\n+            then {\n+                Some(FormatArgsExpn {\n+                    format_string_span: strs_ref.span,\n+                    value_args,\n+                    format_string_parts,\n+                    format_string_symbols,\n+                    args,\n+                    fmt_expr,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "c960eec306414620449cd6d05e189080b8752867", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -38,7 +38,6 @@ pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"defa\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n-pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n@@ -50,9 +49,6 @@ pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n-pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n-pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];"}, {"sha": "b94ec6403ddcea3c63bfd188bbd6914679581c70", "filename": "tests/ui/explicit_write_non_rustfix.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/tests%2Fui%2Fexplicit_write_non_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/tests%2Fui%2Fexplicit_write_non_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_write_non_rustfix.stderr?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -1,10 +1,11 @@\n-error: use of `writeln!(stderr(), ...).unwrap()`. Consider using `eprintln!` instead\n+error: use of `writeln!(stderr(), ...).unwrap()`\n   --> $DIR/explicit_write_non_rustfix.rs:7:5\n    |\n LL |     writeln!(std::io::stderr(), \"foo {}\", bar).unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::explicit-write` implied by `-D warnings`\n+   = help: consider using `eprintln!` instead\n \n error: aborting due to previous error\n "}, {"sha": "5dd64140e81165880f3d6285c60825838d96a0e2", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -69,4 +69,6 @@ fn main() {\n     // Wrap it with braces\n     let v: Vec<String> = vec![\"foo\".to_string(), \"bar\".to_string()];\n     let _s: String = (&*v.join(\"\\n\")).to_string();\n+\n+    format!(\"prepend {:+}\", \"s\");\n }"}, {"sha": "4599fb5207ea85c280f07b863d39f798f6262eaa", "filename": "tests/ui/format.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf4512ef57aaaebcf537af47380026d40238685b/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4512ef57aaaebcf537af47380026d40238685b/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=bf4512ef57aaaebcf537af47380026d40238685b", "patch": "@@ -71,4 +71,6 @@ fn main() {\n     // Wrap it with braces\n     let v: Vec<String> = vec![\"foo\".to_string(), \"bar\".to_string()];\n     let _s: String = format!(\"{}\", &*v.join(\"\\n\"));\n+\n+    format!(\"prepend {:+}\", \"s\");\n }"}]}