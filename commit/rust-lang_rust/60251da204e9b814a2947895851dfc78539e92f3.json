{"sha": "60251da204e9b814a2947895851dfc78539e92f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMjUxZGEyMDRlOWI4MTRhMjk0Nzg5NTg1MWRmYzc4NTM5ZTkyZjM=", "commit": {"author": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-01-14T01:34:38Z"}, "committer": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-01-14T02:09:03Z"}, "message": "refactor(ra_syntax.validation): removed code duplication from validate_literal() function", "tree": {"sha": "b272469e709c0d401f202f097ae217b853e3a58c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b272469e709c0d401f202f097ae217b853e3a58c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60251da204e9b814a2947895851dfc78539e92f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60251da204e9b814a2947895851dfc78539e92f3", "html_url": "https://github.com/rust-lang/rust/commit/60251da204e9b814a2947895851dfc78539e92f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60251da204e9b814a2947895851dfc78539e92f3/comments", "author": null, "committer": null, "parents": [{"sha": "d8d8c20077702b8537086d49914d02654a46ebc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d8c20077702b8537086d49914d02654a46ebc5", "html_url": "https://github.com/rust-lang/rust/commit/d8d8c20077702b8537086d49914d02654a46ebc5"}], "stats": {"total": 61, "additions": 26, "deletions": 35}, "files": [{"sha": "445e3b3e469e2baa3a514c503a2f432e066c3a56", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/60251da204e9b814a2947895851dfc78539e92f3/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60251da204e9b814a2947895851dfc78539e92f3/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=60251da204e9b814a2947895851dfc78539e92f3", "patch": "@@ -111,55 +111,46 @@ pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n     errors\n }\n \n-// FIXME: kill duplication\n fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n+    fn unquote(text: &str, prefix_len: usize, end_delimiter: char) -> Option<&str> {\n+        text.rfind(end_delimiter).and_then(|end| text.get(prefix_len..end))\n+    }\n+\n     let token = literal.token();\n     let text = token.text().as_str();\n+\n+    let mut push_err = |prefix_len, (off, err): (usize, unescape::EscapeError)| {\n+        let off = token.text_range().start() + TextUnit::from_usize(off + prefix_len);\n+        acc.push(SyntaxError::new(err.into(), off));\n+    };\n+\n     match token.kind() {\n         BYTE => {\n-            if let Some(end) = text.rfind('\\'') {\n-                if let Some(without_quotes) = text.get(2..end) {\n-                    if let Err((off, err)) = unescape::unescape_byte(without_quotes) {\n-                        let off = token.text_range().start() + TextUnit::from_usize(off + 2);\n-                        acc.push(SyntaxError::new(err.into(), off))\n-                    }\n-                }\n+            if let Some(Err(e)) = unquote(text, 2, '\\'').map(unescape::unescape_byte) {\n+                push_err(2, e);\n             }\n         }\n         CHAR => {\n-            if let Some(end) = text.rfind('\\'') {\n-                if let Some(without_quotes) = text.get(1..end) {\n-                    if let Err((off, err)) = unescape::unescape_char(without_quotes) {\n-                        let off = token.text_range().start() + TextUnit::from_usize(off + 1);\n-                        acc.push(SyntaxError::new(err.into(), off))\n-                    }\n-                }\n+            if let Some(Err(e)) = unquote(text, 1, '\\'').map(unescape::unescape_char) {\n+                push_err(1, e);\n             }\n         }\n         BYTE_STRING => {\n-            if let Some(end) = text.rfind('\\\"') {\n-                if let Some(without_quotes) = text.get(2..end) {\n-                    unescape::unescape_byte_str(without_quotes, &mut |range, char| {\n-                        if let Err(err) = char {\n-                            let off = range.start;\n-                            let off = token.text_range().start() + TextUnit::from_usize(off + 2);\n-                            acc.push(SyntaxError::new(err.into(), off))\n-                        }\n-                    })\n-                }\n+            if let Some(without_quotes) = unquote(text, 2, '\"') {\n+                unescape::unescape_byte_str(without_quotes, &mut |range, char| {\n+                    if let Err(err) = char {\n+                        push_err(2, (range.start, err));\n+                    }\n+                })\n             }\n         }\n         STRING => {\n-            if let Some(end) = text.rfind('\\\"') {\n-                if let Some(without_quotes) = text.get(1..end) {\n-                    unescape::unescape_str(without_quotes, &mut |range, char| {\n-                        if let Err(err) = char {\n-                            let off = range.start;\n-                            let off = token.text_range().start() + TextUnit::from_usize(off + 1);\n-                            acc.push(SyntaxError::new(err.into(), off))\n-                        }\n-                    })\n-                }\n+            if let Some(without_quotes) = unquote(text, 1, '\"') {\n+                unescape::unescape_str(without_quotes, &mut |range, char| {\n+                    if let Err(err) = char {\n+                        push_err(1, (range.start, err));\n+                    }\n+                })\n             }\n         }\n         _ => (),"}]}