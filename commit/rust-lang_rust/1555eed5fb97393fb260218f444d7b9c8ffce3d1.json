{"sha": "1555eed5fb97393fb260218f444d7b9c8ffce3d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NTVlZWQ1ZmI5NzM5M2ZiMjYwMjE4ZjQ0NGQ3YjljOGZmY2UzZDE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-14T08:25:19Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-14T08:25:19Z"}, "message": "Merge pull request #452 from fhartwig/lifetime-false-positives\n\nFix some false positive in needless_lifetimes lint", "tree": {"sha": "b51400a42d127deb8900a7a15cefd5fdc605615d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b51400a42d127deb8900a7a15cefd5fdc605615d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1555eed5fb97393fb260218f444d7b9c8ffce3d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1555eed5fb97393fb260218f444d7b9c8ffce3d1", "html_url": "https://github.com/rust-lang/rust/commit/1555eed5fb97393fb260218f444d7b9c8ffce3d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1555eed5fb97393fb260218f444d7b9c8ffce3d1/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9881f1b49d6f264e396de30b1d80eac07e1f934a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9881f1b49d6f264e396de30b1d80eac07e1f934a", "html_url": "https://github.com/rust-lang/rust/commit/9881f1b49d6f264e396de30b1d80eac07e1f934a"}, {"sha": "6046edbc234272dd2eeb7a98028e499e57f2a255", "url": "https://api.github.com/repos/rust-lang/rust/commits/6046edbc234272dd2eeb7a98028e499e57f2a255", "html_url": "https://github.com/rust-lang/rust/commit/6046edbc234272dd2eeb7a98028e499e57f2a255"}], "stats": {"total": 107, "additions": 83, "deletions": 24}, "files": [{"sha": "229d13401c678b3928968a23775b07a6f2632a30", "filename": "src/lifetimes.rs", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1555eed5fb97393fb260218f444d7b9c8ffce3d1/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1555eed5fb97393fb260218f444d7b9c8ffce3d1/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=1555eed5fb97393fb260218f444d7b9c8ffce3d1", "patch": "@@ -3,6 +3,7 @@ use reexport::*;\n use rustc::lint::*;\n use syntax::codemap::Span;\n use rustc_front::visit::{Visitor, walk_ty, walk_ty_param_bound};\n+use rustc::middle::def::Def::{DefTy, DefTrait};\n use std::collections::HashSet;\n \n use utils::{in_external_macro, span_lint};\n@@ -53,16 +54,16 @@ use self::RefLt::*;\n \n fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n                   generics: &Generics, span: Span) {\n-    if in_external_macro(cx, span) || has_where_lifetimes(&generics.where_clause) {\n+    if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n-    if could_use_elision(decl, slf, &generics.lifetimes) {\n+    if could_use_elision(cx, decl, slf, &generics.lifetimes) {\n         span_lint(cx, NEEDLESS_LIFETIMES, span,\n                   \"explicit lifetimes given in parameter types where they could be elided\");\n     }\n }\n \n-fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n+fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n                      named_lts: &[LifetimeDef]) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n@@ -74,8 +75,8 @@ fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n     let allowed_lts = allowed_lts_from(named_lts);\n \n     // these will collect all the lifetimes for references in arg/return types\n-    let mut input_visitor = RefVisitor(Vec::new());\n-    let mut output_visitor = RefVisitor(Vec::new());\n+    let mut input_visitor = RefVisitor::new(cx);\n+    let mut output_visitor = RefVisitor::new(cx);\n \n     // extract lifetime in \"self\" argument for methods (there is a \"self\" argument\n     // in func.inputs, but its type is TyInfer)\n@@ -88,14 +89,11 @@ fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n     }\n     // extract lifetimes in input argument types\n     for arg in &func.inputs {\n-        walk_ty(&mut input_visitor, &arg.ty);\n-        if let TyRptr(None, _) = arg.ty.node {\n-            input_visitor.record(&None);\n-        }\n+        input_visitor.visit_ty(&arg.ty);\n     }\n     // extract lifetimes in output type\n     if let Return(ref ty) = func.output {\n-        walk_ty(&mut output_visitor, ty);\n+        output_visitor.visit_ty(ty);\n     }\n \n     let input_lts = input_visitor.into_vec();\n@@ -159,52 +157,92 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n }\n \n /// A visitor usable for rustc_front::visit::walk_ty().\n-struct RefVisitor(Vec<RefLt>);\n+struct RefVisitor<'v, 't: 'v> {\n+    cx: &'v LateContext<'v, 't>, // context reference\n+    lts: Vec<RefLt>\n+}\n+\n+impl <'v, 't> RefVisitor<'v, 't>  {\n+    fn new(cx: &'v LateContext<'v, 't>) -> RefVisitor<'v, 't> {\n+        RefVisitor { cx: cx, lts: Vec::new() }\n+    }\n \n-impl RefVisitor {\n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let &Some(ref lt) = lifetime {\n             if lt.name.as_str() == \"'static\" {\n-                self.0.push(Static);\n+                self.lts.push(Static);\n             } else {\n-                self.0.push(Named(lt.name));\n+                self.lts.push(Named(lt.name));\n             }\n         } else {\n-            self.0.push(Unnamed);\n+            self.lts.push(Unnamed);\n         }\n     }\n \n     fn into_vec(self) -> Vec<RefLt> {\n-        self.0\n+        self.lts\n+    }\n+\n+    fn collect_anonymous_lifetimes(&mut self, path: &Path, ty: &Ty) {\n+        let last_path_segment = path.segments.last().map(|s| &s.parameters);\n+        if let Some(&AngleBracketedParameters(ref params)) = last_path_segment {\n+            if params.lifetimes.is_empty() {\n+                let def = self.cx.tcx.def_map.borrow().get(&ty.id).map(|r| r.full_def());\n+                match def {\n+                    Some(DefTy(def_id, _)) => {\n+                        if let Some(ty_def) = self.cx.tcx.adt_defs.borrow().get(&def_id) {\n+                            let scheme = ty_def.type_scheme(self.cx.tcx);\n+                            for _ in scheme.generics.regions.as_slice() {\n+                                self.record(&None);\n+                            }\n+                        }\n+                    },\n+                    Some(DefTrait(def_id)) => {\n+                        let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n+                        for _ in &trait_def.generics.regions {\n+                            self.record(&None);\n+                        }\n+                    },\n+                    _ => {}\n+                }\n+            }\n+        }\n     }\n }\n \n-impl<'v> Visitor<'v> for RefVisitor {\n+impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n+\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         self.record(&Some(*lifetime));\n     }\n \n     fn visit_ty(&mut self, ty: &'v Ty) {\n-        if let TyRptr(None, _) = ty.node {\n-            self.record(&None);\n+        match ty.node {\n+            TyRptr(None, _) => {\n+                self.record(&None);\n+            },\n+            TyPath(_, ref path) => {\n+                self.collect_anonymous_lifetimes(path, ty);\n+            },\n+            _ => {}\n         }\n         walk_ty(self, ty);\n     }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes(where_clause: &WhereClause) -> bool {\n+fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n     for predicate in &where_clause.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n             WherePredicate::BoundPredicate(ref pred) => {\n                 // a predicate like F: Trait or F: for<'a> Trait<'a>\n-                let mut visitor = RefVisitor(Vec::new());\n+                let mut visitor = RefVisitor::new(cx);\n                 // walk the type F, it may not contain LT refs\n                 walk_ty(&mut visitor, &pred.bounded_ty);\n-                if !visitor.0.is_empty() { return true; }\n+                if !visitor.lts.is_empty() { return true; }\n                 // if the bounds define new lifetimes, they are fine to occur\n                 let allowed_lts = allowed_lts_from(&pred.bound_lifetimes);\n                 // now walk the bounds\n@@ -219,9 +257,9 @@ fn has_where_lifetimes(where_clause: &WhereClause) -> bool {\n                 }\n             }\n             WherePredicate::EqPredicate(ref pred) => {\n-                let mut visitor = RefVisitor(Vec::new());\n+                let mut visitor = RefVisitor::new(cx);\n                 walk_ty(&mut visitor, &pred.ty);\n-                if !visitor.0.is_empty() { return true; }\n+                if !visitor.lts.is_empty() { return true; }\n             }\n         }\n     }"}, {"sha": "f5d95aacc9a3659786a0ee5046e8e82a90b4a005", "filename": "tests/compile-fail/lifetimes.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1555eed5fb97393fb260218f444d7b9c8ffce3d1/tests%2Fcompile-fail%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1555eed5fb97393fb260218f444d7b9c8ffce3d1/tests%2Fcompile-fail%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flifetimes.rs?ref=1555eed5fb97393fb260218f444d7b9c8ffce3d1", "patch": "@@ -85,5 +85,26 @@ fn already_elided<'a>(_: &u8, _: &'a u8) -> &'a u8 {\n     unimplemented!()\n }\n \n+fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str { unimplemented!() } //~ERROR explicit lifetimes given\n+\n+// no warning, two input lifetimes (named on the reference, anonymous on Foo)\n+fn struct_with_lt2<'a>(_foo: &'a Foo) -> &'a str { unimplemented!() }\n+\n+// no warning, two input lifetimes (anonymous on the reference, named on Foo)\n+fn struct_with_lt3<'a>(_foo: &Foo<'a> ) -> &'a str { unimplemented!() }\n+\n+// no warning, two input lifetimes\n+fn struct_with_lt4<'a, 'b>(_foo: &'a Foo<'b> ) -> &'a str { unimplemented!() }\n+\n+trait WithLifetime<'a> {}\n+type WithLifetimeAlias<'a> = WithLifetime<'a>;\n+\n+// should not warn because it won't build without the lifetime\n+fn trait_obj_elided<'a>(_arg: &'a WithLifetime) -> &'a str { unimplemented!() }\n+\n+// this should warn because there is no lifetime on Drop, so this would be\n+// unambiguous if we elided the lifetime\n+fn trait_obj_elided2<'a>(_arg: &'a Drop) -> &'a str { unimplemented!() } //~ERROR explicit lifetimes given\n+\n fn main() {\n }"}]}