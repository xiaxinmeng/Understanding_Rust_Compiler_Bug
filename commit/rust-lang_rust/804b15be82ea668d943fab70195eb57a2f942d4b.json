{"sha": "804b15be82ea668d943fab70195eb57a2f942d4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNGIxNWJlODJlYTY2OGQ5NDNmYWI3MDE5NWViNTdhMmY5NDJkNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-01T03:25:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-01T03:25:54Z"}, "message": "Auto merge of #45846 - pietroalbini:use-nested-groups, r=petrochenkov\n\nAdd nested groups in imports\n\nThis PR adds support for nested groups in imports (rust-lang/rfcs#2128, tracking issue #44494).\n\nr? @petrochenkov", "tree": {"sha": "39e40f11e8616391f33eaafe14ad61a80a78d00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39e40f11e8616391f33eaafe14ad61a80a78d00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/804b15be82ea668d943fab70195eb57a2f942d4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/804b15be82ea668d943fab70195eb57a2f942d4b", "html_url": "https://github.com/rust-lang/rust/commit/804b15be82ea668d943fab70195eb57a2f942d4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/804b15be82ea668d943fab70195eb57a2f942d4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8a60c9611399b1b5c9c703b975af4724b432b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8a60c9611399b1b5c9c703b975af4724b432b0d", "html_url": "https://github.com/rust-lang/rust/commit/d8a60c9611399b1b5c9c703b975af4724b432b0d"}, {"sha": "f7f69512c8741e81714252d481a4cf6936f2c65f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f69512c8741e81714252d481a4cf6936f2c65f", "html_url": "https://github.com/rust-lang/rust/commit/f7f69512c8741e81714252d481a4cf6936f2c65f"}], "stats": {"total": 1527, "additions": 949, "deletions": 578}, "files": [{"sha": "47b635bad736ff80af85b7ce71f0cef7b748c7e6", "filename": "src/doc/unstable-book/src/language-features/use-nested-groups.md", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -0,0 +1,90 @@\n+# `use_nested_groups`\n+\n+The tracking issue for this feature is: [#44494]\n+\n+[#44494]: https://github.com/rust-lang/rust/issues/44494\n+\n+------------------------\n+\n+The `use_nested_groups` feature allows you to import multiple items from a\n+complex module tree easily, by nesting different imports in the same\n+declaration. For example:\n+\n+```rust\n+#![feature(use_nested_groups)]\n+# #![allow(unused_imports, dead_code)]\n+#\n+# mod foo {\n+#     pub mod bar {\n+#         pub type Foo = ();\n+#     }\n+#     pub mod baz {\n+#         pub mod quux {\n+#             pub type Bar = ();\n+#         }\n+#     }\n+# }\n+\n+use foo::{\n+    bar::{self, Foo},\n+    baz::{*, quux::Bar},\n+};\n+#\n+# fn main() {}\n+```\n+\n+## Snippet for the book's new features appendix\n+\n+When stabilizing, add this to\n+`src/doc/book/second-edition/src/appendix-07-newest-features.md`:\n+\n+### Nested groups in `use` declarations\n+\n+If you have a complex module tree with many different submodules and you need\n+to import a few items from each one, it might be useful to group all the\n+imports in the same declaration to keep your code clean and avoid repeating the\n+base modules' name.\n+\n+The `use` declaration supports nesting to help you in those cases, both with\n+simple imports and glob ones. For example this snippets imports `bar`, `Foo`,\n+all the items in `baz` and `Bar`:\n+\n+```rust\n+# #![feature(use_nested_groups)]\n+# #![allow(unused_imports, dead_code)]\n+#\n+# mod foo {\n+#     pub mod bar {\n+#         pub type Foo = ();\n+#     }\n+#     pub mod baz {\n+#         pub mod quux {\n+#             pub type Bar = ();\n+#         }\n+#     }\n+# }\n+#\n+use foo::{\n+    bar::{self, Foo},\n+    baz::{*, quux::Bar},\n+};\n+#\n+# fn main() {}\n+```\n+\n+## Updated reference\n+\n+When stabilizing, replace the shortcut list in\n+`src/doc/reference/src/items/use-declarations.md` with this updated one:\n+\n+* Simultaneously binding a list of paths with a common prefix, using the\n+  glob-like brace syntax `use a::b::{c, d, e::f, g::h::i};`\n+* Simultaneously binding a list of paths with a common prefix and their common\n+  parent module, using the `self` keyword, such as `use a::b::{self, c, d::e};`\n+* Rebinding the target name as a new local name, using the syntax `use p::q::r\n+  as x;`. This can also be used with the last two features:\n+  `use a::b::{self as ab, c as abc}`.\n+* Binding all paths matching a given prefix, using the asterisk wildcard syntax\n+  `use a::b::*;`.\n+* Nesting groups of the previous features multiple times, such as\n+  `use a::b::{self as ab, c d::{*, e::f}};`"}, {"sha": "cafbbe4c117180d7446eba931f8de88b280bb3ae", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 130, "deletions": 78, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -1768,80 +1768,14 @@ impl<'a> LoweringContext<'a> {\n                        -> hir::Item_ {\n         match *i {\n             ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n-            ItemKind::Use(ref view_path) => {\n-                let path = match view_path.node {\n-                    ViewPathSimple(_, ref path) => path,\n-                    ViewPathGlob(ref path) => path,\n-                    ViewPathList(ref path, ref path_list_idents) => {\n-                        for &Spanned { node: ref import, span } in path_list_idents {\n-                            // `use a::{self as x, b as y};` lowers to\n-                            // `use a as x; use a::b as y;`\n-                            let mut ident = import.name;\n-                            let suffix = if ident.name == keywords::SelfValue.name() {\n-                                if let Some(last) = path.segments.last() {\n-                                    ident = last.identifier;\n-                                }\n-                                None\n-                            } else {\n-                                Some(ident.name)\n-                            };\n-\n-                            let mut path = self.lower_path_extra(import.id, path, suffix,\n-                                                                 ParamMode::Explicit, true);\n-                            path.span = span;\n-\n-                            self.allocate_hir_id_counter(import.id, import);\n-                            let LoweredNodeId {\n-                                node_id: import_node_id,\n-                                hir_id: import_hir_id,\n-                            } = self.lower_node_id(import.id);\n-\n-                            self.with_hir_id_owner(import_node_id, |this| {\n-                                let vis = match *vis {\n-                                    hir::Visibility::Public => hir::Visibility::Public,\n-                                    hir::Visibility::Crate => hir::Visibility::Crate,\n-                                    hir::Visibility::Inherited => hir::Visibility::Inherited,\n-                                    hir::Visibility::Restricted { ref path, id: _ } => {\n-                                        hir::Visibility::Restricted {\n-                                            path: path.clone(),\n-                                            // We are allocating a new NodeId here\n-                                            id: this.next_id().node_id,\n-                                        }\n-                                    }\n-                                };\n-\n-                                this.items.insert(import_node_id, hir::Item {\n-                                    id: import_node_id,\n-                                    hir_id: import_hir_id,\n-                                    name: import.rename.unwrap_or(ident).name,\n-                                    attrs: attrs.clone(),\n-                                    node: hir::ItemUse(P(path), hir::UseKind::Single),\n-                                    vis,\n-                                    span,\n-                                });\n-                            });\n-                        }\n-                        path\n-                    }\n+            ItemKind::Use(ref use_tree) => {\n+                // Start with an empty prefix\n+                let prefix = Path {\n+                    segments: vec![],\n+                    span: use_tree.span,\n                 };\n-                let path = P(self.lower_path(id, path, ParamMode::Explicit, true));\n-                let kind = match view_path.node {\n-                    ViewPathSimple(ident, _) => {\n-                        *name = ident.name;\n-                        hir::UseKind::Single\n-                    }\n-                    ViewPathGlob(_) => {\n-                        hir::UseKind::Glob\n-                    }\n-                    ViewPathList(..) => {\n-                        // Privatize the degenerate import base, used only to check\n-                        // the stability of `use a::{};`, to avoid it showing up as\n-                        // a reexport by accident when `pub`, e.g. in documentation.\n-                        *vis = hir::Inherited;\n-                        hir::UseKind::ListStem\n-                    }\n-                };\n-                hir::ItemUse(path, kind)\n+\n+                self.lower_use_tree(use_tree, &prefix, id, vis, name, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n@@ -1963,6 +1897,112 @@ impl<'a> LoweringContext<'a> {\n         //     not cause an assertion failure inside the `lower_defaultness` function\n     }\n \n+    fn lower_use_tree(&mut self,\n+                       tree: &UseTree,\n+                       prefix: &Path,\n+                       id: NodeId,\n+                       vis: &mut hir::Visibility,\n+                       name: &mut Name,\n+                       attrs: &hir::HirVec<Attribute>)\n+                       -> hir::Item_ {\n+        let path = &tree.prefix;\n+\n+        match tree.kind {\n+            UseTreeKind::Simple(ident) => {\n+                *name = ident.name;\n+\n+                // First apply the prefix to the path\n+                let mut path = Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(path.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: path.span.to(prefix.span),\n+                };\n+\n+                // Correctly resolve `self` imports\n+                if path.segments.last().unwrap().identifier.name == keywords::SelfValue.name() {\n+                    let _ = path.segments.pop();\n+                    if ident.name == keywords::SelfValue.name() {\n+                        *name = path.segments.last().unwrap().identifier.name;\n+                    }\n+                }\n+\n+                let path = P(self.lower_path(id, &path, ParamMode::Explicit, true));\n+                hir::ItemUse(path, hir::UseKind::Single)\n+            }\n+            UseTreeKind::Glob => {\n+                let path = P(self.lower_path(id, &Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(path.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: path.span,\n+                }, ParamMode::Explicit, true));\n+                hir::ItemUse(path, hir::UseKind::Glob)\n+            }\n+            UseTreeKind::Nested(ref trees) => {\n+                let prefix = Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(path.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: prefix.span.to(path.span),\n+                };\n+\n+                // Add all the nested PathListItems in the HIR\n+                for &(ref use_tree, id) in trees {\n+                    self.allocate_hir_id_counter(id, &use_tree);\n+                    let LoweredNodeId {\n+                        node_id: new_id,\n+                        hir_id: new_hir_id,\n+                    } = self.lower_node_id(id);\n+\n+                    let mut vis = vis.clone();\n+                    let mut name = name.clone();\n+                    let item = self.lower_use_tree(\n+                        use_tree, &prefix, new_id, &mut vis, &mut name, &attrs,\n+                    );\n+\n+                    self.with_hir_id_owner(new_id, |this| {\n+                        let vis = match vis {\n+                            hir::Visibility::Public => hir::Visibility::Public,\n+                            hir::Visibility::Crate => hir::Visibility::Crate,\n+                            hir::Visibility::Inherited => hir::Visibility::Inherited,\n+                            hir::Visibility::Restricted { ref path, id: _  } => {\n+                                hir::Visibility::Restricted {\n+                                    path: path.clone(),\n+                                    // We are allocating a new NodeId here\n+                                    id: this.next_id().node_id,\n+                                }\n+                            }\n+                        };\n+\n+                        this.items.insert(new_id, hir::Item {\n+                            id: new_id,\n+                            hir_id: new_hir_id,\n+                            name: name,\n+                            attrs: attrs.clone(),\n+                            node: item,\n+                            vis,\n+                            span: use_tree.span,\n+                        });\n+                    });\n+                }\n+\n+                // Privatize the degenerate import base, used only to check\n+                // the stability of `use a::{};`, to avoid it showing up as\n+                // a reexport by accident when `pub`, e.g. in documentation.\n+                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit, true));\n+                *vis = hir::Inherited;\n+                hir::ItemUse(path, hir::UseKind::ListStem)\n+            }\n+        }\n+    }\n+\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n@@ -2129,18 +2169,30 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_item_id(&mut self, i: &Item) -> SmallVector<hir::ItemId> {\n         match i.node {\n-            ItemKind::Use(ref view_path) => {\n-                if let ViewPathList(_, ref imports) = view_path.node {\n-                    return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n-                        .map(|id| hir::ItemId { id: id }).collect();\n-                }\n+            ItemKind::Use(ref use_tree) => {\n+                let mut vec = SmallVector::one(hir::ItemId { id: i.id });\n+                self.lower_item_id_use_tree(use_tree, &mut vec);\n+                return vec;\n             }\n             ItemKind::MacroDef(..) => return SmallVector::new(),\n             _ => {}\n         }\n         SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n+    fn lower_item_id_use_tree(&self, tree: &UseTree, vec: &mut SmallVector<hir::ItemId>) {\n+        match tree.kind {\n+            UseTreeKind::Nested(ref nested_vec) => {\n+                for &(ref nested, id) in nested_vec {\n+                    vec.push(hir::ItemId { id, });\n+                    self.lower_item_id_use_tree(nested, vec);\n+                }\n+            }\n+            UseTreeKind::Glob => {}\n+            UseTreeKind::Simple(..) => {}\n+        }\n+    }\n+\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut name = i.ident.name;\n         let mut vis = self.lower_visibility(&i.vis, None);"}, {"sha": "17a4c66edb9c923168d0743808e6e02abc364891", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -118,21 +118,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n-            ItemKind::Use(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathGlob(..) => {}\n-\n-                    // FIXME(eddyb) Should use the real name. Which namespace?\n-                    ViewPathSimple(..) => {}\n-                    ViewPathList(_, ref imports) => {\n-                        for import in imports {\n-                            self.create_def(import.node.id,\n-                                            DefPathData::Misc,\n-                                            ITEM_LIKE_SPACE);\n-                        }\n-                    }\n-                }\n-                DefPathData::Misc\n+            ItemKind::Use(..) => {\n+                return visit::walk_item(self, i);\n             }\n         };\n         let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE);\n@@ -180,6 +167,11 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n+    fn visit_use_tree(&mut self, use_tree: &'a UseTree, id: NodeId, _nested: bool) {\n+        self.create_def(id, DefPathData::Misc, ITEM_LIKE_SPACE);\n+        visit::walk_use_tree(self, use_tree, id);\n+    }\n+\n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n                                   DefPathData::ValueNs(foreign_item.ident.name.as_str()),"}, {"sha": "2b9d5f27c661e173d9dfdfe8846fd72f7e6500a8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -981,12 +981,6 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         ast_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &'a ast::Path, item: &'a ast::PathListItem) {\n-        run_lints!(self, check_path_list_item, early_passes, item);\n-        self.check_id(item.node.id);\n-        ast_visit::walk_path_list_item(self, prefix, item);\n-    }\n-\n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         run_lints!(self, check_attribute, early_passes, attr);\n     }"}, {"sha": "b5cc6556dace1265364112225ce404a922bb2f86", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -248,7 +248,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_lifetime(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n     fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }\n-    fn check_path_list_item(&mut self, _: &EarlyContext, _: &ast::PathListItem) { }\n     fn check_attribute(&mut self, _: &EarlyContext, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such"}, {"sha": "4e066ecf999e3f0eb99292e3970ea802959b0549", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -330,6 +330,43 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct UnusedImportBraces;\n \n+impl UnusedImportBraces {\n+    fn check_use_tree(&self, cx: &EarlyContext, use_tree: &ast::UseTree, item: &ast::Item) {\n+        if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n+            // Recursively check nested UseTrees\n+            for &(ref tree, _) in items {\n+                self.check_use_tree(cx, tree, item);\n+            }\n+\n+            // Trigger the lint only if there is one nested item\n+            if items.len() != 1 {\n+                return;\n+            }\n+\n+            // Trigger the lint if the nested item is a non-self single item\n+            let node_ident;\n+            match items[0].0.kind {\n+                ast::UseTreeKind::Simple(ident) => {\n+                    if ident.name == keywords::SelfValue.name() {\n+                        return;\n+                    } else {\n+                        node_ident = ident;\n+                    }\n+                }\n+                ast::UseTreeKind::Glob => {\n+                    node_ident = ast::Ident::from_str(\"*\");\n+                }\n+                ast::UseTreeKind::Nested(_) => {\n+                    return;\n+                }\n+            }\n+\n+            let msg = format!(\"braces around {} is unnecessary\", node_ident.name);\n+            cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n+        }\n+    }\n+}\n+\n impl LintPass for UnusedImportBraces {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_IMPORT_BRACES)\n@@ -338,13 +375,8 @@ impl LintPass for UnusedImportBraces {\n \n impl EarlyLintPass for UnusedImportBraces {\n     fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n-        if let ast::ItemKind::Use(ref view_path) = item.node {\n-            if let ast::ViewPathList(_, ref items) = view_path.node {\n-                if items.len() == 1 && items[0].node.name.name != keywords::SelfValue.name() {\n-                    let msg = format!(\"braces around {} is unnecessary\", items[0].node.name);\n-                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n-                }\n-            }\n+        if let ast::ItemKind::Use(ref use_tree) = item.node {\n+            self.check_use_tree(cx, use_tree, item);\n         }\n     }\n }"}, {"sha": "97cea5c9d6452a0d29308746efd8574926b7b6d5", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -181,15 +181,27 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n+    fn visit_use_tree(&mut self, use_tree: &'a UseTree, id: NodeId, _nested: bool) {\n+        // Check if the path in this `use` is not generic, such as `use foo::bar<T>;` While this\n+        // can't happen normally thanks to the parser, a generic might sneak in if the `use` is\n+        // built using a macro.\n+        //\n+        // macro_use foo {\n+        //     ($p:path) => { use $p; }\n+        // }\n+        // foo!(bar::baz<T>);\n+        use_tree.prefix.segments.iter().find(|segment| {\n+            segment.parameters.is_some()\n+        }).map(|segment| {\n+            self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+                                        \"generic arguments in import path\");\n+        });\n+\n+        visit::walk_use_tree(self, use_tree, id);\n+    }\n+\n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n-            ItemKind::Use(ref view_path) => {\n-                let path = view_path.node.path();\n-                path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n-                    self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n-                                                \"generic arguments in import path\");\n-                });\n-            }\n             ItemKind::Impl(.., Some(..), _, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n                 for impl_item in impl_items {"}, {"sha": "6f93fa133b9e4c7cb877c59032a0756205b501d8", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -358,13 +358,6 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"Mac\", Id::None, mac);\n     }\n \n-    fn visit_path_list_item(&mut self,\n-                            prefix: &'v ast::Path,\n-                            item: &'v ast::PathListItem) {\n-        self.record(\"PathListItem\", Id::None, item);\n-        ast_visit::walk_path_list_item(self, prefix, item)\n-    }\n-\n     fn visit_path_segment(&mut self,\n                           path_span: Span,\n                           path_segment: &'v ast::PathSegment) {"}, {"sha": "afca6ea2c07515dc38349d6f1ba005b52652b930", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 141, "deletions": 129, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -32,9 +32,8 @@ use std::rc::Rc;\n use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n-use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n-use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n-use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n+use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::codemap::respan;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n@@ -102,144 +101,157 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n-        let parent = self.current_module;\n-        let ident = item.ident;\n-        let sp = item.span;\n-        let vis = self.resolve_visibility(&item.vis);\n+    fn build_reduced_graph_for_use_tree(&mut self,\n+                                        use_tree: &ast::UseTree,\n+                                        id: NodeId,\n+                                        vis: ty::Visibility,\n+                                        prefix: &ast::Path,\n+                                        nested: bool,\n+                                        item: &Item,\n+                                        expansion: Mark) {\n+        let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n+        let path = &use_tree.prefix;\n+\n+        let mut module_path: Vec<_> = prefix.segments.iter()\n+            .chain(path.segments.iter())\n+            .map(|seg| respan(seg.span, seg.identifier))\n+            .collect();\n+\n+        match use_tree.kind {\n+            ast::UseTreeKind::Simple(mut ident) => {\n+                let mut source = module_path.pop().unwrap().node;\n+                let mut type_ns_only = false;\n+\n+                if nested {\n+                    // Correctly handle `self`\n+                    if source.name == keywords::SelfValue.name() {\n+                        type_ns_only = true;\n+\n+                        let last_segment = *module_path.last().unwrap();\n+                        if last_segment.node.name == keywords::CrateRoot.name() {\n+                            resolve_error(\n+                                self,\n+                                use_tree.span,\n+                                ResolutionError::\n+                                SelfImportOnlyInImportListWithNonEmptyPrefix\n+                            );\n+                            return;\n+                        }\n \n-        match item.node {\n-            ItemKind::Use(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path: Vec<_> = match view_path.node {\n-                    ViewPathSimple(_, ref full_path) => {\n-                        full_path.segments\n-                                 .split_last()\n-                                 .unwrap()\n-                                 .1\n-                                 .iter()\n-                                 .map(|seg| respan(seg.span, seg.identifier))\n-                                 .collect()\n+                        // Replace `use foo::self;` with `use foo;`\n+                        let _ = module_path.pop();\n+                        source = last_segment.node;\n+                        if ident.name == keywords::SelfValue.name() {\n+                            ident = last_segment.node;\n+                        }\n                     }\n-\n-                    ViewPathGlob(ref module_ident_path) |\n-                    ViewPathList(ref module_ident_path, _) => {\n-                        module_ident_path.segments\n-                                         .iter()\n-                                         .map(|seg| respan(seg.span, seg.identifier))\n-                                         .collect()\n+                } else {\n+                    // Disallow `self`\n+                    if source.name == keywords::SelfValue.name() {\n+                        resolve_error(self,\n+                                      use_tree.span,\n+                                      ResolutionError::SelfImportsOnlyAllowedWithin);\n                     }\n-                };\n \n-                // Build up the import directives.\n-                let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n-\n-                match view_path.node {\n-                    ViewPathSimple(mut binding, ref full_path) => {\n-                        let mut source = full_path.segments.last().unwrap().identifier;\n-                        let source_name = source.name;\n-                        if source_name == \"mod\" || source_name == \"self\" {\n-                            resolve_error(self,\n-                                          view_path.span,\n-                                          ResolutionError::SelfImportsOnlyAllowedWithin);\n-                        } else if source_name == keywords::DollarCrate.name() &&\n-                                  full_path.segments.len() == 1 {\n-                            let crate_root = self.resolve_crate_root(source.ctxt);\n-                            let crate_name = match crate_root.kind {\n-                                ModuleKind::Def(_, name) => name,\n-                                ModuleKind::Block(..) => unreachable!(),\n-                            };\n-                            source.name = crate_name;\n-                            if binding.name == keywords::DollarCrate.name() {\n-                                binding.name = crate_name;\n-                            }\n-\n-                            self.session.struct_span_warn(item.span, \"`$crate` may not be imported\")\n-                                .note(\"`use $crate;` was erroneously allowed and \\\n-                                       will become a hard error in a future release\")\n-                                .emit();\n+                    // Disallow `use $crate;`\n+                    if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n+                        let crate_root = self.resolve_crate_root(source.ctxt);\n+                        let crate_name = match crate_root.kind {\n+                            ModuleKind::Def(_, name) => name,\n+                            ModuleKind::Block(..) => unreachable!(),\n+                        };\n+                        source.name = crate_name;\n+                        if ident.name == keywords::DollarCrate.name() {\n+                            ident.name = crate_name;\n                         }\n \n-                        let subclass = SingleImport {\n-                            target: binding,\n-                            source,\n-                            result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n-                            type_ns_only: false,\n-                        };\n-                        self.add_import_directive(\n-                            module_path, subclass, view_path.span, item.id, vis, expansion,\n-                        );\n+                        self.session.struct_span_warn(item.span, \"`$crate` may not be imported\")\n+                            .note(\"`use $crate;` was erroneously allowed and \\\n+                                   will become a hard error in a future release\")\n+                            .emit();\n                     }\n-                    ViewPathList(_, ref source_items) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| {\n-                            if item.node.name.name == keywords::SelfValue.name() {\n-                                Some(item.span)\n-                            } else {\n-                                None\n-                            }\n-                        }).collect::<Vec<Span>>();\n-\n-                        if mod_spans.len() > 1 {\n-                            let mut e = resolve_struct_error(self,\n-                                          mod_spans[0],\n-                                          ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                e.span_note(*other_span, \"another `self` import appears here\");\n-                            }\n-                            e.emit();\n-                        }\n+                }\n \n-                        for source_item in source_items {\n-                            let node = source_item.node;\n-                            let (module_path, ident, rename, type_ns_only) = {\n-                                if node.name.name != keywords::SelfValue.name() {\n-                                    let rename = node.rename.unwrap_or(node.name);\n-                                    (module_path.clone(),\n-                                     respan(source_item.span, node.name),\n-                                     rename,\n-                                     false)\n-                                } else {\n-                                    let ident = *module_path.last().unwrap();\n-                                    if ident.node.name == keywords::CrateRoot.name() {\n-                                        resolve_error(\n-                                            self,\n-                                            source_item.span,\n-                                            ResolutionError::\n-                                            SelfImportOnlyInImportListWithNonEmptyPrefix\n-                                        );\n-                                        continue;\n-                                    }\n-                                    let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.unwrap_or(ident.node);\n-                                    (module_path.to_vec(), ident, rename, true)\n-                                }\n-                            };\n-                            let subclass = SingleImport {\n-                                target: rename,\n-                                source: ident.node,\n-                                result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n-                                type_ns_only,\n-                            };\n-                            let id = source_item.node.id;\n-                            self.add_import_directive(\n-                                module_path, subclass, source_item.span, id, vis, expansion,\n-                            );\n+                let subclass = SingleImport {\n+                    target: ident,\n+                    source,\n+                    result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                    type_ns_only,\n+                };\n+                self.add_import_directive(\n+                    module_path, subclass, use_tree.span, id, vis, expansion,\n+                );\n+            }\n+            ast::UseTreeKind::Glob => {\n+                let subclass = GlobImport {\n+                    is_prelude,\n+                    max_vis: Cell::new(ty::Visibility::Invisible),\n+                };\n+                self.add_import_directive(\n+                    module_path, subclass, use_tree.span, id, vis, expansion,\n+                );\n+            }\n+            ast::UseTreeKind::Nested(ref items) => {\n+                let prefix = ast::Path {\n+                    segments: module_path.iter()\n+                        .map(|s| ast::PathSegment {\n+                            identifier: s.node,\n+                            span: s.span,\n+                            parameters: None,\n+                        })\n+                        .collect(),\n+                    span: path.span,\n+                };\n+\n+                // Ensure there is at most one `self` in the list\n+                let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n+                    if let ast::UseTreeKind::Simple(ident) = use_tree.kind {\n+                        if ident.name == keywords::SelfValue.name() {\n+                            return Some(use_tree.span);\n                         }\n                     }\n-                    ViewPathGlob(_) => {\n-                        let subclass = GlobImport {\n-                            is_prelude,\n-                            max_vis: Cell::new(ty::Visibility::Invisible),\n-                        };\n-                        self.add_import_directive(\n-                            module_path, subclass, view_path.span, item.id, vis, expansion,\n-                        );\n+\n+                    None\n+                }).collect::<Vec<_>>();\n+                if self_spans.len() > 1 {\n+                    let mut e = resolve_struct_error(self,\n+                        self_spans[0],\n+                        ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n+\n+                    for other_span in self_spans.iter().skip(1) {\n+                        e.span_note(*other_span, \"another `self` import appears here\");\n                     }\n+\n+                    e.emit();\n                 }\n+\n+                for &(ref tree, id) in items {\n+                    self.build_reduced_graph_for_use_tree(\n+                        tree, id, vis, &prefix, true, item, expansion\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Constructs the reduced graph for one item.\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n+        let parent = self.current_module;\n+        let ident = item.ident;\n+        let sp = item.span;\n+        let vis = self.resolve_visibility(&item.vis);\n+\n+        match item.node {\n+            ItemKind::Use(ref use_tree) => {\n+                // Just an empty prefix to start out\n+                let prefix = ast::Path {\n+                    segments: vec![],\n+                    span: use_tree.span,\n+                };\n+\n+                self.build_reduced_graph_for_use_tree(\n+                    use_tree, item.id, vis, &prefix, false, item, expansion,\n+                );\n             }\n \n             ItemKind::ExternCrate(as_name) => {"}, {"sha": "0fb3d96cd50d48cffe847f70d3f8d01145db9877", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -26,7 +26,7 @@ use resolve_imports::ImportDirectiveSubclass;\n \n use rustc::{lint, ty};\n use rustc::util::nodemap::NodeMap;\n-use syntax::ast::{self, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast;\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n \n@@ -35,6 +35,8 @@ struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n     unused_imports: NodeMap<NodeMap<Span>>,\n+    base_id: ast::NodeId,\n+    item_span: Span,\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n@@ -77,40 +79,41 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n \n impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n-        visit::walk_item(self, item);\n+        self.item_span = item.span;\n+\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if item.vis == ast::Visibility::Public || item.span.source_equal(&DUMMY_SP) {\n-            return;\n+        if let ast::ItemKind::Use(..) = item.node {\n+            if item.vis == ast::Visibility::Public || item.span.source_equal(&DUMMY_SP) {\n+                return;\n+            }\n         }\n \n-        match item.node {\n-            ast::ItemKind::Use(ref p) => {\n-                match p.node {\n-                    ViewPathSimple(..) => {\n-                        self.check_import(item.id, item.id, p.span)\n-                    }\n-\n-                    ViewPathList(_, ref list) => {\n-                        if list.len() == 0 {\n-                            self.unused_imports\n-                                .entry(item.id)\n-                                .or_insert_with(NodeMap)\n-                                .insert(item.id, item.span);\n-                        }\n-                        for i in list {\n-                            self.check_import(item.id, i.node.id, i.span);\n-                        }\n-                    }\n-                    ViewPathGlob(_) => {\n-                        self.check_import(item.id, item.id, p.span);\n-                    }\n-                }\n+        visit::walk_item(self, item);\n+    }\n+\n+    fn visit_use_tree(&mut self, use_tree: &'a ast::UseTree, id: ast::NodeId, nested: bool) {\n+        // Use the base UseTree's NodeId as the item id\n+        // This allows the grouping of all the lints in the same item\n+        if !nested {\n+            self.base_id = id;\n+        }\n+\n+        if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n+            if items.len() == 0 {\n+                self.unused_imports\n+                    .entry(self.base_id)\n+                    .or_insert_with(NodeMap)\n+                    .insert(id, self.item_span);\n             }\n-            _ => {}\n+        } else {\n+            let base_id = self.base_id;\n+            self.check_import(base_id, id, use_tree.span);\n         }\n+\n+        visit::walk_use_tree(self, use_tree, id);\n     }\n }\n \n@@ -135,6 +138,8 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n     let mut visitor = UnusedImportCheckVisitor {\n         resolver,\n         unused_imports: NodeMap(),\n+        base_id: ast::DUMMY_NODE_ID,\n+        item_span: DUMMY_SP,\n     };\n     visit::walk_crate(&mut visitor, krate);\n "}, {"sha": "44db030b2b242bab474e707f3b2e380154b0be33", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -1937,14 +1937,12 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            ItemKind::Use(ref view_path) => {\n-                match view_path.node {\n-                    ast::ViewPathList(ref prefix, ref items) if items.is_empty() => {\n-                        // Resolve prefix of an import with empty braces (issue #28388).\n-                        self.smart_resolve_path(item.id, None, prefix, PathSource::ImportPrefix);\n-                    }\n-                    _ => {}\n-                }\n+            ItemKind::Use(ref use_tree) => {\n+                let path = Path {\n+                    segments: vec![],\n+                    span: use_tree.span,\n+                };\n+                self.resolve_use_tree(item, use_tree, &path);\n             }\n \n             ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(_)=> {\n@@ -1955,6 +1953,32 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn resolve_use_tree(&mut self, item: &Item, use_tree: &ast::UseTree, prefix: &Path) {\n+        match use_tree.kind {\n+            ast::UseTreeKind::Nested(ref items) => {\n+                let path = Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(use_tree.prefix.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: prefix.span.to(use_tree.prefix.span),\n+                };\n+\n+                if items.len() == 0 {\n+                    // Resolve prefix of an import with empty braces (issue #28388).\n+                    self.smart_resolve_path(item.id, None, &path, PathSource::ImportPrefix);\n+                } else {\n+                    for &(ref tree, _) in items {\n+                        self.resolve_use_tree(item, tree, &path);\n+                    }\n+                }\n+            }\n+            ast::UseTreeKind::Simple(_) => {},\n+            ast::UseTreeKind::Glob => {},\n+        }\n+    }\n+\n     fn with_type_parameter_rib<'b, F>(&'b mut self, type_parameters: TypeParameters<'a, 'b>, f: F)\n         where F: FnOnce(&mut Resolver)\n     {"}, {"sha": "602c70f9a1f4b52bafda9e50565ca95382528f9e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 107, "deletions": 81, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -38,7 +38,7 @@ use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{bounds_to_string, generics_to_string, path_to_string, ty_to_string};\n use syntax::ptr::P;\n-use syntax::codemap::Spanned;\n+use syntax::codemap::{Spanned, DUMMY_SP};\n use syntax_pos::*;\n \n use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n@@ -1229,6 +1229,106 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::ImplItemKind::Macro(_) => {}\n         }\n     }\n+\n+    fn process_use_tree(&mut self,\n+                         use_tree: &'l ast::UseTree,\n+                         id: NodeId,\n+                         parent_item: &'l ast::Item,\n+                         prefix: &ast::Path) {\n+        let path = &use_tree.prefix;\n+        let access = access_from!(self.save_ctxt, parent_item);\n+\n+        match use_tree.kind {\n+            ast::UseTreeKind::Simple(ident) => {\n+                let path = ast::Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(path.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: path.span,\n+                };\n+\n+                let sub_span = self.span.span_for_last_ident(path.span);\n+                let mod_id = match self.lookup_def_id(id) {\n+                    Some(def_id) => {\n+                        self.process_def_kind(id, path.span, sub_span, def_id);\n+                        Some(def_id)\n+                    }\n+                    None => None,\n+                };\n+\n+                // 'use' always introduces an alias, if there is not an explicit\n+                // one, there is an implicit one.\n+                let sub_span = match self.span.sub_span_after_keyword(use_tree.span,\n+                                                                      keywords::As) {\n+                    Some(sub_span) => Some(sub_span),\n+                    None => sub_span,\n+                };\n+\n+                if !self.span.filter_generated(sub_span, path.span) {\n+                    let span =\n+                        self.span_from_span(sub_span.expect(\"No span found for use\"));\n+                    self.dumper.import(&access, Import {\n+                        kind: ImportKind::Use,\n+                        ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n+                        span,\n+                        name: ident.to_string(),\n+                        value: String::new(),\n+                    });\n+                }\n+                self.write_sub_paths_truncated(&path);\n+            }\n+            ast::UseTreeKind::Glob => {\n+                let path = ast::Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(path.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: path.span,\n+                };\n+\n+                // Make a comma-separated list of names of imported modules.\n+                let mut names = vec![];\n+                let glob_map = &self.save_ctxt.analysis.glob_map;\n+                let glob_map = glob_map.as_ref().unwrap();\n+                if glob_map.contains_key(&id) {\n+                    for n in glob_map.get(&id).unwrap() {\n+                        names.push(n.to_string());\n+                    }\n+                }\n+\n+                let sub_span = self.span.sub_span_of_token(use_tree.span,\n+                                                           token::BinOp(token::Star));\n+                if !self.span.filter_generated(sub_span, use_tree.span) {\n+                    let span =\n+                        self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n+                    self.dumper.import(&access, Import {\n+                        kind: ImportKind::GlobUse,\n+                        ref_id: None,\n+                        span,\n+                        name: \"*\".to_owned(),\n+                        value: names.join(\", \"),\n+                    });\n+                }\n+                self.write_sub_paths(&path);\n+            }\n+            ast::UseTreeKind::Nested(ref nested_items) => {\n+                let prefix = ast::Path {\n+                    segments: prefix.segments\n+                        .iter()\n+                        .chain(path.segments.iter())\n+                        .cloned()\n+                        .collect(),\n+                    span: path.span,\n+                };\n+                for &(ref tree, id) in nested_items {\n+                    self.process_use_tree(tree, id, parent_item, &prefix);\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll, O> {\n@@ -1275,86 +1375,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span);\n         match item.node {\n-            Use(ref use_item) => {\n-                let access = access_from!(self.save_ctxt, item);\n-\n-                match use_item.node {\n-                    ast::ViewPathSimple(ident, ref path) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_def_id(item.id) {\n-                            Some(def_id) => {\n-                                self.process_def_kind(item.id, path.span, sub_span, def_id);\n-                                Some(def_id)\n-                            }\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span = match self.span\n-                            .sub_span_after_keyword(use_item.span, keywords::As)\n-                        {\n-                            Some(sub_span) => Some(sub_span),\n-                            None => sub_span,\n-                        };\n-\n-                        if !self.span.filter_generated(sub_span, path.span) {\n-                            let span =\n-                                self.span_from_span(sub_span.expect(\"No span found for use\"));\n-                            self.dumper.import(\n-                                &access,\n-                                Import {\n-                                    kind: ImportKind::Use,\n-                                    ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n-                                    span,\n-                                    name: ident.to_string(),\n-                                    value: String::new(),\n-                                },\n-                            );\n-                        }\n-                        self.write_sub_paths_truncated(path);\n-                    }\n-                    ast::ViewPathGlob(ref path) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut names = vec![];\n-                        let glob_map = &self.save_ctxt.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&item.id) {\n-                            for n in glob_map.get(&item.id).unwrap() {\n-                                names.push(n.to_string());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span\n-                            .sub_span_of_token(item.span, token::BinOp(token::Star));\n-                        if !self.span.filter_generated(sub_span, item.span) {\n-                            let span =\n-                                self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n-                            self.dumper.import(\n-                                &access,\n-                                Import {\n-                                    kind: ImportKind::GlobUse,\n-                                    ref_id: None,\n-                                    span,\n-                                    name: \"*\".to_owned(),\n-                                    value: names.join(\", \"),\n-                                },\n-                            );\n-                        }\n-                        self.write_sub_paths(path);\n-                    }\n-                    ast::ViewPathList(ref path, ref list) => {\n-                        for plid in list {\n-                            let id = plid.node.id;\n-                            if let Some(def_id) = self.lookup_def_id(id) {\n-                                let span = plid.span;\n-                                self.process_def_kind(id, span, Some(span), def_id);\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path);\n-                    }\n-                }\n+            Use(ref use_tree) => {\n+                let prefix = ast::Path {\n+                    segments: vec![],\n+                    span: DUMMY_SP,\n+                };\n+                self.process_use_tree(use_tree, item.id, item, &prefix);\n             }\n             ExternCrate(_) => {\n                 let alias_span = self.span.span_for_last_ident(item.span);"}, {"sha": "3c1d6ea18f7c2d38be251cd5cb10a0baeb126883", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -12,7 +12,6 @@\n \n pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n-pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n@@ -1705,46 +1704,20 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct PathListItem_ {\n-    pub name: Ident,\n-    /// renamed in list, e.g. `use foo::{bar as baz};`\n-    pub rename: Option<Ident>,\n-    pub id: NodeId,\n-}\n-\n-pub type PathListItem = Spanned<PathListItem_>;\n-\n-pub type ViewPath = Spanned<ViewPath_>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ViewPath_ {\n-\n-    /// `foo::bar::baz as quux`\n-    ///\n-    /// or just\n-    ///\n-    /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Ident, Path),\n-\n-    /// `foo::bar::*`\n-    ViewPathGlob(Path),\n-\n-    /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem>)\n+pub enum UseTreeKind {\n+    Simple(Ident),\n+    Glob,\n+    Nested(Vec<(UseTree, NodeId)>),\n }\n \n-impl ViewPath_ {\n-    pub fn path(&self) -> &Path {\n-        match *self {\n-            ViewPathSimple(_, ref path) |\n-            ViewPathGlob (ref path) |\n-            ViewPathList(ref path, _) => path\n-        }\n-    }\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct UseTree {\n+    pub kind: UseTreeKind,\n+    pub prefix: Path,\n+    pub span: Span,\n }\n \n-\n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n@@ -1913,7 +1886,7 @@ pub enum ItemKind {\n     /// A use declaration (`use` or `pub use`) item.\n     ///\n     /// E.g. `use foo;`, `use foo::bar;` or `use foo::bar as FooBar;`\n-    Use(P<ViewPath>),\n+    Use(P<UseTree>),\n     /// A static item (`static` or `pub static`).\n     ///\n     /// E.g. `static FOO: i32 = 42;` or `static FOO: &'static str = \"bar\";`"}, {"sha": "25eef6db9303682e7304769173154fa465a1dfbd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -291,7 +291,7 @@ pub trait AstBuilder {\n                        -> ast::MetaItem;\n \n     fn item_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item>;\n+                vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item>;\n     fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;\n     fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> P<ast::Item>;\n@@ -1142,7 +1142,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n+                vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item> {\n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n             ident: keywords::Invalid.ident(),\n@@ -1161,33 +1161,36 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> P<ast::Item> {\n-        self.item_use(sp, vis,\n-                      P(respan(sp,\n-                               ast::ViewPathSimple(ident,\n-                                                   path))))\n+        self.item_use(sp, vis, P(ast::UseTree {\n+            span: sp,\n+            prefix: path,\n+            kind: ast::UseTreeKind::Simple(ident),\n+        }))\n     }\n \n     fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n                      path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n-            let item = ast::PathListItem_ {\n-                name: *id,\n-                rename: None,\n-                id: ast::DUMMY_NODE_ID,\n-            };\n-            respan(sp, item)\n+            (ast::UseTree {\n+                span: sp,\n+                prefix: self.path(sp, vec![*id]),\n+                kind: ast::UseTreeKind::Simple(*id),\n+            }, ast::DUMMY_NODE_ID)\n         }).collect();\n \n-        self.item_use(sp, vis,\n-                      P(respan(sp,\n-                               ast::ViewPathList(self.path(sp, path),\n-                                                 imports))))\n+        self.item_use(sp, vis, P(ast::UseTree {\n+            span: sp,\n+            prefix: self.path(sp, path),\n+            kind: ast::UseTreeKind::Nested(imports),\n+        }))\n     }\n \n     fn item_use_glob(&self, sp: Span,\n                      vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n-        self.item_use(sp, vis,\n-                      P(respan(sp,\n-                               ast::ViewPathGlob(self.path(sp, path)))))\n+        self.item_use(sp, vis, P(ast::UseTree {\n+            span: sp,\n+            prefix: self.path(sp, path),\n+            kind: ast::UseTreeKind::Glob,\n+        }))\n     }\n }"}, {"sha": "c1223efb27b2a4d44661c38759cc72ebc672fd71", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -428,6 +428,9 @@ declare_features! (\n \n     // In-band lifetime bindings (e.g. `fn foo(x: &'a u8) -> &'a u8`)\n     (active, in_band_lifetimes, \"1.23.0\", Some(44524)),\n+\n+    // Nested groups in `use` (RFC 2128)\n+    (active, use_nested_groups, \"1.23.0\", Some(44494)),\n );\n \n declare_features! (\n@@ -1649,6 +1652,29 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_path(self, path);\n     }\n \n+    fn visit_use_tree(&mut self, use_tree: &'a ast::UseTree, id: NodeId, nested: bool) {\n+        if nested {\n+            match use_tree.kind {\n+                ast::UseTreeKind::Simple(_) => {\n+                    if use_tree.prefix.segments.len() != 1 {\n+                        gate_feature_post!(&self, use_nested_groups, use_tree.span,\n+                                           \"paths in `use` groups are experimental\");\n+                    }\n+                }\n+                ast::UseTreeKind::Glob => {\n+                    gate_feature_post!(&self, use_nested_groups, use_tree.span,\n+                                       \"glob imports in `use` groups are experimental\");\n+                }\n+                ast::UseTreeKind::Nested(_) => {\n+                    gate_feature_post!(&self, use_nested_groups, use_tree.span,\n+                                       \"nested groups in `use` are experimental\");\n+                }\n+            }\n+        }\n+\n+        visit::walk_use_tree(self, use_tree, id);\n+    }\n+\n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n         if let ast::Visibility::Crate(span, ast::CrateSugar::JustCrate) = *vis {\n             gate_feature_post!(&self, crate_visibility_modifier, span,"}, {"sha": "1a92f057e5e874fdf751442a014e3976ec2559c3", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -56,8 +56,8 @@ pub trait Folder : Sized {\n         noop_fold_meta_item(meta_item, self)\n     }\n \n-    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n-        noop_fold_view_path(view_path, self)\n+    fn fold_use_tree(&mut self, use_tree: UseTree) -> UseTree {\n+        noop_fold_use_tree(use_tree, self)\n     }\n \n     fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n@@ -310,30 +310,18 @@ pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<MetaItem>, fld: &mut T) -\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n-pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n-    view_path.map(|Spanned {node, span}| Spanned {\n-        node: match node {\n-            ViewPathSimple(ident, path) => {\n-                ViewPathSimple(fld.fold_ident(ident), fld.fold_path(path))\n-            }\n-            ViewPathGlob(path) => {\n-                ViewPathGlob(fld.fold_path(path))\n-            }\n-            ViewPathList(path, path_list_idents) => {\n-                let path = fld.fold_path(path);\n-                let path_list_idents = path_list_idents.move_map(|path_list_ident| Spanned {\n-                    node: PathListItem_ {\n-                        id: fld.new_id(path_list_ident.node.id),\n-                        rename: path_list_ident.node.rename.map(|ident| fld.fold_ident(ident)),\n-                        name: fld.fold_ident(path_list_ident.node.name),\n-                    },\n-                    span: fld.new_span(path_list_ident.span)\n-                });\n-                ViewPathList(path, path_list_idents)\n-            }\n+pub fn noop_fold_use_tree<T: Folder>(use_tree: UseTree, fld: &mut T) -> UseTree {\n+    UseTree {\n+        span: fld.new_span(use_tree.span),\n+        prefix: fld.fold_path(use_tree.prefix),\n+        kind: match use_tree.kind {\n+            UseTreeKind::Simple(ident) => UseTreeKind::Simple(fld.fold_ident(ident)),\n+            UseTreeKind::Glob => UseTreeKind::Glob,\n+            UseTreeKind::Nested(items) => UseTreeKind::Nested(items.move_map(|(tree, id)| {\n+                (fld.fold_use_tree(tree), fld.new_id(id))\n+            })),\n         },\n-        span: fld.new_span(span)\n-    })\n+    }\n }\n \n pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n@@ -874,8 +862,8 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n     match i {\n         ItemKind::ExternCrate(string) => ItemKind::ExternCrate(string),\n-        ItemKind::Use(view_path) => {\n-            ItemKind::Use(folder.fold_view_path(view_path))\n+        ItemKind::Use(use_tree) => {\n+            ItemKind::Use(use_tree.map(|tree| folder.fold_use_tree(tree)))\n         }\n         ItemKind::Static(t, m, e) => {\n             ItemKind::Static(folder.fold_ty(t), m, folder.fold_expr(e))"}, {"sha": "07956ecb5aff86adf3d0fcdbb28539b10ba7a734", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 85, "deletions": 58, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -35,8 +35,8 @@ use ast::StrStyle;\n use ast::SelfKind;\n use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n-use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause, CrateSugar};\n+use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n@@ -1861,7 +1861,7 @@ impl<'a> Parser<'a> {\n         loop {\n             segments.push(self.parse_path_segment(style, enable_warning)?);\n \n-            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+            if self.is_import_coupler(false) || !self.eat(&token::ModSep) {\n                 return Ok(());\n             }\n         }\n@@ -5964,7 +5964,7 @@ impl<'a> Parser<'a> {\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n-            let item_ = ItemKind::Use(self.parse_view_path()?);\n+            let item_ = ItemKind::Use(P(self.parse_use_tree(false)?));\n             self.expect(&token::Semi)?;\n \n             let prev_span = self.prev_span;\n@@ -6407,74 +6407,101 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> {\n-        self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n-                                 &token::CloseDelim(token::Brace),\n-                                 SeqSep::trailing_allowed(token::Comma), |this| {\n-            let lo = this.span;\n-            let ident = if this.eat_keyword(keywords::SelfValue) {\n-                keywords::SelfValue.ident()\n-            } else {\n-                this.parse_ident()?\n-            };\n-            let rename = this.parse_rename()?;\n-            let node = ast::PathListItem_ {\n-                name: ident,\n-                rename,\n-                id: ast::DUMMY_NODE_ID\n-            };\n-            Ok(respan(lo.to(this.prev_span), node))\n-        })\n+    /// `{` or `::{` or `*` or `::*`\n+    /// `::{` or `::*` (also `{`  or `*` if unprefixed is true)\n+    fn is_import_coupler(&mut self, unprefixed: bool) -> bool {\n+        self.is_import_coupler_inner(&token::OpenDelim(token::Brace), unprefixed) ||\n+            self.is_import_coupler_inner(&token::BinOp(token::Star), unprefixed)\n     }\n \n-    /// `::{` or `::*`\n-    fn is_import_coupler(&mut self) -> bool {\n-        self.check(&token::ModSep) &&\n-            self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n-                                   *t == token::BinOp(token::Star))\n+    fn is_import_coupler_inner(&mut self, token: &token::Token, unprefixed: bool) -> bool {\n+        if self.check(&token::ModSep) {\n+            self.look_ahead(1, |t| t == token)\n+        } else if unprefixed {\n+            self.check(token)\n+        } else {\n+            false\n+        }\n     }\n \n-    /// Matches ViewPath:\n-    /// MOD_SEP? non_global_path\n-    /// MOD_SEP? non_global_path as IDENT\n-    /// MOD_SEP? non_global_path MOD_SEP STAR\n-    /// MOD_SEP? non_global_path MOD_SEP LBRACE item_seq RBRACE\n-    /// MOD_SEP? LBRACE item_seq RBRACE\n-    fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n+    /// Parse UseTree\n+    ///\n+    /// USE_TREE = `*` |\n+    ///            `{` USE_TREE_LIST `}` |\n+    ///            PATH `::` `*` |\n+    ///            PATH `::` `{` USE_TREE_LIST `}` |\n+    ///            PATH [`as` IDENT]\n+    fn parse_use_tree(&mut self, nested: bool) -> PResult<'a, UseTree> {\n         let lo = self.span;\n-        if self.check(&token::OpenDelim(token::Brace)) || self.check(&token::BinOp(token::Star)) ||\n-           self.is_import_coupler() {\n-            // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n-            self.eat(&token::ModSep);\n-            let prefix = ast::Path {\n-                segments: vec![PathSegment::crate_root(lo)],\n-                span: lo.to(self.span),\n-            };\n-            let view_path_kind = if self.eat(&token::BinOp(token::Star)) {\n-                ViewPathGlob(prefix)\n+\n+        let mut prefix = ast::Path {\n+            segments: vec![],\n+            span: lo.to(self.span),\n+        };\n+\n+        let kind = if self.is_import_coupler(true) {\n+            // `use *;` or `use ::*;` or `use {...};` `use ::{...};`\n+\n+            // Remove the first `::`\n+            if self.eat(&token::ModSep) {\n+                prefix.segments.push(PathSegment::crate_root(self.prev_span));\n+            } else if !nested {\n+                prefix.segments.push(PathSegment::crate_root(self.span));\n+            }\n+\n+            if self.eat(&token::BinOp(token::Star)) {\n+                // `use *;`\n+                UseTreeKind::Glob\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                // `use {...};`\n+                UseTreeKind::Nested(self.parse_use_tree_list()?)\n             } else {\n-                ViewPathList(prefix, self.parse_path_list_items()?)\n-            };\n-            Ok(P(respan(lo.to(self.span), view_path_kind)))\n+                return self.unexpected();\n+            }\n         } else {\n-            let prefix = self.parse_path(PathStyle::Mod)?.default_to_global();\n-            if self.is_import_coupler() {\n-                // `foo::bar::{a, b}` or `foo::bar::*`\n-                self.bump();\n-                if self.check(&token::BinOp(token::Star)) {\n-                    self.bump();\n-                    Ok(P(respan(lo.to(self.span), ViewPathGlob(prefix))))\n+            // `use path::...;`\n+            let mut parsed = self.parse_path(PathStyle::Mod)?;\n+            if !nested {\n+                parsed = parsed.default_to_global();\n+            }\n+\n+            prefix.segments.append(&mut parsed.segments);\n+            prefix.span = prefix.span.to(parsed.span);\n+\n+            if self.eat(&token::ModSep) {\n+                if self.eat(&token::BinOp(token::Star)) {\n+                    // `use path::*;`\n+                    UseTreeKind::Glob\n+                } else if self.check(&token::OpenDelim(token::Brace)) {\n+                    // `use path::{...};`\n+                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n                 } else {\n-                    let items = self.parse_path_list_items()?;\n-                    Ok(P(respan(lo.to(self.span), ViewPathList(prefix, items))))\n+                    return self.unexpected();\n                 }\n             } else {\n-                // `foo::bar` or `foo::bar as baz`\n+                // `use path::foo;` or `use path::foo as bar;`\n                 let rename = self.parse_rename()?.\n                                   unwrap_or(prefix.segments.last().unwrap().identifier);\n-                Ok(P(respan(lo.to(self.prev_span), ViewPathSimple(rename, prefix))))\n+                UseTreeKind::Simple(rename)\n             }\n-        }\n+        };\n+\n+        Ok(UseTree {\n+            span: lo.to(self.prev_span),\n+            kind,\n+            prefix,\n+        })\n+    }\n+\n+    /// Parse UseTreeKind::Nested(list)\n+    ///\n+    /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n+    fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n+        self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n+                                 &token::CloseDelim(token::Brace),\n+                                 SeqSep::trailing_allowed(token::Comma), |this| {\n+            Ok((this.parse_use_tree(true)?, ast::DUMMY_NODE_ID))\n+        })\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {"}, {"sha": "a2d3ed4deb652ca1a3ef8c3f5c001d72bd89776c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -1185,9 +1185,9 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            ast::ItemKind::Use(ref vp) => {\n+            ast::ItemKind::Use(ref tree) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n-                self.print_view_path(vp)?;\n+                self.print_use_tree(tree)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n@@ -2918,45 +2918,39 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> io::Result<()> {\n-        match vp.node {\n-            ast::ViewPathSimple(ident, ref path) => {\n-                self.print_path(path, false, 0, true)?;\n+    pub fn print_use_tree(&mut self, tree: &ast::UseTree) -> io::Result<()> {\n+        match tree.kind {\n+            ast::UseTreeKind::Simple(ref ident) => {\n+                self.print_path(&tree.prefix, false, 0, true)?;\n \n-                if path.segments.last().unwrap().identifier.name !=\n-                        ident.name {\n+                if tree.prefix.segments.last().unwrap().identifier.name != ident.name {\n                     self.s.space()?;\n                     self.word_space(\"as\")?;\n-                    self.print_ident(ident)?;\n+                    self.print_ident(*ident)?;\n                 }\n-\n-                Ok(())\n             }\n-\n-            ast::ViewPathGlob(ref path) => {\n-                self.print_path(path, false, 0, true)?;\n-                self.s.word(\"::*\")\n+            ast::UseTreeKind::Glob => {\n+                if !tree.prefix.segments.is_empty() {\n+                    self.print_path(&tree.prefix, false, 0, true)?;\n+                    self.s.word(\"::\")?;\n+                }\n+                self.s.word(\"*\")?;\n             }\n-\n-            ast::ViewPathList(ref path, ref idents) => {\n-                if path.segments.is_empty() {\n+            ast::UseTreeKind::Nested(ref items) => {\n+                if tree.prefix.segments.is_empty() {\n                     self.s.word(\"{\")?;\n                 } else {\n-                    self.print_path(path, false, 0, true)?;\n+                    self.print_path(&tree.prefix, false, 0, true)?;\n                     self.s.word(\"::{\")?;\n                 }\n-                self.commasep(Inconsistent, &idents[..], |s, w| {\n-                    s.print_ident(w.node.name)?;\n-                    if let Some(ident) = w.node.rename {\n-                        s.s.space()?;\n-                        s.word_space(\"as\")?;\n-                        s.print_ident(ident)?;\n-                    }\n-                    Ok(())\n+                self.commasep(Inconsistent, &items[..], |this, &(ref tree, _)| {\n+                    this.print_use_tree(tree)\n                 })?;\n-                self.s.word(\"}\")\n+                self.s.word(\"}\")?;\n             }\n         }\n+\n+        Ok(())\n     }\n \n     pub fn print_mutability(&mut self,"}, {"sha": "ae22230198f577a2f444c5e93e73ee87212bcd6d", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -13,7 +13,7 @@ use attr;\n use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n-use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n+use codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use ptr::P;\n use tokenstream::TokenStream;\n \n@@ -75,12 +75,16 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n             span,\n         }],\n         vis: ast::Visibility::Inherited,\n-        node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n-            segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n-            }).collect(),\n+        node: ast::ItemKind::Use(P(ast::UseTree {\n+            prefix: ast::Path {\n+                segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+                    ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n+                }).collect(),\n+                span,\n+            },\n+            kind: ast::UseTreeKind::Glob,\n             span,\n-        })))),\n+        })),\n         id: ast::DUMMY_NODE_ID,\n         ident: keywords::Invalid.ident(),\n         span,"}, {"sha": "a4ac5826f99c121ea5c1a9a4942a0f54b44cd9b7", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -455,9 +455,11 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let id_test = Ident::from_str(\"test\");\n     let sp = ignored_span(cx, DUMMY_SP);\n     let (vi, vis, ident) = if cx.is_libtest {\n-        (ast::ItemKind::Use(\n-            P(nospan(ast::ViewPathSimple(id_test,\n-                                         path_node(vec![id_test]))))),\n+        (ast::ItemKind::Use(P(ast::UseTree {\n+            span: DUMMY_SP,\n+            prefix: path_node(vec![id_test]),\n+            kind: ast::UseTreeKind::Simple(id_test),\n+        })),\n          ast::Visibility::Public, keywords::Invalid.ident())\n     } else {\n         (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n@@ -547,9 +549,11 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         // building `use <ident> = __test::main`\n         let reexport_ident = Ident::with_empty_ctxt(s);\n \n-        let use_path =\n-            nospan(ast::ViewPathSimple(reexport_ident,\n-                                       path_node(vec![mod_ident, Ident::from_str(\"main\")])));\n+        let use_path = ast::UseTree {\n+            span: DUMMY_SP,\n+            prefix: path_node(vec![mod_ident, Ident::from_str(\"main\")]),\n+            kind: ast::UseTreeKind::Simple(reexport_ident),\n+        };\n \n         expander.fold_item(P(ast::Item {\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "ac5642e53cf676c9e9c4957a218e725bc652cb5e", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -133,9 +133,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) {\n+    fn visit_use_tree(&mut self, use_tree: &UseTree, id: NodeId, _nested: bool) {\n         self.count += 1;\n-        walk_path_list_item(self, prefix, item)\n+        walk_use_tree(self, use_tree, id)\n     }\n     fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n         self.count += 1;"}, {"sha": "9a06ed0ba0297417719fea64e93d784ecac30d46", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -120,8 +120,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_path(&mut self, path: &'ast Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'ast Path, item: &'ast PathListItem) {\n-        walk_path_list_item(self, prefix, item)\n+    fn visit_use_tree(&mut self, use_tree: &'ast UseTree, id: NodeId, _nested: bool) {\n+        walk_use_tree(self, use_tree, id)\n     }\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n@@ -236,22 +236,8 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         ItemKind::ExternCrate(opt_name) => {\n             walk_opt_name(visitor, item.span, opt_name)\n         }\n-        ItemKind::Use(ref vp) => {\n-            match vp.node {\n-                ViewPathSimple(ident, ref path) => {\n-                    visitor.visit_ident(vp.span, ident);\n-                    visitor.visit_path(path, item.id);\n-                }\n-                ViewPathGlob(ref path) => {\n-                    visitor.visit_path(path, item.id);\n-                }\n-                ViewPathList(ref prefix, ref list) => {\n-                    visitor.visit_path(prefix, item.id);\n-                    for item in list {\n-                        visitor.visit_path_list_item(prefix, item)\n-                    }\n-                }\n-            }\n+        ItemKind::Use(ref use_tree) => {\n+            visitor.visit_use_tree(use_tree, item.id, false)\n         }\n         ItemKind::Static(ref typ, _, ref expr) |\n         ItemKind::Const(ref typ, ref expr) => {\n@@ -381,11 +367,22 @@ pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n     }\n }\n \n-pub fn walk_path_list_item<'a, V: Visitor<'a>>(visitor: &mut V,\n-                                               _prefix: &Path,\n-                                               item: &'a PathListItem) {\n-    visitor.visit_ident(item.span, item.node.name);\n-    walk_opt_ident(visitor, item.span, item.node.rename);\n+pub fn walk_use_tree<'a, V: Visitor<'a>>(\n+    visitor: &mut V, use_tree: &'a UseTree, id: NodeId,\n+) {\n+    visitor.visit_path(&use_tree.prefix, id);\n+\n+    match use_tree.kind {\n+        UseTreeKind::Simple(ident) => {\n+            visitor.visit_ident(use_tree.span, ident);\n+        }\n+        UseTreeKind::Glob => {},\n+        UseTreeKind::Nested(ref use_trees) => {\n+            for &(ref nested_tree, nested_id) in use_trees {\n+                visitor.visit_use_tree(nested_tree, nested_id, true);\n+            }\n+        }\n+    }\n }\n \n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,"}, {"sha": "8e5ba489c565ef5239a113f39a070d11cf32ab7c", "filename": "src/test/compile-fail/absolute-paths-in-nested-use-groups.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fcompile-fail%2Fabsolute-paths-in-nested-use-groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fcompile-fail%2Fabsolute-paths-in-nested-use-groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fabsolute-paths-in-nested-use-groups.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(use_nested_groups)]\n+#![allow(unused_imports)]\n+\n+mod foo {}\n+\n+use foo::{\n+    ::bar,       //~ ERROR crate root in paths can only be used in start position\n+    super::bar,  //~ ERROR `super` in paths can only be used in start position\n+    self::bar,   //~ ERROR `self` in paths can only be used in start position\n+};\n+\n+fn main() {}"}, {"sha": "56413a999d7f78e23894ed0d0fa9aa1665660b3a", "filename": "src/test/compile-fail/feature-gate-use_nested_groups.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-use_nested_groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-use_nested_groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-use_nested_groups.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports, dead_code)]\n+\n+mod a {\n+    pub enum B {}\n+    pub enum C {}\n+\n+    pub mod d {\n+        pub enum E {}\n+        pub enum F {}\n+\n+        pub mod g {\n+            pub enum H {}\n+        }\n+    }\n+}\n+\n+use a::{B, d::{*, g::H}};  //~ ERROR glob imports in `use` groups are experimental\n+                           //~^ ERROR nested groups in `use` are experimental\n+                           //~^^ ERROR paths in `use` groups are experimental\n+\n+fn main() {}"}, {"sha": "74a82afd462b869f1f793429ba3226957fdbdd10", "filename": "src/test/run-pass/use-nested-groups.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Frun-pass%2Fuse-nested-groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Frun-pass%2Fuse-nested-groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-nested-groups.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(use_nested_groups)]\n+\n+mod a {\n+    pub enum B {}\n+\n+    pub mod d {\n+        pub enum E {}\n+        pub enum F {}\n+\n+        pub mod g {\n+            pub enum H {}\n+            pub enum I {}\n+        }\n+    }\n+}\n+\n+use a::{B, d::{self, *, g::H}};\n+\n+fn main() {\n+    let _: B;\n+    let _: E;\n+    let _: F;\n+    let _: H;\n+    let _: d::g::I;\n+}"}, {"sha": "dc30c31835299628ccb4806fe4b048b50ed869b7", "filename": "src/test/ui/owl-import-generates-unused-import-lint.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fowl-import-generates-unused-import-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fowl-import-generates-unused-import-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fowl-import-generates-unused-import-lint.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(use_nested_groups)]\n+#![deny(unused_imports)]\n+\n+mod foo {\n+    pub enum Bar {}\n+}\n+\n+use foo::{*, *}; //~ ERROR unused import: `*`\n+\n+fn main() {\n+    let _: Bar;\n+}"}, {"sha": "79089b2a93c7340e5bda63c953be4e11905e137d", "filename": "src/test/ui/owl-import-generates-unused-import-lint.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fowl-import-generates-unused-import-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fowl-import-generates-unused-import-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fowl-import-generates-unused-import-lint.stderr?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -0,0 +1,14 @@\n+error: unused import: `*`\n+  --> $DIR/owl-import-generates-unused-import-lint.rs:18:14\n+   |\n+18 | use foo::{*, *}; //~ ERROR unused import: `*`\n+   |              ^\n+   |\n+note: lint level defined here\n+  --> $DIR/owl-import-generates-unused-import-lint.rs:12:9\n+   |\n+12 | #![deny(unused_imports)]\n+   |         ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "eb7eab9e42dd7a6a86dc802676b91c541152fb4b", "filename": "src/test/ui/similar-tokens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fsimilar-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fsimilar-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimilar-tokens.rs?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -14,6 +14,6 @@ mod x {\n }\n \n // `.` is similar to `,` so list parsing should continue to closing `}`\n-use x::{A. B}; //~ ERROR expected one of `,` or `as`, found `.`\n+use x::{A. B}; //~ ERROR expected one of `,`, `::`, or `as`, found `.`\n \n fn main() {}"}, {"sha": "b4968b1018ff4c72b500f20ba9f49e1aa83106aa", "filename": "src/test/ui/similar-tokens.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fsimilar-tokens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftest%2Fui%2Fsimilar-tokens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimilar-tokens.stderr?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `,` or `as`, found `.`\n+error: expected one of `,`, `::`, or `as`, found `.`\n   --> $DIR/similar-tokens.rs:17:10\n    |\n-17 | use x::{A. B}; //~ ERROR expected one of `,` or `as`, found `.`\n-   |          ^ expected one of `,` or `as` here\n+17 | use x::{A. B}; //~ ERROR expected one of `,`, `::`, or `as`, found `.`\n+   |          ^ expected one of `,`, `::`, or `as` here\n \n error: aborting due to previous error\n "}, {"sha": "3f0d13b585c401efe3d833c6474ae0d07bc47fee", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/804b15be82ea668d943fab70195eb57a2f942d4b/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=804b15be82ea668d943fab70195eb57a2f942d4b", "patch": "@@ -29,7 +29,7 @@ miri = \"Broken\"\n clippy = \"Testing\"\n \n # ping @nrc\n-rls = \"Testing\"\n+rls = \"Broken\"\n \n # ping @nrc\n-rustfmt = \"Testing\"\n+rustfmt = \"Broken\""}]}