{"sha": "23270ae8d39ae15020476f92ec9f4e05960f5de0", "node_id": "C_kwDOAAsO6NoAKDIzMjcwYWU4ZDM5YWUxNTAyMDQ3NmY5MmVjOWY0ZTA1OTYwZjVkZTA", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-11-03T04:09:00Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-11-21T23:38:10Z"}, "message": "Incrementally track which frame to use for diagnostics", "tree": {"sha": "d9e805c214720d42c5961d7dd2d4f08916807835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9e805c214720d42c5961d7dd2d4f08916807835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23270ae8d39ae15020476f92ec9f4e05960f5de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23270ae8d39ae15020476f92ec9f4e05960f5de0", "html_url": "https://github.com/rust-lang/rust/commit/23270ae8d39ae15020476f92ec9f4e05960f5de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23270ae8d39ae15020476f92ec9f4e05960f5de0/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "105dba79686f9e57ce48c07c736acd12f739ca58", "url": "https://api.github.com/repos/rust-lang/rust/commits/105dba79686f9e57ce48c07c736acd12f739ca58", "html_url": "https://github.com/rust-lang/rust/commit/105dba79686f9e57ce48c07c736acd12f739ca58"}], "stats": {"total": 308, "additions": 148, "deletions": 160}, "files": [{"sha": "96d988eb9a3bbdfaa8b04a64cfbd757a0c4bdf8b", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=23270ae8d39ae15020476f92ec9f4e05960f5de0", "patch": "@@ -118,6 +118,13 @@ pub struct Thread<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n \n+    /// The index of the topmost user-relevant frame in `stack`. This field must contain\n+    /// the value produced by `get_top_user_relevant_frame`.\n+    /// The `None` state here represents\n+    /// This field is a cache to reduce how often we call that method. The cache is manually\n+    /// maintained inside `MiriMachine::after_stack_push` and `MiriMachine::after_stack_pop`.\n+    top_user_relevant_frame: Option<usize>,\n+\n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n@@ -147,6 +154,38 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     fn thread_name(&self) -> &[u8] {\n         if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n     }\n+\n+    /// Return the top user-relevant frame, if there is one.\n+    /// Note that the choice to return `None` here when there is no user-relevant frame is part of\n+    /// justifying the optimization that only pushes of user-relevant frames require updating the\n+    /// `top_user_relevant_frame` field.\n+    fn compute_top_user_relevant_frame(&self) -> Option<usize> {\n+        self.stack\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(idx, frame)| if frame.extra.is_user_relevant { Some(idx) } else { None })\n+    }\n+\n+    /// Re-compute the top user-relevant frame from scratch.\n+    pub fn recompute_top_user_relevant_frame(&mut self) {\n+        self.top_user_relevant_frame = self.compute_top_user_relevant_frame();\n+    }\n+\n+    /// Set the top user-relevant frame to the given value. Must be equal to what\n+    /// `get_top_user_relevant_frame` would return!\n+    pub fn set_top_user_relevant_frame(&mut self, frame_idx: usize) {\n+        debug_assert_eq!(Some(frame_idx), self.compute_top_user_relevant_frame());\n+        self.top_user_relevant_frame = Some(frame_idx);\n+    }\n+\n+    pub fn top_user_relevant_frame(&self) -> usize {\n+        debug_assert_eq!(self.top_user_relevant_frame, self.compute_top_user_relevant_frame());\n+        // This can be called upon creation of an allocation. We create allocations while setting up\n+        // parts of the Rust runtime when we do not have any stack frames yet, so we need to handle\n+        // empty stacks.\n+        self.top_user_relevant_frame.unwrap_or_else(|| self.stack.len().saturating_sub(1))\n+    }\n }\n \n impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n@@ -167,6 +206,7 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n             state: ThreadState::Enabled,\n             thread_name: None,\n             stack: Vec::new(),\n+            top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n             panic_payload: None,\n             last_error: None,\n@@ -184,8 +224,15 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n \n impl VisitTags for Thread<'_, '_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let Thread { panic_payload, last_error, stack, state: _, thread_name: _, join_status: _ } =\n-            self;\n+        let Thread {\n+            panic_payload,\n+            last_error,\n+            stack,\n+            top_user_relevant_frame: _,\n+            state: _,\n+            thread_name: _,\n+            join_status: _,\n+        } = self;\n \n         panic_payload.visit_tags(visit);\n         last_error.visit_tags(visit);\n@@ -414,7 +461,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a shared borrow of the currently active thread.\n-    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+    pub fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n         &self.threads[self.active_thread]\n     }\n "}, {"sha": "958ed50496b1fdf03b032765abe5f002dc016d57", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 19, "deletions": 55, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=23270ae8d39ae15020476f92ec9f4e05960f5de0", "patch": "@@ -936,78 +936,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n-    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { current_frame_idx: None, machine: self }\n-    }\n-}\n-\n-/// A `CurrentSpan` should be created infrequently (ideally once) per interpreter step. It does\n-/// nothing on creation, but when `CurrentSpan::get` is called, searches the current stack for the\n-/// topmost frame which corresponds to a local crate, and returns the current span in that frame.\n-/// The result of that search is cached so that later calls are approximately free.\n-#[derive(Clone)]\n-pub struct CurrentSpan<'a, 'mir, 'tcx> {\n-    current_frame_idx: Option<usize>,\n-    machine: &'a MiriMachine<'mir, 'tcx>,\n-}\n-\n-impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n-    pub fn machine(&self) -> &'a MiriMachine<'mir, 'tcx> {\n-        self.machine\n-    }\n-\n-    /// Get the current span, skipping non-local frames.\n+    /// Get the current span in the topmost function which is workspace-local and not\n+    /// `#[track_caller]`.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n-    pub fn get(&mut self) -> Span {\n-        let idx = self.current_frame_idx();\n-        self.stack().get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+    pub fn current_span(&self) -> Span {\n+        self.stack()\n+            .get(self.top_user_relevant_frame())\n+            .map(Frame::current_span)\n+            .unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n     /// Returns the span of the *caller* of the current operation, again\n     /// walking down the stack to find the closest frame in a local crate, if the caller of the\n     /// current operation is not in a local crate.\n     /// This is useful when we are processing something which occurs on function-entry and we want\n     /// to point at the call to the function, not the function definition generally.\n-    pub fn get_caller(&mut self) -> Span {\n+    pub fn caller_span(&self) -> Span {\n         // We need to go down at least to the caller (len - 2), or however\n-        // far we have to go to find a frame in a local crate.\n-        let local_frame_idx = self.current_frame_idx();\n+        // far we have to go to find a frame in a local crate which is also not #[track_caller].\n+        let frame_idx = self.top_user_relevant_frame();\n         let stack = self.stack();\n-        let idx = cmp::min(local_frame_idx, stack.len().saturating_sub(2));\n-        stack.get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+        let frame_idx = cmp::min(frame_idx, stack.len().saturating_sub(2));\n+        stack.get(frame_idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n     fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameData<'tcx>>] {\n-        self.machine.threads.active_thread_stack()\n+        self.threads.active_thread_stack()\n     }\n \n-    fn current_frame_idx(&mut self) -> usize {\n-        *self\n-            .current_frame_idx\n-            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n+    fn top_user_relevant_frame(&self) -> usize {\n+        self.threads.active_thread_ref().top_user_relevant_frame()\n     }\n \n-    // Find the position of the inner-most frame which is part of the crate being\n-    // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n-    #[inline(never)]\n-    fn compute_current_frame_index(machine: &MiriMachine<'_, '_>) -> usize {\n-        machine\n-            .threads\n-            .active_thread_stack()\n-            .iter()\n-            .enumerate()\n-            .rev()\n-            .find_map(|(idx, frame)| {\n-                let def_id = frame.instance.def_id();\n-                if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n-                    && !frame.instance.def.requires_caller_location(machine.tcx)\n-                {\n-                    Some(idx)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(0)\n+    pub fn is_user_relevant(&self, frame: &Frame<'mir, 'tcx, Provenance>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        (def_id.is_local() || self.local_crates.contains(&def_id.krate))\n+            && !frame.instance.def.requires_caller_location(self.tcx)\n     }\n }\n "}, {"sha": "8913f8aa10fcdb962e927e93858cb5f6f21ae1b6", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=23270ae8d39ae15020476f92ec9f4e05960f5de0", "patch": "@@ -97,7 +97,7 @@ pub use crate::diagnostics::{\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n+pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,"}, {"sha": "f5fa8f5f09b46eeb385b77e5899eb51c79aaac17", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=23270ae8d39ae15020476f92ec9f4e05960f5de0", "patch": "@@ -50,12 +50,18 @@ pub struct FrameData<'tcx> {\n     /// for the start of this frame. When we finish executing this frame,\n     /// we use this to register a completed event with `measureme`.\n     pub timing: Option<measureme::DetachedTiming>,\n+\n+    /// Indicates whether a `Frame` is part of a workspace-local crate and is also not\n+    /// `#[track_caller]`. We compute this once on creation and store the result, as an\n+    /// optimization.\n+    /// This is used by `MiriMachine::current_span` and `MiriMachine::caller_span`\n+    pub is_user_relevant: bool,\n }\n \n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n+        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n             .field(\"stacked_borrows\", stacked_borrows)\n             .field(\"catch_unwind\", catch_unwind)\n@@ -65,7 +71,7 @@ impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n \n impl VisitTags for FrameData<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _ } = self;\n+        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n         stacked_borrows.visit_tags(visit);\n@@ -895,13 +901,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n         let alloc = alloc.into_owned();\n         let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                ecx.machine.current_span(),\n-            )\n+            Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind, &ecx.machine)\n         });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n@@ -1016,8 +1016,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -1048,8 +1047,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -1083,8 +1081,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 prove_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )\n         } else {\n             Ok(())\n@@ -1126,7 +1123,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n+            is_user_relevant: ecx.machine.is_user_relevant(&frame),\n         };\n+\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -1174,6 +1173,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.frame().extra.is_user_relevant {\n+            // We just pushed a local frame, so we know that the topmost local frame is the topmost\n+            // frame. If we push a non-local frame, there's no need to do anything.\n+            let stack_len = ecx.active_thread_stack().len();\n+            ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n+        }\n+\n         if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n@@ -1183,6 +1189,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n+        if frame.extra.is_user_relevant {\n+            // All that we store is whether or not the frame we just removed is local, so now we\n+            // have no idea where the next topmost local frame is. So we recompute it.\n+            ecx.active_thread_mut().recompute_top_user_relevant_frame();\n+        }\n         let timing = frame.extra.timing.take();\n         if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().end_call(&frame.extra);"}, {"sha": "662d8ada735eb92e792744b94f2834a6dc6f7620", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 52, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=23270ae8d39ae15020476f92ec9f4e05960f5de0", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use crate::helpers::CurrentSpan;\n use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind};\n use crate::*;\n \n@@ -110,42 +109,29 @@ pub struct TagHistory {\n     pub protected: Option<(String, SpanData)>,\n }\n \n-pub struct DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span cannot be merged with any other lifetime since they appear invariantly, under the\n-    // mutable ref.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n }\n \n-pub struct DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span and 'history cannot be merged, since when we call `unbuild` we need\n-    // to return the exact 'span that was used when calling `build`.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n     history: &'history mut AllocHistory,\n     offset: Size,\n }\n \n-impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+impl<'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     pub fn build<'history>(\n         self,\n         history: &'history mut AllocHistory,\n         offset: Size,\n-    ) -> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCx {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-            history,\n-            offset,\n-        }\n+    ) -> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+        DiagnosticCx { operation: self.operation, machine: self.machine, history, offset }\n     }\n \n     pub fn retag(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         cause: RetagCause,\n         new_tag: SbTag,\n         orig_tag: ProvenanceExtra,\n@@ -154,46 +140,36 @@ impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n         let operation =\n             Operation::Retag(RetagOp { cause, new_tag, orig_tag, range, permission: None });\n \n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn read(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Read, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn write(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Write, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n-    pub fn dealloc(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n-        tag: ProvenanceExtra,\n-    ) -> Self {\n+    pub fn dealloc(machine: &'ecx MiriMachine<'mir, 'tcx>, tag: ProvenanceExtra) -> Self {\n         let operation = Operation::Dealloc(DeallocOp { tag });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-    pub fn unbuild(self) -> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCxBuilder {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-        }\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+    pub fn unbuild(self) -> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+        DiagnosticCxBuilder { machine: self.machine, operation: self.operation }\n     }\n }\n \n@@ -234,18 +210,18 @@ struct DeallocOp {\n }\n \n impl AllocHistory {\n-    pub fn new(id: AllocId, item: Item, current_span: &mut CurrentSpan<'_, '_, '_>) -> Self {\n+    pub fn new(id: AllocId, item: Item, machine: &MiriMachine<'_, '_>) -> Self {\n         Self {\n             id,\n-            base: (item, current_span.get()),\n+            base: (item, machine.current_span()),\n             creations: SmallVec::new(),\n             invalidations: SmallVec::new(),\n             protectors: SmallVec::new(),\n         }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     pub fn start_grant(&mut self, perm: Permission) {\n         let Operation::Retag(op) = &mut self.operation else {\n             unreachable!(\"start_grant must only be called during a retag, this is: {:?}\", self.operation)\n@@ -274,15 +250,17 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"log_creation must only be called during a retag\")\n         };\n-        self.history.creations.push(Creation { retag: op.clone(), span: self.current_span.get() });\n+        self.history\n+            .creations\n+            .push(Creation { retag: op.clone(), span: self.machine.current_span() });\n     }\n \n     pub fn log_invalidation(&mut self, tag: SbTag) {\n-        let mut span = self.current_span.get();\n+        let mut span = self.machine.current_span();\n         let (range, cause) = match &self.operation {\n             Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n                 if *cause == RetagCause::FnEntry {\n-                    span = self.current_span.get_caller();\n+                    span = self.machine.caller_span();\n                 }\n                 (*range, InvalidationCause::Retag(permission.unwrap(), *cause))\n             }\n@@ -301,7 +279,9 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"Protectors can only be created during a retag\")\n         };\n-        self.history.protectors.push(Protection { tag: op.new_tag, span: self.current_span.get() });\n+        self.history\n+            .protectors\n+            .push(Protection { tag: op.new_tag, span: self.machine.current_span() });\n     }\n \n     pub fn get_logs_relevant_to(\n@@ -418,6 +398,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n             ProtectorKind::StrongProtector => \"strongly protected\",\n         };\n         let call_id = self\n+            .machine\n             .threads\n             .all_stacks()\n             .flatten()\n@@ -482,9 +463,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        self.current_span\n-            .machine()\n-            .emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.machine.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "e49b3e4f7246c2af2066e549f6d4d0b513e44ec5", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23270ae8d39ae15020476f92ec9f4e05960f5de0/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=23270ae8d39ae15020476f92ec9f4e05960f5de0", "patch": "@@ -340,7 +340,7 @@ impl<'tcx> Stack {\n     fn item_invalidated(\n         item: &Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         cause: ItemInvalidationCause,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n@@ -385,7 +385,7 @@ impl<'tcx> Stack {\n         access: AccessKind,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n@@ -471,7 +471,7 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make a write access.\n@@ -499,7 +499,7 @@ impl<'tcx> Stack {\n         derived_from: ProvenanceExtra,\n         new: Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n@@ -590,14 +590,14 @@ impl<'tcx> Stacks {\n         perm: Permission,\n         tag: SbTag,\n         id: AllocId,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n             stacks: RangeMap::new(size, stack),\n-            history: AllocHistory::new(id, item, current_span),\n+            history: AllocHistory::new(id, item, machine),\n             exposed_tags: FxHashSet::default(),\n             modified_since_last_gc: false,\n         }\n@@ -607,10 +607,10 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &mut self,\n         range: AllocRange,\n-        mut dcx_builder: DiagnosticCxBuilder<'_, '_, '_, 'tcx>,\n+        mut dcx_builder: DiagnosticCxBuilder<'_, '_, 'tcx>,\n         mut f: impl FnMut(\n             &mut Stack,\n-            &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+            &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -631,7 +631,7 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n-        mut current_span: CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -640,12 +640,11 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack =>\n-                (extra.base_ptr_tag(id, current_span.machine()), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_ptr_tag(id, machine), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, current_span.machine()), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n         };\n-        Stacks::new(size, perm, base_tag, id, &mut current_span)\n+        Stacks::new(size, perm, base_tag, id, machine)\n     }\n \n     #[inline(always)]\n@@ -655,8 +654,7 @@ impl Stacks {\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx>\n     where\n         'tcx: 'ecx,\n@@ -667,7 +665,7 @@ impl Stacks {\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::read(&mut current_span, threads, tag, range);\n+        let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n@@ -681,16 +679,15 @@ impl Stacks {\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::write(&mut current_span, threads, tag, range);\n+        let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n@@ -704,11 +701,10 @@ impl Stacks {\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let dcx = DiagnosticCxBuilder::dealloc(&mut current_span, threads, tag);\n+        let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n@@ -773,7 +769,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n-                    let current_span = &mut this.machine.current_span();\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -783,12 +778,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         .as_ref()\n                         .expect(\"we should have Stacked Borrows data\")\n                         .borrow_mut();\n-                    let threads = &this.machine.threads;\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        current_span,\n-                        threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n@@ -895,8 +888,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n-                // FIXME: can't share this with the current_span inside log_creation\n-                let mut current_span = this.machine.current_span();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -916,8 +907,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     let item = Item::new(new_tag, perm, protected);\n                     let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        &mut current_span, // FIXME avoid this `clone`\n-                        &this.machine.threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n@@ -943,11 +933,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n         let global = machine.stacked_borrows.as_ref().unwrap().borrow();\n-        // FIXME: can't share this with the current_span inside log_creation\n-        let current_span = &mut machine.current_span();\n         let dcx = DiagnosticCxBuilder::retag(\n-            current_span,\n-            &machine.threads,\n+            machine,\n             retag_cause,\n             new_tag,\n             orig_tag,"}]}