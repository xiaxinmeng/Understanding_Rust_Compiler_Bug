{"sha": "11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYTFmMTNjZDFjZjZkYTQ4NGZkNGI4YmZiNWY3MmE2MjVjMjE4NmE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-01T11:35:11Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-01T11:41:29Z"}, "message": "Being Ty::InferenceVar closes to chalk equivalent", "tree": {"sha": "d9923bbea2a75e02b599961790952e8a9a2edf2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9923bbea2a75e02b599961790952e8a9a2edf2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "html_url": "https://github.com/rust-lang/rust/commit/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e5c49619986144f6f0b1656bed2fac30b638a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5c49619986144f6f0b1656bed2fac30b638a26", "html_url": "https://github.com/rust-lang/rust/commit/4e5c49619986144f6f0b1656bed2fac30b638a26"}], "stats": {"total": 324, "additions": 172, "deletions": 152}, "files": [{"sha": "351ba75ffdd73d80a608d21a1ea40e5dfec3c3a3", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -33,7 +33,7 @@ use hir_ty::{\n     traits::{FnTrait, Solution, SolutionVariables},\n     BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n     InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n-    Ty, TyDefId, TyKind,\n+    Ty, TyDefId, TyVariableKind,\n };\n use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n@@ -1655,7 +1655,7 @@ impl Type {\n                 self.ty.environment.clone(),\n                 Obligation::Projection(predicate),\n             ),\n-            kinds: Arc::new([TyKind::General]),\n+            kinds: Arc::new([TyVariableKind::General]),\n         };\n \n         match db.trait_solve(self.krate, goal)? {"}, {"sha": "21d1e5446dd7c2b525e2b1cc6309999707b41046", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -89,8 +89,10 @@ fn deref_by_trait(\n \n     let in_env = InEnvironment { value: obligation, environment: ty.environment };\n \n-    let canonical =\n-        Canonical::new(in_env, ty.value.kinds.iter().copied().chain(Some(super::TyKind::General)));\n+    let canonical = Canonical::new(\n+        in_env,\n+        ty.value.kinds.iter().copied().chain(Some(chalk_ir::TyVariableKind::General)),\n+    );\n \n     let solution = db.trait_solve(krate, canonical)?;\n "}, {"sha": "ff8211094171df779ebbf09b5cfb16e101b2465a", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -565,7 +565,7 @@ impl HirDisplay for Ty {\n                 }\n                 write!(f, \"{{unknown}}\")?;\n             }\n-            Ty::Infer(..) => write!(f, \"_\")?,\n+            Ty::InferenceVar(..) => write!(f, \"_\")?,\n         }\n         Ok(())\n     }"}, {"sha": "1d78d1feb872942d21cfb68c4f76043de78e677f", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -36,12 +36,11 @@ use stdx::impl_from;\n use syntax::SmolStr;\n \n use super::{\n-    primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode, Scalar,\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n };\n \n pub(crate) use unify::unify;\n@@ -655,30 +654,17 @@ impl<'a> InferenceContext<'a> {\n /// two are used for inference of literal values (e.g. `100` could be one of\n /// several integer types).\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum InferTy {\n-    TypeVar(unify::TypeVarId),\n-    IntVar(unify::TypeVarId),\n-    FloatVar(unify::TypeVarId),\n-    MaybeNeverTypeVar(unify::TypeVarId),\n+pub struct InferenceVar {\n+    index: u32,\n }\n \n-impl InferTy {\n+impl InferenceVar {\n     fn to_inner(self) -> unify::TypeVarId {\n-        match self {\n-            InferTy::TypeVar(ty)\n-            | InferTy::IntVar(ty)\n-            | InferTy::FloatVar(ty)\n-            | InferTy::MaybeNeverTypeVar(ty) => ty,\n-        }\n+        unify::TypeVarId(self.index)\n     }\n \n-    fn fallback_value(self) -> Ty {\n-        match self {\n-            InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => Ty::Scalar(Scalar::Int(IntTy::I32)),\n-            InferTy::FloatVar(..) => Ty::Scalar(Scalar::Float(FloatTy::F64)),\n-            InferTy::MaybeNeverTypeVar(..) => Ty::Never,\n-        }\n+    fn from_inner(unify::TypeVarId(index): unify::TypeVarId) -> Self {\n+        InferenceVar { index }\n     }\n }\n "}, {"sha": "667b26a7646538870a4760d5259db895011271f8", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -4,12 +4,13 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n+use chalk_ir::TyVariableKind;\n use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n use test_utils::mark;\n \n use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty};\n \n-use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n+use super::{InEnvironment, InferenceContext};\n \n impl<'a> InferenceContext<'a> {\n     /// Unify two types, but may coerce the first one to the second one\n@@ -53,9 +54,8 @@ impl<'a> InferenceContext<'a> {\n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n-            (Ty::Never, Ty::Infer(InferTy::TypeVar(tv))) => {\n-                let var = self.table.new_maybe_never_type_var();\n-                self.table.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+            (Ty::Never, Ty::InferenceVar(tv, TyVariableKind::General)) => {\n+                self.table.type_variable_table.set_diverging(*tv, true);\n                 return true;\n             }\n             (Ty::Never, _) => return true,"}, {"sha": "928ad37a3dea6798aac9b7478f6981cd2b5c131e", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -3,6 +3,7 @@\n use std::iter::{repeat, repeat_with};\n use std::{mem, sync::Arc};\n \n+use chalk_ir::TyVariableKind;\n use hir_def::{\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     path::{GenericArg, GenericArgs},\n@@ -18,8 +19,8 @@ use crate::{\n     primitive::{self, UintTy},\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    Binders, CallableDefId, FnPointer, FnSig, InferTy, Mutability, Obligation, OpaqueTyId, Rawness,\n-    Scalar, Substs, TraitRef, Ty,\n+    Binders, CallableDefId, FnPointer, FnSig, Mutability, Obligation, OpaqueTyId, Rawness, Scalar,\n+    Substs, TraitRef, Ty,\n };\n \n use super::{\n@@ -527,8 +528,8 @@ impl<'a> InferenceContext<'a> {\n                             Ty::Scalar(Scalar::Int(_))\n                             | Ty::Scalar(Scalar::Uint(_))\n                             | Ty::Scalar(Scalar::Float(_))\n-                            | Ty::Infer(InferTy::IntVar(..))\n-                            | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n+                            | Ty::InferenceVar(_, TyVariableKind::Integer)\n+                            | Ty::InferenceVar(_, TyVariableKind::Float) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Neg trait\n                             _ => self\n                                 .resolve_associated_type(inner_ty, self.resolve_ops_neg_output()),\n@@ -540,7 +541,7 @@ impl<'a> InferenceContext<'a> {\n                             Ty::Scalar(Scalar::Bool)\n                             | Ty::Scalar(Scalar::Int(_))\n                             | Ty::Scalar(Scalar::Uint(_))\n-                            | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                            | Ty::InferenceVar(_, TyVariableKind::Integer) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Not trait\n                             _ => self\n                                 .resolve_associated_type(inner_ty, self.resolve_ops_not_output()),\n@@ -761,7 +762,7 @@ impl<'a> InferenceContext<'a> {\n             // `!`).\n             if self.diverges.is_always() {\n                 // we don't even make an attempt at coercion\n-                self.table.new_maybe_never_type_var()\n+                self.table.new_maybe_never_var()\n             } else {\n                 self.coerce(&Ty::unit(), expected.coercion_target());\n                 Ty::unit()"}, {"sha": "1e9a94c04a199c92d8ab8d3c66c3ba22c270e9e0", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 119, "deletions": 74, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -2,14 +2,15 @@\n \n use std::borrow::Cow;\n \n+use chalk_ir::{FloatTy, IntTy, TyVariableKind};\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use test_utils::mark;\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Scalar, Substs,\n-    Ty, TyKind, TypeWalk,\n+    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferenceVar, Scalar,\n+    Substs, Ty, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -26,7 +27,7 @@ where\n     'a: 'b,\n {\n     ctx: &'b mut InferenceContext<'a>,\n-    free_vars: Vec<InferTy>,\n+    free_vars: Vec<(InferenceVar, TyVariableKind)>,\n     /// A stack of type variables that is used to detect recursive types (which\n     /// are an error, but we need to protect against them to avoid stack\n     /// overflows).\n@@ -36,29 +37,26 @@ where\n #[derive(Debug)]\n pub(super) struct Canonicalized<T> {\n     pub(super) value: Canonical<T>,\n-    free_vars: Vec<InferTy>,\n+    free_vars: Vec<(InferenceVar, TyVariableKind)>,\n }\n \n-impl<'a, 'b> Canonicalizer<'a, 'b>\n-where\n-    'a: 'b,\n-{\n-    fn add(&mut self, free_var: InferTy) -> usize {\n-        self.free_vars.iter().position(|&v| v == free_var).unwrap_or_else(|| {\n+impl<'a, 'b> Canonicalizer<'a, 'b> {\n+    fn add(&mut self, free_var: InferenceVar, kind: TyVariableKind) -> usize {\n+        self.free_vars.iter().position(|&(v, _)| v == free_var).unwrap_or_else(|| {\n             let next_index = self.free_vars.len();\n-            self.free_vars.push(free_var);\n+            self.free_vars.push((free_var, kind));\n             next_index\n         })\n     }\n \n     fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: DebruijnIndex) -> T {\n         t.fold_binders(\n             &mut |ty, binders| match ty {\n-                Ty::Infer(tv) => {\n-                    let inner = tv.to_inner();\n+                Ty::InferenceVar(var, kind) => {\n+                    let inner = var.to_inner();\n                     if self.var_stack.contains(&inner) {\n                         // recursive type\n-                        return tv.fallback_value();\n+                        return self.ctx.table.type_variable_table.fallback_value(var, kind);\n                     }\n                     if let Some(known_ty) =\n                         self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n@@ -69,13 +67,7 @@ where\n                         result\n                     } else {\n                         let root = self.ctx.table.var_unification_table.find(inner);\n-                        let free_var = match tv {\n-                            InferTy::TypeVar(_) => InferTy::TypeVar(root),\n-                            InferTy::IntVar(_) => InferTy::IntVar(root),\n-                            InferTy::FloatVar(_) => InferTy::FloatVar(root),\n-                            InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n-                        };\n-                        let position = self.add(free_var);\n+                        let position = self.add(InferenceVar::from_inner(root), kind);\n                         Ty::Bound(BoundVar::new(binders, position))\n                     }\n                 }\n@@ -86,19 +78,7 @@ where\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n-        let kinds = self\n-            .free_vars\n-            .iter()\n-            .map(|v| match v {\n-                // mapping MaybeNeverTypeVar to the same kind as general ones\n-                // should be fine, because as opposed to int or float type vars,\n-                // they don't restrict what kind of type can go into them, they\n-                // just affect fallback.\n-                InferTy::TypeVar(_) | InferTy::MaybeNeverTypeVar(_) => TyKind::General,\n-                InferTy::IntVar(_) => TyKind::Integer,\n-                InferTy::FloatVar(_) => TyKind::Float,\n-            })\n-            .collect();\n+        let kinds = self.free_vars.iter().map(|&(_, k)| k).collect();\n         Canonicalized { value: Canonical { value: result, kinds }, free_vars: self.free_vars }\n     }\n \n@@ -132,7 +112,8 @@ impl<T> Canonicalized<T> {\n             &mut |ty, binders| {\n                 if let &mut Ty::Bound(bound) = ty {\n                     if bound.debruijn >= binders {\n-                        *ty = Ty::Infer(self.free_vars[bound.index]);\n+                        let (v, k) = self.free_vars[bound.index];\n+                        *ty = Ty::InferenceVar(v, k);\n                     }\n                 }\n             },\n@@ -152,18 +133,18 @@ impl<T> Canonicalized<T> {\n                 .kinds\n                 .iter()\n                 .map(|k| match k {\n-                    TyKind::General => ctx.table.new_type_var(),\n-                    TyKind::Integer => ctx.table.new_integer_var(),\n-                    TyKind::Float => ctx.table.new_float_var(),\n+                    TyVariableKind::General => ctx.table.new_type_var(),\n+                    TyVariableKind::Integer => ctx.table.new_integer_var(),\n+                    TyVariableKind::Float => ctx.table.new_float_var(),\n                 })\n                 .collect(),\n         );\n         for (i, ty) in solution.value.into_iter().enumerate() {\n-            let var = self.free_vars[i];\n+            let (v, k) = self.free_vars[i];\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n             let ty = ctx.normalize_associated_types_in(ty.clone().subst_bound_vars(&new_vars));\n-            ctx.table.unify(&Ty::Infer(var), &ty);\n+            ctx.table.unify(&Ty::InferenceVar(v, k), &ty);\n         }\n     }\n }\n@@ -197,32 +178,83 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n     )\n }\n \n+#[derive(Clone, Debug)]\n+pub(super) struct TypeVariableTable {\n+    inner: Vec<TypeVariableData>,\n+}\n+\n+impl TypeVariableTable {\n+    fn push(&mut self, data: TypeVariableData) {\n+        self.inner.push(data);\n+    }\n+\n+    pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n+        self.inner[iv.to_inner().0 as usize].diverging = diverging;\n+    }\n+\n+    fn is_diverging(&mut self, iv: InferenceVar) -> bool {\n+        self.inner[iv.to_inner().0 as usize].diverging\n+    }\n+\n+    fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n+        match kind {\n+            _ if self.inner[iv.to_inner().0 as usize].diverging => Ty::Never,\n+            TyVariableKind::General => Ty::Unknown,\n+            TyVariableKind::Integer => Ty::Scalar(Scalar::Int(IntTy::I32)),\n+            TyVariableKind::Float => Ty::Scalar(Scalar::Float(FloatTy::F64)),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct TypeVariableData {\n+    diverging: bool,\n+}\n+\n #[derive(Clone, Debug)]\n pub(crate) struct InferenceTable {\n     pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    pub(super) type_variable_table: TypeVariableTable,\n }\n \n impl InferenceTable {\n     pub(crate) fn new() -> Self {\n-        InferenceTable { var_unification_table: InPlaceUnificationTable::new() }\n+        InferenceTable {\n+            var_unification_table: InPlaceUnificationTable::new(),\n+            type_variable_table: TypeVariableTable { inner: Vec::new() },\n+        }\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+        self.type_variable_table.push(TypeVariableData { diverging: false });\n+        Ty::InferenceVar(\n+            InferenceVar::from_inner(self.var_unification_table.new_key(TypeVarValue::Unknown)),\n+            TyVariableKind::General,\n+        )\n     }\n \n     pub(crate) fn new_integer_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+        self.type_variable_table.push(TypeVariableData { diverging: false });\n+        Ty::InferenceVar(\n+            InferenceVar::from_inner(self.var_unification_table.new_key(TypeVarValue::Unknown)),\n+            TyVariableKind::Integer,\n+        )\n     }\n \n     pub(crate) fn new_float_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+        self.type_variable_table.push(TypeVariableData { diverging: false });\n+        Ty::InferenceVar(\n+            InferenceVar::from_inner(self.var_unification_table.new_key(TypeVarValue::Unknown)),\n+            TyVariableKind::Float,\n+        )\n     }\n \n-    pub(crate) fn new_maybe_never_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::MaybeNeverTypeVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n+    pub(crate) fn new_maybe_never_var(&mut self) -> Ty {\n+        self.type_variable_table.push(TypeVariableData { diverging: true });\n+        Ty::InferenceVar(\n+            InferenceVar::from_inner(self.var_unification_table.new_key(TypeVarValue::Unknown)),\n+            TyVariableKind::General,\n+        )\n     }\n \n     pub(crate) fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n@@ -283,33 +315,46 @@ impl InferenceTable {\n                 true\n             }\n \n-            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n-            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n+            (\n+                Ty::InferenceVar(tv1, TyVariableKind::General),\n+                Ty::InferenceVar(tv2, TyVariableKind::General),\n+            )\n             | (\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n-            ) => {\n+                Ty::InferenceVar(tv1, TyVariableKind::Integer),\n+                Ty::InferenceVar(tv2, TyVariableKind::Integer),\n+            )\n+            | (\n+                Ty::InferenceVar(tv1, TyVariableKind::Float),\n+                Ty::InferenceVar(tv2, TyVariableKind::Float),\n+            ) if self.type_variable_table.is_diverging(*tv1)\n+                == self.type_variable_table.is_diverging(*tv2) =>\n+            {\n                 // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(*tv1, *tv2);\n+                self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n                 true\n             }\n \n             // The order of MaybeNeverTypeVar matters here.\n             // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n             // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (Ty::Infer(InferTy::TypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ Ty::Scalar(Scalar::Int(_)))\n-            | (other @ Ty::Scalar(Scalar::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ Ty::Scalar(Scalar::Uint(_)))\n-            | (other @ Ty::Scalar(Scalar::Uint(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other @ Ty::Scalar(Scalar::Float(_)))\n-            | (other @ Ty::Scalar(Scalar::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n+            (Ty::InferenceVar(tv, TyVariableKind::General), other)\n+            | (other, Ty::InferenceVar(tv, TyVariableKind::General))\n+            | (Ty::InferenceVar(tv, TyVariableKind::Integer), other @ Ty::Scalar(Scalar::Int(_)))\n+            | (other @ Ty::Scalar(Scalar::Int(_)), Ty::InferenceVar(tv, TyVariableKind::Integer))\n+            | (\n+                Ty::InferenceVar(tv, TyVariableKind::Integer),\n+                other @ Ty::Scalar(Scalar::Uint(_)),\n+            )\n+            | (\n+                other @ Ty::Scalar(Scalar::Uint(_)),\n+                Ty::InferenceVar(tv, TyVariableKind::Integer),\n+            )\n+            | (Ty::InferenceVar(tv, TyVariableKind::Float), other @ Ty::Scalar(Scalar::Float(_)))\n+            | (other @ Ty::Scalar(Scalar::Float(_)), Ty::InferenceVar(tv, TyVariableKind::Float)) =>\n+            {\n                 // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n+                self.var_unification_table\n+                    .union_value(tv.to_inner(), TypeVarValue::Known(other.clone()));\n                 true\n             }\n \n@@ -354,7 +399,7 @@ impl InferenceTable {\n                 mark::hit!(type_var_resolves_to_int_var);\n             }\n             match &*ty {\n-                Ty::Infer(tv) => {\n+                Ty::InferenceVar(tv, _) => {\n                     let inner = tv.to_inner();\n                     match self.var_unification_table.inlined_probe_value(inner).known() {\n                         Some(known_ty) => {\n@@ -377,12 +422,12 @@ impl InferenceTable {\n     /// known type.\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n+            Ty::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n                     mark::hit!(type_var_cycles_resolve_as_possible);\n                     // recursive type\n-                    return tv.fallback_value();\n+                    return self.type_variable_table.fallback_value(tv, kind);\n                 }\n                 if let Some(known_ty) =\n                     self.var_unification_table.inlined_probe_value(inner).known()\n@@ -404,12 +449,12 @@ impl InferenceTable {\n     /// replaced by Ty::Unknown.\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n+            Ty::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n                     mark::hit!(type_var_cycles_resolve_completely);\n                     // recursive type\n-                    return tv.fallback_value();\n+                    return self.type_variable_table.fallback_value(tv, kind);\n                 }\n                 if let Some(known_ty) =\n                     self.var_unification_table.inlined_probe_value(inner).known()\n@@ -420,7 +465,7 @@ impl InferenceTable {\n                     tv_stack.pop();\n                     result\n                 } else {\n-                    tv.fallback_value()\n+                    self.type_variable_table.fallback_value(tv, kind)\n                 }\n             }\n             _ => ty,\n@@ -430,7 +475,7 @@ impl InferenceTable {\n \n /// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(pub(super) u32);\n+pub(super) struct TypeVarId(pub(super) u32);\n \n impl UnifyKey for TypeVarId {\n     type Value = TypeVarValue;\n@@ -451,7 +496,7 @@ impl UnifyKey for TypeVarId {\n /// The value of a type variable: either we already know the type, or we don't\n /// know it yet.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum TypeVarValue {\n+pub(super) enum TypeVarValue {\n     Known(Ty),\n     Unknown,\n }"}, {"sha": "762437bf422de6229a7cc205d184bcef424936a3", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -42,14 +42,14 @@ use crate::{\n };\n \n pub use autoderef::autoderef;\n-pub use infer::{InferTy, InferenceResult};\n+pub use infer::{InferenceResult, InferenceVar};\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, CallableDefId, ImplTraitLoweringMode,\n     TyDefId, TyLoweringContext, ValueTyDefId,\n };\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n-pub use chalk_ir::{BoundVar, DebruijnIndex, Scalar};\n+pub use chalk_ir::{BoundVar, DebruijnIndex, Scalar, TyVariableKind};\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Lifetime {\n@@ -218,7 +218,7 @@ pub enum Ty {\n     Bound(BoundVar),\n \n     /// A type variable used during type checking.\n-    Infer(InferTy),\n+    InferenceVar(InferenceVar, TyVariableKind),\n \n     /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n     ///\n@@ -527,22 +527,15 @@ impl TypeWalk for GenericPredicate {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Canonical<T> {\n     pub value: T,\n-    pub kinds: Arc<[TyKind]>,\n+    pub kinds: Arc<[chalk_ir::TyVariableKind]>,\n }\n \n impl<T> Canonical<T> {\n-    pub fn new(value: T, kinds: impl IntoIterator<Item = TyKind>) -> Self {\n+    pub fn new(value: T, kinds: impl IntoIterator<Item = chalk_ir::TyVariableKind>) -> Self {\n         Self { value, kinds: kinds.into_iter().collect() }\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum TyKind {\n-    General,\n-    Integer,\n-    Float,\n-}\n-\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "8b171787399cd0be73667c3194085254850177b8", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     primitive::{self, FloatTy, IntTy, UintTy},\n     utils::all_super_traits,\n     Canonical, DebruijnIndex, FnPointer, FnSig, InEnvironment, Scalar, Substs, TraitEnvironment,\n-    TraitRef, Ty, TyKind, TypeWalk,\n+    TraitRef, Ty, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -667,7 +667,7 @@ pub(crate) fn inherent_impl_substs(\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n     let mut kinds = self_ty.kinds.to_vec();\n-    kinds.extend(iter::repeat(TyKind::General).take(vars.len()));\n+    kinds.extend(iter::repeat(chalk_ir::TyVariableKind::General).take(vars.len()));\n     let tys = Canonical { kinds: kinds.into(), value: (self_ty_with_vars, self_ty.value.clone()) };\n     let substs = super::infer::unify(&tys);\n     // We only want the substs for the vars we added, not the ones from self_ty.\n@@ -759,7 +759,7 @@ fn generic_implements_goal(\n         .push(self_ty.value)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n-    kinds.extend(iter::repeat(TyKind::General).take(substs.len() - 1));\n+    kinds.extend(iter::repeat(chalk_ir::TyVariableKind::General).take(substs.len() - 1));\n     let trait_ref = TraitRef { trait_, substs };\n     let obligation = super::Obligation::Trait(trait_ref);\n     Canonical { kinds: kinds.into(), value: InEnvironment::new(env, obligation) }"}, {"sha": "bb9b8bbfcd89c942f7f872f2dfe9eebccd2ff04b", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -1,7 +1,8 @@\n //! Helper functions for binary operator type inference.\n+use chalk_ir::TyVariableKind;\n use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n \n-use crate::{InferTy, Scalar, Ty};\n+use crate::{Scalar, Ty};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n     match op {\n@@ -11,14 +12,16 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n             Ty::Scalar(Scalar::Int(_))\n             | Ty::Scalar(Scalar::Uint(_))\n             | Ty::Scalar(Scalar::Float(_)) => lhs_ty,\n-            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n+            Ty::InferenceVar(_, TyVariableKind::Integer)\n+            | Ty::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::ArithOp(_) => match rhs_ty {\n             Ty::Scalar(Scalar::Int(_))\n             | Ty::Scalar(Scalar::Uint(_))\n             | Ty::Scalar(Scalar::Float(_)) => rhs_ty,\n-            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n+            Ty::InferenceVar(_, TyVariableKind::Integer)\n+            | Ty::InferenceVar(_, TyVariableKind::Float) => rhs_ty,\n             _ => Ty::Unknown,\n         },\n     }\n@@ -30,7 +33,8 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         BinaryOp::Assignment { op: None } => lhs_ty,\n         BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n             Ty::Scalar(_) | Ty::Str => lhs_ty,\n-            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n+            Ty::InferenceVar(_, TyVariableKind::Integer)\n+            | Ty::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => Ty::Unknown,\n@@ -40,7 +44,8 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n             Ty::Scalar(Scalar::Int(_))\n             | Ty::Scalar(Scalar::Uint(_))\n             | Ty::Scalar(Scalar::Float(_)) => lhs_ty,\n-            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n+            Ty::InferenceVar(_, TyVariableKind::Integer)\n+            | Ty::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n     }"}, {"sha": "995ff6a9a7e5f5a5f01271aa504e7329c34c2570", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=11a1f13cd1cf6da484fd4b8bfb5f72a625c2186a", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     primitive::UintTy,\n     traits::{Canonical, Obligation},\n     CallableDefId, FnPointer, FnSig, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n-    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty, TyKind,\n+    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty,\n };\n \n use super::interner::*;\n@@ -107,7 +107,7 @@ impl ToChalk for Ty {\n                 .to_ty::<Interner>(&Interner)\n             }\n             Ty::Bound(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n-            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n+            Ty::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n             Ty::Dyn(predicates) => {\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n                     &Interner,\n@@ -532,20 +532,12 @@ where\n     type Chalk = chalk_ir::Canonical<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n-        let kinds = self\n-            .kinds\n-            .iter()\n-            .map(|k| match k {\n-                TyKind::General => chalk_ir::TyVariableKind::General,\n-                TyKind::Integer => chalk_ir::TyVariableKind::Integer,\n-                TyKind::Float => chalk_ir::TyVariableKind::Float,\n-            })\n-            .map(|tk| {\n-                chalk_ir::CanonicalVarKind::new(\n-                    chalk_ir::VariableKind::Ty(tk),\n-                    chalk_ir::UniverseIndex::ROOT,\n-                )\n-            });\n+        let kinds = self.kinds.iter().map(|&tk| {\n+            chalk_ir::CanonicalVarKind::new(\n+                chalk_ir::VariableKind::Ty(tk),\n+                chalk_ir::UniverseIndex::ROOT,\n+            )\n+        });\n         let value = self.value.to_chalk(db);\n         chalk_ir::Canonical {\n             value,\n@@ -558,17 +550,13 @@ where\n             .binders\n             .iter(&Interner)\n             .map(|k| match k.kind {\n-                chalk_ir::VariableKind::Ty(tk) => match tk {\n-                    chalk_ir::TyVariableKind::General => TyKind::General,\n-                    chalk_ir::TyVariableKind::Integer => TyKind::Integer,\n-                    chalk_ir::TyVariableKind::Float => TyKind::Float,\n-                },\n+                chalk_ir::VariableKind::Ty(tk) => tk,\n                 // HACK: Chalk can sometimes return new lifetime variables. We\n                 // want to just skip them, but to not mess up the indices of\n                 // other variables, we'll just create a new type variable in\n                 // their place instead. This should not matter (we never see the\n                 // actual *uses* of the lifetime variable).\n-                chalk_ir::VariableKind::Lifetime => TyKind::General,\n+                chalk_ir::VariableKind::Lifetime => chalk_ir::TyVariableKind::General,\n                 chalk_ir::VariableKind::Const(_) => panic!(\"unexpected const from Chalk\"),\n             })\n             .collect();"}]}