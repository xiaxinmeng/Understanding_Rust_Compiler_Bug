{"sha": "57ede5f281a406986d4167bbca137d09e6a7f565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZWRlNWYyODFhNDA2OTg2ZDQxNjdiYmNhMTM3ZDA5ZTZhN2Y1NjU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-16T03:47:38Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-16T06:22:12Z"}, "message": "Added non_ty_var precondition to trans::type_of_inner\n\nThis allows us to legitimately call unreachable() in the ty_var case.", "tree": {"sha": "bbc2917032c6875a07a4eaa95440bf02dea13dce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbc2917032c6875a07a4eaa95440bf02dea13dce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57ede5f281a406986d4167bbca137d09e6a7f565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57ede5f281a406986d4167bbca137d09e6a7f565", "html_url": "https://github.com/rust-lang/rust/commit/57ede5f281a406986d4167bbca137d09e6a7f565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57ede5f281a406986d4167bbca137d09e6a7f565/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce1877dc8ed18847024c2b199263554686f3d150", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce1877dc8ed18847024c2b199263554686f3d150", "html_url": "https://github.com/rust-lang/rust/commit/ce1877dc8ed18847024c2b199263554686f3d150"}], "stats": {"total": 166, "additions": 109, "deletions": 57}, "files": [{"sha": "4a1e7c4cd425559243aecf1484edd24e653e7d8f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 93, "deletions": 51, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/57ede5f281a406986d4167bbca137d09e6a7f565/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ede5f281a406986d4167bbca137d09e6a7f565/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=57ede5f281a406986d4167bbca137d09e6a7f565", "patch": "@@ -48,13 +48,20 @@ import tvec = trans_vec;\n \n fn type_of(cx: @crate_ctxt, sp: span, t: ty::t) : type_has_static_size(cx, t)\n    -> TypeRef {\n+    // Should follow from type_has_static_size -- argh.\n+    // FIXME\n+    check non_ty_var(cx, t);\n     type_of_inner(cx, sp, t)\n }\n \n fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n    [TypeRef] {\n     let atys = [];\n-    for arg in inputs { atys += [T_ptr(type_of_inner(cx, sp, arg.ty))]; }\n+    for arg in inputs {\n+        let arg_ty = arg.ty;\n+        check non_ty_var(cx, arg_ty);\n+        atys += [T_ptr(type_of_inner(cx, sp, arg_ty))];\n+    }\n     ret atys;\n }\n \n@@ -71,6 +78,7 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n+    check non_ty_var(cx, output);\n     let out_ty = T_ptr(type_of_inner(cx, sp, output));\n     atys += [ret_ref ? T_ptr(out_ty) : out_ty];\n \n@@ -91,7 +99,13 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n         // If it's an iter, the 'output' type of the iter is actually the\n         // *input* type of the function we're given as our iter-block\n         // argument.\n-        atys += [type_of_inner(cx, sp, ty::mk_iter_body_fn(cx.tcx, output))];\n+        let iter_body_ty = ty::mk_iter_body_fn(cx.tcx, output);\n+        // FIXME: this check could be avoided pretty easily if we had\n+        // postconditions\n+        // (or better yet, just use a constraiend type that expresses\n+        // non-ty-var things)\n+        check non_ty_var(cx, iter_body_ty);\n+        atys += [type_of_inner(cx, sp, iter_body_ty)];\n     }\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, sp, inputs);\n@@ -102,9 +116,12 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n                       ty_param_count: uint) -> TypeRef {\n     let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(cx.tcx, fty));\n+    // FIXME: constraint?\n+    let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n+    check non_ty_var(cx, ret_ty);\n     ret type_of_fn(cx, sp, ty::ty_fn_proto(cx.tcx, fty),\n                    false, by_ref, ty::ty_fn_args(cx.tcx, fty),\n-                   ty::ty_fn_ret(cx.tcx, fty), ty_param_count);\n+                   ret_ty, ty_param_count);\n }\n \n fn type_of_native_fn(cx: @crate_ctxt, sp: span, abi: ast::native_abi,\n@@ -117,83 +134,97 @@ fn type_of_native_fn(cx: @crate_ctxt, sp: span, abi: ast::native_abi,\n         while i < ty_param_count { atys += [T_ptr(cx.tydesc_type)]; i += 1u; }\n     }\n     atys += type_of_explicit_args(cx, sp, inputs);\n+    check non_ty_var(cx, output);\n     ret T_fn(atys, type_of_inner(cx, sp, output));\n }\n \n-/* FIXME: could add type_has_static_size as a constraint,\n-   allowing us to get rid of some impossible cases. */\n-fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t) -> TypeRef {\n+fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n+    : non_ty_var(cx, t) -> TypeRef {\n     // Check the cache.\n \n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n-    let llty: TypeRef = 0 as TypeRef;\n+    let llty =\n     alt ty::struct(cx.tcx, t) {\n-      ty::ty_native(_) { llty = T_ptr(T_i8()); }\n-      ty::ty_nil. { llty = T_nil(); }\n+      ty::ty_native(_) { T_ptr(T_i8()) }\n+      ty::ty_nil. { T_nil() }\n       ty::ty_bot. {\n-        llty = T_nil(); /* ...I guess? */\n-\n+        T_nil() /* ...I guess? */\n       }\n-      ty::ty_bool. { llty = T_bool(); }\n-      ty::ty_int. { llty = T_int(); }\n-      ty::ty_float. { llty = T_float(); }\n-      ty::ty_uint. { llty = T_int(); }\n+      ty::ty_bool. { T_bool() }\n+      ty::ty_int. { T_int() }\n+      ty::ty_float. { T_float() }\n+      ty::ty_uint. { T_int() }\n       ty::ty_machine(tm) {\n         alt tm {\n-          ast::ty_i8. { llty = T_i8(); }\n-          ast::ty_u8. { llty = T_i8(); }\n-          ast::ty_i16. { llty = T_i16(); }\n-          ast::ty_u16. { llty = T_i16(); }\n-          ast::ty_i32. { llty = T_i32(); }\n-          ast::ty_u32. { llty = T_i32(); }\n-          ast::ty_i64. { llty = T_i64(); }\n-          ast::ty_u64. { llty = T_i64(); }\n-          ast::ty_f32. { llty = T_f32(); }\n-          ast::ty_f64. { llty = T_f64(); }\n+          ast::ty_i8. | ast::ty_u8. { T_i8() }\n+          ast::ty_i16. | ast::ty_u16. { T_i16() }\n+          ast::ty_i32. | ast::ty_u32. { T_i32() }\n+          ast::ty_i64. | ast::ty_u64. { T_i64() }\n+          ast::ty_f32. { T_f32() }\n+          ast::ty_f64. { T_f64() }\n         }\n       }\n-      ty::ty_char. { llty = T_char(); }\n-      ty::ty_str. { llty = T_ptr(T_vec(T_i8())); }\n-      ty::ty_tag(did, _) { llty = type_of_tag(cx, sp, did, t); }\n-      ty::ty_box(mt) { llty = T_ptr(T_box(type_of_inner(cx, sp, mt.ty))); }\n-      ty::ty_uniq(t) { llty = T_ptr(type_of_inner(cx, sp, t)); }\n+      ty::ty_char. { T_char() }\n+      ty::ty_str. { T_ptr(T_vec(T_i8())) }\n+      ty::ty_tag(did, _) { type_of_tag(cx, sp, did, t) }\n+      ty::ty_box(mt) {\n+        let mt_ty = mt.ty;\n+        check non_ty_var(cx, mt_ty);\n+        T_ptr(T_box(type_of_inner(cx, sp, mt_ty))) }\n+      ty::ty_uniq(t) {\n+        check non_ty_var(cx, t);\n+        T_ptr(type_of_inner(cx, sp, t)) }\n       ty::ty_vec(mt) {\n-        if ty::type_has_dynamic_size(cx.tcx, mt.ty) {\n-            llty = T_ptr(T_opaque_vec());\n-        } else { llty = T_ptr(T_vec(type_of_inner(cx, sp, mt.ty))); }\n-      }\n-      ty::ty_ptr(mt) { llty = T_ptr(type_of_inner(cx, sp, mt.ty)); }\n+        let mt_ty = mt.ty;\n+        if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n+            T_ptr(T_opaque_vec())\n+        } else {\n+            // should be unnecessary\n+            check non_ty_var(cx, mt_ty);\n+            T_ptr(T_vec(type_of_inner(cx, sp, mt_ty))) }\n+      }\n+      ty::ty_ptr(mt) {\n+        let mt_ty = mt.ty;\n+        check non_ty_var(cx, mt_ty);\n+        T_ptr(type_of_inner(cx, sp, mt_ty)) }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = [];\n         for f: ty::field in fields {\n-            tys += [type_of_inner(cx, sp, f.mt.ty)];\n+            let mt_ty = f.mt.ty;\n+            check non_ty_var(cx, mt_ty);\n+            tys += [type_of_inner(cx, sp, mt_ty)];\n         }\n-        llty = T_struct(tys);\n+        T_struct(tys)\n       }\n       ty::ty_fn(_, _, _, _, _) {\n-        llty = T_fn_pair(*cx, type_of_fn_from_ty(cx, sp, t, 0u));\n+        T_fn_pair(*cx, type_of_fn_from_ty(cx, sp, t, 0u))\n       }\n       ty::ty_native_fn(abi, args, out) {\n         let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n-        llty = T_fn_pair(*cx, nft);\n+        T_fn_pair(*cx, nft)\n       }\n-      ty::ty_obj(meths) { llty = cx.rust_object_type; }\n+      ty::ty_obj(meths) { cx.rust_object_type }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n+        check non_ty_var(cx, sub1);\n         ret T_struct([T_i32(), type_of_inner(cx, sp, sub1)]);\n       }\n       ty::ty_var(_) {\n+        // FIXME should be a constraint that makes this impossible\n+        // (use unreachable())\n         cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n       }\n-      ty::ty_param(_, _) { llty = T_typaram(cx.tn); }\n-      ty::ty_type. { llty = T_ptr(cx.tydesc_type); }\n+      ty::ty_param(_, _) { T_typaram(cx.tn) }\n+      ty::ty_type. { T_ptr(cx.tydesc_type) }\n       ty::ty_tup(elts) {\n         let tys = [];\n-        for elt in elts { tys += [type_of_inner(cx, sp, elt)]; }\n-        llty = T_struct(tys);\n+        for elt in elts {\n+            check non_ty_var(cx, elt);\n+            tys += [type_of_inner(cx, sp, elt)];\n+        }\n+        T_struct(tys)\n       }\n-    }\n-    assert (llty as int != 0);\n+    };\n     cx.lltypes.insert(t, llty);\n     ret llty;\n }\n@@ -1131,6 +1162,7 @@ fn declare_generic_glue(cx: @local_ctxt, t: ty::t, llfnty: TypeRef, name: str)\n     ret llfn;\n }\n \n+// FIXME: was this causing the leak?\n fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n@@ -3296,8 +3328,10 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // The 'llretptr' that will arrive in the thunk we're creating also needs\n     // to be the correct type.  Cast it to f's return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    if ty::type_contains_params(cx.ccx.tcx, outgoing_ret_ty) {\n-        let llretty = type_of_inner(cx.ccx, sp, outgoing_ret_ty);\n+    let ccx = cx.ccx;\n+    if ty::type_contains_params(ccx.tcx, outgoing_ret_ty) {\n+        check non_ty_var(ccx, outgoing_ret_ty);\n+        let llretty = type_of_inner(ccx, sp, outgoing_ret_ty);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n@@ -3573,6 +3607,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n+        check non_ty_var(ccx, retty);\n         let llretty = T_ptr(type_of_inner(ccx, bcx.sp, retty));\n         if by_ref { llretty = T_ptr(llretty); }\n         llargs += [PointerCast(cx, llretslot, llretty)];\n@@ -3594,6 +3629,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n         let lli =\n             if ty::type_contains_params(tcx, retty) {\n                 let body_ty = ty::mk_iter_body_fn(tcx, retty);\n+                check non_ty_var(ccx, body_ty);\n                 let body_llty = type_of_inner(ccx, cx.sp, body_ty);\n                 PointerCast(bcx, lli, T_ptr(body_llty))\n             } else { lli };\n@@ -3884,7 +3920,7 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n }\n \n fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n-    ret trans_expr_out(cx, e, return);\n+    trans_expr_out(cx, e, return)\n }\n \n fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n@@ -4531,7 +4567,7 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t) -> result {\n         // let llalign = align_of(llsz.bcx, t);\n         bcx = call_bzero(llsz.bcx, llptr, llsz.val, C_int(0)).bcx;\n     }\n-    ret rslt(bcx, llptr);\n+    rslt(bcx, llptr)\n }\n \n fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> result {\n@@ -5372,6 +5408,7 @@ fn decl_fn_and_pair_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n       ty::ty_fn(proto, inputs, output, rs, _) {\n+        check non_ty_var(ccx, output);\n         llfty = type_of_fn(ccx, sp, proto, false,\n                            ast_util::ret_by_ref(rs), inputs, output,\n                            vec::len(ty_params));\n@@ -5412,8 +5449,12 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let vecarg_ty: ty::arg =\n             {mode: ast::by_ref,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n+        // FIXME: mk_nil should have a post condition\n+        let nt = ty::mk_nil(ccx.tcx);\n+        check non_ty_var(ccx, nt);\n+\n         let llfty = type_of_fn(ccx, sp, ast::proto_fn, false, false,\n-                               [vecarg_ty], ty::mk_nil(ccx.tcx), 0u);\n+                               [vecarg_ty], nt, 0u);\n         let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n \n         let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n@@ -5514,6 +5555,7 @@ fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(abi, args, out) {\n+        check non_ty_var(cx, out);\n         ret type_of_fn(cx, sp, ast::proto_fn, false, false, args, out,\n                        ty_param_count);\n       }"}, {"sha": "4f6dbfaa5f9a937795d22b662293d3151d1a2c1f", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57ede5f281a406986d4167bbca137d09e6a7f565/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ede5f281a406986d4167bbca137d09e6a7f565/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=57ede5f281a406986d4167bbca137d09e6a7f565", "patch": "@@ -627,8 +627,11 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // creating also needs to be the correct type.  Cast it to the method's\n     // return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n-        let llretty = type_of_inner(cx.ccx, sp, m.output);\n+    let ccx = cx.ccx;\n+    if ty::type_contains_params(ccx.tcx, m.output) {\n+        let m_output = m.output;\n+        check non_ty_var(ccx, m_output);\n+        let llretty = type_of_inner(ccx, sp, m_output);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n@@ -732,8 +735,11 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // creating also needs to be the correct type.  Cast it to the method's\n     // return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n-        let llretty = type_of_inner(cx.ccx, sp, m.output);\n+    let ccx = cx.ccx;\n+    if ty::type_contains_params(ccx.tcx, m.output) {\n+        let m_output = m.output;\n+        check non_ty_var(ccx, m_output);\n+        let llretty = type_of_inner(ccx, sp, m_output);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n@@ -881,7 +887,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let llfnty = T_nil();\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n       ty::ty_fn(proto, inputs, output, rs, _) {\n-        llfnty = type_of_fn(cx.ccx, m.span, proto, true,\n+        let ccx = cx.ccx;\n+        check non_ty_var(ccx, output);\n+        llfnty = type_of_fn(ccx, m.span, proto, true,\n                             ast_util::ret_by_ref(rs), inputs, output,\n                             vec::len(ty_params));\n       }\n@@ -933,8 +941,10 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n \n fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n+    let out_ty = m.output;\n+    check non_ty_var(ccx, out_ty);\n     type_of_fn(ccx, sp, m.proto, true, ast_util::ret_by_ref(m.cf),\n-               m.inputs, m.output, vec::len(tps))\n+               m.inputs, out_ty, vec::len(tps))\n }\n \n //"}]}