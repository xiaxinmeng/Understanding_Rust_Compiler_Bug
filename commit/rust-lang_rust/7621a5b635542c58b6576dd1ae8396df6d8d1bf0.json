{"sha": "7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MjFhNWI2MzU1NDJjNThiNjU3NmRkMWFlODM5NmRmNmQ4ZDFiZjA=", "commit": {"author": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-07-29T21:15:31Z"}, "committer": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-07-29T21:15:31Z"}, "message": "Refactor DocFS to fix error handling bugs", "tree": {"sha": "66f92ba08e73a422efa06e44c6ca6b513d023351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66f92ba08e73a422efa06e44c6ca6b513d023351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEtei29J14PIgXYsIlGom1QEO7zL0FAl8h5vMACgkQGom1QEO7\nzL2NiQf/chdU0iF4TxYkLCTBR19ddtB6kT/EGPP4pxvBwZfmY/MrYON+ScWAs+Dt\nnPJ7w5BKmeXBoOehQm3PM736MGgFlX6Qpnosyn98h8YVZVTcJVuoDKP7X8hH9OgJ\nDkzp9xrAFmu3eorVL2rv3fKRXuzXHO8esDIG7n9gJTHMz+NVjx0hSr+2ecJ5pJ6c\nqCe0dTtGX5wj2FZDDSwlFG+DxjlDJcfc1ndzxhEr8rPL41Vi+T7jzFHcfFYQsEut\ncOEKbWK9nddk5oz2tmaeQaNSgH6HVMFBAGioa67t862Ej7KGP2mrhVtvKSyMtpKE\nF51kOkm4b6l/lLOK02l5LSDaHZMRIw==\n=o7bM\n-----END PGP SIGNATURE-----", "payload": "tree 66f92ba08e73a422efa06e44c6ca6b513d023351\nparent cee8023c690158daf4f6c3d8bf2d32297fdfed0c\nauthor Joseph Ryan <josephryan3.14@gmail.com> 1596057331 -0500\ncommitter Joseph Ryan <josephryan3.14@gmail.com> 1596057331 -0500\n\nRefactor DocFS to fix error handling bugs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "html_url": "https://github.com/rust-lang/rust/commit/7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/comments", "author": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "html_url": "https://github.com/rust-lang/rust/commit/cee8023c690158daf4f6c3d8bf2d32297fdfed0c"}], "stats": {"total": 89, "additions": 34, "deletions": 55}, "files": [{"sha": "119059aa4a0f833cde550c965aa6c4c04bb81269", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 16, "deletions": 45, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "patch": "@@ -13,8 +13,7 @@ use std::fs;\n use std::io;\n use std::path::Path;\n use std::string::ToString;\n-use std::sync::mpsc::{channel, Receiver, Sender};\n-use std::sync::Arc;\n+use std::sync::mpsc::Sender;\n \n macro_rules! try_err {\n     ($e:expr, $file:expr) => {\n@@ -31,47 +30,24 @@ pub trait PathError {\n         S: ToString + Sized;\n }\n \n-pub struct ErrorStorage {\n-    sender: Option<Sender<Option<String>>>,\n-    receiver: Receiver<Option<String>>,\n-}\n-\n-impl ErrorStorage {\n-    pub fn new() -> ErrorStorage {\n-        let (sender, receiver) = channel();\n-        ErrorStorage { sender: Some(sender), receiver }\n-    }\n-\n-    /// Prints all stored errors. Returns the number of printed errors.\n-    pub fn write_errors(&mut self, diag: &rustc_errors::Handler) -> usize {\n-        let mut printed = 0;\n-        // In order to drop the sender part of the channel.\n-        self.sender = None;\n-\n-        for msg in self.receiver.iter() {\n-            if let Some(ref error) = msg {\n-                diag.struct_err(&error).emit();\n-                printed += 1;\n-            }\n-        }\n-        printed\n-    }\n-}\n-\n pub struct DocFS {\n     sync_only: bool,\n-    errors: Arc<ErrorStorage>,\n+    errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    pub fn new(errors: &Arc<ErrorStorage>) -> DocFS {\n-        DocFS { sync_only: false, errors: Arc::clone(errors) }\n+    pub fn new(errors: &Sender<String>) -> DocFS {\n+        DocFS { sync_only: false, errors: Some(errors.clone()) }\n     }\n \n     pub fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n+    pub fn close(&mut self) {\n+        self.errors = None;\n+    }\n+\n     pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n@@ -88,20 +64,15 @@ impl DocFS {\n         if !self.sync_only && cfg!(windows) {\n             // A possible future enhancement after more detailed profiling would\n             // be to create the file sync so errors are reported eagerly.\n-            let contents = contents.as_ref().to_vec();\n             let path = path.as_ref().to_path_buf();\n-            let sender = self.errors.sender.clone().unwrap();\n-            rayon::spawn(move || match fs::write(&path, &contents) {\n-                Ok(_) => {\n-                    sender.send(None).unwrap_or_else(|_| {\n-                        panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n-                    });\n-                }\n-                Err(e) => {\n-                    sender.send(Some(format!(\"\\\"{}\\\": {}\", path.display(), e))).unwrap_or_else(\n-                        |_| panic!(\"failed to send non-error on \\\"{}\\\"\", path.display()),\n-                    );\n-                }\n+            let contents = contents.as_ref().to_vec();\n+            let sender = self.errors.clone().expect(\"can't write after closing\");\n+            rayon::spawn(move || {\n+                fs::write(&path, contents).unwrap_or_else(|e| {\n+                    sender\n+                        .send(format!(\"\\\"{}\\\": {}\", path.display(), e))\n+                        .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                });\n             });\n             Ok(())\n         } else {"}, {"sha": "715b5e647649fcf85287d5c31a596cd8f2b79074", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "patch": "@@ -44,6 +44,7 @@ use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n use std::string::ToString;\n+use std::sync::mpsc::{channel, Receiver};\n use std::sync::Arc;\n \n use itertools::Itertools;\n@@ -65,7 +66,7 @@ use serde::{Serialize, Serializer};\n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n use crate::config::RenderInfo;\n use crate::config::RenderOptions;\n-use crate::docfs::{DocFS, ErrorStorage, PathError};\n+use crate::docfs::{DocFS, PathError};\n use crate::doctree;\n use crate::error::Error;\n use crate::formats::cache::{cache, Cache};\n@@ -113,7 +114,9 @@ crate struct Context {\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n     all: Rc<RefCell<AllTypes>>,\n-    pub errors: Arc<ErrorStorage>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    pub errors: Rc<Receiver<String>>,\n }\n \n crate struct SharedContext {\n@@ -403,7 +406,6 @@ impl FormatRenderer for Context {\n             },\n             _ => PathBuf::new(),\n         };\n-        let errors = Arc::new(ErrorStorage::new());\n         // If user passed in `--playground-url` arg, we fill in crate name here\n         let mut playground = None;\n         if let Some(url) = playground_url {\n@@ -447,6 +449,7 @@ impl FormatRenderer for Context {\n                 }\n             }\n         }\n+        let (sender, receiver) = channel();\n         let mut scx = SharedContext {\n             collapsed: krate.collapsed,\n             src_root,\n@@ -459,7 +462,7 @@ impl FormatRenderer for Context {\n             style_files,\n             resource_suffix,\n             static_root_path,\n-            fs: DocFS::new(&errors),\n+            fs: DocFS::new(&sender),\n             edition,\n             codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n             playground,\n@@ -493,7 +496,7 @@ impl FormatRenderer for Context {\n             id_map: Rc::new(RefCell::new(id_map)),\n             shared: Arc::new(scx),\n             all: Rc::new(RefCell::new(AllTypes::new())),\n-            errors,\n+            errors: Rc::new(receiver),\n         };\n \n         CURRENT_DEPTH.with(|s| s.set(0));\n@@ -506,8 +509,8 @@ impl FormatRenderer for Context {\n     }\n \n     fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error> {\n-        let nb_errors =\n-            Arc::get_mut(&mut self.errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n+        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n+        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n         if nb_errors > 0 {\n             Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n         } else {"}, {"sha": "65bc089faf42816dc9dbd9ba9cb5505c9e10fbce", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7621a5b635542c58b6576dd1ae8396df6d8d1bf0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7621a5b635542c58b6576dd1ae8396df6d8d1bf0", "patch": "@@ -507,9 +507,14 @@ fn main_options(options: config::Options) -> i32 {\n         ) {\n             Ok(_) => rustc_driver::EXIT_SUCCESS,\n             Err(e) => {\n-                diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error))\n-                    .note(&format!(\"failed to create or modify \\\"{}\\\"\", e.file.display()))\n-                    .emit();\n+                let mut msg =\n+                    diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n+                let file = e.file.display().to_string();\n+                if file.is_empty() {\n+                    msg.emit()\n+                } else {\n+                    msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file)).emit()\n+                }\n                 rustc_driver::EXIT_FAILURE\n             }\n         }"}]}