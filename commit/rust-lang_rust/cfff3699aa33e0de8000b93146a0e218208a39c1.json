{"sha": "cfff3699aa33e0de8000b93146a0e218208a39c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZmYzNjk5YWEzM2UwZGU4MDAwYjkzMTQ2YTBlMjE4MjA4YTM5YzE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-05-03T01:21:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-03T01:21:18Z"}, "message": "Rollup merge of #41625 - nikomatsakis:incr-comp-dep-tracking-cell-mir, r=eddyb\n\nrework the queries for the MIR pipeline\n\nThis PR refashions the MIR pipeline. There are a number of changes:\n\n* We no longer have \"MIR passes\" and the pass manager is completely reworked. Unless we are doing the interprocedural optimization (meaning, right now, the inline pass), we will process a single MIR from beginning to finish in a completely on-demand fashion; i.e., when you request `optimized_mir(D)`, that will trigger the MIR for `D` to actually be built and optimized, but no other functions are built or touched.\n* We no longer use `&'tcx RefCell<Mir<'tcx>>` as the result of queries, since that spoils the view of queries as \"pure functions\". To avoid however copying the MIR, we use a `&'tcx Steal<Mir<'tcx>>` -- this is something like a ref-cell, in that you can use `borrow()` to read it, but it has no `borrow_mut()`. Instead, it has `steal()`, which will take the contents and then panic if any further read attempt occurs.\n* We now support `[multi]` queries, which can optionally yield not just one result but a sequence of (K, V) pairs. This is used for the inlining pass. If inlining is enabled, then when it is invoked on **any** def-id D, it will go and read the results for **all** def-ids and transform them, and then return the results for all of them at once. This isn't ideal, and we'll probably want to rework this further, but it seems ok for now (note that MIR inlining is not enabled by default).\n\n**Tips for the reviewer:** The commits here are meant to build individually, but the path is a *bit* meandering. In some cases, for example, I introduce a trait in one commit, and then tweak it in a later commit as I actually try to put it to use. You may want to read the README in the final commit to get a sense of where the overall design is headed.\n\n@eddyb I did not wind up adding support for queries that produce more than one *kind* of result. Instead, I decided to just insert judicious use of the `force()` command. In other words, we had talked about e.g. having a query that produced not only the MIR but also the `const_qualif` result for the MIR in one sweep. I realized you can also have the same effect by having a kind of meta-query that forces the const-qualif pass and then reads the result. See the README for a description. (We can still do these \"multi-query results\" later if we want, I'm not sure though if it is necessary.)\n\nr? @eddyb\n\ncc @michaelwoerister @matthewhammer @arielb1, who participated in the IRC discussion.", "tree": {"sha": "1296691ebf441d063b300d7b022c8078e9932dfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1296691ebf441d063b300d7b022c8078e9932dfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfff3699aa33e0de8000b93146a0e218208a39c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfff3699aa33e0de8000b93146a0e218208a39c1", "html_url": "https://github.com/rust-lang/rust/commit/cfff3699aa33e0de8000b93146a0e218208a39c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfff3699aa33e0de8000b93146a0e218208a39c1/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "html_url": "https://github.com/rust-lang/rust/commit/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda"}, {"sha": "488b2a3e7b9d8a4c96f388dc7d8fdd2023ecc815", "url": "https://api.github.com/repos/rust-lang/rust/commits/488b2a3e7b9d8a4c96f388dc7d8fdd2023ecc815", "html_url": "https://github.com/rust-lang/rust/commit/488b2a3e7b9d8a4c96f388dc7d8fdd2023ecc815"}], "stats": {"total": 2541, "additions": 1263, "deletions": 1278}, "files": [{"sha": "66505d9a06b59306f1f4e5da94d0c9ad6b7aa02c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -76,6 +76,7 @@ pub enum DepNode<D: Clone + Debug> {\n     BorrowCheck(D),\n     RvalueCheck(D),\n     Reachability,\n+    MirKeys,\n     LateLintCheck,\n     TransCrateItem(D),\n     TransInlinedItem(D),\n@@ -202,6 +203,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             Variance => Some(Variance),\n             PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n             Reachability => Some(Reachability),\n+            MirKeys => Some(MirKeys),\n             LateLintCheck => Some(LateLintCheck),\n             TransWriteMetadata => Some(TransWriteMetadata),\n "}, {"sha": "6cb86a30400a772806fdcb546ad65b32871deff6", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -28,6 +28,5 @@ pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::visit::visit_all_bodies_in_krate;\n pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "59dce6f6bb0975a83f35090a27ac576ef1fccc60", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -50,6 +50,12 @@ impl<A, B> DepGraphSafe for (A, B)\n {\n }\n \n+/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a A\n+    where A: DepGraphSafe,\n+{\n+}\n+\n /// No data here! :)\n impl DepGraphSafe for () {\n }"}, {"sha": "bf3748659fe07f0e4f4e84e8bb7ccb7782a85eb0", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -75,15 +75,3 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     krate.visit_all_item_likes(&mut tracking_visitor)\n }\n \n-pub fn visit_all_bodies_in_krate<'a, 'tcx, C>(tcx: TyCtxt<'a, 'tcx, 'tcx>, callback: C)\n-    where C: Fn(/* body_owner */\n-                DefId,\n-                /* body id */\n-                hir::BodyId)\n-{\n-    let krate = tcx.hir.krate();\n-    for &body_id in &krate.body_ids {\n-        let body_owner_def_id = tcx.hir.body_owner_def_id(body_id);\n-        callback(body_owner_def_id, body_id);\n-    }\n-}"}, {"sha": "abc967dec905c23459cfc9fc567679316d5467af", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -455,7 +455,7 @@ impl<'hir> Map<'hir> {\n                 if let EntryExpr(_, expr) = entry {\n                     BodyId { node_id: expr.id }\n                 } else {\n-                    span_bug!(self.span(id), \"id `{}` has no associated body\", id);\n+                    span_bug!(self.span(id), \"id `{}` has no associated body: {:?}\", id, entry);\n                 }\n             }\n         } else {"}, {"sha": "d3954326e7b721c28586f0c001bbc82d3e703a6c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -43,6 +43,9 @@\n #![feature(unboxed_closures)]\n #![feature(discriminant_value)]\n #![feature(sort_unstable)]\n+#![feature(trace_macros)]\n+\n+#![recursion_limit=\"128\"]\n \n extern crate arena;\n extern crate core;"}, {"sha": "e8ed8bf104cc8892fd60416a4fe752abff12ea48", "filename": "src/librustc/mir/README.md", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -0,0 +1,90 @@\n+# MIR definition and pass system\n+\n+This file contains the definition of the MIR datatypes along with the\n+various types for the \"MIR Pass\" system, which lets you easily\n+register and define new MIR transformations and analyses.\n+\n+Most of the code that operates on MIR can be found in the\n+`librustc_mir` crate or other crates. The code found here in\n+`librustc` is just the datatype definitions, alonging the functions\n+which operate on MIR to be placed everywhere else.\n+\n+## MIR Data Types and visitor\n+\n+The main MIR data type is `rustc::mir::Mir`, defined in `mod.rs`.\n+There is also the MIR visitor (in `visit.rs`) which allows you to walk\n+the MIR and override what actions will be taken at various points (you\n+can visit in either shared or mutable mode; the latter allows changing\n+the MIR in place). Finally `traverse.rs` contains various traversal\n+routines for visiting the MIR CFG in [different standard orders][traversal]\n+(e.g. pre-order, reverse post-order, and so forth).\n+\n+[traversal]: https://en.wikipedia.org/wiki/Tree_traversal\n+\n+## MIR pass suites and their integration into the query system\n+\n+As a MIR *consumer*, you are expected to use one of the queries that\n+returns a \"final MIR\". As of the time of this writing, there is only\n+one: `optimized_mir(def_id)`, but more are expected to come in the\n+future. For foreign def-ids, we simply read the MIR from the other\n+crate's metadata. But for local query, this query will construct the\n+MIR and then iteratively optimize it by putting it through various\n+pipeline stages. This section describes those pipeline stages and how\n+you can extend them.\n+\n+To produce the `optimized_mir(D)` for a given def-id `D`, the MIR\n+passes through several suites of optimizations, each represented by a\n+query. Each suite consists of multiple optimizations and\n+transformations. These suites represent useful intermediate points\n+where we want to access the MIR for type checking or other purposes:\n+\n+- `mir_build(D)` -- not a query, but this constructs the initial MIR\n+- `mir_const(D)` -- applies some simple transformations to make MIR ready for constant evaluation;\n+- `mir_validated(D)` -- applies some more transformations, making MIR ready for borrow checking;\n+- `optimized_mir(D)` -- the final state, after all optimizations have been performed.\n+\n+### Stealing\n+\n+The intermediate queries `mir_const()` and `mir_validated()` yield up\n+a `&'tcx Steal<Mir<'tcx>>`, allocated using\n+`tcx.alloc_steal_mir()`. This indicates that the result may be\n+**stolen** by the next suite of optimizations -- this is an\n+optimization to avoid cloning the MIR. Attempting to use a stolen\n+result will cause a panic in the compiler. Therefore, it is important\n+that you not read directly from these intermediate queries except as\n+part of the MIR processing pipeline.\n+\n+Because of this stealing mechanism, some care must also be taken to\n+ensure that, before the MIR at a particular phase in the processing\n+pipeline is stolen, anyone who may want to read from it has already\n+done so. Concretely, this means that if you have some query `foo(D)`\n+that wants to access the result of `mir_const(D)` or\n+`mir_validated(D)`, you need to have the successor pass either \"force\"\n+`foo(D)` using `ty::queries::foo::force(...)`. This will force a query\n+to execute even though you don't directly require its result.\n+\n+As an example, consider MIR const qualification. It wants to read the\n+result produced by the `mir_const()` suite. However, that result will\n+be **stolen** by the `mir_validated()` suite. If nothing was done,\n+then `mir_const_qualif(D)` would succeed if it came before\n+`mir_validated(D)`, but fail otherwise. Therefore, `mir_validated(D)`\n+will **force** `mir_const_qualif` before it actually steals, thus\n+ensuring that the reads have already happened:\n+\n+```\n+mir_const(D) --read-by--> mir_const_qualif(D)\n+     |                       ^\n+  stolen-by                  |\n+     |                    (forces)\n+     v                       |\n+mir_validated(D) ------------+\n+```\n+\n+### Implementing and registering a pass\n+\n+To create a new MIR pass, you simply implement the `MirPass` trait for\n+some fresh singleton type `Foo`. Once you have implemented a trait for\n+your type `Foo`, you then have to insert `Foo` into one of the suites;\n+this is done in `librustc_driver/driver.rs` by invoking `push_pass(S,\n+Foo)` with the appropriate suite substituted for `S`.\n+"}, {"sha": "b517ebabbe767622e9b4ab7e1b1e099a328bf3f1", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! MIR datatypes and passes. See [the README](README.md) for details.\n+\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};"}, {"sha": "aa91123ef6952ac044781b2aac0369725292fd5e", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 90, "deletions": 97, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n+//! See [the README](README.md) for details on writing your own pass.\n+\n use hir;\n+use hir::def_id::DefId;\n use hir::map::DefPathData;\n use mir::{Mir, Promoted};\n use ty::TyCtxt;\n+use std::rc::Rc;\n use syntax::ast::NodeId;\n-use util::common::time;\n \n use std::borrow::Cow;\n-use std::fmt;\n \n /// Where a specific Mir comes from.\n #[derive(Debug, Copy, Clone)]\n@@ -36,6 +37,11 @@ pub enum MirSource {\n }\n \n impl<'a, 'tcx> MirSource {\n+    pub fn from_local_def_id(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> MirSource {\n+        let id = tcx.hir.as_local_node_id(def_id).expect(\"mir source requires local def-id\");\n+        Self::from_node(tcx, id)\n+    }\n+\n     pub fn from_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId) -> MirSource {\n         use hir::*;\n \n@@ -70,124 +76,111 @@ impl<'a, 'tcx> MirSource {\n     }\n }\n \n-/// Various information about pass.\n-pub trait Pass {\n-    // fn should_run(Session) to check if pass should run?\n-    fn name<'a>(&self) -> Cow<'static, str> {\n-        let name = unsafe { ::std::intrinsics::type_name::<Self>() };\n-        if let Some(tail) = name.rfind(\":\") {\n-            Cow::from(&name[tail+1..])\n-        } else {\n-            Cow::from(name)\n-        }\n+/// Generates a default name for the pass based on the name of the\n+/// type `T`.\n+pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n+    let name = unsafe { ::std::intrinsics::type_name::<T>() };\n+    if let Some(tail) = name.rfind(\":\") {\n+        Cow::from(&name[tail+1..])\n+    } else {\n+        Cow::from(name)\n     }\n-    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> { None }\n }\n \n-/// A pass which inspects the whole Mir map.\n-pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        hooks: &mut [Box<for<'s> MirPassHook<'s>>]);\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct MirSuite(pub usize);\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct MirPassIndex(pub usize);\n+\n+/// A pass hook is invoked both before and after each pass executes.\n+/// This is primarily used to dump MIR for debugging.\n+///\n+/// You can tell whether this is before or after by inspecting the\n+/// `mir` parameter -- before the pass executes, it will be `None` (in\n+/// which case you can inspect the MIR from previous pass by executing\n+/// `mir_cx.read_previous_mir()`); after the pass executes, it will be\n+/// `Some()` with the result of the pass (in which case the output\n+/// from the previous pass is most likely stolen, so you would not\n+/// want to try and access it). If the pass is interprocedural, then\n+/// the hook will be invoked once per output.\n+pub trait PassHook {\n+    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 suite: MirSuite,\n+                                 pass_num: MirPassIndex,\n+                                 pass_name: &str,\n+                                 source: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 is_after: bool);\n }\n \n-pub trait MirPassHook<'tcx>: Pass {\n-    fn on_mir_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        src: MirSource,\n-        mir: &Mir<'tcx>,\n-        pass: &Pass,\n-        is_after: bool\n-    );\n-}\n-\n-/// A pass which inspects Mir of functions in isolation.\n-pub trait MirPass<'tcx>: Pass {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>);\n-}\n-\n-impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n-    {\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-        for def_id in def_ids {\n-            if !def_id.is_local() {\n-                continue;\n-            }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, false);\n-            }\n-            MirPass::run_pass(self, tcx, src, mir);\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, true);\n-            }\n+/// The full suite of types that identifies a particular\n+/// application of a pass to a def-id.\n+pub type PassId = (MirSuite, MirPassIndex, DefId);\n \n-            for (i, mir) in mir.promoted.iter_enumerated_mut() {\n-                let src = MirSource::Promoted(id, i);\n-                for hook in &mut *hooks {\n-                    hook.on_mir_pass(tcx, src, mir, self, false);\n-                }\n-                MirPass::run_pass(self, tcx, src, mir);\n-                for hook in &mut *hooks {\n-                    hook.on_mir_pass(tcx, src, mir, self, true);\n-                }\n-            }\n-        }\n+/// A streamlined trait that you can implement to create a pass; the\n+/// pass will be named after the type, and it will consist of a main\n+/// loop that goes over each available MIR and applies `run_pass`.\n+pub trait MirPass {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        default_name::<Self>()\n     }\n+\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>);\n }\n \n /// A manager for MIR passes.\n+///\n+/// FIXME(#41712) -- it is unclear whether we should have this struct.\n+#[derive(Clone)]\n pub struct Passes {\n-    passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>,\n-    pass_hooks: Vec<Box<for<'tcx> MirPassHook<'tcx>>>,\n-    plugin_passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>\n+    pass_hooks: Vec<Rc<PassHook>>,\n+    suites: Vec<Vec<Rc<MirPass>>>,\n }\n \n+/// The number of \"pass suites\" that we have:\n+///\n+/// - ready for constant evaluation\n+/// - unopt\n+/// - optimized\n+pub const MIR_SUITES: usize = 3;\n+\n+/// Run the passes we need to do constant qualification and evaluation.\n+pub const MIR_CONST: MirSuite = MirSuite(0);\n+\n+/// Run the passes we need to consider the MIR validated and ready for borrowck etc.\n+pub const MIR_VALIDATED: MirSuite = MirSuite(1);\n+\n+/// Run the passes we need to consider the MIR *optimized*.\n+pub const MIR_OPTIMIZED: MirSuite = MirSuite(2);\n+\n impl<'a, 'tcx> Passes {\n     pub fn new() -> Passes {\n-        let passes = Passes {\n-            passes: Vec::new(),\n+        Passes {\n             pass_hooks: Vec::new(),\n-            plugin_passes: Vec::new()\n-        };\n-        passes\n-    }\n-\n-    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        let Passes { ref mut passes, ref mut plugin_passes, ref mut pass_hooks } = *self;\n-        for pass in plugin_passes.iter_mut().chain(passes.iter_mut()) {\n-            time(tcx.sess.time_passes(), &*pass.name(),\n-                 || pass.run_pass(tcx, pass_hooks));\n+            suites: (0..MIR_SUITES).map(|_| Vec::new()).collect(),\n         }\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass(&mut self, pass: Box<for<'b> MirMapPass<'b>>) {\n-        self.passes.push(pass);\n+    pub fn push_pass<T: MirPass + 'static>(&mut self, suite: MirSuite, pass: T) {\n+        self.suites[suite.0].push(Rc::new(pass));\n     }\n \n     /// Pushes a pass hook.\n-    pub fn push_hook(&mut self, hook: Box<for<'b> MirPassHook<'b>>) {\n-        self.pass_hooks.push(hook);\n+    pub fn push_hook<T: PassHook + 'static>(&mut self, hook: T) {\n+        self.pass_hooks.push(Rc::new(hook));\n+    }\n+\n+    pub fn passes(&self, suite: MirSuite) -> &[Rc<MirPass>] {\n+        &self.suites[suite.0]\n     }\n-}\n \n-/// Copies the plugin passes.\n-impl ::std::iter::Extend<Box<for<'a> MirMapPass<'a>>> for Passes {\n-    fn extend<I: IntoIterator<Item=Box<for <'a> MirMapPass<'a>>>>(&mut self, it: I) {\n-        self.plugin_passes.extend(it);\n+    pub fn hooks(&self) -> &[Rc<PassHook>] {\n+        &self.pass_hooks\n     }\n }"}, {"sha": "fdfcd83d5b43545bf67c1026a2b1ff1aaa4e5f54", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -1003,6 +1003,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n+    dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n+          \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "ec3eaa124c3078a253f804317843f0451aa16dda", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -21,7 +21,6 @@ use session::config::DebugInfoLevel;\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::duration_to_secs_str;\n-use mir::transform as mir_pass;\n \n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n@@ -85,7 +84,6 @@ pub struct Session {\n     /// redundantly verbose output (Issue #24690).\n     pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Span, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n-    pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n@@ -670,7 +668,6 @@ pub fn build_session_(sopts: config::Options,\n         lints: RefCell::new(lint::LintTable::new()),\n         one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n-        mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),"}, {"sha": "08807d0ced01e62de14fba310dda0a7612e738a6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -25,6 +25,7 @@ use middle::region::{CodeExtent, CodeExtentData};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n+use mir::transform::Passes;\n use ty::subst::{Kind, Substs};\n use ty::ReprOptions;\n use traits;\n@@ -39,6 +40,7 @@ use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n+use ty::steal::Steal;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -47,11 +49,12 @@ use arena::{TypedArena, DroplessArena};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n+use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n use std::iter;\n-use std::cmp::Ordering;\n+use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -68,7 +71,8 @@ pub struct GlobalArenas<'tcx> {\n     generics: TypedArena<ty::Generics>,\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n-    mir: TypedArena<RefCell<Mir<'tcx>>>,\n+    steal_mir: TypedArena<Steal<Mir<'tcx>>>,\n+    mir: TypedArena<Mir<'tcx>>,\n     tables: TypedArena<ty::TypeckTables<'tcx>>,\n }\n \n@@ -79,6 +83,7 @@ impl<'tcx> GlobalArenas<'tcx> {\n             generics: TypedArena::new(),\n             trait_def: TypedArena::new(),\n             adt_def: TypedArena::new(),\n+            steal_mir: TypedArena::new(),\n             mir: TypedArena::new(),\n             tables: TypedArena::new(),\n         }\n@@ -443,8 +448,11 @@ pub struct GlobalCtxt<'tcx> {\n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n     pub hir: hir_map::Map<'tcx>,\n+\n     pub maps: maps::Maps<'tcx>,\n \n+    pub mir_passes: Rc<Passes>,\n+\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n@@ -619,8 +627,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.generics.alloc(generics)\n     }\n \n-    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx RefCell<Mir<'gcx>> {\n-        self.global_arenas.mir.alloc(RefCell::new(mir))\n+    pub fn alloc_steal_mir(self, mir: Mir<'gcx>) -> &'gcx Steal<Mir<'gcx>> {\n+        self.global_arenas.steal_mir.alloc(Steal::new(mir))\n+    }\n+\n+    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx Mir<'gcx> {\n+        self.global_arenas.mir.alloc(mir)\n     }\n \n     pub fn alloc_tables(self, tables: ty::TypeckTables<'gcx>) -> &'gcx ty::TypeckTables<'gcx> {\n@@ -714,6 +726,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   local_providers: ty::maps::Providers<'tcx>,\n                                   extern_providers: ty::maps::Providers<'tcx>,\n+                                  mir_passes: Rc<Passes>,\n                                   arenas: &'tcx GlobalArenas<'tcx>,\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n@@ -748,6 +761,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n             maps: maps::Maps::new(dep_graph, providers),\n+            mir_passes,\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             rcache: RefCell::new(FxHashMap()),"}, {"sha": "385abbd039e08eb97d5eb22865d1480bc270f6e6", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 191, "deletions": 25, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -16,22 +16,26 @@ use middle::const_val;\n use middle::privacy::AccessLevels;\n use middle::region::RegionMaps;\n use mir;\n+use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::item_path;\n+use ty::steal::Steal;\n use ty::subst::Substs;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{DefIdSet, NodeSet};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::symbol::Symbol;\n \n-trait Key {\n+pub trait Key: Clone + Hash + Eq + Debug {\n     fn map_crate(&self) -> CrateNum;\n     fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n@@ -101,6 +105,24 @@ impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n     }\n }\n \n+impl Key for (MirSuite, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirSuite, MirPassIndex, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.2.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.2.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -270,8 +292,13 @@ impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n \n impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n     fn describe(tcx: TyCtxt, (def_id, _): (DefId, &'tcx Substs<'tcx>)) -> String {\n-        format!(\"const-evaluating `{}`\",\n-                tcx.item_path_str(def_id))\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"getting a list of all mir_keys\")\n     }\n }\n \n@@ -306,7 +333,7 @@ impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'t\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_item_mir_available<'tcx> {\n+impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking if item is mir available: `{}`\",\n             tcx.item_path_str(def_id))\n@@ -316,11 +343,10 @@ impl<'tcx> QueryDescription for queries::is_item_mir_available<'tcx> {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       [$($pub:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n-        pub struct Maps<$tcx> {\n-            providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])* $($pub)* $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n+       [$($modifiers:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n         impl<$tcx> Maps<$tcx> {\n@@ -400,7 +426,7 @@ macro_rules! define_maps {\n                     provider(tcx.global_tcx(), key)\n                 })?;\n \n-                Ok(f(&tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n+                Ok(f(tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n@@ -461,25 +487,153 @@ macro_rules! define_maps {\n             })*\n         }\n \n-        pub struct Providers<$tcx> {\n-            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $V),*\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n+            output: ()\n         }\n \n         impl<$tcx> Copy for Providers<$tcx> {}\n         impl<$tcx> Clone for Providers<$tcx> {\n             fn clone(&self) -> Self { *self }\n         }\n+    }\n+}\n+\n+macro_rules! define_map_struct {\n+    // Initial state\n+    (tcx: $tcx:tt,\n+     input: $input:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final output\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($($output:tt)*)) => {\n+        pub struct Maps<$tcx> {\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n+            $($output)*\n+        }\n+    };\n+\n+    // Field recognized and ready to shift into the output\n+    (tcx: $tcx:tt,\n+     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)*\n+                     $(#[$attr])* $($pub)* $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>,)\n+        }\n+    };\n+\n+    // Detect things with the `pub` modifier\n+    (tcx: $tcx:tt,\n+     input: (([pub $($other_modifiers:tt)*] $attrs:tt $name:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            ready: ([pub] $attrs $name),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // No modifiers left? This is a private item.\n+    (tcx: $tcx:tt,\n+     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            ready: ([pub] $attrs $name),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip other modifiers\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n+}\n+\n+macro_rules! define_provider_struct {\n+    // Initial state:\n+    (tcx: $tcx:tt, input: $input:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final state:\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n+        pub struct Providers<$tcx> {\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+        }\n \n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $V {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n                     bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n                 Providers { $($name),* }\n             }\n         }\n-    }\n+    };\n+\n+    // Something ready to shift:\n+    (tcx: $tcx:tt,\n+     ready: ($name:tt $K:tt $V:tt),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)* ($name $K $V))\n+        }\n+    };\n+\n+    // Regular queries produce a `V` only.\n+    (tcx: $tcx:tt,\n+     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            ready: ($name $K $V),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip modifiers.\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n }\n \n // Each of these maps also corresponds to a method on a\n@@ -537,20 +691,28 @@ define_maps! { <'tcx>\n     /// Methods in these implementations don't need to be exported.\n     [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n-    /// Maps from the def-id of a function/method or const/static\n-    /// to its MIR. Mutation is done at an item granularity to\n-    /// allow MIR optimization passes to function and still\n-    /// access cross-crate MIR (e.g. inlining or const eval).\n-    ///\n-    /// Note that cross-crate MIR appears to be always borrowed\n-    /// (in the `RefCell` sense) to prevent accidental mutation.\n-    [pub] mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    /// Set of all the def-ids in this crate that have MIR associated with\n+    /// them. This includes all the body owners, but also things like struct\n+    /// constructors.\n+    [] mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n     [] mir_const_qualif: Mir(DefId) -> u8,\n \n+    /// Fetch the MIR for a given def-id up till the point where it is\n+    /// ready for const evaluation.\n+    ///\n+    /// See the README for the `mir` module for details.\n+    [] mir_const: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+    [] mir_validated: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+    /// MIR after our optimization passes have run. This is MIR that is ready\n+    /// for trans. This is also the only query that can fetch non-local MIR, at present.\n+    [] optimized_mir: Mir(DefId) -> &'tcx mir::Mir<'tcx>,\n+\n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n@@ -598,7 +760,7 @@ define_maps! { <'tcx>\n     /// fn item.\n     [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps<'tcx>>,\n \n-    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n \n     [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n     [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n@@ -608,7 +770,7 @@ define_maps! { <'tcx>\n \n     [] item_body_nested_bodies: metadata_dep_node(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n     [] const_is_rvalue_promotable_to_static: metadata_dep_node(DefId) -> bool,\n-    [] is_item_mir_available: metadata_dep_node(DefId) -> bool,\n+    [] is_mir_available: metadata_dep_node(DefId) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -644,3 +806,7 @@ fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n     DepNode::ConstEval(def_id)\n }\n+\n+fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::MirKeys\n+}"}, {"sha": "55466b1f36dac513c687a61708e0d3ef38d6e81a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -35,7 +35,7 @@ use util::common::ErrorReported;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::collections::BTreeMap;\n use std::cmp;\n use std::fmt;\n@@ -96,6 +96,7 @@ pub mod _match;\n pub mod maps;\n pub mod outlives;\n pub mod relate;\n+pub mod steal;\n pub mod subst;\n pub mod trait_def;\n pub mod walk;\n@@ -2049,6 +2050,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.typeck_tables_of(self.hir.body_owner_def_id(body))\n     }\n \n+    /// Returns an iterator of the def-ids for all body-owners in this\n+    /// crate. If you would prefer to iterate over the bodies\n+    /// themselves, you can do `self.hir.krate().body_ids.iter()`.\n+    pub fn body_owners(self) -> impl Iterator<Item = DefId> + 'a {\n+        self.hir.krate()\n+                .body_ids\n+                .iter()\n+                .map(move |&body_id| self.hir.body_owner_def_id(body_id))\n+    }\n+\n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n             Some(hir_map::NodeExpr(e)) => {\n@@ -2313,33 +2324,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given the did of an item, returns its MIR, borrowed immutably.\n-    pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        self.mir(did).borrow()\n-    }\n-\n     /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n-                        -> Ref<'gcx, Mir<'gcx>>\n+                        -> &'gcx Mir<'gcx>\n     {\n         match instance {\n-            ty::InstanceDef::Item(did) if true => self.item_mir(did),\n-            _ => self.mir_shims(instance).borrow(),\n+            ty::InstanceDef::Item(did) => {\n+                self.optimized_mir(did)\n+            }\n+            ty::InstanceDef::Intrinsic(..) |\n+            ty::InstanceDef::FnPtrShim(..) |\n+            ty::InstanceDef::Virtual(..) |\n+            ty::InstanceDef::ClosureOnceShim { .. } |\n+            ty::InstanceDef::DropGlue(..) => {\n+                self.mir_shims(instance)\n+            }\n         }\n     }\n \n     /// Given the DefId of an item, returns its MIR, borrowed immutably.\n     /// Returns None if there is no MIR for the DefId\n-    pub fn maybe_item_mir(self, did: DefId) -> Option<Ref<'gcx, Mir<'gcx>>> {\n-        if did.is_local() && !self.maps.mir.borrow().contains_key(&did) {\n-            return None;\n-        }\n-\n-        if !did.is_local() && !self.is_item_mir_available(did) {\n-            return None;\n+    pub fn maybe_optimized_mir(self, did: DefId) -> Option<&'gcx Mir<'gcx>> {\n+        if self.is_mir_available(did) {\n+            Some(self.optimized_mir(did))\n+        } else {\n+            None\n         }\n-\n-        Some(self.item_mir(did))\n     }\n \n     /// Get the attributes of a definition.\n@@ -2541,17 +2551,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n-    /// Invokes `callback` for each body in the krate. This will\n-    /// create a read edge from `DepNode::Krate` to the current task;\n-    /// it is meant to be run in the context of some global task like\n-    /// `BorrowckCrate`. The callback would then create a task like\n-    /// `BorrowckBody(DefId)` to process each individual item.\n-    pub fn visit_all_bodies_in_krate<C>(self, callback: C)\n-        where C: Fn(/* body_owner */ DefId, /* body id */ hir::BodyId),\n-    {\n-        dep_graph::visit_all_bodies_in_krate(self.global_tcx(), callback)\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "0b0818888812f1700db4c8d4caf8b115b1e1ba3d", "filename": "src/librustc/ty/steal.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::{Ref, RefCell};\n+use std::mem;\n+\n+/// The `Steal` struct is intended to used as the value for a query.\n+/// Specifically, we sometimes have queries (*cough* MIR *cough*)\n+/// where we create a large, complex value that we want to iteratively\n+/// update (e.g., optimize). We could clone the value for each\n+/// optimization, but that'd be expensive. And yet we don't just want\n+/// to mutate it in place, because that would spoil the idea that\n+/// queries are these pure functions that produce an immutable value\n+/// (since if you did the query twice, you could observe the\n+/// mutations). So instead we have the query produce a `&'tcx\n+/// Steal<Mir<'tcx>>` (to be very specific). Now we can read from this\n+/// as much as we want (using `borrow()`), but you can also\n+/// `steal()`. Once you steal, any further attempt to read will panic.\n+/// Therefore we know that -- assuming no ICE -- nobody is observing\n+/// the fact that the MIR was updated.\n+///\n+/// Obviously, whenever you have a query that yields a `Steal` value,\n+/// you must treat it with caution, and make sure that you know that\n+/// -- once the value is stolen -- it will never be read from again.\n+///\n+/// FIXME(#41710) -- what is the best way to model linear queries?\n+pub struct Steal<T> {\n+    value: RefCell<Option<T>>\n+}\n+\n+impl<T> Steal<T> {\n+    pub fn new(value: T) -> Self {\n+        Steal {\n+            value: RefCell::new(Some(value))\n+        }\n+    }\n+\n+    pub fn borrow(&self) -> Ref<T> {\n+        Ref::map(self.value.borrow(), |opt| match *opt {\n+            None => bug!(\"attempted to read from stolen value\"),\n+            Some(ref v) => v\n+        })\n+    }\n+\n+    pub fn steal(&self) -> T {\n+        let value_ref = &mut *self.value.borrow_mut();\n+        let value = mem::replace(value_ref, None);\n+        value.expect(\"attempt to read from stolen value\")\n+    }\n+}"}, {"sha": "4ae8bdc284b226760c17ddcd924f71e715679711", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -16,7 +16,7 @@ use super::{drop_flag_effects_for_location, on_lookup_result_bits};\n use super::MoveDataParamEnv;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -32,9 +32,11 @@ use std::u32;\n \n pub struct ElaborateDrops;\n \n-impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>)\n+impl MirPass for ElaborateDrops {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n         match src {\n@@ -74,8 +76,6 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n     }\n }\n \n-impl Pass for ElaborateDrops {}\n-\n /// Return the set of basic blocks whose unwind edges are known\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything."}, {"sha": "47f708bf58367215e64ba9b9e25e0a57f1425471", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -61,7 +61,10 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n     let def_id = tcx.hir.local_def_id(id);\n     debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n \n-    let mir = &tcx.item_mir(def_id);\n+    // It is safe for us to borrow `mir_validated()`: `optimized_mir`\n+    // steals it, but it forces the `borrowck` query.\n+    let mir = &tcx.mir_validated(def_id).borrow();\n+\n     let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };"}, {"sha": "f8073455bd08ad422077ffd583228274fa7aa002", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -63,9 +63,9 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+    for body_owner_def_id in tcx.body_owners() {\n         tcx.borrowck(body_owner_def_id);\n-    });\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -86,6 +86,19 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n+\n+    match tcx.hir.get(owner_id) {\n+        hir_map::NodeStructCtor(_) |\n+        hir_map::NodeVariant(_) => {\n+            // We get invoked with anything that has MIR, but some of\n+            // those things (notably the synthesized constructors from\n+            // tuple structs/variants) do not have an associated body\n+            // and do not need borrowchecking.\n+            return;\n+        }\n+        _ => { }\n+    }\n+\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let attributes = tcx.get_attrs(owner_def_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n@@ -96,6 +109,16 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n \n     if bccx.tcx.has_attr(owner_def_id, \"rustc_mir_borrowck\") {\n         mir::borrowck_mir(bccx, owner_id, &attributes);\n+    } else {\n+        // Eventually, borrowck will always read the MIR, but at the\n+        // moment we do not. So, for now, we always force MIR to be\n+        // constructed for a given fn, since this may result in errors\n+        // being reported and we want that to happen.\n+        //\n+        // Note that `mir_validated` is a \"stealable\" result; the\n+        // thief, `optimized_mir()`, forces borrowck, so we know that\n+        // is not yet stolen.\n+        tcx.mir_validated(owner_def_id).borrow();\n     }\n \n     let cfg = cfg::CFG::new(bccx.tcx, &body);"}, {"sha": "9f0f567b6cee1b5519db89074683098de89e1d4a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -20,6 +20,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n+use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n@@ -35,8 +36,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts,\n-                   static_recursion, hir_stats, mir_stats};\n+use rustc_passes::{ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n \n@@ -903,9 +903,44 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);\n \n+    // Setup the MIR passes that we want to run.\n+    let mut passes = Passes::new();\n+    passes.push_hook(mir::transform::dump_mir::DumpMir);\n+\n+    // What we need to do constant evaluation.\n+    passes.push_pass(MIR_CONST, mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n+    passes.push_pass(MIR_CONST, mir::transform::type_check::TypeckMir);\n+\n+    // What we need to run borrowck etc.\n+    passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n+    passes.push_pass(MIR_VALIDATED,\n+                     mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n+    passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n+\n+    // Optimizations begin.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n+\n+    // From here on out, regions are gone.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n+    passes.push_pass(MIR_OPTIMIZED, borrowck::ElaborateDrops);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n+\n+    // No lifetime analysis based on borrowing can be done from here on out.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::inline::Inline);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::instcombine::InstCombine);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::copy_prop::CopyPropagation);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyLocals);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n+\n     TyCtxt::create_and_enter(sess,\n                              local_providers,\n                              extern_providers,\n+                             Rc::new(passes),\n                              arenas,\n                              arena,\n                              resolutions,\n@@ -962,30 +997,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"liveness checking\",\n              || middle::liveness::check_crate(tcx));\n \n-        time(time_passes,\n-             \"MIR dump\",\n-             || mir::mir_map::build_mir_for_crate(tcx));\n-\n-        if sess.opts.debugging_opts.mir_stats {\n-            mir_stats::print_mir_stats(tcx, \"PRE CLEANUP MIR STATS\");\n-        }\n-\n-        time(time_passes, \"MIR cleanup and validation\", || {\n-            let mut passes = sess.mir_passes.borrow_mut();\n-            // Push all the built-in validation passes.\n-            // NB: if you\u2019re adding an *optimisation* it ought to go to another set of passes\n-            // in stage 4 below.\n-            passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(box mir::transform::type_check::TypeckMir);\n-            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n-            passes.push_pass(\n-                box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n-            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n-            // And run everything.\n-            passes.run_passes(tcx);\n-        });\n-\n         time(time_passes,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n@@ -1034,43 +1045,6 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    if tcx.sess.opts.debugging_opts.mir_stats {\n-        mir_stats::print_mir_stats(tcx, \"PRE OPTIMISATION MIR STATS\");\n-    }\n-\n-    // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n-    // code.\n-    time(time_passes, \"MIR optimisations\", || {\n-        let mut passes = ::rustc::mir::transform::Passes::new();\n-        passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n-\n-        // From here on out, regions are gone.\n-        passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n-\n-        passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n-        passes.push_pass(box borrowck::ElaborateDrops);\n-        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n-\n-        // No lifetime analysis based on borrowing can be done from here on out.\n-        passes.push_pass(box mir::transform::inline::Inline);\n-        passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n-        passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n-        passes.push_pass(box mir::transform::copy_prop::CopyPropagation);\n-\n-        passes.push_pass(box mir::transform::simplify::SimplifyLocals);\n-        passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n-        passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n-\n-        passes.run_passes(tcx);\n-    });\n-\n-    if tcx.sess.opts.debugging_opts.mir_stats {\n-        mir_stats::print_mir_stats(tcx, \"POST OPTIMISATION MIR STATS\");\n-    }\n-\n     let translation =\n         time(time_passes,\n              \"translation\","}, {"sha": "d40a2ab0b530986128ee893f4de3d3e985167054", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -41,7 +41,6 @@ use graphviz as dot;\n use std::cell::Cell;\n use std::fs::File;\n use std::io::{self, Write};\n-use std::iter;\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n@@ -999,22 +998,14 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 if let Some(nodeid) = nodeid {\n                     let def_id = tcx.hir.local_def_id(nodeid);\n                     match ppm {\n-                        PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx, iter::once(def_id), &mut out),\n+                        PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n+                        PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 } else {\n                     match ppm {\n-                        PpmMir => {\n-                            write_mir_pretty(tcx,\n-                                             tcx.maps.mir.borrow().keys().into_iter(),\n-                                             &mut out)\n-                        }\n-                        PpmMirCFG => {\n-                            write_mir_graphviz(tcx,\n-                                               tcx.maps.mir.borrow().keys().into_iter(),\n-                                               &mut out)\n-                        }\n+                        PpmMir => write_mir_pretty(tcx, None, &mut out),\n+                        PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 }"}, {"sha": "8b95be00fa752cb50bf6c90b00641aff783579e4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -27,6 +27,7 @@ use rustc::infer::{self, InferOk, InferResult};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n+use rustc::mir::transform::Passes;\n use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::ast;\n@@ -141,6 +142,7 @@ fn test_env<F>(source_string: &str,\n     TyCtxt::create_and_enter(&sess,\n                              ty::maps::Providers::default(),\n                              ty::maps::Providers::default(),\n+                             Rc::new(Passes::new()),\n                              &arenas,\n                              &arena,\n                              resolutions,"}, {"sha": "872b2eb6f711363461dd49c4d7b509987b8908f1", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -30,7 +30,6 @@ use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n use std::any::Any;\n-use std::mem;\n use std::rc::Rc;\n \n use syntax::ast;\n@@ -95,16 +94,13 @@ provide! { <'tcx> tcx, def_id, cdata\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    mir => {\n-        let mir = cdata.maybe_get_item_mir(tcx, def_id.index).unwrap_or_else(|| {\n-            bug!(\"get_item_mir: missing MIR for `{:?}`\", def_id)\n+    optimized_mir => {\n+        let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n+            bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n         });\n \n         let mir = tcx.alloc_mir(mir);\n \n-        // Perma-borrow MIR from extern crates to prevent mutation.\n-        mem::forget(mir.borrow());\n-\n         mir\n     }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n@@ -126,7 +122,7 @@ provide! { <'tcx> tcx, def_id, cdata\n         cdata.entry(def_id.index).ast.expect(\"const item missing `ast`\")\n             .decode(cdata).rvalue_promotable_to_static\n     }\n-    is_item_mir_available => {\n+    is_mir_available => {\n         !cdata.is_proc_macro(def_id.index) &&\n         cdata.maybe_entry(def_id.index).and_then(|item| item.decode(cdata).mir).is_some()\n     }"}, {"sha": "ae755adcf5fbbe8bb92b76fc9fa7ad9144371b2d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -779,10 +779,10 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_tables(ast.tables.decode((self, tcx)))\n     }\n \n-    pub fn maybe_get_item_mir(&self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: DefIndex)\n-                              -> Option<Mir<'tcx>> {\n+    pub fn maybe_get_optimized_mir(&self,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   id: DefIndex)\n+                                   -> Option<Mir<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),"}, {"sha": "125026b799c98e3bdeef935d5d0c5277d1c6cb22", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -433,7 +433,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -528,7 +528,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             } else {\n                 None\n             },\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -598,7 +598,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: ast.map(|body| self.encode_body(body)),\n-            mir: if mir { self.encode_mir(def_id) } else { None },\n+            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n         }\n     }\n \n@@ -619,9 +619,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         self.lazy_seq(names.iter().map(|name| name.node))\n     }\n \n-    fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n+    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n-        self.tcx.maps.mir.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n+        if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n+            let mir = self.tcx.optimized_mir(def_id);\n+            Some(self.lazy(&mir))\n+        } else {\n+            None\n+        }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n@@ -856,15 +861,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             },\n             mir: match item.node {\n                 hir::ItemStatic(..) if self.tcx.sess.opts.debugging_opts.always_encode_mir => {\n-                    self.encode_mir(def_id)\n+                    self.encode_optimized_mir(def_id)\n                 }\n-                hir::ItemConst(..) => self.encode_mir(def_id),\n+                hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let tps_len = generics.ty_params.len();\n                     let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n-                        self.encode_mir(def_id)\n+                        self.encode_optimized_mir(def_id)\n                     } else {\n                         None\n                     }\n@@ -1161,7 +1166,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: None,\n \n             ast: None,\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -1187,7 +1192,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: Some(self.encode_body(body)),\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n "}, {"sha": "0d912513c6c765fee1498667f2e1a815287d1055", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -18,7 +18,7 @@ use build::{BlockAnd, Builder};\n use hair::*;\n use rustc::mir::*;\n \n-pub trait EvalInto<'tcx> {\n+pub(in build) trait EvalInto<'tcx> {\n     fn eval_into<'a, 'gcx>(self,\n                            builder: &mut Builder<'a, 'gcx, 'tcx>,\n                            destination: &Lvalue<'tcx>,"}, {"sha": "8c057b02df2bf35c07c81dd550669a2ecbd82227", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 215, "deletions": 14, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -8,24 +8,225 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+use build;\n use hair::cx::Cx;\n use hair::Pattern;\n-\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{self, Ty};\n use rustc::mir::*;\n+use rustc::mir::transform::MirSource;\n+use rustc::mir::visit::MutVisitor;\n+use rustc::traits::Reveal;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n-use rustc::hir;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use shim;\n+use std::mem;\n+use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n+use util as mir_util;\n \n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+/// Construct the MIR for a given def-id.\n+pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let unsupported = || {\n+        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n+    };\n \n-use std::u32;\n+    // Figure out what primary body this item has.\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) |\n+                hir::ItemFn(.., body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) |\n+                hir::TraitItemKind::Method(_,\n+                    hir::TraitMethod::Provided(body)) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) |\n+                hir::ImplItemKind::Method(_, body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(_, _, body, _) => body,\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        hir::map::NodeVariant(variant) =>\n+            return create_constructor_shim(tcx, id, &variant.node.data),\n+        hir::map::NodeStructCtor(ctor) =>\n+            return create_constructor_shim(tcx, id, ctor),\n+        _ => unsupported()\n+    };\n+\n+    let src = MirSource::from_node(tcx, id);\n+    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n+        let cx = Cx::new(&infcx, src);\n+        let mut mir = if cx.tables().tainted_by_errors {\n+            build::construct_error(cx, body_id)\n+        } else if let MirSource::Fn(id) = src {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n+            let mut abi = fn_sig.abi;\n+            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n+                // HACK(eddyb) Avoid having RustCall on closures,\n+                // as it adds unnecessary (and wrong) auto-tupling.\n+                abi = Abi::Rust;\n+                Some((closure_self_ty(tcx, id, body_id), None))\n+            } else {\n+                None\n+            };\n+\n+            let body = tcx.hir.body(body_id);\n+            let explicit_arguments =\n+                body.arguments\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(index, arg)| {\n+                        (fn_sig.inputs()[index], Some(&*arg.pat))\n+                    });\n+\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+        } else {\n+            build::construct_const(cx, body_id)\n+        };\n+\n+        // Convert the Mir to global types.\n+        let mut globalizer = GlobalizeMir {\n+            tcx: tcx,\n+            span: mir.span\n+        };\n+        globalizer.visit_mir(&mut mir);\n+        let mir = unsafe {\n+            mem::transmute::<Mir, Mir<'tcx>>(mir)\n+        };\n+\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+\n+        mir\n+    })\n+}\n+\n+/// A pass to lift all the types and substitutions in a Mir\n+/// to the global tcx. Sadly, we don't have a \"folder\" that\n+/// can change 'tcx so we have to transmute afterwards.\n+struct GlobalizeMir<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(ty) {\n+            *ty = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found type `{:?}` with inference types/regions in MIR\",\n+                      ty);\n+        }\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(substs) {\n+            *substs = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found substs `{:?}` with inference types/regions in MIR\",\n+                      substs);\n+        }\n+    }\n+}\n+\n+fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     ctor_id: ast::NodeId,\n+                                     v: &'tcx hir::VariantData)\n+                                     -> Mir<'tcx>\n+{\n+    let span = tcx.hir.span(ctor_id);\n+    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n+        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n+        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n+            let (mut mir, src) =\n+                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n+\n+            // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n+            let mut globalizer = GlobalizeMir {\n+                tcx: tcx,\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n+            };\n+\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+\n+            mir\n+        })\n+    } else {\n+        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n+\n+fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             closure_expr_id: ast::NodeId,\n+                             body_id: hir::BodyId)\n+                             -> Ty<'tcx> {\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n+\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: Some(tcx.item_extent(body_id.node_id)),\n+        bound_region: ty::BoundRegion::BrEnv,\n+    });\n+    let region = tcx.mk_region(region);\n+\n+    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n+        ty::ClosureKind::Fn =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutImmutable }),\n+        ty::ClosureKind::FnMut =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutMutable }),\n+        ty::ClosureKind::FnOnce =>\n+            closure_ty\n+    }\n+}\n \n-pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n \n@@ -82,7 +283,7 @@ impl Idx for ScopeId {\n /// convenient.\n \n #[must_use] // if you don't use one of these results, you're leaving a dangling edge\n-pub struct BlockAnd<T>(BasicBlock, T);\n+struct BlockAnd<T>(BasicBlock, T);\n \n trait BlockAndExtension {\n     fn and<T>(self, v: T) -> BlockAnd<T>;\n@@ -121,13 +322,13 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       fn_id: ast::NodeId,\n-                                       arguments: A,\n-                                       abi: Abi,\n-                                       return_ty: Ty<'gcx>,\n-                                       body: &'gcx hir::Body)\n-                                       -> Mir<'tcx>\n+fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                   fn_id: ast::NodeId,\n+                                   arguments: A,\n+                                   abi: Abi,\n+                                   return_ty: Ty<'gcx>,\n+                                   body: &'gcx hir::Body)\n+                                   -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n     let arguments: Vec<_> = arguments.collect();"}, {"sha": "69416289d8e2682b1d68e8f18a902b866b22f36e", "filename": "src/librustc_mir/callgraph.rs", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/src%2Flibrustc_mir%2Fcallgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/src%2Flibrustc_mir%2Fcallgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fcallgraph.rs?ref=1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "patch": "@@ -1,252 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! MIR-based callgraph.\n-//!\n-//! This only considers direct calls\n-\n-use rustc::hir::def_id::DefId;\n-use rustc_data_structures::graph;\n-\n-use rustc::mir::*;\n-use rustc::mir::visit::*;\n-\n-use rustc::ty;\n-\n-use rustc::util::nodemap::DefIdMap;\n-\n-pub struct CallGraph {\n-    node_map: DefIdMap<graph::NodeIndex>,\n-    graph: graph::Graph<DefId, ()>\n-}\n-\n-impl CallGraph {\n-    // FIXME: allow for construction of a callgraph that inspects\n-    // cross-crate MIRs if available.\n-    pub fn build<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> CallGraph {\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-\n-        let mut callgraph = CallGraph {\n-            node_map: DefIdMap(),\n-            graph: graph::Graph::new()\n-        };\n-\n-        for def_id in def_ids {\n-            if !def_id.is_local() { continue; }\n-\n-            let idx = callgraph.add_node(def_id);\n-\n-            let mut call_visitor = CallVisitor {\n-                caller: idx,\n-                graph: &mut callgraph\n-            };\n-\n-            let mir = tcx.item_mir(def_id);\n-            call_visitor.visit_mir(&mir);\n-        }\n-\n-        callgraph\n-    }\n-\n-    // Iterate over the strongly-connected components of the graph\n-    pub fn scc_iter(&self) -> SCCIterator {\n-        SCCIterator::new(&self.graph)\n-    }\n-\n-    // Get the def_id for the given graph node\n-    pub fn def_id(&self, node: graph::NodeIndex) -> DefId {\n-        *self.graph.node_data(node)\n-    }\n-\n-    fn add_node(&mut self, id: DefId) -> graph::NodeIndex {\n-        let graph = &mut self.graph;\n-        *self.node_map.entry(id).or_insert_with(|| {\n-            graph.add_node(id)\n-        })\n-    }\n-}\n-\n-struct CallVisitor<'a> {\n-    caller: graph::NodeIndex,\n-    graph: &'a mut CallGraph\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for CallVisitor<'a> {\n-    fn visit_terminator_kind(&mut self, _block: BasicBlock,\n-                             kind: &TerminatorKind<'tcx>, _loc: Location) {\n-        if let TerminatorKind::Call {\n-            func: Operand::Constant(ref f)\n-            , .. } = *kind {\n-            if let ty::TyFnDef(def_id, _, _) = f.ty.sty {\n-                let callee = self.graph.add_node(def_id);\n-                self.graph.graph.add_edge(self.caller, callee, ());\n-            }\n-        }\n-    }\n-}\n-\n-struct StackElement<'g> {\n-    node: graph::NodeIndex,\n-    lowlink: usize,\n-    children: graph::AdjacentTargets<'g, DefId, ()>\n-}\n-\n-/**\n- * Iterator over strongly-connected-components using Tarjan's algorithm[1]\n- *\n- * [1]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n- */\n-pub struct SCCIterator<'g> {\n-    graph: &'g graph::Graph<DefId, ()>,\n-    index: usize,\n-    node_indices: Vec<Option<usize>>,\n-    scc_stack: Vec<graph::NodeIndex>,\n-    current_scc: Vec<graph::NodeIndex>,\n-    visit_stack: Vec<StackElement<'g>>,\n-}\n-\n-impl<'g> SCCIterator<'g> {\n-    pub fn new(graph: &'g graph::Graph<DefId, ()>) -> SCCIterator<'g> {\n-        if graph.len_nodes() == 0 {\n-            return SCCIterator {\n-                graph: graph,\n-                index: 0,\n-                node_indices: Vec::new(),\n-                scc_stack: Vec::new(),\n-                current_scc: Vec::new(),\n-                visit_stack: Vec::new()\n-            };\n-        }\n-\n-        let first = graph::NodeIndex(0);\n-\n-        SCCIterator::with_entry(graph, first)\n-    }\n-\n-    pub fn with_entry(graph: &'g graph::Graph<DefId, ()>,\n-                      entry: graph::NodeIndex) -> SCCIterator<'g> {\n-        let mut iter = SCCIterator {\n-            graph: graph,\n-            index: 0,\n-            node_indices: Vec::with_capacity(graph.len_nodes()),\n-            scc_stack: Vec::new(),\n-            current_scc: Vec::new(),\n-            visit_stack: Vec::new()\n-        };\n-\n-        iter.visit_one(entry);\n-\n-        iter\n-    }\n-\n-    fn get_next(&mut self) {\n-        self.current_scc.clear();\n-\n-        while !self.visit_stack.is_empty() {\n-            self.visit_children();\n-\n-            let node = self.visit_stack.pop().unwrap();\n-\n-            if let Some(last) = self.visit_stack.last_mut() {\n-                if last.lowlink > node.lowlink {\n-                    last.lowlink = node.lowlink;\n-                }\n-            }\n-\n-            debug!(\"TarjanSCC: Popped node {:?} : lowlink = {:?}; index = {:?}\",\n-                   node.node, node.lowlink, self.node_index(node.node).unwrap());\n-\n-            if node.lowlink != self.node_index(node.node).unwrap() {\n-                continue;\n-            }\n-\n-            loop {\n-                let n = self.scc_stack.pop().unwrap();\n-                self.current_scc.push(n);\n-                self.set_node_index(n, !0);\n-                if n == node.node { return; }\n-            }\n-        }\n-    }\n-\n-    fn visit_one(&mut self, node: graph::NodeIndex) {\n-        self.index += 1;\n-        let idx =  self.index;\n-        self.set_node_index(node, idx);\n-        self.scc_stack.push(node);\n-        self.visit_stack.push(StackElement {\n-            node: node,\n-            lowlink: self.index,\n-            children: self.graph.successor_nodes(node)\n-        });\n-        debug!(\"TarjanSCC: Node {:?} : index = {:?}\", node, idx);\n-    }\n-\n-    fn visit_children(&mut self) {\n-        while let Some(child) = self.visit_stack.last_mut().unwrap().children.next() {\n-            if let Some(child_num) = self.node_index(child) {\n-                let cur = self.visit_stack.last_mut().unwrap();\n-                if cur.lowlink > child_num {\n-                    cur.lowlink = child_num;\n-                }\n-            } else {\n-                self.visit_one(child);\n-            }\n-        }\n-    }\n-\n-    fn node_index(&self, node: graph::NodeIndex) -> Option<usize> {\n-        self.node_indices.get(node.node_id()).and_then(|&idx| idx)\n-    }\n-\n-    fn set_node_index(&mut self, node: graph::NodeIndex, idx: usize) {\n-        let i = node.node_id();\n-        if i >= self.node_indices.len() {\n-            self.node_indices.resize(i + 1, None);\n-        }\n-        self.node_indices[i] = Some(idx);\n-    }\n-}\n-\n-impl<'g> Iterator for SCCIterator<'g> {\n-    type Item = Vec<graph::NodeIndex>;\n-\n-    fn next(&mut self) -> Option<Vec<graph::NodeIndex>> {\n-        self.get_next();\n-\n-        if self.current_scc.is_empty() {\n-            // Try a new root for the next SCC, if the node_indices\n-            // map is doesn't contain all nodes, use the smallest one\n-            // with no entry, otherwise find the first empty node.\n-            //\n-            // FIXME: This should probably use a set of precomputed\n-            // roots instead\n-            if self.node_indices.len() < self.graph.len_nodes() {\n-                let idx = graph::NodeIndex(self.node_indices.len());\n-                self.visit_one(idx);\n-            } else {\n-                for idx in 0..self.node_indices.len() {\n-                    if self.node_indices[idx].is_none() {\n-                        let idx = graph::NodeIndex(idx);\n-                        self.visit_one(idx);\n-                        break;\n-                    }\n-                }\n-            }\n-            self.get_next();\n-        }\n-\n-        if self.current_scc.is_empty() {\n-            None\n-        } else {\n-            Some(self.current_scc.clone())\n-        }\n-    }\n-}"}, {"sha": "ee8547e5dd679f9f4694d8e75e6c8d6cdf37a50c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::region::RegionMaps;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n use std::rc::Rc;\n@@ -103,10 +103,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn str_literal(&mut self, value: InternedString) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Str(value) }\n-    }\n-\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Bool(true) }\n     }"}, {"sha": "5fa56bac1379be8b120ab0e044d77bd4bee40877", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -46,18 +46,15 @@ extern crate rustc_const_eval;\n \n pub mod diagnostics;\n \n-pub mod build;\n-pub mod callgraph;\n+mod build;\n mod hair;\n mod shim;\n-pub mod mir_map;\n pub mod transform;\n pub mod util;\n \n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n-    mir_map::provide(providers);\n     shim::provide(providers);\n-    transform::qualify_consts::provide(providers);\n+    transform::provide(providers);\n }"}, {"sha": "1abae515ae68374ee32c9a6672226f8a7dfdb862", "filename": "src/librustc_mir/mir_map.rs", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "patch": "@@ -1,273 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An experimental pass that scources for `#[rustc_mir]` attributes,\n-//! builds the resulting MIR, and dumps it out into a file for inspection.\n-//!\n-//! The attribute formats that are currently accepted are:\n-//!\n-//! - `#[rustc_mir(graphviz=\"file.gv\")]`\n-//! - `#[rustc_mir(pretty=\"file.mir\")]`\n-\n-use build;\n-use rustc::hir::def_id::DefId;\n-use rustc::dep_graph::DepNode;\n-use rustc::mir::Mir;\n-use rustc::mir::transform::MirSource;\n-use rustc::mir::visit::MutVisitor;\n-use shim;\n-use hair::cx::Cx;\n-use util as mir_util;\n-\n-use rustc::traits::Reveal;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::maps::Providers;\n-use rustc::ty::subst::Substs;\n-use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use syntax::abi::Abi;\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-use std::cell::RefCell;\n-use std::mem;\n-\n-pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.dep_graph.with_task(DepNode::MirKrate, tcx, (), build_mir_for_crate_task);\n-\n-    fn build_mir_for_crate_task<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, (): ()) {\n-        tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n-            tcx.item_mir(body_owner_def_id);\n-        });\n-\n-        // Tuple struct/variant constructors don't have a BodyId, so we need\n-        // to build them separately.\n-        struct GatherCtors<'a, 'tcx: 'a> {\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>\n-        }\n-        impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n-            fn visit_variant_data(&mut self,\n-                                  v: &'tcx hir::VariantData,\n-                                  _: ast::Name,\n-                                  _: &'tcx hir::Generics,\n-                                  _: ast::NodeId,\n-                                  _: Span) {\n-                if let hir::VariantData::Tuple(_, node_id) = *v {\n-                    self.tcx.item_mir(self.tcx.hir.local_def_id(node_id));\n-                }\n-                intravisit::walk_struct_def(self, v)\n-            }\n-            fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n-                NestedVisitorMap::None\n-            }\n-        }\n-        tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n-            tcx: tcx\n-        }.as_deep_visitor());\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.mir = build_mir;\n-}\n-\n-fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                       -> &'tcx RefCell<Mir<'tcx>> {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let unsupported = || {\n-        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n-    };\n-\n-    // Figure out what primary body this item has.\n-    let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) |\n-                hir::ItemFn(.., body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeTraitItem(item) => {\n-            match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) |\n-                hir::TraitItemKind::Method(_,\n-                    hir::TraitMethod::Provided(body)) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeImplItem(item) => {\n-            match item.node {\n-                hir::ImplItemKind::Const(_, body) |\n-                hir::ImplItemKind::Method(_, body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeExpr(expr) => {\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            // Type-checking should not let closures get\n-            // this far in a constant position.\n-            // Assume that everything other than closures\n-            // is a constant \"initializer\" expression.\n-            match expr.node {\n-                hir::ExprClosure(_, _, body, _) => body,\n-                _ => hir::BodyId { node_id: expr.id }\n-            }\n-        }\n-        hir::map::NodeVariant(variant) =>\n-            return create_constructor_shim(tcx, id, &variant.node.data),\n-        hir::map::NodeStructCtor(ctor) =>\n-            return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported()\n-    };\n-\n-    let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-        let cx = Cx::new(&infcx, src);\n-        let mut mir = if cx.tables().tainted_by_errors {\n-            build::construct_error(cx, body_id)\n-        } else if let MirSource::Fn(id) = src {\n-            // fetch the fully liberated fn signature (that is, all bound\n-            // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n-\n-            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n-            let mut abi = fn_sig.abi;\n-            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n-                // HACK(eddyb) Avoid having RustCall on closures,\n-                // as it adds unnecessary (and wrong) auto-tupling.\n-                abi = Abi::Rust;\n-                Some((closure_self_ty(tcx, id, body_id), None))\n-            } else {\n-                None\n-            };\n-\n-            let body = tcx.hir.body(body_id);\n-            let explicit_arguments =\n-                body.arguments\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(index, arg)| {\n-                        (fn_sig.inputs()[index], Some(&*arg.pat))\n-                    });\n-\n-            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n-        } else {\n-            build::construct_const(cx, body_id)\n-        };\n-\n-        // Convert the Mir to global types.\n-        let mut globalizer = GlobalizeMir {\n-            tcx: tcx,\n-            span: mir.span\n-        };\n-        globalizer.visit_mir(&mut mir);\n-        let mir = unsafe {\n-            mem::transmute::<Mir, Mir<'tcx>>(mir)\n-        };\n-\n-        mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n-\n-        tcx.alloc_mir(mir)\n-    })\n-}\n-\n-/// A pass to lift all the types and substitutions in a Mir\n-/// to the global tcx. Sadly, we don't have a \"folder\" that\n-/// can change 'tcx so we have to transmute afterwards.\n-struct GlobalizeMir<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    span: Span\n-}\n-\n-impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n-        if let Some(lifted) = self.tcx.lift(ty) {\n-            *ty = lifted;\n-        } else {\n-            span_bug!(self.span,\n-                      \"found type `{:?}` with inference types/regions in MIR\",\n-                      ty);\n-        }\n-    }\n-\n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n-        if let Some(lifted) = self.tcx.lift(substs) {\n-            *substs = lifted;\n-        } else {\n-            span_bug!(self.span,\n-                      \"found substs `{:?}` with inference types/regions in MIR\",\n-                      substs);\n-        }\n-    }\n-}\n-\n-fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ctor_id: ast::NodeId,\n-                                     v: &'tcx hir::VariantData)\n-                                     -> &'tcx RefCell<Mir<'tcx>>\n-{\n-    let span = tcx.hir.span(ctor_id);\n-    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n-        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n-            let (mut mir, src) =\n-                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n-\n-            // Convert the Mir to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx: tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_mir(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'tcx>>(mir)\n-            };\n-\n-            mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n-\n-            tcx.alloc_mir(mir)\n-        })\n-    } else {\n-        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n-\n-fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             closure_expr_id: ast::NodeId,\n-                             body_id: hir::BodyId)\n-                             -> Ty<'tcx> {\n-    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n-\n-    let region = ty::ReFree(ty::FreeRegion {\n-        scope: Some(tcx.item_extent(body_id.node_id)),\n-        bound_region: ty::BoundRegion::BrEnv,\n-    });\n-    let region = tcx.mk_region(region);\n-\n-    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n-        ty::ClosureKind::Fn =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutImmutable }),\n-        ty::ClosureKind::FnMut =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutMutable }),\n-        ty::ClosureKind::FnOnce =>\n-            closure_ty\n-    }\n-}"}, {"sha": "1458ea7fdd6a29fcd9fb5e9b75c5ddf88bf95337", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -24,10 +24,8 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use std::cell::RefCell;\n use std::fmt;\n use std::iter;\n-use std::mem;\n \n use transform::{add_call_guards, no_landing_pads, simplify};\n use util::elaborate_drops::{self, DropElaborator, DropStyle, DropFlagMode};\n@@ -39,7 +37,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                        instance: ty::InstanceDef<'tcx>)\n-                       -> &'tcx RefCell<Mir<'tcx>>\n+                       -> &'tcx Mir<'tcx>\n {\n     debug!(\"make_shim({:?})\", instance);\n     let did = instance.def_id();\n@@ -116,10 +114,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         add_call_guards::add_call_guards(&mut result);\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n-    let result = tcx.alloc_mir(result);\n-    // Perma-borrow MIR from shims to prevent mutation.\n-    mem::forget(result.borrow());\n-    result\n+    tcx.alloc_mir(result)\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]"}, {"sha": "b7c7a1774dd356f3ab2aac43decccb7002904a36", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n pub struct AddCallGuards;\n@@ -35,8 +35,11 @@ pub struct AddCallGuards;\n  *\n  */\n \n-impl<'tcx> MirPass<'tcx> for AddCallGuards {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for AddCallGuards {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         add_call_guards(mir);\n     }\n }\n@@ -82,5 +85,3 @@ pub fn add_call_guards(mir: &mut Mir) {\n \n     mir.basic_blocks_mut().extend(new_blocks);\n }\n-\n-impl Pass for AddCallGuards {}"}, {"sha": "fbb67161bac9d82fb7d5034ccab663d481d9819c", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -30,21 +30,19 @@\n //! future.\n \n use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use util::def_use::DefUseAnalysis;\n use transform::qualify_consts;\n \n pub struct CopyPropagation;\n \n-impl Pass for CopyPropagation {}\n-\n-impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    source: MirSource,\n-                    mir: &mut Mir<'tcx>) {\n+impl MirPass for CopyPropagation {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         match source {\n             MirSource::Const(_) => {\n                 // Don't run on constants, because constant qualification might reject the"}, {"sha": "4309f91c635bb15bc6f733123354c0d24b733625", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -10,16 +10,16 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc_data_structures::indexed_vec::Idx;\n \n pub struct Deaggregator;\n \n-impl Pass for Deaggregator {}\n-\n-impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    source: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for Deaggregator {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let node_id = source.item_id();\n         let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n         debug!(\"running on: {:?}\", node_path);"}, {"sha": "67a3281dba48b0afacda60f88445690337336920", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -10,77 +10,73 @@\n \n //! This pass just dumps MIR at a specified point.\n \n+use std::borrow::Cow;\n use std::fmt;\n use std::fs::File;\n use std::io;\n \n+use rustc::mir::Mir;\n+use rustc::mir::transform::{MirPass, MirPassIndex, MirSource, MirSuite, PassHook};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n-use rustc::mir::*;\n-use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n use util as mir_util;\n \n-pub struct Marker<'a>(pub &'a str);\n+pub struct Marker(pub &'static str);\n \n-impl<'b, 'tcx> MirPass<'tcx> for Marker<'b> {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _src: MirSource, _mir: &mut Mir<'tcx>)\n-    {}\n-}\n+impl MirPass for Marker {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        Cow::Borrowed(self.0)\n+    }\n \n-impl<'b> Pass for Marker<'b> {\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { String::from(self.0).into() }\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _source: MirSource,\n+                          _mir: &mut Mir<'tcx>)\n+    {\n+    }\n }\n \n-pub struct Disambiguator<'a> {\n-    pass: &'a Pass,\n+pub struct Disambiguator {\n     is_after: bool\n }\n \n-impl<'a> fmt::Display for Disambiguator<'a> {\n+impl fmt::Display for Disambiguator {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         let title = if self.is_after { \"after\" } else { \"before\" };\n-        if let Some(fmt) = self.pass.disambiguator() {\n-            write!(formatter, \"{}-{}\", fmt, title)\n-        } else {\n-            write!(formatter, \"{}\", title)\n-        }\n+        write!(formatter, \"{}\", title)\n     }\n }\n \n pub struct DumpMir;\n \n-impl<'tcx> MirPassHook<'tcx> for DumpMir {\n-    fn on_mir_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        src: MirSource,\n-        mir: &Mir<'tcx>,\n-        pass: &Pass,\n-        is_after: bool)\n+impl PassHook for DumpMir {\n+    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 suite: MirSuite,\n+                                 pass_num: MirPassIndex,\n+                                 pass_name: &str,\n+                                 source: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 is_after: bool)\n     {\n-        mir_util::dump_mir(\n-            tcx,\n-            &*pass.name(),\n-            &Disambiguator {\n-                pass: pass,\n-                is_after: is_after\n-            },\n-            src,\n-            mir\n-        );\n+        if mir_util::dump_enabled(tcx, pass_name, source) {\n+            mir_util::dump_mir(tcx,\n+                               Some((suite, pass_num)),\n+                               pass_name,\n+                               &Disambiguator { is_after },\n+                               source,\n+                               mir);\n+        }\n     }\n }\n \n-impl<'b> Pass for DumpMir {}\n-\n pub fn emit_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     outputs: &OutputFilenames)\n     -> io::Result<()>\n {\n     let path = outputs.path(OutputType::Mir);\n     let mut f = File::create(&path)?;\n-    mir_util::write_mir_pretty(tcx, tcx.maps.mir.borrow().keys().into_iter(), &mut f)?;\n+    mir_util::write_mir_pretty(tcx, None, &mut f)?;\n     Ok(())\n }"}, {"sha": "19714849b09141c252cb1c9640fe679852768aaf", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -69,11 +69,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n \n pub struct EraseRegions;\n \n-impl Pass for EraseRegions {}\n-\n-impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for EraseRegions {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "f60dcbed6ba474bee54f34fd07d9042b35f97e39", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 76, "deletions": 188, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -14,24 +14,20 @@ use rustc::hir::def_id::DefId;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::graph;\n \n-use rustc::dep_graph::DepNode;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirMapPass, MirPassHook, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::*;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n-use rustc::util::nodemap::{DefIdSet};\n \n+use std::collections::VecDeque;\n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n \n use syntax::{attr};\n use syntax::abi::Abi;\n \n-use callgraph;\n-\n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n \n@@ -42,178 +38,94 @@ const UNKNOWN_SIZE_COST: usize = 10;\n \n pub struct Inline;\n \n-impl<'tcx> MirMapPass<'tcx> for Inline {\n-    fn run_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        hooks: &mut [Box<for<'s> MirPassHook<'s>>]) {\n-\n-        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 { return; }\n-\n-        let _ignore = tcx.dep_graph.in_ignore();\n-\n-        let callgraph = callgraph::CallGraph::build(tcx);\n-\n-        let mut inliner = Inliner {\n-            tcx: tcx,\n-        };\n-\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-        for &def_id in &def_ids {\n-            if !def_id.is_local() { continue; }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mut mir = if let Some(mir) = tcx.maps.mir.borrow().get(&def_id) {\n-                mir.borrow_mut()\n-            } else {\n-                continue;\n-            };\n-\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, &mut mir, self, false);\n-            }\n-        }\n-\n-        for scc in callgraph.scc_iter() {\n-            inliner.inline_scc(&callgraph, &scc);\n-        }\n-\n-        for def_id in def_ids {\n-            if !def_id.is_local() { continue; }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mut mir = tcx.maps.mir.borrow()[&def_id].borrow_mut();\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, &mut mir, self, true);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Pass for Inline { }\n-\n-struct Inliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n #[derive(Copy, Clone)]\n struct CallSite<'tcx> {\n-    caller: DefId,\n     callee: DefId,\n     substs: &'tcx Substs<'tcx>,\n     bb: BasicBlock,\n     location: SourceInfo,\n }\n \n-impl<'a, 'tcx> Inliner<'a, 'tcx> {\n-    fn inline_scc(&mut self, callgraph: &callgraph::CallGraph, scc: &[graph::NodeIndex]) -> bool {\n-        let mut callsites = Vec::new();\n-        let mut in_scc = DefIdSet();\n-\n-        let mut inlined_into = DefIdSet();\n+impl MirPass for Inline {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+            Inliner { tcx, source }.run_pass(mir);\n+        }\n+    }\n+}\n \n-        for &node in scc {\n-            let def_id = callgraph.def_id(node);\n+struct Inliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: MirSource,\n+}\n \n-            // Don't inspect functions from other crates\n-            let id = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                id\n-            } else {\n-                continue;\n-            };\n-            let src = MirSource::from_node(self.tcx, id);\n-            if let MirSource::Fn(_) = src {\n-                if let Some(mir) = self.tcx.maybe_item_mir(def_id) {\n-                    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-                        // Don't inline calls that are in cleanup blocks.\n-                        if bb_data.is_cleanup { continue; }\n-\n-                        // Only consider direct calls to functions\n-                        let terminator = bb_data.terminator();\n-                        if let TerminatorKind::Call {\n-                            func: Operand::Constant(ref f), .. } = terminator.kind {\n-                            if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n-                                callsites.push(CallSite {\n-                                    caller: def_id,\n-                                    callee: callee_def_id,\n-                                    substs: substs,\n-                                    bb: bb,\n-                                    location: terminator.source_info\n-                                });\n-                            }\n-                        }\n+impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+    fn run_pass(&self, caller_mir: &mut Mir<'tcx>) {\n+        // Keep a queue of callsites to try inlining on. We take\n+        // advantage of the fact that queries detect cycles here to\n+        // allow us to try and fetch the fully optimized MIR of a\n+        // call; if it succeeds, we can inline it and we know that\n+        // they do not call us.  Otherwise, we just don't try to\n+        // inline.\n+        //\n+        // We use a queue so that we inline \"broadly\" before we inline\n+        // in depth. It is unclear if this is the best heuristic,\n+        // really, but that's true of all the heuristics in this\n+        // file. =)\n+\n+        let mut callsites = VecDeque::new();\n+\n+        // Only do inlining into fn bodies.\n+        if let MirSource::Fn(_) = self.source {\n+            for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n+                // Don't inline calls that are in cleanup blocks.\n+                if bb_data.is_cleanup { continue; }\n+\n+                // Only consider direct calls to functions\n+                let terminator = bb_data.terminator();\n+                if let TerminatorKind::Call {\n+                    func: Operand::Constant(ref f), .. } = terminator.kind {\n+                    if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                        callsites.push_back(CallSite {\n+                            callee: callee_def_id,\n+                            substs: substs,\n+                            bb: bb,\n+                            location: terminator.source_info\n+                        });\n                     }\n-\n-                    in_scc.insert(def_id);\n                 }\n             }\n         }\n \n-        // Move callsites that are in the the SCC to the end so\n-        // they're inlined after calls to outside the SCC\n-        let mut first_call_in_scc = callsites.len();\n-\n-        let mut i = 0;\n-        while i < first_call_in_scc {\n-            let f = callsites[i].caller;\n-            if in_scc.contains(&f) {\n-                first_call_in_scc -= 1;\n-                callsites.swap(i, first_call_in_scc);\n-            } else {\n-                i += 1;\n-            }\n-        }\n-\n         let mut local_change;\n         let mut changed = false;\n \n         loop {\n             local_change = false;\n-            let mut csi = 0;\n-            while csi < callsites.len() {\n-                let callsite = callsites[csi];\n-                csi += 1;\n-\n-                let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n-                self.tcx.dep_graph.write(DepNode::Mir(callsite.caller));\n-\n-                let callee_mir = {\n-                    if let Some(callee_mir) = self.tcx.maybe_item_mir(callsite.callee) {\n-                        if !self.should_inline(callsite, &callee_mir) {\n-                            continue;\n-                        }\n+            while let Some(callsite) = callsites.pop_front() {\n+                if !self.tcx.is_mir_available(callsite.callee) {\n+                    continue;\n+                }\n \n+                let callee_mir = match ty::queries::optimized_mir::try_get(self.tcx,\n+                                                                           callsite.location.span,\n+                                                                           callsite.callee) {\n+                    Ok(ref callee_mir) if self.should_inline(callsite, callee_mir) => {\n                         callee_mir.subst(self.tcx, callsite.substs)\n-                    } else {\n-                        continue;\n                     }\n \n-                };\n-\n-                let mut caller_mir = {\n-                    let map = self.tcx.maps.mir.borrow();\n-                    let mir = map.get(&callsite.caller).unwrap();\n-                    mir.borrow_mut()\n+                    _ => continue,\n                 };\n \n                 let start = caller_mir.basic_blocks().len();\n \n-                if !self.inline_call(callsite, &mut caller_mir, callee_mir) {\n+                if !self.inline_call(callsite, caller_mir, callee_mir) {\n                     continue;\n                 }\n \n-                inlined_into.insert(callsite.caller);\n-\n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n                     // Only consider direct calls to functions\n@@ -223,8 +135,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n-                                callsites.push(CallSite {\n-                                    caller: callsite.caller,\n+                                callsites.push_back(CallSite {\n                                     callee: callee_def_id,\n                                     substs: substs,\n                                     bb: bb,\n@@ -235,13 +146,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     }\n                 }\n \n-                csi -= 1;\n-                if scc.len() == 1 {\n-                    callsites.swap_remove(csi);\n-                } else {\n-                    callsites.remove(csi);\n-                }\n-\n                 local_change = true;\n                 changed = true;\n             }\n@@ -251,27 +155,19 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n         }\n \n-        // Simplify functions we inlined into.\n-        for def_id in inlined_into {\n-            let _task = self.tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            self.tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let mut caller_mir = {\n-                let map = self.tcx.maps.mir.borrow();\n-                let mir = map.get(&def_id).unwrap();\n-                mir.borrow_mut()\n-            };\n-\n-            debug!(\"Running simplify cfg on {:?}\", def_id);\n-            CfgSimplifier::new(&mut caller_mir).simplify();\n-            remove_dead_blocks(&mut caller_mir);\n+        // Simplify if we inlined anything.\n+        if changed {\n+            debug!(\"Running simplify cfg on {:?}\", self.source);\n+            CfgSimplifier::new(caller_mir).simplify();\n+            remove_dead_blocks(caller_mir);\n         }\n-        changed\n     }\n \n-    fn should_inline(&self, callsite: CallSite<'tcx>,\n-                     callee_mir: &'a Mir<'tcx>) -> bool {\n-\n+    fn should_inline(&self,\n+                     callsite: CallSite<'tcx>,\n+                     callee_mir: &Mir<'tcx>)\n+                     -> bool\n+    {\n         let tcx = self.tcx;\n \n         // Don't inline closures that have captures\n@@ -323,8 +219,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         // FIXME: Give a bonus to functions with only a single caller\n \n-        let id = tcx.hir.as_local_node_id(callsite.caller).expect(\"Caller not local\");\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, self.source.item_id());\n \n         let mut first_block = true;\n         let mut cost = 0;\n@@ -423,22 +318,15 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-\n-    fn inline_call(&self, callsite: CallSite<'tcx>,\n-                             caller_mir: &mut Mir<'tcx>, mut callee_mir: Mir<'tcx>) -> bool {\n-\n-        // Don't inline a function into itself\n-        if callsite.caller == callsite.callee { return false; }\n-\n-        let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n-\n-\n+    fn inline_call(&self,\n+                   callsite: CallSite<'tcx>,\n+                   caller_mir: &mut Mir<'tcx>,\n+                   mut callee_mir: Mir<'tcx>) -> bool {\n         let terminator = caller_mir[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n-\n-                debug!(\"Inlined {:?} into {:?}\", callsite.callee, callsite.caller);\n+                debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n                 let is_box_free = Some(callsite.callee) == self.tcx.lang_items.box_free_fn();\n "}, {"sha": "88a368077d4f5e94248dc4e15bcec93ed2a29cff", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -11,32 +11,20 @@\n //! Performs various peephole optimizations.\n \n use rustc::mir::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n \n-pub struct InstCombine {\n-    optimizations: OptimizationList,\n-}\n-\n-impl InstCombine {\n-    pub fn new() -> InstCombine {\n-        InstCombine {\n-            optimizations: OptimizationList::default(),\n-        }\n-    }\n-}\n-\n-impl Pass for InstCombine {}\n+pub struct InstCombine;\n \n-impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource,\n-                    mir: &mut Mir<'tcx>) {\n+impl MirPass for InstCombine {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -45,18 +33,22 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Lvalue::ty()`).\n-        {\n+        let optimizations = {\n             let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n             optimization_finder.visit_mir(mir);\n-            self.optimizations = optimization_finder.optimizations\n-        }\n+            optimization_finder.optimizations\n+        };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_mir(&mut *self, mir);\n+        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations }, mir);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for InstCombine {\n+pub struct InstCombineVisitor {\n+    optimizations: OptimizationList,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);"}, {"sha": "fcea5d4c86047cc6e05a5dd9fd4b2d34f6fa6b2e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -8,6 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use build;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::mir::Mir;\n+use rustc::mir::transform::{MirPassIndex, MirSuite, MirSource,\n+                            MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::maps::Providers;\n+use rustc::ty::steal::Steal;\n+use rustc::hir;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::util::nodemap::DefIdSet;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax_pos::{DUMMY_SP, Span};\n+use transform;\n+\n pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n@@ -21,3 +37,114 @@ pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n pub mod inline;\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    self::qualify_consts::provide(providers);\n+    *providers = Providers {\n+        mir_keys,\n+        mir_const,\n+        mir_validated,\n+        optimized_mir,\n+        is_mir_available,\n+        ..*providers\n+    };\n+}\n+\n+fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    tcx.mir_keys(def_id.krate).contains(&def_id)\n+}\n+\n+/// Finds the full set of def-ids within the current crate that have\n+/// MIR associated with them.\n+fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n+                      -> Rc<DefIdSet> {\n+    assert_eq!(krate, LOCAL_CRATE);\n+\n+    let mut set = DefIdSet();\n+\n+    // All body-owners have MIR associated with them.\n+    set.extend(tcx.body_owners());\n+\n+    // Additionally, tuple struct/variant constructors have MIR, but\n+    // they don't have a BodyId, so we need to build them separately.\n+    struct GatherCtors<'a, 'tcx: 'a> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        set: &'a mut DefIdSet,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n+        fn visit_variant_data(&mut self,\n+                              v: &'tcx hir::VariantData,\n+                              _: ast::Name,\n+                              _: &'tcx hir::Generics,\n+                              _: ast::NodeId,\n+                              _: Span) {\n+            if let hir::VariantData::Tuple(_, node_id) = *v {\n+                self.set.insert(self.tcx.hir.local_def_id(node_id));\n+            }\n+            intravisit::walk_struct_def(self, v)\n+        }\n+        fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+    tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n+        tcx: tcx,\n+        set: &mut set,\n+    }.as_deep_visitor());\n+\n+    Rc::new(set)\n+}\n+\n+fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let mut mir = build::mir_build(tcx, def_id);\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    transform::run_suite(tcx, source, MIR_CONST, &mut mir);\n+    tcx.alloc_steal_mir(mir)\n+}\n+\n+fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    if let MirSource::Const(_) = source {\n+        // Ensure that we compute the `mir_const_qualif` for constants at\n+        // this point, before we steal the mir-const result. We don't\n+        // directly need the result or `mir_const_qualif`, so we can just force it.\n+        ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n+    }\n+\n+    let mut mir = tcx.mir_const(def_id).steal();\n+    transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);\n+    tcx.alloc_steal_mir(mir)\n+}\n+\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n+    // Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    ty::queries::borrowck::force(tcx, DUMMY_SP, def_id);\n+\n+    let mut mir = tcx.mir_validated(def_id).steal();\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    transform::run_suite(tcx, source, MIR_OPTIMIZED, &mut mir);\n+    tcx.alloc_mir(mir)\n+}\n+\n+fn run_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       source: MirSource,\n+                       suite: MirSuite,\n+                       mir: &mut Mir<'tcx>)\n+{\n+    let passes = tcx.mir_passes.passes(suite);\n+\n+    for (pass, index) in passes.iter().zip(0..) {\n+        let pass_num = MirPassIndex(index);\n+\n+        for hook in tcx.mir_passes.hooks() {\n+            hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, false);\n+        }\n+\n+        pass.run_pass(tcx, source, mir);\n+\n+        for hook in tcx.mir_passes.hooks() {\n+            hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, true);\n+        }\n+    }\n+}"}, {"sha": "8595663ba18c4ea4051feaffa15dcd975f039ab3", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -14,10 +14,25 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{MirPass, MirSource};\n \n pub struct NoLandingPads;\n \n+impl MirPass for NoLandingPads {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        no_landing_pads(tcx, mir)\n+    }\n+}\n+\n+pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+    if tcx.sess.no_landing_pads() {\n+        NoLandingPads.visit_mir(mir);\n+    }\n+}\n+\n impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n     fn visit_terminator(&mut self,\n                         bb: BasicBlock,\n@@ -41,18 +56,3 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n         self.super_terminator(bb, terminator, location);\n     }\n }\n-\n-pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n-    if tcx.sess.no_landing_pads() {\n-        NoLandingPads.visit_mir(mir);\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n-        no_landing_pads(tcx, mir)\n-    }\n-}\n-\n-impl Pass for NoLandingPads {}"}, {"sha": "4b1c82f383f85ce1a638dc2e048b0980f1af43a3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 19, "deletions": 46, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -16,7 +16,6 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -27,7 +26,7 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n@@ -919,13 +918,21 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    providers.mir_const_qualif = qualify_const_item;\n+    *providers = Providers {\n+        mir_const_qualif,\n+        ..*providers\n+    };\n }\n \n-fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> u8 {\n-    let mir = &tcx.item_mir(def_id);\n+fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> u8 {\n+    // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n+    // cannot yet be stolen), because `mir_validated()`, which steals\n+    // from `mir_const(), forces this query to execute before\n+    // performing the steal.\n+    let mir = &tcx.mir_const(def_id).borrow();\n+\n     if mir.return_ty.references_error() {\n         return Qualif::NOT_CONST.bits();\n     }\n@@ -939,45 +946,11 @@ fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct QualifyAndPromoteConstants;\n \n-impl Pass for QualifyAndPromoteConstants {}\n-\n-impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n-    {\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-        for def_id in def_ids {\n-            if !def_id.is_local() {\n-                continue;\n-            }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            if let MirSource::Const(_) = src {\n-                tcx.mir_const_qualif(def_id);\n-                continue;\n-            }\n-\n-            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, false);\n-            }\n-            self.run_pass(tcx, src, mir);\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, true);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for QualifyAndPromoteConstants {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n         let def_id = tcx.hir.local_def_id(id);\n         let mode = match src {"}, {"sha": "d5b79c0d1c3829595379951c9e6f199fcddf4bd8", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -41,15 +41,15 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::{MutVisitor, Visitor, LvalueContext};\n-use std::fmt;\n+use std::borrow::Cow;\n \n-pub struct SimplifyCfg<'a> { label: &'a str }\n+pub struct SimplifyCfg { label: String }\n \n-impl<'a> SimplifyCfg<'a> {\n-    pub fn new(label: &'a str) -> Self {\n-        SimplifyCfg { label: label }\n+impl SimplifyCfg {\n+    pub fn new(label: &str) -> Self {\n+        SimplifyCfg { label: format!(\"SimplifyCfg-{}\", label) }\n     }\n }\n \n@@ -61,20 +61,18 @@ pub fn simplify_cfg(mir: &mut Mir) {\n     mir.basic_blocks_mut().raw.shrink_to_fit();\n }\n \n-impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n-        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n-        simplify_cfg(mir);\n+impl MirPass for SimplifyCfg {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        Cow::Borrowed(&self.label)\n     }\n-}\n \n-impl<'l> Pass for SimplifyCfg<'l> {\n-    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n-        Some(Box::new(self.label))\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n+        simplify_cfg(mir);\n     }\n-\n-    // avoid calling `type_name` - it contains `<'static>`\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyCfg\".into() }\n }\n \n pub struct CfgSimplifier<'a, 'tcx: 'a> {\n@@ -315,12 +313,11 @@ pub fn remove_dead_blocks(mir: &mut Mir) {\n \n pub struct SimplifyLocals;\n \n-impl Pass for SimplifyLocals {\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyLocals\".into() }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for SimplifyLocals {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live"}, {"sha": "d21a6ddfdfb970c85b57276238399370133ddeff", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -12,21 +12,28 @@\n \n use rustc::ty::TyCtxt;\n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::*;\n \n-use std::fmt;\n+use std::borrow::Cow;\n \n-pub struct SimplifyBranches<'a> { label: &'a str }\n+pub struct SimplifyBranches { label: String }\n \n-impl<'a> SimplifyBranches<'a> {\n-    pub fn new(label: &'a str) -> Self {\n-        SimplifyBranches { label: label }\n+impl SimplifyBranches {\n+    pub fn new(label: &str) -> Self {\n+        SimplifyBranches { label: format!(\"SimplifyBranches-{}\", label) }\n     }\n }\n \n-impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for SimplifyBranches {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        Cow::Borrowed(&self.label)\n+    }\n+\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         for block in mir.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n@@ -60,11 +67,3 @@ impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n     }\n }\n \n-impl<'l> Pass for SimplifyBranches<'l> {\n-    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n-        Some(Box::new(self.label))\n-    }\n-\n-    // avoid calling `type_name` - it contains `<'static>`\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyBranches\".into() }\n-}"}, {"sha": "b325470ec818cadcd33f6dd3309ec408400a5351", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::Visitor;\n use std::fmt;\n use syntax::ast;\n@@ -737,9 +737,11 @@ impl TypeckMir {\n     }\n }\n \n-impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for TypeckMir {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let item_id = src.item_id();\n         let def_id = tcx.hir.local_def_id(item_id);\n         debug!(\"run_pass: {}\", tcx.item_path_str(def_id));\n@@ -765,6 +767,3 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n         });\n     }\n }\n-\n-impl Pass for TypeckMir {\n-}"}, {"sha": "cf13a80e677b1266bac748cd8cfd43360ff00758", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -18,16 +18,18 @@ use syntax::ast::NodeId;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n+use super::pretty::dump_mir_def_ids;\n+\n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                                              iter: I,\n-                                              w: &mut W)\n-                                              -> io::Result<()>\n-    where W: Write, I: Iterator<Item=DefId>\n+pub fn write_mir_graphviz<'a, 'tcx, W>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       single: Option<DefId>,\n+                                       w: &mut W)\n+                                       -> io::Result<()>\n+    where W: Write\n {\n-    for def_id in iter {\n+    for def_id in dump_mir_def_ids(tcx, single) {\n         let nodeid = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let mir = &tcx.item_mir(def_id);\n+        let mir = &tcx.optimized_mir(def_id);\n \n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n "}, {"sha": "4386bab38c0399650bb461a6a6d7cfc16cacedbe", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -15,6 +15,6 @@ pub mod patch;\n mod graphviz;\n mod pretty;\n \n-pub use self::pretty::{dump_mir, write_mir_pretty};\n+pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n pub use self::graphviz::{write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "5f51888019b9d2cd2f34b1d4ba2e4a55d8b08077", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n-use rustc::mir::transform::MirSource;\n+use rustc::mir::transform::{MirSuite, MirPassIndex, MirSource};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n@@ -28,7 +28,7 @@ const ALIGN: usize = 40;\n /// representation of the mir into:\n ///\n /// ```text\n-/// rustc.node<node_id>.<pass_name>.<disambiguator>\n+/// rustc.node<node_id>.<pass_num>.<pass_name>.<disambiguator>\n /// ```\n ///\n /// Output from this function is controlled by passing `-Z dump-mir=<filter>`,\n@@ -39,64 +39,95 @@ const ALIGN: usize = 40;\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          pass_num: Option<(MirSuite, MirPassIndex)>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n-                          src: MirSource,\n+                          source: MirSource,\n                           mir: &Mir<'tcx>) {\n+    if !dump_enabled(tcx, pass_name, source) {\n+        return;\n+    }\n+\n+    let node_path = tcx.item_path_str(tcx.hir.local_def_id(source.item_id()));\n+    dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n+                          disambiguator, source, mir);\n+    for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n+        let promoted_source = MirSource::Promoted(source.item_id(), index);\n+        dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator,\n+                              promoted_source, promoted_mir);\n+    }\n+}\n+\n+pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              pass_name: &str,\n+                              source: MirSource)\n+                              -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n-        None => return,\n+        None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_id = src.item_id();\n+    let node_id = source.item_id();\n     let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n-    let is_matched =\n-        filters.split(\"&\")\n-               .any(|filter| {\n-                   filter == \"all\" ||\n-                       pass_name.contains(filter) ||\n-                       node_path.contains(filter)\n-               });\n-    if !is_matched {\n-        return;\n-    }\n+    filters.split(\"&\")\n+           .any(|filter| {\n+               filter == \"all\" ||\n+                   pass_name.contains(filter) ||\n+                   node_path.contains(filter)\n+           })\n+}\n \n-    let promotion_id = match src {\n+fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                   pass_name: &str,\n+                                   node_path: &str,\n+                                   disambiguator: &Display,\n+                                   source: MirSource,\n+                                   mir: &Mir<'tcx>) {\n+    let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n         _ => String::new()\n     };\n \n+    let pass_num = if tcx.sess.opts.debugging_opts.dump_mir_exclude_pass_number {\n+        format!(\"\")\n+    } else {\n+        match pass_num {\n+            None => format!(\".-------\"),\n+            Some((suite, pass_num)) => format!(\".{:03}-{:03}\", suite.0, pass_num.0),\n+        }\n+    };\n+\n     let mut file_path = PathBuf::new();\n     if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n         let p = Path::new(file_dir);\n         file_path.push(p);\n     };\n-    let file_name = format!(\"rustc.node{}{}.{}.{}.mir\",\n-                            node_id, promotion_id, pass_name, disambiguator);\n+    let file_name = format!(\"rustc.node{}{}{}.{}.{}.mir\",\n+                            source.item_id(), promotion_id, pass_num, pass_name, disambiguator);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {\n         writeln!(file, \"// MIR for `{}`\", node_path)?;\n-        writeln!(file, \"// node_id = {}\", node_id)?;\n+        writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, src, mir, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut file)?;\n         Ok(())\n     });\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                                         iter: I,\n-                                         w: &mut Write)\n-                                         -> io::Result<()>\n-    where I: Iterator<Item=DefId>, 'tcx: 'a\n+pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  single: Option<DefId>,\n+                                  w: &mut Write)\n+                                  -> io::Result<()>\n {\n     writeln!(w, \"// WARNING: This output format is intended for human consumers only\")?;\n     writeln!(w, \"// and is subject to change without notice. Knock yourself out.\")?;\n \n     let mut first = true;\n-    for def_id in iter.filter(DefId::is_local) {\n-        let mir = &tcx.item_mir(def_id);\n+    for def_id in dump_mir_def_ids(tcx, single) {\n+        let mir = &tcx.optimized_mir(def_id);\n \n         if first {\n             first = false;\n@@ -312,3 +343,11 @@ fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n \n     Ok(())\n }\n+\n+pub fn dump_mir_def_ids(tcx: TyCtxt, single: Option<DefId>) -> Vec<DefId> {\n+    if let Some(i) = single {\n+        vec![i]\n+    } else {\n+        tcx.mir_keys(LOCAL_CRATE).iter().cloned().collect()\n+    }\n+}"}, {"sha": "d9921e62330b95e1fa098a7f39b60540641af3c5", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -13,6 +13,7 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n@@ -44,10 +45,9 @@ pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n     // For debugging instrumentation like this, we don't need to worry\n     // about maintaining the dep graph.\n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mir_map = tcx.maps.mir.borrow();\n-    for def_id in mir_map.keys() {\n-        let mir = mir_map.get(&def_id).unwrap();\n-        collector.visit_mir(&mir.borrow());\n+    for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n+        let mir = tcx.optimized_mir(def_id);\n+        collector.visit_mir(&mir);\n     }\n     collector.print(title);\n }"}, {"sha": "6d7d95f54872105ea12b790ee9cd1b8e656777a8", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -659,7 +659,7 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n                 // in this crate\n                 false\n             } else {\n-                if !tcx.is_item_mir_available(def_id) {\n+                if !tcx.is_mir_available(def_id) {\n                     bug!(\"Cannot create local trans-item for {:?}\", def_id)\n                 }\n                 true"}, {"sha": "11095e70f621c6e699a17e60d92d0f382f0dacda", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -640,9 +640,9 @@ pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> CompileResult {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.sess.track_errors(|| {\n-        tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+        for body_owner_def_id in tcx.body_owners() {\n             tcx.typeck_tables_of(body_owner_def_id);\n-        });\n+        }\n     })\n }\n "}, {"sha": "e4eb1aeaf9be2db8e2576179d558ce6f0c49536d", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -36,7 +36,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.SimplifyCfg.initial-after.mir\n+// START rustc.node4.SimplifyCfg-initial.after.mir\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const false;\n@@ -82,4 +82,4 @@ fn main() {\n //         StorageDead(_1);\n //         return;\n //     }\n-// END rustc.node4.SimplifyCfg.initial-after.mir\n+// END rustc.node4.SimplifyCfg-initial.after.mir"}, {"sha": "5a9336e96592d6a287eb159eb6d667375622497d", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -21,7 +21,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.SimplifyCfg.initial-after.mir\n+// START rustc.node4.SimplifyCfg-initial.after.mir\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const false;\n@@ -48,4 +48,4 @@ fn main() {\n //         _2 = ();\n //         goto -> bb1;\n //     }\n-// END rustc.node4.SimplifyCfg.initial-after.mir\n+// END rustc.node4.SimplifyCfg-initial.after.mir"}, {"sha": "cff108246a550da31dd2e116b4460b8409e1f2fc", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -15,13 +15,13 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.SimplifyBranches.initial-before.mir\n+// START rustc.node4.SimplifyBranches-initial.before.mir\n // bb0: {\n //     switchInt(const false) -> [0u8: bb2, otherwise: bb1];\n // }\n-// END rustc.node4.SimplifyBranches.initial-before.mir\n-// START rustc.node4.SimplifyBranches.initial-after.mir\n+// END rustc.node4.SimplifyBranches-initial.before.mir\n+// START rustc.node4.SimplifyBranches-initial.after.mir\n // bb0: {\n //     goto -> bb2;\n // }\n-// END rustc.node4.SimplifyBranches.initial-after.mir\n+// END rustc.node4.SimplifyBranches-initial.after.mir"}, {"sha": "a044282666da0a7ec100086b2927bdf097f3c3c9", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfff3699aa33e0de8000b93146a0e218208a39c1/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=cfff3699aa33e0de8000b93146a0e218208a39c1", "patch": "@@ -1402,18 +1402,16 @@ actual:\\n\\\n                 }\n             }\n             MirOpt => {\n-                args.extend([\"-Z\",\n-                             \"dump-mir=all\",\n-                             \"-Z\",\n-                             \"mir-opt-level=3\",\n-                             \"-Z\"]\n+                args.extend([\"-Zdump-mir=all\",\n+                             \"-Zmir-opt-level=3\",\n+                             \"-Zdump-mir-exclude-pass-number\"]\n                             .iter()\n                             .map(|s| s.to_string()));\n \n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n                 create_dir_all(mir_dump_dir.as_path()).unwrap();\n-                let mut dir_opt = \"dump-mir-dir=\".to_string();\n+                let mut dir_opt = \"-Zdump-mir-dir=\".to_string();\n                 dir_opt.push_str(mir_dump_dir.to_str().unwrap());\n                 debug!(\"dir_opt: {:?}\", dir_opt);\n "}]}