{"sha": "9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTkxZTEyNDM0YmRmM2NkYzZjNDAyN2EwZDBiMzlhYzA1MTk2ZDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-12T20:44:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-13T00:57:26Z"}, "message": "librustdoc: Remove all `~str` usage from librustdoc.", "tree": {"sha": "44c8d96c7c9e629dadeae31b69694c96b9a910b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44c8d96c7c9e629dadeae31b69694c96b9a910b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "html_url": "https://github.com/rust-lang/rust/commit/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "html_url": "https://github.com/rust-lang/rust/commit/6559a3675e021c9e8a416fc0d9ef416ddfda2f13"}], "stats": {"total": 618, "additions": 357, "deletions": 261}, "files": [{"sha": "4439f626b2ce12a2fc9f95069bedb81f3f6c04d9", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -69,7 +69,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Crate {\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n }\n@@ -92,7 +92,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         let id = link::find_crate_id(self.attrs.as_slice(),\n                                      t_outputs.out_filestem.as_slice());\n         Crate {\n-            name: id.name.to_owned(),\n+            name: id.name.to_strbuf(),\n             module: Some(self.module.clean()),\n             externs: externs,\n         }\n@@ -101,14 +101,14 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct ExternalCrate {\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub attrs: Vec<Attribute>,\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n     fn clean(&self) -> ExternalCrate {\n         ExternalCrate {\n-            name: self.name.to_owned(),\n+            name: self.name.to_strbuf(),\n             attrs: decoder::get_crate_attributes(self.data()).clean()\n                                                              .move_iter()\n                                                              .collect(),\n@@ -124,7 +124,7 @@ pub struct Item {\n     /// Stringified span\n     pub source: Span,\n     /// Not everything has a name. E.g., impls\n-    pub name: Option<~str>,\n+    pub name: Option<StrBuf>,\n     pub attrs: Vec<Attribute> ,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n@@ -137,7 +137,9 @@ impl Item {\n     pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n         for attr in self.attrs.iter() {\n             match *attr {\n-                List(ref x, ref list) if \"doc\" == *x => { return Some(list.as_slice()); }\n+                List(ref x, ref list) if \"doc\" == x.as_slice() => {\n+                    return Some(list.as_slice());\n+                }\n                 _ => {}\n             }\n         }\n@@ -149,7 +151,9 @@ impl Item {\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n         for attr in self.attrs.iter() {\n             match *attr {\n-                NameValue(ref x, ref v) if \"doc\" == *x => { return Some(v.as_slice()); }\n+                NameValue(ref x, ref v) if \"doc\" == x.as_slice() => {\n+                    return Some(v.as_slice());\n+                }\n                 _ => {}\n             }\n         }\n@@ -161,7 +165,9 @@ impl Item {\n             Some(ref l) => {\n                 for innerattr in l.iter() {\n                     match *innerattr {\n-                        Word(ref s) if \"hidden\" == *s => return true,\n+                        Word(ref s) if \"hidden\" == s.as_slice() => {\n+                            return true\n+                        }\n                         _ => (),\n                     }\n                 }\n@@ -225,7 +231,7 @@ impl Clean<Item> for doctree::Module {\n         let name = if self.name.is_some() {\n             self.name.unwrap().clean()\n         } else {\n-            \"\".to_owned()\n+            \"\".to_strbuf()\n         };\n         let mut foreigns = Vec::new();\n         for subforeigns in self.foreigns.clean().move_iter() {\n@@ -281,20 +287,20 @@ impl Clean<Item> for doctree::Module {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum Attribute {\n-    Word(~str),\n-    List(~str, Vec<Attribute> ),\n-    NameValue(~str, ~str)\n+    Word(StrBuf),\n+    List(StrBuf, Vec<Attribute> ),\n+    NameValue(StrBuf, StrBuf)\n }\n \n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self) -> Attribute {\n         match self.node {\n-            ast::MetaWord(ref s) => Word(s.get().to_owned()),\n+            ast::MetaWord(ref s) => Word(s.get().to_strbuf()),\n             ast::MetaList(ref s, ref l) => {\n-                List(s.get().to_owned(), l.clean().move_iter().collect())\n+                List(s.get().to_strbuf(), l.clean().move_iter().collect())\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n-                NameValue(s.get().to_owned(), lit_to_str(v))\n+                NameValue(s.get().to_strbuf(), lit_to_str(v))\n             }\n         }\n     }\n@@ -311,14 +317,16 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString {\n         match **self {\n             Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n-                token::intern_and_get_ident(*n)\n+                token::intern_and_get_ident(n.as_slice())\n             }\n         }\n     }\n \n     fn value_str(&self) -> Option<InternedString> {\n         match **self {\n-            NameValue(_, ref v) => Some(token::intern_and_get_ident(*v)),\n+            NameValue(_, ref v) => {\n+                Some(token::intern_and_get_ident(v.as_slice()))\n+            }\n             _ => None,\n         }\n     }\n@@ -330,7 +338,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyParam {\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub id: ast::NodeId,\n     pub bounds: Vec<TyParamBound>,\n }\n@@ -362,19 +370,19 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub struct Lifetime(~str);\n+pub struct Lifetime(StrBuf);\n \n impl Lifetime {\n     pub fn get_ref<'a>(&'a self) -> &'a str {\n         let Lifetime(ref s) = *self;\n-        let s: &'a str = *s;\n+        let s: &'a str = s.as_slice();\n         return s;\n     }\n }\n \n impl Clean<Lifetime> for ast::Lifetime {\n     fn clean(&self) -> Lifetime {\n-        Lifetime(token::get_name(self.name).get().to_owned())\n+        Lifetime(token::get_name(self.name).get().to_strbuf())\n     }\n }\n \n@@ -566,7 +574,7 @@ impl Clean<FnDecl> for ast::FnDecl {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Argument {\n     pub type_: Type,\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub id: ast::NodeId,\n }\n \n@@ -687,7 +695,7 @@ pub enum Type {\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Vector(Box<Type>),\n-    FixedVector(Box<Type>, ~str),\n+    FixedVector(Box<Type>, StrBuf),\n     String,\n     Bool,\n     /// aka TyNil\n@@ -890,7 +898,7 @@ impl Clean<VariantKind> for ast::VariantKind {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Span {\n-    pub filename: ~str,\n+    pub filename: StrBuf,\n     pub loline: uint,\n     pub locol: uint,\n     pub hiline: uint,\n@@ -905,7 +913,7 @@ impl Clean<Span> for syntax::codemap::Span {\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n         Span {\n-            filename: filename.to_owned(),\n+            filename: filename.to_strbuf(),\n             loline: lo.line,\n             locol: lo.col.to_uint(),\n             hiline: hi.line,\n@@ -931,7 +939,7 @@ impl Clean<Path> for ast::Path {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct PathSegment {\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub lifetimes: Vec<Lifetime>,\n     pub types: Vec<Type>,\n }\n@@ -946,7 +954,7 @@ impl Clean<PathSegment> for ast::PathSegment {\n     }\n }\n \n-fn path_to_str(p: &ast::Path) -> ~str {\n+fn path_to_str(p: &ast::Path) -> StrBuf {\n     use syntax::parse::token;\n \n     let mut s = StrBuf::new();\n@@ -959,12 +967,12 @@ fn path_to_str(p: &ast::Path) -> ~str {\n         }\n         s.push_str(i.get());\n     }\n-    s.into_owned()\n+    s\n }\n \n-impl Clean<~str> for ast::Ident {\n-    fn clean(&self) -> ~str {\n-        token::get_ident(*self).get().to_owned()\n+impl Clean<StrBuf> for ast::Ident {\n+    fn clean(&self) -> StrBuf {\n+        token::get_ident(*self).get().to_strbuf()\n     }\n }\n \n@@ -995,7 +1003,7 @@ pub struct BareFunctionDecl {\n     pub fn_style: ast::FnStyle,\n     pub generics: Generics,\n     pub decl: FnDecl,\n-    pub abi: ~str,\n+    pub abi: StrBuf,\n }\n \n impl Clean<BareFunctionDecl> for ast::BareFnTy {\n@@ -1007,7 +1015,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n                 type_params: Vec::new(),\n             },\n             decl: self.decl.clean(),\n-            abi: self.abi.to_str(),\n+            abi: self.abi.to_str().to_strbuf(),\n         }\n     }\n }\n@@ -1019,7 +1027,7 @@ pub struct Static {\n     /// It's useful to have the value of a static documented, but I have no\n     /// desire to represent expressions (that'd basically be all of the AST,\n     /// which is huge!). So, have a string.\n-    pub expr: ~str,\n+    pub expr: StrBuf,\n }\n \n impl Clean<Item> for doctree::Static {\n@@ -1116,7 +1124,7 @@ impl Clean<Item> for ast::ViewItem {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewItemInner {\n-    ExternCrate(~str, Option<~str>, ast::NodeId),\n+    ExternCrate(StrBuf, Option<StrBuf>, ast::NodeId),\n     Import(ViewPath)\n }\n \n@@ -1126,7 +1134,7 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n             &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n                 let string = match *p {\n                     None => None,\n-                    Some((ref x, _)) => Some(x.get().to_owned()),\n+                    Some((ref x, _)) => Some(x.get().to_strbuf()),\n                 };\n                 ExternCrate(i.clean(), string, *id)\n             }\n@@ -1140,7 +1148,7 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewPath {\n     // use str = source;\n-    SimpleImport(~str, ImportSource),\n+    SimpleImport(StrBuf, ImportSource),\n     // use source::*;\n     GlobImport(ImportSource),\n     // use source::{a, b, c};\n@@ -1170,7 +1178,7 @@ impl Clean<ViewPath> for ast::ViewPath {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct ViewListIdent {\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub source: Option<ast::DefId>,\n }\n \n@@ -1203,7 +1211,7 @@ impl Clean<Item> for ast::ForeignItem {\n                 ForeignStaticItem(Static {\n                     type_: ty.clean(),\n                     mutability: if mutbl {Mutable} else {Immutable},\n-                    expr: \"\".to_owned(),\n+                    expr: \"\".to_strbuf(),\n                 })\n             }\n         };\n@@ -1221,56 +1229,56 @@ impl Clean<Item> for ast::ForeignItem {\n // Utilities\n \n trait ToSource {\n-    fn to_src(&self) -> ~str;\n+    fn to_src(&self) -> StrBuf;\n }\n \n impl ToSource for syntax::codemap::Span {\n-    fn to_src(&self) -> ~str {\n+    fn to_src(&self) -> StrBuf {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n         let ctxt = super::ctxtkey.get().unwrap();\n         let cm = ctxt.sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n-            Some(x) => x.to_owned(),\n-            None    => \"\".to_owned()\n+            Some(x) => x.to_strbuf(),\n+            None    => \"\".to_strbuf()\n         };\n         debug!(\"got snippet {}\", sn);\n         sn\n     }\n }\n \n-fn lit_to_str(lit: &ast::Lit) -> ~str {\n+fn lit_to_str(lit: &ast::Lit) -> StrBuf {\n     match lit.node {\n-        ast::LitStr(ref st, _) => st.get().to_owned(),\n-        ast::LitBinary(ref data) => format!(\"{:?}\", data.as_slice()),\n-        ast::LitChar(c) => format!(\"'{}'\", c),\n-        ast::LitInt(i, _t) => i.to_str(),\n-        ast::LitUint(u, _t) => u.to_str(),\n-        ast::LitIntUnsuffixed(i) => i.to_str(),\n-        ast::LitFloat(ref f, _t) => f.get().to_str(),\n-        ast::LitFloatUnsuffixed(ref f) => f.get().to_str(),\n-        ast::LitBool(b) => b.to_str(),\n-        ast::LitNil => \"\".to_owned(),\n+        ast::LitStr(ref st, _) => st.get().to_strbuf(),\n+        ast::LitBinary(ref data) => format_strbuf!(\"{:?}\", data.as_slice()),\n+        ast::LitChar(c) => format_strbuf!(\"'{}'\", c),\n+        ast::LitInt(i, _t) => i.to_str().to_strbuf(),\n+        ast::LitUint(u, _t) => u.to_str().to_strbuf(),\n+        ast::LitIntUnsuffixed(i) => i.to_str().to_strbuf(),\n+        ast::LitFloat(ref f, _t) => f.get().to_strbuf(),\n+        ast::LitFloatUnsuffixed(ref f) => f.get().to_strbuf(),\n+        ast::LitBool(b) => b.to_str().to_strbuf(),\n+        ast::LitNil => \"\".to_strbuf(),\n     }\n }\n \n-fn name_from_pat(p: &ast::Pat) -> ~str {\n+fn name_from_pat(p: &ast::Pat) -> StrBuf {\n     use syntax::ast::*;\n     debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n     match p.node {\n-        PatWild => \"_\".to_owned(),\n-        PatWildMulti => \"..\".to_owned(),\n+        PatWild => \"_\".to_strbuf(),\n+        PatWildMulti => \"..\".to_strbuf(),\n         PatIdent(_, ref p, _) => path_to_str(p),\n         PatEnum(ref p, _) => path_to_str(p),\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n-        PatTup(..) => \"(tuple arg NYI)\".to_owned(),\n+        PatTup(..) => \"(tuple arg NYI)\".to_strbuf(),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");\n-            \"()\".to_owned()\n+            \"()\".to_strbuf()\n         },\n         PatRange(..) => fail!(\"tried to get argument name from PatRange, \\\n                               which is not allowed in function arguments\"),\n@@ -1326,7 +1334,7 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n         core::NotTyped(_) => return did\n     };\n     let fqn = csearch::get_item_path(tcx, did);\n-    let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n+    let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n     debug!(\"recording {} => {}\", did, fqn);\n     cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n     return did;\n@@ -1351,13 +1359,13 @@ fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Macro {\n-    pub source: ~str,\n+    pub source: StrBuf,\n }\n \n impl Clean<Item> for doctree::Macro {\n     fn clean(&self) -> Item {\n         Item {\n-            name: Some(self.name.clean() + \"!\"),\n+            name: Some(format_strbuf!(\"{}!\", self.name.clean())),\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: ast::Public.clean(),"}, {"sha": "2f6f16a4ed44bea7499e6a16e8101321bdd3c891", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -32,7 +32,7 @@ pub enum MaybeTyped {\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n-                                                (Vec<~str>, clean::TypeKind)>>>;\n+                                                (Vec<StrBuf>, clean::TypeKind)>>>;\n \n pub struct DocContext {\n     pub krate: ast::Crate,\n@@ -57,7 +57,7 @@ pub struct CrateAnalysis {\n }\n \n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n+fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<StrBuf>)\n                        -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n@@ -88,7 +88,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n \n     let mut cfg = build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n-        let cfg_ = token::intern_and_get_ident(cfg_);\n+        let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n         cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n@@ -112,7 +112,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n     })\n }\n \n-pub fn run_core(libs: HashSet<Path>, cfgs: Vec<~str>, path: &Path)\n+pub fn run_core(libs: HashSet<Path>, cfgs: Vec<StrBuf>, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;"}, {"sha": "342b96ba82f50c3f2599a539616fc93ff6f6bdf1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -151,11 +151,13 @@ fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n     path(w, p, print_all,\n         |cache, loc| {\n             if ast_util::is_local(did) {\n-                Some(\"../\".repeat(loc.len()))\n+                Some((\"../\".repeat(loc.len())).to_strbuf())\n             } else {\n                 match *cache.extern_locations.get(&did.krate) {\n-                    render::Remote(ref s) => Some(s.clone()),\n-                    render::Local => Some(\"../\".repeat(loc.len())),\n+                    render::Remote(ref s) => Some(s.to_strbuf()),\n+                    render::Local => {\n+                        Some((\"../\".repeat(loc.len())).to_strbuf())\n+                    }\n                     render::Unknown => None,\n                 }\n             }\n@@ -169,8 +171,8 @@ fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n }\n \n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n-        root: |&render::Cache, &[~str]| -> Option<~str>,\n-        info: |&render::Cache| -> Option<(Vec<~str> , ItemType)>)\n+        root: |&render::Cache, &[StrBuf]| -> Option<StrBuf>,\n+        info: |&render::Cache| -> Option<(Vec<StrBuf> , ItemType)>)\n     -> fmt::Result\n {\n     // The generics will get written to both the title and link\n@@ -206,10 +208,11 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n             Some(root) => {\n                 let mut root = StrBuf::from_str(root);\n                 for seg in path.segments.slice_to(amt).iter() {\n-                    if \"super\" == seg.name || \"self\" == seg.name {\n+                    if \"super\" == seg.name.as_slice() ||\n+                            \"self\" == seg.name.as_slice() {\n                         try!(write!(w, \"{}::\", seg.name));\n                     } else {\n-                        root.push_str(seg.name);\n+                        root.push_str(seg.name.as_slice());\n                         root.push_str(\"/\");\n                         try!(write!(w, \"<a class='mod'\n                                             href='{}index.html'>{}</a>::\",\n@@ -229,21 +232,21 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     match info(&**cache) {\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n-            let mut url = StrBuf::from_str(abs_root.unwrap());\n+            let mut url = StrBuf::from_str(abs_root.unwrap().as_slice());\n             let to_link = fqp.slice_to(fqp.len() - 1);\n             for component in to_link.iter() {\n-                url.push_str(*component);\n+                url.push_str(component.as_slice());\n                 url.push_str(\"/\");\n             }\n             match shortty {\n                 item_type::Module => {\n-                    url.push_str(*fqp.last().unwrap());\n+                    url.push_str(fqp.last().unwrap().as_slice());\n                     url.push_str(\"/index.html\");\n                 }\n                 _ => {\n                     url.push_str(shortty.to_static_str());\n                     url.push_str(\".\");\n-                    url.push_str(*fqp.last().unwrap());\n+                    url.push_str(fqp.last().unwrap().as_slice());\n                     url.push_str(\".html\");\n                 }\n             }\n@@ -352,16 +355,20 @@ impl fmt::Show for clean::Type {\n                                {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n-                           \"\".to_owned()\n+                           \"\".to_strbuf()\n                        } else {\n-                           format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n+                           format_strbuf!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n                        bounds = if decl.bounds.len() == 0 {\n-                           \"\".to_owned()\n+                           \"\".to_strbuf()\n                        } else {\n-                           let mut m = decl.bounds.iter().map(|s| s.to_str());\n-                           \": \" + m.collect::<Vec<~str>>().connect(\" + \")\n+                           let mut m = decl.bounds\n+                                           .iter()\n+                                           .map(|s| s.to_str().to_strbuf());\n+                           format_strbuf!(\n+                               \": {}\",\n+                               m.collect::<Vec<StrBuf>>().connect(\" + \"))\n                        },\n                        arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n                        ret = decl.decl.output)\n@@ -370,9 +377,9 @@ impl fmt::Show for clean::Type {\n                 write!(f.buf, \"{}{}fn{}{}\",\n                        FnStyleSpace(decl.fn_style),\n                        match decl.abi.as_slice() {\n-                           \"\" => \" extern \".to_owned(),\n-                           \"\\\"Rust\\\"\" => \"\".to_owned(),\n-                           s => format!(\" extern {} \", s)\n+                           \"\" => \" extern \".to_strbuf(),\n+                           \"\\\"Rust\\\"\" => \"\".to_strbuf(),\n+                           s => format_strbuf!(\" extern {} \", s)\n                        },\n                        decl.generics,\n                        decl.decl)"}, {"sha": "590086e9d3ac168bcfc1bf705962b2284bf8da9a", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -25,7 +25,7 @@ use html::escape::Escape;\n use t = syntax::parse::token;\n \n /// Highlights some source code, returning the HTML output.\n-pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n+pub fn highlight(src: &str, class: Option<&str>) -> StrBuf {\n     let sess = parse::new_parse_sess();\n     let fm = parse::string_to_filemap(&sess,\n                                       src.to_strbuf(),\n@@ -36,7 +36,7 @@ pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n          lexer::new_string_reader(&sess.span_diagnostic, fm),\n          class,\n          &mut out).unwrap();\n-    str::from_utf8_lossy(out.unwrap().as_slice()).into_owned()\n+    str::from_utf8_lossy(out.unwrap().as_slice()).to_strbuf()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "e667f7a57f14bfb7ff4092ae4adbd8074f11c037", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -13,9 +13,9 @@ use std::io;\n \n #[deriving(Clone)]\n pub struct Layout {\n-    pub logo: ~str,\n-    pub favicon: ~str,\n-    pub krate: ~str,\n+    pub logo: StrBuf,\n+    pub favicon: StrBuf,\n+    pub krate: StrBuf,\n }\n \n pub struct Page<'a> {\n@@ -119,9 +119,9 @@ r##\"<!DOCTYPE html>\n     content   = *t,\n     root_path = page.root_path,\n     ty        = page.ty,\n-    logo      = nonestr(layout.logo),\n+    logo      = nonestr(layout.logo.as_slice()),\n     title     = page.title,\n-    favicon   = nonestr(layout.favicon),\n+    favicon   = nonestr(layout.favicon.as_slice()),\n     sidebar   = *sidebar,\n     krate     = layout.krate,\n     )"}, {"sha": "76f7949bcf9c2d90e9add8fe965356a09898c05f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -139,7 +139,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-local_data_key!(used_header_map: RefCell<HashMap<~str, uint>>)\n+local_data_key!(used_header_map: RefCell<HashMap<StrBuf, uint>>)\n \n pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n@@ -177,7 +177,8 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n                 };\n \n                 if !rendered {\n-                    let output = highlight::highlight(text, None).to_c_str();\n+                    let output = highlight::highlight(text, None).as_slice()\n+                                                                 .to_c_str();\n                     output.with_ref(|r| {\n                         hoedown_buffer_puts(ob, r)\n                     })\n@@ -201,16 +202,16 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.words().map(|s| {\n+        let id = (s.words().map(|s| {\n             match s.to_ascii_opt() {\n-                Some(s) => s.to_lower().into_str(),\n-                None => s.to_owned()\n+                Some(s) => s.to_lower().into_str().to_strbuf(),\n+                None => s.to_strbuf()\n             }\n-        }).collect::<Vec<~str>>().connect(\"-\");\n+        }).collect::<Vec<StrBuf>>().connect(\"-\")).to_strbuf();\n \n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text.\n-        let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\");\n+        let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\").to_strbuf();\n \n         let opaque = opaque as *mut hoedown_html_renderer_state;\n         let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n@@ -219,13 +220,13 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n         let map = used_header_map.get().unwrap();\n         let id = match map.borrow_mut().find_mut(&id) {\n             None => id,\n-            Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n+            Some(a) => { *a += 1; format_strbuf!(\"{}-{}\", id, *a - 1) }\n         };\n         map.borrow_mut().insert(id.clone(), 1);\n \n         let sec = match opaque.toc_builder {\n             Some(ref mut builder) => {\n-                builder.push(level as u32, s.clone(), id.clone())\n+                builder.push(level as u32, s.to_strbuf(), id.clone())\n             }\n             None => {\"\"}\n         };\n@@ -298,7 +299,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                     stripped_filtered_line(l).unwrap_or(l)\n                 });\n                 let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-                tests.add_test(text, should_fail, no_run, ignore);\n+                tests.add_test(text.to_strbuf(), should_fail, no_run, ignore);\n             })\n         }\n     }"}, {"sha": "288e6ebffbaa3e5a2c65e93b61d240342d216bc2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -70,7 +70,7 @@ use html::markdown;\n pub struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub current: Vec<~str> ,\n+    pub current: Vec<StrBuf> ,\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: StrBuf,\n@@ -85,7 +85,7 @@ pub struct Context {\n     /// functions), and the value is the list of containers belonging to this\n     /// header. This map will change depending on the surrounding context of the\n     /// page.\n-    pub sidebar: HashMap<~str, Vec<~str> >,\n+    pub sidebar: HashMap<StrBuf, Vec<StrBuf> >,\n     /// This flag indicates whether [src] links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n@@ -95,7 +95,7 @@ pub struct Context {\n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n     /// Remote URL root of the external crate\n-    Remote(~str),\n+    Remote(StrBuf),\n     /// This external crate can be found in the local doc/ folder\n     Local,\n     /// The external crate could not be found.\n@@ -124,22 +124,22 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: HashMap<ast::NodeId, ~str>,\n+    pub typarams: HashMap<ast::NodeId, StrBuf>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<~str>)> >,\n+    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<StrBuf>)> >,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: HashMap<ast::DefId, (Vec<~str>, ItemType)>,\n+    pub paths: HashMap<ast::DefId, (Vec<StrBuf>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -157,7 +157,7 @@ pub struct Cache {\n \n     // Private fields only used when initially crawling a crate to build a cache\n \n-    stack: Vec<~str> ,\n+    stack: Vec<StrBuf> ,\n     parent_stack: Vec<ast::NodeId> ,\n     search_index: Vec<IndexItem> ,\n     privmod: bool,\n@@ -176,7 +176,7 @@ struct SourceCollector<'a> {\n     cx: &'a mut Context,\n \n     /// Processed source-file paths\n-    seen: HashSet<~str>,\n+    seen: HashSet<StrBuf>,\n     /// Root destination to place all HTML output into\n     dst: Path,\n }\n@@ -195,16 +195,16 @@ struct Sidebar<'a> { cx: &'a Context, item: &'a clean::Item, }\n /// by hand to a large JS file at the end of cache-creation.\n struct IndexItem {\n     ty: ItemType,\n-    name: ~str,\n-    path: ~str,\n-    desc: ~str,\n+    name: StrBuf,\n+    path: StrBuf,\n+    desc: StrBuf,\n     parent: Option<ast::NodeId>,\n }\n \n // TLS keys used to carry information around during rendering.\n \n local_data_key!(pub cache_key: Arc<Cache>)\n-local_data_key!(pub current_location_key: Vec<~str> )\n+local_data_key!(pub current_location_key: Vec<StrBuf> )\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n@@ -214,8 +214,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         root_path: StrBuf::new(),\n         sidebar: HashMap::new(),\n         layout: layout::Layout {\n-            logo: \"\".to_owned(),\n-            favicon: \"\".to_owned(),\n+            logo: \"\".to_strbuf(),\n+            favicon: \"\".to_strbuf(),\n             krate: krate.name.clone(),\n         },\n         include_sources: true,\n@@ -226,13 +226,16 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n                 match *attr {\n-                    clean::NameValue(ref x, ref s) if \"html_favicon_url\" == *x => {\n-                        cx.layout.favicon = s.to_owned();\n+                    clean::NameValue(ref x, ref s)\n+                            if \"html_favicon_url\" == x.as_slice() => {\n+                        cx.layout.favicon = s.to_strbuf();\n                     }\n-                    clean::NameValue(ref x, ref s) if \"html_logo_url\" == *x => {\n-                        cx.layout.logo = s.to_owned();\n+                    clean::NameValue(ref x, ref s)\n+                            if \"html_logo_url\" == x.as_slice() => {\n+                        cx.layout.logo = s.to_strbuf();\n                     }\n-                    clean::Word(ref x) if \"html_no_source\" == *x => {\n+                    clean::Word(ref x)\n+                            if \"html_no_source\" == x.as_slice() => {\n                         cx.include_sources = false;\n                     }\n                     _ => {}\n@@ -291,8 +294,9 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                     index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n-                        desc: shorter(item.doc_value()).to_owned(),\n+                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\")\n+                                                         .to_strbuf(),\n+                        desc: shorter(item.doc_value()).to_strbuf(),\n                         parent: Some(pid),\n                     });\n                 },\n@@ -322,14 +326,14 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         let mut w = MemWriter::new();\n         try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n \n-        let mut lastpath = \"\".to_owned();\n+        let mut lastpath = \"\".to_strbuf();\n         for (i, item) in cache.search_index.iter().enumerate() {\n             // Omit the path if it is same to that of the prior item.\n             let path;\n-            if lastpath == item.path {\n+            if lastpath.as_slice() == item.path.as_slice() {\n                 path = \"\";\n             } else {\n-                lastpath = item.path.clone();\n+                lastpath = item.path.to_strbuf();\n                 path = item.path.as_slice();\n             };\n \n@@ -485,14 +489,15 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // external crate\n     for attr in e.attrs.iter() {\n         match *attr {\n-            clean::List(ref x, ref list) if \"doc\" == *x => {\n+            clean::List(ref x, ref list) if \"doc\" == x.as_slice() => {\n                 for attr in list.iter() {\n                     match *attr {\n-                        clean::NameValue(ref x, ref s) if \"html_root_url\" == *x => {\n-                            if s.ends_with(\"/\") {\n-                                return Remote(s.to_owned());\n+                        clean::NameValue(ref x, ref s)\n+                                if \"html_root_url\" == x.as_slice() => {\n+                            if s.as_slice().ends_with(\"/\") {\n+                                return Remote(s.to_strbuf());\n                             }\n-                            return Remote(*s + \"/\");\n+                            return Remote(format_strbuf!(\"{}/\", s));\n                         }\n                         _ => {}\n                     }\n@@ -517,7 +522,10 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx.include_sources = match self.emit_source(item.source.filename) {\n+            self.cx\n+                .include_sources = match self.emit_source(item.source\n+                                                              .filename\n+                                                              .as_slice()) {\n                 Ok(()) => true,\n                 Err(e) => {\n                     println!(\"warning: source code was requested to be rendered, \\\n@@ -689,9 +697,9 @@ impl DocFolder for Cache {\n                     (parent, Some(path)) if !self.privmod => {\n                         self.search_index.push(IndexItem {\n                             ty: shortty(&item),\n-                            name: s.to_owned(),\n-                            path: path.connect(\"::\"),\n-                            desc: shorter(item.doc_value()).to_owned(),\n+                            name: s.to_strbuf(),\n+                            path: path.connect(\"::\").to_strbuf(),\n+                            desc: shorter(item.doc_value()).to_strbuf(),\n                             parent: parent,\n                         });\n                     }\n@@ -710,7 +718,7 @@ impl DocFolder for Cache {\n         let pushed = if item.name.is_some() {\n             let n = item.name.get_ref();\n             if n.len() > 0 {\n-                self.stack.push(n.to_owned());\n+                self.stack.push(n.to_strbuf());\n                 true\n             } else { false }\n         } else { false };\n@@ -779,7 +787,10 @@ impl DocFolder for Cache {\n                                 // extract relevant documentation for this impl\n                                 match attrs.move_iter().find(|a| {\n                                     match *a {\n-                                        clean::NameValue(ref x, _) if \"doc\" == *x => true,\n+                                        clean::NameValue(ref x, _)\n+                                                if \"doc\" == x.as_slice() => {\n+                                            true\n+                                        }\n                                         _ => false\n                                     }\n                                 }) {\n@@ -828,7 +839,7 @@ impl<'a> Cache {\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n-    fn recurse<T>(&mut self, s: ~str, f: |&mut Context| -> T) -> T {\n+    fn recurse<T>(&mut self, s: StrBuf, f: |&mut Context| -> T) -> T {\n         if s.len() == 0 {\n             fail!(\"what {:?}\", self);\n         }\n@@ -898,7 +909,7 @@ impl Context {\n                 if title.len() > 0 {\n                     title.push_str(\"::\");\n                 }\n-                title.push_str(*it.name.get_ref());\n+                title.push_str(it.name.get_ref().as_slice());\n             }\n             title.push_str(\" - Rust\");\n             let page = layout::Page {\n@@ -923,7 +934,7 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n-                let name = item.name.get_ref().to_owned();\n+                let name = item.name.get_ref().to_strbuf();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n                     let item = item.take_unwrap();\n@@ -963,21 +974,23 @@ impl<'a> Item<'a> {\n         }\n     }\n \n-    fn link(&self) -> ~str {\n+    fn link(&self) -> StrBuf {\n         let mut path = Vec::new();\n         clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n             path.push(component.to_owned());\n         });\n         let href = if self.item.source.loline == self.item.source.hiline {\n-            format!(\"{}\", self.item.source.loline)\n+            format_strbuf!(\"{}\", self.item.source.loline)\n         } else {\n-            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n+            format_strbuf!(\"{}-{}\",\n+                           self.item.source.loline,\n+                           self.item.source.hiline)\n         };\n-        format!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n-                root = self.cx.root_path,\n-                krate = self.cx.layout.krate,\n-                path = path.connect(\"/\"),\n-                href = href)\n+        format_strbuf!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n+                       root = self.cx.root_path,\n+                       krate = self.cx.layout.krate,\n+                       path = path.connect(\"/\"),\n+                       href = href)\n     }\n }\n \n@@ -1047,18 +1060,24 @@ impl<'a> fmt::Show for Item<'a> {\n     }\n }\n \n-fn item_path(item: &clean::Item) -> ~str {\n+fn item_path(item: &clean::Item) -> StrBuf {\n     match item.inner {\n-        clean::ModuleItem(..) => *item.name.get_ref() + \"/index.html\",\n-        _ => shortty(item).to_static_str() + \".\" + *item.name.get_ref() + \".html\"\n+        clean::ModuleItem(..) => {\n+            format_strbuf!(\"{}/index.html\", item.name.get_ref())\n+        }\n+        _ => {\n+            format_strbuf!(\"{}.{}.html\",\n+                           shortty(item).to_static_str(),\n+                           *item.name.get_ref())\n+        }\n     }\n }\n \n-fn full_path(cx: &Context, item: &clean::Item) -> ~str {\n+fn full_path(cx: &Context, item: &clean::Item) -> StrBuf {\n     let mut s = StrBuf::from_str(cx.current.connect(\"::\"));\n     s.push_str(\"::\");\n     s.push_str(item.name.get_ref().as_slice());\n-    return s.into_owned();\n+    return s\n }\n \n fn blank<'a>(s: Option<&'a str>) -> &'a str {\n@@ -1197,7 +1216,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 VisSpace(myitem.visibility),\n                 *myitem.name.get_ref(),\n                 s.type_,\n-                Initializer(s.expr, Item { cx: cx, item: myitem }),\n+                Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n                 Markdown(blank(myitem.doc_value()))));\n             }\n \n@@ -1584,11 +1603,11 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n             let mut non_trait = v.iter().filter(|p| {\n                 p.ref0().trait_.is_none()\n             });\n-            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n+            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<StrBuf>)>>();\n             let mut traits = v.iter().filter(|p| {\n                 p.ref0().trait_.is_some()\n             });\n-            let traits = traits.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n+            let traits = traits.collect::<Vec<&(clean::Impl, Option<StrBuf>)>>();\n \n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n@@ -1624,7 +1643,7 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n }\n \n fn render_impl(w: &mut Writer, i: &clean::Impl,\n-               dox: &Option<~str>) -> fmt::Result {\n+               dox: &Option<StrBuf>) -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n@@ -1760,15 +1779,15 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n-fn build_sidebar(m: &clean::Module) -> HashMap<~str, Vec<~str> > {\n+fn build_sidebar(m: &clean::Module) -> HashMap<StrBuf, Vec<StrBuf> > {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n         let short = shortty(item).to_static_str();\n         let myname = match item.name {\n             None => continue,\n-            Some(ref s) => s.to_owned(),\n+            Some(ref s) => s.to_strbuf(),\n         };\n-        let v = map.find_or_insert_with(short.to_owned(), |_| Vec::new());\n+        let v = map.find_or_insert_with(short.to_strbuf(), |_| Vec::new());\n         v.push(myname);\n     }\n \n@@ -1800,6 +1819,7 @@ impl<'a> fmt::Show for Source<'a> {\n \n fn item_macro(w: &mut Writer, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write_str(highlight::highlight(t.source, Some(\"macro\"))));\n+    try!(w.write_str(highlight::highlight(t.source.as_slice(),\n+                                          Some(\"macro\")).as_slice()));\n     document(w, it)\n }"}, {"sha": "893214dc9c9c7d433b963c95f601e8bd0cf19a17", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -39,9 +39,9 @@ impl Toc {\n #[deriving(Eq)]\n pub struct TocEntry {\n     level: u32,\n-    sec_number: ~str,\n-    name: ~str,\n-    id: ~str,\n+    sec_number: StrBuf,\n+    name: StrBuf,\n+    id: StrBuf,\n     children: Toc,\n }\n \n@@ -125,7 +125,7 @@ impl TocBuilder {\n     /// Push a level `level` heading into the appropriate place in the\n     /// heirarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n-    pub fn push<'a>(&'a mut self, level: u32, name: ~str, id: ~str) -> &'a str {\n+    pub fn push<'a>(&'a mut self, level: u32, name: StrBuf, id: StrBuf) -> &'a str {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we\n@@ -141,7 +141,8 @@ impl TocBuilder {\n                     (0, &self.top_level)\n                 }\n                 Some(entry) => {\n-                    sec_number = StrBuf::from_str(entry.sec_number.clone());\n+                    sec_number = StrBuf::from_str(entry.sec_number\n+                                                       .as_slice());\n                     sec_number.push_str(\".\");\n                     (entry.level, &entry.children)\n                 }\n@@ -153,13 +154,13 @@ impl TocBuilder {\n                 sec_number.push_str(\"0.\");\n             }\n             let number = toc.count_entries_with_level(level);\n-            sec_number.push_str(format!(\"{}\", number + 1))\n+            sec_number.push_str(format_strbuf!(\"{}\", number + 1).as_slice())\n         }\n \n         self.chain.push(TocEntry {\n             level: level,\n             name: name,\n-            sec_number: sec_number.into_owned(),\n+            sec_number: sec_number,\n             id: id,\n             children: Toc { entries: Vec::new() }\n         });\n@@ -200,7 +201,10 @@ mod test {\n         // there's been no macro mistake.\n         macro_rules! push {\n             ($level: expr, $name: expr) => {\n-                assert_eq!(builder.push($level, $name.to_owned(), \"\".to_owned()), $name);\n+                assert_eq!(builder.push($level,\n+                                        $name.to_strbuf(),\n+                                        \"\".to_strbuf()),\n+                           $name);\n             }\n         }\n         push!(2, \"0.1\");\n@@ -238,9 +242,9 @@ mod test {\n                         $(\n                             TocEntry {\n                                 level: $level,\n-                                name: $name.to_owned(),\n-                                sec_number: $name.to_owned(),\n-                                id: \"\".to_owned(),\n+                                name: $name.to_strbuf(),\n+                                sec_number: $name.to_strbuf(),\n+                                id: \"\".to_strbuf(),\n                                 children: toc!($($sub),*)\n                             }\n                             ),*"}, {"sha": "cde4eac488fb554251534d0ab948fc8718161202", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 67, "deletions": 34, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -85,7 +85,10 @@ local_data_key!(pub analysiskey: core::CrateAnalysis)\n type Output = (clean::Crate, Vec<plugins::PluginJson> );\n \n pub fn main() {\n-    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n+    std::os::set_exit_status(main_args(std::os::args().iter()\n+                                                      .map(|x| x.to_strbuf())\n+                                                      .collect::<Vec<_>>()\n+                                                      .as_slice()));\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {\n@@ -133,19 +136,24 @@ pub fn usage(argv0: &str) {\n                             opts().as_slice()));\n }\n \n-pub fn main_args(args: &[~str]) -> int {\n-    let matches = match getopts::getopts(args.tail(), opts().as_slice()) {\n+pub fn main_args(args: &[StrBuf]) -> int {\n+    let matches = match getopts::getopts(args.tail()\n+                                             .iter()\n+                                             .map(|x| (*x).to_owned())\n+                                             .collect::<Vec<_>>()\n+                                             .as_slice(),\n+                                         opts().as_slice()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err.to_err_msg());\n             return 1;\n         }\n     };\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(args[0]);\n+        usage(args[0].as_slice());\n         return 0;\n     } else if matches.opt_present(\"version\") {\n-        rustc::driver::version(args[0]);\n+        rustc::driver::version(args[0].as_slice());\n         return 0;\n     }\n \n@@ -161,10 +169,10 @@ pub fn main_args(args: &[~str]) -> int {\n     let libs = matches.opt_strs(\"L\").iter().map(|s| Path::new(s.as_slice())).collect();\n \n     let test_args = matches.opt_strs(\"test-args\");\n-    let test_args: Vec<~str> = test_args.iter()\n-                                        .flat_map(|s| s.words())\n-                                        .map(|s| s.to_owned())\n-                                        .collect();\n+    let test_args: Vec<StrBuf> = test_args.iter()\n+                                          .flat_map(|s| s.words())\n+                                          .map(|s| s.to_strbuf())\n+                                          .collect();\n \n     let should_test = matches.opt_present(\"test\");\n     let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n@@ -178,9 +186,14 @@ pub fn main_args(args: &[~str]) -> int {\n                                   libs,\n                                   test_args.move_iter().collect())\n         }\n-        (true, false) => return test::run(input, cfgs.move_iter().collect(),\n-                                          libs, test_args),\n-\n+        (true, false) => {\n+            return test::run(input,\n+                             cfgs.move_iter()\n+                                 .map(|x| x.to_strbuf())\n+                                 .collect(),\n+                             libs,\n+                             test_args)\n+        }\n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n                                                  &matches),\n         (false, false) => {}\n@@ -235,11 +248,11 @@ pub fn main_args(args: &[~str]) -> int {\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input(input: &str,\n-                 matches: &getopts::Matches) -> Result<Output, ~str> {\n+                 matches: &getopts::Matches) -> Result<Output, StrBuf> {\n     match matches.opt_str(\"r\").as_ref().map(|s| s.as_slice()) {\n         Some(\"rust\") => Ok(rust_input(input, matches)),\n         Some(\"json\") => json_input(input),\n-        Some(s) => Err(\"unknown input format: \" + s),\n+        Some(s) => Err(format_strbuf!(\"unknown input format: {}\", s)),\n         None => {\n             if input.ends_with(\".json\") {\n                 json_input(input)\n@@ -258,7 +271,10 @@ fn acquire_input(input: &str,\n fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n-    let mut plugins = matches.opt_strs(\"plugins\");\n+    let mut plugins = matches.opt_strs(\"plugins\")\n+                             .move_iter()\n+                             .map(|x| x.to_strbuf())\n+                             .collect::<Vec<_>>();\n \n     // First, parse the crate and extract all relevant information.\n     let libs: Vec<Path> = matches.opt_strs(\"L\")\n@@ -270,8 +286,8 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     info!(\"starting to run rustc\");\n     let (krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n-        core::run_core(libs.move_iter().collect(),\n-                       cfgs.move_iter().collect(),\n+        core::run_core(libs.move_iter().map(|x| x.clone()).collect(),\n+                       cfgs.move_iter().map(|x| x.to_strbuf()).collect(),\n                        &cr)\n     }).unwrap();\n     info!(\"finished with rustc\");\n@@ -283,17 +299,20 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n         Some(nested) => {\n             for inner in nested.iter() {\n                 match *inner {\n-                    clean::Word(ref x) if \"no_default_passes\" == *x => {\n+                    clean::Word(ref x)\n+                            if \"no_default_passes\" == x.as_slice() => {\n                         default_passes = false;\n                     }\n-                    clean::NameValue(ref x, ref value) if \"passes\" == *x => {\n-                        for pass in value.words() {\n+                    clean::NameValue(ref x, ref value)\n+                            if \"passes\" == x.as_slice() => {\n+                        for pass in value.as_slice().words() {\n                             passes.push(pass.to_owned());\n                         }\n                     }\n-                    clean::NameValue(ref x, ref value) if \"plugins\" == *x => {\n-                        for p in value.words() {\n-                            plugins.push(p.to_owned());\n+                    clean::NameValue(ref x, ref value)\n+                            if \"plugins\" == x.as_slice() => {\n+                        for p in value.as_slice().words() {\n+                            plugins.push(p.to_strbuf());\n                         }\n                     }\n                     _ => {}\n@@ -333,39 +352,45 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n-fn json_input(input: &str) -> Result<Output, ~str> {\n+fn json_input(input: &str) -> Result<Output, StrBuf> {\n     let mut input = match File::open(&Path::new(input)) {\n         Ok(f) => f,\n-        Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n+        Err(e) => {\n+            return Err(format_strbuf!(\"couldn't open {}: {}\", input, e))\n+        }\n     };\n     match json::from_reader(&mut input) {\n-        Err(s) => Err(s.to_str()),\n+        Err(s) => Err(s.to_str().to_strbuf()),\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n             match obj.pop(&\"schema\".to_owned()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n-                        return Err(format!(\"sorry, but I only understand \\\n-                                            version {}\", SCHEMA_VERSION))\n+                        return Err(format_strbuf!(\n+                                \"sorry, but I only understand version {}\",\n+                                SCHEMA_VERSION))\n                     }\n                 }\n-                Some(..) => return Err(\"malformed json\".to_owned()),\n-                None => return Err(\"expected a schema version\".to_owned()),\n+                Some(..) => return Err(\"malformed json\".to_strbuf()),\n+                None => return Err(\"expected a schema version\".to_strbuf()),\n             }\n-            let krate = match obj.pop(&\"crate\".to_owned()) {\n+            let krate = match obj.pop(&\"crate\".to_str()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()\n                 }\n-                None => return Err(\"malformed json\".to_owned()),\n+                None => return Err(\"malformed json\".to_strbuf()),\n             };\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n             let plugin_output = Vec::new();\n             Ok((krate, plugin_output))\n         }\n-        Ok(..) => Err(\"malformed json input: expected an object at the top\".to_owned()),\n+        Ok(..) => {\n+            Err(\"malformed json input: expected an object at the \\\n+                 top\".to_strbuf())\n+        }\n     }\n }\n \n@@ -380,7 +405,15 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     // }\n     let mut json = box collections::TreeMap::new();\n     json.insert(\"schema\".to_owned(), json::String(SCHEMA_VERSION.to_owned()));\n-    let plugins_json = box res.move_iter().filter_map(|opt| opt).collect();\n+    let plugins_json = box res.move_iter()\n+                              .filter_map(|opt| {\n+                                  match opt {\n+                                      None => None,\n+                                      Some((string, json)) => {\n+                                          Some((string.to_owned(), json))\n+                                      }\n+                                  }\n+                              }).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation."}, {"sha": "3ee38f7a4d65a2bc90d3cd7e807956f68efe39a3", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -19,10 +19,10 @@ use html::escape::Escape;\n use html::markdown::{MarkdownWithToc, find_testable_code, reset_headers};\n use test::Collector;\n \n-fn load_string(input: &Path) -> io::IoResult<Option<~str>> {\n+fn load_string(input: &Path) -> io::IoResult<Option<StrBuf>> {\n     let mut f = try!(io::File::open(input));\n     let d = try!(f.read_to_end());\n-    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_owned()))\n+    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_strbuf()))\n }\n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n@@ -61,13 +61,13 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     (metadata, \"\")\n }\n \n-fn load_external_files(names: &[~str]) -> Option<~str> {\n+fn load_external_files(names: &[StrBuf]) -> Option<StrBuf> {\n     let mut out = StrBuf::new();\n     for name in names.iter() {\n-        out.push_str(load_or_return!(name.as_slice(), None, None));\n+        out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n         out.push_char('\\n');\n     }\n-    Some(out.into_owned())\n+    Some(out)\n }\n \n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n@@ -87,10 +87,19 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n \n     let (in_header, before_content, after_content) =\n         match (load_external_files(matches.opt_strs(\"markdown-in-header\")\n+                                          .move_iter()\n+                                          .map(|x| x.to_strbuf())\n+                                          .collect::<Vec<_>>()\n                                           .as_slice()),\n                load_external_files(matches.opt_strs(\"markdown-before-content\")\n+                                          .move_iter()\n+                                          .map(|x| x.to_strbuf())\n+                                          .collect::<Vec<_>>()\n                                           .as_slice()),\n                load_external_files(matches.opt_strs(\"markdown-after-content\")\n+                                          .move_iter()\n+                                          .map(|x| x.to_strbuf())\n+                                          .collect::<Vec<_>>()\n                                           .as_slice())) {\n         (Some(a), Some(b), Some(c)) => (a,b,c),\n         _ => return 3\n@@ -106,7 +115,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n         Ok(f) => f\n     };\n \n-    let (metadata, text) = extract_leading_metadata(input_str);\n+    let (metadata, text) = extract_leading_metadata(input_str.as_slice());\n     if metadata.len() == 0 {\n         let _ = writeln!(&mut io::stderr(),\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n@@ -161,12 +170,16 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n+pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<StrBuf>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n-    let mut collector = Collector::new(input.to_owned(), libs, true, true);\n-    find_testable_code(input_str, &mut collector);\n-    test_args.unshift(\"rustdoctest\".to_owned());\n-    testing::test_main(test_args.as_slice(), collector.tests);\n+    let mut collector = Collector::new(input.to_strbuf(), libs, true, true);\n+    find_testable_code(input_str.as_slice(), &mut collector);\n+    test_args.unshift(\"rustdoctest\".to_strbuf());\n+    testing::test_main(test_args.move_iter()\n+                                .map(|x| x.to_str())\n+                                .collect::<Vec<_>>()\n+                                .as_slice(),\n+                       collector.tests);\n     0\n }"}, {"sha": "9ba8e1e9a963a8d3c6967266fc09a5ac69aba8d8", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -228,8 +228,11 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n             let mut avec: Vec<clean::Attribute> = Vec::new();\n             for attr in i.attrs.iter() {\n                 match attr {\n-                    &clean::NameValue(ref x, ref s) if \"doc\" == *x => avec.push(\n-                        clean::NameValue(\"doc\".to_owned(), unindent(*s))),\n+                    &clean::NameValue(ref x, ref s)\n+                            if \"doc\" == x.as_slice() => {\n+                        avec.push(clean::NameValue(\"doc\".to_strbuf(),\n+                                                   unindent(s.as_slice())))\n+                    }\n                     x => avec.push(x.clone())\n                 }\n             }\n@@ -250,19 +253,20 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n             let mut i = i;\n             for attr in i.attrs.iter() {\n                 match *attr {\n-                    clean::NameValue(ref x, ref s) if \"doc\" == *x => {\n-                        docstr.push_str(s.clone());\n+                    clean::NameValue(ref x, ref s)\n+                            if \"doc\" == x.as_slice() => {\n+                        docstr.push_str(s.as_slice());\n                         docstr.push_char('\\n');\n                     },\n                     _ => ()\n                 }\n             }\n             let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n+                &clean::NameValue(ref x, _) if \"doc\" == x.as_slice() => false,\n                 _ => true\n             }).map(|x| x.clone()).collect();\n             if docstr.len() > 0 {\n-                a.push(clean::NameValue(\"doc\".to_owned(), docstr.into_owned()));\n+                a.push(clean::NameValue(\"doc\".to_strbuf(), docstr));\n             }\n             i.attrs = a;\n             self.fold_item_recur(i)\n@@ -273,7 +277,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     (krate, None)\n }\n \n-pub fn unindent(s: &str) -> ~str {\n+pub fn unindent(s: &str) -> StrBuf {\n     let lines = s.lines_any().collect::<Vec<&str> >();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n@@ -318,18 +322,18 @@ pub fn unindent(s: &str) -> ~str {\n     });\n \n     if lines.len() >= 1 {\n-        let mut unindented = vec!( lines.get(0).trim() );\n+        let mut unindented = vec![ lines.get(0).trim().to_strbuf() ];\n         unindented.push_all(lines.tail().iter().map(|&line| {\n             if line.is_whitespace() {\n-                line\n+                line.to_strbuf()\n             } else {\n                 assert!(line.len() >= min_indent);\n-                line.slice_from(min_indent)\n+                line.slice_from(min_indent).to_strbuf()\n             }\n         }).collect::<Vec<_>>().as_slice());\n-        unindented.connect(\"\\n\")\n+        unindented.connect(\"\\n\").to_strbuf()\n     } else {\n-        s.to_owned()\n+        s.to_strbuf()\n     }\n }\n \n@@ -341,14 +345,14 @@ mod unindent_tests {\n     fn should_unindent() {\n         let s = \"    line1\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, \"line1\\nline2\".to_owned());\n+        assert_eq!(r.as_slice(), \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n         let s = \"    line1\\n\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, \"line1\\n\\nline2\".to_owned());\n+        assert_eq!(r.as_slice(), \"line1\\n\\nline2\");\n     }\n \n     #[test]\n@@ -357,7 +361,7 @@ mod unindent_tests {\n         // base indentation and should be preserved\n         let s = \"    line1\\n\\n        line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, \"line1\\n\\n    line2\".to_owned());\n+        assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n     }\n \n     #[test]\n@@ -369,13 +373,13 @@ mod unindent_tests {\n         //          and continue here\"]\n         let s = \"line1\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, \"line1\\nline2\".to_owned());\n+        assert_eq!(r.as_slice(), \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n         let s = \"line1\\n\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, \"line1\\n\\n    line2\".to_owned());\n+        assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n     }\n }"}, {"sha": "90653730a3518cf8d8c2aa109cfeab88e009f488", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -14,7 +14,7 @@ use dl = std::unstable::dynamic_lib;\n use serialize::json;\n use std::strbuf::StrBuf;\n \n-pub type PluginJson = Option<(~str, json::Json)>;\n+pub type PluginJson = Option<(StrBuf, json::Json)>;\n pub type PluginResult = (clean::Crate, PluginJson);\n pub type PluginCallback = fn (clean::Crate) -> PluginResult;\n \n@@ -41,7 +41,7 @@ impl PluginManager {\n     /// Turns `name` into the proper dynamic library filename for the given\n     /// platform. On windows, it turns into name.dll, on OS X, name.dylib, and\n     /// elsewhere, libname.so.\n-    pub fn load_plugin(&mut self, name: ~str) {\n+    pub fn load_plugin(&mut self, name: StrBuf) {\n         let x = self.prefix.join(libname(name));\n         let lib_result = dl::DynamicLibrary::open(Some(&x));\n         let lib = lib_result.unwrap();\n@@ -71,23 +71,21 @@ impl PluginManager {\n }\n \n #[cfg(target_os=\"win32\")]\n-fn libname(n: ~str) -> ~str {\n-    let mut n = StrBuf::from_owned_str(n);\n+fn libname(mut n: StrBuf) -> StrBuf {\n     n.push_str(\".dll\");\n-    n.into_owned()\n+    n\n }\n \n #[cfg(target_os=\"macos\")]\n-fn libname(n: ~str) -> ~str {\n-    let mut n = StrBuf::from_owned_str(n);\n+fn libname(mut n: StrBuf) -> StrBuf {\n     n.push_str(\".dylib\");\n-    n.into_owned()\n+    n\n }\n \n #[cfg(not(target_os=\"win32\"), not(target_os=\"macos\"))]\n-fn libname(n: ~str) -> ~str {\n+fn libname(n: StrBuf) -> StrBuf {\n     let mut i = StrBuf::from_str(\"lib\");\n-    i.push_str(n);\n+    i.push_str(n.as_slice());\n     i.push_str(\".so\");\n-    i.into_owned()\n+    i\n }"}, {"sha": "c1da6396d0e29dab5d90930a115b32bc8baafcbc", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9ba91e12434bdf3cdc6c4027a0d0b39ac05196d7", "patch": "@@ -37,9 +37,9 @@ use passes;\n use visit_ast::RustdocVisitor;\n \n pub fn run(input: &str,\n-           cfgs: Vec<~str>,\n+           cfgs: Vec<StrBuf>,\n            libs: HashSet<Path>,\n-           mut test_args: Vec<~str>)\n+           mut test_args: Vec<StrBuf>)\n            -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n@@ -63,7 +63,7 @@ pub fn run(input: &str,\n \n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.move_iter().map(|cfg_| {\n-        let cfg_ = token::intern_and_get_ident(cfg_);\n+        let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n         @dummy_spanned(ast::MetaWord(cfg_))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n@@ -84,15 +84,18 @@ pub fn run(input: &str,\n     let (krate, _) = passes::unindent_comments(krate);\n     let (krate, _) = passes::collapse_docs(krate);\n \n-    let mut collector = Collector::new(krate.name.to_owned(),\n+    let mut collector = Collector::new(krate.name.to_strbuf(),\n                                        libs,\n                                        false,\n                                        false);\n     collector.fold_crate(krate);\n \n-    test_args.unshift(\"rustdoctest\".to_owned());\n+    test_args.unshift(\"rustdoctest\".to_strbuf());\n \n-    testing::test_main(test_args.as_slice(),\n+    testing::test_main(test_args.move_iter()\n+                                .map(|x| x.to_str())\n+                                .collect::<Vec<_>>()\n+                                .as_slice(),\n                        collector.tests.move_iter().collect());\n     0\n }\n@@ -173,7 +176,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     }\n }\n \n-fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n+fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> StrBuf {\n     let mut prog = StrBuf::from_str(r\"\n #![deny(warnings)]\n #![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n@@ -198,23 +201,23 @@ fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n         prog.push_str(\"\\n}\");\n     }\n \n-    return prog.into_owned();\n+    return prog\n }\n \n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n-    names: Vec<~str>,\n+    names: Vec<StrBuf>,\n     libs: HashSet<Path>,\n     cnt: uint,\n     use_headers: bool,\n-    current_header: Option<~str>,\n-    cratename: ~str,\n+    current_header: Option<StrBuf>,\n+    cratename: StrBuf,\n \n     loose_feature_gating: bool\n }\n \n impl Collector {\n-    pub fn new(cratename: ~str, libs: HashSet<Path>,\n+    pub fn new(cratename: StrBuf, libs: HashSet<Path>,\n                use_headers: bool, loose_feature_gating: bool) -> Collector {\n         Collector {\n             tests: Vec::new(),\n@@ -229,7 +232,7 @@ impl Collector {\n         }\n     }\n \n-    pub fn add_test(&mut self, test: ~str, should_fail: bool, no_run: bool, should_ignore: bool) {\n+    pub fn add_test(&mut self, test: StrBuf, should_fail: bool, no_run: bool, should_ignore: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n             format!(\"{}_{}\", s, self.cnt)\n@@ -248,7 +251,12 @@ impl Collector {\n                 should_fail: false, // compiler failures are test failures\n             },\n             testfn: testing::DynTestFn(proc() {\n-                runtest(test, cratename, libs, should_fail, no_run, loose_feature_gating);\n+                runtest(test.as_slice(),\n+                        cratename,\n+                        libs,\n+                        should_fail,\n+                        no_run,\n+                        loose_feature_gating);\n             }),\n         });\n     }\n@@ -264,7 +272,7 @@ impl Collector {\n                     } else {\n                         '_'\n                     }\n-                }).collect::<~str>();\n+                }).collect::<StrBuf>();\n \n             // new header => reset count.\n             self.cnt = 0;\n@@ -277,7 +285,7 @@ impl DocFolder for Collector {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         let pushed = match item.name {\n             Some(ref name) if name.len() == 0 => false,\n-            Some(ref name) => { self.names.push(name.to_owned()); true }\n+            Some(ref name) => { self.names.push(name.to_strbuf()); true }\n             None => false\n         };\n         match item.doc_value() {"}]}