{"sha": "ab0d8472777d2359492dfdee1d21230fbf144f70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMGQ4NDcyNzc3ZDIzNTk0OTJkZmRlZTFkMjEyMzBmYmYxNDRmNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-12T19:21:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-12T19:21:58Z"}, "message": "auto merge of #13448 : alexcrichton/rust/rework-chan-return-values, r=brson\n\nThere are currently a number of return values from the std::comm methods, not\r\nall of which are necessarily completely expressive:\r\n\r\n * `Sender::try_send(t: T) -> bool`\r\n    This method currently doesn't transmit back the data `t` if the send fails\r\n    due to the other end having disconnected. Additionally, this shares the name\r\n    of the synchronous try_send method, but it differs in semantics in that it\r\n    only has one failure case, not two (the buffer can never be full).\r\n\r\n * `SyncSender::try_send(t: T) -> TrySendResult<T>`\r\n    This method accurately conveys all possible information, but it uses a\r\n    custom type to the std::comm module with no convenience methods on it.\r\n    Additionally, if you want to inspect the result you're forced to import\r\n    something from `std::comm`.\r\n\r\n * `SyncSender::send_opt(t: T) -> Option<T>`\r\n    This method uses Some(T) as an \"error value\" and None as a \"success value\",\r\n    but almost all other uses of Option<T> have Some/None the other way\r\n\r\n * `Receiver::try_recv(t: T) -> TryRecvResult<T>`\r\n    Similarly to the synchronous try_send, this custom return type is lacking in\r\n    terms of usability (no convenience methods).\r\n\r\nWith this number of drawbacks in mind, I believed it was time to re-work the\r\nreturn types of these methods. The new API for the comm module is:\r\n\r\n    Sender::send(t: T) -> ()\r\n    Sender::send_opt(t: T) -> Result<(), T>\r\n    SyncSender::send(t: T) -> ()\r\n    SyncSender::send_opt(t: T) -> Result<(), T>\r\n    SyncSender::try_send(t: T) -> Result<(), TrySendError<T>>\r\n    Receiver::recv() -> T\r\n    Receiver::recv_opt() -> Result<T, ()>\r\n    Receiver::try_recv() -> Result<T, TryRecvError>\r\n\r\nThe notable changes made are:\r\n\r\n* Sender::try_send => Sender::send_opt. This renaming brings the semantics in\r\n  line with the SyncSender::send_opt method. An asychronous send only has one\r\n  failure case, unlike the synchronous try_send method which has two failure\r\n  cases (full/disconnected).\r\n\r\n* Sender::send_opt returns the data back to the caller if the send is guaranteed\r\n  to fail. This method previously returned `bool`, but then it was unable to\r\n  retrieve the data if the data was guaranteed to fail to send. There is still a\r\n  race such that when `Ok(())` is returned the data could still fail to be\r\n  received, but that's inherent to an asynchronous channel.\r\n\r\n* Result is now the basis of all return values. This not only adds lots of\r\n  convenience methods to all return values for free, but it also means that you\r\n  can inspect the return values with no extra imports (Ok/Err are in the\r\n  prelude). Additionally, it's now self documenting when something failed or not\r\n  because the return value has \"Err\" in the name.\r\n\r\nThings I'm a little uneasy about:\r\n\r\n* The methods send_opt and recv_opt are not returning options, but rather\r\n  results. I felt more strongly that Option was the wrong return type than the\r\n  _opt prefix was wrong, and I coudn't think of a much better name for these\r\n  methods. One possible way to think about them is to read the _opt suffix as\r\n  \"optionally\".\r\n\r\n* Result<T, ()> is often better expressed as Option<T>. This is only applicable\r\n  to the recv_opt() method, but I thought it would be more consistent for\r\n  everything to return Result rather than one method returning an Option.\r\n\r\nDespite my two reasons to feel uneasy, I feel much better about the consistency\r\nin return values at this point, and I think the only real open question is if\r\nthere's a better suffix for {send,recv}_opt.\r\n\r\nCloses #11527", "tree": {"sha": "c114b541931882c4666d07fa105b1a0c7195c136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c114b541931882c4666d07fa105b1a0c7195c136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab0d8472777d2359492dfdee1d21230fbf144f70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab0d8472777d2359492dfdee1d21230fbf144f70", "html_url": "https://github.com/rust-lang/rust/commit/ab0d8472777d2359492dfdee1d21230fbf144f70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab0d8472777d2359492dfdee1d21230fbf144f70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecc774f788ca3880ce76e4b87ac0d21a3a16d3ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc774f788ca3880ce76e4b87ac0d21a3a16d3ae", "html_url": "https://github.com/rust-lang/rust/commit/ecc774f788ca3880ce76e4b87ac0d21a3a16d3ae"}, {"sha": "545d4718c8e1b9e69474165a1cb38d873627183d", "url": "https://api.github.com/repos/rust-lang/rust/commits/545d4718c8e1b9e69474165a1cb38d873627183d", "html_url": "https://github.com/rust-lang/rust/commit/545d4718c8e1b9e69474165a1cb38d873627183d"}], "stats": {"total": 459, "additions": 232, "deletions": 227}, "files": [{"sha": "e214797d4f84bdfb547541348ca42a331da3e119", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -1011,7 +1011,6 @@ fn new_sched_rng() -> XorShiftRng {\n mod test {\n     use rustuv;\n \n-    use std::comm;\n     use std::task::TaskOpts;\n     use std::rt::task::Task;\n     use std::rt::local::Local;\n@@ -1428,7 +1427,7 @@ mod test {\n             // This task should not be able to starve the sender;\n             // The sender should get stolen to another thread.\n             spawn(proc() {\n-                while rx.try_recv() != comm::Data(()) { }\n+                while rx.try_recv().is_err() { }\n             });\n \n             tx.send(());\n@@ -1445,7 +1444,7 @@ mod test {\n             // This task should not be able to starve the other task.\n             // The sends should eventually yield.\n             spawn(proc() {\n-                while rx1.try_recv() != comm::Data(()) {\n+                while rx1.try_recv().is_err() {\n                     tx2.send(());\n                 }\n             });\n@@ -1499,7 +1498,7 @@ mod test {\n                     let mut val = 20;\n                     while val > 0 {\n                         val = po.recv();\n-                        ch.try_send(val - 1);\n+                        let _ = ch.send_opt(val - 1);\n                     }\n                 }\n "}, {"sha": "534e9f8401e9d718580143efc40f4bab0dd21509", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -515,7 +515,7 @@ mod tests {\n             let _tx = tx;\n             fail!()\n         });\n-        assert_eq!(rx.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), Err(()));\n     }\n \n     #[test]"}, {"sha": "0bf97d58ffdff5313c462223c430c949fce7f8aa", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -46,7 +46,6 @@\n //!\n //! Note that all time units in this file are in *milliseconds*.\n \n-use std::comm::Data;\n use libc;\n use std::mem;\n use std::os;\n@@ -119,7 +118,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n             Some(timer) => timer, None => return\n         };\n         let tx = timer.tx.take_unwrap();\n-        if tx.try_send(()) && timer.repeat {\n+        if tx.send_opt(()).is_ok() && timer.repeat {\n             timer.tx = Some(tx);\n             timer.target += timer.interval;\n             insert(timer, active);\n@@ -162,14 +161,14 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n-                        Data(Shutdown) => {\n+                        Ok(Shutdown) => {\n                             assert!(active.len() == 0);\n                             break 'outer;\n                         }\n \n-                        Data(NewTimer(timer)) => insert(timer, &mut active),\n+                        Ok(NewTimer(timer)) => insert(timer, &mut active),\n \n-                        Data(RemoveTimer(id, ack)) => {\n+                        Ok(RemoveTimer(id, ack)) => {\n                             match dead.iter().position(|&(i, _)| id == i) {\n                                 Some(i) => {\n                                     let (_, i) = dead.remove(i).unwrap();"}, {"sha": "3fd61dc1da5d09086cf0e711905a78d9560c003b", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -28,7 +28,6 @@\n //!\n //! As with timer_other, all units in this file are in units of millseconds.\n \n-use std::comm::Data;\n use libc;\n use std::ptr;\n use std::os;\n@@ -107,7 +106,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n                     match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n                         Some(i) => {\n                             let (_, ref c, oneshot) = *list.get(i);\n-                            (!c.try_send(()) || oneshot, i)\n+                            (c.send_opt(()).is_err() || oneshot, i)\n                         }\n                         None => fail!(\"fd not active: {}\", fd),\n                     }\n@@ -121,7 +120,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n \n         while incoming {\n             match messages.try_recv() {\n-                Data(NewTimer(fd, chan, one, timeval)) => {\n+                Ok(NewTimer(fd, chan, one, timeval)) => {\n                     // acknowledge we have the new channel, we will never send\n                     // another message to the old channel\n                     chan.send(());\n@@ -149,7 +148,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n                     assert_eq!(ret, 0);\n                 }\n \n-                Data(RemoveTimer(fd, chan)) => {\n+                Ok(RemoveTimer(fd, chan)) => {\n                     match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n                         Some(i) => {\n                             drop(list.remove(i));\n@@ -160,7 +159,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n                     chan.send(());\n                 }\n \n-                Data(Shutdown) => {\n+                Ok(Shutdown) => {\n                     assert!(list.len() == 0);\n                     break 'outer;\n                 }"}, {"sha": "a15898feb92b793612a478c441fbd5f4eb376a68", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -20,7 +20,6 @@\n //! Other than that, the implementation is pretty straightforward in terms of\n //! the other two implementations of timers with nothing *that* new showing up.\n \n-use std::comm::Data;\n use libc;\n use std::ptr;\n use std::rt::rtio;\n@@ -54,11 +53,11 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n         if idx == 0 {\n             loop {\n                 match messages.try_recv() {\n-                    Data(NewTimer(obj, c, one)) => {\n+                    Ok(NewTimer(obj, c, one)) => {\n                         objs.push(obj);\n                         chans.push((c, one));\n                     }\n-                    Data(RemoveTimer(obj, c)) => {\n+                    Ok(RemoveTimer(obj, c)) => {\n                         c.send(());\n                         match objs.iter().position(|&o| o == obj) {\n                             Some(i) => {\n@@ -68,7 +67,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n                             None => {}\n                         }\n                     }\n-                    Data(Shutdown) => {\n+                    Ok(Shutdown) => {\n                         assert_eq!(objs.len(), 1);\n                         assert_eq!(chans.len(), 0);\n                         break 'outer;\n@@ -79,7 +78,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n         } else {\n             let remove = {\n                 match chans.get(idx as uint - 1) {\n-                    &(ref c, oneshot) => !c.try_send(()) || oneshot\n+                    &(ref c, oneshot) => c.send_opt(()).is_err() || oneshot\n                 }\n             };\n             if remove {"}, {"sha": "ddfd46ecad9b5bc9fa07d0c3c7850d7aa20cf50e", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -274,7 +274,7 @@ mod tests {\n             let _tx = tx;\n             fail!()\n         });\n-        assert_eq!(rx.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), Err(()));\n     }\n \n     #[test]"}, {"sha": "b893f5f693fa73beba94e24b5695b26c9d9591ea", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -1065,7 +1065,7 @@ mod test {\n             }\n             reads += 1;\n \n-            tx2.try_send(());\n+            let _ = tx2.send_opt(());\n         }\n \n         // Make sure we had multiple reads"}, {"sha": "2dcf2de681c39b8b0f7bcb125e524aa9557a058a", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -51,7 +51,7 @@ impl SignalWatcher {\n extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n     let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n     assert_eq!(signum as int, s.signal as int);\n-    s.channel.try_send(s.signal);\n+    let _ = s.channel.send_opt(s.signal);\n }\n \n impl HomingIO for SignalWatcher {"}, {"sha": "58008002837d1fdd7612883db9b1c14763b49484", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -140,9 +140,9 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n             let task = timer.blocker.take_unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n-        SendOnce(chan) => { let _ = chan.try_send(()); }\n+        SendOnce(chan) => { let _ = chan.send_opt(()); }\n         SendMany(chan, id) => {\n-            let _ = chan.try_send(());\n+            let _ = chan.send_opt(());\n \n             // Note that the above operation could have performed some form of\n             // scheduling. This means that the timer may have decided to insert\n@@ -196,8 +196,8 @@ mod test {\n         let oport = timer.oneshot(1);\n         let pport = timer.period(1);\n         timer.sleep(1);\n-        assert_eq!(oport.recv_opt(), None);\n-        assert_eq!(pport.recv_opt(), None);\n+        assert_eq!(oport.recv_opt(), Err(()));\n+        assert_eq!(pport.recv_opt(), Err(()));\n         timer.oneshot(1).recv();\n     }\n \n@@ -284,7 +284,7 @@ mod test {\n             let mut timer = TimerWatcher::new(local_loop());\n             timer.oneshot(1000)\n         };\n-        assert_eq!(port.recv_opt(), None);\n+        assert_eq!(port.recv_opt(), Err(()));\n     }\n \n     #[test]\n@@ -293,7 +293,7 @@ mod test {\n             let mut timer = TimerWatcher::new(local_loop());\n             timer.period(1000)\n         };\n-        assert_eq!(port.recv_opt(), None);\n+        assert_eq!(port.recv_opt(), Err(()));\n     }\n \n     #[test]"}, {"sha": "58781c01d662e69af43816752572978871881d3c", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 125, "deletions": 114, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -322,25 +322,19 @@ pub struct SyncSender<T> {\n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n #[deriving(Eq, Clone, Show)]\n-pub enum TryRecvResult<T> {\n+pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n     Empty,\n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n     Disconnected,\n-    /// The channel had some data and we successfully popped it\n-    Data(T),\n }\n \n-/// This enumeration is the list of the possible outcomes for the\n+/// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n #[deriving(Eq, Clone, Show)]\n-pub enum TrySendResult<T> {\n-    /// The data was successfully sent along the channel. This either means that\n-    /// it was buffered in the channel, or handed off to a receiver. In either\n-    /// case, the callee no longer has ownership of the data.\n-    Sent,\n+pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n@@ -365,7 +359,7 @@ enum Flavor<T> {\n /// of `Receiver` and `Sender` to see what's possible with them.\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let (a, b) = UnsafeArc::new2(oneshot::Packet::new());\n-    (Sender::my_new(Oneshot(b)), Receiver::my_new(Oneshot(a)))\n+    (Sender::new(Oneshot(b)), Receiver::new(Oneshot(a)))\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -401,15 +395,15 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// ```\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let (a, b) = UnsafeArc::new2(sync::Packet::new(bound));\n-    (SyncSender::new(a), Receiver::my_new(Sync(b)))\n+    (SyncSender::new(a), Receiver::new(Sync(b)))\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Sender\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> Sender<T> {\n-    fn my_new(inner: Flavor<T>) -> Sender<T> {\n+    fn new(inner: Flavor<T>) -> Sender<T> {\n         Sender { inner: inner, sends: Cell::new(0), marker: marker::NoShare }\n     }\n \n@@ -433,25 +427,42 @@ impl<T: Send> Sender<T> {\n     /// The purpose of this functionality is to propagate failure among tasks.\n     /// If failure is not desired, then consider using the `try_send` method\n     pub fn send(&self, t: T) {\n-        if !self.try_send(t) {\n+        if self.send_opt(t).is_err() {\n             fail!(\"sending on a closed channel\");\n         }\n     }\n \n-    /// Attempts to send a value on this channel, returning whether it was\n-    /// successfully sent.\n+    /// Attempts to send a value on this channel, returning it back if it could\n+    /// not be sent.\n     ///\n     /// A successful send occurs when it is determined that the other end of\n     /// the channel has not hung up already. An unsuccessful send would be one\n     /// where the corresponding receiver has already been deallocated. Note\n-    /// that a return value of `false` means that the data will never be\n-    /// received, but a return value of `true` does *not* mean that the data\n+    /// that a return value of `Err` means that the data will never be\n+    /// received, but a return value of `Ok` does *not* mean that the data\n     /// will be received.  It is possible for the corresponding receiver to\n-    /// hang up immediately after this function returns `true`.\n+    /// hang up immediately after this function returns `Ok`.\n     ///\n-    /// Like `send`, this method will never block. If the failure of send cannot\n-    /// be tolerated, then this method should be used instead.\n-    pub fn try_send(&self, t: T) -> bool {\n+    /// Like `send`, this method will never block.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This method will never fail, it will return the message back to the\n+    /// caller if the other end is disconnected\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let (tx, rx) = channel();\n+    ///\n+    /// // This send is always successful\n+    /// assert_eq!(tx.send_opt(1), Ok(()));\n+    ///\n+    /// // This send will fail because the receiver is gone\n+    /// drop(rx);\n+    /// assert_eq!(tx.send_opt(1), Err(1));\n+    /// ```\n+    pub fn send_opt(&self, t: T) -> Result<(), T> {\n         // In order to prevent starvation of other tasks in situations where\n         // a task sends repeatedly without ever receiving, we occassionally\n         // yield instead of doing a send immediately.\n@@ -475,16 +486,19 @@ impl<T: Send> Sender<T> {\n                         return (*p).send(t);\n                     } else {\n                         let (a, b) = UnsafeArc::new2(stream::Packet::new());\n-                        match (*p).upgrade(Receiver::my_new(Stream(b))) {\n+                        match (*p).upgrade(Receiver::new(Stream(b))) {\n                             oneshot::UpSuccess => {\n-                                (*a.get()).send(t);\n-                                (a, true)\n+                                let ret = (*a.get()).send(t);\n+                                (a, ret)\n                             }\n-                            oneshot::UpDisconnected => (a, false),\n+                            oneshot::UpDisconnected => (a, Err(t)),\n                             oneshot::UpWoke(task) => {\n-                                (*a.get()).send(t);\n+                                // This send cannot fail because the task is\n+                                // asleep (we're looking at it), so the receiver\n+                                // can't go away.\n+                                (*a.get()).send(t).unwrap();\n                                 task.wake().map(|t| t.reawaken());\n-                                (a, true)\n+                                (a, Ok(()))\n                             }\n                         }\n                     }\n@@ -496,7 +510,7 @@ impl<T: Send> Sender<T> {\n         };\n \n         unsafe {\n-            let mut tmp = Sender::my_new(Stream(new_inner));\n+            let mut tmp = Sender::new(Stream(new_inner));\n             mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n         }\n         return ret;\n@@ -508,32 +522,32 @@ impl<T: Send> Clone for Sender<T> {\n         let (packet, sleeper) = match self.inner {\n             Oneshot(ref p) => {\n                 let (a, b) = UnsafeArc::new2(shared::Packet::new());\n-                match unsafe { (*p.get()).upgrade(Receiver::my_new(Shared(a))) } {\n+                match unsafe { (*p.get()).upgrade(Receiver::new(Shared(a))) } {\n                     oneshot::UpSuccess | oneshot::UpDisconnected => (b, None),\n                     oneshot::UpWoke(task) => (b, Some(task))\n                 }\n             }\n             Stream(ref p) => {\n                 let (a, b) = UnsafeArc::new2(shared::Packet::new());\n-                match unsafe { (*p.get()).upgrade(Receiver::my_new(Shared(a))) } {\n+                match unsafe { (*p.get()).upgrade(Receiver::new(Shared(a))) } {\n                     stream::UpSuccess | stream::UpDisconnected => (b, None),\n                     stream::UpWoke(task) => (b, Some(task)),\n                 }\n             }\n             Shared(ref p) => {\n                 unsafe { (*p.get()).clone_chan(); }\n-                return Sender::my_new(Shared(p.clone()));\n+                return Sender::new(Shared(p.clone()));\n             }\n             Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper);\n \n-            let mut tmp = Sender::my_new(Shared(packet.clone()));\n+            let mut tmp = Sender::new(Shared(packet.clone()));\n             mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n         }\n-        Sender::my_new(Shared(packet))\n+        Sender::new(Shared(packet))\n     }\n }\n \n@@ -579,7 +593,7 @@ impl<T: Send> SyncSender<T> {\n     /// `SyncSender::send_opt` method which will not fail if the receiver\n     /// disconnects.\n     pub fn send(&self, t: T) {\n-        if self.send_opt(t).is_some() {\n+        if self.send_opt(t).is_err() {\n             fail!(\"sending on a closed channel\");\n         }\n     }\n@@ -595,11 +609,8 @@ impl<T: Send> SyncSender<T> {\n     /// # Failure\n     ///\n     /// This function cannot fail.\n-    pub fn send_opt(&self, t: T) -> Option<T> {\n-        match unsafe { (*self.inner.get()).send(t) } {\n-            Ok(()) => None,\n-            Err(t) => Some(t),\n-        }\n+    pub fn send_opt(&self, t: T) -> Result<(), T> {\n+        unsafe { (*self.inner.get()).send(t) }\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n@@ -615,7 +626,7 @@ impl<T: Send> SyncSender<T> {\n     /// # Failure\n     ///\n     /// This function cannot fail\n-    pub fn try_send(&self, t: T) -> TrySendResult<T> {\n+    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n }\n@@ -639,7 +650,7 @@ impl<T: Send> Drop for SyncSender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> Receiver<T> {\n-    fn my_new(inner: Flavor<T>) -> Receiver<T> {\n+    fn new(inner: Flavor<T>) -> Receiver<T> {\n         Receiver { inner: inner, receives: Cell::new(0), marker: marker::NoShare }\n     }\n \n@@ -664,8 +675,8 @@ impl<T: Send> Receiver<T> {\n     ///   peek at a value on this receiver.\n     pub fn recv(&self) -> T {\n         match self.recv_opt() {\n-            Some(t) => t,\n-            None => fail!(\"receiving on a closed channel\"),\n+            Ok(t) => t,\n+            Err(()) => fail!(\"receiving on a closed channel\"),\n         }\n     }\n \n@@ -679,7 +690,7 @@ impl<T: Send> Receiver<T> {\n     /// block on a receiver.\n     ///\n     /// This function cannot fail.\n-    pub fn try_recv(&self) -> TryRecvResult<T> {\n+    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         // If a thread is spinning in try_recv, we should take the opportunity\n         // to reschedule things occasionally. See notes above in scheduling on\n         // sends for why this doesn't always hit TLS, and also for why this uses\n@@ -695,32 +706,32 @@ impl<T: Send> Receiver<T> {\n             let mut new_port = match self.inner {\n                 Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n-                        Ok(t) => return Data(t),\n-                        Err(oneshot::Empty) => return Empty,\n-                        Err(oneshot::Disconnected) => return Disconnected,\n+                        Ok(t) => return Ok(t),\n+                        Err(oneshot::Empty) => return Err(Empty),\n+                        Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n-                        Ok(t) => return Data(t),\n-                        Err(stream::Empty) => return Empty,\n-                        Err(stream::Disconnected) => return Disconnected,\n+                        Ok(t) => return Ok(t),\n+                        Err(stream::Empty) => return Err(Empty),\n+                        Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n-                        Ok(t) => return Data(t),\n-                        Err(shared::Empty) => return Empty,\n-                        Err(shared::Disconnected) => return Disconnected,\n+                        Ok(t) => return Ok(t),\n+                        Err(shared::Empty) => return Err(Empty),\n+                        Err(shared::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n                 Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n-                        Ok(t) => return Data(t),\n-                        Err(sync::Empty) => return Empty,\n-                        Err(sync::Disconnected) => return Disconnected,\n+                        Ok(t) => return Ok(t),\n+                        Err(sync::Empty) => return Err(Empty),\n+                        Err(sync::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n             };\n@@ -741,32 +752,32 @@ impl<T: Send> Receiver<T> {\n     /// In other words, this function has the same semantics as the `recv`\n     /// method except for the failure aspect.\n     ///\n-    /// If the channel has hung up, then `None` is returned. Otherwise `Some` of\n+    /// If the channel has hung up, then `Err` is returned. Otherwise `Ok` of\n     /// the value found on the receiver is returned.\n-    pub fn recv_opt(&self) -> Option<T> {\n+    pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n             let mut new_port = match self.inner {\n                 Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n-                        Ok(t) => return Some(t),\n+                        Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n-                        Err(oneshot::Disconnected) => return None,\n+                        Err(oneshot::Disconnected) => return Err(()),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n-                        Ok(t) => return Some(t),\n+                        Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n-                        Err(stream::Disconnected) => return None,\n+                        Err(stream::Disconnected) => return Err(()),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n-                        Ok(t) => return Some(t),\n+                        Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n-                        Err(shared::Disconnected) => return None,\n+                        Err(shared::Disconnected) => return Err(()),\n                     }\n                 }\n                 Sync(ref p) => return unsafe { (*p.get()).recv() }\n@@ -873,7 +884,7 @@ impl<T: Send> select::Packet for Receiver<T> {\n }\n \n impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n-    fn next(&mut self) -> Option<T> { self.rx.recv_opt() }\n+    fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }\n }\n \n #[unsafe_destructor]\n@@ -1022,7 +1033,7 @@ mod test {\n                 assert_eq!(rx.recv(), 1);\n             }\n             match rx.try_recv() {\n-                Data(..) => fail!(),\n+                Ok(..) => fail!(),\n                 _ => {}\n             }\n             dtx.send(());\n@@ -1136,45 +1147,45 @@ mod test {\n \n     test!(fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = channel::<int>();\n-        assert!(tx.try_send(10));\n+        assert!(tx.send_opt(10).is_ok());\n         assert!(rx.recv() == 10);\n     })\n \n     test!(fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        assert!(!tx.try_send(10));\n+        assert!(tx.send_opt(10).is_err());\n     })\n \n     test!(fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = channel::<int>();\n         tx.send(10);\n-        assert!(rx.recv_opt() == Some(10));\n+        assert!(rx.recv_opt() == Ok(10));\n     })\n \n     test!(fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert!(rx.recv_opt() == None);\n+        assert!(rx.recv_opt() == Err(()));\n     })\n \n     test!(fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Empty)\n+        assert_eq!(rx.try_recv(), Err(Empty))\n         tx.send(10);\n-        assert_eq!(rx.try_recv(), Data(10));\n+        assert_eq!(rx.try_recv(), Ok(10));\n     })\n \n     test!(fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Disconnected);\n-        assert_eq!(rx.try_recv(), Disconnected);\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n     })\n \n     test!(fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Empty);\n+        assert_eq!(rx.try_recv(), Err(Empty));\n     })\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n@@ -1335,7 +1346,7 @@ mod test {\n         tx.send(2);\n         tx.send(2);\n         tx.send(2);\n-        tx.try_send(2);\n+        let _ = tx.send_opt(2);\n         drop(tx);\n         assert_eq!(count_rx.recv(), 4);\n     })\n@@ -1353,14 +1364,14 @@ mod test {\n             tx3.send(());\n         });\n \n-        assert_eq!(rx1.try_recv(), Empty);\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n         tx2.send(());\n         rx3.recv();\n-        assert_eq!(rx1.try_recv(), Data(1));\n-        assert_eq!(rx1.try_recv(), Empty);\n+        assert_eq!(rx1.try_recv(), Ok(1));\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n         tx2.send(());\n         rx3.recv();\n-        assert_eq!(rx1.try_recv(), Disconnected);\n+        assert_eq!(rx1.try_recv(), Err(Disconnected));\n     })\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n@@ -1409,9 +1420,9 @@ mod test {\n             let mut hits = 0;\n             while hits < 10 {\n                 match rx.try_recv() {\n-                    Data(()) => { hits += 1; }\n-                    Empty => { Thread::yield_now(); }\n-                    Disconnected => return,\n+                    Ok(()) => { hits += 1; }\n+                    Err(Empty) => { Thread::yield_now(); }\n+                    Err(Disconnected) => return,\n                 }\n             }\n             cdone.send(());\n@@ -1542,7 +1553,7 @@ mod sync_tests {\n                 assert_eq!(rx.recv(), 1);\n             }\n             match rx.try_recv() {\n-                Data(..) => fail!(),\n+                Ok(..) => fail!(),\n                 _ => {}\n             }\n             dtx.send(());\n@@ -1596,50 +1607,50 @@ mod sync_tests {\n \n     test!(fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(tx.try_send(10), Sent);\n+        assert_eq!(tx.try_send(10), Ok(()));\n         assert!(rx.recv() == 10);\n     })\n \n     test!(fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        assert_eq!(tx.try_send(10), RecvDisconnected(10));\n+        assert_eq!(tx.try_send(10), Err(RecvDisconnected(10)));\n     })\n \n     test!(fn oneshot_single_thread_try_send_closed2() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(10), Full(10));\n+        assert_eq!(tx.try_send(10), Err(Full(10)));\n     })\n \n     test!(fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n         tx.send(10);\n-        assert!(rx.recv_opt() == Some(10));\n+        assert!(rx.recv_opt() == Ok(10));\n     })\n \n     test!(fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert!(rx.recv_opt() == None);\n+        assert!(rx.recv_opt() == Err(()));\n     })\n \n     test!(fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(rx.try_recv(), Empty)\n+        assert_eq!(rx.try_recv(), Err(Empty))\n         tx.send(10);\n-        assert_eq!(rx.try_recv(), Data(10));\n+        assert_eq!(rx.try_recv(), Ok(10));\n     })\n \n     test!(fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Disconnected);\n-        assert_eq!(rx.try_recv(), Disconnected);\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n     })\n \n     test!(fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = sync_channel::<int>(0);\n-        assert_eq!(rx.try_recv(), Empty);\n+        assert_eq!(rx.try_recv(), Err(Empty));\n     })\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n@@ -1800,7 +1811,7 @@ mod sync_tests {\n         tx.send(2);\n         tx.send(2);\n         tx.send(2);\n-        tx.try_send(2);\n+        let _ = tx.try_send(2);\n         drop(tx);\n         assert_eq!(count_rx.recv(), 4);\n     })\n@@ -1818,14 +1829,14 @@ mod sync_tests {\n             tx3.send(());\n         });\n \n-        assert_eq!(rx1.try_recv(), Empty);\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n         tx2.send(());\n         rx3.recv();\n-        assert_eq!(rx1.try_recv(), Data(1));\n-        assert_eq!(rx1.try_recv(), Empty);\n+        assert_eq!(rx1.try_recv(), Ok(1));\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n         tx2.send(());\n         rx3.recv();\n-        assert_eq!(rx1.try_recv(), Disconnected);\n+        assert_eq!(rx1.try_recv(), Err(Disconnected));\n     })\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n@@ -1859,9 +1870,9 @@ mod sync_tests {\n             let mut hits = 0;\n             while hits < 10 {\n                 match rx.try_recv() {\n-                    Data(()) => { hits += 1; }\n-                    Empty => { Thread::yield_now(); }\n-                    Disconnected => return,\n+                    Ok(()) => { hits += 1; }\n+                    Err(Empty) => { Thread::yield_now(); }\n+                    Err(Disconnected) => return,\n                 }\n             }\n             cdone.send(());\n@@ -1876,20 +1887,20 @@ mod sync_tests {\n     test!(fn send_opt1() {\n         let (tx, rx) = sync_channel(0);\n         spawn(proc() { rx.recv(); });\n-        assert_eq!(tx.send_opt(1), None);\n+        assert_eq!(tx.send_opt(1), Ok(()));\n     })\n \n     test!(fn send_opt2() {\n         let (tx, rx) = sync_channel(0);\n         spawn(proc() { drop(rx); });\n-        assert_eq!(tx.send_opt(1), Some(1));\n+        assert_eq!(tx.send_opt(1), Err(1));\n     })\n \n     test!(fn send_opt3() {\n         let (tx, rx) = sync_channel(1);\n-        assert_eq!(tx.send_opt(1), None);\n+        assert_eq!(tx.send_opt(1), Ok(()));\n         spawn(proc() { drop(rx); });\n-        assert_eq!(tx.send_opt(1), Some(1));\n+        assert_eq!(tx.send_opt(1), Err(1));\n     })\n \n     test!(fn send_opt4() {\n@@ -1898,11 +1909,11 @@ mod sync_tests {\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n         spawn(proc() {\n-            assert_eq!(tx.send_opt(1), Some(1));\n+            assert_eq!(tx.send_opt(1), Err(1));\n             done.send(());\n         });\n         spawn(proc() {\n-            assert_eq!(tx2.send_opt(2), Some(2));\n+            assert_eq!(tx2.send_opt(2), Err(2));\n             done2.send(());\n         });\n         drop(rx);\n@@ -1912,27 +1923,27 @@ mod sync_tests {\n \n     test!(fn try_send1() {\n         let (tx, _rx) = sync_channel(0);\n-        assert_eq!(tx.try_send(1), Full(1));\n+        assert_eq!(tx.try_send(1), Err(Full(1)));\n     })\n \n     test!(fn try_send2() {\n         let (tx, _rx) = sync_channel(1);\n-        assert_eq!(tx.try_send(1), Sent);\n-        assert_eq!(tx.try_send(1), Full(1));\n+        assert_eq!(tx.try_send(1), Ok(()));\n+        assert_eq!(tx.try_send(1), Err(Full(1)));\n     })\n \n     test!(fn try_send3() {\n         let (tx, rx) = sync_channel(1);\n-        assert_eq!(tx.try_send(1), Sent);\n+        assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n-        assert_eq!(tx.try_send(1), RecvDisconnected(1));\n+        assert_eq!(tx.try_send(1), Err(RecvDisconnected(1)));\n     })\n \n     test!(fn try_send4() {\n         let (tx, rx) = sync_channel(0);\n         spawn(proc() {\n             for _ in range(0, 1000) { task::deschedule(); }\n-            assert_eq!(tx.try_send(1), Sent);\n+            assert_eq!(tx.try_send(1), Ok(()));\n         });\n         assert_eq!(rx.recv(), 1);\n     } #[ignore(reason = \"flaky on libnative\")])"}, {"sha": "e92b5cb272a809ce7347dbcbe7de7ed809898f48", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -90,7 +90,7 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-    pub fn send(&mut self, t: T) -> bool {\n+    pub fn send(&mut self, t: T) -> Result<(), T> {\n         // Sanity check\n         match self.upgrade {\n             NothingSent => {}\n@@ -102,14 +102,12 @@ impl<T: Send> Packet<T> {\n \n         match self.state.swap(DATA, atomics::SeqCst) {\n             // Sent the data, no one was waiting\n-            EMPTY => true,\n+            EMPTY => Ok(()),\n \n-            // Couldn't send the data, the port hung up first. We need to be\n-            // sure to deallocate the sent data (to not leave it stuck in the\n-            // queue)\n+            // Couldn't send the data, the port hung up first. Return the data\n+            // back up the stack.\n             DISCONNECTED => {\n-                self.data.take_unwrap();\n-                false\n+                Err(self.data.take_unwrap())\n             }\n \n             // Not possible, these are one-use channels\n@@ -121,7 +119,7 @@ impl<T: Send> Packet<T> {\n             n => unsafe {\n                 let t = BlockedTask::cast_from_uint(n);\n                 t.wake().map(|t| t.reawaken());\n-                true\n+                Ok(())\n             }\n         }\n     }"}, {"sha": "c286fd84849340b1e35a5077d48aa0a43cd8a252", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -236,7 +236,7 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n     /// semantics as `Receiver.recv_opt`\n-    pub fn recv_opt(&mut self) -> Option<T> { self.rx.recv_opt() }\n+    pub fn recv_opt(&mut self) -> Result<T, ()> { self.rx.recv_opt() }\n \n     /// Adds this handle to the receiver set that the handle was created from. This\n     /// method can be called multiple times, but it has no effect if `add` was\n@@ -338,12 +338,12 @@ mod test {\n         )\n         drop(tx1);\n         select! (\n-            foo = rx1.recv_opt() => { assert_eq!(foo, None); },\n+            foo = rx1.recv_opt() => { assert_eq!(foo, Err(())); },\n             _bar = rx2.recv() => { fail!() }\n         )\n         drop(tx2);\n         select! (\n-            bar = rx2.recv_opt() => { assert_eq!(bar, None); }\n+            bar = rx2.recv_opt() => { assert_eq!(bar, Err(())); }\n         )\n     })\n \n@@ -370,7 +370,7 @@ mod test {\n \n         select! (\n             _a1 = rx1.recv_opt() => { fail!() },\n-            a2 = rx2.recv_opt() => { assert_eq!(a2, None); }\n+            a2 = rx2.recv_opt() => { assert_eq!(a2, Err(())); }\n         )\n     })\n \n@@ -392,7 +392,7 @@ mod test {\n         )\n         tx3.send(1);\n         select! (\n-            a = rx1.recv_opt() => { assert_eq!(a, None); },\n+            a = rx1.recv_opt() => { assert_eq!(a, Err(())); },\n             _b = rx2.recv() => { fail!() }\n         )\n     })\n@@ -417,8 +417,8 @@ mod test {\n             a = rx1.recv() => { assert_eq!(a, 1); },\n             a = rx2.recv() => { assert_eq!(a, 2); }\n         )\n-        assert_eq!(rx1.try_recv(), Empty);\n-        assert_eq!(rx2.try_recv(), Empty);\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n+        assert_eq!(rx2.try_recv(), Err(Empty));\n         tx3.send(());\n     })\n \n@@ -456,7 +456,7 @@ mod test {\n         spawn(proc() {\n             rx3.recv();\n             tx1.clone();\n-            assert_eq!(rx3.try_recv(), Empty);\n+            assert_eq!(rx3.try_recv(), Err(Empty));\n             tx1.send(2);\n             rx3.recv();\n         });\n@@ -477,7 +477,7 @@ mod test {\n         spawn(proc() {\n             rx3.recv();\n             tx1.clone();\n-            assert_eq!(rx3.try_recv(), Empty);\n+            assert_eq!(rx3.try_recv(), Err(Empty));\n             tx1.send(2);\n             rx3.recv();\n         });"}, {"sha": "525786f5d1e76bc58cb1edfeaca94c279e5f2167", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -131,9 +131,9 @@ impl<T: Send> Packet<T> {\n         unsafe { self.select_lock.unlock_noguard() }\n     }\n \n-    pub fn send(&mut self, t: T) -> bool {\n+    pub fn send(&mut self, t: T) -> Result<(), T> {\n         // See Port::drop for what's going on\n-        if self.port_dropped.load(atomics::SeqCst) { return false }\n+        if self.port_dropped.load(atomics::SeqCst) { return Err(t) }\n \n         // Note that the multiple sender case is a little tricker\n         // semantically than the single sender case. The logic for\n@@ -161,7 +161,7 @@ impl<T: Send> Packet<T> {\n         // received\". Once we get beyond this check, we have permanently\n         // entered the realm of \"this may be received\"\n         if self.cnt.load(atomics::SeqCst) < DISCONNECTED + FUDGE {\n-            return false\n+            return Err(t)\n         }\n \n         self.queue.push(t);\n@@ -213,7 +213,7 @@ impl<T: Send> Packet<T> {\n             _ => {}\n         }\n \n-        true\n+        Ok(())\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure> {"}, {"sha": "6c9280e0abc69156313d3df97bf15b3301ead0f9", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -87,25 +87,27 @@ impl<T: Send> Packet<T> {\n     }\n \n \n-    pub fn send(&mut self, t: T) -> bool {\n+    pub fn send(&mut self, t: T) -> Result<(), T> {\n+        // If the other port has deterministically gone away, then definitely\n+        // must return the data back up the stack. Otherwise, the data is\n+        // considered as being sent.\n+        if self.port_dropped.load(atomics::SeqCst) { return Err(t) }\n+\n         match self.do_send(Data(t)) {\n-            UpSuccess => true,\n-            UpDisconnected => false,\n-            UpWoke(task) => {\n-                task.wake().map(|t| t.reawaken());\n-                true\n-            }\n+            UpSuccess | UpDisconnected => {},\n+            UpWoke(task) => { task.wake().map(|t| t.reawaken()); }\n         }\n+        Ok(())\n     }\n     pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n+        // If the port has gone away, then there's no need to proceed any\n+        // further.\n+        if self.port_dropped.load(atomics::SeqCst) { return UpDisconnected }\n+\n         self.do_send(GoUp(up))\n     }\n \n     fn do_send(&mut self, t: Message<T>) -> UpgradeResult {\n-        // Use an acquire/release ordering to maintain the same position with\n-        // respect to the atomic loads below\n-        if self.port_dropped.load(atomics::SeqCst) { return UpDisconnected }\n-\n         self.queue.push(t);\n         match self.cnt.fetch_add(1, atomics::SeqCst) {\n             // As described in the mod's doc comment, -1 == wakeup"}, {"sha": "6228c4c682b061340315f4a92921179404e08e3e", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -201,38 +201,38 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-    pub fn try_send(&self, t: T) -> super::TrySendResult<T> {\n+    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n         let (guard, state) = self.lock();\n         if state.disconnected {\n-            super::RecvDisconnected(t)\n+            Err(super::RecvDisconnected(t))\n         } else if state.buf.size() == state.buf.cap() {\n-            super::Full(t)\n+            Err(super::Full(t))\n         } else if state.cap == 0 {\n             // With capacity 0, even though we have buffer space we can't\n             // transfer the data unless there's a receiver waiting.\n             match mem::replace(&mut state.blocker, NoneBlocked) {\n-                NoneBlocked => super::Full(t),\n+                NoneBlocked => Err(super::Full(t)),\n                 BlockedSender(..) => unreachable!(),\n                 BlockedReceiver(task) => {\n                     state.buf.enqueue(t);\n                     wakeup(task, guard);\n-                    super::Sent\n+                    Ok(())\n                 }\n             }\n         } else {\n             // If the buffer has some space and the capacity isn't 0, then we\n             // just enqueue the data for later retrieval.\n             assert!(state.buf.size() < state.buf.cap());\n             state.buf.enqueue(t);\n-            super::Sent\n+            Ok(())\n         }\n     }\n \n     // Receives a message from this channel\n     //\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n-    pub fn recv(&self) -> Option<T> {\n+    pub fn recv(&self) -> Result<T, ()> {\n         let (guard, state) = self.lock();\n \n         // Wait for the buffer to have something in it. No need for a while loop\n@@ -242,13 +242,13 @@ impl<T: Send> Packet<T> {\n             wait(&mut state.blocker, BlockedReceiver, &self.lock);\n             waited = true;\n         }\n-        if state.disconnected && state.buf.size() == 0 { return None }\n+        if state.disconnected && state.buf.size() == 0 { return Err(()) }\n \n         // Pick up the data, wake up our neighbors, and carry on\n         assert!(state.buf.size() > 0);\n         let ret = state.buf.dequeue();\n         self.wakeup_senders(waited, guard, state);\n-        return Some(ret);\n+        return Ok(ret);\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {"}, {"sha": "aa7371944daf73a25d16ef36ad480e70d06b2341", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -73,7 +73,7 @@ impl Reader for ChanReader {\n                 break;\n             }\n             self.pos = 0;\n-            self.buf = self.rx.recv_opt();\n+            self.buf = self.rx.recv_opt().ok();\n             self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n@@ -116,15 +116,13 @@ impl Clone for ChanWriter {\n \n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        if !self.tx.try_send(buf.to_owned()) {\n-            Err(io::IoError {\n+        self.tx.send_opt(buf.to_owned()).map_err(|_| {\n+            io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\",\n                 detail: None\n-            })\n-        } else {\n-            Ok(())\n-        }\n+            }\n+        })\n     }\n }\n "}, {"sha": "cd2c81d284ad1c07f7ca167cc53dea4838e4ddbb", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -422,13 +422,13 @@ mod test {\n         spawn(proc() {\n             let mut sock3 = sock3;\n             match sock3.sendto([1], addr2) {\n-                Ok(..) => { let _ = tx2.try_send(()); }\n+                Ok(..) => { let _ = tx2.send_opt(()); }\n                 Err(..) => {}\n             }\n             done.send(());\n         });\n         match sock1.sendto([2], addr2) {\n-            Ok(..) => { let _ = tx.try_send(()); }\n+            Ok(..) => { let _ = tx.send_opt(()); }\n             Err(..) => {}\n         }\n         drop(tx);"}, {"sha": "d3f3d888b87b9f66ce72ffc3246599d28493c603", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -149,6 +149,7 @@ impl Listener {\n \n #[cfg(test, unix)]\n mod test_unix {\n+    use prelude::*;\n     use libc;\n     use comm::Empty;\n     use io::timer;\n@@ -199,7 +200,7 @@ mod test_unix {\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);\n-        assert_eq!(s2.rx.try_recv(), Empty);\n+        assert_eq!(s2.rx.try_recv(), Err(Empty));\n     }\n }\n "}, {"sha": "1ca36df968ccef3fb9b71af9632d2020dc98cd27", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -137,15 +137,15 @@ mod test {\n         let rx1 = timer.oneshot(10000);\n         let rx = timer.oneshot(1);\n         rx.recv();\n-        assert_eq!(rx1.recv_opt(), None);\n+        assert_eq!(rx1.recv_opt(), Err(()));\n     })\n \n     iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(100000000000);\n         timer.sleep(1); // this should inalidate rx\n \n-        assert_eq!(rx.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn test_io_timer_sleep_periodic() {\n@@ -170,20 +170,20 @@ mod test {\n \n         let rx = timer.oneshot(1);\n         rx.recv();\n-        assert!(rx.recv_opt().is_none());\n+        assert!(rx.recv_opt().is_err());\n \n         let rx = timer.oneshot(1);\n         rx.recv();\n-        assert!(rx.recv_opt().is_none());\n+        assert!(rx.recv_opt().is_err());\n     })\n \n     iotest!(fn override() {\n         let mut timer = Timer::new().unwrap();\n         let orx = timer.oneshot(100);\n         let prx = timer.periodic(100);\n         timer.sleep(1);\n-        assert_eq!(orx.recv_opt(), None);\n-        assert_eq!(prx.recv_opt(), None);\n+        assert_eq!(orx.recv_opt(), Err(()));\n+        assert_eq!(prx.recv_opt(), Err(()));\n         timer.oneshot(1).recv();\n     })\n \n@@ -226,7 +226,7 @@ mod test {\n         let timer_rx = timer.periodic(1000);\n \n         spawn(proc() {\n-            timer_rx.recv_opt();\n+            let _ = timer_rx.recv_opt();\n         });\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -239,7 +239,7 @@ mod test {\n         let timer_rx = timer.periodic(1000);\n \n         spawn(proc() {\n-            timer_rx.recv_opt();\n+            let _ = timer_rx.recv_opt();\n         });\n \n         timer.oneshot(1);\n@@ -251,7 +251,7 @@ mod test {\n         let timer_rx = timer.periodic(1000);\n \n         spawn(proc() {\n-            timer_rx.recv_opt();\n+            let _ = timer_rx.recv_opt();\n         });\n \n         timer.sleep(1);\n@@ -262,15 +262,15 @@ mod test {\n             let mut timer = Timer::new().unwrap();\n             timer.oneshot(1000)\n         };\n-        assert_eq!(rx.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn sender_goes_away_period() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n             timer.periodic(1000)\n         };\n-        assert_eq!(rx.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn receiver_goes_away_oneshot() {"}, {"sha": "a112ed77f094fba756c3b48231ec4a12ea4aaff9", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -385,7 +385,7 @@ impl Death {\n     pub fn collect_failure(&mut self, result: TaskResult) {\n         match self.on_exit.take() {\n             Some(Execute(f)) => f(result),\n-            Some(SendMessage(ch)) => { ch.try_send(result); }\n+            Some(SendMessage(ch)) => { let _ = ch.send_opt(result); }\n             None => {}\n         }\n     }"}, {"sha": "13e075501d9f58027042856b7e90a123aef62bf4", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -37,16 +37,16 @@ impl<S:Send,R:Send> DuplexStream<S, R> {\n     pub fn send(&self, x: S) {\n         self.tx.send(x)\n     }\n-    pub fn try_send(&self, x: S) -> bool {\n-        self.tx.try_send(x)\n+    pub fn send_opt(&self, x: S) -> Result<(), S> {\n+        self.tx.send_opt(x)\n     }\n     pub fn recv(&self) -> R {\n         self.rx.recv()\n     }\n-    pub fn try_recv(&self) -> comm::TryRecvResult<R> {\n+    pub fn try_recv(&self) -> Result<R, comm::TryRecvError> {\n         self.rx.try_recv()\n     }\n-    pub fn recv_opt(&self) -> Option<R> {\n+    pub fn recv_opt(&self) -> Result<R, ()> {\n         self.rx.recv_opt()\n     }\n }"}, {"sha": "911cd1d2eb1ccdb80036a64160363a8509a37887", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -800,7 +800,7 @@ mod tests {\n         // At this point, all spawned tasks should be blocked,\n         // so we shouldn't get anything from the port\n         assert!(match rx.try_recv() {\n-            Empty => true,\n+            Err(Empty) => true,\n             _ => false,\n         });\n "}, {"sha": "eb90797395edfed6458ac34ff7c0ac55d11b458d", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -16,7 +16,6 @@\n //! containing data.\n \n use std::cast;\n-use std::comm;\n use std::kinds::marker;\n use std::mem::replace;\n use std::sync::atomics;\n@@ -46,10 +45,10 @@ impl WaitQueue {\n     // Signals one live task from the queue.\n     fn signal(&self) -> bool {\n         match self.head.try_recv() {\n-            comm::Data(ch) => {\n+            Ok(ch) => {\n                 // Send a wakeup signal. If the waiter was killed, its port will\n                 // have closed. Keep trying until we get a live task.\n-                if ch.try_send(()) {\n+                if ch.send_opt(()).is_ok() {\n                     true\n                 } else {\n                     self.signal()\n@@ -63,8 +62,8 @@ impl WaitQueue {\n         let mut count = 0;\n         loop {\n             match self.head.try_recv() {\n-                comm::Data(ch) => {\n-                    if ch.try_send(()) {\n+                Ok(ch) => {\n+                    if ch.send_opt(()).is_ok() {\n                         count += 1;\n                     }\n                 }\n@@ -76,7 +75,7 @@ impl WaitQueue {\n \n     fn wait_end(&self) -> WaitEnd {\n         let (signal_end, wait_end) = channel();\n-        assert!(self.tail.try_send(signal_end));\n+        self.tail.send(signal_end);\n         wait_end\n     }\n }"}, {"sha": "d2e08cfccf890be1fcc12f4f06cd7cd08f442b55", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -38,12 +38,12 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     let mut done = false;\n     while !done {\n         match requests.recv_opt() {\n-          Some(get_count) => { responses.send(count.clone()); }\n-          Some(bytes(b)) => {\n+          Ok(get_count) => { responses.send(count.clone()); }\n+          Ok(bytes(b)) => {\n             //println!(\"server: received {:?} bytes\", b);\n             count += b;\n           }\n-          None => { done = true; }\n+          Err(..) => { done = true; }\n           _ => { }\n         }\n     }"}, {"sha": "dc9b3561bb16857bd677edd52c54c4d9c61ca5dc", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -33,12 +33,12 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     let mut done = false;\n     while !done {\n         match requests.recv_opt() {\n-          Some(get_count) => { responses.send(count.clone()); }\n-          Some(bytes(b)) => {\n+          Ok(get_count) => { responses.send(count.clone()); }\n+          Ok(bytes(b)) => {\n             //println!(\"server: received {:?} bytes\", b);\n             count += b;\n           }\n-          None => { done = true; }\n+          Err(..) => { done = true; }\n           _ => { }\n         }\n     }"}, {"sha": "a45f8c61be50f9ec738eb00ffde871e141aedc26", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -50,7 +50,7 @@ fn main() {\n \n     let (tx, rx) = channel();\n     child_generation(from_str::<uint>(*args.get(1)).unwrap(), tx);\n-    if rx.recv_opt().is_none() {\n+    if rx.recv_opt().is_err() {\n         fail!(\"it happened when we slumbered\");\n     }\n }"}, {"sha": "9f08f1db41057a6b5c9935172166d5a4b85d2abe", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -20,9 +20,9 @@ pub fn main() {\n     });\n     loop {\n         match rx.try_recv() {\n-            comm::Data(()) => break,\n-            comm::Empty => {}\n-            comm::Disconnected => unreachable!()\n+            Ok(()) => break,\n+            Err(comm::Empty) => {}\n+            Err(comm::Disconnected) => unreachable!()\n         }\n     }\n }"}]}