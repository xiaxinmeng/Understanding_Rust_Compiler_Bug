{"sha": "91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMDI0ZjFmZGVlMmQyYzJmZWJmYzdjNzYxMjdkNjhkMmI2ZTYyOWU=", "commit": {"author": {"name": "Jane Lusby", "email": "jlusby@yaah.dev", "date": "2020-08-26T23:31:49Z"}, "committer": {"name": "Jane Lusby", "email": "jlusby@yaah.dev", "date": "2020-08-26T23:31:49Z"}, "message": "Add new lint to prevent usage of unwrap in fns that return result", "tree": {"sha": "b4fc470d1761d4c0bed9023a0642eaf7981dda98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4fc470d1761d4c0bed9023a0642eaf7981dda98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "html_url": "https://github.com/rust-lang/rust/commit/91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/comments", "author": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e45c59e922c4450b8ab136eac38a37000fca9254", "url": "https://api.github.com/repos/rust-lang/rust/commits/e45c59e922c4450b8ab136eac38a37000fca9254", "html_url": "https://github.com/rust-lang/rust/commit/e45c59e922c4450b8ab136eac38a37000fca9254"}], "stats": {"total": 237, "additions": 237, "deletions": 0}, "files": [{"sha": "137b561028a658fae51e18d0a5a16601a1a66e9c", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "patch": "@@ -1778,6 +1778,7 @@ Released 2018-09-13\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n+[`unwrap_in_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_in_result\n [`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n [`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self"}, {"sha": "577ce6523b491f4342a4138f75c229fe61bcd9f5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "patch": "@@ -314,6 +314,7 @@ mod unused_io_amount;\n mod unused_self;\n mod unused_unit;\n mod unwrap;\n+mod unwrap_in_result;\n mod use_self;\n mod useless_conversion;\n mod vec;\n@@ -850,6 +851,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unused_unit::UNUSED_UNIT,\n         &unwrap::PANICKING_UNWRAP,\n         &unwrap::UNNECESSARY_UNWRAP,\n+        &unwrap_in_result::UNWRAP_IN_RESULT,\n         &use_self::USE_SELF,\n         &useless_conversion::USELESS_CONVERSION,\n         &utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n@@ -1094,6 +1096,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n+    store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n \n@@ -1133,6 +1136,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&shadow::SHADOW_REUSE),\n         LintId::of(&shadow::SHADOW_SAME),\n         LintId::of(&strings::STRING_ADD),\n+        LintId::of(&unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(&verbose_file_reads::VERBOSE_FILE_READS),\n         LintId::of(&write::PRINT_STDOUT),\n         LintId::of(&write::USE_DEBUG),"}, {"sha": "1c7e62ecd3d2c0c1e7fe6e8c149ad8ebbed8d4ae", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "patch": "@@ -0,0 +1,140 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, return_ty, span_lint_and_then, walk_ptrs_ty};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions of type Result that contain `expect()` or `unwrap()`\n+    ///\n+    /// **Why is this bad?** These functions promote recoverable errors to non-recoverable errors which may be undesirable in code bases which wish to avoid panics.\n+    ///\n+    /// **Known problems:** This can cause false positives in functions that handle both recoverable and non recoverable errors.\n+    ///\n+    /// **Example:**\n+    /// Before:\n+    /// ```rust\n+    /// fn divisible_by_3(i_str: String) -> Result<(), String> {\n+    ///     let i = i_str\n+    ///         .parse::<i32>()\n+    ///         .expect(\"cannot divide the input by three\");\n+    ///\n+    ///     if i % 3 != 0 {\n+    ///         Err(\"Number is not divisible by 3\")?\n+    ///     }\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// After:\n+    /// ```rust\n+    /// fn divisible_by_3(i_str: String) -> Result<(), String> {\n+    ///     let i = i_str\n+    ///         .parse::<i32>()\n+    ///         .map_err(|e| format!(\"cannot divide the input by three: {}\", e))?;\n+    ///\n+    ///     if i % 3 != 0 {\n+    ///         Err(\"Number is not divisible by 3\")?\n+    ///     }\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    pub UNWRAP_IN_RESULT,\n+    restriction,\n+    \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\"\n+}\n+\n+declare_lint_pass!(UnwrapInResult=> [UNWRAP_IN_RESULT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n+        if_chain! {\n+            // first check if it's a method or function\n+            if let hir::ImplItemKind::Fn(ref _signature, _) = impl_item.kind;\n+            // checking if its return type is `result` or `option`\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(result_type))\n+                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(option_type));\n+            then {\n+                lint_impl_body(cx, impl_item.span, impl_item);\n+            }\n+        }\n+    }\n+}\n+\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ImplItemKind};\n+\n+struct FindExpectUnwrap<'a, 'tcx> {\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        // check for `expect`\n+        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n+            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            {\n+                self.result.push(expr.span);\n+            }\n+        }\n+\n+        // check for `unwrap`\n+        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            {\n+                self.result.push(expr.span);\n+            }\n+        }\n+\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if_chain! {\n+\n+        if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n+        then {\n+            let body = cx.tcx.hir().body(body_id);\n+            let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+            let mut fpu = FindExpectUnwrap {\n+                lcx: cx,\n+                typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                result: Vec::new(),\n+            };\n+            fpu.visit_expr(&body.value);\n+\n+            // if we've found one, lint\n+            if  !fpu.result.is_empty()  {\n+                span_lint_and_then(\n+                    cx,\n+                    UNWRAP_IN_RESULT,\n+                    impl_span,\n+                    \"used unwrap or expect in a function that returns result or option\",\n+                    move |diag| {\n+                        diag.help(\n+                            \"unwrap and expect should not be used in a function that returns result or option\" );\n+                        diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    });\n+            }\n+        }\n+    }\n+}"}, {"sha": "687fac7baa848038e9c5a735728907dd177b37fb", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "patch": "@@ -2516,6 +2516,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"unused_unit\",\n     },\n+    Lint {\n+        name: \"unwrap_in_result\",\n+        group: \"restriction\",\n+        desc: \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\",\n+        deprecation: None,\n+        module: \"unwrap_in_result\",\n+    },\n     Lint {\n         name: \"unwrap_used\",\n         group: \"restriction\","}, {"sha": "2aa842adc85609690dfbc6f09875fb4b5541f338", "filename": "tests/ui/unwrap_in_result.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/tests%2Fui%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/tests%2Fui%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_in_result.rs?ref=91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::unwrap_in_result)]\n+\n+struct A;\n+\n+impl A {\n+    // should not be detected\n+    fn good_divisible_by_3(i_str: String) -> Result<bool, String> {\n+        // checks whether a string represents a number divisible by 3\n+        let i_result = i_str.parse::<i32>();\n+        match i_result {\n+            Err(_e) => Err(\"Not a number\".to_string()),\n+            Ok(i) => {\n+                if i % 3 == 0 {\n+                    return Ok(true);\n+                }\n+                Err(\"Number is not divisible by 3\".to_string())\n+            },\n+        }\n+    }\n+\n+    // should be detected\n+    fn bad_divisible_by_3(i_str: String) -> Result<bool, String> {\n+        // checks whether a string represents a number divisible by 3\n+        let i = i_str.parse::<i32>().unwrap();\n+        if i % 3 == 0 {\n+            Ok(true)\n+        } else {\n+            Err(\"Number is not divisible by 3\".to_string())\n+        }\n+    }\n+\n+    fn example_option_expect(i_str: String) -> Option<bool> {\n+        let i = i_str.parse::<i32>().expect(\"not a number\");\n+        if i % 3 == 0 {\n+            return Some(true);\n+        }\n+        None\n+    }\n+}\n+\n+fn main() {\n+    A::bad_divisible_by_3(\"3\".to_string());\n+    A::good_divisible_by_3(\"3\".to_string());\n+}"}, {"sha": "56bc2f2d1c00edfe1665a9b532e2edd4ab299d7c", "filename": "tests/ui/unwrap_in_result.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/tests%2Fui%2Funwrap_in_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91024f1fdee2d2c2febfc7c76127d68d2b6e629e/tests%2Fui%2Funwrap_in_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_in_result.stderr?ref=91024f1fdee2d2c2febfc7c76127d68d2b6e629e", "patch": "@@ -0,0 +1,41 @@\n+error: used unwrap or expect in a function that returns result or option\n+  --> $DIR/unwrap_in_result.rs:22:5\n+   |\n+LL | /     fn bad_divisible_by_3(i_str: String) -> Result<bool, String> {\n+LL | |         // checks whether a string represents a number divisible by 3\n+LL | |         let i = i_str.parse::<i32>().unwrap();\n+LL | |         if i % 3 == 0 {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::unwrap-in-result` implied by `-D warnings`\n+   = help: unwrap and expect should not be used in a function that returns result or option\n+note: potential non-recoverable error(s)\n+  --> $DIR/unwrap_in_result.rs:24:17\n+   |\n+LL |         let i = i_str.parse::<i32>().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: used unwrap or expect in a function that returns result or option\n+  --> $DIR/unwrap_in_result.rs:32:5\n+   |\n+LL | /     fn example_option_expect(i_str: String) -> Option<bool> {\n+LL | |         let i = i_str.parse::<i32>().expect(\"not a number\");\n+LL | |         if i % 3 == 0 {\n+LL | |             return Some(true);\n+LL | |         }\n+LL | |         None\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: unwrap and expect should not be used in a function that returns result or option\n+note: potential non-recoverable error(s)\n+  --> $DIR/unwrap_in_result.rs:33:17\n+   |\n+LL |         let i = i_str.parse::<i32>().expect(\"not a number\");\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}