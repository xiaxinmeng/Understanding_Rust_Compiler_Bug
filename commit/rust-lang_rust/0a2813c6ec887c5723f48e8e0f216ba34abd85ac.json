{"sha": "0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMjgxM2M2ZWM4ODdjNTcyM2Y0OGU4ZTBmMjE2YmEzNGFiZDg1YWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-21T14:29:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-21T14:29:49Z"}, "message": "Rollup merge of #67467 - matthewjasper:test-slice-patterns, r=oli-obk\n\nTest slice patterns more\n\nAdds tests for const evaluation and some more borrow checking tests.\n\nFixes some bugs in const eval for subslice patterns.\ncloses #66934\n\nr? @oli-obk\ncc @Centril", "tree": {"sha": "bcd3a73aabfac085f3a8bb694207216ba6cf502f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcd3a73aabfac085f3a8bb694207216ba6cf502f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/ixdCRBK7hj4Ov3rIwAAdHIIAEbcCeRM+b8IMLPOwFaenXRX\nAr4i8fNbehxlEyjcGoiaiA08n2jd5F/YqJlPT8d64EVh//fMP/KpbJzwIdy/MM16\nJf+K+2CDbT2MiQxs0rCDf13MJOeI3usFADg6T5FFZ5w81A6IeubM5mFEUtsv9UQG\n/uFEt7sZNK2EIjQX1tfg4iu1vm1hrVte9O9bVy6TOHQNFwq08iik79bk/ILpAJcJ\nFOkEFZoXjqUOpCG05vgvIBC6SzEurcRDbRYxWeUtOdBoByKAXQVpMGySTYWOIHcg\n2Hc2w4O/rNfo1vb0NeEmh0ZtAfPkmV5pyaahYm9XPzLD4MX/CvKO61uFVf1WZok=\n=fbpU\n-----END PGP SIGNATURE-----\n", "payload": "tree bcd3a73aabfac085f3a8bb694207216ba6cf502f\nparent f43ced3dbc3c4563c82bcf807ce8f18061c6b96e\nparent 8c3c4466483af5f51b49148c64844ea0d31b59da\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576938589 +0100\ncommitter GitHub <noreply@github.com> 1576938589 +0100\n\nRollup merge of #67467 - matthewjasper:test-slice-patterns, r=oli-obk\n\nTest slice patterns more\n\nAdds tests for const evaluation and some more borrow checking tests.\n\nFixes some bugs in const eval for subslice patterns.\ncloses #66934\n\nr? @oli-obk\ncc @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "html_url": "https://github.com/rust-lang/rust/commit/0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f43ced3dbc3c4563c82bcf807ce8f18061c6b96e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f43ced3dbc3c4563c82bcf807ce8f18061c6b96e", "html_url": "https://github.com/rust-lang/rust/commit/f43ced3dbc3c4563c82bcf807ce8f18061c6b96e"}, {"sha": "8c3c4466483af5f51b49148c64844ea0d31b59da", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c3c4466483af5f51b49148c64844ea0d31b59da", "html_url": "https://github.com/rust-lang/rust/commit/8c3c4466483af5f51b49148c64844ea0d31b59da"}], "stats": {"total": 707, "additions": 703, "deletions": 4}, "files": [{"sha": "93ab7b9aab7fbf5925b3a404570f056eacdad991", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -444,13 +444,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n-            Subslice { .. } | ConstantIndex { .. } | Index(_) => if base.layout.is_zst() {\n+            ConstantIndex { .. } | Index(_) if base.layout.is_zst() => {\n                 OpTy {\n                     op: Operand::Immediate(Scalar::zst().into()),\n                     // the actual index doesn't matter, so we just pick a convenient one like 0\n                     layout: base.layout.field(self, 0)?,\n                 }\n-            } else {\n+            }\n+            Subslice { from, to, from_end } if base.layout.is_zst() => {\n+                let elem_ty = if let ty::Array(elem_ty, _) = base.layout.ty.kind {\n+                    elem_ty\n+                } else {\n+                    bug!(\"slices shouldn't be zero-sized\");\n+                };\n+                assert!(!from_end, \"arrays shouldn't be subsliced from the end\");\n+\n+                OpTy {\n+                    op: Operand::Immediate(Scalar::zst().into()),\n+                    layout: self.layout_of(self.tcx.mk_array(elem_ty, (to - from) as u64))?,\n+                }\n+            }\n+            Subslice { .. } | ConstantIndex { .. }  | Index(_) => {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n                 let mplace = base.assert_mem_place();"}, {"sha": "8923b167fdee8aa8cdf8244ec576eb6c7fe7d24f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -455,7 +455,10 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let actual_to = if from_end {\n-            assert!(from <= len - to);\n+            if from + to > len {\n+                // This can only be reached in ConstProp and non-rustc-MIR.\n+                throw_ub!(BoundsCheckFailed { len: len as u64, index: from as u64 + to as u64 });\n+            }\n             len - to\n         } else {\n             to\n@@ -523,7 +526,11 @@ where\n                 from_end,\n             } => {\n                 let n = base.len(self)?;\n-                assert!(n >= min_length as u64);\n+                if n < min_length as u64 {\n+                    // This can only be reached in ConstProp and non-rustc-MIR.\n+                    throw_ub!(BoundsCheckFailed { len: min_length as u64, index: n as u64 });\n+                }\n+                assert!(offset < min_length);\n \n                 let index = if from_end {\n                     n - u64::from(offset)"}, {"sha": "0e767d9613a996b7f591cfb472aab1d58b6e82f9", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,97 @@\n+// Test that slice subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#![feature(slice_patterns, const_fn, const_if_match)]\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation_inner {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Compare the result of matching `$e` against `$p` using both `if let` and\n+// `match`.\n+macro_rules! compare_evaluation {\n+    ($p:pat, $e:expr, $matches:expr, $t:ty $(,)?) => {{\n+        compare_evaluation_inner!(if let $p = $e as &[_] { $matches } else { None }, $t);\n+        compare_evaluation_inner!(match $e as &[_] { $p => $matches, _ => None }, $t);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!([_, x @ .., _], &$arr!(1, 2, 3, 4), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1, 2, 3, 4), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1, 2, 3, 4), Some(x), Option<&'static $Ty>);\n+\n+        compare_evaluation!([_, x @ .., _], &$arr!(1, 2), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1, 2), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1, 2), Some(x), Option<&'static $Ty>);\n+\n+        compare_evaluation!([_, x @ .., _], &$arr!(1), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1), Some(x), Option<&'static $Ty>);\n+    }\n+\n+    compare_evaluation!([N(x), .., _], &n!(1, 2, 3, 4), Some(x), Option<&'static u8>);\n+    compare_evaluation!([_, .., N(x)], &n!(1, 2, 3, 4), Some(x), Option<&'static u8>);\n+\n+    compare_evaluation!([N(x), .., _], &n!(1, 2), Some(x), Option<&'static u8>);\n+    compare_evaluation!([_, .., N(x)], &n!(1, 2), Some(x), Option<&'static u8>);\n+}"}, {"sha": "5444f8a9051bdae248ee4b09fb684ecc93f09053", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,97 @@\n+// Test that array subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#![feature(slice_patterns)]\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!({ let [_, x @ .., _] = $arr!(1, 2, 3, 4); x }, [$Ty; 2]);\n+        compare_evaluation!({ let [_, ref x @ .., _] = $arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+        compare_evaluation!({ let [_, x @ .., _] = &$arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+\n+        compare_evaluation!({ let [_, _, x @ .., _, _] = $arr!(1, 2, 3, 4); x }, [$Ty; 0]);\n+        compare_evaluation!(\n+            { let [_, _, ref x @ .., _, _] = $arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+        compare_evaluation!(\n+            { let [_, _, x @ .., _, _] = &$arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+\n+        compare_evaluation!({ let [_, .., x] = $arr!(1, 2, 3, 4); x }, $Ty);\n+        compare_evaluation!({ let [_, .., ref x] = $arr!(1, 2, 3, 4); x }, &'static $Ty);\n+        compare_evaluation!({ let [_, _y @ .., x] = &$arr!(1, 2, 3, 4); x }, &'static $Ty);\n+    }\n+\n+    compare_evaluation!({ let [_, .., N(x)] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [_, .., N(ref x)] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [_, .., N(x)] = &n!(1, 2, 3, 4); x }, &'static u8);\n+\n+    compare_evaluation!({ let [N(x), .., _] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [N(ref x), .., _] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [N(x), .., _] = &n!(1, 2, 3, 4); x }, &'static u8);\n+}"}, {"sha": "a70ccb7aa4b73ccd51c7f5cbee83a09a70ac9eb0", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns-ok.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,118 @@\n+// Check that closure captures for slice patterns are inferred correctly\n+\n+#![feature(slice_patterns)]\n+#![allow(unused_variables)]\n+\n+// run-pass\n+\n+fn arr_by_ref(x: [String; 3]) {\n+    let r = &x;\n+    let f = || {\n+        let [ref y, ref z @ ..] = x;\n+    };\n+    f();\n+    f();\n+    // Ensure `x` was borrowed\n+    drop(r);\n+    // Ensure that `x` wasn't moved from.\n+    drop(x);\n+}\n+\n+fn arr_by_mut(mut x: [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = x;\n+    };\n+    f();\n+    f();\n+    drop(x);\n+}\n+\n+fn arr_by_move(x: [String; 3]) {\n+    let f = || {\n+        let [y, z @ ..] = x;\n+    };\n+    f();\n+}\n+\n+fn arr_ref_by_ref(x: &[String; 3]) {\n+    let r = &x;\n+    let f = || {\n+        let [ref y, ref z @ ..] = *x;\n+    };\n+    let g = || {\n+        let [y, z @ ..] = x;\n+    };\n+    f();\n+    g();\n+    f();\n+    g();\n+    drop(r);\n+    drop(x);\n+}\n+\n+fn arr_ref_by_mut(x: &mut [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = *x;\n+    };\n+    f();\n+    f();\n+    let mut g = || {\n+        let [y, z @ ..] = x;\n+        // Ensure binding mode was chosen correctly:\n+        std::mem::swap(y, &mut z[0]);\n+    };\n+    g();\n+    g();\n+    drop(x);\n+}\n+\n+fn arr_box_by_move(x: Box<[String; 3]>) {\n+    let f = || {\n+        let [y, z @ ..] = *x;\n+    };\n+    f();\n+}\n+\n+fn slice_by_ref(x: &[String]) {\n+    let r = &x;\n+    let f = || {\n+        if let [ref y, ref z @ ..] = *x {}\n+    };\n+    let g = || {\n+        if let [y, z @ ..] = x {}\n+    };\n+    f();\n+    g();\n+    f();\n+    g();\n+    drop(r);\n+    drop(x);\n+}\n+\n+fn slice_by_mut(x: &mut [String]) {\n+    let mut f = || {\n+        if let [ref mut y, ref mut z @ ..] = *x {}\n+    };\n+    f();\n+    f();\n+    let mut g = || {\n+        if let [y, z @ ..] = x {\n+            // Ensure binding mode was chosen correctly:\n+            std::mem::swap(y, &mut z[0]);\n+        }\n+    };\n+    g();\n+    g();\n+    drop(x);\n+}\n+\n+fn main() {\n+    arr_by_ref(Default::default());\n+    arr_by_mut(Default::default());\n+    arr_by_move(Default::default());\n+    arr_ref_by_ref(&Default::default());\n+    arr_ref_by_mut(&mut Default::default());\n+    arr_box_by_move(Default::default());\n+    slice_by_ref(&<[_; 3]>::default());\n+    slice_by_mut(&mut <[_; 3]>::default());\n+}"}, {"sha": "984eb8804b7a2ea7be683182b4fc62e25c070ba4", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,84 @@\n+// Check that closure captures for slice patterns are inferred correctly\n+\n+#![feature(slice_patterns)]\n+\n+fn arr_by_ref(mut x: [String; 3]) {\n+    let f = || {\n+        let [ref y, ref z @ ..] = x;\n+    };\n+    let r = &mut x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_by_mut(mut x: [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = x;\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_by_move(x: [String; 3]) {\n+    let f = || {\n+        let [y, z @ ..] = x;\n+    };\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn arr_ref_by_ref(x: &mut [String; 3]) {\n+    let f = || {\n+        let [ref y, ref z @ ..] = *x;\n+    };\n+    let r = &mut *x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_ref_by_uniq(x: &mut [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = *x;\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_box_by_move(x: Box<[String; 3]>) {\n+    let f = || {\n+        let [y, z @ ..] = *x;\n+    };\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn slice_by_ref(x: &mut [String]) {\n+    let f = || {\n+        if let [ref y, ref z @ ..] = *x {}\n+    };\n+    let r = &mut *x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn slice_by_uniq(x: &mut [String]) {\n+    let mut f = || {\n+        if let [ref mut y, ref mut z @ ..] = *x {}\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn main() {\n+    arr_by_ref(Default::default());\n+    arr_by_mut(Default::default());\n+    arr_by_move(Default::default());\n+    arr_ref_by_ref(&mut Default::default());\n+    arr_ref_by_uniq(&mut Default::default());\n+    arr_box_by_move(Default::default());\n+    slice_by_ref(&mut <[_; 3]>::default());\n+    slice_by_uniq(&mut <[_; 3]>::default());\n+}"}, {"sha": "c5b27f5f8b4032d34ae46e4f041d5f4f67c0ad77", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.stderr", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,114 @@\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:9:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         let [ref y, ref z @ ..] = x;\n+   |                                   - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut x;\n+   |             ^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:18:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- mutable borrow occurs here\n+LL |         let [ref mut y, ref mut z @ ..] = x;\n+   |                                           - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ immutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - mutable borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/borrowck-closures-slice-patterns.rs:27:5\n+   |\n+LL | fn arr_by_move(x: [String; 3]) {\n+   |                - move occurs because `x` has type `[std::string::String; 3]`, which does not implement the `Copy` trait\n+LL |     let f = || {\n+   |             -- value moved into closure here\n+LL |         let [y, z @ ..] = x;\n+   |                           - variable moved due to use in closure\n+LL |     };\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:35:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         let [ref y, ref z @ ..] = *x;\n+   |                                    - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut *x;\n+   |             ^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/borrowck-closures-slice-patterns.rs:44:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- closure construction occurs here\n+LL |         let [ref mut y, ref mut z @ ..] = *x;\n+   |                                            - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ second borrow occurs here\n+LL |\n+LL |     f();\n+   |     - first borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/borrowck-closures-slice-patterns.rs:53:5\n+   |\n+LL | fn arr_box_by_move(x: Box<[String; 3]>) {\n+   |                    - move occurs because `x` has type `std::boxed::Box<[std::string::String; 3]>`, which does not implement the `Copy` trait\n+LL |     let f = || {\n+   |             -- value moved into closure here\n+LL |         let [y, z @ ..] = *x;\n+   |                            - variable moved due to use in closure\n+LL |     };\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:61:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         if let [ref y, ref z @ ..] = *x {}\n+   |                                       - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut *x;\n+   |             ^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/borrowck-closures-slice-patterns.rs:70:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- closure construction occurs here\n+LL |         if let [ref mut y, ref mut z @ ..] = *x {}\n+   |                                               - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ second borrow occurs here\n+LL |\n+LL |     f();\n+   |     - first borrow later used here\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0382, E0501, E0502.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "4ca60ddfec27c7c941c3eaa066f7be226cf3e85d", "filename": "src/test/ui/moves/move-out-of-array-ref.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,36 @@\n+// Ensure that we cannot move out of a reference to a fixed-size array\n+\n+#![feature(slice_patterns)]\n+\n+struct D { _x: u8 }\n+\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+fn move_elem(a: &[D; 4]) -> D {\n+    let [_, e, _, _] = *a;              //~ ERROR cannot move\n+    e\n+}\n+\n+fn move_subarr(a: &[D; 4]) -> [D; 2] {\n+    let [_, s @ .. , _] = *a;           //~ ERROR cannot move\n+    s\n+}\n+\n+fn move_elem_mut(a: &mut [D; 4]) -> D {\n+    let [_, e, _, _] = *a;              //~ ERROR cannot move\n+    e\n+}\n+\n+fn move_subarr_mut(a: &mut [D; 4]) -> [D; 2] {\n+    let [_, s @ .. , _] = *a;           //~ ERROR cannot move\n+    s\n+}\n+\n+fn main() {\n+    fn d() -> D { D { _x: 0 } }\n+\n+    move_elem(&[d(), d(), d(), d()]);\n+    move_subarr(&[d(), d(), d(), d()]);\n+    move_elem_mut(&mut [d(), d(), d(), d()]);\n+    move_subarr_mut(&mut [d(), d(), d(), d()]);\n+}"}, {"sha": "ae3d2f5f2826ac6fed5642bca720cdeb5dbf1c59", "filename": "src/test/ui/moves/move-out-of-array-ref.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,47 @@\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:10:24\n+   |\n+LL |     let [_, e, _, _] = *a;\n+   |             -          ^^\n+   |             |          |\n+   |             |          cannot move out of here\n+   |             |          help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:15:27\n+   |\n+LL |     let [_, s @ .. , _] = *a;\n+   |             ------        ^^\n+   |             |             |\n+   |             |             cannot move out of here\n+   |             |             help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:20:24\n+   |\n+LL |     let [_, e, _, _] = *a;\n+   |             -          ^^\n+   |             |          |\n+   |             |          cannot move out of here\n+   |             |          help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:25:27\n+   |\n+LL |     let [_, s @ .. , _] = *a;\n+   |             ------        ^^\n+   |             |             |\n+   |             |             cannot move out of here\n+   |             |             help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "e460246193e5b88d58e46a4c514cf0294f10b649", "filename": "src/test/ui/moves/move-out-of-slice-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,34 @@\n+#![feature(slice_patterns, unsized_locals)]\n+\n+struct A;\n+#[derive(Clone, Copy)]\n+struct C;\n+\n+fn main() {\n+    let a: Box<[A]> = Box::new([A]);\n+    match *a {\n+        //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n+        [a @ ..] => {},\n+        _ => {}\n+    }\n+    let b: Box<[A]> = Box::new([A, A, A]);\n+    match *b {\n+        //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n+        [_, _, b @ .., _] => {},\n+        _ => {}\n+    }\n+\n+    // `[C]` isn't `Copy`, even if `C` is.\n+    let c: Box<[C]> = Box::new([C]);\n+    match *c {\n+        //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n+        [c @ ..] => {},\n+        _ => {}\n+    }\n+    let d: Box<[C]> = Box::new([C, C, C]);\n+    match *d {\n+        //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n+        [_, _, d @ .., _] => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "058f34b24a3b62ab2627973bbc4f7c519f6cad05", "filename": "src/test/ui/moves/move-out-of-slice-2.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a2813c6ec887c5723f48e8e0f216ba34abd85ac/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr?ref=0a2813c6ec887c5723f48e8e0f216ba34abd85ac", "patch": "@@ -0,0 +1,51 @@\n+error[E0508]: cannot move out of type `[A]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:9:11\n+   |\n+LL |     match *a {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [a @ ..] => {},\n+   |          ------\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `[A]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[A]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:15:11\n+   |\n+LL |     match *b {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [_, _, b @ .., _] => {},\n+   |                ------\n+   |                |\n+   |                data moved here\n+   |                move occurs because `b` has type `[A]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[C]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:23:11\n+   |\n+LL |     match *c {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [c @ ..] => {},\n+   |          ------\n+   |          |\n+   |          data moved here\n+   |          move occurs because `c` has type `[C]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[C]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:29:11\n+   |\n+LL |     match *d {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [_, _, d @ .., _] => {},\n+   |                ------\n+   |                |\n+   |                data moved here\n+   |                move occurs because `d` has type `[C]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}]}