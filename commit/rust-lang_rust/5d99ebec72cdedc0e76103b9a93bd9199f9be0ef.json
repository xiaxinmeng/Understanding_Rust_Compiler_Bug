{"sha": "5d99ebec72cdedc0e76103b9a93bd9199f9be0ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOTllYmVjNzJjZGVkYzBlNzYxMDNiOWE5M2JkOTE5OWY5YmUwZWY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-14T12:21:05Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-14T12:37:12Z"}, "message": "fixed false positives (at the cost of some false negatives)", "tree": {"sha": "de549815337b5b2a27649c4cc84d389820c2a3de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de549815337b5b2a27649c4cc84d389820c2a3de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef", "html_url": "https://github.com/rust-lang/rust/commit/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1118f97691b9c088afe8392d6b2fafabfa5382ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/1118f97691b9c088afe8392d6b2fafabfa5382ca", "html_url": "https://github.com/rust-lang/rust/commit/1118f97691b9c088afe8392d6b2fafabfa5382ca"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "e0d4182081f61027aebc12393a878e37be351f29", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=5d99ebec72cdedc0e76103b9a93bd9199f9be0ef", "patch": "@@ -19,41 +19,58 @@ impl LintPass for EtaPass {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        if let ExprClosure(_, ref decl, ref blk) = expr.node {\n-            if !blk.stmts.is_empty() {\n-                // || {foo(); bar()}; can't be reduced here\n-                return;\n-            }\n-            if let Some(ref ex) = blk.expr {\n-                if let ExprCall(ref caller, ref args) = ex.node {\n-                    if args.len() != decl.inputs.len() {\n-                        // Not the same number of arguments, there\n-                        // is no way the closure is the same as the function\n-                        return;\n-                    }\n-                    for (ref a1, ref a2) in decl.inputs.iter().zip(args) {\n-                        if let PatIdent(_, ident, _) = a1.pat.node {\n-                            // XXXManishearth Should I be checking the binding mode here?\n-                            if let ExprPath(None, ref p) = a2.node {\n-                                if p.segments.len() != 1 {\n-                                    // If it's a proper path, it can't be a local variable\n-                                    return;\n-                                }\n-                                if p.segments[0].identifier != ident.node {\n-                                    // The two idents should be the same\n-                                    return\n-                                }\n-                            } else {\n+        match &expr.node {\n+            &ExprCall(_, ref args) |\n+            &ExprMethodCall(_, _, ref args) => {\n+                for arg in args {\n+                    check_closure(cx, &*arg)\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn is_adjusted(cx: &Context, e: &Expr) -> bool {\n+    cx.tcx.tables.borrow().adjustments.get(&e.id).is_some()\n+}\n+\n+fn check_closure(cx: &Context, expr: &Expr) {\n+    if let ExprClosure(_, ref decl, ref blk) = expr.node {\n+        if !blk.stmts.is_empty() {\n+            // || {foo(); bar()}; can't be reduced here\n+            return;\n+        }\n+        if let Some(ref ex) = blk.expr {\n+            if let ExprCall(ref caller, ref args) = ex.node {\n+                if args.len() != decl.inputs.len() {\n+                    // Not the same number of arguments, there\n+                    // is no way the closure is the same as the function\n+                    return;\n+                }\n+                if args.iter().any(|arg| is_adjusted(cx, arg)) { return; }\n+                for (ref a1, ref a2) in decl.inputs.iter().zip(args) {\n+                    if let PatIdent(_, ident, _) = a1.pat.node {\n+                        // XXXManishearth Should I be checking the binding mode here?\n+                        if let ExprPath(None, ref p) = a2.node {\n+                            if p.segments.len() != 1 {\n+                                // If it's a proper path, it can't be a local variable\n+                                return;\n+                            }\n+                            if p.segments[0].identifier != ident.node {\n+                                // The two idents should be the same\n                                 return\n                             }\n                         } else {\n                             return\n                         }\n+                    } else {\n+                        return\n                     }\n-                    span_lint(cx, REDUNDANT_CLOSURE, expr.span,\n-                                 &format!(\"redundant closure found. Consider using `{}` in its place\",\n-                                          expr_to_string(caller))[..])\n                 }\n+                span_lint(cx, REDUNDANT_CLOSURE, expr.span,\n+                             &format!(\"redundant closure found. Consider using `{}` in its place\",\n+                                      expr_to_string(caller))[..])\n             }\n         }\n     }"}, {"sha": "bf6ecd796171eb0b069bd79e97ffdab6f518c34f", "filename": "tests/compile-fail/eta.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef/tests%2Fcompile-fail%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d99ebec72cdedc0e76103b9a93bd9199f9be0ef/tests%2Fcompile-fail%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feta.rs?ref=5d99ebec72cdedc0e76103b9a93bd9199f9be0ef", "patch": "@@ -4,18 +4,31 @@\n #![deny(redundant_closure)]\n \n fn main() {\n-    let a = |a, b| foo(a, b);\n+    let a = Some(1u8).map(|a| foo(a));\n     //~^ ERROR redundant closure found. Consider using `foo` in its place\n-    let c = |a, b| {1+2; foo}(a, b);\n+    meta(|a| foo(a));\n+    //~^ ERROR redundant closure found. Consider using `foo` in its place\n+    let c = Some(1u8).map(|a| {1+2; foo}(a));\n     //~^ ERROR redundant closure found. Consider using `{ 1 + 2; foo }` in its place\n-    let d = |a, b| foo((|c, d| foo2(c,d))(a,b), b);\n-    //~^ ERROR redundant closure found. Consider using `foo2` in its place\n+    let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n+    all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n+}\n+\n+fn meta<F>(f: F) where F: Fn(u8) {\n+    f(1u8)\n }\n \n-fn foo(_: u8, _: u8) {\n+fn foo(_: u8) {\n \n }\n \n-fn foo2(_: u8, _: u8) -> u8 {\n+fn foo2(_: u8) -> u8 {\n     1u8\n }\n+\n+fn all<X, F>(x: &[X], y: &X, f: F) -> bool\n+where F: Fn(&X, &X) -> bool {\n+    x.iter().all(|e| f(e, y))\n+}\n+\n+fn below(x: &u8, y: &u8) -> bool { x < y }"}]}