{"sha": "1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZmM1YmI1NjMzZGQ5YmYzYTM4NzY2ZmJmNzhkZGM3NmQ4YjBiYzg=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-01T18:47:31Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-01T18:55:54Z"}, "message": "Implement futex_wait and futex_wake.\n\nThis does not support futex_wait with a timeout yet.", "tree": {"sha": "115a7e7bdb4b530fbc738c3e1f644b7da53142d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/115a7e7bdb4b530fbc738c3e1f644b7da53142d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8", "html_url": "https://github.com/rust-lang/rust/commit/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "266b75faecd11e6a0b63fb6526fac56cda22bebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/266b75faecd11e6a0b63fb6526fac56cda22bebc", "html_url": "https://github.com/rust-lang/rust/commit/266b75faecd11e6a0b63fb6526fac56cda22bebc"}], "stats": {"total": 94, "additions": 94, "deletions": 0}, "files": [{"sha": "8434d7bfa806231daa8d7055cdb9920c08d2ca41", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8", "patch": "@@ -1,4 +1,5 @@\n use rustc_middle::mir;\n+use rustc_target::abi::{Align, Size};\n \n use crate::*;\n use crate::helpers::check_arg_count;\n@@ -120,6 +121,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .eval_libc(\"SYS_statx\")?\n                     .to_machine_usize(this)?;\n \n+                let sys_futex = this\n+                    .eval_libc(\"SYS_futex\")?\n+                    .to_machine_usize(this)?;\n+\n                 if args.is_empty() {\n                     throw_ub_format!(\"incorrect number of arguments for syscall: got 0, expected at least 1\");\n                 }\n@@ -139,6 +144,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         let result = this.linux_statx(dirfd, pathname, flags, mask, statxbuf)?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n+                    // `futex` is used by some synchonization primitives.\n+                    id if id == sys_futex => {\n+                        futex(this, args, dest)?;\n+                    }\n                     id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n                 }\n             }\n@@ -192,3 +201,61 @@ fn getrandom<'tcx>(\n     this.write_scalar(Scalar::from_machine_usize(len, this), dest)?;\n     Ok(())\n }\n+\n+fn futex<'tcx>(\n+    this: &mut MiriEvalContext<'_, 'tcx>,\n+    args: &[OpTy<'tcx, Tag>],\n+    dest: PlaceTy<'tcx, Tag>,\n+) -> InterpResult<'tcx> {\n+    if args.len() < 4 {\n+        throw_ub_format!(\"incorrect number of arguments for futex syscall: got {}, expected at least 4\", args.len());\n+    }\n+    let addr = this.read_scalar(args[1])?.check_init()?;\n+    let op = this.read_scalar(args[2])?.to_i32()?;\n+    let val = this.read_scalar(args[3])?.to_i32()?;\n+\n+    this.memory.check_ptr_access(addr, Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n+\n+    let addr = addr.assert_ptr();\n+\n+    let thread = this.get_active_thread();\n+\n+    let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n+    let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n+    let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n+\n+    match op & !futex_private {\n+        op if op == futex_wait => {\n+            if args.len() < 5 {\n+                throw_ub_format!(\"incorrect number of arguments for FUTEX_WAIT syscall: got {}, expected at least 5\", args.len());\n+            }\n+            let timeout = this.read_scalar(args[4])?.check_init()?;\n+            if !this.is_null(timeout)? {\n+                throw_ub_format!(\"miri does not support timeouts for futex operations\");\n+            }\n+            let futex_val = this.read_scalar_at_offset(args[1], 0, this.machine.layouts.i32)?.to_i32()?;\n+            if val == futex_val {\n+                this.block_thread(thread);\n+                this.futex_wait(addr, thread);\n+            } else {\n+                let eagain = this.eval_libc(\"EAGAIN\")?;\n+                this.set_last_error(eagain)?;\n+            }\n+        }\n+        op if op == futex_wake => {\n+            let mut n = 0;\n+            for _ in 0..val {\n+                if let Some(thread) = this.futex_wake(addr) {\n+                    this.unblock_thread(thread);\n+                    n += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+            this.write_scalar(Scalar::from_i32(n), dest)?;\n+        }\n+        op => throw_unsup_format!(\"miri does not support SYS_futex operation {}\", op),\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "d5594fb9eca4c24a6022cdac9a86b9644da878b8", "filename": "src/sync.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=1ffc5bb5633dd9bf3a38766fbf78ddc76d8b0bc8", "patch": "@@ -96,12 +96,26 @@ struct Condvar {\n     waiters: VecDeque<CondvarWaiter>,\n }\n \n+/// The futex state.\n+#[derive(Default, Debug)]\n+struct Futex {\n+    waiters: VecDeque<FutexWaiter>,\n+}\n+\n+/// A thread waiting on a futex.\n+#[derive(Debug)]\n+struct FutexWaiter {\n+    /// The thread that is waiting on this futex.\n+    thread: ThreadId,\n+}\n+\n /// The state of all synchronization variables.\n #[derive(Default, Debug)]\n pub(super) struct SynchronizationState {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n+    futexes: HashMap<Pointer<stacked_borrows::Tag>, Futex>,\n }\n \n // Private extension trait for local helper methods\n@@ -403,4 +417,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.condvars[id].waiters.retain(|waiter| waiter.thread != thread);\n     }\n+\n+    fn futex_wait(&mut self, addr: Pointer<stacked_borrows::Tag>, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        let waiters = &mut this.machine.threads.sync.futexes.entry(addr).or_default().waiters;\n+        assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n+        waiters.push_back(FutexWaiter { thread });\n+    }\n+\n+    fn futex_wake(&mut self, addr: Pointer<stacked_borrows::Tag>) -> Option<ThreadId> {\n+        let this = self.eval_context_mut();\n+        let waiters = &mut this.machine.threads.sync.futexes.get_mut(&addr)?.waiters;\n+        waiters.pop_front().map(|waiter| waiter.thread)\n+    }\n }"}]}