{"sha": "1d24f07271f7be9f67c7ba7edb7071f58995e294", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMjRmMDcyNzFmN2JlOWY2N2M3YmE3ZWRiNzA3MWY1ODk5NWUyOTQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-01-28T02:27:13Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-02-25T17:16:48Z"}, "message": "Detect match statement intended to be tail expression\n\nCC #24157", "tree": {"sha": "17cf52f03dd11b16df8734862fbfaf6df179a9e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17cf52f03dd11b16df8734862fbfaf6df179a9e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d24f07271f7be9f67c7ba7edb7071f58995e294", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d24f07271f7be9f67c7ba7edb7071f58995e294", "html_url": "https://github.com/rust-lang/rust/commit/1d24f07271f7be9f67c7ba7edb7071f58995e294", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d24f07271f7be9f67c7ba7edb7071f58995e294/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8486b64b0c87dabd045453b6c81500015d122d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8486b64b0c87dabd045453b6c81500015d122d6", "html_url": "https://github.com/rust-lang/rust/commit/a8486b64b0c87dabd045453b6c81500015d122d6"}], "stats": {"total": 171, "additions": 161, "deletions": 10}, "files": [{"sha": "cfd4e0830ef2a5fea0c0ff123ca4debabae7327e", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=1d24f07271f7be9f67c7ba7edb7071f58995e294", "patch": "@@ -1,10 +1,11 @@\n use crate::check::coercion::{AsCoercionSite, CoerceMany};\n use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n-use rustc_span::Span;\n+use rustc_span::{MultiSpan, Span};\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -206,7 +207,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ),\n                 };\n                 let cause = self.cause(span, code);\n-                coercion.coerce(self, &cause, &arm.body, arm_ty);\n+                let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+                    Some(ret_coercion) if self.in_tail_expr => {\n+                        let ret_ty = ret_coercion.borrow().expected_ty();\n+                        let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                        self.can_coerce(arm_ty, ret_ty)\n+                            && prior_arm_ty.map_or(true, |t| self.can_coerce(t, ret_ty))\n+                            // The match arms need to unify for the case of `impl Trait`.\n+                            && !matches!(ret_ty.kind(), ty::Opaque(..))\n+                    }\n+                    _ => false,\n+                };\n+\n+                // This is the moral equivalent of `coercion.coerce(self, cause, arm.body, arm_ty)`.\n+                // We use it this way to be able to expand on the potential error and detect when a\n+                // `match` tail statement could be a tail expression instead. If so, we suggest\n+                // removing the stray semicolon.\n+                coercion.coerce_inner(\n+                    self,\n+                    &cause,\n+                    Some(&arm.body),\n+                    arm_ty,\n+                    Some(&mut |err: &mut DiagnosticBuilder<'_>| {\n+                        if let (Expectation::IsLast(stmt), Some(ret), true) =\n+                            (orig_expected, self.ret_type_span, can_coerce_to_return_ty)\n+                        {\n+                            let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+                            let mut ret_span: MultiSpan = semi_span.into();\n+                            ret_span.push_span_label(\n+                                expr.span,\n+                                \"this could be implicitly returned but it is a statement, not a \\\n+                                 tail expression\"\n+                                    .to_owned(),\n+                            );\n+                            ret_span.push_span_label(\n+                                ret,\n+                                \"the `match` arms can conform to this return type\".to_owned(),\n+                            );\n+                            ret_span.push_span_label(\n+                                semi_span,\n+                                \"the `match` is a statement because of this semicolon, consider \\\n+                                 removing it\"\n+                                    .to_owned(),\n+                            );\n+                            err.span_note(\n+                                ret_span,\n+                                \"you might have meant to return the `match` expression\",\n+                            );\n+                            err.tool_only_span_suggestion(\n+                                semi_span,\n+                                \"remove this semicolon\",\n+                                String::new(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }),\n+                    false,\n+                );\n+\n                 other_arms.push(arm_span);\n                 if other_arms.len() > 5 {\n                     other_arms.remove(0);"}, {"sha": "e3aacc44a02ee6d58711f891072c5e368beb68ad", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=1d24f07271f7be9f67c7ba7edb7071f58995e294", "patch": "@@ -1236,7 +1236,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// The inner coercion \"engine\". If `expression` is `None`, this\n     /// is a forced-unit case, and hence `expression_ty` must be\n     /// `Nil`.\n-    fn coerce_inner<'a>(\n+    crate fn coerce_inner<'a>(\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "22be10a731f9f8ddd83eb88b370979b4a78e14cc", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=1d24f07271f7be9f67c7ba7edb7071f58995e294", "patch": "@@ -21,6 +21,8 @@ pub enum Expectation<'tcx> {\n     /// This rvalue expression will be wrapped in `&` or `Box` and coerced\n     /// to `&Ty` or `Box<Ty>`, respectively. `Ty` is `[A]` or `Trait`.\n     ExpectRvalueLikeUnsized(Ty<'tcx>),\n+\n+    IsLast(Span),\n }\n \n impl<'a, 'tcx> Expectation<'tcx> {\n@@ -79,19 +81,20 @@ impl<'a, 'tcx> Expectation<'tcx> {\n \n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n-    // no constraints yet present), just returns `None`.\n+    // no constraints yet present), just returns `self`.\n     fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) => ExpectCastableToType(fcx.resolve_vars_if_possible(t)),\n             ExpectHasType(t) => ExpectHasType(fcx.resolve_vars_if_possible(t)),\n             ExpectRvalueLikeUnsized(t) => ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(t)),\n+            IsLast(sp) => IsLast(sp),\n         }\n     }\n \n     pub(super) fn to_option(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n-            NoExpectation => None,\n+            NoExpectation | IsLast(_) => None,\n             ExpectCastableToType(ty) | ExpectHasType(ty) | ExpectRvalueLikeUnsized(ty) => Some(ty),\n         }\n     }\n@@ -103,7 +106,9 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     pub(super) fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n-            NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n+            NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) | IsLast(_) => {\n+                None\n+            }\n         }\n     }\n "}, {"sha": "5b8b25c2100183657548ea73fe6ffaac8b1542f5", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d24f07271f7be9f67c7ba7edb7071f58995e294/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=1d24f07271f7be9f67c7ba7edb7071f58995e294", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.overwrite_local_ty_if_err(local, ty, pat_ty);\n     }\n \n-    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n+    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>, is_last: bool) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.kind {\n             hir::StmtKind::Item(..) => return,\n@@ -567,7 +567,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 });\n             }\n             hir::StmtKind::Semi(ref expr) => {\n-                self.check_expr(&expr);\n+                // All of this is equivalent to calling `check_expr`, but it is inlined out here\n+                // in order to capture the fact that this `match` is the last statement in its\n+                // function. This is done for better suggestions to remove the `;`.\n+                let expectation = match expr.kind {\n+                    hir::ExprKind::Match(..) if is_last => IsLast(stmt.span),\n+                    _ => NoExpectation,\n+                };\n+                self.check_expr_with_expectation(expr, expectation);\n             }\n         }\n \n@@ -626,8 +633,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n         let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for s in blk.stmts {\n-                self.check_stmt(s);\n+            for (pos, s) in blk.stmts.iter().enumerate() {\n+                self.check_stmt(s, blk.stmts.len() - 1 == pos);\n             }\n \n             // check the tail expression **without** holding the"}, {"sha": "0360ce6e6b84cec397c330547f68b229e6a6f7fd", "filename": "src/test/ui/suggestions/match-with-different-arm-types-as-stmt-instead-of-expr.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1d24f07271f7be9f67c7ba7edb7071f58995e294/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-with-different-arm-types-as-stmt-instead-of-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d24f07271f7be9f67c7ba7edb7071f58995e294/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-with-different-arm-types-as-stmt-instead-of-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-with-different-arm-types-as-stmt-instead-of-expr.rs?ref=1d24f07271f7be9f67c7ba7edb7071f58995e294", "patch": "@@ -0,0 +1,30 @@\n+pub trait Foo {}\n+\n+struct Bar;\n+struct Baz;\n+\n+impl Foo for Bar { }\n+impl Foo for Baz { }\n+\n+fn not_all_paths(a: &str) -> u32 { //~ ERROR mismatched types\n+    match a {\n+        \"baz\" => 0,\n+        _ => 1,\n+    };\n+}\n+\n+fn right(b: &str) -> Box<dyn Foo> {\n+    match b {\n+        \"baz\" => Box::new(Baz),\n+        _ => Box::new(Bar),\n+    }\n+}\n+\n+fn wrong(c: &str) -> Box<dyn Foo> { //~ ERROR mismatched types\n+    match c {\n+        \"baz\" => Box::new(Baz),\n+        _ => Box::new(Bar), //~ ERROR `match` arms have incompatible types\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "7dce97468b6ddcf80227957ab94d3450808b30da", "filename": "src/test/ui/suggestions/match-with-different-arm-types-as-stmt-instead-of-expr.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1d24f07271f7be9f67c7ba7edb7071f58995e294/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-with-different-arm-types-as-stmt-instead-of-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d24f07271f7be9f67c7ba7edb7071f58995e294/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-with-different-arm-types-as-stmt-instead-of-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-with-different-arm-types-as-stmt-instead-of-expr.stderr?ref=1d24f07271f7be9f67c7ba7edb7071f58995e294", "patch": "@@ -0,0 +1,51 @@\n+error[E0308]: mismatched types\n+  --> $DIR/match-with-different-arm-types-as-stmt-instead-of-expr.rs:9:30\n+   |\n+LL | fn not_all_paths(a: &str) -> u32 {\n+   |    -------------             ^^^ expected `u32`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+...\n+LL |     };\n+   |      - help: consider removing this semicolon\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-with-different-arm-types-as-stmt-instead-of-expr.rs:26:14\n+   |\n+LL | /     match c {\n+LL | |         \"baz\" => Box::new(Baz),\n+   | |                  ------------- this is found to be of type `Box<Baz>`\n+LL | |         _ => Box::new(Bar),\n+   | |              ^^^^^^^^^^^^^ expected struct `Baz`, found struct `Bar`\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `Box<Baz>`\n+            found struct `Box<Bar>`\n+note: you might have meant to return the `match` expression\n+  --> $DIR/match-with-different-arm-types-as-stmt-instead-of-expr.rs:27:6\n+   |\n+LL |   fn wrong(c: &str) -> Box<dyn Foo> {\n+   |                        ------------ the `match` arms can conform to this return type\n+LL | /     match c {\n+LL | |         \"baz\" => Box::new(Baz),\n+LL | |         _ => Box::new(Bar),\n+LL | |     };\n+   | |     -^ the `match` is a statement because of this semicolon, consider removing it\n+   | |_____|\n+   |       this could be implicitly returned but it is a statement, not a tail expression\n+\n+error[E0308]: mismatched types\n+  --> $DIR/match-with-different-arm-types-as-stmt-instead-of-expr.rs:23:22\n+   |\n+LL | fn wrong(c: &str) -> Box<dyn Foo> {\n+   |    -----             ^^^^^^^^^^^^ expected struct `Box`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected struct `Box<(dyn Foo + 'static)>`\n+           found unit type `()`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}