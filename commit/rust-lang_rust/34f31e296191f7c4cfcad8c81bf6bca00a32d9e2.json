{"sha": "34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZjMxZTI5NjE5MWY3YzRjZmNhZDhjODFiZjZiY2EwMGEzMmQ5ZTI=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-09T22:56:21Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:10Z"}, "message": "rework fold so that fold_tts takes an ast_fold rather than a thunk, stop using closures in ident traversal", "tree": {"sha": "91a4f6e34bff97165bbf82df38356e35ecdb521e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a4f6e34bff97165bbf82df38356e35ecdb521e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "html_url": "https://github.com/rust-lang/rust/commit/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09e6dda4f268e24c5d1f0804f5c1e57d1fcc158d", "url": "https://api.github.com/repos/rust-lang/rust/commits/09e6dda4f268e24c5d1f0804f5c1e57d1fcc158d", "html_url": "https://github.com/rust-lang/rust/commit/09e6dda4f268e24c5d1f0804f5c1e57d1fcc158d"}], "stats": {"total": 120, "additions": 69, "deletions": 51}, "files": [{"sha": "c73f8b01b9c9102d7e59054f3d6a67393c9059b5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "patch": "@@ -1421,38 +1421,52 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     return ret;\n }\n \n-// given a function from idents to idents, produce\n-// an ast_fold that applies that function:\n-pub fn fun_to_ident_folder(f: @fn(ast::Ident)->ast::Ident) -> @ast_fold{\n-    let afp = default_ast_fold();\n-    let f_pre = @AstFoldFns{\n-        fold_ident : |id, _| f(id),\n-        .. *afp\n-    };\n-    make_fold(f_pre)\n+// a function in SyntaxContext -> SyntaxContext\n+pub trait CtxtFn{\n+    fn f(&self, ast::SyntaxContext) -> ast::SyntaxContext;\n }\n \n-// update the ctxts in a path to get a rename node\n-pub fn new_ident_renamer(from: ast::Ident,\n-                      to: ast::Name) ->\n-    @fn(ast::Ident)->ast::Ident {\n-    |id : ast::Ident|\n-    ast::Ident{\n-        name: id.name,\n-        ctxt: new_rename(from,to,id.ctxt)\n+pub struct Renamer {\n+    from : ast::Ident,\n+    to : ast::Name\n+}\n+\n+impl CtxtFn for Renamer {\n+    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        new_rename(self.from,self.to,ctxt)\n     }\n }\n \n-// update the ctxts in a path to get a mark node\n-pub fn new_ident_marker(mark: Mrk) ->\n-    @fn(ast::Ident)->ast::Ident {\n-    |id : ast::Ident|\n-    ast::Ident{\n-        name: id.name,\n-        ctxt: new_mark(mark,id.ctxt)\n+pub struct Marker { mark : Mrk }\n+\n+impl CtxtFn for Marker {\n+    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        new_mark(self.mark,ctxt)\n+    }\n+}\n+\n+// given a function from ctxts to ctxts, produce\n+// an ast_fold that applies that function to all ctxts:\n+pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n+    let afp = default_ast_fold();\n+    let fi : @fn(ast::Ident, @ast_fold) -> ast::Ident =\n+        |ast::Ident{name, ctxt}, _| {\n+        ast::Ident{name:name,ctxt:cf.f(ctxt)}\n+    };\n+    @AstFoldFns{\n+        fold_ident : fi,\n+        // check that it works, then add the fold_expr clause....\n+        .. *afp\n     }\n }\n \n+// just a convenience:\n+pub fn new_mark_folder(m : Mrk) -> @AstFoldFns { fun_to_ctxt_folder(@Marker{mark:m}) }\n+pub fn new_rename_folder(from : ast::Ident, to : ast::Name) -> @AstFoldFns {\n+    fun_to_ctxt_folder(@Renamer{from:from,to:to})\n+}\n+\n+/*\n // perform resolution (in the MTWT sense) on all of the\n // idents in the tree. This is the final step in expansion.\n // FIXME #6993: this function could go away, along with\n@@ -1465,25 +1479,26 @@ pub fn new_ident_resolver() ->\n         ctxt : EMPTY_CTXT\n     }\n }\n+*/\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n-    fold_tts(tts,new_ident_marker(m))\n+    fold_tts(tts,new_mark_folder(m) as @ast_fold)\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n-    fun_to_ident_folder(new_ident_marker(m)).fold_expr(expr)\n+    new_mark_folder(m).fold_expr(expr)\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n-    fun_to_ident_folder(new_ident_marker(m)).fold_stmt(expr).unwrap()\n+    new_mark_folder(m).fold_stmt(expr).unwrap()\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n fn mark_item(expr : @ast::item, m : Mrk) -> Option<@ast::item> {\n-    fun_to_ident_folder(new_ident_marker(m)).fold_item(expr)\n+    new_mark_folder(m).fold_item(expr)\n }\n \n #[cfg(test)]\n@@ -1499,8 +1514,8 @@ mod test {\n     use print::pprust;\n     use std;\n     use std::vec;\n-    use util::parser_testing::{string_to_crate_and_sess, string_to_item, string_to_pat};\n-    use util::parser_testing::{strs_to_idents};\n+    use util::parser_testing::{string_to_crate, string_to_crate_and_sess, string_to_item};\n+    use util::parser_testing::{string_to_pat, strs_to_idents};\n     use visit;\n \n     // make sure that fail! is present\n@@ -1601,30 +1616,31 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let item_ast = string_to_item(@\"fn a() -> int { let b = 13; b }\").unwrap();\n+        let item_ast = string_to_crate(@\"fn f() -> int { a }\");\n         let a_name = intern(\"a\");\n         let a2_name = gensym(\"a2\");\n-        let renamer = new_ident_renamer(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n+        let renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n-        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n-        let resolver = new_ident_resolver();\n-        let resolver_fold = fun_to_ident_folder(resolver);\n-        let resolved_ast = resolver_fold.fold_item(renamed_ast).unwrap();\n-        let resolved_as_str = pprust::item_to_str(resolved_ast,\n-                                                  get_ident_interner());\n-        assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");\n+        let renamed_ast = renamer.fold_crate(item_ast);\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), &renamed_ast, ());\n+        match varrefs {\n+            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n+            _ => assert_eq!(0,1)\n+        }\n \n         // try a double-rename, with pending_renames.\n         let a3_name = gensym(\"a3\");\n         let ctxt2 = new_rename(ast::Ident::new(a_name),a2_name,EMPTY_CTXT);\n         let pending_renames = @mut ~[(ast::Ident::new(a_name),a2_name),\n                                      (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)];\n-        let double_renamed = renames_to_fold(pending_renames).fold_item(item_ast).unwrap();\n-        let resolved_again = resolver_fold.fold_item(double_renamed).unwrap();\n-        let double_renamed_as_str = pprust::item_to_str(resolved_again,\n-                                                        get_ident_interner());\n-        assert_eq!(double_renamed_as_str,~\"fn a3() -> int { let b = 13; b }\");\n-\n+        let double_renamed = renames_to_fold(pending_renames).fold_crate(item_ast);\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), &double_renamed, ());\n+        match varrefs {\n+            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n+            _ => assert_eq!(0,1)\n+        }\n     }\n \n     fn fake_print_crate(s: @pprust::ps, crate: &ast::Crate) {"}, {"sha": "9aacc18eabf1f8fb37ed055f4f4706cc90cb5348", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "patch": "@@ -118,16 +118,16 @@ fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n         node: match m.node {\n             mac_invoc_tt(ref p,ref tts,ctxt) =>\n             mac_invoc_tt(fld.fold_path(p),\n-                         fold_tts(*tts,|id|{fld.fold_ident(id)}),\n+                         fold_tts(*tts,fld),\n                          ctxt)\n         },\n         span: fld.new_span(m.span)\n     }\n }\n \n-// build a new vector of tts by appling the given function to\n+// build a new vector of tts by appling the ast_fold's fold_ident to\n // all of the identifiers in the token trees.\n-pub fn fold_tts(tts : &[token_tree], f: @fn(Ident)->Ident) -> ~[token_tree] {\n+pub fn fold_tts(tts : &[token_tree], f : @ast_fold) -> ~[token_tree] {\n     do tts.map |tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n@@ -140,16 +140,16 @@ pub fn fold_tts(tts : &[token_tree], f: @fn(Ident)->Ident) -> ~[token_tree] {\n                    sep.map(|tok|maybe_fold_ident(tok,f)),\n                    is_optional),\n             tt_nonterminal(sp,ref ident) =>\n-            tt_nonterminal(sp,f(*ident))\n+            tt_nonterminal(sp,f.fold_ident(*ident))\n         }\n     }\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident(t : &token::Token, f: @fn(Ident)->Ident) -> token::Token {\n+fn maybe_fold_ident(t : &token::Token, f: @ast_fold) -> token::Token {\n     match *t {\n         token::IDENT(id,followed_by_colons) =>\n-        token::IDENT(f(id),followed_by_colons),\n+        token::IDENT(f.fold_ident(id),followed_by_colons),\n         _ => (*t).clone()\n     }\n }\n@@ -948,6 +948,8 @@ impl AstFoldExtensions for @ast_fold {\n     }\n }\n \n+// brson agrees with me that this function's existence is probably\n+// not a good or useful thing.\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }"}]}