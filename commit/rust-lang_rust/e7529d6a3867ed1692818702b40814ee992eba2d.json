{"sha": "e7529d6a3867ed1692818702b40814ee992eba2d", "node_id": "C_kwDOAAsO6NoAKGU3NTI5ZDZhMzg2N2VkMTY5MjgxODcwMmI0MDgxNGVlOTkyZWJhMmQ", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-01-10T23:39:21Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-01-17T19:59:40Z"}, "message": "Update term for use in more places\n\nReplace use of `ty()` on term and use it in more places. This will allow more flexibility in the\nfuture, but slightly worried it allows items which are consts which only accept types.", "tree": {"sha": "604113f2d4e343f78db6c168ce8624a767de87d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/604113f2d4e343f78db6c168ce8624a767de87d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7529d6a3867ed1692818702b40814ee992eba2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7529d6a3867ed1692818702b40814ee992eba2d", "html_url": "https://github.com/rust-lang/rust/commit/e7529d6a3867ed1692818702b40814ee992eba2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7529d6a3867ed1692818702b40814ee992eba2d/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67f56671d0384bdb2d92dddebfbf42510b16e0f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/67f56671d0384bdb2d92dddebfbf42510b16e0f7", "html_url": "https://github.com/rust-lang/rust/commit/67f56671d0384bdb2d92dddebfbf42510b16e0f7"}], "stats": {"total": 412, "additions": 284, "deletions": 128}, "files": [{"sha": "4851e637d3a62eeb3f440bba63776549497b7107", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -7,7 +7,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n-use rustc_middle::ty::{self, OpaqueTypeKey, Term, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n@@ -584,13 +584,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n-                if let Term::Ty(ty) = projection.term {\n-                    if ty.references_error() {\n-                        // No point on adding these obligations since there's a type error involved.\n-                        return tcx.ty_error();\n-                    }\n-                } else {\n-                    todo!();\n+                if projection.term.references_error() {\n+                    return tcx.ty_error();\n                 }\n             }\n "}, {"sha": "3921187baa55eda5c3ebe94ec0e758c9fe4ccf1d", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -742,6 +742,8 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n                                         ast::AssocConstraintKind::Equality { ref term } => {\n                                             match term {\n                                                 Term::Ty(ty) => involves_impl_trait(ty),\n+                                                // FIXME(...): This should check if the constant\n+                                                // involves a trait impl, but for now ignore.\n                                                 Term::Const(_) => false,\n                                             }\n                                         }"}, {"sha": "2776370ba6f465809b4a128928ae68d2cb799e60", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -152,6 +152,19 @@ impl<'tcx> AssocItems<'tcx> {\n             .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n     }\n \n+    /// Returns the associated item with the given name and any of `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kinds(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kinds: &[AssocKind],\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| kinds.contains(&item.kind))\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n     /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n     pub fn find_by_name_and_namespace(\n         &self,"}, {"sha": "d6c35dfef8888339b07d5fdf5e169c65dfb58564", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -86,10 +86,14 @@ impl<'tcx> Const<'tcx> {\n         if let Some(lit_input) = lit_input {\n             // If an error occurred, ignore that it's a literal and leave reporting the error up to\n             // mir.\n-            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n-                return Some(c);\n-            } else {\n-                tcx.sess.delay_span_bug(expr.span, \"Const::from_anon_const: couldn't lit_to_const\");\n+            match tcx.at(expr.span).lit_to_const(lit_input) {\n+                Ok(c) => return Some(c),\n+                Err(e) => {\n+                    tcx.sess.delay_span_bug(\n+                        expr.span,\n+                        &format!(\"Const::from_anon_const: couldn't lit_to_const {:?}\", e),\n+                    );\n+                }\n             }\n         }\n "}, {"sha": "be9021dc6198948c1cb9664b8bff1eccb531d5f5", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -245,7 +245,7 @@ impl FlagComputation {\n                 self.add_projection_ty(projection_ty);\n                 match term {\n                     Term::Ty(ty) => self.add_ty(ty),\n-                    Term::Const(_c) => todo!(),\n+                    Term::Const(c) => self.add_const(c),\n                 }\n             }\n             ty::PredicateKind::WellFormed(arg) => {"}, {"sha": "42e6f3f6ef58449629552ff0fa90b9c69fbcc423", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -815,8 +815,8 @@ impl<'tcx> From<&'tcx Const<'tcx>> for Term<'tcx> {\n }\n \n impl<'tcx> Term<'tcx> {\n-    pub fn ty(&self) -> Ty<'tcx> {\n-        if let Term::Ty(ty) = self { ty } else { panic!(\"Expected type\") }\n+    pub fn ty(&self) -> Option<Ty<'tcx>> {\n+        if let Term::Ty(ty) = self { Some(ty) } else { None }\n     }\n }\n \n@@ -861,8 +861,8 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.projection_ty.trait_ref(tcx))\n     }\n \n-    pub fn ty(&self) -> Binder<'tcx, Ty<'tcx>> {\n-        self.map_bound(|predicate| if let Term::Ty(ty) = predicate.term { ty } else { todo!() })\n+    pub fn term(&self) -> Binder<'tcx, Term<'tcx>> {\n+        self.map_bound(|predicate| predicate.term)\n     }\n \n     /// The `DefId` of the `TraitItem` for the associated type."}, {"sha": "6fcb6ac5f4c0b4ffa56bcbfa88749859fc5d2b44", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -1,6 +1,6 @@\n use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n-use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sso::SsoHashSet;\n@@ -799,7 +799,7 @@ pub trait PrettyPrinter<'tcx>:\n                     let trait_ref = proj_ref.required_poly_trait_ref(self.tcx());\n \n                     // Projection type entry -- the def-id for naming, and the ty.\n-                    let proj_ty = (proj_ref.projection_def_id(), proj_ref.ty());\n+                    let proj_ty = (proj_ref.projection_def_id(), proj_ref.term());\n \n                     self.insert_trait_and_projection(\n                         trait_ref,\n@@ -850,8 +850,10 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n \n                     p!(\")\");\n-                    if !return_ty.skip_binder().is_unit() {\n-                        p!(\"-> \", print(return_ty));\n+                    if let Term::Ty(ty) = return_ty.skip_binder() {\n+                        if !ty.is_unit() {\n+                            p!(\"-> \", print(return_ty));\n+                        }\n                     }\n                     p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n \n@@ -902,14 +904,15 @@ pub trait PrettyPrinter<'tcx>:\n                     first = false;\n                 }\n \n-                for (assoc_item_def_id, ty) in assoc_items {\n+                for (assoc_item_def_id, term) in assoc_items {\n+                    let ty = if let Term::Ty(ty) = term.skip_binder() { ty } else { continue };\n                     if !first {\n                         p!(\", \");\n                     }\n                     p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).ident));\n \n                     // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks\n-                    match ty.skip_binder().kind() {\n+                    match ty.kind() {\n                         ty::Projection(ty::ProjectionTy { item_def_id, .. })\n                             if Some(*item_def_id) == self.tcx().lang_items().generator_return() =>\n                         {\n@@ -943,8 +946,11 @@ pub trait PrettyPrinter<'tcx>:\n     fn insert_trait_and_projection(\n         &mut self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        proj_ty: Option<(DefId, ty::Binder<'tcx, Ty<'tcx>>)>,\n-        traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, BTreeMap<DefId, ty::Binder<'tcx, Ty<'tcx>>>>,\n+        proj_ty: Option<(DefId, ty::Binder<'tcx, Term<'tcx>>)>,\n+        traits: &mut BTreeMap<\n+            ty::PolyTraitRef<'tcx>,\n+            BTreeMap<DefId, ty::Binder<'tcx, Term<'tcx>>>,\n+        >,\n         fn_traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, OpaqueFnEntry<'tcx>>,\n     ) {\n         let trait_def_id = trait_ref.def_id();\n@@ -2716,5 +2722,5 @@ pub struct OpaqueFnEntry<'tcx> {\n     has_fn_once: bool,\n     fn_mut_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n     fn_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n-    return_ty: Option<ty::Binder<'tcx, Ty<'tcx>>>,\n+    return_ty: Option<ty::Binder<'tcx, Term<'tcx>>>,\n }"}, {"sha": "bd6c24445ef518e02bdfb359edd6b4671176a746", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -833,19 +833,30 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::Term<'tcx> {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: Self,\n+        b: Self,\n+    ) -> RelateResult<'tcx, Self> {\n+        Ok(match (a, b) {\n+            (Term::Ty(a), Term::Ty(b)) => relation.relate(a, b)?.into(),\n+            (Term::Const(a), Term::Const(b)) => relation.relate(a, b)?.into(),\n+            _ => return Err(TypeError::Mismatch),\n+        })\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: ty::ProjectionPredicate<'tcx>,\n         b: ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>> {\n-        match (a.term, b.term) {\n-            (Term::Ty(a_ty), Term::Ty(b_ty)) => Ok(ty::ProjectionPredicate {\n-                projection_ty: relation.relate(a.projection_ty, b.projection_ty)?,\n-                term: relation.relate(a_ty, b_ty)?.into(),\n-            }),\n-            _ => todo!(),\n-        }\n+        Ok(ty::ProjectionPredicate {\n+            projection_ty: relation.relate(a.projection_ty, b.projection_ty)?,\n+            term: relation.relate(a.term, b.term)?.into(),\n+        })\n     }\n }\n "}, {"sha": "453e380f6e3a05dd8c6894d7e897f6e965eeaf24", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -1583,7 +1583,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n         let ty = if let Term::Ty(ty) = projection_predicate.term {\n             ty\n         } else {\n-            todo!();\n+            panic!(\"Only types are permitted here\");\n         };\n \n         Self {"}, {"sha": "73873c8cf0d914f29f7e9d005fb91915b342aae9", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -128,8 +128,10 @@ where\n                 polarity: _,\n             }) => self.visit_trait(trait_ref),\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n-                let ty = term.ty();\n-                ty.visit_with(self)?;\n+                match term {\n+                    ty::Term::Ty(ty) => ty.visit_with(self)?,\n+                    ty::Term::Const(ct) => ct.visit_with(self)?,\n+                }\n                 self.visit_projection_ty(projection_ty)\n             }\n             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n@@ -1186,10 +1188,13 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n-                if self.visit(poly_predicate.skip_binder().term.ty()).is_break()\n-                    || self\n-                        .visit_projection_ty(poly_predicate.skip_binder().projection_ty)\n-                        .is_break()\n+                let pred = poly_predicate.skip_binder();\n+                let poly_pred_term = match pred.term {\n+                    ty::Term::Ty(ty) => self.visit(ty),\n+                    ty::Term::Const(ct) => self.visit(ct),\n+                };\n+                if poly_pred_term.is_break()\n+                    || self.visit_projection_ty(pred.projection_ty).is_break()\n                 {\n                     return;\n                 }"}, {"sha": "cc20c1179452c20176a91fb5648197e66c2b1961", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::{Region, RegionVid};\n+use rustc_middle::ty::{Region, RegionVid, Term};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n@@ -606,7 +606,11 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n-        matches!(*p.ty().skip_binder().kind(), ty::Projection(proj) if proj == p.skip_binder().projection_ty)\n+        if let Term::Ty(ty) = p.term().skip_binder() {\n+            matches!(ty.kind(), ty::Projection(proj) if proj == &p.skip_binder().projection_ty)\n+        } else {\n+            false\n+        }\n     }\n \n     fn evaluate_nested_obligations(\n@@ -663,7 +667,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     // Additionally, we check if we've seen this predicate before,\n                     // to avoid rendering duplicate bounds to the user.\n                     if self.is_param_no_infer(p.skip_binder().projection_ty.substs)\n-                        && !p.ty().skip_binder().has_infer_types()\n+                        && !p.term().skip_binder().has_infer_types()\n                         && is_new_pred\n                     {\n                         debug!(\n@@ -752,7 +756,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                             // when we started out trying to unify\n                             // some inference variables. See the comment above\n                             // for more infomration\n-                            if p.ty().skip_binder().has_infer_types() {\n+                            if p.term().skip_binder().ty().map_or(false, |ty| ty.has_infer_types())\n+                            {\n                                 if !self.evaluate_nested_obligations(\n                                     ty,\n                                     v.into_iter(),\n@@ -774,7 +779,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                             // However, we should always make progress (either by generating\n                             // subobligations or getting an error) when we started off with\n                             // inference variables\n-                            if p.ty().skip_binder().has_infer_types() {\n+                            if p.term().skip_binder().ty().map_or(false, |ty| ty.has_infer_types())\n+                            {\n                                 panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n                             }\n                         }"}, {"sha": "43a961c5c91169b2a145d56e3aba2244ca61755b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -1304,8 +1304,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n                 debug!(\n                     \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n-                    normalized_ty,\n-                    data.term.ty()\n+                    normalized_ty, data.term,\n                 );\n \n                 let is_normalized_ty_expected = !matches!(\n@@ -1315,16 +1314,17 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(_)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-\n+                // FIXME(...): Handle Consts here\n+                let data_ty = data.term.ty().unwrap();\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n                     is_normalized_ty_expected,\n                     normalized_ty,\n-                    data.term.ty(),\n+                    data_ty,\n                 ) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n                         is_normalized_ty_expected,\n                         normalized_ty,\n-                        data.term.ty(),\n+                        data_ty,\n                     )));\n \n                     err_buf = error;"}, {"sha": "4b53b624c72f1c354a2a92788b6be359987356ea", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -212,10 +212,9 @@ fn project_and_unify_type<'cx, 'tcx>(\n     debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n \n     let infcx = selcx.infcx();\n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        .eq(normalized_ty, obligation.predicate.term.ty())\n-    {\n+    // FIXME(...): Handle consts here as well as types.\n+    let obligation_pred_ty = obligation.predicate.term.ty().unwrap();\n+    match infcx.at(&obligation.cause, obligation.param_env).eq(normalized_ty, obligation_pred_ty) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Ok(Some(obligations)))\n@@ -1803,7 +1802,9 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n-            Progress { ty: cache_entry.term.ty(), obligations: nested_obligations }\n+            // FIXME(...): Handle consts here as well? Maybe this progress type should just take\n+            // a term instead.\n+            Progress { ty: cache_entry.term.ty().unwrap(), obligations: nested_obligations }\n         }\n         Err(e) => {\n             let msg = format!("}, {"sha": "aea44841b8f128b9345c128c2019b9155d221199", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn update<'tcx, T>(\n     if let ty::PredicateKind::Projection(predicate) = obligation.predicate.kind().skip_binder() {\n         // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n         // we need to make it into one.\n-        if let Some(vid) = predicate.term.ty().ty_vid() {\n+        if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {\n             debug!(\"relationship: {:?}.output = true\", vid);\n             engine.relationships().entry(vid).or_default().output = true;\n         }"}, {"sha": "6a355b567e0916538d82ff32a3a7bcc8e5f89397", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -116,7 +116,10 @@ pub fn predicate_obligations<'a, 'tcx>(\n         }\n         ty::PredicateKind::Projection(t) => {\n             wf.compute_projection(t.projection_ty);\n-            wf.compute(t.term.ty().into());\n+            wf.compute(match t.term {\n+                ty::Term::Ty(ty) => ty.into(),\n+                ty::Term::Const(c) => c.into(),\n+            })\n         }\n         ty::PredicateKind::WellFormed(arg) => {\n             wf.compute(arg);\n@@ -219,7 +222,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let ty::Projection(projection_ty) = proj.term.ty().kind() {\n+            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind()) {\n                 if let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n                 {"}, {"sha": "dd98e4ae81b34ece14f062f293c21fb72f0b6db4", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -227,12 +227,24 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::AliasEq<RustInterner<'tcx>> {\n         chalk_ir::AliasEq {\n-            ty: self.term.ty().lower_into(interner),\n+            ty: self.term.ty().unwrap().lower_into(interner),\n             alias: self.projection_ty.lower_into(interner),\n         }\n     }\n }\n \n+/*\n+// FIXME(...): Where do I add this to Chalk? I can't find it in the rustc repo anywhere.\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Term<RustInterner<'tcx>>> for rustc_middle::ty::Term<'tcx> {\n+  fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::Term<RustInterner<'tcx>> {\n+    match self {\n+      ty::Term::Ty(ty) => ty.lower_into(interner).into(),\n+      ty::Term::Const(c) => c.lower_into(interner).into(),\n+    }\n+  }\n+}\n+*/\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n         let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i));\n@@ -787,7 +799,7 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n             trait_bound: trait_ref.lower_into(interner),\n             associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n             parameters: own_substs.iter().map(|arg| arg.lower_into(interner)).collect(),\n-            value: self.term.ty().lower_into(interner),\n+            value: self.term.ty().unwrap().lower_into(interner),\n         }\n     }\n }"}, {"sha": "a13eaa6f178de2d6957f4b113007cbfb59ff5a16", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -123,8 +123,7 @@ struct ConvertedBinding<'a, 'tcx> {\n \n #[derive(Debug)]\n enum ConvertedBindingKind<'a, 'tcx> {\n-    Equality(Ty<'tcx>),\n-    Const(&'tcx Const<'tcx>),\n+    Equality(ty::Term<'tcx>),\n     Constraint(&'a [hir::GenericBound<'a>]),\n }\n \n@@ -604,12 +603,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let kind = match binding.kind {\n                     hir::TypeBindingKind::Equality { ref term } => match term {\n                         hir::Term::Ty(ref ty) => {\n-                            ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty))\n+                            ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty).into())\n                         }\n                         hir::Term::Const(ref c) => {\n                             let local_did = self.tcx().hir().local_def_id(c.hir_id);\n                             let c = Const::from_anon_const(self.tcx(), local_did);\n-                            ConvertedBindingKind::Const(&c)\n+                            ConvertedBindingKind::Equality(c.into())\n                         }\n                     },\n                     hir::TypeBindingKind::Constraint { ref bounds } => {\n@@ -875,6 +874,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n             .is_some()\n     }\n+    fn trait_defines_associated_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+        self.tcx()\n+            .associated_items(trait_def_id)\n+            .find_by_name_and_kinds(\n+                self.tcx(),\n+                assoc_name,\n+                &[ty::AssocKind::Type, ty::AssocKind::Const],\n+                trait_def_id,\n+            )\n+            .is_some()\n+    }\n \n     // Sets `implicitly_sized` to true on `Bounds` if necessary\n     pub(crate) fn add_implicitly_sized<'hir>(\n@@ -1223,24 +1233,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         match binding.kind {\n-            ConvertedBindingKind::Equality(ty) => {\n+            ConvertedBindingKind::Equality(term) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n                 //\n                 // `<T as Iterator>::Item = u32`\n                 bounds.projection_bounds.push((\n                     projection_ty.map_bound(|projection_ty| ty::ProjectionPredicate {\n                         projection_ty,\n-                        term: ty.into(),\n-                    }),\n-                    binding.span,\n-                ));\n-            }\n-            ConvertedBindingKind::Const(c) => {\n-                bounds.projection_bounds.push((\n-                    projection_ty.map_bound(|projection_ty| ty::ProjectionPredicate {\n-                        projection_ty,\n-                        term: c.into(),\n+                        term: term,\n                     }),\n                     binding.span,\n                 ));\n@@ -1391,8 +1392,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n-                        let references_self =\n-                            pred.skip_binder().term.ty().walk().any(|arg| arg == dummy_self.into());\n+                        let references_self = match pred.skip_binder().term {\n+                            ty::Term::Ty(ty) => ty.walk().any(|arg| arg == dummy_self.into()),\n+                            ty::Term::Const(c) => {\n+                                c.ty.walk().any(|arg| arg == dummy_self.into())\n+                            }\n+                        };\n \n                         // If the projection output contains `Self`, force the user to\n                         // elaborate it explicitly to avoid a lot of complexity.\n@@ -1615,7 +1620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     {\n         let mut matching_candidates = all_candidates()\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n+            .filter(|r| self.trait_defines_associated_named(r.def_id(), assoc_name));\n \n         let bound = match matching_candidates.next() {\n             Some(bound) => bound,"}, {"sha": "504807e87b69a5396e85f666ac7ce9c8fa5011fe", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -279,7 +279,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         };\n \n-        let ret_param_ty = projection.skip_binder().term.ty();\n+        // Since this is a return parameter type it is safe to unwrap.\n+        let ret_param_ty = projection.skip_binder().term.ty().unwrap();\n         let ret_param_ty = self.resolve_vars_if_possible(ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n@@ -706,9 +707,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Extract the type from the projection. Note that there can\n         // be no bound variables in this type because the \"self type\"\n         // does not have any regions in it.\n-        let output_ty = self.resolve_vars_if_possible(predicate.term.ty());\n+        let output_ty = self.resolve_vars_if_possible(predicate.term);\n         debug!(\"deduce_future_output_from_projection: output_ty={:?}\", output_ty);\n-        Some(output_ty)\n+        // FIXME(...): How to handle consts here? Will this always be a const?\n+        Some(output_ty.ty().unwrap())\n     }\n \n     /// Converts the types that the user supplied, in case that doing"}, {"sha": "bf362357ed073ccff73ba7295c6d1d207ea7e72a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -789,10 +789,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     item_def_id: projection_ty.item_def_id,\n                                 };\n \n-                                let ty: Ty<'_> = pred.skip_binder().term.ty();\n+                                let fmt = match pred.skip_binder().term {\n+                                    ty::Term::Ty(ty) => format!(\"{}\", ty),\n+                                    ty::Term::Const(c) => format!(\"{}\", c),\n+                                };\n \n-                                let obligation = format!(\"{} = {}\", projection_ty, ty);\n-                                let quiet = format!(\"{} = {}\", quiet_projection_ty, ty);\n+                                let obligation = format!(\"{} = {}\", projection_ty, fmt);\n+                                let quiet = format!(\"{} = {}\", quiet_projection_ty, fmt);\n \n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))"}, {"sha": "9f67713d585bd58fcd26d6312798eda383930e85", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -694,7 +694,10 @@ fn bounds_from_generic_predicates<'tcx>(\n         where_clauses.push(format!(\n             \"{} = {}\",\n             tcx.def_path_str(p.projection_ty.item_def_id),\n-            p.term.ty()\n+            match p.term {\n+                ty::Term::Ty(ty) => format!(\"{}\", ty),\n+                ty::Term::Const(c) => format!(\"{}\", c),\n+            }\n         ));\n     }\n     let where_clauses = if where_clauses.is_empty() {"}, {"sha": "18a4d8a475380f328ec17ef2792a5114c1e66231", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -553,8 +553,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             if self.is_fn_trait(trait_) && left_name == sym::Output {\n                                 ty_to_fn\n                                     .entry(*ty.clone())\n-                                    .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n-                                    .or_insert((None, Some(rhs)));\n+                                    .and_modify(|e| {\n+                                        *e = (e.0.clone(), Some(rhs.ty().unwrap().clone()))\n+                                    })\n+                                    .or_insert((None, Some(rhs.ty().unwrap().clone())));\n                                 continue;\n                             }\n \n@@ -570,7 +572,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n                                     bindings.push(TypeBinding {\n                                         name: left_name,\n-                                        kind: TypeBindingKind::Equality { ty: rhs },\n+                                        kind: TypeBindingKind::Equality { term: rhs },\n                                     });\n                                 }\n                                 GenericArgs::Parenthesized { .. } => {"}, {"sha": "6a3cdcc2c20da729326f900e81fb6ae1f0cf535c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -272,9 +272,10 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                 bounds: wrp.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n             },\n \n-            hir::WherePredicate::EqPredicate(ref wrp) => {\n-                WherePredicate::EqPredicate { lhs: wrp.lhs_ty.clean(cx), rhs: wrp.rhs_ty.clean(cx) }\n-            }\n+            hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n+                lhs: wrp.lhs_ty.clean(cx),\n+                rhs: wrp.rhs_ty.clean(cx).into(),\n+            },\n         }\n     }\n }\n@@ -352,11 +353,31 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n+impl<'tcx> Clean<Term> for ty::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+        match self {\n+            ty::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<Term> for hir::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+        match self {\n+            hir::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            hir::Term::Const(c) => {\n+                let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n+                Term::Constant(ty::Const::from_anon_const(cx.tcx, def_id).clean(cx))\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         let ty::ProjectionPredicate { projection_ty, term } = self;\n-        let ty = term.ty();\n-        WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n+        WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: term.clean(cx) }\n     }\n }\n \n@@ -614,7 +635,7 @@ fn clean_ty_generics(\n \n             if let Some(param_idx) = param_idx {\n                 if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p = p.clean(cx)?;\n+                    let p: WherePredicate = p.clean(cx)?;\n \n                     b.extend(\n                         p.get_bounds()\n@@ -624,13 +645,17 @@ fn clean_ty_generics(\n                             .filter(|b| !b.is_sized_bound(cx)),\n                     );\n \n-                    let proj = projection.map(|p| {\n-                        (p.skip_binder().projection_ty.clean(cx), p.skip_binder().term.ty())\n-                    });\n+                    let proj = projection\n+                        .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().term));\n                     if let Some(((_, trait_did, name), rhs)) =\n                         proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n                     {\n-                        impl_trait_proj.entry(param_idx).or_default().push((trait_did, name, rhs));\n+                        // FIXME(...): Remove this unwrap()\n+                        impl_trait_proj.entry(param_idx).or_default().push((\n+                            trait_did,\n+                            name,\n+                            rhs.ty().unwrap(),\n+                        ));\n                     }\n \n                     return None;\n@@ -649,7 +674,7 @@ fn clean_ty_generics(\n             if let Some(proj) = impl_trait_proj.remove(&idx) {\n                 for (trait_did, name, rhs) in proj {\n                     let rhs = rhs.clean(cx);\n-                    simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n+                    simplify::merge_bounds(cx, &mut bounds, trait_did, name, &Term::Type(rhs));\n                 }\n             }\n         } else {\n@@ -1497,7 +1522,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n                         name: cx.tcx.associated_item(pb.item_def_id()).ident.name,\n-                        kind: TypeBindingKind::Equality { ty: pb.skip_binder().ty.clean(cx) },\n+                        kind: TypeBindingKind::Equality {\n+                            term: pb.skip_binder().ty.clean(cx).into(),\n+                        },\n                     });\n                 }\n \n@@ -1568,7 +1595,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                                 .ident\n                                                 .name,\n                                             kind: TypeBindingKind::Equality {\n-                                                ty: proj.term.ty().clean(cx),\n+                                                term: proj.term.clean(cx),\n                                             },\n                                         })\n                                     } else {\n@@ -2116,10 +2143,9 @@ impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n         match *self {\n-            hir::TypeBindingKind::Equality { ref term } => match term {\n-                hir::Term::Ty(ref ty) => TypeBindingKind::Equality { ty: ty.clean(cx) },\n-                hir::Term::Const(ref _c) => todo!(),\n-            },\n+            hir::TypeBindingKind::Equality { ref term } => {\n+                TypeBindingKind::Equality { term: term.clean(cx) }\n+            }\n             hir::TypeBindingKind::Constraint { ref bounds } => TypeBindingKind::Constraint {\n                 bounds: bounds.iter().filter_map(|b| b.clean(cx)).collect(),\n             },"}, {"sha": "0bad153280822f971d101f4aad49b5e651e6ffd3", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -92,7 +92,7 @@ crate fn merge_bounds(\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,\n     name: Symbol,\n-    rhs: &clean::Type,\n+    rhs: &clean::Term,\n ) -> bool {\n     !bounds.iter_mut().any(|b| {\n         let trait_ref = match *b {\n@@ -110,14 +110,14 @@ crate fn merge_bounds(\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {\n                     name,\n-                    kind: clean::TypeBindingKind::Equality { ty: rhs.clone() },\n+                    kind: clean::TypeBindingKind::Equality { term: rhs.clone() },\n                 });\n             }\n             PP::Parenthesized { ref mut output, .. } => match output {\n-                Some(o) => assert_eq!(o.as_ref(), rhs),\n+                Some(o) => assert_eq!(&clean::Term::Type(o.as_ref().clone()), rhs),\n                 None => {\n-                    if *rhs != clean::Type::Tuple(Vec::new()) {\n-                        *output = Some(Box::new(rhs.clone()));\n+                    if *rhs != clean::Term::Type(clean::Type::Tuple(Vec::new())) {\n+                        *output = Some(Box::new(rhs.ty().unwrap().clone()));\n                     }\n                 }\n             },"}, {"sha": "ba771c0c1a1a4bcfdf144c20f46499b56b6443e5", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -1212,7 +1212,7 @@ impl Lifetime {\n crate enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<Lifetime> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n-    EqPredicate { lhs: Type, rhs: Type },\n+    EqPredicate { lhs: Type, rhs: Term },\n }\n \n impl WherePredicate {\n@@ -1308,7 +1308,12 @@ impl FnDecl {\n             FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n                 GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n                     let bindings = trait_.bindings().unwrap();\n-                    FnRetTy::Return(bindings[0].ty().clone())\n+                    let ret_ty = bindings[0].term();\n+                    let ty = match ret_ty {\n+                        Term::Type(ty) => ty,\n+                        Term::Constant(_c) => unreachable!(),\n+                    };\n+                    FnRetTy::Return(ty.clone())\n                 }\n                 _ => panic!(\"unexpected desugaring of async function\"),\n             },\n@@ -2121,6 +2126,24 @@ crate struct Constant {\n     crate kind: ConstantKind,\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+crate enum Term {\n+    Type(Type),\n+    Constant(Constant),\n+}\n+\n+impl Term {\n+    crate fn ty(&self) -> Option<&Type> {\n+        if let Term::Type(ty) = self { Some(ty) } else { None }\n+    }\n+}\n+\n+impl From<Type> for Term {\n+    fn from(ty: Type) -> Self {\n+        Term::Type(ty)\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n crate enum ConstantKind {\n     /// This is the wrapper around `ty::Const` for a non-local constant. Because it doesn't have a\n@@ -2283,14 +2306,14 @@ crate struct TypeBinding {\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum TypeBindingKind {\n-    Equality { ty: Type },\n+    Equality { term: Term },\n     Constraint { bounds: Vec<GenericBound> },\n }\n \n impl TypeBinding {\n-    crate fn ty(&self) -> &Type {\n+    crate fn term(&self) -> &Term {\n         match self.kind {\n-            TypeBindingKind::Equality { ref ty } => ty,\n+            TypeBindingKind::Equality { ref term } => term,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n         }\n     }"}, {"sha": "08840626259dc31eabda7e5a2a6678b54a3fd877", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -1442,11 +1442,11 @@ impl clean::TypeBinding {\n         display_fn(move |f| {\n             f.write_str(self.name.as_str())?;\n             match self.kind {\n-                clean::TypeBindingKind::Equality { ref ty } => {\n+                clean::TypeBindingKind::Equality { ref term } => {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cx))?;\n+                        write!(f, \" = {:#}\", term.print(cx))?;\n                     } else {\n-                        write!(f, \" = {}\", ty.print(cx))?;\n+                        write!(f, \" = {}\", term.print(cx))?;\n                     }\n                 }\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n@@ -1492,6 +1492,18 @@ impl clean::GenericArg {\n     }\n }\n \n+impl clean::types::Term {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        match self {\n+            clean::types::Term::Type(ty) => ty.print(cx),\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n crate fn display_fn(f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Display {\n     struct WithFormatter<F>(Cell<Option<F>>);\n "}, {"sha": "e77bd5c9223138ddc81b0a3faf07d0ade82cd450", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -162,7 +162,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     fn from_tcx(kind: clean::TypeBindingKind, tcx: TyCtxt<'_>) -> Self {\n         use clean::TypeBindingKind::*;\n         match kind {\n-            Equality { ty } => TypeBindingKind::Equality(ty.into_tcx(tcx)),\n+            Equality { term } => TypeBindingKind::Equality(term.into_tcx(tcx)),\n             Constraint { bounds } => {\n                 TypeBindingKind::Constraint(bounds.into_iter().map(|a| a.into_tcx(tcx)).collect())\n             }\n@@ -452,6 +452,15 @@ impl FromWithTcx<clean::Type> for Type {\n     }\n }\n \n+impl FromWithTcx<clean::Term> for Term {\n+    fn from_tcx(term: clean::Term, tcx: TyCtxt<'_>) -> Term {\n+        match term {\n+            clean::Term::Type(ty) => Term::Type(FromWithTcx::from_tcx(ty, tcx)),\n+            clean::Term::Constant(c) => Term::Constant(FromWithTcx::from_tcx(c, tcx)),\n+        }\n+    }\n+}\n+\n impl FromWithTcx<clean::BareFunctionDecl> for FunctionPointer {\n     fn from_tcx(bare_decl: clean::BareFunctionDecl, tcx: TyCtxt<'_>) -> Self {\n         let clean::BareFunctionDecl { unsafety, generic_params, decl, abi } = bare_decl;"}, {"sha": "618c8aab86a19416986712912d64f3cb853cbb65", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -148,7 +148,7 @@ pub struct TypeBinding {\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n #[serde(rename_all = \"snake_case\")]\n pub enum TypeBindingKind {\n-    Equality(Type),\n+    Equality(Term),\n     Constraint(Vec<GenericBound>),\n }\n \n@@ -335,7 +335,7 @@ pub enum GenericParamDefKind {\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: String, bounds: Vec<GenericBound> },\n-    EqPredicate { lhs: Type, rhs: Type },\n+    EqPredicate { lhs: Type, rhs: Term },\n }\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n@@ -359,6 +359,13 @@ pub enum TraitBoundModifier {\n     MaybeConst,\n }\n \n+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n+pub enum Term {\n+    Type(Type),\n+    Constant(Constant),\n+}\n+\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n #[serde(rename_all = \"snake_case\")]\n #[serde(tag = \"kind\", content = \"inner\")]"}, {"sha": "ad51707070f9f0f84e7503217fbce9b2363a2741", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[HASH]::Id::This) }, (I,)), [])`\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[HASH]::Id::This) }, Ty((I,))), [])`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "ca8bbbd8f9169de0aa1930275d798bbd3e83ed51", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -2141,12 +2141,16 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n                     if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+                        let assoc_ty = match projection_predicate.term {\n+                          ty::Term::Ty(ty) => ty,\n+                          ty::Term::Const(c) => c.ty,\n+                        };\n                         // walk the associated type and check for Self\n                         if let Some(self_adt) = self_ty.ty_adt_def() {\n-                            if contains_adt_constructor(projection_predicate.term.ty(), self_adt) {\n+                            if contains_adt_constructor(assoc_ty, self_adt) {\n                                 return;\n                             }\n-                        } else if contains_ty(projection_predicate.term.ty(), self_ty) {\n+                        } else if contains_ty(assoc_ty, self_ty) {\n                             return;\n                         }\n                     }"}, {"sha": "9162de3cceafa3b377c67020154ece42f4c170cd", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -243,9 +243,10 @@ fn check_other_call_arg<'tcx>(\n         if if trait_predicate.def_id() == deref_trait_id {\n             if let [projection_predicate] = projection_predicates[..] {\n                 let normalized_ty =\n-                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term.ty());\n+                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term);\n                 implements_trait(cx, receiver_ty, deref_trait_id, &[])\n-                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(normalized_ty)\n+                    && get_associated_type(cx, receiver_ty, deref_trait_id,\n+                    \"Target\").map_or(false, |ty| ty::Term::Ty(ty) == normalized_ty)\n             } else {\n                 false\n             }"}, {"sha": "68156df2ecea879c1067e9c184131cbd53579d28", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7529d6a3867ed1692818702b40814ee992eba2d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=e7529d6a3867ed1692818702b40814ee992eba2d", "patch": "@@ -98,9 +98,10 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n                         if trait_pred.self_ty() == inp;\n                         if let Some(return_ty_pred) = get_projection_pred(cx, generics, *trait_pred);\n                         then {\n-                            if ord_preds.iter().any(|ord| ord.self_ty() == return_ty_pred.term.ty()) {\n+                            if ord_preds.iter().any(|ord| Some(ord.self_ty()) ==\n+                            return_ty_pred.term.ty()) {\n                                 args_to_check.push((i, \"Ord\".to_string()));\n-                            } else if partial_ord_preds.iter().any(|pord| pord.self_ty() == return_ty_pred.term.ty()) {\n+                            } else if partial_ord_preds.iter().any(|pord| pord.self_ty() == return_ty_pred.term.ty().unwrap()) {\n                                 args_to_check.push((i, \"PartialOrd\".to_string()));\n                             }\n                         }"}]}