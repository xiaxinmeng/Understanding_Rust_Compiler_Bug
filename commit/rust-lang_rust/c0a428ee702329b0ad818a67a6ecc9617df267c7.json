{"sha": "c0a428ee702329b0ad818a67a6ecc9617df267c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYTQyOGVlNzAyMzI5YjBhZDgxOGE2N2E2ZWNjOTYxN2RmMjY3Yzc=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-10-03T11:49:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T13:07:24Z"}, "message": "Great separation of librustc_codegen_llvm: librustc_codegen_ssa compiles", "tree": {"sha": "c47602d70ccd0f3d54f47e29730e880751afada4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c47602d70ccd0f3d54f47e29730e880751afada4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a428ee702329b0ad818a67a6ecc9617df267c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a428ee702329b0ad818a67a6ecc9617df267c7", "html_url": "https://github.com/rust-lang/rust/commit/c0a428ee702329b0ad818a67a6ecc9617df267c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a428ee702329b0ad818a67a6ecc9617df267c7/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "915382f7306be7841c4254cee13fa55a865bdd8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/915382f7306be7841c4254cee13fa55a865bdd8b", "html_url": "https://github.com/rust-lang/rust/commit/915382f7306be7841c4254cee13fa55a865bdd8b"}], "stats": {"total": 3104, "additions": 1634, "deletions": 1470}, "files": [{"sha": "bd396e89e072888f87b319ab87be29c2c0a6e9a5", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 9, "deletions": 915, "changes": 924, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -38,7 +38,7 @@ use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{Linkage, Visibility, Stats, CodegenUnitNameBuilder};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::middle::exported_symbols;\n@@ -66,7 +66,6 @@ use rustc::util::nodemap::FxHashMap;\n use CrateInfo;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::indexed_vec::Idx;\n \n use interfaces::*;\n \n@@ -88,500 +87,6 @@ use mir::operand::OperandValue;\n \n use rustc_codegen_utils::check_for_rustc_errors_attr;\n \n-pub struct StatRecorder<'a, 'tcx, Cx: 'a + CodegenMethods<'tcx>> {\n-    cx: &'a Cx,\n-    name: Option<String>,\n-    istart: usize,\n-    _marker: marker::PhantomData<&'tcx ()>,\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> StatRecorder<'a, 'tcx, Cx> {\n-    pub fn new(cx: &'a Cx, name: String) -> Self {\n-        let istart = cx.stats().borrow().n_llvm_insns;\n-        StatRecorder {\n-            cx,\n-            name: Some(name),\n-            istart,\n-            _marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> Drop for StatRecorder<'a, 'tcx, Cx> {\n-    fn drop(&mut self) {\n-        if self.cx.sess().codegen_stats() {\n-            let mut stats = self.cx.stats().borrow_mut();\n-            let iend = stats.n_llvm_insns;\n-            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n-            stats.n_fns += 1;\n-            // Reset LLVM insn count to avoid compound costs.\n-            stats.n_llvm_insns = self.istart;\n-        }\n-    }\n-}\n-\n-pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n-                                signed: bool)\n-                                -> IntPredicate {\n-    match op {\n-        hir::BinOpKind::Eq => IntPredicate::IntEQ,\n-        hir::BinOpKind::Ne => IntPredicate::IntNE,\n-        hir::BinOpKind::Lt => if signed { IntPredicate::IntSLT } else { IntPredicate::IntULT },\n-        hir::BinOpKind::Le => if signed { IntPredicate::IntSLE } else { IntPredicate::IntULE },\n-        hir::BinOpKind::Gt => if signed { IntPredicate::IntSGT } else { IntPredicate::IntUGT },\n-        hir::BinOpKind::Ge => if signed { IntPredicate::IntSGE } else { IntPredicate::IntUGE },\n-        op => {\n-            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n-                  found {:?}\",\n-                 op)\n-        }\n-    }\n-}\n-\n-pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n-    match op {\n-        hir::BinOpKind::Eq => RealPredicate::RealOEQ,\n-        hir::BinOpKind::Ne => RealPredicate::RealUNE,\n-        hir::BinOpKind::Lt => RealPredicate::RealOLT,\n-        hir::BinOpKind::Le => RealPredicate::RealOLE,\n-        hir::BinOpKind::Gt => RealPredicate::RealOGT,\n-        hir::BinOpKind::Ge => RealPredicate::RealOGE,\n-        op => {\n-            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n-                  found {:?}\",\n-                 op);\n-        }\n-    }\n-}\n-\n-pub fn compare_simd_types<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value,\n-    t: Ty<'tcx>,\n-    ret_ty: Bx::Type,\n-    op: hir::BinOpKind\n-) -> Bx::Value {\n-    let signed = match t.sty {\n-        ty::Float(_) => {\n-            let cmp = bin_op_to_fcmp_predicate(op);\n-            return bx.sext(bx.fcmp(cmp, lhs, rhs), ret_ty);\n-        },\n-        ty::Uint(_) => false,\n-        ty::Int(_) => true,\n-        _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n-    };\n-\n-    let cmp = bin_op_to_icmp_predicate(op, signed);\n-    // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n-    // to get the correctly sized type. This will compile to a single instruction\n-    // once the IR is converted to assembly if the SIMD instruction is supported\n-    // by the target architecture.\n-    bx.sext(bx.icmp(cmp, lhs, rhs), ret_ty)\n-}\n-\n-/// Retrieve the information we are losing (making dynamic) in an unsizing\n-/// adjustment.\n-///\n-/// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be derived\n-/// from the old one.\n-pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n-    cx: &Cx,\n-    source: Ty<'tcx>,\n-    target: Ty<'tcx>,\n-    old_info: Option<Cx::Value>,\n-) -> Cx::Value {\n-    let (source, target) = cx.tcx().struct_lockstep_tails(source, target);\n-    match (&source.sty, &target.sty) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => {\n-            cx.const_usize(len.unwrap_usize(cx.tcx()))\n-        }\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n-        }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target))\n-                .field(cx, abi::FAT_PTR_EXTRA);\n-            cx.static_ptrcast(meth::get_vtable(cx, source, data.principal()),\n-                            cx.backend_type(vtable_ptr))\n-        }\n-        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                  source,\n-                  target),\n-    }\n-}\n-\n-/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    src: Bx::Value,\n-    src_ty: Ty<'tcx>,\n-    dst_ty: Ty<'tcx>\n-) -> (Bx::Value, Bx::Value) {\n-    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n-    match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::Ref(_, a, _),\n-         &ty::Ref(_, b, _)) |\n-        (&ty::Ref(_, a, _),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n-            assert_eq!(def_a, def_b);\n-\n-            let src_layout = bx.cx().layout_of(src_ty);\n-            let dst_layout = bx.cx().layout_of(dst_ty);\n-            let mut result = None;\n-            for i in 0..src_layout.fields.count() {\n-                let src_f = src_layout.field(bx.cx(), i);\n-                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n-                if src_f.is_zst() {\n-                    continue;\n-                }\n-                assert_eq!(src_layout.size, src_f.size);\n-\n-                let dst_f = dst_layout.field(bx.cx(), i);\n-                assert_ne!(src_f.ty, dst_f.ty);\n-                assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n-            }\n-            let (lldata, llextra) = result.unwrap();\n-            // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n-             bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n-        }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n-    }\n-}\n-\n-/// Coerce `src`, which is a reference to a value of type `src_ty`,\n-/// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    src: PlaceRef<'tcx, Bx::Value>,\n-    dst: PlaceRef<'tcx, Bx::Value>\n-)  {\n-    let src_ty = src.layout.ty;\n-    let dst_ty = dst.layout.ty;\n-    let coerce_ptr = || {\n-        let (base, info) = match bx.load_operand(src).val {\n-            OperandValue::Pair(base, info) => {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n-                // So we need to pointercast the base to ensure\n-                // the types match up.\n-                let thin_ptr = dst.layout.field(bx.cx(), abi::FAT_PTR_ADDR);\n-                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n-            }\n-            OperandValue::Immediate(base) => {\n-                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n-            }\n-            OperandValue::Ref(..) => bug!()\n-        };\n-        OperandValue::Pair(base, info).store(bx, dst);\n-    };\n-    match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::Ref(..), &ty::Ref(..)) |\n-        (&ty::Ref(..), &ty::RawPtr(..)) |\n-        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n-            coerce_ptr()\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            coerce_ptr()\n-        }\n-\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n-            assert_eq!(def_a, def_b);\n-\n-            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n-                let src_f = src.project_field(bx, i);\n-                let dst_f = dst.project_field(bx, i);\n-\n-                if dst_f.layout.is_zst() {\n-                    continue;\n-                }\n-\n-                if src_f.layout.ty == dst_f.layout.ty {\n-                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n-                              src_f.layout, MemFlags::empty());\n-                } else {\n-                    coerce_unsized_into(bx, src_f, dst_f);\n-                }\n-            }\n-        }\n-        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-                  src_ty,\n-                  dst_ty),\n-    }\n-}\n-\n-pub fn cast_shift_expr_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    op: hir::BinOpKind,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value\n-) -> Bx::Value {\n-    cast_shift_rhs(bx, op, lhs, rhs, |a, b| bx.trunc(a, b), |a, b| bx.zext(a, b))\n-}\n-\n-fn cast_shift_rhs<'a, 'tcx: 'a, F, G, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    op: hir::BinOpKind,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value,\n-    trunc: F,\n-    zext: G\n-) -> Bx::Value\n-    where F: FnOnce(\n-        Bx::Value,\n-        Bx::Type\n-    ) -> Bx::Value,\n-    G: FnOnce(\n-        Bx::Value,\n-        Bx::Type\n-    ) -> Bx::Value\n-{\n-    // Shifts may have any size int on the rhs\n-    if op.is_shift() {\n-        let mut rhs_llty = bx.cx().val_ty(rhs);\n-        let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n-            rhs_llty = bx.cx().element_type(rhs_llty)\n-        }\n-        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n-            lhs_llty = bx.cx().element_type(lhs_llty)\n-        }\n-        let rhs_sz = bx.cx().int_width(rhs_llty);\n-        let lhs_sz = bx.cx().int_width(lhs_llty);\n-        if lhs_sz < rhs_sz {\n-            trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If in the future shifting by negative\n-            // values is no longer undefined then this is wrong.\n-            zext(rhs, lhs_llty)\n-        } else {\n-            rhs\n-        }\n-    } else {\n-        rhs\n-    }\n-}\n-\n-/// Returns whether this session's target will use SEH-based unwinding.\n-///\n-/// This is only true for MSVC targets, and even then the 64-bit MSVC target\n-/// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n-/// 64-bit MinGW) instead of \"full SEH\".\n-pub fn wants_msvc_seh(sess: &Session) -> bool {\n-    sess.target.target.options.is_like_msvc\n-}\n-\n-pub fn call_assume<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    val: Bx::Value\n-) {\n-    let assume_intrinsic = bx.cx().get_intrinsic(\"llvm.assume\");\n-    bx.call(assume_intrinsic, &[val], None);\n-}\n-\n-pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    val: Bx::Value\n-) -> Bx::Value {\n-    if bx.cx().val_ty(val) == bx.cx().type_i1() {\n-        bx.zext(val, bx.cx().type_i8())\n-    } else {\n-        val\n-    }\n-}\n-\n-pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    val: Bx::Value,\n-    layout: layout::TyLayout,\n-) -> Bx::Value {\n-    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-        return to_immediate_scalar(bx, val, scalar);\n-    }\n-    val\n-}\n-\n-pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    val: Bx::Value,\n-    scalar: &layout::Scalar,\n-) -> Bx::Value {\n-    if scalar.is_bool() {\n-        return bx.trunc(val, bx.cx().type_i1());\n-    }\n-    val\n-}\n-\n-pub fn memcpy_ty<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    dst: Bx::Value,\n-    dst_align: Align,\n-    src: Bx::Value,\n-    src_align: Align,\n-    layout: TyLayout<'tcx>,\n-    flags: MemFlags,\n-) {\n-    let size = layout.size.bytes();\n-    if size == 0 {\n-        return;\n-    }\n-\n-    bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n-}\n-\n-pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    cx: &'a Bx::CodegenCx,\n-    instance: Instance<'tcx>,\n-) {\n-    let _s = if cx.sess().codegen_stats() {\n-        let mut instance_name = String::new();\n-        DefPathBasedNames::new(cx.tcx(), true, true)\n-            .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(cx, instance_name))\n-    } else {\n-        None\n-    };\n-\n-    // this is an info! to allow collecting monomorphization statistics\n-    // and to allow finding the last function before LLVM aborts from\n-    // release builds.\n-    info!(\"codegen_instance({})\", instance);\n-\n-    let sig = instance.fn_sig(cx.tcx());\n-    let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-\n-    let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n-        bug!(\"Instance `{:?}` not already declared\", instance));\n-\n-    cx.stats().borrow_mut().n_closures += 1;\n-\n-    let mir = cx.tcx().instance_mir(instance.def);\n-    mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n-}\n-\n-pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n-    let sect = match attrs.link_section {\n-        Some(name) => name,\n-        None => return,\n-    };\n-    unsafe {\n-        let buf = SmallCStr::new(&sect.as_str());\n-        llvm::LLVMSetSection(llval, buf.as_ptr());\n-    }\n-}\n-\n-/// Create the `main` function which will initialize the rust runtime and call\n-/// users main function.\n-fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    cx: &'a Bx::CodegenCx\n-) {\n-    let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n-        Some((id, span, _)) => {\n-            (cx.tcx().hir.local_def_id(id), span)\n-        }\n-        None => return,\n-    };\n-\n-    let instance = Instance::mono(cx.tcx(), main_def_id);\n-\n-    if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n-        // We want to create the wrapper in the same codegen unit as Rust's main\n-        // function.\n-        return;\n-    }\n-\n-    let main_llfn = cx.get_fn(instance);\n-\n-    let et = cx.sess().entry_fn.get().map(|e| e.2);\n-    match et {\n-        Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n-        Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n-        None => {}    // Do nothing.\n-    }\n-\n-    fn create_entry_fn<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-        cx: &'a Bx::CodegenCx,\n-        sp: Span,\n-        rust_main: Bx::Value,\n-        rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n-    ) {\n-        let llfty =\n-            cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int());\n-\n-        let main_ret_ty = cx.tcx().fn_sig(rust_main_def_id).output();\n-        // Given that `main()` has no arguments,\n-        // then its return type cannot have\n-        // late-bound regions, since late-bound\n-        // regions must appear in the argument\n-        // listing.\n-        let main_ret_ty = cx.tcx().erase_regions(\n-            &main_ret_ty.no_bound_vars().unwrap(),\n-        );\n-\n-        if cx.get_defined_value(\"main\").is_some() {\n-            // FIXME: We should be smart and show a better diagnostic here.\n-            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n-                     .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n-                     .emit();\n-            cx.sess().abort_if_errors();\n-            bug!();\n-        }\n-        let llfn = cx.declare_cfn(\"main\", llfty);\n-\n-        // `main` should respect same config for frame pointer elimination as rest of code\n-        cx.set_frame_pointer_elimination(llfn);\n-        cx.apply_target_cpu_attr(llfn);\n-\n-        let bx = Bx::new_block(&cx, llfn, \"top\");\n-\n-        bx.insert_reference_to_gdb_debug_scripts_section_global();\n-\n-        // Params from native main() used as args for rust start function\n-        let param_argc = cx.get_param(llfn, 0);\n-        let param_argv = cx.get_param(llfn, 1);\n-        let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n-        let arg_argv = param_argv;\n-\n-        let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem);\n-            let start_fn = callee::resolve_and_get_fn(\n-                cx,\n-                start_def_id,\n-                cx.tcx().intern_substs(&[main_ret_ty.into()]),\n-            );\n-            (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n-                            arg_argc, arg_argv])\n-        } else {\n-            debug!(\"using user-defined start fn\");\n-            (rust_main, vec![arg_argc, arg_argv])\n-        };\n-\n-        let result = bx.call(start_fn, &args, None);\n-        bx.ret(bx.intcast(result, cx.type_int(), true));\n-    }\n-}\n-\n pub(crate) fn write_metadata<'a, 'gcx>(\n     tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     llvm_module: &ModuleLlvm\n@@ -675,397 +180,6 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 cgu: &CodegenUnit<'tcx>)\n-                                 -> CguReuse {\n-    if !tcx.dep_graph.is_fully_enabled() {\n-        return CguReuse::No\n-    }\n-\n-    let work_product_id = &cgu.work_product_id();\n-    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n-        // We don't have anything cached for this CGU. This can happen\n-        // if the CGU did not exist in the previous session.\n-        return CguReuse::No\n-    }\n-\n-    // Try to mark the CGU as green. If it we can do so, it means that nothing\n-    // affecting the LLVM module has changed and we can re-use a cached version.\n-    // If we compile with any kind of LTO, this means we can re-use the bitcode\n-    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n-    // know that later). If we are not doing LTO, there is only one optimized\n-    // version of each module, so we re-use that.\n-    let dep_node = cgu.codegen_dep_node(tcx);\n-    assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n-        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n-        cgu.name());\n-\n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        // We can re-use either the pre- or the post-thinlto state\n-        if tcx.sess.lto() != Lto::No {\n-            CguReuse::PreLto\n-        } else {\n-            CguReuse::PostLto\n-        }\n-    } else {\n-        CguReuse::No\n-    }\n-}\n-\n-pub fn codegen_crate<B: BackendMethods>(\n-    backend: B,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    rx: mpsc::Receiver<Box<dyn Any + Send>>\n-) -> B::OngoingCodegen {\n-\n-    check_for_rustc_errors_attr(tcx);\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-\n-    // Codegen the metadata.\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n-\n-    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                            &[\"crate\"],\n-                                                            Some(\"metadata\")).as_str()\n-                                                                             .to_string();\n-    let metadata_llvm_module = backend.new_metadata(tcx.sess, &metadata_cgu_name);\n-    let metadata = time(tcx.sess, \"write metadata\", || {\n-        backend.write_metadata(tcx, &metadata_llvm_module)\n-    });\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n-\n-    let metadata_module = ModuleCodegen {\n-        name: metadata_cgu_name,\n-        module_llvm: metadata_llvm_module,\n-        kind: ModuleKind::Metadata,\n-    };\n-\n-    let time_graph = if tcx.sess.opts.debugging_opts.codegen_time_graph {\n-        Some(time_graph::TimeGraph::new())\n-    } else {\n-        None\n-    };\n-\n-    // Skip crate items and just output metadata in -Z no-codegen mode.\n-    if tcx.sess.opts.debugging_opts.no_codegen ||\n-       !tcx.sess.opts.output_types.should_codegen() {\n-        let ongoing_codegen = backend.start_async_codegen(\n-            tcx,\n-            time_graph,\n-            metadata,\n-            rx,\n-            1);\n-\n-        backend.submit_pre_codegened_module_to_llvm(&ongoing_codegen, tcx, metadata_module);\n-        backend.codegen_finished(&ongoing_codegen, tcx);\n-\n-        assert_and_save_dep_graph(tcx);\n-\n-        backend.check_for_errors(&ongoing_codegen, tcx.sess);\n-\n-        return ongoing_codegen;\n-    }\n-\n-    // Run the monomorphization collector and partition the collected items into\n-    // codegen units.\n-    let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n-    let codegen_units = (*codegen_units).clone();\n-\n-    // Force all codegen_unit queries so they are already either red or green\n-    // when compile_codegen_unit accesses them. We are not able to re-execute\n-    // the codegen_unit query from just the DepNode, so an unknown color would\n-    // lead to having to re-execute compile_codegen_unit, possibly\n-    // unnecessarily.\n-    if tcx.dep_graph.is_fully_enabled() {\n-        for cgu in &codegen_units {\n-            tcx.codegen_unit(cgu.name().clone());\n-        }\n-    }\n-\n-    let ongoing_codegen = backend.start_async_codegen(\n-        tcx,\n-        time_graph.clone(),\n-        metadata,\n-        rx,\n-        codegen_units.len());\n-    let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n-\n-    // Codegen an allocator shim, if necessary.\n-    //\n-    // If the crate doesn't have an `allocator_kind` set then there's definitely\n-    // no shim to generate. Otherwise we also check our dependency graph for all\n-    // our output crate types. If anything there looks like its a `Dynamic`\n-    // linkage, then it's already got an allocator shim and we'll be using that\n-    // one instead. If nothing exists then it's our job to generate the\n-    // allocator!\n-    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n-        .iter()\n-        .any(|(_, list)| {\n-            use rustc::middle::dependency_format::Linkage;\n-            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n-    let allocator_module = if any_dynamic_crate {\n-        None\n-    } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n-        let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                       &[\"crate\"],\n-                                                       Some(\"allocator\")).as_str()\n-                                                                         .to_string();\n-        let modules = backend.new_metadata(tcx.sess, &llmod_id);\n-        time(tcx.sess, \"write allocator module\", || {\n-            backend.codegen_allocator(tcx, &modules, kind)\n-        });\n-\n-        Some(ModuleCodegen {\n-            name: llmod_id,\n-            module_llvm: modules,\n-            kind: ModuleKind::Allocator,\n-        })\n-    } else {\n-        None\n-    };\n-\n-    if let Some(allocator_module) = allocator_module {\n-        backend.submit_pre_codegened_module_to_llvm(&ongoing_codegen, tcx, allocator_module);\n-    }\n-\n-    backend.submit_pre_codegened_module_to_llvm(&ongoing_codegen, tcx, metadata_module);\n-\n-    // We sort the codegen units by size. This way we can schedule work for LLVM\n-    // a bit more efficiently.\n-    let codegen_units = {\n-        let mut codegen_units = codegen_units;\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        codegen_units\n-    };\n-\n-    let mut total_codegen_time = Duration::new(0, 0);\n-    let mut all_stats = Stats::default();\n-\n-    for cgu in codegen_units.into_iter() {\n-        backend.wait_for_signal_to_codegen_item(&ongoing_codegen);\n-        backend.check_for_errors(&ongoing_codegen, tcx.sess);\n-\n-        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n-        tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n-\n-        match cgu_reuse {\n-            CguReuse::No => {\n-                let _timing_guard = time_graph.as_ref().map(|time_graph| {\n-                    time_graph.start(write::CODEGEN_WORKER_TIMELINE,\n-                                     write::CODEGEN_WORK_PACKAGE_KIND,\n-                                     &format!(\"codegen {}\", cgu.name()))\n-                });\n-                let start_time = Instant::now();\n-                let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n-                all_stats.extend(stats);\n-                total_codegen_time += start_time.elapsed();\n-                false\n-            }\n-            CguReuse::PreLto => {\n-                write::submit_pre_lto_module_to_llvm(tcx, CachedModuleCodegen {\n-                    name: cgu.name().to_string(),\n-                    source: cgu.work_product(tcx),\n-                });\n-                true\n-            }\n-            CguReuse::PostLto => {\n-                write::submit_post_lto_module_to_llvm(tcx, CachedModuleCodegen {\n-                    name: cgu.name().to_string(),\n-                    source: cgu.work_product(tcx),\n-                });\n-                true\n-            }\n-        };\n-    }\n-\n-    backend.codegen_finished(&ongoing_codegen, tcx);\n-\n-    // Since the main thread is sometimes blocked during codegen, we keep track\n-    // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(),\n-                            \"codegen to LLVM IR\",\n-                            total_codegen_time);\n-\n-    rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-\n-    symbol_names_test::report_symbol_names(tcx);\n-\n-    if tcx.sess.codegen_stats() {\n-        println!(\"--- codegen stats ---\");\n-        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n-        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n-        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n-\n-        println!(\"n_fns: {}\", all_stats.n_fns);\n-        println!(\"n_inlines: {}\", all_stats.n_inlines);\n-        println!(\"n_closures: {}\", all_stats.n_closures);\n-        println!(\"fn stats:\");\n-        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n-        for &(ref name, insns) in all_stats.fn_stats.iter() {\n-            println!(\"{} insns, {}\", insns, *name);\n-        }\n-    }\n-\n-    if tcx.sess.count_llvm_insns() {\n-        for (k, v) in all_stats.llvm_insns.iter() {\n-            println!(\"{:7} {}\", *v, *k);\n-        }\n-    }\n-\n-    backend.check_for_errors(&ongoing_codegen, tcx.sess);\n-\n-    assert_and_save_dep_graph(tcx);\n-    ongoing_codegen.into_inner()\n-}\n-\n-/// A curious wrapper structure whose only purpose is to call `codegen_aborted`\n-/// when it's dropped abnormally.\n-///\n-/// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n-/// stumbled upon. The segfault was never reproduced locally, but it was\n-/// suspected to be related to the fact that codegen worker threads were\n-/// sticking around by the time the main thread was exiting, causing issues.\n-///\n-/// This structure is an attempt to fix that issue where the `codegen_aborted`\n-/// message will block until all workers have finished. This should ensure that\n-/// even if the main codegen thread panics we'll wait for pending work to\n-/// complete before returning from the main thread, hopefully avoiding\n-/// segfaults.\n-///\n-/// If you see this comment in the code, then it means that this workaround\n-/// worked! We may yet one day track down the mysterious cause of that\n-/// segfault...\n-struct AbortCodegenOnDrop<B: BackendMethods>(Option<B::OngoingCodegen>);\n-\n-impl<B: BackendMethods> AbortCodegenOnDrop<B> {\n-    fn into_inner(mut self) -> B::OngoingCodegen {\n-        self.0.take().unwrap()\n-    }\n-}\n-\n-impl<B: BackendMethods> Deref for AbortCodegenOnDrop<B> {\n-    type Target = B::OngoingCodegen;\n-\n-    fn deref(&self) -> &B::OngoingCodegen {\n-        self.0.as_ref().unwrap()\n-    }\n-}\n-\n-impl<B: BackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n-    fn deref_mut(&mut self) -> &mut B::OngoingCodegen {\n-        self.0.as_mut().unwrap()\n-    }\n-}\n-\n-impl<B: BackendMethods> Drop for AbortCodegenOnDrop<B> {\n-    fn drop(&mut self) {\n-        if let Some(codegen) = self.0.take() {\n-            B::codegen_aborted(codegen);\n-        }\n-    }\n-}\n-\n-fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n-    time(tcx.sess,\n-         \"assert dep graph\",\n-         || rustc_incremental::assert_dep_graph(tcx));\n-\n-    time(tcx.sess,\n-         \"serialize dep graph\",\n-         || rustc_incremental::save_dep_graph(tcx));\n-}\n-\n-impl CrateInfo {\n-    pub fn new(tcx: TyCtxt) -> CrateInfo {\n-        let mut info = CrateInfo {\n-            panic_runtime: None,\n-            compiler_builtins: None,\n-            profiler_runtime: None,\n-            sanitizer_runtime: None,\n-            is_no_builtins: Default::default(),\n-            native_libraries: Default::default(),\n-            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n-            link_args: tcx.link_args(LOCAL_CRATE),\n-            crate_name: Default::default(),\n-            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n-            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n-            used_crate_source: Default::default(),\n-            wasm_imports: Default::default(),\n-            lang_item_to_crate: Default::default(),\n-            missing_lang_items: Default::default(),\n-        };\n-        let lang_items = tcx.lang_items();\n-\n-        let load_wasm_items = tcx.sess.crate_types.borrow()\n-            .iter()\n-            .any(|c| *c != config::CrateType::Rlib) &&\n-            tcx.sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\";\n-\n-        if load_wasm_items {\n-            info.load_wasm_imports(tcx, LOCAL_CRATE);\n-        }\n-\n-        let crates = tcx.crates();\n-\n-        let n_crates = crates.len();\n-        info.native_libraries.reserve(n_crates);\n-        info.crate_name.reserve(n_crates);\n-        info.used_crate_source.reserve(n_crates);\n-        info.missing_lang_items.reserve(n_crates);\n-\n-        for &cnum in crates.iter() {\n-            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n-            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n-            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n-            if tcx.is_panic_runtime(cnum) {\n-                info.panic_runtime = Some(cnum);\n-            }\n-            if tcx.is_compiler_builtins(cnum) {\n-                info.compiler_builtins = Some(cnum);\n-            }\n-            if tcx.is_profiler_runtime(cnum) {\n-                info.profiler_runtime = Some(cnum);\n-            }\n-            if tcx.is_sanitizer_runtime(cnum) {\n-                info.sanitizer_runtime = Some(cnum);\n-            }\n-            if tcx.is_no_builtins(cnum) {\n-                info.is_no_builtins.insert(cnum);\n-            }\n-            if load_wasm_items {\n-                info.load_wasm_imports(tcx, cnum);\n-            }\n-            let missing = tcx.missing_lang_items(cnum);\n-            for &item in missing.iter() {\n-                if let Ok(id) = lang_items.require(item) {\n-                    info.lang_item_to_crate.insert(item, id.krate);\n-                }\n-            }\n-\n-            // No need to look for lang items that are whitelisted and don't\n-            // actually need to exist.\n-            let missing = missing.iter()\n-                .cloned()\n-                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n-                .collect();\n-            info.missing_lang_items.insert(cnum, missing);\n-        }\n-\n-        return info\n-    }\n-\n-    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n-        self.wasm_imports.extend(tcx.wasm_import_module_map(cnum).iter().map(|(&id, module)| {\n-            let instance = Instance::mono(tcx, id);\n-            let import_name = tcx.symbol_name(instance);\n-\n-            (import_name.to_string(), module.clone())\n-        }));\n-    }\n-}\n-\n pub fn compile_codegen_unit<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n                                   cgu_name: InternedString)\n                                   -> Stats {\n@@ -1141,35 +255,15 @@ pub fn compile_codegen_unit<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn provide_both(providers: &mut Providers) {\n-    providers.dllimport_foreign_items = |tcx, krate| {\n-        let module_map = tcx.foreign_modules(krate);\n-        let module_map = module_map.iter()\n-            .map(|lib| (lib.def_id, lib))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        let dllimports = tcx.native_libraries(krate)\n-            .iter()\n-            .filter(|lib| {\n-                if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n-                    return false\n-                }\n-                let cfg = match lib.cfg {\n-                    Some(ref cfg) => cfg,\n-                    None => return true,\n-                };\n-                attr::cfg_matches(cfg, &tcx.sess.parse_sess, None)\n-            })\n-            .filter_map(|lib| lib.foreign_module)\n-            .map(|id| &module_map[&id])\n-            .flat_map(|module| module.foreign_items.iter().cloned())\n-            .collect();\n-        Lrc::new(dllimports)\n-    };\n-\n-    providers.is_dllimport_foreign_item = |tcx, def_id| {\n-        tcx.dllimport_foreign_items(def_id.krate).contains(&def_id)\n+pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n+    let sect = match attrs.link_section {\n+        Some(name) => name,\n+        None => return,\n     };\n+    unsafe {\n+        let buf = SmallCStr::new(&sect.as_str());\n+        llvm::LLVMSetSection(llval, buf.as_ptr());\n+    }\n }\n \n pub fn linkage_to_llvm(linkage: Linkage) -> llvm::Linkage {"}, {"sha": "40fddef8be3d3ccc7df4d792fb90b2285ff69abd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -53,14 +53,6 @@ fn noname() -> *const c_char {\n     &CNULL\n }\n \n-bitflags! {\n-    pub struct MemFlags: u8 {\n-        const VOLATILE = 1 << 0;\n-        const NONTEMPORAL = 1 << 1;\n-        const UNALIGNED = 1 << 2;\n-    }\n-}\n-\n impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n     type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;"}, {"sha": "d5b398d8a339d6318f72847faafbd4f22e917a54", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -202,35 +202,3 @@ pub fn get_fn(\n \n     llfn\n }\n-\n-pub fn resolve_and_get_fn<'tcx, Cx: CodegenMethods<'tcx>>(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: &'tcx Substs<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}\n-\n-pub fn resolve_and_get_fn_for_vtable<'tcx,\n-    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n->(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: &'tcx Substs<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve_for_vtable(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}"}, {"sha": "2211ec5247f9795e1c3024bea3ea4ffe485775e5", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -405,88 +405,3 @@ pub fn struct_in_context(\n fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)\n }\n-\n-pub fn langcall(tcx: TyCtxt,\n-                span: Option<Span>,\n-                msg: &str,\n-                li: LangItem)\n-                -> DefId {\n-    tcx.lang_items().require(li).unwrap_or_else(|s| {\n-        let msg = format!(\"{} {}\", msg, s);\n-        match span {\n-            Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n-            None => tcx.sess.fatal(&msg[..]),\n-        }\n-    })\n-}\n-\n-// To avoid UB from LLVM, these two functions mask RHS with an\n-// appropriate mask unconditionally (i.e. the fallback behavior for\n-// all shifts). For 32- and 64-bit types, this matches the semantics\n-// of Java. (See related discussion on #1877 and #10183.)\n-\n-pub fn build_unchecked_lshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value\n-) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bx, rhs);\n-    bx.shl(lhs, rhs)\n-}\n-\n-pub fn build_unchecked_rshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    lhs_t: Ty<'tcx>,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value\n-) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bx, rhs);\n-    let is_signed = lhs_t.is_signed();\n-    if is_signed {\n-        bx.ashr(lhs, rhs)\n-    } else {\n-        bx.lshr(lhs, rhs)\n-    }\n-}\n-\n-fn shift_mask_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    rhs: Bx::Value\n-) -> Bx::Value {\n-    let rhs_llty = bx.cx().val_ty(rhs);\n-    bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n-}\n-\n-pub fn shift_mask_val<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n-    llty: Bx::Type,\n-    mask_llty: Bx::Type,\n-    invert: bool\n-) -> Bx::Value {\n-    let kind = bx.cx().type_kind(llty);\n-    match kind {\n-        TypeKind::Integer => {\n-            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n-            let val = bx.cx().int_width(llty) - 1;\n-            if invert {\n-                bx.cx().const_int(mask_llty, !val as i64)\n-            } else {\n-                bx.cx().const_uint(mask_llty, val)\n-            }\n-        },\n-        TypeKind::Vector => {\n-            let mask = shift_mask_val(\n-                bx,\n-                bx.cx().element_type(llty),\n-                bx.cx().element_type(mask_llty),\n-                invert\n-            );\n-            bx.vector_splat(bx.cx().vector_length(mask_llty), mask)\n-        },\n-        _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n-    }\n-}"}, {"sha": "8a5a817f57424d80d082ef387d39744b8d574eab", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -31,6 +31,58 @@ use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n+pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n+    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let dl = cx.data_layout();\n+    let pointer_size = dl.pointer_size.bytes() as usize;\n+\n+    let mut next_offset = 0;\n+    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n+        let offset = offset.bytes();\n+        assert_eq!(offset as usize as u64, offset);\n+        let offset = offset as usize;\n+        if offset > next_offset {\n+            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n+        }\n+        let ptr_offset = read_target_uint(\n+            dl.endian,\n+            &alloc.bytes[offset..(offset + pointer_size)],\n+        ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n+        llvals.push(cx.scalar_to_backend(\n+            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n+            &layout::Scalar {\n+                value: layout::Primitive::Pointer,\n+                valid_range: 0..=!0\n+            },\n+            cx.type_i8p()\n+        ));\n+        next_offset = offset + pointer_size;\n+    }\n+    if alloc.bytes.len() >= next_offset {\n+        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n+    }\n+\n+    cx.const_struct(&llvals, true)\n+}\n+\n+pub fn codegen_static_initializer(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    def_id: DefId,\n+) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n+    let instance = ty::Instance::mono(cx.tcx, def_id);\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None,\n+    };\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n+\n+    let alloc = match static_.val {\n+        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n+        _ => bug!(\"static const eval returned {:#?}\", static_),\n+    };\n+    Ok((const_alloc_to_llvm(cx, alloc), alloc))\n+}\n \n fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n                         gv: &'ll Value,"}, {"sha": "3eb9728e90c72801b96dc4a64064799498404ba6", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -10,6 +10,7 @@\n \n use attributes;\n use llvm;\n+use llvm_util;\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use debuginfo;\n@@ -445,6 +446,9 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         attributes::apply_target_cpu_attr(self, llfn)\n     }\n \n+    fn closure_env_needs_indirect_debuginfo(&self) {\n+        llvm_util::get_major_version() < 6\n+    }\n \n     fn create_used_variable(&self) {\n         let name = const_cstr!(\"llvm.used\");"}, {"sha": "8eb266f8069a812001f826a545a4468c71178145", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -26,21 +26,6 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use syntax_pos::BytePos;\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope<D> {\n-    pub scope_metadata: Option<D>,\n-    // Start and end offsets of the file to which this DIScope belongs.\n-    // These are used to quickly determine whether some span refers to the same file.\n-    pub file_start_pos: BytePos,\n-    pub file_end_pos: BytePos,\n-}\n-\n-impl<D> MirDebugScope<D> {\n-    pub fn is_valid(&self) -> bool {\n-        self.scope_metadata.is_some()\n-    }\n-}\n-\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes("}, {"sha": "ddd346e99d5fbc28f41e74b7485cbe97ee937b2d", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 16, "deletions": 55, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -111,54 +111,6 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext<D> {\n-    RegularContext(FunctionDebugContextData<D>),\n-    DebugInfoDisabled,\n-    FunctionWithoutDebugInfo,\n-}\n-\n-impl<D> FunctionDebugContext<D> {\n-    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<D> {\n-        match *self {\n-            FunctionDebugContext::RegularContext(ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(span, \"{}\", Self::debuginfo_disabled_message());\n-            }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(span, \"{}\", Self::should_be_ignored_message());\n-            }\n-        }\n-    }\n-\n-    fn debuginfo_disabled_message() -> &'static str {\n-        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n-    }\n-\n-    fn should_be_ignored_message() -> &'static str {\n-        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n-         ignored by debug info!\"\n-    }\n-}\n-\n-pub struct FunctionDebugContextData<D> {\n-    fn_metadata: D,\n-    source_locations_enabled: Cell<bool>,\n-    pub defining_crate: CrateNum,\n-}\n-\n-pub enum VariableAccess<'a, V> {\n-    // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: V },\n-    // The llptr given is an alloca containing the start of some pointer chain\n-    // leading to the variable's content.\n-    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n-}\n-\n-pub enum VariableKind {\n-    ArgumentVariable(usize /*index*/),\n-    LocalVariable,\n-}\n-\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: &CodegenCx) {\n     if cx.dbg_cx.is_none() {\n@@ -578,15 +530,24 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn extend_scope_to_file(\n-        &self,\n-        scope_metadata: &'ll DIScope,\n-        file: &syntax_pos::SourceFile,\n-        defining_crate: CrateNum,\n-    ) -> &'ll DILexicalBlock {\n-        metadata::extend_scope_to_file(&self, scope_metadata, file, defining_crate)\n-    }\n+         &self,\n+         scope_metadata: &'ll DIScope,\n+         file: &syntax_pos::SourceFile,\n+         defining_crate: CrateNum,\n+     ) -> &'ll DILexicalBlock {\n+         metadata::extend_scope_to_file(&self, scope_metadata, file, defining_crate)\n+     }\n \n     fn debuginfo_finalize(&self) {\n         finalize(self)\n     }\n+\n+    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> &[i64] {\n+        unsafe {\n+            [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+             llvm::LLVMRustDIBuilderCreateOpPlusUconst(),\n+             byte_offset_of_var_in_env as i64,\n+             llvm::LLVMRustDIBuilderCreateOpDeref()]\n+        };\n+    }\n }"}, {"sha": "a4fe912d1d79d5761dd4905545f881184ef02df4", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -50,18 +50,6 @@ pub fn set_source_location<D>(\n     set_debug_location(bx, dbg_loc);\n }\n \n-/// Enables emitting source locations for the given functions.\n-///\n-/// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to codegen a new function. This functions\n-/// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations<D>(dbg_context: &FunctionDebugContext<D>) {\n-    if let FunctionDebugContext::RegularContext(ref data) = *dbg_context {\n-        data.source_locations_enabled.set(true);\n-    }\n-}\n-\n \n #[derive(Copy, Clone, PartialEq)]\n pub enum InternalDebugLocation<'ll> {"}, {"sha": "94776f17c7989074aea7cf6b89a75776788d76dd", "filename": "src/librustc_codegen_llvm/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -47,37 +47,4 @@ unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n ```\n \"##,\n \n-E0668: r##\"\n-Malformed inline assembly rejected by LLVM.\n-\n-LLVM checks the validity of the constraints and the assembly string passed to\n-it. This error implies that LLVM seems something wrong with the inline\n-assembly call.\n-\n-In particular, it can happen if you forgot the closing bracket of a register\n-constraint (see issue #51430):\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(asm)]\n-\n-fn main() {\n-    let rax: u64;\n-    unsafe {\n-        asm!(\"\" :\"={rax\"(rax));\n-        println!(\"Accumulator is: {}\", rax);\n-    }\n-}\n-```\n-\"##,\n-\n-E0669: r##\"\n-Cannot convert inline assembly operand to a single LLVM value.\n-\n-This error usually happens when trying to pass in a value to an input inline\n-assembly operand that is actually a pair of values. In particular, this can\n-happen when trying to pass in a slice, for instance a `&str`. In Rust, these\n-values are represented internally as a pair of values, the pointer and its\n-length. When passed as an input operand, this pair of values can not be\n-coerced into a register and thus we must fail with an error.\n-\"##,\n-\n }"}, {"sha": "5fff056758589efaefa107600a3ef715b97861c9", "filename": "src/librustc_codegen_llvm/interfaces/mod.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/915382f7306be7841c4254cee13fa55a865bdd8b/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915382f7306be7841c4254cee13fa55a865bdd8b/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs?ref=915382f7306be7841c4254cee13fa55a865bdd8b", "patch": "@@ -1,72 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod abi;\n-mod asm;\n-mod builder;\n-mod consts;\n-mod debuginfo;\n-mod intrinsic;\n-mod type_;\n-\n-pub use self::abi::{AbiBuilderMethods, AbiMethods};\n-pub use self::asm::{AsmBuilderMethods, AsmMethods};\n-pub use self::builder::BuilderMethods;\n-pub use self::consts::ConstMethods;\n-pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n-pub use self::intrinsic::{IntrinsicCallMethods, IntrinsicDeclarationMethods};\n-pub use self::type_::{\n-    ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n-};\n-pub use rustc_codegen_ssa::interfaces::{\n-    Backend, BackendMethods, BackendTypes, CodegenObject, DeclareMethods, MiscMethods,\n-    PreDefineMethods, StaticMethods,\n-};\n-\n-pub trait CodegenMethods<'tcx>:\n-    Backend<'tcx>\n-    + TypeMethods<'tcx>\n-    + MiscMethods<'tcx>\n-    + ConstMethods<'tcx>\n-    + StaticMethods<'tcx>\n-    + DebugInfoMethods<'tcx>\n-    + AbiMethods<'tcx>\n-    + IntrinsicDeclarationMethods<'tcx>\n-    + DeclareMethods<'tcx>\n-    + AsmMethods<'tcx>\n-    + PreDefineMethods<'tcx>\n-{\n-}\n-\n-impl<'tcx, T> CodegenMethods<'tcx> for T where\n-    Self: Backend<'tcx>\n-        + TypeMethods<'tcx>\n-        + MiscMethods<'tcx>\n-        + ConstMethods<'tcx>\n-        + StaticMethods<'tcx>\n-        + DebugInfoMethods<'tcx>\n-        + AbiMethods<'tcx>\n-        + IntrinsicDeclarationMethods<'tcx>\n-        + DeclareMethods<'tcx>\n-        + AsmMethods<'tcx>\n-        + PreDefineMethods<'tcx>\n-{}\n-\n-pub trait HasCodegen<'tcx>: Backend<'tcx> {\n-    type CodegenCx: CodegenMethods<'tcx>\n-        + BackendTypes<\n-            Value = Self::Value,\n-            BasicBlock = Self::BasicBlock,\n-            Type = Self::Type,\n-            Context = Self::Context,\n-            Funclet = Self::Funclet,\n-            DIScope = Self::DIScope,\n-        >;\n-}"}, {"sha": "41796d24d9ecfbf24bfc1ad7e4fdb8e9d71bae4a", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -39,7 +39,6 @@\n use back::write::create_target_machine;\n use syntax_pos::symbol::Symbol;\n \n-#[macro_use] extern crate bitflags;\n extern crate flate2;\n extern crate libc;\n #[macro_use] extern crate rustc;\n@@ -92,7 +91,7 @@ use rustc::util::time_graph;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::util::profiling::ProfileCategory;\n use rustc_mir::monomorphize;\n-use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n+use rustc_codegen_ssa::{interfaces, ModuleCodegen, CompiledModule};\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::svh::Svh;\n \n@@ -108,8 +107,6 @@ mod back {\n     pub mod wasm;\n }\n \n-mod interfaces;\n-\n mod abi;\n mod allocator;\n mod asm;\n@@ -122,16 +119,13 @@ mod consts;\n mod context;\n mod debuginfo;\n mod declare;\n-mod glue;\n mod intrinsic;\n \n // The following is a work around that replaces `pub mod llvm;` and that fixes issue 53912.\n #[path = \"llvm/mod.rs\"] mod llvm_; pub mod llvm { pub use super::llvm_::*; }\n \n mod llvm_util;\n mod metadata;\n-mod meth;\n-mod mir;\n mod mono_item;\n mod type_;\n mod type_of;\n@@ -171,6 +165,12 @@ impl BackendMethods for LlvmCodegenBackend {\n     ) {\n         codegen.submit_pre_codegened_module_to_llvm(tcx, module)\n     }\n+    fn submit_pre_lto_module_to_llvm(&self, tcx: TyCtxt, module: CachedModuleCodegen) {\n+        write::submit_pre_lto_module_to_llvm(tcx, module)\n+    }\n+    fn submit_post_lto_module_to_llvm(&self, tcx: TyCtxt, module: CachedModuleCodegen) {\n+        write::submit_post_lto_module_to_llvm(tcx, module)\n+    }\n     fn codegen_aborted(codegen: OngoingCodegen) {\n         codegen.codegen_aborted();\n     }\n@@ -378,24 +378,4 @@ struct CodegenResults {\n     linker_info: rustc_codegen_utils::linker::LinkerInfo,\n     crate_info: CrateInfo,\n }\n-\n-/// Misc info we load from metadata to persist beyond the tcx\n-struct CrateInfo {\n-    panic_runtime: Option<CrateNum>,\n-    compiler_builtins: Option<CrateNum>,\n-    profiler_runtime: Option<CrateNum>,\n-    sanitizer_runtime: Option<CrateNum>,\n-    is_no_builtins: FxHashSet<CrateNum>,\n-    native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n-    crate_name: FxHashMap<CrateNum, String>,\n-    used_libraries: Lrc<Vec<NativeLibrary>>,\n-    link_args: Lrc<Vec<String>>,\n-    used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n-    used_crates_static: Vec<(CrateNum, LibSource)>,\n-    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n-    wasm_imports: FxHashMap<String, String>,\n-    lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n-    missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n-}\n-\n __build_diagnostic_array! { librustc_codegen_llvm, DIAGNOSTICS }"}, {"sha": "750e2ab07419203ed3ca3e70bf585a69567799af", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -8,12 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Walks the crate looking for items/impl-items/trait-items that have\n-//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n-//! generates an error giving, respectively, the symbol name or\n-//! item-path. This is used for unit testing the code that generates\n-//! paths etc in all kinds of annoying scenarios.\n-\n use attributes;\n use base;\n use context::CodegenCx;\n@@ -31,98 +25,6 @@ use interfaces::*;\n \n pub use rustc::mir::mono::MonoItem;\n \n-pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n-\n-pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n-    fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx) {\n-        debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n-               self.to_raw_string(),\n-               cx.codegen_unit().name());\n-\n-        match *self.as_mono_item() {\n-            MonoItem::Static(def_id) => {\n-                let tcx = cx.tcx();\n-                let is_mutable = match tcx.describe_def(def_id) {\n-                    Some(Def::Static(_, is_mutable)) => is_mutable,\n-                    Some(other) => {\n-                        bug!(\"Expected Def::Static, found {:?}\", other)\n-                    }\n-                    None => {\n-                        bug!(\"Expected Def::Static for {:?}, found nothing\", def_id)\n-                    }\n-                };\n-                cx.codegen_static(def_id, is_mutable);\n-            }\n-            MonoItem::GlobalAsm(node_id) => {\n-                let item = cx.tcx().hir.expect_item(node_id);\n-                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n-                    cx.codegen_global_asm(ga);\n-                } else {\n-                    span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n-                }\n-            }\n-            MonoItem::Fn(instance) => {\n-                base::codegen_instance::<Bx>(&cx, instance);\n-            }\n-        }\n-\n-        debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n-               self.to_raw_string(),\n-               cx.codegen_unit().name());\n-    }\n-\n-    fn predefine<Bx: BuilderMethods<'a, 'tcx>>(\n-        &self,\n-        cx: &'a Bx::CodegenCx,\n-        linkage: Linkage,\n-        visibility: Visibility\n-    ) {\n-        debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n-               self.to_raw_string(),\n-               cx.codegen_unit().name());\n-\n-        let symbol_name = self.symbol_name(cx.tcx()).as_str();\n-\n-        debug!(\"symbol {}\", &symbol_name);\n-\n-        match *self.as_mono_item() {\n-            MonoItem::Static(def_id) => {\n-                cx.predefine_static(def_id, linkage, visibility, &symbol_name);\n-            }\n-            MonoItem::Fn(instance) => {\n-                cx.predefine_fn(instance, linkage, visibility, &symbol_name);\n-            }\n-            MonoItem::GlobalAsm(..) => {}\n-        }\n-\n-        debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n-               self.to_raw_string(),\n-               cx.codegen_unit().name());\n-    }\n-\n-    fn to_raw_string(&self) -> String {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                        instance.def,\n-                        instance.substs.as_ptr() as usize)\n-            }\n-            MonoItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n-            }\n-            MonoItem::GlobalAsm(id) => {\n-                format!(\"GlobalAsm({:?})\", id)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n-\n impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn predefine_static(&self,\n                                   def_id: DefId,"}, {"sha": "d21542a50fb5354d2654919fd772402cf0499eb2", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -400,6 +400,12 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool {\n         layout.is_llvm_immediate()\n     }\n+    fn is_backend_scalar_pair(&self, ty: &TyLayout<'tcx>) -> bool {\n+        ty.is_llvm_scalar_pair()\n+    }\n+    fn backend_field_index(&self, ty: &TyLayout<'tcx>, index: usize) -> u64 {\n+        ty.llvm_field_index()\n+    }\n     fn scalar_pair_element_backend_type<'a>(\n         &self,\n         layout: TyLayout<'tcx>,"}, {"sha": "de85bb543972aa8f718a83131ecb254a83c212e4", "filename": "src/librustc_codegen_ssa/base.rs", "status": "added", "additions": 989, "deletions": 0, "changes": 989, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -0,0 +1,989 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Codegen the completed AST to the LLVM IR.\n+//!\n+//! Some functions here, such as codegen_block and codegen_expr, return a value --\n+//! the result of the codegen to LLVM -- while others, such as codegen_fn\n+//! and mono_item, are called only for the side effect of adding a\n+//! particular definition to the LLVM IR output we're producing.\n+//!\n+//! Hopefully useful general knowledge about codegen:\n+//!\n+//!   * There's no way to find out the Ty type of a Value.  Doing so\n+//!     would be \"trying to get the eggs out of an omelette\" (credit:\n+//!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n+//!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n+//!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n+\n+use {ModuleCodegen, ModuleKind, CachedModuleCodegen};\n+\n+use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::middle::lang_items::StartFnLangItem;\n+use rustc::middle::weak_lang_items;\n+use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::ty::query::Providers;\n+use rustc::middle::cstore::{self, LinkagePreference};\n+use rustc::util::common::{time, print_time_passes_entry};\n+use rustc::util::profiling::ProfileCategory;\n+use rustc::session::config::{self, EntryFnType, Lto};\n+use rustc::session::Session;\n+use mir::place::PlaceRef;\n+use {MemFlags, CrateInfo};\n+use callee;\n+use rustc_mir::monomorphize::item::DefPathBasedNames;\n+use common::{RealPredicate, TypeKind, IntPredicate};\n+use meth;\n+use mir;\n+use rustc::util::time_graph;\n+use rustc_mir::monomorphize::Instance;\n+use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n+use mono_item::MonoItem;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_codegen_utils::{symbol_names_test, check_for_rustc_errors_attr};\n+use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n+\n+use interfaces::*;\n+\n+use std::any::Any;\n+use std::cmp;\n+use std::ops::{Deref, DerefMut};\n+use std::time::{Instant, Duration};\n+use std::sync::mpsc;\n+use syntax_pos::Span;\n+use syntax::attr;\n+use rustc::hir;\n+\n+use mir::operand::OperandValue;\n+\n+use std::marker::PhantomData;\n+\n+pub struct StatRecorder<'a, 'tcx, Cx: 'a + CodegenMethods<'tcx>> {\n+    cx: &'a Cx,\n+    name: Option<String>,\n+    istart: usize,\n+    _marker: PhantomData<&'tcx ()>,\n+}\n+\n+impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> StatRecorder<'a, 'tcx, Cx> {\n+    pub fn new(cx: &'a Cx, name: String) -> Self {\n+        let istart = cx.stats().borrow().n_llvm_insns;\n+        StatRecorder {\n+            cx,\n+            name: Some(name),\n+            istart,\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> Drop for StatRecorder<'a, 'tcx, Cx> {\n+    fn drop(&mut self) {\n+        if self.cx.sess().codegen_stats() {\n+            let mut stats = self.cx.stats().borrow_mut();\n+            let iend = stats.n_llvm_insns;\n+            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n+            stats.n_fns += 1;\n+            // Reset LLVM insn count to avoid compound costs.\n+            stats.n_llvm_insns = self.istart;\n+        }\n+    }\n+}\n+\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n+                                signed: bool)\n+                                -> IntPredicate {\n+    match op {\n+        hir::BinOpKind::Eq => IntPredicate::IntEQ,\n+        hir::BinOpKind::Ne => IntPredicate::IntNE,\n+        hir::BinOpKind::Lt => if signed { IntPredicate::IntSLT } else { IntPredicate::IntULT },\n+        hir::BinOpKind::Le => if signed { IntPredicate::IntSLE } else { IntPredicate::IntULE },\n+        hir::BinOpKind::Gt => if signed { IntPredicate::IntSGT } else { IntPredicate::IntUGT },\n+        hir::BinOpKind::Ge => if signed { IntPredicate::IntSGE } else { IntPredicate::IntUGE },\n+        op => {\n+            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op)\n+        }\n+    }\n+}\n+\n+pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n+    match op {\n+        hir::BinOpKind::Eq => RealPredicate::RealOEQ,\n+        hir::BinOpKind::Ne => RealPredicate::RealUNE,\n+        hir::BinOpKind::Lt => RealPredicate::RealOLT,\n+        hir::BinOpKind::Le => RealPredicate::RealOLE,\n+        hir::BinOpKind::Gt => RealPredicate::RealOGT,\n+        hir::BinOpKind::Ge => RealPredicate::RealOGE,\n+        op => {\n+            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op);\n+        }\n+    }\n+}\n+\n+pub fn compare_simd_types<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value,\n+    t: Ty<'tcx>,\n+    ret_ty: Bx::Type,\n+    op: hir::BinOpKind\n+) -> Bx::Value {\n+    let signed = match t.sty {\n+        ty::Float(_) => {\n+            let cmp = bin_op_to_fcmp_predicate(op);\n+            return bx.sext(bx.fcmp(cmp, lhs, rhs), ret_ty);\n+        },\n+        ty::Uint(_) => false,\n+        ty::Int(_) => true,\n+        _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n+    };\n+\n+    let cmp = bin_op_to_icmp_predicate(op, signed);\n+    // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n+    // to get the correctly sized type. This will compile to a single instruction\n+    // once the IR is converted to assembly if the SIMD instruction is supported\n+    // by the target architecture.\n+    bx.sext(bx.icmp(cmp, lhs, rhs), ret_ty)\n+}\n+\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be derived\n+/// from the old one.\n+pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    source: Ty<'tcx>,\n+    target: Ty<'tcx>,\n+    old_info: Option<Cx::Value>,\n+) -> Cx::Value {\n+    let (source, target) = cx.tcx().struct_lockstep_tails(source, target);\n+    match (&source.sty, &target.sty) {\n+        (&ty::Array(_, len), &ty::Slice(_)) => {\n+            cx.const_usize(len.unwrap_usize(cx.tcx()))\n+        }\n+        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::Dynamic(ref data, ..)) => {\n+            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target))\n+                .field(cx, FAT_PTR_EXTRA);\n+            cx.static_ptrcast(meth::get_vtable(cx, source, data.principal()),\n+                            cx.backend_type(vtable_ptr))\n+        }\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                  source,\n+                  target),\n+    }\n+}\n+\n+/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    src: Bx::Value,\n+    src_ty: Ty<'tcx>,\n+    dst_ty: Ty<'tcx>\n+) -> (Bx::Value, Bx::Value) {\n+    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            assert!(bx.cx().type_is_sized(a));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n+            assert!(bx.cx().type_is_sized(a));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_layout = bx.cx().layout_of(src_ty);\n+            let dst_layout = bx.cx().layout_of(dst_ty);\n+            let mut result = None;\n+            for i in 0..src_layout.fields.count() {\n+                let src_f = src_layout.field(bx.cx(), i);\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                if src_f.is_zst() {\n+                    continue;\n+                }\n+                assert_eq!(src_layout.size, src_f.size);\n+\n+                let dst_f = dst_layout.field(bx.cx(), i);\n+                assert_ne!(src_f.ty, dst_f.ty);\n+                assert_eq!(result, None);\n+                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n+            }\n+            let (lldata, llextra) = result.unwrap();\n+            // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n+             bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n+        }\n+        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+    }\n+}\n+\n+/// Coerce `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty` and store the result in `dst`\n+pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    src: PlaceRef<'tcx, Bx::Value>,\n+    dst: PlaceRef<'tcx, Bx::Value>\n+)  {\n+    let src_ty = src.layout.ty;\n+    let dst_ty = dst.layout.ty;\n+    let coerce_ptr = || {\n+        let (base, info) = match bx.load_operand(src).val {\n+            OperandValue::Pair(base, info) => {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n+                // So we need to pointercast the base to ensure\n+                // the types match up.\n+                let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n+                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n+            }\n+            OperandValue::Immediate(base) => {\n+                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n+            }\n+            OperandValue::Ref(..) => bug!()\n+        };\n+        OperandValue::Pair(base, info).store(bx, dst);\n+    };\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::Ref(..), &ty::Ref(..)) |\n+        (&ty::Ref(..), &ty::RawPtr(..)) |\n+        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n+            coerce_ptr()\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            coerce_ptr()\n+        }\n+\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n+                let src_f = src.project_field(bx, i);\n+                let dst_f = dst.project_field(bx, i);\n+\n+                if dst_f.layout.is_zst() {\n+                    continue;\n+                }\n+\n+                if src_f.layout.ty == dst_f.layout.ty {\n+                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n+                              src_f.layout, MemFlags::empty());\n+                } else {\n+                    coerce_unsized_into(bx, src_f, dst_f);\n+                }\n+            }\n+        }\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                  src_ty,\n+                  dst_ty),\n+    }\n+}\n+\n+pub fn cast_shift_expr_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    op: hir::BinOpKind,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    cast_shift_rhs(bx, op, lhs, rhs, |a, b| bx.trunc(a, b), |a, b| bx.zext(a, b))\n+}\n+\n+fn cast_shift_rhs<'a, 'tcx: 'a, F, G, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    op: hir::BinOpKind,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value,\n+    trunc: F,\n+    zext: G\n+) -> Bx::Value\n+    where F: FnOnce(\n+        Bx::Value,\n+        Bx::Type\n+    ) -> Bx::Value,\n+    G: FnOnce(\n+        Bx::Value,\n+        Bx::Type\n+    ) -> Bx::Value\n+{\n+    // Shifts may have any size int on the rhs\n+    if op.is_shift() {\n+        let mut rhs_llty = bx.cx().val_ty(rhs);\n+        let mut lhs_llty = bx.cx().val_ty(lhs);\n+        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n+            rhs_llty = bx.cx().element_type(rhs_llty)\n+        }\n+        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n+            lhs_llty = bx.cx().element_type(lhs_llty)\n+        }\n+        let rhs_sz = bx.cx().int_width(rhs_llty);\n+        let lhs_sz = bx.cx().int_width(lhs_llty);\n+        if lhs_sz < rhs_sz {\n+            trunc(rhs, lhs_llty)\n+        } else if lhs_sz > rhs_sz {\n+            // FIXME (#1877: If in the future shifting by negative\n+            // values is no longer undefined then this is wrong.\n+            zext(rhs, lhs_llty)\n+        } else {\n+            rhs\n+        }\n+    } else {\n+        rhs\n+    }\n+}\n+\n+/// Returns whether this session's target will use SEH-based unwinding.\n+///\n+/// This is only true for MSVC targets, and even then the 64-bit MSVC target\n+/// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n+/// 64-bit MinGW) instead of \"full SEH\".\n+pub fn wants_msvc_seh(sess: &Session) -> bool {\n+    sess.target.target.options.is_like_msvc\n+}\n+\n+pub fn call_assume<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value\n+) {\n+    let assume_intrinsic = bx.cx().get_intrinsic(\"llvm.assume\");\n+    bx.call(assume_intrinsic, &[val], None);\n+}\n+\n+pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value\n+) -> Bx::Value {\n+    if bx.cx().val_ty(val) == bx.cx().type_i1() {\n+        bx.zext(val, bx.cx().type_i8())\n+    } else {\n+        val\n+    }\n+}\n+\n+pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value,\n+    layout: layout::TyLayout,\n+) -> Bx::Value {\n+    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n+        return to_immediate_scalar(bx, val, scalar);\n+    }\n+    val\n+}\n+\n+pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value,\n+    scalar: &layout::Scalar,\n+) -> Bx::Value {\n+    if scalar.is_bool() {\n+        return bx.trunc(val, bx.cx().type_i1());\n+    }\n+    val\n+}\n+\n+pub fn memcpy_ty<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    dst: Bx::Value,\n+    dst_align: Align,\n+    src: Bx::Value,\n+    src_align: Align,\n+    layout: TyLayout<'tcx>,\n+    flags: MemFlags,\n+) {\n+    let size = layout.size.bytes();\n+    if size == 0 {\n+        return;\n+    }\n+\n+    bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n+}\n+\n+pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+    instance: Instance<'tcx>,\n+) {\n+    let _s = if cx.sess().codegen_stats() {\n+        let mut instance_name = String::new();\n+        DefPathBasedNames::new(cx.tcx(), true, true)\n+            .push_def_path(instance.def_id(), &mut instance_name);\n+        Some(StatRecorder::new(cx, instance_name))\n+    } else {\n+        None\n+    };\n+\n+    // this is an info! to allow collecting monomorphization statistics\n+    // and to allow finding the last function before LLVM aborts from\n+    // release builds.\n+    info!(\"codegen_instance({})\", instance);\n+\n+    let sig = instance.fn_sig(cx.tcx());\n+    let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+\n+    let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n+        bug!(\"Instance `{:?}` not already declared\", instance));\n+\n+    cx.stats().borrow_mut().n_closures += 1;\n+\n+    let mir = cx.tcx().instance_mir(instance.def);\n+    mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n+}\n+\n+/// Create the `main` function which will initialize the rust runtime and call\n+/// users main function.\n+fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx\n+) {\n+    let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n+        Some((id, span, _)) => {\n+            (cx.tcx().hir.local_def_id(id), span)\n+        }\n+        None => return,\n+    };\n+\n+    let instance = Instance::mono(cx.tcx(), main_def_id);\n+\n+    if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n+        // We want to create the wrapper in the same codegen unit as Rust's main\n+        // function.\n+        return;\n+    }\n+\n+    let main_llfn = cx.get_fn(instance);\n+\n+    let et = cx.sess().entry_fn.get().map(|e| e.2);\n+    match et {\n+        Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n+        Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n+        None => {}    // Do nothing.\n+    }\n+\n+    fn create_entry_fn<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+        cx: &'a Bx::CodegenCx,\n+        sp: Span,\n+        rust_main: Bx::Value,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+    ) {\n+        let llfty =\n+            cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int());\n+\n+        let main_ret_ty = cx.tcx().fn_sig(rust_main_def_id).output();\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = cx.tcx().erase_regions(\n+            &main_ret_ty.no_bound_vars().unwrap(),\n+        );\n+\n+        if cx.get_defined_value(\"main\").is_some() {\n+            // FIXME: We should be smart and show a better diagnostic here.\n+            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n+                     .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n+                     .emit();\n+            cx.sess().abort_if_errors();\n+            bug!();\n+        }\n+        let llfn = cx.declare_cfn(\"main\", llfty);\n+\n+        // `main` should respect same config for frame pointer elimination as rest of code\n+        cx.set_frame_pointer_elimination(llfn);\n+        cx.apply_target_cpu_attr(llfn);\n+\n+        let bx = Bx::new_block(&cx, llfn, \"top\");\n+\n+        bx.insert_reference_to_gdb_debug_scripts_section_global();\n+\n+        // Params from native main() used as args for rust start function\n+        let param_argc = cx.get_param(llfn, 0);\n+        let param_argv = cx.get_param(llfn, 1);\n+        let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n+        let arg_argv = param_argv;\n+\n+        let (start_fn, args) = if use_start_lang_item {\n+            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem);\n+            let start_fn = callee::resolve_and_get_fn(\n+                cx,\n+                start_def_id,\n+                cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+            );\n+            (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n+                            arg_argc, arg_argv])\n+        } else {\n+            debug!(\"using user-defined start fn\");\n+            (rust_main, vec![arg_argc, arg_argv])\n+        };\n+\n+        let result = bx.call(start_fn, &args, None);\n+        bx.ret(bx.intcast(result, cx.type_int(), true));\n+    }\n+}\n+\n+pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n+pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n+    time_graph::TimelineId(CODEGEN_WORKER_ID);\n+pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n+\n+\n+pub fn codegen_crate<B: BackendMethods>(\n+    backend: B,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    rx: mpsc::Receiver<Box<dyn Any + Send>>\n+) -> B::OngoingCodegen {\n+\n+    check_for_rustc_errors_attr(tcx);\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+\n+    // Codegen the metadata.\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n+\n+    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                            &[\"crate\"],\n+                                                            Some(\"metadata\")).as_str()\n+                                                                             .to_string();\n+    let metadata_llvm_module = backend.new_metadata(tcx.sess, &metadata_cgu_name);\n+    let metadata = time(tcx.sess, \"write metadata\", || {\n+        backend.write_metadata(tcx, &metadata_llvm_module)\n+    });\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n+\n+    let metadata_module = ModuleCodegen {\n+        name: metadata_cgu_name,\n+        module_llvm: metadata_llvm_module,\n+        kind: ModuleKind::Metadata,\n+    };\n+\n+    let time_graph = if tcx.sess.opts.debugging_opts.codegen_time_graph {\n+        Some(time_graph::TimeGraph::new())\n+    } else {\n+        None\n+    };\n+\n+    // Skip crate items and just output metadata in -Z no-codegen mode.\n+    if tcx.sess.opts.debugging_opts.no_codegen ||\n+       !tcx.sess.opts.output_types.should_codegen() {\n+        let ongoing_codegen = backend.start_async_codegen(\n+            tcx,\n+            time_graph,\n+            metadata,\n+            rx,\n+            1);\n+\n+        backend.submit_pre_codegened_module_to_backend(&ongoing_codegen, tcx, metadata_module);\n+        backend.codegen_finished(&ongoing_codegen, tcx);\n+\n+        assert_and_save_dep_graph(tcx);\n+\n+        backend.check_for_errors(&ongoing_codegen, tcx.sess);\n+\n+        return ongoing_codegen;\n+    }\n+\n+    // Run the monomorphization collector and partition the collected items into\n+    // codegen units.\n+    let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n+    let codegen_units = (*codegen_units).clone();\n+\n+    // Force all codegen_unit queries so they are already either red or green\n+    // when compile_codegen_unit accesses them. We are not able to re-execute\n+    // the codegen_unit query from just the DepNode, so an unknown color would\n+    // lead to having to re-execute compile_codegen_unit, possibly\n+    // unnecessarily.\n+    if tcx.dep_graph.is_fully_enabled() {\n+        for cgu in &codegen_units {\n+            tcx.codegen_unit(cgu.name().clone());\n+        }\n+    }\n+\n+    let ongoing_codegen = backend.start_async_codegen(\n+        tcx,\n+        time_graph.clone(),\n+        metadata,\n+        rx,\n+        codegen_units.len());\n+    let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n+\n+    // Codegen an allocator shim, if necessary.\n+    //\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+        .iter()\n+        .any(|(_, list)| {\n+            use rustc::middle::dependency_format::Linkage;\n+            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+        });\n+    let allocator_module = if any_dynamic_crate {\n+        None\n+    } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n+        let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                       &[\"crate\"],\n+                                                       Some(\"allocator\")).as_str()\n+                                                                         .to_string();\n+        let modules = backend.new_metadata(tcx.sess, &llmod_id);\n+        time(tcx.sess, \"write allocator module\", || {\n+            backend.codegen_allocator(tcx, &modules, kind)\n+        });\n+\n+        Some(ModuleCodegen {\n+            name: llmod_id,\n+            module_llvm: modules,\n+            kind: ModuleKind::Allocator,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    if let Some(allocator_module) = allocator_module {\n+        backend.submit_pre_codegened_module_to_backend(&ongoing_codegen, tcx, allocator_module);\n+    }\n+\n+    backend.submit_pre_codegened_module_to_backend(&ongoing_codegen, tcx, metadata_module);\n+\n+    // We sort the codegen units by size. This way we can schedule work for LLVM\n+    // a bit more efficiently.\n+    let codegen_units = {\n+        let mut codegen_units = codegen_units;\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        codegen_units\n+    };\n+\n+    let mut total_codegen_time = Duration::new(0, 0);\n+    let mut all_stats = Stats::default();\n+\n+    for cgu in codegen_units.into_iter() {\n+        backend.wait_for_signal_to_codegen_item(&ongoing_codegen);\n+        backend.check_for_errors(&ongoing_codegen, tcx.sess);\n+\n+        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n+        tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+        match cgu_reuse {\n+            CguReuse::No => {\n+                let _timing_guard = time_graph.as_ref().map(|time_graph| {\n+                    time_graph.start(CODEGEN_WORKER_TIMELINE,\n+                                     CODEGEN_WORK_PACKAGE_KIND,\n+                                     &format!(\"codegen {}\", cgu.name()))\n+                });\n+                let start_time = Instant::now();\n+                let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n+                all_stats.extend(stats);\n+                total_codegen_time += start_time.elapsed();\n+                false\n+            }\n+            CguReuse::PreLto => {\n+                backend.submit_pre_lto_module_to_backend(tcx, CachedModuleCodegen {\n+                    name: cgu.name().to_string(),\n+                    source: cgu.work_product(tcx),\n+                });\n+                true\n+            }\n+            CguReuse::PostLto => {\n+                backend.submit_post_lto_module_to_backend(tcx, CachedModuleCodegen {\n+                    name: cgu.name().to_string(),\n+                    source: cgu.work_product(tcx),\n+                });\n+                true\n+            }\n+        };\n+    }\n+\n+    backend.codegen_finished(&ongoing_codegen, tcx);\n+\n+    // Since the main thread is sometimes blocked during codegen, we keep track\n+    // -Ztime-passes output manually.\n+    print_time_passes_entry(tcx.sess.time_passes(),\n+                            \"codegen to LLVM IR\",\n+                            total_codegen_time);\n+\n+    ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+\n+    symbol_names_test::report_symbol_names(tcx);\n+\n+    if tcx.sess.codegen_stats() {\n+        println!(\"--- codegen stats ---\");\n+        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n+        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n+        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n+\n+        println!(\"n_fns: {}\", all_stats.n_fns);\n+        println!(\"n_inlines: {}\", all_stats.n_inlines);\n+        println!(\"n_closures: {}\", all_stats.n_closures);\n+        println!(\"fn stats:\");\n+        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n+        for &(ref name, insns) in all_stats.fn_stats.iter() {\n+            println!(\"{} insns, {}\", insns, *name);\n+        }\n+    }\n+\n+    if tcx.sess.count_llvm_insns() {\n+        for (k, v) in all_stats.llvm_insns.iter() {\n+            println!(\"{:7} {}\", *v, *k);\n+        }\n+    }\n+\n+    backend.check_for_errors(&ongoing_codegen, tcx.sess);\n+\n+    assert_and_save_dep_graph(tcx);\n+    ongoing_codegen.into_inner()\n+}\n+\n+/// A curious wrapper structure whose only purpose is to call `codegen_aborted`\n+/// when it's dropped abnormally.\n+///\n+/// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n+/// stumbled upon. The segfault was never reproduced locally, but it was\n+/// suspected to be related to the fact that codegen worker threads were\n+/// sticking around by the time the main thread was exiting, causing issues.\n+///\n+/// This structure is an attempt to fix that issue where the `codegen_aborted`\n+/// message will block until all workers have finished. This should ensure that\n+/// even if the main codegen thread panics we'll wait for pending work to\n+/// complete before returning from the main thread, hopefully avoiding\n+/// segfaults.\n+///\n+/// If you see this comment in the code, then it means that this workaround\n+/// worked! We may yet one day track down the mysterious cause of that\n+/// segfault...\n+struct AbortCodegenOnDrop<B: BackendMethods>(Option<B::OngoingCodegen>);\n+\n+impl<B: BackendMethods> AbortCodegenOnDrop<B> {\n+    fn into_inner(mut self) -> B::OngoingCodegen {\n+        self.0.take().unwrap()\n+    }\n+}\n+\n+impl<B: BackendMethods> Deref for AbortCodegenOnDrop<B> {\n+    type Target = B::OngoingCodegen;\n+\n+    fn deref(&self) -> &B::OngoingCodegen {\n+        self.0.as_ref().unwrap()\n+    }\n+}\n+\n+impl<B: BackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n+    fn deref_mut(&mut self) -> &mut B::OngoingCodegen {\n+        self.0.as_mut().unwrap()\n+    }\n+}\n+\n+impl<B: BackendMethods> Drop for AbortCodegenOnDrop<B> {\n+    fn drop(&mut self) {\n+        if let Some(codegen) = self.0.take() {\n+            B::codegen_aborted(codegen);\n+        }\n+    }\n+}\n+\n+fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n+    time(tcx.sess,\n+         \"assert dep graph\",\n+         || ::rustc_incremental::assert_dep_graph(tcx));\n+\n+    time(tcx.sess,\n+         \"serialize dep graph\",\n+         || ::rustc_incremental::save_dep_graph(tcx));\n+}\n+\n+impl CrateInfo {\n+    pub fn new(tcx: TyCtxt) -> CrateInfo {\n+        let mut info = CrateInfo {\n+            panic_runtime: None,\n+            compiler_builtins: None,\n+            profiler_runtime: None,\n+            sanitizer_runtime: None,\n+            is_no_builtins: Default::default(),\n+            native_libraries: Default::default(),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            link_args: tcx.link_args(LOCAL_CRATE),\n+            crate_name: Default::default(),\n+            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n+            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n+            used_crate_source: Default::default(),\n+            wasm_imports: Default::default(),\n+            lang_item_to_crate: Default::default(),\n+            missing_lang_items: Default::default(),\n+        };\n+        let lang_items = tcx.lang_items();\n+\n+        let load_wasm_items = tcx.sess.crate_types.borrow()\n+            .iter()\n+            .any(|c| *c != config::CrateType::Rlib) &&\n+            tcx.sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\";\n+\n+        if load_wasm_items {\n+            info.load_wasm_imports(tcx, LOCAL_CRATE);\n+        }\n+\n+        let crates = tcx.crates();\n+\n+        let n_crates = crates.len();\n+        info.native_libraries.reserve(n_crates);\n+        info.crate_name.reserve(n_crates);\n+        info.used_crate_source.reserve(n_crates);\n+        info.missing_lang_items.reserve(n_crates);\n+\n+        for &cnum in crates.iter() {\n+            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n+            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n+            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n+            if tcx.is_panic_runtime(cnum) {\n+                info.panic_runtime = Some(cnum);\n+            }\n+            if tcx.is_compiler_builtins(cnum) {\n+                info.compiler_builtins = Some(cnum);\n+            }\n+            if tcx.is_profiler_runtime(cnum) {\n+                info.profiler_runtime = Some(cnum);\n+            }\n+            if tcx.is_sanitizer_runtime(cnum) {\n+                info.sanitizer_runtime = Some(cnum);\n+            }\n+            if tcx.is_no_builtins(cnum) {\n+                info.is_no_builtins.insert(cnum);\n+            }\n+            if load_wasm_items {\n+                info.load_wasm_imports(tcx, cnum);\n+            }\n+            let missing = tcx.missing_lang_items(cnum);\n+            for &item in missing.iter() {\n+                if let Ok(id) = lang_items.require(item) {\n+                    info.lang_item_to_crate.insert(item, id.krate);\n+                }\n+            }\n+\n+            // No need to look for lang items that are whitelisted and don't\n+            // actually need to exist.\n+            let missing = missing.iter()\n+                .cloned()\n+                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n+                .collect();\n+            info.missing_lang_items.insert(cnum, missing);\n+        }\n+\n+        return info\n+    }\n+\n+    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n+        self.wasm_imports.extend(tcx.wasm_import_module_map(cnum).iter().map(|(&id, module)| {\n+            let instance = Instance::mono(tcx, id);\n+            let import_name = tcx.symbol_name(instance);\n+\n+            (import_name.to_string(), module.clone())\n+        }));\n+    }\n+}\n+\n+fn is_codegened_item(tcx: TyCtxt, id: DefId) -> bool {\n+    let (all_mono_items, _) =\n+        tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+    all_mono_items.contains(&id)\n+}\n+\n+pub fn provide_both(providers: &mut Providers) {\n+    providers.dllimport_foreign_items = |tcx, krate| {\n+        let module_map = tcx.foreign_modules(krate);\n+        let module_map = module_map.iter()\n+            .map(|lib| (lib.def_id, lib))\n+            .collect::<FxHashMap<_, _>>();\n+\n+        let dllimports = tcx.native_libraries(krate)\n+            .iter()\n+            .filter(|lib| {\n+                if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n+                    return false\n+                }\n+                let cfg = match lib.cfg {\n+                    Some(ref cfg) => cfg,\n+                    None => return true,\n+                };\n+                attr::cfg_matches(cfg, &tcx.sess.parse_sess, None)\n+            })\n+            .filter_map(|lib| lib.foreign_module)\n+            .map(|id| &module_map[&id])\n+            .flat_map(|module| module.foreign_items.iter().cloned())\n+            .collect();\n+        Lrc::new(dllimports)\n+    };\n+\n+    providers.is_dllimport_foreign_item = |tcx, def_id| {\n+        tcx.dllimport_foreign_items(def_id.krate).contains(&def_id)\n+    };\n+}\n+\n+fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 cgu: &CodegenUnit<'tcx>)\n+                                 -> CguReuse {\n+    if !tcx.dep_graph.is_fully_enabled() {\n+        return CguReuse::No\n+    }\n+\n+    let work_product_id = &cgu.work_product_id();\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n+        // We don't have anything cached for this CGU. This can happen\n+        // if the CGU did not exist in the previous session.\n+        return CguReuse::No\n+    }\n+\n+    // Try to mark the CGU as green. If it we can do so, it means that nothing\n+    // affecting the LLVM module has changed and we can re-use a cached version.\n+    // If we compile with any kind of LTO, this means we can re-use the bitcode\n+    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n+    // know that later). If we are not doing LTO, there is only one optimized\n+    // version of each module, so we re-use that.\n+    let dep_node = cgu.codegen_dep_node(tcx);\n+    assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n+        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n+        cgu.name());\n+\n+    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+        // We can re-use either the pre- or the post-thinlto state\n+        if tcx.sess.lto() != Lto::No {\n+            CguReuse::PreLto\n+        } else {\n+            CguReuse::PostLto\n+        }\n+    } else {\n+        CguReuse::No\n+    }\n+}"}, {"sha": "3d8f96573dbeb2fe3e5bac76784c2da2a9a6b43a", "filename": "src/librustc_codegen_ssa/callee.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcallee.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use interfaces::*;\n+use rustc::ty;\n+use rustc::ty::subst::Substs;\n+use rustc::hir::def_id::DefId;\n+\n+pub fn resolve_and_get_fn<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> Cx::Value {\n+    cx.get_fn(\n+        ty::Instance::resolve(\n+            cx.tcx(),\n+            ty::ParamEnv::reveal_all(),\n+            def_id,\n+            substs\n+        ).unwrap()\n+    )\n+}\n+\n+pub fn resolve_and_get_fn_for_vtable<'tcx,\n+    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n+>(\n+    cx: &Cx,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> Cx::Value {\n+    cx.get_fn(\n+        ty::Instance::resolve_for_vtable(\n+            cx.tcx(),\n+            ty::ParamEnv::reveal_all(),\n+            def_id,\n+            substs\n+        ).unwrap()\n+    )\n+}"}, {"sha": "619fd078fb75f928eb66a7f0e39304b199d8117d", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -10,8 +10,15 @@\n #![allow(non_camel_case_types, non_snake_case)]\n \n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax_pos::DUMMY_SP;\n+use syntax_pos::{DUMMY_SP, Span};\n \n+use rustc::hir::def_id::DefId;\n+use rustc::middle::lang_items::LangItem;\n+use base;\n+use interfaces::*;\n+\n+use rustc::hir;\n+use interfaces::BuilderMethods;\n \n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n@@ -135,3 +142,88 @@ mod temp_stable_hash_impls {\n         }\n     }\n }\n+\n+pub fn langcall(tcx: TyCtxt,\n+                span: Option<Span>,\n+                msg: &str,\n+                li: LangItem)\n+                -> DefId {\n+    tcx.lang_items().require(li).unwrap_or_else(|s| {\n+        let msg = format!(\"{} {}\", msg, s);\n+        match span {\n+            Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n+            None => tcx.sess.fatal(&msg[..]),\n+        }\n+    })\n+}\n+\n+// To avoid UB from LLVM, these two functions mask RHS with an\n+// appropriate mask unconditionally (i.e. the fallback behavior for\n+// all shifts). For 32- and 64-bit types, this matches the semantics\n+// of Java. (See related discussion on #1877 and #10183.)\n+\n+pub fn build_unchecked_lshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bx, rhs);\n+    bx.shl(lhs, rhs)\n+}\n+\n+pub fn build_unchecked_rshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    lhs_t: Ty<'tcx>,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bx, rhs);\n+    let is_signed = lhs_t.is_signed();\n+    if is_signed {\n+        bx.ashr(lhs, rhs)\n+    } else {\n+        bx.lshr(lhs, rhs)\n+    }\n+}\n+\n+fn shift_mask_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    let rhs_llty = bx.cx().val_ty(rhs);\n+    bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n+}\n+\n+pub fn shift_mask_val<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    llty: Bx::Type,\n+    mask_llty: Bx::Type,\n+    invert: bool\n+) -> Bx::Value {\n+    let kind = bx.cx().type_kind(llty);\n+    match kind {\n+        TypeKind::Integer => {\n+            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+            let val = bx.cx().int_width(llty) - 1;\n+            if invert {\n+                bx.cx().const_int(mask_llty, !val as i64)\n+            } else {\n+                bx.cx().const_uint(mask_llty, val)\n+            }\n+        },\n+        TypeKind::Vector => {\n+            let mask = shift_mask_val(\n+                bx,\n+                bx.cx().element_type(llty),\n+                bx.cx().element_type(mask_llty),\n+                invert\n+            );\n+            bx.vector_splat(bx.cx().vector_length(mask_llty), mask)\n+        },\n+        _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+    }\n+}"}, {"sha": "2891b1c22fe3bcf756c5717a4c5ca1be5741d43d", "filename": "src/librustc_codegen_ssa/debuginfo.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::{BytePos, Span};\n+use rustc::hir::def_id::CrateNum;\n+use std::cell::Cell;\n+\n+pub enum FunctionDebugContext<D> {\n+    RegularContext(FunctionDebugContextData<D>),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n+}\n+\n+impl<D> FunctionDebugContext<D> {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<D> {\n+        match *self {\n+            FunctionDebugContext::RegularContext(ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n+                span_bug!(span, \"{}\", FunctionDebugContext::<D>::debuginfo_disabled_message());\n+            }\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                span_bug!(span, \"{}\", FunctionDebugContext::<D>::should_be_ignored_message());\n+            }\n+        }\n+    }\n+\n+    fn debuginfo_disabled_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n+    }\n+\n+    fn should_be_ignored_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n+         ignored by debug info!\"\n+    }\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to codegen a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is codegened.\n+pub fn start_emitting_source_locations<D>(dbg_context: &FunctionDebugContext<D>) {\n+    match *dbg_context {\n+        FunctionDebugContext::RegularContext(ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+pub struct FunctionDebugContextData<D> {\n+    fn_metadata: D,\n+    source_locations_enabled: Cell<bool>,\n+    pub defining_crate: CrateNum,\n+}\n+\n+pub enum VariableAccess<'a, V> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: V },\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n+    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n+}\n+\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+}\n+\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct MirDebugScope<D> {\n+    pub scope_metadata: Option<D>,\n+    // Start and end offsets of the file to which this DIScope belongs.\n+    // These are used to quickly determine whether some span refers to the same file.\n+    pub file_start_pos: BytePos,\n+    pub file_end_pos: BytePos,\n+}\n+\n+impl<D> MirDebugScope<D> {\n+    pub fn is_valid(&self) -> bool {\n+        !self.scope_metadata.is_none()\n+    }\n+}"}, {"sha": "abe19068889c1008153b090b2a982e1af6d74943", "filename": "src/librustc_codegen_ssa/diagnostics.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdiagnostics.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+E0668: r##\"\n+Malformed inline assembly rejected by LLVM.\n+\n+LLVM checks the validity of the constraints and the assembly string passed to\n+it. This error implies that LLVM seems something wrong with the inline\n+assembly call.\n+\n+In particular, it can happen if you forgot the closing bracket of a register\n+constraint (see issue #51430):\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(asm)]\n+\n+fn main() {\n+    let rax: u64;\n+    unsafe {\n+        asm!(\"\" :\"={rax\"(rax));\n+        println!(\"Accumulator is: {}\", rax);\n+    }\n+}\n+```\n+\"##,\n+\n+E0669: r##\"\n+Cannot convert inline assembly operand to a single LLVM value.\n+\n+This error usually happens when trying to pass in a value to an input inline\n+assembly operand that is actually a pair of values. In particular, this can\n+happen when trying to pass in a slice, for instance a `&str`. In Rust, these\n+values are represented internally as a pair of values, the pointer and its\n+length. When passed as an input operand, this pair of values can not be\n+coerced into a register and thus we must fail with an error.\n+\"##,\n+\n+}"}, {"sha": "cfb2ceb5a1a365837ee39d0b13bfdbb2ea74913c", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -14,7 +14,7 @@\n \n use std;\n \n-use rustc_codegen_ssa::common::IntPredicate;\n+use common::IntPredicate;\n use meth;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};", "previous_filename": "src/librustc_codegen_llvm/glue.rs"}, {"sha": "eda6d92dabe387bd5d597c8f7c88c189433799b6", "filename": "src/librustc_codegen_ssa/interfaces/abi.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fabi.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use super::HasCodegen;\n-use abi::FnType;\n use rustc::ty::{FnSig, Instance, Ty};\n+use rustc_target::abi::call::FnType;\n \n pub trait AbiMethods<'tcx> {\n     fn new_fn_type(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;", "previous_filename": "src/librustc_codegen_llvm/interfaces/abi.rs"}, {"sha": "ffe9679fcd6cbc8c358fc4bf43ece9ac4b726120", "filename": "src/librustc_codegen_ssa/interfaces/asm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fasm.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "previous_filename": "src/librustc_codegen_llvm/interfaces/asm.rs"}, {"sha": "6cc7d66a2078b5fd2d3ba06ac2f58b10bc91f5e1", "filename": "src/librustc_codegen_ssa/interfaces/backend.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -21,7 +21,7 @@ use rustc::util::time_graph::TimeGraph;\n use std::any::Any;\n use std::sync::mpsc::Receiver;\n use syntax_pos::symbol::InternedString;\n-use ModuleCodegen;\n+use {CachedModuleCodegen, ModuleCodegen};\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n@@ -62,12 +62,14 @@ pub trait BackendMethods {\n         coordinator_receive: Receiver<Box<dyn Any + Send>>,\n         total_cgus: usize,\n     ) -> Self::OngoingCodegen;\n-    fn submit_pre_codegened_module_to_llvm(\n+    fn submit_pre_codegened_module_to_backend(\n         &self,\n         codegen: &Self::OngoingCodegen,\n         tcx: TyCtxt,\n         module: ModuleCodegen<Self::Module>,\n     );\n+    fn submit_pre_lto_module_to_backend(&self, tcx: TyCtxt, module: CachedModuleCodegen);\n+    fn submit_post_lto_module_to_backend(&self, tcx: TyCtxt, module: CachedModuleCodegen);\n     fn codegen_aborted(codegen: Self::OngoingCodegen);\n     fn codegen_finished(&self, codegen: &Self::OngoingCodegen, tcx: TyCtxt);\n     fn check_for_errors(&self, codegen: &Self::OngoingCodegen, sess: &Session);"}, {"sha": "953152534d30ffe5f1e103af51cce6ae25257fbc", "filename": "src/librustc_codegen_ssa/interfaces/builder.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbuilder.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -14,14 +14,12 @@ use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgTypeMethods;\n use super::HasCodegen;\n-use builder::MemFlags;\n+use common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n use libc::c_char;\n use mir::operand::OperandRef;\n use mir::place::PlaceRef;\n use rustc::ty::layout::{Align, Size};\n-use rustc_codegen_ssa::common::{\n-    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope,\n-};\n+use MemFlags;\n \n use std::borrow::Cow;\n use std::ops::Range;", "previous_filename": "src/librustc_codegen_llvm/interfaces/builder.rs"}, {"sha": "c0a5445219565cb86e7fab49ec48be0ae175a41d", "filename": "src/librustc_codegen_ssa/interfaces/consts.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fconsts.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "previous_filename": "src/librustc_codegen_llvm/interfaces/consts.rs"}, {"sha": "784d69e93bfc80506ff9a97d3c9e7be7bfe337be", "filename": "src/librustc_codegen_ssa/interfaces/debuginfo.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fdebuginfo.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -11,11 +11,11 @@\n use super::Backend;\n use super::HasCodegen;\n use debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess, VariableKind};\n-use monomorphize::Instance;\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_mir::monomorphize::Instance;\n use syntax::ast::Name;\n use syntax_pos::{SourceFile, Span};\n \n@@ -48,6 +48,7 @@ pub trait DebugInfoMethods<'tcx>: Backend<'tcx> {\n         defining_crate: CrateNum,\n     ) -> Self::DIScope;\n     fn debuginfo_finalize(&self);\n+    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> &[i64];\n }\n \n pub trait DebugInfoBuilderMethods<'tcx>: HasCodegen<'tcx> {", "previous_filename": "src/librustc_codegen_llvm/interfaces/debuginfo.rs"}, {"sha": "84a7c47ac621ceb8b46f3f69228b52c993da73ab", "filename": "src/librustc_codegen_ssa/interfaces/intrinsic.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fintrinsic.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -10,9 +10,9 @@\n \n use super::Backend;\n use super::HasCodegen;\n-use abi::FnType;\n use mir::operand::OperandRef;\n use rustc::ty::Ty;\n+use rustc_target::abi::call::FnType;\n use syntax_pos::Span;\n \n pub trait IntrinsicCallMethods<'tcx>: HasCodegen<'tcx> {", "previous_filename": "src/librustc_codegen_llvm/interfaces/intrinsic.rs"}, {"sha": "0425b8e8e23b1dd0d849773ab5fa7f66fa4d69b5", "filename": "src/librustc_codegen_ssa/interfaces/misc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmisc.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -33,6 +33,7 @@ pub trait MiscMethods<'tcx>: Backend<'tcx> {\n     fn consume_stats(self) -> RefCell<Stats>;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn statics_to_rauw(&self) -> &RefCell<Vec<(Self::Value, Self::Value)>>;\n+    fn closure_env_needs_indirect_debuginfo(&self) -> bool;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n     fn set_frame_pointer_elimination(&self, llfn: Self::Value);\n     fn apply_target_cpu_attr(&self, llfn: Self::Value);"}, {"sha": "0b2617072a36f379245530a06150f5773db206f5", "filename": "src/librustc_codegen_ssa/interfaces/mod.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmod.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -8,17 +8,74 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod abi;\n+mod asm;\n mod backend;\n+mod builder;\n+mod consts;\n+mod debuginfo;\n mod declare;\n+mod intrinsic;\n mod misc;\n mod statics;\n+mod type_;\n \n+pub use self::abi::{AbiBuilderMethods, AbiMethods};\n+pub use self::asm::{AsmBuilderMethods, AsmMethods};\n pub use self::backend::{Backend, BackendMethods, BackendTypes};\n+pub use self::builder::BuilderMethods;\n+pub use self::consts::ConstMethods;\n+pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n pub use self::declare::{DeclareMethods, PreDefineMethods};\n+pub use self::intrinsic::{IntrinsicCallMethods, IntrinsicDeclarationMethods};\n pub use self::misc::MiscMethods;\n pub use self::statics::StaticMethods;\n+pub use self::type_::{\n+    ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n+};\n \n use std::fmt;\n \n pub trait CodegenObject: Copy + PartialEq + fmt::Debug {}\n impl<T: Copy + PartialEq + fmt::Debug> CodegenObject for T {}\n+\n+pub trait CodegenMethods<'tcx>:\n+    Backend<'tcx>\n+    + TypeMethods<'tcx>\n+    + MiscMethods<'tcx>\n+    + ConstMethods<'tcx>\n+    + StaticMethods<'tcx>\n+    + DebugInfoMethods<'tcx>\n+    + AbiMethods<'tcx>\n+    + IntrinsicDeclarationMethods<'tcx>\n+    + DeclareMethods<'tcx>\n+    + AsmMethods<'tcx>\n+    + PreDefineMethods<'tcx>\n+{\n+}\n+\n+impl<'tcx, T> CodegenMethods<'tcx> for T where\n+    Self: Backend<'tcx>\n+        + TypeMethods<'tcx>\n+        + MiscMethods<'tcx>\n+        + ConstMethods<'tcx>\n+        + StaticMethods<'tcx>\n+        + DebugInfoMethods<'tcx>\n+        + AbiMethods<'tcx>\n+        + IntrinsicDeclarationMethods<'tcx>\n+        + DeclareMethods<'tcx>\n+        + AsmMethods<'tcx>\n+        + PreDefineMethods<'tcx>\n+{}\n+\n+pub trait HasCodegen<'tcx>: Backend<'tcx> {\n+    type CodegenCx: CodegenMethods<'tcx>\n+        + BackendTypes<\n+            Value = Self::Value,\n+            BasicBlock = Self::BasicBlock,\n+            Type = Self::Type,\n+            Context = Self::Context,\n+            Funclet = Self::Funclet,\n+            DIScope = Self::DIScope,\n+        >;\n+}"}, {"sha": "52c06618faa2b84edf2f64d98aee91e6264930f1", "filename": "src/librustc_codegen_ssa/interfaces/type_.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -10,13 +10,13 @@\n \n use super::Backend;\n use super::HasCodegen;\n+use common::TypeKind;\n use mir::place::PlaceRef;\n use rustc::ty::layout::TyLayout;\n use rustc::ty::layout::{self, Align, Size};\n use rustc::ty::Ty;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_codegen_ssa::common::TypeKind;\n-use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n+    use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n use std::cell::RefCell;\n use syntax::ast;\n \n@@ -93,6 +93,8 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool;\n+    fn is_backend_scalar_pair(&self, layout: TyLayout<'tcx>) -> bool;\n+    fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64;\n     fn scalar_pair_element_backend_type<'a>(\n         &self,\n         layout: TyLayout<'tcx>,", "previous_filename": "src/librustc_codegen_llvm/interfaces/type_.rs"}, {"sha": "9c4dfb0825ad5919c8db1072b46121af201ea04a", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -20,28 +20,49 @@\n #![feature(box_syntax)]\n #![feature(custom_attribute)]\n #![feature(libc)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(in_band_lifetimes)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(nll)]\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n #![feature(quote)]\n-#![feature(rustc_diagnostic_macros)]\n \n-#![recursion_limit=\"256\"]\n-\n-extern crate rustc;\n+#[macro_use] extern crate bitflags;\n+#[macro_use] extern crate log;\n+extern crate rustc_apfloat;\n+#[macro_use]  extern crate rustc;\n extern crate rustc_target;\n extern crate rustc_mir;\n-extern crate syntax;\n+#[macro_use] extern crate syntax;\n extern crate syntax_pos;\n+extern crate rustc_incremental;\n+extern crate rustc_codegen_utils;\n extern crate rustc_data_structures;\n extern crate libc;\n \n use std::path::PathBuf;\n use rustc::dep_graph::WorkProduct;\n use rustc::session::config::{OutputFilenames, OutputType};\n+use rustc::middle::lang_items::LangItem;\n+use rustc::hir::def_id::CrateNum;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n+use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n+\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+mod diagnostics;\n \n pub mod common;\n pub mod interfaces;\n+pub mod mir;\n+pub mod debuginfo;\n+pub mod base;\n+pub mod callee;\n+pub mod glue;\n+pub mod meth;\n+pub mod mono_item;\n \n pub struct ModuleCodegen<M> {\n     /// The name of the module. When the crate may be saved between\n@@ -111,5 +132,31 @@ pub enum ModuleKind {\n     Allocator,\n }\n \n+bitflags! {\n+    pub struct MemFlags: u8 {\n+        const VOLATILE = 1 << 0;\n+        const NONTEMPORAL = 1 << 1;\n+        const UNALIGNED = 1 << 2;\n+    }\n+}\n+\n+/// Misc info we load from metadata to persist beyond the tcx\n+struct CrateInfo {\n+    panic_runtime: Option<CrateNum>,\n+    compiler_builtins: Option<CrateNum>,\n+    profiler_runtime: Option<CrateNum>,\n+    sanitizer_runtime: Option<CrateNum>,\n+    is_no_builtins: FxHashSet<CrateNum>,\n+    native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n+    crate_name: FxHashMap<CrateNum, String>,\n+    used_libraries: Lrc<Vec<NativeLibrary>>,\n+    link_args: Lrc<Vec<String>>,\n+    used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n+    used_crates_static: Vec<(CrateNum, LibSource)>,\n+    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n+    wasm_imports: FxHashMap<String, String>,\n+    lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n+    missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n+}\n \n __build_diagnostic_array! { librustc_codegen_ssa, DIAGNOSTICS }"}, {"sha": "4584adfff65daf122277005bfaa49d284ebbbdac", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::FnType;\n+use rustc_target::abi::call::FnType;\n use callee;\n-use monomorphize;\n+use rustc_mir::monomorphize;\n \n use interfaces::*;\n ", "previous_filename": "src/librustc_codegen_llvm/meth.rs"}, {"sha": "2dc6ae3a04922c87e28cde37946bf1492d6b6ba8", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -19,7 +19,6 @@ use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUs\n use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n-use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n use interfaces::*;\n \n@@ -35,10 +34,10 @@ pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         let ty = fx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n         let layout = fx.cx.layout_of(ty);\n-        if layout.is_llvm_immediate() {\n+        if fx.cx.is_backend_immediate(layout) {\n             // These sorts of types are immediates that we can store\n             // in an Value without an alloca.\n-        } else if layout.is_llvm_scalar_pair() {\n+        } else if fx.cx.is_backend_scalar_pair(layout) {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n@@ -191,7 +190,7 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n                     let layout = cx.layout_of(base_ty.to_ty(cx.tcx()));\n-                    if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n+                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n                         // which would trigger `not_ssa` on locals.", "previous_filename": "src/librustc_codegen_llvm/mir/analyze.rs"}, {"sha": "46665193ab5f1f2933071362ab6c5491a4fcc377", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -13,14 +13,13 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::interpret::EvalErrorKind;\n-use abi::{Abi, FnType, PassMode};\n-use rustc_target::abi::call::ArgType;\n+use rustc_target::abi::call::{ArgType, FnType, PassMode};\n+use rustc_target::spec::abi::Abi;\n use base;\n-use builder::MemFlags;\n-use common;\n-use rustc_codegen_ssa::common::IntPredicate;\n+use MemFlags;\n+use common::{self, IntPredicate};\n use meth;\n-use monomorphize;\n+use rustc_mir::monomorphize;\n \n use interfaces::*;\n ", "previous_filename": "src/librustc_codegen_llvm/mir/block.rs"}, {"sha": "b71a0bc54b13154fc6728ee3a23d5dc7ae8d62cc", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "renamed", "additions": 3, "deletions": 59, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -8,74 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::interpret::{ErrorHandled, read_target_uint};\n+use rustc::mir::interpret::ErrorHandled;\n use rustc_mir::const_eval::const_field;\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, Pointer, Allocation, ConstValue};\n+use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n-use common::CodegenCx;\n+use rustc::ty::layout::{self, LayoutOf};\n use syntax::source_map::Span;\n-use value::Value;\n use interfaces::*;\n \n use super::FunctionCx;\n \n-pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n-    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n-    let dl = cx.data_layout();\n-    let pointer_size = dl.pointer_size.bytes() as usize;\n-\n-    let mut next_offset = 0;\n-    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n-        let offset = offset.bytes();\n-        assert_eq!(offset as usize as u64, offset);\n-        let offset = offset as usize;\n-        if offset > next_offset {\n-            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n-        }\n-        let ptr_offset = read_target_uint(\n-            dl.endian,\n-            &alloc.bytes[offset..(offset + pointer_size)],\n-        ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n-        llvals.push(cx.scalar_to_backend(\n-            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n-            &layout::Scalar {\n-                value: layout::Primitive::Pointer,\n-                valid_range: 0..=!0\n-            },\n-            cx.type_i8p()\n-        ));\n-        next_offset = offset + pointer_size;\n-    }\n-    if alloc.bytes.len() >= next_offset {\n-        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n-    }\n-\n-    cx.const_struct(&llvals, true)\n-}\n-\n-pub fn codegen_static_initializer(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    def_id: DefId,\n-) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n-    let instance = ty::Instance::mono(cx.tcx, def_id);\n-    let cid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-    let param_env = ty::ParamEnv::reveal_all();\n-    let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n-\n-    let alloc = match static_.val {\n-        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n-        _ => bug!(\"static const eval returned {:#?}\", static_),\n-    };\n-    Ok((const_alloc_to_llvm(cx, alloc), alloc))\n-}\n-\n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn fully_evaluate(\n         &mut self,", "previous_filename": "src/librustc_codegen_llvm/mir/constant.rs"}, {"sha": "3fdc37ee833dea3a4a937eb6d57fbad5b3e9786b", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "renamed", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -9,17 +9,15 @@\n // except according to those terms.\n \n use libc::c_uint;\n-use llvm;\n-use llvm_util;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout, HasTyCtxt};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::session::config::DebugInfo;\n use base;\n use debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n-use monomorphize::Instance;\n-use abi::{FnType, PassMode};\n+use rustc_mir::monomorphize::Instance;\n+use rustc_target::abi::call::{FnType, PassMode};\n use interfaces::*;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n@@ -30,8 +28,6 @@ use std::iter;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n-pub use self::constant::codegen_static_initializer;\n-\n use self::analyze::CleanupKind;\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n@@ -171,7 +167,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(self.cx.extend_scope_to_file(\n                 scope_metadata.unwrap(),\n                 &sm.lookup_char_pos(pos).file,\n-                defining_crate,\n+                defining_crate\n             ))\n         } else {\n             scope_metadata\n@@ -616,7 +612,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             // (cuviper) It seems to be fine without the alloca on LLVM 6 and later.\n-            let env_alloca = !env_ref && llvm_util::get_major_version() < 6;\n+            let env_alloca = !env_ref && bx.cx().closure_env_needs_indirect_debuginfo();\n             let env_ptr = if env_alloca {\n                 let scratch = PlaceRef::alloca(bx,\n                     bx.cx().layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n@@ -630,12 +626,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n                 let byte_offset_of_var_in_env = closure_layout.fields.offset(i).bytes();\n \n-                let ops = unsafe {\n-                    [llvm::LLVMRustDIBuilderCreateOpDeref(),\n-                     llvm::LLVMRustDIBuilderCreateOpPlusUconst(),\n-                     byte_offset_of_var_in_env as i64,\n-                     llvm::LLVMRustDIBuilderCreateOpDeref()]\n-                };\n+                let ops = bx.cx().debuginfo_upvar_decls_ops_sequence(byte_offset_of_var_in_env);\n \n                 // The environment and the capture can each be indirect.\n ", "previous_filename": "src/librustc_codegen_llvm/mir/mod.rs"}, {"sha": "8196aba87e4af8a969139521a901782853189ae7", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -14,7 +14,7 @@ use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n \n use base;\n-use builder::MemFlags;\n+use MemFlags;\n use glue;\n \n use interfaces::*;", "previous_filename": "src/librustc_codegen_llvm/mir/operand.rs"}, {"sha": "c976609d929ca36340b86724cd6147a448f92615", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -12,9 +12,8 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n-use builder::MemFlags;\n-use rustc_codegen_ssa::common::IntPredicate;\n-use type_of::LayoutLlvmExt;\n+use MemFlags;\n+use common::IntPredicate;\n use glue;\n \n use interfaces::*;\n@@ -114,7 +113,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 assert_eq!(offset, a.value.size(cx).abi_align(b.value.align(cx)));\n                 bx.struct_gep(self.llval, 1)\n             } else {\n-                bx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n+                bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n             };\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.", "previous_filename": "src/librustc_codegen_llvm/mir/place.rs"}, {"sha": "69c53879354ee463db67d9e3c7166c0d990b9a1e", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "renamed", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -17,12 +17,10 @@ use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n \n use base;\n-use builder::MemFlags;\n+use MemFlags;\n use callee;\n-use common;\n-use rustc_codegen_ssa::common::{RealPredicate, IntPredicate};\n-use monomorphize;\n-use type_of::LayoutLlvmExt;\n+use common::{self, RealPredicate, IntPredicate};\n+use rustc_mir::monomorphize;\n \n use interfaces::*;\n \n@@ -52,7 +50,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, _) => {\n                 // The destination necessarily contains a fat pointer, so if\n                 // it's a scalar pair, it's a fat pointer or newtype thereof.\n-                if dest.layout.is_llvm_scalar_pair() {\n+                if bx.cx().is_backend_scalar_pair(dest.layout) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n@@ -241,7 +239,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         operand.val\n                     }\n                     mir::CastKind::Unsize => {\n-                        assert!(cast.is_llvm_scalar_pair());\n+                        assert!(bx.cx().is_backend_scalar_pair(cast));\n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer - this is a\n@@ -267,9 +265,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if operand.layout.is_llvm_scalar_pair() => {\n+                    mir::CastKind::Misc if bx.cx().is_backend_scalar_pair(operand.layout) => {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n-                            if cast.is_llvm_scalar_pair() {\n+                            if bx.cx().is_backend_scalar_pair(cast) {\n                                 let data_cast = bx.pointercast(data_ptr,\n                                     bx.cx().scalar_pair_element_backend_type(cast, 0, true));\n                                 OperandValue::Pair(data_cast, meta)\n@@ -285,7 +283,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::Misc => {\n-                        assert!(cast.is_llvm_immediate());\n+                        assert!(bx.cx().is_backend_immediate(cast));\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {\n                             let val = OperandValue::Immediate(bx.cx().const_undef(ll_t_out));", "previous_filename": "src/librustc_codegen_llvm/mir/rvalue.rs"}, {"sha": "40af52c05a374c9173b8c367efe2c00c75808fce", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "previous_filename": "src/librustc_codegen_llvm/mir/statement.rs"}, {"sha": "508055ffc5a0ac330a2f8fe39bef1e404dc74a0f", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a428ee702329b0ad818a67a6ecc9617df267c7/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=c0a428ee702329b0ad818a67a6ecc9617df267c7", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Walks the crate looking for items/impl-items/trait-items that have\n+//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! generates an error giving, respectively, the symbol name or\n+//! item-path. This is used for unit testing the code that generates\n+//! paths etc in all kinds of annoying scenarios.\n+\n+use base;\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::mir::mono::{Linkage, Visibility};\n+use rustc::ty::layout::HasTyCtxt;\n+use std::fmt;\n+use interfaces::*;\n+\n+pub use rustc::mir::mono::MonoItem;\n+\n+pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n+\n+pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n+    fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx) {\n+        debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n+               self.to_string(cx.tcx()),\n+               self.to_raw_string(),\n+               cx.codegen_unit().name());\n+\n+        match *self.as_mono_item() {\n+            MonoItem::Static(def_id) => {\n+                let tcx = cx.tcx();\n+                let is_mutable = match tcx.describe_def(def_id) {\n+                    Some(Def::Static(_, is_mutable)) => is_mutable,\n+                    Some(other) => {\n+                        bug!(\"Expected Def::Static, found {:?}\", other)\n+                    }\n+                    None => {\n+                        bug!(\"Expected Def::Static for {:?}, found nothing\", def_id)\n+                    }\n+                };\n+                cx.codegen_static(def_id, is_mutable);\n+            }\n+            MonoItem::GlobalAsm(node_id) => {\n+                let item = cx.tcx().hir.expect_item(node_id);\n+                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n+                    cx.codegen_global_asm(ga);\n+                } else {\n+                    span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n+                }\n+            }\n+            MonoItem::Fn(instance) => {\n+                base::codegen_instance::<Bx>(&cx, instance);\n+            }\n+        }\n+\n+        debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n+               self.to_string(cx.tcx()),\n+               self.to_raw_string(),\n+               cx.codegen_unit().name());\n+    }\n+\n+    fn predefine<Bx: BuilderMethods<'a, 'tcx>>(\n+        &self,\n+        cx: &'a Bx::CodegenCx,\n+        linkage: Linkage,\n+        visibility: Visibility\n+    ) {\n+        debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n+               self.to_string(cx.tcx()),\n+               self.to_raw_string(),\n+               cx.codegen_unit().name());\n+\n+        let symbol_name = self.symbol_name(cx.tcx()).as_str();\n+\n+        debug!(\"symbol {}\", &symbol_name);\n+\n+        match *self.as_mono_item() {\n+            MonoItem::Static(def_id) => {\n+                cx.predefine_static(def_id, linkage, visibility, &symbol_name);\n+            }\n+            MonoItem::Fn(instance) => {\n+                cx.predefine_fn(instance, linkage, visibility, &symbol_name);\n+            }\n+            MonoItem::GlobalAsm(..) => {}\n+        }\n+\n+        debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n+               self.to_string(cx.tcx()),\n+               self.to_raw_string(),\n+               cx.codegen_unit().name());\n+    }\n+\n+    fn to_raw_string(&self) -> String {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(instance) => {\n+                format!(\"Fn({:?}, {})\",\n+                        instance.def,\n+                        instance.substs.as_ptr() as usize)\n+            }\n+            MonoItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+            MonoItem::GlobalAsm(id) => {\n+                format!(\"GlobalAsm({:?})\", id)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}"}]}