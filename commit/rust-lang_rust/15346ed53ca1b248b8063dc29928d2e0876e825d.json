{"sha": "15346ed53ca1b248b8063dc29928d2e0876e825d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MzQ2ZWQ1M2NhMWIyNDhiODA2M2RjMjk5MjhkMmUwODc2ZTgyNWQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-29T05:42:20Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-26T23:19:19Z"}, "message": "Remove `BitDenotation` framework", "tree": {"sha": "15a53ec8913b9a924da9b18da5d1281a18776100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15a53ec8913b9a924da9b18da5d1281a18776100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15346ed53ca1b248b8063dc29928d2e0876e825d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15346ed53ca1b248b8063dc29928d2e0876e825d", "html_url": "https://github.com/rust-lang/rust/commit/15346ed53ca1b248b8063dc29928d2e0876e825d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15346ed53ca1b248b8063dc29928d2e0876e825d/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fbb07525e2f07a815e780a4268b11916248b5a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbb07525e2f07a815e780a4268b11916248b5a9", "html_url": "https://github.com/rust-lang/rust/commit/2fbb07525e2f07a815e780a4268b11916248b5a9"}], "stats": {"total": 1019, "additions": 2, "deletions": 1017}, "files": [{"sha": "e4eb8506846c0b60b571ef0fc9603e780f2a2277", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/2fbb07525e2f07a815e780a4268b11916248b5a9/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbb07525e2f07a815e780a4268b11916248b5a9/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=2fbb07525e2f07a815e780a4268b11916248b5a9", "patch": "@@ -1,169 +0,0 @@\n-//! A nice wrapper to consume dataflow results at several CFG\n-//! locations.\n-\n-use rustc::mir::{BasicBlock, Location};\n-use rustc_index::bit_set::{BitIter, BitSet, HybridBitSet};\n-\n-use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n-\n-use std::borrow::Borrow;\n-use std::iter;\n-\n-/// A trait for \"cartesian products\" of multiple FlowAtLocation.\n-///\n-/// There's probably a way to auto-impl this, but I think\n-/// it is cleaner to have manual visitor impls.\n-pub trait FlowsAtLocation {\n-    /// Reset the state bitvector to represent the entry to block `bb`.\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock);\n-\n-    /// Reset the state bitvector to represent the exit of the\n-    /// terminator of block `bb`.\n-    ///\n-    /// **Important:** In the case of a `Call` terminator, these\n-    /// effects do *not* include the result of storing the destination\n-    /// of the call, since that is edge-dependent (in other words, the\n-    /// effects don't apply to the unwind edge).\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock);\n-\n-    /// Builds gen and kill sets for statement at `loc`.\n-    ///\n-    /// Note that invoking this method alone does not change the\n-    /// `curr_state` -- you must invoke `apply_local_effect`\n-    /// afterwards.\n-    fn reconstruct_statement_effect(&mut self, loc: Location);\n-\n-    /// Builds gen and kill sets for terminator for `loc`.\n-    ///\n-    /// Note that invoking this method alone does not change the\n-    /// `curr_state` -- you must invoke `apply_local_effect`\n-    /// afterwards.\n-    fn reconstruct_terminator_effect(&mut self, loc: Location);\n-\n-    /// Apply current gen + kill sets to `flow_state`.\n-    ///\n-    /// (`loc` parameters can be ignored if desired by\n-    /// client. For the terminator, the `stmt_idx` will be the number\n-    /// of statements in the block.)\n-    fn apply_local_effect(&mut self, loc: Location);\n-}\n-\n-/// Represents the state of dataflow at a particular\n-/// CFG location, both before and after it is\n-/// executed.\n-///\n-/// Data flow results are typically computed only as basic block\n-/// boundaries. A `FlowInProgress` allows you to reconstruct the\n-/// effects at any point in the control-flow graph by starting with\n-/// the state at the start of the basic block (`reset_to_entry_of`)\n-/// and then replaying the effects of statements and terminators\n-/// (e.g., via `reconstruct_statement_effect` and\n-/// `reconstruct_terminator_effect`; don't forget to call\n-/// `apply_local_effect`).\n-pub struct FlowAtLocation<'tcx, BD, DR = DataflowResults<'tcx, BD>>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    base_results: DR,\n-    curr_state: BitSet<BD::Idx>,\n-    stmt_trans: GenKillSet<BD::Idx>,\n-}\n-\n-impl<'tcx, BD, DR> FlowAtLocation<'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    /// Iterate over each bit set in the current state.\n-    pub fn each_state_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.curr_state.iter().for_each(f)\n-    }\n-\n-    /// Iterate over each `gen` bit in the current effect (invoke\n-    /// `reconstruct_statement_effect` or\n-    /// `reconstruct_terminator_effect` first).\n-    pub fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.stmt_trans.gen_set.iter().for_each(f)\n-    }\n-\n-    pub fn new(results: DR) -> Self {\n-        let bits_per_block = results.borrow().sets().bits_per_block();\n-        let curr_state = BitSet::new_empty(bits_per_block);\n-        let stmt_trans = GenKillSet::from_elem(HybridBitSet::new_empty(bits_per_block));\n-        FlowAtLocation { base_results: results, curr_state, stmt_trans }\n-    }\n-\n-    /// Access the underlying operator.\n-    pub fn operator(&self) -> &BD {\n-        self.base_results.borrow().operator()\n-    }\n-\n-    pub fn contains(&self, x: BD::Idx) -> bool {\n-        self.curr_state.contains(x)\n-    }\n-\n-    /// Returns an iterator over the elements present in the current state.\n-    pub fn iter_incoming(&self) -> iter::Peekable<BitIter<'_, BD::Idx>> {\n-        self.curr_state.iter().peekable()\n-    }\n-\n-    /// Creates a clone of the current state and applies the local\n-    /// effects to the clone (leaving the state of self intact).\n-    /// Invokes `f` with an iterator over the resulting state.\n-    pub fn with_iter_outgoing<F>(&self, f: F)\n-    where\n-        F: FnOnce(BitIter<'_, BD::Idx>),\n-    {\n-        let mut curr_state = self.curr_state.clone();\n-        self.stmt_trans.apply(&mut curr_state);\n-        f(curr_state.iter());\n-    }\n-\n-    /// Returns a bitset of the elements present in the current state.\n-    pub fn as_dense(&self) -> &BitSet<BD::Idx> {\n-        &self.curr_state\n-    }\n-}\n-\n-impl<'tcx, BD, DR> FlowsAtLocation for FlowAtLocation<'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.curr_state.overwrite(self.base_results.borrow().sets().entry_set_for(bb.index()));\n-    }\n-\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n-        self.reset_to_entry_of(bb);\n-        let trans = self.base_results.borrow().sets().trans_for(bb.index());\n-        trans.apply(&mut self.curr_state)\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_trans.clear();\n-        self.base_results.borrow().operator().before_statement_effect(&mut self.stmt_trans, loc);\n-        self.stmt_trans.apply(&mut self.curr_state);\n-\n-        self.base_results.borrow().operator().statement_effect(&mut self.stmt_trans, loc);\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_trans.clear();\n-        self.base_results.borrow().operator().before_terminator_effect(&mut self.stmt_trans, loc);\n-        self.stmt_trans.apply(&mut self.curr_state);\n-\n-        self.base_results.borrow().operator().terminator_effect(&mut self.stmt_trans, loc);\n-    }\n-\n-    fn apply_local_effect(&mut self, _loc: Location) {\n-        self.stmt_trans.apply(&mut self.curr_state)\n-    }\n-}"}, {"sha": "b7189f60984eabc77e0ac73745a1f30dbd5a625e", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 848, "changes": 850, "blob_url": "https://github.com/rust-lang/rust/blob/15346ed53ca1b248b8063dc29928d2e0876e825d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15346ed53ca1b248b8063dc29928d2e0876e825d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=15346ed53ca1b248b8063dc29928d2e0876e825d", "patch": "@@ -1,21 +1,9 @@\n-use rustc::mir::traversal;\n-use rustc::mir::{self, BasicBlock, BasicBlockData, Body, Location, Statement, Terminator};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_ast::ast::{self, MetaItem};\n-use rustc_ast_pretty::pprust;\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::borrow::Borrow;\n-use std::fmt;\n-use std::io;\n-use std::path::PathBuf;\n-\n-pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n pub use self::impls::borrows::Borrows;\n pub use self::impls::DefinitelyInitializedPlaces;\n@@ -26,10 +14,8 @@ pub use self::impls::{MaybeRequiresStorage, MaybeStorageLive};\n \n use self::move_paths::MoveData;\n \n-mod at_location;\n pub mod drop_flag_effects;\n pub mod generic;\n-mod graphviz;\n mod impls;\n pub mod move_paths;\n \n@@ -40,76 +26,6 @@ pub(crate) mod indexes {\n     };\n }\n \n-pub(crate) struct DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    def_id: DefId,\n-    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n-    print_preflow_to: Option<String>,\n-    print_postflow_to: Option<String>,\n-}\n-\n-/// `DebugFormatted` encapsulates the \"{:?}\" rendering of some\n-/// arbitrary value. This way: you pay cost of allocating an extra\n-/// string (as well as that of rendering up-front); in exchange, you\n-/// don't have to hand over ownership of your value or deal with\n-/// borrowing it.\n-pub struct DebugFormatted(String);\n-\n-impl DebugFormatted {\n-    pub fn new(input: &dyn fmt::Debug) -> DebugFormatted {\n-        DebugFormatted(format!(\"{:?}\", input))\n-    }\n-}\n-\n-impl fmt::Debug for DebugFormatted {\n-    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(w, \"{}\", self.0)\n-    }\n-}\n-\n-pub trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n-    /// Sets up and runs the dataflow problem, using `p` to render results if\n-    /// implementation so chooses.\n-    fn dataflow<P>(&mut self, p: P)\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        let _ = p; // default implementation does not instrument process.\n-        self.build_sets();\n-        self.propagate();\n-    }\n-\n-    /// Sets up the entry, gen, and kill sets for this instance of a dataflow problem.\n-    fn build_sets(&mut self);\n-\n-    /// Finds a fixed-point solution to this instance of a dataflow problem.\n-    fn propagate(&mut self);\n-}\n-\n-impl<'a, 'tcx, BD> Dataflow<'tcx, BD> for DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn dataflow<P>(&mut self, p: P)\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        self.flow_state.build_sets();\n-        self.pre_dataflow_instrumentation(|c, i| p(c, i)).unwrap();\n-        self.flow_state.propagate();\n-        self.post_dataflow_instrumentation(|c, i| p(c, i)).unwrap();\n-    }\n-\n-    fn build_sets(&mut self) {\n-        self.flow_state.build_sets();\n-    }\n-    fn propagate(&mut self) {\n-        self.flow_state.propagate();\n-    }\n-}\n-\n pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n     for attr in attrs {\n         if attr.check_name(sym::rustc_mir) {\n@@ -130,525 +46,6 @@ pub struct MoveDataParamEnv<'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub fn do_dataflow<'a, 'tcx, BD, P>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n-    def_id: DefId,\n-    attributes: &[ast::Attribute],\n-    dead_unwinds: &BitSet<BasicBlock>,\n-    bd: BD,\n-    p: P,\n-) -> DataflowResults<'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-{\n-    let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n-    flow_state.run(tcx, def_id, attributes, p)\n-}\n-\n-impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    pub(crate) fn run<P>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        attributes: &[ast::Attribute],\n-        p: P,\n-    ) -> DataflowResults<'tcx, BD>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n-            if let Some(item) = has_rustc_mir_with(attrs, name) {\n-                if let Some(s) = item.value_str() {\n-                    return Some(s.to_string());\n-                } else {\n-                    let path = pprust::path_to_string(&item.path);\n-                    sess.span_err(item.span, &format!(\"{} attribute requires a path\", path));\n-                    return None;\n-                }\n-            }\n-            None\n-        };\n-\n-        let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);\n-        let print_postflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_postflow);\n-\n-        let mut mbcx =\n-            DataflowBuilder { def_id, print_preflow_to, print_postflow_to, flow_state: self };\n-\n-        mbcx.dataflow(p);\n-        mbcx.flow_state.results()\n-    }\n-}\n-\n-struct PropagationContext<'b, 'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n-}\n-\n-impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn propagate(&mut self) {\n-        let mut temp = BitSet::new_empty(self.flow_state.sets.bits_per_block);\n-        let mut propcx = PropagationContext { builder: self };\n-        propcx.walk_cfg(&mut temp);\n-    }\n-\n-    fn build_sets(&mut self) {\n-        // Build the transfer function for each block.\n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n-            let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n-\n-            let trans = self.flow_state.sets.trans_mut_for(bb.index());\n-            for j_stmt in 0..statements.len() {\n-                let location = Location { block: bb, statement_index: j_stmt };\n-                self.flow_state.operator.before_statement_effect(trans, location);\n-                self.flow_state.operator.statement_effect(trans, location);\n-            }\n-\n-            if terminator.is_some() {\n-                let location = Location { block: bb, statement_index: statements.len() };\n-                self.flow_state.operator.before_terminator_effect(trans, location);\n-                self.flow_state.operator.terminator_effect(trans, location);\n-            }\n-        }\n-\n-        // Initialize the flow state at entry to the start block.\n-        let on_entry = self.flow_state.sets.entry_set_mut_for(mir::START_BLOCK.index());\n-        self.flow_state.operator.start_block_effect(on_entry);\n-    }\n-}\n-\n-impl<'b, 'a, 'tcx, BD> PropagationContext<'b, 'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n-        let body = self.builder.body;\n-\n-        // Initialize the dirty queue in reverse post-order. This makes it more likely that the\n-        // entry state for each basic block will have the effects of its predecessors applied\n-        // before it is processed. In fact, for CFGs without back edges, this guarantees that\n-        // dataflow will converge in exactly `N` iterations, where `N` is the number of basic\n-        // blocks.\n-        let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n-            WorkQueue::with_none(body.basic_blocks().len());\n-        for (bb, _) in traversal::reverse_postorder(body) {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        for bb in body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        while let Some(bb) = dirty_queue.pop() {\n-            let (on_entry, trans) = self.builder.flow_state.sets.get_mut(bb.index());\n-            debug_assert!(in_out.words().len() == on_entry.words().len());\n-            in_out.overwrite(on_entry);\n-            trans.apply(in_out);\n-\n-            let bb_data = &body[bb];\n-            self.builder.propagate_bits_into_graph_successors_of(\n-                in_out,\n-                (bb, bb_data),\n-                &mut dirty_queue,\n-            );\n-        }\n-    }\n-}\n-\n-fn dataflow_path(context: &str, path: &str) -> PathBuf {\n-    let mut path = PathBuf::from(path);\n-    let new_file_name = {\n-        let orig_file_name = path.file_name().unwrap().to_str().unwrap();\n-        format!(\"{}_{}\", context, orig_file_name)\n-    };\n-    path.set_file_name(new_file_name);\n-    path\n-}\n-\n-impl<'a, 'tcx, BD> DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        if let Some(ref path_str) = self.print_preflow_to {\n-            let path = dataflow_path(BD::name(), path_str);\n-            graphviz::print_borrowck_graph_to(self, &path, p)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        if let Some(ref path_str) = self.print_postflow_to {\n-            let path = dataflow_path(BD::name(), path_str);\n-            graphviz::print_borrowck_graph_to(self, &path, p)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-/// DataflowResultsConsumer abstracts over walking the MIR with some\n-/// already constructed dataflow results.\n-///\n-/// It abstracts over the FlowState and also completely hides the\n-/// underlying flow analysis results, because it needs to handle cases\n-/// where we are combining the results of *multiple* flow analyses\n-/// (e.g., borrows + inits + uninits).\n-pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n-    type FlowState: FlowsAtLocation;\n-\n-    // Observation Hooks: override (at least one of) these to get analysis feedback.\n-    fn visit_block_entry(&mut self, _bb: BasicBlock, _flow_state: &Self::FlowState) {}\n-\n-    fn visit_statement_entry(\n-        &mut self,\n-        _loc: Location,\n-        _stmt: &'a Statement<'tcx>,\n-        _flow_state: &Self::FlowState,\n-    ) {\n-    }\n-\n-    fn visit_terminator_entry(\n-        &mut self,\n-        _loc: Location,\n-        _term: &'a Terminator<'tcx>,\n-        _flow_state: &Self::FlowState,\n-    ) {\n-    }\n-\n-    // Main entry point: this drives the processing of results.\n-\n-    fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n-        let flow = flow_uninit;\n-        for (bb, _) in traversal::reverse_postorder(self.body()) {\n-            flow.reset_to_entry_of(bb);\n-            self.process_basic_block(bb, flow);\n-        }\n-    }\n-\n-    fn process_basic_block(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        self.visit_block_entry(bb, flow_state);\n-\n-        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = self.body()[bb];\n-        let mut location = Location { block: bb, statement_index: 0 };\n-        for stmt in statements.iter() {\n-            flow_state.reconstruct_statement_effect(location);\n-            self.visit_statement_entry(location, stmt, flow_state);\n-            flow_state.apply_local_effect(location);\n-            location.statement_index += 1;\n-        }\n-\n-        if let Some(ref term) = *terminator {\n-            flow_state.reconstruct_terminator_effect(location);\n-            self.visit_terminator_entry(location, term, flow_state);\n-\n-            // We don't need to apply the effect of the terminator,\n-            // since we are only visiting dataflow state on control\n-            // flow entry to the various nodes. (But we still need to\n-            // reconstruct the effect, because the visit method might\n-            // inspect it.)\n-        }\n-    }\n-\n-    // Delegated Hooks: Provide access to the MIR and process the flow state.\n-\n-    fn body(&self) -> &'a Body<'tcx>;\n-}\n-\n-/// Allows iterating dataflow results in a flexible and reasonably fast way.\n-pub struct DataflowResultsCursor<'mir, 'tcx, BD, DR = DataflowResults<'tcx, BD>>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    flow_state: FlowAtLocation<'tcx, BD, DR>,\n-\n-    // The statement (or terminator) whose effect has been reconstructed in\n-    // flow_state.\n-    curr_loc: Option<Location>,\n-\n-    body: &'mir Body<'tcx>,\n-}\n-\n-pub type DataflowResultsRefCursor<'mir, 'tcx, BD> =\n-    DataflowResultsCursor<'mir, 'tcx, BD, &'mir DataflowResults<'tcx, BD>>;\n-\n-impl<'mir, 'tcx, BD, DR> DataflowResultsCursor<'mir, 'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    pub fn new(result: DR, body: &'mir Body<'tcx>) -> Self {\n-        DataflowResultsCursor { flow_state: FlowAtLocation::new(result), curr_loc: None, body }\n-    }\n-\n-    /// Seek to the given location in MIR. This method is fast if you are\n-    /// traversing your MIR statements in order.\n-    ///\n-    /// After calling `seek`, the current state will reflect all effects up to\n-    /// and including the `before_statement_effect` of the statement at location\n-    /// `loc`. The `statement_effect` of the statement at `loc` will be\n-    /// available as the current effect (see e.g. `each_gen_bit`).\n-    ///\n-    /// If `loc.statement_index` equals the number of statements in the block,\n-    /// we will reconstruct the terminator effect in the same way as described\n-    /// above.\n-    pub fn seek(&mut self, loc: Location) {\n-        if self.curr_loc.map(|cur| loc == cur).unwrap_or(false) {\n-            return;\n-        }\n-\n-        let start_index;\n-        let should_reset = match self.curr_loc {\n-            None => true,\n-            Some(cur) if loc.block != cur.block || loc.statement_index < cur.statement_index => {\n-                true\n-            }\n-            _ => false,\n-        };\n-        if should_reset {\n-            self.flow_state.reset_to_entry_of(loc.block);\n-            start_index = 0;\n-        } else {\n-            let curr_loc = self.curr_loc.unwrap();\n-            start_index = curr_loc.statement_index;\n-            // Apply the effect from the last seek to the current state.\n-            self.flow_state.apply_local_effect(curr_loc);\n-        }\n-\n-        for stmt in start_index..loc.statement_index {\n-            let mut stmt_loc = loc;\n-            stmt_loc.statement_index = stmt;\n-            self.flow_state.reconstruct_statement_effect(stmt_loc);\n-            self.flow_state.apply_local_effect(stmt_loc);\n-        }\n-\n-        if loc.statement_index == self.body[loc.block].statements.len() {\n-            self.flow_state.reconstruct_terminator_effect(loc);\n-        } else {\n-            self.flow_state.reconstruct_statement_effect(loc);\n-        }\n-        self.curr_loc = Some(loc);\n-    }\n-\n-    /// Return whether the current state contains bit `x`.\n-    pub fn contains(&self, x: BD::Idx) -> bool {\n-        self.flow_state.contains(x)\n-    }\n-\n-    /// Iterate over each `gen` bit in the current effect (invoke `seek` first).\n-    pub fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.flow_state.each_gen_bit(f)\n-    }\n-\n-    pub fn get(&self) -> &BitSet<BD::Idx> {\n-        self.flow_state.as_dense()\n-    }\n-}\n-\n-pub struct DataflowAnalysis<'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    flow_state: DataflowState<'tcx, O>,\n-    dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-    body: &'a Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx, O> DataflowAnalysis<'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    pub fn results(self) -> DataflowResults<'tcx, O> {\n-        DataflowResults(self.flow_state)\n-    }\n-\n-    pub fn body(&self) -> &'a Body<'tcx> {\n-        self.body\n-    }\n-}\n-\n-pub struct DataflowResults<'tcx, O>(pub(crate) DataflowState<'tcx, O>)\n-where\n-    O: BitDenotation<'tcx>;\n-\n-impl<'tcx, O: BitDenotation<'tcx>> DataflowResults<'tcx, O> {\n-    pub fn sets(&self) -> &AllSets<O::Idx> {\n-        &self.0.sets\n-    }\n-\n-    pub fn operator(&self) -> &O {\n-        &self.0.operator\n-    }\n-}\n-\n-/// State of a dataflow analysis; couples a collection of bit sets\n-/// with operator used to initialize and merge bits during analysis.\n-pub struct DataflowState<'tcx, O: BitDenotation<'tcx>> {\n-    /// All the sets for the analysis. (Factored into its\n-    /// own structure so that we can borrow it mutably\n-    /// on its own separate from other fields.)\n-    pub sets: AllSets<O::Idx>,\n-\n-    /// operator used to initialize, combine, and interpret bits.\n-    pub(crate) operator: O,\n-}\n-\n-impl<'tcx, O: BitDenotation<'tcx>> DataflowState<'tcx, O> {\n-    pub(crate) fn interpret_set<'c, P>(\n-        &self,\n-        o: &'c O,\n-        set: &BitSet<O::Idx>,\n-        render_idx: &P,\n-    ) -> Vec<DebugFormatted>\n-    where\n-        P: Fn(&O, O::Idx) -> DebugFormatted,\n-    {\n-        set.iter().map(|i| render_idx(o, i)).collect()\n-    }\n-\n-    pub(crate) fn interpret_hybrid_set<'c, P>(\n-        &self,\n-        o: &'c O,\n-        set: &HybridBitSet<O::Idx>,\n-        render_idx: &P,\n-    ) -> Vec<DebugFormatted>\n-    where\n-        P: Fn(&O, O::Idx) -> DebugFormatted,\n-    {\n-        set.iter().map(|i| render_idx(o, i)).collect()\n-    }\n-}\n-\n-/// A 2-tuple representing the \"gen\" and \"kill\" bitsets during\n-/// dataflow analysis.\n-///\n-/// It is best to ensure that the intersection of `gen_set` and\n-/// `kill_set` is empty; otherwise the results of the dataflow will\n-/// have a hidden dependency on what order the bits are generated and\n-/// killed during the iteration. (This is such a good idea that the\n-/// `fn gen` and `fn kill` methods that set their state enforce this\n-/// for you.)\n-#[derive(Debug, Clone, Copy)]\n-pub struct GenKill<T> {\n-    pub(crate) gen_set: T,\n-    pub(crate) kill_set: T,\n-}\n-\n-pub type GenKillSet<T> = GenKill<HybridBitSet<T>>;\n-\n-impl<T> GenKill<T> {\n-    /// Creates a new tuple where `gen_set == kill_set == elem`.\n-    pub(crate) fn from_elem(elem: T) -> Self\n-    where\n-        T: Clone,\n-    {\n-        GenKill { gen_set: elem.clone(), kill_set: elem }\n-    }\n-}\n-\n-impl<E: Idx> GenKillSet<E> {\n-    pub fn clear(&mut self) {\n-        self.gen_set.clear();\n-        self.kill_set.clear();\n-    }\n-\n-    pub fn gen(&mut self, e: E) {\n-        self.gen_set.insert(e);\n-        self.kill_set.remove(e);\n-    }\n-\n-    pub fn gen_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n-        for j in i {\n-            self.gen(*j.borrow());\n-        }\n-    }\n-\n-    pub fn kill(&mut self, e: E) {\n-        self.gen_set.remove(e);\n-        self.kill_set.insert(e);\n-    }\n-\n-    pub fn kill_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n-        for j in i {\n-            self.kill(*j.borrow());\n-        }\n-    }\n-\n-    /// Computes `(set \u222a gen) - kill` and assigns the result to `set`.\n-    pub(crate) fn apply(&self, set: &mut BitSet<E>) {\n-        set.union(&self.gen_set);\n-        set.subtract(&self.kill_set);\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct AllSets<E: Idx> {\n-    /// Analysis bitwidth for each block.\n-    bits_per_block: usize,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry: Vec<BitSet<E>>,\n-\n-    /// The transfer function of each block expressed as the set of bits\n-    /// generated and killed by executing the statements + terminator in the\n-    /// block -- with one caveat. In particular, for *call terminators*, the\n-    /// effect of storing the destination is not included, since that only takes\n-    /// effect on the **success** edge (and not the unwind edge).\n-    trans: Vec<GenKillSet<E>>,\n-}\n-\n-impl<E: Idx> AllSets<E> {\n-    pub fn bits_per_block(&self) -> usize {\n-        self.bits_per_block\n-    }\n-\n-    pub fn get_mut(&mut self, block_idx: usize) -> (&mut BitSet<E>, &mut GenKillSet<E>) {\n-        (&mut self.on_entry[block_idx], &mut self.trans[block_idx])\n-    }\n-\n-    pub fn trans_for(&self, block_idx: usize) -> &GenKillSet<E> {\n-        &self.trans[block_idx]\n-    }\n-    pub fn trans_mut_for(&mut self, block_idx: usize) -> &mut GenKillSet<E> {\n-        &mut self.trans[block_idx]\n-    }\n-    pub fn entry_set_for(&self, block_idx: usize) -> &BitSet<E> {\n-        &self.on_entry[block_idx]\n-    }\n-    pub fn entry_set_mut_for(&mut self, block_idx: usize) -> &mut BitSet<E> {\n-        &mut self.on_entry[block_idx]\n-    }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.trans_for(block_idx).gen_set\n-    }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.trans_for(block_idx).kill_set\n-    }\n-}\n-\n /// Parameterization for the precise form of data flow that is used.\n ///\n /// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n@@ -689,246 +86,3 @@ pub trait BottomValue {\n         if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n     }\n }\n-\n-/// A specific flavor of dataflow analysis.\n-///\n-/// To run a dataflow analysis, one sets up an initial state for the\n-/// `START_BLOCK` via `start_block_effect` and a transfer function (`trans`)\n-/// for each block individually. The entry set for all other basic blocks is\n-/// initialized to `Self::BOTTOM_VALUE`. The dataflow analysis then\n-/// iteratively modifies the various entry sets (but leaves the the transfer\n-/// function unchanged). `BottomValue::join` is used to merge the bitsets from\n-/// two blocks (e.g. when two blocks' terminator jumps to a single block, that\n-/// target block's state is the merged state of both incoming blocks).\n-pub trait BitDenotation<'tcx>: BottomValue {\n-    /// Specifies what index type is used to access the bitvector.\n-    type Idx: Idx;\n-\n-    /// A name describing the dataflow analysis that this\n-    /// `BitDenotation` is supporting. The name should be something\n-    /// suitable for plugging in as part of a filename (i.e., avoid\n-    /// space-characters or other things that tend to look bad on a\n-    /// file system, like slashes or periods). It is also better for\n-    /// the name to be reasonably short, again because it will be\n-    /// plugged into a filename.\n-    fn name() -> &'static str;\n-\n-    /// Size of each bitvector allocated for each block in the analysis.\n-    fn bits_per_block(&self) -> usize;\n-\n-    /// Mutates the entry set according to the effects that\n-    /// have been established *prior* to entering the start\n-    /// block. This can't access the gen/kill sets, because\n-    /// these won't be accounted for correctly.\n-    ///\n-    /// (For example, establishing the call arguments.)\n-    fn start_block_effect(&self, entry_set: &mut BitSet<Self::Idx>);\n-\n-    /// Similar to `statement_effect`, except it applies\n-    /// *just before* the statement rather than *just after* it.\n-    ///\n-    /// This matters for \"dataflow at location\" APIs, because the\n-    /// before-statement effect is visible while visiting the\n-    /// statement, while the after-statement effect only becomes\n-    /// visible at the next statement.\n-    ///\n-    /// Both the before-statement and after-statement effects are\n-    /// applied, in that order, before moving for the next\n-    /// statement.\n-    fn before_statement_effect(&self, _trans: &mut GenKillSet<Self::Idx>, _location: Location) {}\n-\n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects of evaluating statement.\n-    ///\n-    /// This is used, in particular, for building up the\n-    /// \"transfer-function\" representing the overall-effect of the\n-    /// block, represented via GEN and KILL sets.\n-    ///\n-    /// The statement is identified as `bb_data[idx_stmt]`, where\n-    /// `bb_data` is the sequence of statements identified by `bb` in\n-    /// the MIR.\n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location);\n-\n-    /// Similar to `terminator_effect`, except it applies\n-    /// *just before* the terminator rather than *just after* it.\n-    ///\n-    /// This matters for \"dataflow at location\" APIs, because the\n-    /// before-terminator effect is visible while visiting the\n-    /// terminator, while the after-terminator effect only becomes\n-    /// visible at the terminator's successors.\n-    ///\n-    /// Both the before-terminator and after-terminator effects are\n-    /// applied, in that order, before moving for the next\n-    /// terminator.\n-    fn before_terminator_effect(&self, _trans: &mut GenKillSet<Self::Idx>, _location: Location) {}\n-\n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects of evaluating\n-    /// the terminator.\n-    ///\n-    /// This is used, in particular, for building up the\n-    /// \"transfer-function\" representing the overall-effect of the\n-    /// block, represented via GEN and KILL sets.\n-    ///\n-    /// The effects applied here cannot depend on which branch the\n-    /// terminator took.\n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location);\n-\n-    /// Mutates the block-sets according to the (flow-dependent)\n-    /// effect of a successful return from a Call terminator.\n-    ///\n-    /// If basic-block BB_x ends with a call-instruction that, upon\n-    /// successful return, flows to BB_y, then this method will be\n-    /// called on the exit flow-state of BB_x in order to set up the\n-    /// entry flow-state of BB_y.\n-    ///\n-    /// This is used, in particular, as a special case during the\n-    /// \"propagate\" loop where all of the basic blocks are repeatedly\n-    /// visited. Since the effects of a Call terminator are\n-    /// flow-dependent, the current MIR cannot encode them via just\n-    /// GEN and KILL sets attached to the block, and so instead we add\n-    /// this extra machinery to represent the flow-dependent effect.\n-    //\n-    // FIXME: right now this is a bit of a wart in the API. It might\n-    // be better to represent this as an additional gen- and\n-    // kill-sets associated with each edge coming out of the basic\n-    // block.\n-    fn propagate_call_return(\n-        &self,\n-        in_out: &mut BitSet<Self::Idx>,\n-        call_bb: mir::BasicBlock,\n-        dest_bb: mir::BasicBlock,\n-        dest_place: &mir::Place<'tcx>,\n-    );\n-}\n-\n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n-where\n-    D: BitDenotation<'tcx>,\n-{\n-    pub fn new(\n-        body: &'a Body<'tcx>,\n-        dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-        denotation: D,\n-    ) -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let num_blocks = body.basic_blocks().len();\n-\n-        let on_entry = if D::BOTTOM_VALUE {\n-            vec![BitSet::new_filled(bits_per_block); num_blocks]\n-        } else {\n-            vec![BitSet::new_empty(bits_per_block); num_blocks]\n-        };\n-        let nop = GenKill::from_elem(HybridBitSet::new_empty(bits_per_block));\n-\n-        DataflowAnalysis {\n-            body,\n-            dead_unwinds,\n-            flow_state: DataflowState {\n-                sets: AllSets { bits_per_block, on_entry, trans: vec![nop; num_blocks] },\n-                operator: denotation,\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n-where\n-    D: BitDenotation<'tcx>,\n-{\n-    /// Propagates the bits of `in_out` into all the successors of `bb`,\n-    /// using bitwise operator denoted by `self.operator`.\n-    ///\n-    /// For most blocks, this is entirely uniform. However, for blocks\n-    /// that end with a call terminator, the effect of the call on the\n-    /// dataflow state may depend on whether the call returned\n-    /// successfully or unwound.\n-    ///\n-    /// To reflect this, the `propagate_call_return` method of the\n-    /// `BitDenotation` mutates `in_out` when propagating `in_out` via\n-    /// a call terminator; such mutation is performed *last*, to\n-    /// ensure its side-effects do not leak elsewhere (e.g., into\n-    /// unwind target).\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<D::Idx>,\n-        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<mir::BasicBlock>,\n-    ) {\n-        match bb_data.terminator().kind {\n-            mir::TerminatorKind::Return\n-            | mir::TerminatorKind::Resume\n-            | mir::TerminatorKind::Abort\n-            | mir::TerminatorKind::GeneratorDrop\n-            | mir::TerminatorKind::Unreachable => {}\n-            mir::TerminatorKind::Goto { target }\n-            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n-            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n-            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n-            {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-            }\n-            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n-            | mir::TerminatorKind::DropAndReplace {\n-                target,\n-                value: _,\n-                location: _,\n-                unwind: Some(unwind),\n-            } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if !self.dead_unwinds.contains(bb) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::Call { cleanup, ref destination, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-                if let Some((ref dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    self.flow_state.operator.propagate_call_return(in_out, bb, dest_bb, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<D::Idx>,\n-        bb: mir::BasicBlock,\n-        dirty_queue: &mut WorkQueue<mir::BasicBlock>,\n-    ) {\n-        let entry_set = self.flow_state.sets.entry_set_mut_for(bb.index());\n-        let set_changed = self.flow_state.operator.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-}"}]}