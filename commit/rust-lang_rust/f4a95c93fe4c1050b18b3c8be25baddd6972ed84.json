{"sha": "f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YTk1YzkzZmU0YzEwNTBiMThiM2M4YmUyNWJhZGRkNjk3MmVkODQ=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-29T05:04:24Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:45Z"}, "message": "Remove unneeded indirection on PatCtxt", "tree": {"sha": "d0daaf253953ffa93bafe7afd2eecb7b9d84fd54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0daaf253953ffa93bafe7afd2eecb7b9d84fd54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "html_url": "https://github.com/rust-lang/rust/commit/f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26baab5d2836eb5affd93d1991b3e96853f13869", "url": "https://api.github.com/repos/rust-lang/rust/commits/26baab5d2836eb5affd93d1991b3e96853f13869", "html_url": "https://github.com/rust-lang/rust/commit/26baab5d2836eb5affd93d1991b3e96853f13869"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "88018b5d9a21fd9e60b4197d95df7a6e41b1e9f1", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "patch": "@@ -373,12 +373,12 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n             db.body_with_source_map(self.owner);\n \n-        let match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n+        let _match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n             return;\n         } else {\n             &infer.type_of_expr[match_expr]\n         };\n-        // eprintln!(\"ExprValidator::validate_match2({:?})\", match_expr_ty.kind(&Interner));\n+        // eprintln!(\"ExprValidator::validate_match2({:?})\", _match_expr_ty.kind(&Interner));\n \n         let pattern_arena = usefulness::PatternArena::clone_from(&body.pats);\n         let cx = usefulness::MatchCheckCtx {"}, {"sha": "d41b95d2f96c9a4861c062cdeaa34620c4bb2db4", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "patch": "@@ -143,7 +143,7 @@ impl Constructor {\n     /// matrix, unless all of them are.\n     pub(super) fn split<'a>(\n         &self,\n-        pcx: &PatCtxt<'_>,\n+        pcx: PatCtxt<'_>,\n         ctors: impl Iterator<Item = &'a Constructor> + Clone,\n     ) -> SmallVec<[Self; 1]> {\n         match self {\n@@ -166,7 +166,7 @@ impl Constructor {\n     /// this checks for inclusion.\n     // We inline because this has a single call site in `Matrix::specialize_constructor`.\n     #[inline]\n-    pub(super) fn is_covered_by(&self, pcx: &PatCtxt<'_>, other: &Self) -> bool {\n+    pub(super) fn is_covered_by(&self, pcx: PatCtxt<'_>, other: &Self) -> bool {\n         // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n@@ -188,7 +188,7 @@ impl Constructor {\n     /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n     /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n     /// assumed to have been split from a wildcard.\n-    fn is_covered_by_any(&self, pcx: &PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n+    fn is_covered_by_any(&self, pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n         if used_ctors.is_empty() {\n             return false;\n         }\n@@ -236,7 +236,7 @@ pub(super) struct SplitWildcard {\n }\n \n impl SplitWildcard {\n-    pub(super) fn new(pcx: &PatCtxt<'_>) -> Self {\n+    pub(super) fn new(pcx: PatCtxt<'_>) -> Self {\n         // let cx = pcx.cx;\n         // let make_range = |start, end| IntRange(todo!());\n \n@@ -260,7 +260,7 @@ impl SplitWildcard {\n     /// do what you want.\n     pub(super) fn split<'a>(\n         &mut self,\n-        pcx: &PatCtxt<'_>,\n+        pcx: PatCtxt<'_>,\n         ctors: impl Iterator<Item = &'a Constructor> + Clone,\n     ) {\n         // Since `all_ctors` never contains wildcards, this won't recurse further.\n@@ -270,21 +270,21 @@ impl SplitWildcard {\n     }\n \n     /// Whether there are any value constructors for this type that are not present in the matrix.\n-    fn any_missing(&self, pcx: &PatCtxt<'_>) -> bool {\n+    fn any_missing(&self, pcx: PatCtxt<'_>) -> bool {\n         self.iter_missing(pcx).next().is_some()\n     }\n \n     /// Iterate over the constructors for this type that are not present in the matrix.\n     pub(super) fn iter_missing<'a>(\n         &'a self,\n-        pcx: &'a PatCtxt<'_>,\n+        pcx: PatCtxt<'a>,\n     ) -> impl Iterator<Item = &'a Constructor> {\n         self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n     }\n \n     /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n     /// top of the file, if any constructors are missing we can ignore the present ones.\n-    fn into_ctors(self, pcx: &PatCtxt<'_>) -> SmallVec<[Constructor; 1]> {\n+    fn into_ctors(self, pcx: PatCtxt<'_>) -> SmallVec<[Constructor; 1]> {\n         if self.any_missing(pcx) {\n             // Some constructors are missing, thus we can specialize with the special `Missing`\n             // constructor, which stands for those constructors that are not seen in the matrix,\n@@ -313,7 +313,7 @@ impl SplitWildcard {\n             //\n             // The exception is: if we are at the top-level, for example in an empty match, we\n             // sometimes prefer reporting the list of constructors instead of just `_`.\n-            let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(&pcx.ty);\n+            let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n             let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n                 Missing\n             } else {\n@@ -381,8 +381,8 @@ impl Fields {\n         Fields::Vec(pats)\n     }\n \n-    pub(crate) fn wildcards(pcx: &PatCtxt<'_>, constructor: &Constructor) -> Self {\n-        let ty = &pcx.ty;\n+    pub(crate) fn wildcards(pcx: PatCtxt<'_>, constructor: &Constructor) -> Self {\n+        let ty = pcx.ty;\n         let cx = pcx.cx;\n         let wildcard_from_ty = |ty| cx.alloc_pat(Pat::Wild, ty);\n \n@@ -446,7 +446,7 @@ impl Fields {\n     /// `ty`: `Option<bool>`\n     /// `self`: `[false]`\n     /// returns `Some(false)`\n-    pub(super) fn apply(self, pcx: &PatCtxt<'_>, ctor: &Constructor) -> Pat {\n+    pub(super) fn apply(self, pcx: PatCtxt<'_>, ctor: &Constructor) -> Pat {\n         let subpatterns_and_indices = self.patterns_and_indices();\n         let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p);\n "}, {"sha": "7d9ab849b144d51b6774c5797e2c97febb8e63eb", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a95c93fe4c1050b18b3c8be25baddd6972ed84/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "patch": "@@ -51,11 +51,11 @@ impl<'a> MatchCheckCtx<'a> {\n     }\n }\n \n-#[derive(Clone)]\n+#[derive(Copy, Clone)]\n pub(super) struct PatCtxt<'a> {\n     pub(super) cx: &'a MatchCheckCtx<'a>,\n     /// Type of the current column under investigation.\n-    pub(super) ty: Ty,\n+    pub(super) ty: &'a Ty,\n     /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n     /// subpattern.\n     pub(super) is_top_level: bool,\n@@ -223,7 +223,7 @@ impl Matrix {\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n-        pcx: &PatCtxt<'_>,\n+        pcx: PatCtxt<'_>,\n         ctor: &Constructor,\n         ctor_wild_subpatterns: &Fields,\n     ) -> Matrix {\n@@ -447,7 +447,7 @@ impl Usefulness {\n     /// with the results of specializing with the other constructors.\n     fn apply_constructor(\n         self,\n-        pcx: &PatCtxt<'_>,\n+        pcx: PatCtxt<'_>,\n         matrix: &Matrix,\n         ctor: &Constructor,\n         ctor_wild_subpatterns: &Fields,\n@@ -555,7 +555,7 @@ impl Witness {\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n     fn apply_constructor(\n         mut self,\n-        pcx: &PatCtxt<'_>,\n+        pcx: PatCtxt<'_>,\n         ctor: &Constructor,\n         ctor_wild_subpatterns: &Fields,\n     ) -> Self {\n@@ -623,7 +623,7 @@ fn is_useful(\n     // FIXME(Nadrieril): Hack to work around type normalization issues (see rust-lang/rust#72476).\n     // TODO(iDawer): ty.strip_references()  ?\n     let ty = matrix.heads().next().map_or(cx.type_of(v.head()), |r| cx.type_of(r));\n-    let pcx = PatCtxt { cx, ty, is_top_level };\n+    let pcx = PatCtxt { cx, ty: &ty, is_top_level };\n \n     // If the first pattern is an or-pattern, expand it.\n     let ret = if v.head().is_or_pat(cx) {\n@@ -657,20 +657,20 @@ fn is_useful(\n         // }\n \n         // We split the head constructor of `v`.\n-        let split_ctors = v_ctor.split(&pcx, matrix.head_ctors(cx));\n+        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n         let start_matrix = matrix;\n         let usefulnesses = split_ctors.into_iter().map(|ctor| {\n             // debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n-            let ctor_wild_subpatterns = Fields::wildcards(&pcx, &ctor);\n+            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n             let spec_matrix =\n-                start_matrix.specialize_constructor(&pcx, &ctor, &ctor_wild_subpatterns);\n+                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns, cx);\n             let usefulness =\n                 is_useful(cx, &spec_matrix, &v, witness_preference, is_under_guard, false);\n-            usefulness.apply_constructor(&pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n+            usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n         });\n         Usefulness::merge(witness_preference, usefulnesses)\n     };"}]}