{"sha": "1265cbf4e05628c98f51afebe0b662c451173faa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNjVjYmY0ZTA1NjI4Yzk4ZjUxYWZlYmUwYjY2MmM0NTExNzNmYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-15T20:34:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-15T20:34:11Z"}, "message": "Auto merge of #36393 - petrochenkov:ancient, r=eddyb\n\nRemove some obsolete code from the compiler", "tree": {"sha": "d22f9883386d441d7431306ec1029c2035b01133", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d22f9883386d441d7431306ec1029c2035b01133"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1265cbf4e05628c98f51afebe0b662c451173faa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1265cbf4e05628c98f51afebe0b662c451173faa", "html_url": "https://github.com/rust-lang/rust/commit/1265cbf4e05628c98f51afebe0b662c451173faa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1265cbf4e05628c98f51afebe0b662c451173faa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1acabeaa204db9235d9e72c5bae4cfaa82da763", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1acabeaa204db9235d9e72c5bae4cfaa82da763", "html_url": "https://github.com/rust-lang/rust/commit/d1acabeaa204db9235d9e72c5bae4cfaa82da763"}, {"sha": "b57f1099b577d4d388cc5236fb6990275c028b5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b57f1099b577d4d388cc5236fb6990275c028b5b", "html_url": "https://github.com/rust-lang/rust/commit/b57f1099b577d4d388cc5236fb6990275c028b5b"}], "stats": {"total": 236, "additions": 40, "deletions": 196}, "files": [{"sha": "c419f96e8209581973a5965ede579c3f16eac1bc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 82, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -67,7 +67,6 @@ pub use self::ElementKind::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n-pub use self::deref_kind::*;\n \n use self::Aliasability::*;\n \n@@ -195,51 +194,6 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n-// We pun on *T to mean both actual deref of a ptr as well\n-// as accessing of components:\n-#[derive(Copy, Clone)]\n-pub enum deref_kind<'tcx> {\n-    deref_ptr(PointerKind<'tcx>),\n-    deref_interior(InteriorKind),\n-}\n-\n-type DerefKindContext = Option<InteriorOffsetKind>;\n-\n-// Categorizes a derefable type.  Note that we include vectors and strings as\n-// derefable (we model an index as the combination of a deref and then a\n-// pointer adjustment).\n-fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n-    match t.sty {\n-        ty::TyBox(_) => {\n-            Ok(deref_ptr(Unique))\n-        }\n-\n-        ty::TyRef(r, mt) => {\n-            let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Ok(deref_ptr(BorrowedPtr(kind, r)))\n-        }\n-\n-        ty::TyRawPtr(ref mt) => {\n-            Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n-        }\n-\n-        ty::TyAdt(..) => { // newtype\n-            Ok(deref_interior(InteriorField(PositionalField(0))))\n-        }\n-\n-        ty::TyArray(..) | ty::TySlice(_) => {\n-            // no deref of indexed content without supplying InteriorOffsetKind\n-            if let Some(context) = context {\n-                Ok(deref_interior(InteriorElement(context, ElementKind::VecElement)))\n-            } else {\n-                Err(())\n-            }\n-        }\n-\n-        _ => Err(()),\n-    }\n-}\n-\n pub trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;\n@@ -476,7 +430,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                autoderefs,\n                cmt);\n         for deref in 1..autoderefs + 1 {\n-            cmt = self.cat_deref(expr, cmt, deref, None)?;\n+            cmt = self.cat_deref(expr, cmt, deref)?;\n         }\n         return Ok(cmt);\n     }\n@@ -488,7 +442,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             let base_cmt = self.cat_expr(&e_base)?;\n-            self.cat_deref(expr, base_cmt, 0, None)\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n@@ -507,7 +461,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           hir::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n-            let context = InteriorOffsetKind::Index;\n             match self.infcx.node_method_ty(method_call) {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it\n@@ -529,10 +482,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     // is an rvalue. That is what we will be\n                     // dereferencing.\n                     let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n-                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n+                    Ok(self.cat_deref_common(expr, base_cmt, 1, elem_ty, true))\n                 }\n                 None => {\n-                    self.cat_index(expr, self.cat_expr(&base)?, context)\n+                    self.cat_index(expr, self.cat_expr(&base)?, InteriorOffsetKind::Index)\n                 }\n             }\n           }\n@@ -907,8 +860,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: usize,\n-                             deref_context: DerefKindContext)\n+                             deref_cnt: usize)\n                              -> McResult<cmt<'tcx>> {\n         let method_call = ty::MethodCall {\n             expr_id: node.id(),\n@@ -930,12 +882,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_cmt_ty = base_cmt.ty;\n         match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n             Some(mt) => {\n-                let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n-                                              mt.ty,\n-                                              deref_context,\n-                                                /* implicit: */ false);\n+                let ret = self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, false);\n                 debug!(\"cat_deref ret {:?}\", ret);\n-                ret\n+                Ok(ret)\n             }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {:?}\",\n@@ -950,40 +899,29 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                     base_cmt: cmt<'tcx>,\n                                     deref_cnt: usize,\n                                     deref_ty: Ty<'tcx>,\n-                                    deref_context: DerefKindContext,\n                                     implicit: bool)\n-                                    -> McResult<cmt<'tcx>>\n+                                    -> cmt<'tcx>\n     {\n-        let (m, cat) = match deref_kind(base_cmt.ty, deref_context)? {\n-            deref_ptr(ptr) => {\n-                let ptr = if implicit {\n-                    match ptr {\n-                        BorrowedPtr(bk, r) => Implicit(bk, r),\n-                        _ => span_bug!(node.span(),\n-                            \"Implicit deref of non-borrowed pointer\")\n-                    }\n-                } else {\n-                    ptr\n-                };\n-                // for unique ptrs, we inherit mutability from the\n-                // owning reference.\n-                (MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-                 Categorization::Deref(base_cmt, deref_cnt, ptr))\n-            }\n-            deref_interior(interior) => {\n-                (base_cmt.mutbl.inherit(), Categorization::Interior(base_cmt, interior))\n+        let ptr = match base_cmt.ty.sty {\n+            ty::TyBox(..) => Unique,\n+            ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n+            ty::TyRef(r, mt) => {\n+                let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n+                if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n+            ref ty => bug!(\"unexpected type in cat_deref_common: {:?}\", ty)\n         };\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat,\n-            mutbl: m,\n+            // For unique ptrs, we inherit mutability from the owning reference.\n+            mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n+            cat: Categorization::Deref(base_cmt, deref_cnt, ptr),\n             ty: deref_ty,\n             note: NoteNone\n         });\n         debug!(\"cat_deref_common ret {:?}\", ret);\n-        Ok(ret)\n+        ret\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -1206,7 +1144,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n+            let subcmt = self.cat_deref(pat, cmt, 0)?;\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n "}, {"sha": "e228bf74302612f35c09b122911f04ffb2dafe35", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -252,27 +252,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-/// Iterates through \"auxiliary node IDs\", which are node IDs that describe\n-/// top-level items that are sub-items of the given item. Specifically:\n-///\n-/// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id<F>(item: &hir::Item, callback: F) -> bool where\n-    F: FnOnce(NodeId) -> bool,\n-{\n-    let mut continue_ = true;\n-    match item.node {\n-        hir::ItemStruct(ref struct_def, _) => {\n-            // If this is a newtype struct, return the constructor.\n-            if struct_def.is_tuple() {\n-                continue_ = callback(struct_def.id());\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    continue_\n-}\n-\n fn encode_reexports(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder,\n                     id: NodeId) {\n@@ -313,13 +292,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n         for item_id in &md.item_ids {\n             self.rbml_w.wr_tagged_u64(tag_mod_child,\n                                  def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n-\n-            let item = ecx.tcx.map.expect_item(item_id.id);\n-            each_auxiliary_node_id(item, |auxiliary_node_id| {\n-                self.rbml_w.wr_tagged_u64(tag_mod_child,\n-                                     def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n-                true\n-            });\n         }\n \n         self.encode_visibility(vis);"}, {"sha": "83f03e7cfc5acc2f09b6379b91295e36ca059f47", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -261,8 +261,8 @@ impl<'b> Resolver<'b> {\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n \n-                // If this is a newtype or unit-like struct, define a name\n-                // in the value namespace as well\n+                // If this is a tuple or unit struct, define a name\n+                // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let def = Def::Struct(self.definitions.local_def_id(struct_def.id()));\n                     self.define(parent, name, ValueNS, (def, sp, vis));"}, {"sha": "67e5ec2616d29e12114f33a7473aec6eee976ead", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -231,7 +231,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n \n                 if cases.len() == 1 && hint == attr::ReprAny {\n-                    // Equivalent to a struct/tuple/newtype.\n+                    // Equivalent to a struct or tuple.\n                     return Univariant(mk_struct(cx, &cases[0].tys, false, t));\n                 }\n "}, {"sha": "709e36989244faa6ea602f609455ad627b5ee9e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::cstore;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, VariantKind};\n use rustc::util::nodemap::FnvHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n@@ -207,11 +207,10 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n-        struct_type: match &variant.fields[..] {\n-            &[] => doctree::Unit,\n-            &[_] if variant.kind == ty::VariantKind::Tuple => doctree::Newtype,\n-            &[..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,\n-            _ => doctree::Plain,\n+        struct_type: match variant.kind {\n+            VariantKind::Struct => doctree::Plain,\n+            VariantKind::Tuple => doctree::Tuple,\n+            VariantKind::Unit => doctree::Unit,\n         },\n         generics: (t.generics, &predicates).clean(cx),\n         fields: variant.fields.clean(cx),"}, {"sha": "c2404f4294e9607d14a496bb07d9a7ec0410dadc", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -82,14 +82,12 @@ impl Module {\n \n #[derive(Debug, Clone, RustcEncodable, RustcDecodable, Copy)]\n pub enum StructType {\n-    /// A normal struct\n+    /// A braced struct\n     Plain,\n     /// A tuple struct\n     Tuple,\n-    /// A newtype struct (tuple struct with one element)\n-    Newtype,\n     /// A unit struct\n-    Unit\n+    Unit,\n }\n \n pub enum TypeBound {\n@@ -262,15 +260,10 @@ pub struct Import {\n     pub whence: Span,\n }\n \n-pub fn struct_type_from_def(sd: &hir::VariantData) -> StructType {\n-    if !sd.is_struct() {\n-        // We are in a tuple-struct\n-        match sd.fields().len() {\n-            0 => Unit,\n-            1 => Newtype,\n-            _ => Tuple\n-        }\n-    } else {\n-        Plain\n+pub fn struct_type_from_def(vdata: &hir::VariantData) -> StructType {\n+    match *vdata {\n+        hir::VariantData::Struct(..) => Plain,\n+        hir::VariantData::Tuple(..) => Tuple,\n+        hir::VariantData::Unit(..) => Unit,\n     }\n }"}, {"sha": "8cc9bbb422ae6f19240c6ac196cd8de8b8c0ffe2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -2546,7 +2546,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             }\n             write!(w, \"}}\")?;\n         }\n-        doctree::Tuple | doctree::Newtype => {\n+        doctree::Tuple => {\n             write!(w, \"(\")?;\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {"}, {"sha": "a46a788ca0808ef01aa409eba76ad10ee177e6ab", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -19,8 +19,7 @@ use parse::parser;\n /// The specific types of unsupported syntax\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n-    ClosureKind,\n-    ExternCrateString,\n+    // Nothing here at the moment\n }\n \n pub trait ParserObsoleteMethods {\n@@ -36,18 +35,10 @@ pub trait ParserObsoleteMethods {\n \n impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n+    #[allow(unused_variables)]\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc, error) = match kind {\n-            ObsoleteSyntax::ClosureKind => (\n-                \"`:`, `&mut:`, or `&:`\",\n-                \"rely on inference instead\",\n-                true,\n-            ),\n-            ObsoleteSyntax::ExternCrateString => (\n-                \"\\\"crate-name\\\"\",\n-                \"use an identifier not in quotes instead\",\n-                false, // warning for now\n-            ),\n+            // Nothing here at the moment\n         };\n \n         self.report(sp, kind, kind_str, desc, error);"}, {"sha": "d0936fd981b508390f488664a1d2937e9c703517", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1265cbf4e05628c98f51afebe0b662c451173faa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1265cbf4e05628c98f51afebe0b662c451173faa", "patch": "@@ -47,7 +47,7 @@ use parse;\n use parse::classify;\n use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n-use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n+use parse::obsolete::ObsoleteSyntax;\n use parse::token::{self, intern, MatchNt, SubstNt, SpecialVarNt, InternedString};\n use parse::token::{keywords, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n@@ -1165,36 +1165,6 @@ impl<'a> Parser<'a> {\n         })))\n     }\n \n-    /// Parses an obsolete closure kind (`&:`, `&mut:`, or `:`).\n-    pub fn parse_obsolete_closure_kind(&mut self) -> PResult<'a, ()> {\n-         let lo = self.span.lo;\n-        if\n-            self.check(&token::BinOp(token::And)) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n-            self.look_ahead(2, |t| *t == token::Colon)\n-        {\n-            self.bump();\n-            self.bump();\n-            self.bump();\n-        } else if\n-            self.token == token::BinOp(token::And) &&\n-            self.look_ahead(1, |t| *t == token::Colon)\n-        {\n-            self.bump();\n-            self.bump();\n-        } else if\n-            self.eat(&token::Colon)\n-        {\n-            /* nothing */\n-        } else {\n-            return Ok(());\n-        }\n-\n-        let span = mk_sp(lo, self.span.hi);\n-        self.obsolete(span, ObsoleteSyntax::ClosureKind);\n-        Ok(())\n-    }\n-\n     pub fn parse_unsafety(&mut self) -> PResult<'a, Unsafety> {\n         if self.eat_keyword(keywords::Unsafe) {\n             return Ok(Unsafety::Unsafe);\n@@ -4728,7 +4698,6 @@ impl<'a> Parser<'a> {\n                 Vec::new()\n             } else {\n                 self.expect(&token::BinOp(token::Or))?;\n-                self.parse_obsolete_closure_kind()?;\n                 let args = self.parse_seq_to_before_end(\n                     &token::BinOp(token::Or),\n                     SeqSep::trailing_allowed(token::Comma),"}, {"sha": "89134e806a75cb0c370d8d33e82f2def9140d8c3", "filename": "src/test/parse-fail/obsolete-closure-kind.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1acabeaa204db9235d9e72c5bae4cfaa82da763/src%2Ftest%2Fparse-fail%2Fobsolete-closure-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1acabeaa204db9235d9e72c5bae4cfaa82da763/src%2Ftest%2Fparse-fail%2Fobsolete-closure-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fobsolete-closure-kind.rs?ref=d1acabeaa204db9235d9e72c5bae4cfaa82da763", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we generate obsolete syntax errors around usages of closure kinds: `|:|`, `|&:|` and\n-// `|&mut:|`.\n-\n-fn main() {\n-    let a = |:| {};  //~ ERROR obsolete syntax: `:`, `&mut:`, or `&:`\n-    let a = |&:| {};  //~ ERROR obsolete syntax: `:`, `&mut:`, or `&:`\n-    let a = |&mut:| {};  //~ ERROR obsolete syntax: `:`, `&mut:`, or `&:`\n-}"}]}