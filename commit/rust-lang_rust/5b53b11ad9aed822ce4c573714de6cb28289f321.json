{"sha": "5b53b11ad9aed822ce4c573714de6cb28289f321", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNTNiMTFhZDlhZWQ4MjJjZTRjNTczNzE0ZGU2Y2IyODI4OWYzMjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-26T11:40:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:21Z"}, "message": "Allow object safe traits to access associated types.", "tree": {"sha": "c8805a1d6523947767861cd2de3ab85441b484a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8805a1d6523947767861cd2de3ab85441b484a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b53b11ad9aed822ce4c573714de6cb28289f321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b53b11ad9aed822ce4c573714de6cb28289f321", "html_url": "https://github.com/rust-lang/rust/commit/5b53b11ad9aed822ce4c573714de6cb28289f321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b53b11ad9aed822ce4c573714de6cb28289f321/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "url": "https://api.github.com/repos/rust-lang/rust/commits/becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "html_url": "https://github.com/rust-lang/rust/commit/becbd81aaa1b8c60eb13fee898163d1a2ac33de3"}], "stats": {"total": 103, "additions": 98, "deletions": 5}, "files": [{"sha": "e8bd5c088fca71b274dc5b2c3c57b82117f88593", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 98, "deletions": 5, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5b53b11ad9aed822ce4c573714de6cb28289f321/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b53b11ad9aed822ce4c573714de6cb28289f321/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=5b53b11ad9aed822ce4c573714de6cb28289f321", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{FnSpace};\n+use middle::subst::{FnSpace, SelfSpace};\n use middle::traits;\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n@@ -141,15 +141,15 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::PolyTraitRef<'tcx>,\n-                                 span: Span) {\n+                                   object_trait: &ty::PolyTraitRef<'tcx>,\n+                                   span: Span) {\n     let trait_items = ty::trait_items(tcx, object_trait.def_id());\n \n     let mut errors = Vec::new();\n     for item in trait_items.iter() {\n         match *item {\n             ty::MethodTraitItem(ref m) => {\n-                errors.push(check_object_safety_of_method(tcx, &**m))\n+                errors.push(check_object_safety_of_method(tcx, object_trait, &**m))\n             }\n             ty::TypeTraitItem(_) => {}\n         }\n@@ -173,6 +173,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n     /// type is not known (that's the whole point of a trait instance, after all, to obscure the\n     /// self type) and (b) the call must go through a vtable and hence cannot be monomorphized.\n     fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           object_trait: &ty::PolyTraitRef<'tcx>,\n                                            method: &ty::Method<'tcx>)\n                                            -> Vec<String> {\n         let mut msgs = Vec::new();\n@@ -196,7 +197,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // reason (a) above\n         let check_for_self_ty = |ty| {\n-            if ty::type_has_self(ty) {\n+            if contains_illegal_self_type_reference(tcx, object_trait.def_id(), ty) {\n                 Some(format!(\n                     \"cannot call a method (`{}`) whose type contains \\\n                      a self-type (`{}`) through a trait object\",\n@@ -225,6 +226,98 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         msgs\n     }\n+\n+    fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                  trait_def_id: ast::DefId,\n+                                                  ty: Ty<'tcx>)\n+                                                  -> bool\n+    {\n+        // This is somewhat subtle. In general, we want to forbid\n+        // references to `Self` in the argument and return types,\n+        // since the value of `Self` is erased. However, there is one\n+        // exception: it is ok to reference `Self` in order to access\n+        // an associated type of the current trait, since we retain\n+        // the value of those associated types in the object type\n+        // itself.\n+        //\n+        // ```rust\n+        // trait SuperTrait {\n+        //     type X;\n+        // }\n+        //\n+        // trait Trait : SuperTrait {\n+        //     type Y;\n+        //     fn foo(&self, x: Self) // bad\n+        //     fn foo(&self) -> Self // bad\n+        //     fn foo(&self) -> Option<Self> // bad\n+        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as Trait>::Y // OK\n+        //     fn foo(&self) -> Self::X // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+        // }\n+        // ```\n+        //\n+        // However, it is not as simple as allowing `Self` in a projected\n+        // type, because there are illegal ways to use `Self` as well:\n+        //\n+        // ```rust\n+        // trait Trait : SuperTrait {\n+        //     ...\n+        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+        // }\n+        // ```\n+        //\n+        // Here we will not have the type of `X` recorded in the\n+        // object type, and we cannot resolve `Self as SomeOtherTrait`\n+        // without knowing what `Self` is.\n+\n+        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+        let mut error = false;\n+        ty::maybe_walk_ty(ty, |ty| {\n+            match ty.sty {\n+                ty::ty_param(ref param_ty) => {\n+                    if param_ty.space == SelfSpace {\n+                        error = true;\n+                    }\n+\n+                    false // no contained types to walk\n+                }\n+\n+                ty::ty_projection(ref data) => {\n+                    // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                    // Compute supertraits of current trait lazilly.\n+                    if supertraits.is_none() {\n+                        let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+                    }\n+\n+                    // Determine whether the trait reference `Foo as\n+                    // SomeTrait` is in fact a supertrait of the\n+                    // current trait. In that case, this type is\n+                    // legal, because the type `X` will be specified\n+                    // in the object type.  Note that we can just use\n+                    // direct equality here because all of these types\n+                    // are part of the formal parameter listing, and\n+                    // hence there should be no inference variables.\n+                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                    let is_supertrait_of_current_trait =\n+                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                    if is_supertrait_of_current_trait {\n+                        false // do not walk contained types, do not report error, do collect $200\n+                    } else {\n+                        true // DO walk contained types, POSSIBLY reporting an error\n+                    }\n+                }\n+\n+                _ => true, // walk contained types, if any\n+            }\n+        });\n+\n+        error\n+    }\n }\n \n pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}]}