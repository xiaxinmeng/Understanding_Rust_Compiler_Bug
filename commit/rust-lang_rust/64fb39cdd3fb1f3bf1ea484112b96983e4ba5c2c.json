{"sha": "64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZmIzOWNkZDNmYjFmM2JmMWVhNDg0MTEyYjk2OTgzZTRiYTVjMmM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-20T02:13:20Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-20T02:52:21Z"}, "message": "Clean up formatting.", "tree": {"sha": "da0a85bc4fc4125d96b1f3e69a91fb926add832f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da0a85bc4fc4125d96b1f3e69a91fb926add832f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c", "html_url": "https://github.com/rust-lang/rust/commit/64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "html_url": "https://github.com/rust-lang/rust/commit/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6"}], "stats": {"total": 23, "additions": 10, "deletions": 13}, "files": [{"sha": "1ba59e7c1eae4f368436d9e7a4551127f2bce547", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=64fb39cdd3fb1f3bf1ea484112b96983e4ba5c2c", "patch": "@@ -1,4 +1,3 @@\n-\n import syntax::ast;\n import ast::mutability;\n import ast::local_def;\n@@ -186,8 +185,8 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n         ty_substs_opt = some[ty::t[]](ty_substs);\n         if (ty_param_count == 0u) {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n-                                      \"this item does not take type \" +\n-                                          \"parameters\");\n+                                      \"this item does not take type \\\n+                                      parameters\");\n             fail;\n         }\n     } else {\n@@ -1527,10 +1526,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     fn check_call_or_bind(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n                &(option::t[@ast::expr])[] args, call_kind call_kind) {\n         // Check the function.\n-\n         check_expr(fcx, f);\n-        // Get the function type.\n \n+        // Get the function type.\n         auto fty = expr_ty(fcx.ccx.tcx, f);\n \n         // We want to autoderef calls but not binds\n@@ -1551,8 +1549,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                           + ty_to_str(fcx.ccx.tcx, fty));\n             }\n         }\n-        // Check that the correct number of arguments were supplied.\n \n+        // Check that the correct number of arguments were supplied.\n         auto expected_arg_count = ivec::len[ty::arg](arg_tys);\n         auto supplied_arg_count = ivec::len[option::t[@ast::expr]](args);\n         if (expected_arg_count != supplied_arg_count) {\n@@ -1568,9 +1566,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                \" was\"\n                                            } else { \"s were\" }));\n         }\n+\n         // Check the arguments.\n         // TODO: iter2\n-\n         auto i = 0u;\n         for (option::t[@ast::expr] a_opt in args) {\n             auto check_ty_vars = call_kind == kind_spawn;\n@@ -2486,9 +2484,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n \n             write::ty_only_fixup(fcx, id, ot);\n+\n             // Write the methods into the node type table.  (This happens in\n             // collect::convert for regular objects.)\n-\n             auto i = 0u;\n             while (i < ivec::len[@ast::method](ao.methods)) {\n                 write::ty_only(fcx.ccx.tcx, ao.methods.(i).node.id,\n@@ -2569,7 +2567,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::local local) {\n     alt (fcx.locals.find(a_id)) {\n         case (none) {\n             fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n-                                     local.node.ident);\n+                                 local.node.ident);\n         }\n         case (some(?i)) {\n             auto t = ty::mk_var(fcx.ccx.tcx, i);\n@@ -2650,12 +2648,11 @@ fn check_fn(&@crate_ctxt ccx, &ast::_fn f, &ast::node_id id) {\n     check_block(fcx, body);\n     alt (decl.purity) {\n         case (ast::pure_fn) {\n-\n-            // per the previous comment, this just checks that the declared\n-            // type is bool, and trusts that that's the actual return type.\n+            // This just checks that the declared type is bool, and trusts\n+            // that that's the actual return type.\n             if (!ty::type_is_bool(ccx.tcx, fcx.ret_ty)) {\n                 ccx.tcx.sess.span_fatal(body.span,\n-                                      \"Non-boolean return type in pred\");\n+                                        \"Non-boolean return type in pred\");\n             }\n         }\n         case (_) { }"}]}