{"sha": "0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NTc4MTJiYzJmOTUwMzdiNWUyZWZiZThmYmZjODBmYjI4NDkyYzE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-18T16:47:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-18T16:47:58Z"}, "message": "Merge #9321\n\n9321: Inline generics in const and function trait completions r=Veykril a=RDambrosio016\n\nThis PR does a couple of things:\r\n- moves path_transform from ide_assists to ide_db to be shared by both assists and completions\r\n- when completing a const or a function for a trait, it will \"inline\" any generics in those associated items instead \r\nof leaving the generic's name. For example:\r\n```rust\r\ntrait Foo<T> {\r\n    const BAR: T;\r\n    fn foo() -> T;\r\n}\r\nstruct Bar;\r\n\r\nimpl Foo<u32> for Bar {\r\n    // autocompletes to this\r\n    fn foo() -> u32;\r\n\r\n    // and not this (old)\r\n    fn foo() -> T;\r\n\r\n    // also works for associated consts and where clauses\r\n    const BAR: u32 = /* */\r\n}\r\n```\r\n\r\nCurrently this does not work for const generics, because `PathTransform` does not seem to account for them. If this should work on const generics too, `PathTransform` will need to be changed. However, it is uncommon to implement a trait only for a single const value, so this isnt a huge concern.\n\nCo-authored-by: rdambrosio <rdambrosio016@gmail.com>", "tree": {"sha": "1e2df163514b45efc2af9b159bd44f62be0cf9a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2df163514b45efc2af9b159bd44f62be0cf9a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgzM4+CRBK7hj4Ov3rIwAAGCEIAJcWD1zlWeBm+iBYw1ZlpazU\nZ7jFlgDs9N0zmQALYiA52y3f1TAf3bs6hiLHzPdGAeG+bnRAONsX5M8RblGhid+e\nzsgi2FTBWRaosofb5kzdvd594nJtbbUp9nkykgxomDChTieBflijeVUVZs4q31ER\nnxRsVwyxp6KkDxjxx4p0xSFjuZXwCdwLuDdWMJbQGNyCCBsMThMpjqIoQLtGGkqN\ngqxI7Me++kagriXYrMH3cjqbvzfioDonDHMxR20kOys4Ir5UQez31fO40uEGpW81\nNJO7In6Amj5ktDVwseiVdsl6rnIfOQJlj0yTYkbJC0Bur/9nqK6xwNvXL5Ny7EI=\n=j5oQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e2df163514b45efc2af9b159bd44f62be0cf9a6\nparent 7eb843b218b5e10b39a5171f5b9689ec6c2d71c3\nparent b3e5c648e0def7a359a75b2b5023c18aceda83d3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624034878 +0000\ncommitter GitHub <noreply@github.com> 1624034878 +0000\n\nMerge #9321\n\n9321: Inline generics in const and function trait completions r=Veykril a=RDambrosio016\n\nThis PR does a couple of things:\r\n- moves path_transform from ide_assists to ide_db to be shared by both assists and completions\r\n- when completing a const or a function for a trait, it will \"inline\" any generics in those associated items instead \r\nof leaving the generic's name. For example:\r\n```rust\r\ntrait Foo<T> {\r\n    const BAR: T;\r\n    fn foo() -> T;\r\n}\r\nstruct Bar;\r\n\r\nimpl Foo<u32> for Bar {\r\n    // autocompletes to this\r\n    fn foo() -> u32;\r\n\r\n    // and not this (old)\r\n    fn foo() -> T;\r\n\r\n    // also works for associated consts and where clauses\r\n    const BAR: u32 = /* */\r\n}\r\n```\r\n\r\nCurrently this does not work for const generics, because `PathTransform` does not seem to account for them. If this should work on const generics too, `PathTransform` will need to be changed. However, it is uncommon to implement a trait only for a single const value, so this isnt a huge concern.\n\nCo-authored-by: rdambrosio <rdambrosio016@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "html_url": "https://github.com/rust-lang/rust/commit/0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eb843b218b5e10b39a5171f5b9689ec6c2d71c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eb843b218b5e10b39a5171f5b9689ec6c2d71c3", "html_url": "https://github.com/rust-lang/rust/commit/7eb843b218b5e10b39a5171f5b9689ec6c2d71c3"}, {"sha": "b3e5c648e0def7a359a75b2b5023c18aceda83d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3e5c648e0def7a359a75b2b5023c18aceda83d3", "html_url": "https://github.com/rust-lang/rust/commit/b3e5c648e0def7a359a75b2b5023c18aceda83d3"}], "stats": {"total": 329, "additions": 275, "deletions": 54}, "files": [{"sha": "86a57ce5dcaa9d8bddc6f9405bf001e0cfae8479", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "patch": "@@ -15,7 +15,6 @@ mod assist_context;\n #[cfg(test)]\n mod tests;\n pub mod utils;\n-pub mod path_transform;\n \n use hir::Semantics;\n use ide_db::{base_db::FileRange, RootDatabase};"}, {"sha": "0ec236aa0c7232e3efa08c367e0533e472201aa9", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "patch": "@@ -8,6 +8,7 @@ use ast::TypeBoundsOwner;\n use hir::{Adt, HasSource, Semantics};\n use ide_db::{\n     helpers::{FamousDefs, SnippetCap},\n+    path_transform::PathTransform,\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -22,10 +23,7 @@ use syntax::{\n     SyntaxNode, TextSize, T,\n };\n \n-use crate::{\n-    assist_context::{AssistBuilder, AssistContext},\n-    path_transform::PathTransform,\n-};\n+use crate::assist_context::{AssistBuilder, AssistContext};\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block)"}, {"sha": "65f0f38430c5f2261d240c8274b6e3bcfa6fae23", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 266, "deletions": 43, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "patch": "@@ -32,7 +32,7 @@\n //! ```\n \n use hir::{self, HasAttrs, HasSource};\n-use ide_db::{traits::get_missing_assoc_items, SymbolKind};\n+use ide_db::{path_transform::PathTransform, traits::get_missing_assoc_items, SymbolKind};\n use syntax::{\n     ast::{self, edit},\n     display::function_declaration,\n@@ -52,24 +52,26 @@ enum ImplCompletionKind {\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n     if let Some((kind, trigger, impl_def)) = completion_match(ctx.token.clone()) {\n-        get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| match item {\n-            hir::AssocItem::Function(fn_item)\n-                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Fn =>\n-            {\n-                add_function_impl(&trigger, acc, ctx, fn_item)\n-            }\n-            hir::AssocItem::TypeAlias(type_item)\n-                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::TypeAlias =>\n-            {\n-                add_type_alias_impl(&trigger, acc, ctx, type_item)\n-            }\n-            hir::AssocItem::Const(const_item)\n-                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Const =>\n-            {\n-                add_const_impl(&trigger, acc, ctx, const_item)\n-            }\n-            _ => {}\n-        });\n+        if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n+            get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| match item {\n+                hir::AssocItem::Function(fn_item)\n+                    if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Fn =>\n+                {\n+                    add_function_impl(&trigger, acc, ctx, fn_item, hir_impl)\n+                }\n+                hir::AssocItem::TypeAlias(type_item)\n+                    if kind == ImplCompletionKind::All || kind == ImplCompletionKind::TypeAlias =>\n+                {\n+                    add_type_alias_impl(&trigger, acc, ctx, type_item)\n+                }\n+                hir::AssocItem::Const(const_item)\n+                    if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Const =>\n+                {\n+                    add_const_impl(&trigger, acc, ctx, const_item, hir_impl)\n+                }\n+                _ => {}\n+            });\n+        }\n     }\n }\n \n@@ -129,6 +131,7 @@ fn add_function_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     func: hir::Function,\n+    impl_def: hir::Impl,\n ) {\n     let fn_name = func.name(ctx.db).to_string();\n \n@@ -147,23 +150,55 @@ fn add_function_impl(\n         CompletionItemKind::SymbolKind(SymbolKind::Function)\n     };\n     let range = replacement_range(ctx, fn_def_node);\n-    if let Some(src) = func.source(ctx.db) {\n-        let function_decl = function_declaration(&src.value);\n-        match ctx.config.snippet_cap {\n-            Some(cap) => {\n-                let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n-                item.snippet_edit(cap, TextEdit::replace(range, snippet));\n-            }\n-            None => {\n-                let header = format!(\"{} {{\", function_decl);\n-                item.text_edit(TextEdit::replace(range, header));\n-            }\n-        };\n-        item.kind(completion_kind);\n-        item.add_to(acc);\n+\n+    if let Some(source) = func.source(ctx.db) {\n+        let assoc_item = ast::AssocItem::Fn(source.value);\n+        if let Some(transformed_item) = get_transformed_assoc_item(ctx, assoc_item, impl_def) {\n+            let transformed_fn = match transformed_item {\n+                ast::AssocItem::Fn(func) => func,\n+                _ => unreachable!(),\n+            };\n+\n+            let function_decl = function_declaration(&transformed_fn);\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n+                    item.snippet_edit(cap, TextEdit::replace(range, snippet));\n+                }\n+                None => {\n+                    let header = format!(\"{} {{\", function_decl);\n+                    item.text_edit(TextEdit::replace(range, header));\n+                }\n+            };\n+            item.kind(completion_kind);\n+            item.add_to(acc);\n+        }\n     }\n }\n \n+/// Transform a relevant associated item to inline generics from the impl, remove attrs and docs, etc.\n+fn get_transformed_assoc_item(\n+    ctx: &CompletionContext,\n+    assoc_item: ast::AssocItem,\n+    impl_def: hir::Impl,\n+) -> Option<ast::AssocItem> {\n+    let assoc_item = assoc_item.clone_for_update();\n+    let trait_ = impl_def.trait_(ctx.db)?;\n+    let source_scope = &ctx.sema.scope_for_def(trait_);\n+    let target_scope = &ctx.sema.scope(impl_def.source(ctx.db)?.syntax().value);\n+    let transform = PathTransform {\n+        subst: (trait_, impl_def.source(ctx.db)?.value),\n+        source_scope,\n+        target_scope,\n+    };\n+\n+    transform.apply(assoc_item.clone());\n+    Some(match assoc_item {\n+        ast::AssocItem::Fn(func) => ast::AssocItem::Fn(edit::remove_attrs_and_docs(&func)),\n+        _ => assoc_item,\n+    })\n+}\n+\n fn add_type_alias_impl(\n     type_def_node: &SyntaxNode,\n     acc: &mut Completions,\n@@ -188,21 +223,30 @@ fn add_const_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     const_: hir::Const,\n+    impl_def: hir::Impl,\n ) {\n     let const_name = const_.name(ctx.db).map(|n| n.to_string());\n \n     if let Some(const_name) = const_name {\n         if let Some(source) = const_.source(ctx.db) {\n-            let snippet = make_const_compl_syntax(&source.value);\n-\n-            let range = replacement_range(ctx, const_def_node);\n-            let mut item =\n-                CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone());\n-            item.text_edit(TextEdit::replace(range, snippet))\n-                .lookup_by(const_name)\n-                .kind(SymbolKind::Const)\n-                .set_documentation(const_.docs(ctx.db));\n-            item.add_to(acc);\n+            let assoc_item = ast::AssocItem::Const(source.value);\n+            if let Some(transformed_item) = get_transformed_assoc_item(ctx, assoc_item, impl_def) {\n+                let transformed_const = match transformed_item {\n+                    ast::AssocItem::Const(const_) => const_,\n+                    _ => unreachable!(),\n+                };\n+\n+                let snippet = make_const_compl_syntax(&transformed_const);\n+\n+                let range = replacement_range(ctx, const_def_node);\n+                let mut item =\n+                    CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone());\n+                item.text_edit(TextEdit::replace(range, snippet))\n+                    .lookup_by(const_name)\n+                    .kind(SymbolKind::Const)\n+                    .set_documentation(const_.docs(ctx.db));\n+                item.add_to(acc);\n+            }\n         }\n     }\n }\n@@ -779,4 +823,183 @@ impl Foo for T {{\n         test(\"Type\", \"type T$0\", \"type Type = \");\n         test(\"CONST\", \"const C$0\", \"const CONST: i32 = \");\n     }\n+\n+    #[test]\n+    fn generics_are_inlined_in_return_type() {\n+        check_edit(\n+            \"function\",\n+            r#\"\n+trait Foo<T> {\n+    fn function() -> T;\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn f$0\n+}\n+\"#,\n+            r#\"\n+trait Foo<T> {\n+    fn function() -> T;\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn function() -> u32 {\n+    $0\n+}\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generics_are_inlined_in_parameter() {\n+        check_edit(\n+            \"function\",\n+            r#\"\n+trait Foo<T> {\n+    fn function(bar: T);\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn f$0\n+}\n+\"#,\n+            r#\"\n+trait Foo<T> {\n+    fn function(bar: T);\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn function(bar: u32) {\n+    $0\n+}\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generics_are_inlined_when_part_of_other_types() {\n+        check_edit(\n+            \"function\",\n+            r#\"\n+trait Foo<T> {\n+    fn function(bar: Vec<T>);\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn f$0\n+}\n+\"#,\n+            r#\"\n+trait Foo<T> {\n+    fn function(bar: Vec<T>);\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn function(bar: Vec<u32>) {\n+    $0\n+}\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generics_are_inlined_complex() {\n+        check_edit(\n+            \"function\",\n+            r#\"\n+trait Foo<T, U, V> {\n+    fn function(bar: Vec<T>, baz: U) -> Arc<Vec<V>>;\n+}\n+struct Bar;\n+\n+impl Foo<u32, Vec<usize>, u8> for Bar {\n+    fn f$0\n+}\n+\"#,\n+            r#\"\n+trait Foo<T, U, V> {\n+    fn function(bar: Vec<T>, baz: U) -> Arc<Vec<V>>;\n+}\n+struct Bar;\n+\n+impl Foo<u32, Vec<usize>, u8> for Bar {\n+    fn function(bar: Vec<u32>, baz: Vec<usize>) -> Arc<Vec<u8>> {\n+    $0\n+}\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generics_are_inlined_in_associated_const() {\n+        check_edit(\n+            \"BAR\",\n+            r#\"\n+trait Foo<T> {\n+    const BAR: T;\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    const B$0;\n+}\n+\"#,\n+            r#\"\n+trait Foo<T> {\n+    const BAR: T;\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    const BAR: u32 = ;\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generics_are_inlined_in_where_clause() {\n+        check_edit(\n+            \"function\",\n+            r#\"\n+trait SomeTrait<T> {}\n+\n+trait Foo<T> {\n+    fn function()\n+    where Self: SomeTrait<T>;\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn f$0\n+}\n+\"#,\n+            r#\"\n+trait SomeTrait<T> {}\n+\n+trait Foo<T> {\n+    fn function()\n+    where Self: SomeTrait<T>;\n+}\n+struct Bar;\n+\n+impl Foo<u32> for Bar {\n+    fn function()\n+where Self: SomeTrait<u32> {\n+    $0\n+}\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "bde8767dd68fdc3c6997aa57bc7b1249740f2098", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "patch": "@@ -14,6 +14,7 @@ pub mod ty_filter;\n pub mod traits;\n pub mod call_info;\n pub mod helpers;\n+pub mod path_transform;\n \n pub mod search;\n pub mod rename;"}, {"sha": "f3d7aa920c09ac8dff31548cae271dc8939df1ff", "filename": "crates/ide_db/src/path_transform.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0657812bc2f95037b5e2efbe8fbfc80fb28492c1/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=0657812bc2f95037b5e2efbe8fbfc80fb28492c1", "patch": "@@ -1,7 +1,7 @@\n //! See [`PathTransform`].\n \n+use crate::helpers::mod_path_to_ast;\n use hir::{HirDisplay, SemanticsScope};\n-use ide_db::helpers::mod_path_to_ast;\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstNode},\n@@ -31,14 +31,14 @@ use syntax::{\n ///   }\n /// }\n /// ```\n-pub(crate) struct PathTransform<'a> {\n-    pub(crate) subst: (hir::Trait, ast::Impl),\n-    pub(crate) target_scope: &'a SemanticsScope<'a>,\n-    pub(crate) source_scope: &'a SemanticsScope<'a>,\n+pub struct PathTransform<'a> {\n+    pub subst: (hir::Trait, ast::Impl),\n+    pub target_scope: &'a SemanticsScope<'a>,\n+    pub source_scope: &'a SemanticsScope<'a>,\n }\n \n impl<'a> PathTransform<'a> {\n-    pub(crate) fn apply(&self, item: ast::AssocItem) {\n+    pub fn apply(&self, item: ast::AssocItem) {\n         if let Some(ctx) = self.build_ctx() {\n             ctx.apply(item)\n         }", "previous_filename": "crates/ide_assists/src/path_transform.rs"}]}