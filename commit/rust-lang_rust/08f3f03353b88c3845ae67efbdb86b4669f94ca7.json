{"sha": "08f3f03353b88c3845ae67efbdb86b4669f94ca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjNmMDMzNTNiODhjMzg0NWFlNjdlZmJkYjg2YjQ2NjlmOTRjYTc=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-11T12:52:27Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-11T12:52:27Z"}, "message": "Implement combining against match arms", "tree": {"sha": "df2c3f11d06f5396c7a5326e2656da09db8c4bfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2c3f11d06f5396c7a5326e2656da09db8c4bfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f3f03353b88c3845ae67efbdb86b4669f94ca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f3f03353b88c3845ae67efbdb86b4669f94ca7", "html_url": "https://github.com/rust-lang/rust/commit/08f3f03353b88c3845ae67efbdb86b4669f94ca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f3f03353b88c3845ae67efbdb86b4669f94ca7/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3552595a3b40abd1aa5a24074f4ab2caa2fa034f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3552595a3b40abd1aa5a24074f4ab2caa2fa034f", "html_url": "https://github.com/rust-lang/rust/commit/3552595a3b40abd1aa5a24074f4ab2caa2fa034f"}], "stats": {"total": 419, "additions": 209, "deletions": 210}, "files": [{"sha": "d60377df65a0372c32496dcf621a81b7b20be18e", "filename": "src/expr.rs", "status": "modified", "additions": 198, "deletions": 210, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/08f3f03353b88c3845ae67efbdb86b4669f94ca7/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3f03353b88c3845ae67efbdb86b4669f94ca7/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=08f3f03353b88c3845ae67efbdb86b4669f94ca7", "patch": "@@ -1553,27 +1553,96 @@ fn rewrite_match(\n         ControlBraceStyle::AlwaysNextLine => alt_block_sep.as_str(),\n         _ => \" \",\n     };\n-    let mut result = format!(\"match {}{}{{\", cond_str, block_sep);\n+\n+    Some(format!(\n+        \"match {}{}{{{}\\n{}}}\",\n+        cond_str,\n+        block_sep,\n+        try_opt!(rewrite_match_arms(context, arms, shape, span, cond.span.hi)),\n+        shape.indent.to_string(context.config),\n+    ))\n+}\n+\n+fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n+    if config.match_block_trailing_comma() {\n+        \",\"\n+    } else if let ast::ExprKind::Block(ref block) = body.node {\n+        if let ast::BlockCheckMode::Default = block.rules {\n+            \"\"\n+        } else {\n+            \",\"\n+        }\n+    } else {\n+        \",\"\n+    }\n+}\n+\n+fn rewrite_match_pattern(\n+    context: &RewriteContext,\n+    pats: &Vec<ptr::P<ast::Pat>>,\n+    guard: &Option<ptr::P<ast::Expr>>,\n+    shape: Shape,\n+) -> Option<String> {\n+    // Patterns\n+    // 5 = ` => {`\n+    let pat_shape = try_opt!(shape.sub_width(5));\n+\n+    let pat_strs = try_opt!(\n+        pats.iter()\n+            .map(|p| p.rewrite(context, pat_shape))\n+            .collect::<Option<Vec<_>>>()\n+    );\n+\n+    let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n+    let tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \" |\",\n+        trailing_separator: SeparatorTactic::Never,\n+        shape: pat_shape,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n+    let pats_str = try_opt!(write_list(&items, &fmt));\n+\n+    // Guard\n+    let guard_str = try_opt!(rewrite_guard(\n+        context,\n+        guard,\n+        shape,\n+        trimmed_last_line_width(&pats_str),\n+    ));\n+\n+    Some(format!(\"{}{}\", pats_str, guard_str))\n+}\n+\n+fn rewrite_match_arms(\n+    context: &RewriteContext,\n+    arms: &[ast::Arm],\n+    shape: Shape,\n+    span: Span,\n+    cond_end_pos: BytePos,\n+) -> Option<String> {\n+    let mut result = String::new();\n \n     let arm_shape = if context.config.indent_match_arms() {\n         shape.block_indent(context.config.tab_spaces())\n     } else {\n         shape.block_indent(0)\n-    };\n-\n+    }.with_max_width(context.config);\n     let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n     let open_brace_pos = context\n         .codemap\n-        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n+        .span_after(mk_sp(cond_end_pos, arms[0].span().lo), \"{\");\n \n     let arm_num = arms.len();\n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n         let missed_str = if i == 0 {\n-            context.snippet(mk_sp(open_brace_pos, arm_start_pos(arm)))\n+            context.snippet(mk_sp(open_brace_pos, arm.span().lo))\n         } else {\n-            context.snippet(mk_sp(arm_end_pos(&arms[i - 1]), arm_start_pos(arm)))\n+            context.snippet(mk_sp(arms[i - 1].span().hi, arm.span().lo))\n         };\n         let comment = try_opt!(rewrite_match_arm_comment(\n             context,\n@@ -1585,7 +1654,7 @@ fn rewrite_match(\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n \n-        let arm_str = arm.rewrite(&context, arm_shape.with_max_width(context.config));\n+        let arm_str = rewrite_match_arm(context, arm, arm_shape);\n         if let Some(ref arm_str) = arm_str {\n             // Trim the trailing comma if necessary.\n             if i == arm_num - 1 && context.config.trailing_comma() == SeparatorTactic::Never &&\n@@ -1597,15 +1666,15 @@ fn rewrite_match(\n             }\n         } else {\n             // We couldn't format the arm, just reproduce the source.\n-            let snippet = context.snippet(mk_sp(arm_start_pos(arm), arm_end_pos(arm)));\n+            let snippet = context.snippet(arm.span());\n             result.push_str(&snippet);\n             if context.config.trailing_comma() != SeparatorTactic::Never {\n                 result.push_str(arm_comma(context.config, &arm.body))\n             }\n         }\n     }\n     // BytePos(1) = closing match brace.\n-    let last_span = mk_sp(arm_end_pos(&arms[arms.len() - 1]), span.hi - BytePos(1));\n+    let last_span = mk_sp(arms[arms.len() - 1].span().hi, span.hi - BytePos(1));\n     let last_comment = context.snippet(last_span);\n     let comment = try_opt!(rewrite_match_arm_comment(\n         context,\n@@ -1614,223 +1683,146 @@ fn rewrite_match(\n         &arm_indent_str,\n     ));\n     result.push_str(&comment);\n-    result.push('\\n');\n-    result.push_str(&shape.indent.to_string(context.config));\n-    result.push('}');\n-    Some(result)\n-}\n-\n-fn arm_start_pos(arm: &ast::Arm) -> BytePos {\n-    let &ast::Arm {\n-        ref attrs,\n-        ref pats,\n-        ..\n-    } = arm;\n-    if !attrs.is_empty() {\n-        return attrs[0].span.lo;\n-    }\n \n-    pats[0].span.lo\n-}\n-\n-fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n-    arm.body.span.hi\n+    Some(result)\n }\n \n-fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n-    if config.match_block_trailing_comma() {\n-        \",\"\n-    } else if let ast::ExprKind::Block(ref block) = body.node {\n-        if let ast::BlockCheckMode::Default = block.rules {\n-            \"\"\n-        } else {\n-            \",\"\n+fn rewrite_match_arm(context: &RewriteContext, arm: &ast::Arm, shape: Shape) -> Option<String> {\n+    let attr_str = if !arm.attrs.is_empty() {\n+        if contains_skip(&arm.attrs) {\n+            return None;\n         }\n+        format!(\n+            \"{}\\n{}\",\n+            try_opt!(arm.attrs.rewrite(context, shape)),\n+            shape.indent.to_string(context.config)\n+        )\n     } else {\n-        \",\"\n-    }\n+        String::new()\n+    };\n+    let pats_str = try_opt!(rewrite_match_pattern(context, &arm.pats, &arm.guard, shape));\n+    let pats_str = attr_str + &pats_str;\n+    rewrite_match_body(context, &arm.body, &pats_str, shape, arm.guard.is_some())\n }\n \n-// Match arms.\n-impl Rewrite for ast::Arm {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        debug!(\"Arm::rewrite {:?} {:?}\", self, shape);\n-        let &ast::Arm {\n-            ref attrs,\n-            ref pats,\n-            ref guard,\n-            ref body,\n-        } = self;\n-\n-        let attr_str = if !attrs.is_empty() {\n-            if contains_skip(attrs) {\n-                return None;\n+fn rewrite_match_body(\n+    context: &RewriteContext,\n+    body: &ptr::P<ast::Expr>,\n+    pats_str: &str,\n+    shape: Shape,\n+    has_guard: bool,\n+) -> Option<String> {\n+    let (extend, body) = match body.node {\n+        ast::ExprKind::Block(ref block)\n+            if !is_unsafe_block(block) && is_simple_block(block, context.codemap) => {\n+            if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n+                (expr.can_be_overflowed(context, 1), &**expr)\n+            } else {\n+                (false, &**body)\n             }\n-            format!(\n-                \"{}\\n{}\",\n-                try_opt!(attrs.rewrite(context, shape)),\n-                shape.indent.to_string(context.config)\n-            )\n-        } else {\n-            String::new()\n-        };\n-\n-        // Patterns\n-        // 5 = ` => {`\n-        let pat_shape = try_opt!(shape.sub_width(5));\n-\n-        let pat_strs = try_opt!(\n-            pats.iter()\n-                .map(|p| p.rewrite(context, pat_shape))\n-                .collect::<Option<Vec<_>>>()\n-        );\n-\n-        let all_simple = pat_strs.iter().all(|p| !p.contains('\\n'));\n-        let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n-        let mut tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n-        if tactic == DefinitiveListTactic::Horizontal && all_simple {\n-            tactic = DefinitiveListTactic::Mixed;\n-        }\n-        let fmt = ListFormatting {\n-            tactic: tactic,\n-            separator: \" |\",\n-            trailing_separator: SeparatorTactic::Never,\n-            shape: pat_shape,\n-            ends_with_newline: false,\n-            config: context.config,\n-        };\n-        let pats_str = try_opt!(write_list(&items, &fmt));\n-\n-        let guard_str = try_opt!(rewrite_guard(\n-            context,\n-            guard,\n-            shape,\n-            trimmed_last_line_width(&pats_str),\n-        ));\n+        }\n+        _ => (body.can_be_overflowed(context, 1), &**body),\n+    };\n \n-        let pats_len = pats_str.len();\n-        let pats_str = format!(\"{}{}\", pats_str, guard_str);\n+    let comma = arm_comma(&context.config, body);\n+    let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+    let alt_block_sep = alt_block_sep.as_str();\n+    let is_block = if let ast::ExprKind::Block(..) = body.node {\n+        true\n+    } else {\n+        false\n+    };\n \n-        let (mut extend, body) = match body.node {\n-            ast::ExprKind::Block(ref block)\n-                if !is_unsafe_block(block) && is_simple_block(block, context.codemap) &&\n-                    context.config.wrap_match_arms() => {\n-                if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n-                    (false, &**expr)\n-                } else {\n-                    (false, &**body)\n-                }\n+    let combine_orig_body = |body_str: &str| {\n+        let block_sep = match context.config.control_brace_style() {\n+            ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep,\n+            _ if has_guard && pats_str.contains('\\n') && is_block && body_str != \"{}\" => {\n+                alt_block_sep\n             }\n-            ast::ExprKind::Call(_, ref args) => (args.len() == 1, &**body),\n-            ast::ExprKind::Closure(..) | ast::ExprKind::Struct(..) | ast::ExprKind::Tup(..) => (\n-                true,\n-                &**body,\n-            ),\n-            _ => (false, &**body),\n+            _ => \" \",\n         };\n-        extend &= context.use_block_indent();\n-\n-        let comma = arm_comma(&context.config, body);\n-        let alt_block_sep =\n-            String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-\n-        let pat_width = extra_offset(&pats_str, shape);\n-        // Let's try and get the arm body on the same line as the condition.\n-        // 4 = ` => `.len()\n-        if shape.width > pat_width + comma.len() + 4 {\n-            let arm_shape = shape\n-                .offset_left(pat_width + 4)\n-                .unwrap()\n-                .sub_width(comma.len())\n-                .unwrap();\n-            let rewrite = nop_block_collapse(\n-                format_expr(body, ExprType::Statement, context, arm_shape),\n-                arm_shape.width,\n-            );\n-            let is_block = if let ast::ExprKind::Block(..) = body.node {\n-                true\n-            } else {\n-                false\n-            };\n \n-            match rewrite {\n-                Some(ref body_str)\n-                    if (!body_str.contains('\\n') && body_str.len() <= arm_shape.width) ||\n-                        !context.config.wrap_match_arms() ||\n-                        (extend && first_line_width(body_str) <= arm_shape.width) ||\n-                        is_block =>\n-                {\n-                    let block_sep = match context.config.control_brace_style() {\n-                        ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n-                        _ if guard.is_some() && pats_str.contains('\\n') && is_block &&\n-                            body_str != \"{}\" &&\n-                            pats_len > context.config.tab_spaces() => alt_block_sep.as_str(),\n-                        _ => \" \",\n-                    };\n-\n-                    return Some(format!(\n-                        \"{}{} =>{}{}{}\",\n-                        attr_str.trim_left(),\n-                        pats_str,\n-                        block_sep,\n-                        body_str,\n-                        comma\n-                    ));\n-                }\n-                _ => {}\n-            }\n-        }\n+        Some(format!(\"{} =>{}{}{}\", pats_str, block_sep, body_str, comma))\n+    };\n \n-        // FIXME: we're doing a second rewrite of the expr; This may not be\n-        // necessary.\n-        let body_shape = try_opt!(shape.block_left(context.config.tab_spaces()));\n-        let next_line_body = try_opt!(nop_block_collapse(\n-            format_expr(body, ExprType::Statement, context, body_shape),\n-            body_shape.width,\n-        ));\n+    let combine_next_line_body = |body_str: &str| {\n         let indent_str = shape\n             .indent\n             .block_indent(context.config)\n             .to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms() {\n-            if context.config.match_block_trailing_comma() {\n-                (\"{\", \"},\")\n+            let comma = if context.config.match_block_trailing_comma() {\n+                \",\"\n             } else {\n-                (\"{\", \"}\")\n-            }\n+                \"\"\n+            };\n+            (\n+                \"{\",\n+                format!(\"\\n{}}}{}\", shape.indent.to_string(context.config), comma),\n+            )\n         } else {\n-            (\"\", \",\")\n+            (\"\", String::from(\",\"))\n         };\n \n-\n         let block_sep = match context.config.control_brace_style() {\n-            ControlBraceStyle::AlwaysNextLine => alt_block_sep + body_prefix + \"\\n\",\n+            ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\\n\", alt_block_sep, body_prefix),\n             _ if body_prefix.is_empty() => \"\\n\".to_owned(),\n             _ => \" \".to_owned() + body_prefix + \"\\n\",\n-        };\n+        } + &indent_str;\n \n-        if context.config.wrap_match_arms() {\n-            Some(format!(\n-                \"{}{} =>{}{}{}\\n{}{}\",\n-                attr_str.trim_left(),\n-                pats_str,\n-                block_sep,\n-                indent_str,\n-                next_line_body,\n-                shape.indent.to_string(context.config),\n-                body_suffix\n-            ))\n-        } else {\n-            Some(format!(\n-                \"{}{} =>{}{}{}{}\",\n-                attr_str.trim_left(),\n-                pats_str,\n-                block_sep,\n-                indent_str,\n-                next_line_body,\n-                body_suffix\n-            ))\n+        Some(format!(\n+            \"{} =>{}{}{}\",\n+            pats_str,\n+            block_sep,\n+            body_str,\n+            body_suffix\n+        ))\n+    };\n+\n+    // Let's try and get the arm body on the same line as the condition.\n+    // 4 = ` => `.len()\n+    let orig_arm_shape = shape\n+        .offset_left(extra_offset(&pats_str, shape) + 4)\n+        .and_then(|shape| shape.sub_width(comma.len()));\n+    let orig_body = if let Some(arm_shape) = orig_arm_shape {\n+        let rewrite = nop_block_collapse(\n+            format_expr(body, ExprType::Statement, context, arm_shape),\n+            arm_shape.width,\n+        );\n+\n+        match rewrite {\n+            Some(ref body_str)\n+                if ((!body_str.contains('\\n')) && first_line_width(body_str) <= arm_shape.width) ||\n+                    is_block =>\n+            {\n+                return combine_orig_body(body_str);\n+            }\n+            _ => rewrite,\n         }\n+    } else {\n+        None\n+    };\n+    let orig_budget = orig_arm_shape.map_or(0, |shape| shape.width);\n+\n+    // Try putting body on the next line and see if it looks better.\n+    let next_line_body_shape =\n+        Shape::indented(shape.indent.block_indent(context.config), context.config);\n+    let next_line_body = nop_block_collapse(\n+        format_expr(body, ExprType::Statement, context, next_line_body_shape),\n+        next_line_body_shape.width,\n+    );\n+    match (orig_body, next_line_body) {\n+        (Some(ref orig_str), Some(ref next_line_str))\n+            if prefer_next_line(orig_str, next_line_str) => combine_next_line_body(next_line_str),\n+        (Some(ref orig_str), _) if extend && first_line_width(orig_str) <= orig_budget => {\n+            combine_orig_body(orig_str)\n+        }\n+        (Some(ref orig_str), Some(ref next_line_str)) if orig_str.contains('\\n') => {\n+            combine_next_line_body(next_line_str)\n+        }\n+        (None, Some(ref next_line_str)) => combine_next_line_body(next_line_str),\n+        (None, None) => None,\n+        (Some(ref orig_str), _) => combine_orig_body(orig_str),\n     }\n }\n \n@@ -1846,14 +1838,11 @@ fn rewrite_guard(\n     if let Some(ref guard) = *guard {\n         // First try to fit the guard string on the same line as the pattern.\n         // 4 = ` if `, 5 = ` => {`\n-        if let Some(cond_shape) = shape\n+        let cond_shape = shape\n             .offset_left(pattern_width + 4)\n-            .and_then(|s| s.sub_width(5))\n-        {\n-            if let Some(cond_str) = guard\n-                .rewrite(context, cond_shape)\n-                .and_then(|s| s.rewrite(context, cond_shape))\n-            {\n+            .and_then(|s| s.sub_width(5));\n+        if let Some(cond_shape) = cond_shape {\n+            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n                 if !cond_str.contains('\\n') || pattern_width <= context.config.tab_spaces() {\n                     return Some(format!(\" if {}\", cond_str));\n                 }\n@@ -1862,11 +1851,10 @@ fn rewrite_guard(\n \n         // Not enough space to put the guard after the pattern, try a newline.\n         // 3 = `if `, 5 = ` => {`\n-        if let Some(cond_shape) =\n-            Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                .offset_left(3)\n-                .and_then(|s| s.sub_width(5))\n-        {\n+        let cond_shape = Shape::indented(shape.indent.block_indent(context.config), context.config)\n+            .offset_left(3)\n+            .and_then(|s| s.sub_width(5));\n+        if let Some(cond_shape) = cond_shape {\n             if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n                 return Some(format!(\n                     \"\\n{}if {}\","}, {"sha": "899d168cee4d76f6573f0ceb1c7a0d7d86da49b1", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08f3f03353b88c3845ae67efbdb86b4669f94ca7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3f03353b88c3845ae67efbdb86b4669f94ca7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=08f3f03353b88c3845ae67efbdb86b4669f94ca7", "patch": "@@ -104,6 +104,17 @@ impl Spanned for ast::Ty {\n     }\n }\n \n+impl Spanned for ast::Arm {\n+    fn span(&self) -> Span {\n+        let hi = self.body.span.hi;\n+        if self.attrs.is_empty() {\n+            mk_sp(self.pats[0].span.lo, hi)\n+        } else {\n+            mk_sp(self.attrs[0].span.lo, hi)\n+        }\n+    }\n+}\n+\n impl Spanned for ast::Arg {\n     fn span(&self) -> Span {\n         if items::is_named_arg(self) {"}]}