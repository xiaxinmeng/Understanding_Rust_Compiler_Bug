{"sha": "ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "node_id": "C_kwDOAAsO6NoAKGFkNjllMGIzNmFhN2Y3YzFlYWY4NWJmOTY1NzM3MmZlYWZmY2ZlNGU", "commit": {"author": {"name": "Christian Poveda", "email": "git@pvdrz.com", "date": "2022-08-29T21:24:22Z"}, "committer": {"name": "Christian Poveda", "email": "git@pvdrz.com", "date": "2022-09-13T20:16:40Z"}, "message": "hide all enums inside kind types", "tree": {"sha": "88a1945e77e76c85252eb0999918abf34545ce9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88a1945e77e76c85252eb0999918abf34545ce9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCYyDlKAAKCRAnUl7150IK\nUD74AP9DjUI4UN7PKjemDmlFcQmWSTxV3W59l5BfFAKaR8mcLgEAkmIgdheGth3B\nw0+egJ7GUWWheDMe14UAbYz8Q19L1QY=\n=J1kO\n-----END PGP SIGNATURE-----", "payload": "tree 88a1945e77e76c85252eb0999918abf34545ce9f\nparent 6a37643265bb11658794222e9ba15652f7272990\nauthor Christian Poveda <git@pvdrz.com> 1661808262 -0500\ncommitter Christian Poveda <git@pvdrz.com> 1663100200 -0500\n\nhide all enums inside kind types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "html_url": "https://github.com/rust-lang/rust/commit/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a37643265bb11658794222e9ba15652f7272990", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a37643265bb11658794222e9ba15652f7272990", "html_url": "https://github.com/rust-lang/rust/commit/6a37643265bb11658794222e9ba15652f7272990"}], "stats": {"total": 77, "additions": 47, "deletions": 30}, "files": [{"sha": "fa01b7b1caee8cc9eb037650be8a6fe2f8d40c2c", "filename": "src/shims/time.rs", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "patch": "@@ -11,14 +11,24 @@ use crate::*;\n const NANOSECOND_PER_BASIC_BLOCK: u64 = 10;\n \n #[derive(Debug)]\n-pub enum Instant {\n+pub struct Instant {\n+    kind: InstantKind,\n+}\n+\n+#[derive(Debug)]\n+enum InstantKind {\n     Host(StdInstant),\n     Virtual { nanoseconds: u64 },\n }\n \n /// A monotone clock used for `Instant` simulation.\n #[derive(Debug)]\n-pub enum Clock {\n+pub struct Clock {\n+    kind: ClockKind,\n+}\n+\n+#[derive(Debug)]\n+enum ClockKind {\n     Host {\n         /// The \"time anchor\" for this machine's monotone clock.\n         time_anchor: StdInstant,\n@@ -32,39 +42,42 @@ pub enum Clock {\n impl Clock {\n     /// Create a new clock based on the availability of communication with the host.\n     pub fn new(communicate: bool) -> Self {\n-        if communicate {\n-            Self::Host { time_anchor: StdInstant::now() }\n+        let kind = if communicate {\n+            ClockKind::Host { time_anchor: StdInstant::now() }\n         } else {\n-            Self::Virtual { nanoseconds: 0.into() }\n-        }\n+            ClockKind::Virtual { nanoseconds: 0.into() }\n+        };\n+\n+        Self { kind }\n     }\n \n     /// Get the current time relative to this clock.\n     pub fn get(&self) -> Duration {\n-        match self {\n-            Self::Host { time_anchor } => StdInstant::now().saturating_duration_since(*time_anchor),\n-            Self::Virtual { nanoseconds } =>\n+        match &self.kind {\n+            ClockKind::Host { time_anchor } =>\n+                StdInstant::now().saturating_duration_since(*time_anchor),\n+            ClockKind::Virtual { nanoseconds } =>\n                 Duration::from_nanos(nanoseconds.load(Ordering::Relaxed)),\n         }\n     }\n \n     /// Let the time pass for a small interval.\n     pub fn tick(&self) {\n-        match self {\n-            Self::Host { .. } => {\n+        match &self.kind {\n+            ClockKind::Host { .. } => {\n                 // Time will pass without us doing anything.\n             }\n-            Self::Virtual { nanoseconds } => {\n+            ClockKind::Virtual { nanoseconds } => {\n                 nanoseconds.fetch_add(NANOSECOND_PER_BASIC_BLOCK, Ordering::Relaxed);\n             }\n         }\n     }\n \n     /// Sleep for the desired duration.\n     pub fn sleep(&self, duration: Duration) {\n-        match self {\n-            Self::Host { .. } => std::thread::sleep(duration),\n-            Self::Virtual { nanoseconds } => {\n+        match &self.kind {\n+            ClockKind::Host { .. } => std::thread::sleep(duration),\n+            ClockKind::Virtual { nanoseconds } => {\n                 // Just pretend that we have slept for some time.\n                 nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::Relaxed);\n             }\n@@ -73,30 +86,34 @@ impl Clock {\n \n     /// Compute `now + duration` relative to this clock.\n     pub fn get_time_relative(&self, duration: Duration) -> Option<Time> {\n-        match self {\n-            Self::Host { .. } =>\n+        match &self.kind {\n+            ClockKind::Host { .. } =>\n                 StdInstant::now()\n                     .checked_add(duration)\n-                    .map(|instant| Time::Monotonic(Instant::Host(instant))),\n-            Self::Virtual { nanoseconds } =>\n+                    .map(|instant| Time::Monotonic(Instant { kind: InstantKind::Host(instant) })),\n+            ClockKind::Virtual { nanoseconds } =>\n                 nanoseconds\n                     .load(Ordering::Relaxed)\n                     .checked_add(duration.as_nanos().try_into().unwrap())\n-                    .map(|nanoseconds| Time::Monotonic(Instant::Virtual { nanoseconds })),\n+                    .map(|nanoseconds| {\n+                        Time::Monotonic(Instant { kind: InstantKind::Virtual { nanoseconds } })\n+                    }),\n         }\n     }\n \n     /// Compute `start + duration` relative to this clock where `start` is the instant of time when\n     /// this clock was created.\n     pub fn get_time_absolute(&self, duration: Duration) -> Option<Time> {\n-        match self {\n-            Self::Host { time_anchor } =>\n+        match &self.kind {\n+            ClockKind::Host { time_anchor } =>\n                 time_anchor\n                     .checked_add(duration)\n-                    .map(|instant| Time::Monotonic(Instant::Host(instant))),\n-            Self::Virtual { .. } =>\n-                Some(Time::Monotonic(Instant::Virtual {\n-                    nanoseconds: duration.as_nanos().try_into().unwrap(),\n+                    .map(|instant| Time::Monotonic(Instant { kind: InstantKind::Host(instant) })),\n+            ClockKind::Virtual { .. } =>\n+                Some(Time::Monotonic(Instant {\n+                    kind: InstantKind::Virtual {\n+                        nanoseconds: duration.as_nanos().try_into().unwrap(),\n+                    },\n                 })),\n         }\n     }\n@@ -105,12 +122,12 @@ impl Clock {\n     pub fn get_wait_time(&self, time: &Time) -> Duration {\n         match time {\n             Time::Monotonic(instant) =>\n-                match (instant, self) {\n-                    (Instant::Host(instant), Clock::Host { .. }) =>\n+                match (&instant.kind, &self.kind) {\n+                    (InstantKind::Host(instant), ClockKind::Host { .. }) =>\n                         instant.saturating_duration_since(StdInstant::now()),\n                     (\n-                        Instant::Virtual { nanoseconds },\n-                        Clock::Virtual { nanoseconds: current_ns },\n+                        InstantKind::Virtual { nanoseconds },\n+                        ClockKind::Virtual { nanoseconds: current_ns },\n                     ) =>\n                         Duration::from_nanos(\n                             nanoseconds.saturating_sub(current_ns.load(Ordering::Relaxed)),"}]}