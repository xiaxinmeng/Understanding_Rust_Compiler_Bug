{"sha": "9368a1e3e2b5f27438754c149948a877edbcd767", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNjhhMWUzZTJiNWYyNzQzODc1NGMxNDk5NDhhODc3ZWRiY2Q3Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-21T09:17:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-21T09:17:26Z"}, "message": "Auto merge of #45684 - bjorn3:runtime_choose_trans2, r=eddyb\n\nAllow runtime switching between trans backends\n\nThe driver callback after_llvm has been removed as it doesnt work with multiple backends.\n\nr? @eddyb", "tree": {"sha": "f96ba686b2172a0faace53dfcbf0a001c92030f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f96ba686b2172a0faace53dfcbf0a001c92030f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9368a1e3e2b5f27438754c149948a877edbcd767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9368a1e3e2b5f27438754c149948a877edbcd767", "html_url": "https://github.com/rust-lang/rust/commit/9368a1e3e2b5f27438754c149948a877edbcd767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9368a1e3e2b5f27438754c149948a877edbcd767/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "html_url": "https://github.com/rust-lang/rust/commit/8d3e93beae9562f8b32b7f82c3824389f6ac5bad"}, {"sha": "a30232f9fd6be9b81e7aa7cfe38b1755ecd9c770", "url": "https://api.github.com/repos/rust-lang/rust/commits/a30232f9fd6be9b81e7aa7cfe38b1755ecd9c770", "html_url": "https://github.com/rust-lang/rust/commit/a30232f9fd6be9b81e7aa7cfe38b1755ecd9c770"}], "stats": {"total": 1223, "additions": 669, "deletions": 554}, "files": [{"sha": "6f919fd1acd3c79d7c011b8595baeeb4923d3c54", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -2010,7 +2010,6 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_trans_utils 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -2133,6 +2132,8 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "cd4e3cfed7a3391fac50249ceec17fb8455147e2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -1045,6 +1045,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          build_debugging_options, \"Z\", \"debugging\",\n          DB_OPTIONS, db_type_desc, dbsetters,\n+    codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"the backend to use\"),\n     verbose: bool = (false, parse_bool, [UNTRACKED],\n         \"in general, enable more debug printouts\"),\n     span_free_formats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "468a08b1fd9f37fd36989e6a6377a315d98af693", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 86, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -31,7 +31,6 @@ use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n-use rustc_trans as trans;\n use rustc_trans_utils::trans_crate::TransCrate;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -40,7 +39,6 @@ use rustc_plugin as plugin;\n use rustc_passes::{self, ast_validation, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n-use ::DefaultTransCrate;\n \n use serialize::json;\n \n@@ -68,16 +66,15 @@ use pretty::ReplaceBodyWithLoop;\n \n use profile;\n \n-pub fn compile_input(sess: &Session,\n+pub fn compile_input(trans: Box<TransCrate>,\n+                     sess: &Session,\n                      cstore: &CStore,\n                      input_path: &Option<PathBuf>,\n                      input: &Input,\n                      outdir: &Option<PathBuf>,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: &CompileController) -> CompileResult {\n-    use rustc::session::config::CrateType;\n-\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -94,30 +91,14 @@ pub fn compile_input(sess: &Session,\n         }}\n     }\n \n-    if cfg!(not(feature=\"llvm\")) {\n-        for cty in sess.opts.crate_types.iter() {\n-            match *cty {\n-                CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n-                CrateType::CrateTypeExecutable => {},\n-                _ => {\n-                    sess.parse_sess.span_diagnostic.warn(\n-                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n-                    );\n-                },\n-            }\n-        }\n-\n-        sess.abort_if_errors();\n-    }\n-\n     if sess.profile_queries() {\n         profile::begin();\n     }\n \n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans, dep_graph) = {\n+    let (outputs, ongoing_trans, dep_graph) = {\n         let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -217,7 +198,8 @@ pub fn compile_input(sess: &Session,\n             None\n         };\n \n-        phase_3_run_analysis_passes(control,\n+        phase_3_run_analysis_passes(&*trans,\n+                                    control,\n                                     sess,\n                                     cstore,\n                                     hir_map,\n@@ -254,7 +236,7 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            let trans = phase_4_translate_to_llvm::<DefaultTransCrate>(tcx, rx);\n+            let ongoing_trans = phase_4_translate_to_llvm(&*trans, tcx, rx);\n \n             if log_enabled!(::log::Level::Info) {\n                 println!(\"Post-trans\");\n@@ -268,33 +250,15 @@ pub fn compile_input(sess: &Session,\n                 }\n             }\n \n-            Ok((outputs.clone(), trans, tcx.dep_graph.clone()))\n+            Ok((outputs.clone(), ongoing_trans, tcx.dep_graph.clone()))\n         })??\n     };\n \n     if sess.opts.debugging_opts.print_type_sizes {\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    let (phase5_result, trans) =\n-        phase_5_run_llvm_passes::<DefaultTransCrate>(sess, &dep_graph, trans);\n-\n-    controller_entry_point!(after_llvm,\n-                            sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                            phase5_result);\n-    phase5_result?;\n-\n-    // Run the linker on any artifacts that resulted from the LLVM run.\n-    // This should produce either a finished executable or library.\n-    time(sess.time_passes(), \"linking\", || {\n-        DefaultTransCrate::link_binary(sess, &trans, &outputs)\n-    });\n-\n-    // Now that we won't touch anything in the incremental compilation directory\n-    // any more, we can finalize it (which involves renaming it)\n-    #[cfg(feature=\"llvm\")]\n-    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+    trans.join_trans_and_link(ongoing_trans, sess, &dep_graph, &outputs)?;\n \n     if sess.opts.debugging_opts.perf_stats {\n         sess.print_perf_stats();\n@@ -340,7 +304,6 @@ pub struct CompileController<'a> {\n     pub after_expand: PhaseController<'a>,\n     pub after_hir_lowering: PhaseController<'a>,\n     pub after_analysis: PhaseController<'a>,\n-    pub after_llvm: PhaseController<'a>,\n     pub compilation_done: PhaseController<'a>,\n \n     // FIXME we probably want to group the below options together and offer a\n@@ -366,7 +329,6 @@ impl<'a> CompileController<'a> {\n             after_expand: PhaseController::basic(),\n             after_hir_lowering: PhaseController::basic(),\n             after_analysis: PhaseController::basic(),\n-            after_llvm: PhaseController::basic(),\n             compilation_done: PhaseController::basic(),\n             make_glob_map: MakeGlobMap::No,\n             keep_ast: false,\n@@ -415,7 +377,6 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub resolutions: Option<&'a Resolutions>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-    pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n impl<'a, 'tcx> CompileState<'a, 'tcx> {\n@@ -440,7 +401,6 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             resolutions: None,\n             analysis: None,\n             tcx: None,\n-            trans: None,\n         }\n     }\n \n@@ -528,19 +488,6 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    fn state_after_llvm(input: &'a Input,\n-                        session: &'tcx Session,\n-                        out_dir: &'a Option<PathBuf>,\n-                        out_file: &'a Option<PathBuf>,\n-                        trans: &'a trans::CrateTranslation)\n-                        -> Self {\n-        CompileState {\n-            trans: Some(trans),\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-\n     fn state_when_compilation_done(input: &'a Input,\n                                    session: &'tcx Session,\n                                    out_dir: &'a Option<PathBuf>,\n@@ -933,7 +880,6 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     reachable::provide(providers);\n     resolve_lifetime::provide(providers);\n     rustc_privacy::provide(providers);\n-    DefaultTransCrate::provide(providers);\n     typeck::provide(providers);\n     ty::provide(providers);\n     traits::provide(providers);\n@@ -947,13 +893,13 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n \n pub fn default_provide_extern(providers: &mut ty::maps::Providers) {\n     cstore::provide_extern(providers);\n-    DefaultTransCrate::provide_extern(providers);\n }\n \n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n+pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n+                                               control: &CompileController,\n                                                sess: &'tcx Session,\n                                                cstore: &'tcx CrateStore,\n                                                hir_map: hir_map::Map<'tcx>,\n@@ -1006,10 +952,12 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n \n     let mut local_providers = ty::maps::Providers::default();\n     default_provide(&mut local_providers);\n+    trans.provide(&mut local_providers);\n     (control.provide)(&mut local_providers);\n \n     let mut extern_providers = local_providers;\n     default_provide_extern(&mut extern_providers);\n+    trans.provide_extern(&mut extern_providers);\n     (control.provide_extern)(&mut extern_providers);\n \n     let (tx, rx) = mpsc::channel();\n@@ -1101,9 +1049,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'a, 'tcx, Trans: TransCrate>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn phase_4_translate_to_llvm<'a, 'tcx>(trans: &TransCrate,\n+                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            rx: mpsc::Receiver<Box<Any + Send>>)\n-                                           -> <Trans as TransCrate>::OngoingCrateTranslation {\n+                                           -> Box<Any> {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,\n@@ -1112,7 +1061,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx, Trans: TransCrate>(tcx: TyCtxt<'a, 't\n \n     let translation =\n         time(time_passes, \"translation\", move || {\n-            Trans::trans_crate(tcx, rx)\n+            trans.trans_crate(tcx, rx)\n         });\n     if tcx.sess.profile_queries() {\n         profile::dump(\"profile_queries\".to_string())\n@@ -1121,25 +1070,6 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx, Trans: TransCrate>(tcx: TyCtxt<'a, 't\n     translation\n }\n \n-/// Run LLVM itself, producing a bitcode file, assembly file or object file\n-/// as a side effect.\n-pub fn phase_5_run_llvm_passes<Trans: TransCrate>(sess: &Session,\n-                               dep_graph: &DepGraph,\n-                               trans: <Trans as TransCrate>::OngoingCrateTranslation)\n-                               -> (CompileResult, <Trans as TransCrate>::TranslatedCrate) {\n-    let trans = Trans::join_trans(trans, sess, dep_graph);\n-\n-    if sess.opts.debugging_opts.incremental_info {\n-        Trans::dump_incremental_data(&trans);\n-    }\n-\n-    time(sess.time_passes(),\n-         \"serialize work products\",\n-         move || rustc_incremental::save_work_products(sess, dep_graph));\n-\n-    (sess.compile_status(), trans)\n-}\n-\n fn escape_dep_filename(filename: &FileName) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4"}, {"sha": "de5559c8b14404e9ca02ce2755eecaaf75107f1d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 102, "deletions": 64, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -48,7 +48,7 @@ extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n #[cfg(feature=\"llvm\")]\n-extern crate rustc_trans;\n+pub extern crate rustc_trans;\n extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;\n@@ -66,7 +66,7 @@ use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n-use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n+use rustc::session::config::{Input, PrintRequest, ErrorOutputType};\n use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n@@ -106,9 +106,32 @@ mod test;\n pub mod profile;\n pub mod driver;\n pub mod pretty;\n-pub mod target_features;\n mod derive_registrar;\n \n+pub mod target_features {\n+    use syntax::ast;\n+    use syntax::symbol::Symbol;\n+    use rustc::session::Session;\n+    use rustc_trans_utils::trans_crate::TransCrate;\n+\n+    /// Add `target_feature = \"...\"` cfgs for a variety of platform\n+    /// specific features (SSE, NEON etc.).\n+    ///\n+    /// This is performed by checking whether a whitelisted set of\n+    /// features is available on the target machine, by querying LLVM.\n+    pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session, trans: &TransCrate) {\n+        let tf = Symbol::intern(\"target_feature\");\n+\n+        for feat in trans.target_features(sess) {\n+            cfg.insert((tf, Some(feat)));\n+        }\n+\n+        if sess.crt_static_feature() {\n+            cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n+        }\n+    }\n+}\n+\n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";\n \n@@ -159,25 +182,51 @@ pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as DefaultTransCr\n pub use rustc_trans::LlvmTransCrate as DefaultTransCrate;\n \n #[cfg(not(feature=\"llvm\"))]\n-mod rustc_trans {\n-    use syntax_pos::symbol::Symbol;\n-    use rustc::session::Session;\n-    use rustc::session::config::PrintRequest;\n+pub mod rustc_trans {\n     pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as LlvmTransCrate;\n-    pub use rustc_trans_utils::trans_crate::TranslatedCrate as CrateTranslation;\n \n-    pub fn init(_sess: &Session) {}\n     pub fn print_version() {}\n     pub fn print_passes() {}\n-    pub fn print(_req: PrintRequest, _sess: &Session) {}\n-    pub fn target_features(_sess: &Session) -> Vec<Symbol> { vec![] }\n-\n-    pub mod back {\n-        pub mod write {\n-            pub const RELOC_MODEL_ARGS: [(&'static str, ()); 0] = [];\n-            pub const CODE_GEN_MODEL_ARGS: [(&'static str, ()); 0] = [];\n-            pub const TLS_MODEL_ARGS: [(&'static str, ()); 0] = [];\n+}\n+\n+fn load_backend_from_dylib(sess: &Session, backend_name: &str) -> Box<TransCrate> {\n+    use std::path::Path;\n+    use rustc_metadata::dynamic_lib::DynamicLibrary;\n+\n+    match DynamicLibrary::open(Some(Path::new(backend_name))) {\n+        Ok(lib) => {\n+            unsafe {\n+                let trans = {\n+                    let __rustc_codegen_backend: unsafe fn(&Session) -> Box<TransCrate>;\n+                    __rustc_codegen_backend = match lib.symbol(\"__rustc_codegen_backend\") {\n+                        Ok(f) => ::std::mem::transmute::<*mut u8, _>(f),\n+                        Err(e) => sess.fatal(&format!(\"Couldnt load codegen backend as it\\\n+                        doesn't export the __rustc_backend_new symbol: {:?}\", e)),\n+                    };\n+                    __rustc_codegen_backend(sess)\n+                };\n+                ::std::mem::forget(lib);\n+                trans\n+            }\n+        }\n+        Err(err) => {\n+            sess.fatal(&format!(\"Couldnt load codegen backend {:?}: {:?}\", backend_name, err));\n+        }\n+    }\n+}\n+\n+pub fn get_trans(sess: &Session) -> Box<TransCrate> {\n+    let trans_name = sess.opts.debugging_opts.codegen_backend.clone();\n+    match trans_name.as_ref().map(|s|&**s) {\n+        None => DefaultTransCrate::new(&sess),\n+        Some(\"llvm\") => rustc_trans::LlvmTransCrate::new(&sess),\n+        Some(\"metadata_only\") => {\n+            rustc_trans_utils::trans_crate::MetadataOnlyTransCrate::new(&sess)\n+        }\n+        Some(filename) if filename.contains(\".\") => {\n+            load_backend_from_dylib(&sess, &filename)\n         }\n+        Some(trans_name) => sess.fatal(&format!(\"Unknown codegen backend {}\", trans_name)),\n     }\n }\n \n@@ -222,30 +271,36 @@ pub fn run_compiler<'a>(args: &[String],\n         },\n     };\n \n-    let cstore = CStore::new(DefaultTransCrate::metadata_loader());\n-\n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, input_file_path.clone(), descriptions, codemap, emitter_dest,\n     );\n-    rustc_trans::init(&sess);\n+\n+    let trans = get_trans(&sess);\n+\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n-    target_features::add_configuration(&mut cfg, &sess);\n+    target_features::add_configuration(&mut cfg, &sess, &*trans);\n     sess.parse_sess.config = cfg;\n \n-    do_or_return!(callbacks.late_callback(&matches,\n+    let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n+\n+    let cstore = CStore::new(trans.metadata_loader());\n+\n+    do_or_return!(callbacks.late_callback(&*trans,\n+                                          &matches,\n                                           &sess,\n                                           &cstore,\n                                           &input,\n                                           &odir,\n                                           &ofile), Some(sess));\n \n-    let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess, &matches);\n-    (driver::compile_input(&sess,\n+\n+    (driver::compile_input(trans,\n+                           &sess,\n                            &cstore,\n                            &input_file_path,\n                            &input,\n@@ -338,6 +393,7 @@ pub trait CompilerCalls<'a> {\n     // be called just before actual compilation starts (and before build_controller\n     // is called), after all arguments etc. have been completely handled.\n     fn late_callback(&mut self,\n+                     _: &TransCrate,\n                      _: &getopts::Matches,\n                      _: &Session,\n                      _: &CrateStore,\n@@ -517,13 +573,18 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 let mut sess = build_session(sopts.clone(),\n                     None,\n                     descriptions.clone());\n-                rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n-                target_features::add_configuration(&mut cfg, &sess);\n+                let trans = get_trans(&sess);\n+                target_features::add_configuration(&mut cfg, &sess, &*trans);\n                 sess.parse_sess.config = cfg;\n-                let should_stop =\n-                    RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n+                let should_stop = RustcDefaultCalls::print_crate_info(\n+                    &*trans,\n+                    &sess,\n+                    None,\n+                    odir,\n+                    ofile\n+                );\n \n                 if should_stop == Compilation::Stop {\n                     return None;\n@@ -536,14 +597,15 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     }\n \n     fn late_callback(&mut self,\n+                     trans: &TransCrate,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n                      cstore: &CrateStore,\n                      input: &Input,\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n-        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile)\n+        RustcDefaultCalls::print_crate_info(trans, sess, Some(input), odir, ofile)\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, cstore, matches, input))\n     }\n \n@@ -607,11 +669,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             control.after_hir_lowering.stop = Compilation::Stop;\n         }\n \n-        if !sess.opts.output_types.keys().any(|&i| i == OutputType::Exe ||\n-                                                   i == OutputType::Metadata) {\n-            control.after_llvm.stop = Compilation::Stop;\n-        }\n-\n         if save_analysis(sess) {\n             enable_save_analysis(&mut control);\n         }\n@@ -681,11 +738,13 @@ impl RustcDefaultCalls {\n     }\n \n \n-    fn print_crate_info(sess: &Session,\n+    fn print_crate_info(trans: &TransCrate,\n+                        sess: &Session,\n                         input: Option<&Input>,\n                         odir: &Option<PathBuf>,\n                         ofile: &Option<PathBuf>)\n                         -> Compilation {\n+        use rustc::session::config::PrintRequest::*;\n         // PrintRequest::NativeStaticLibs is special - printed during linking\n         // (empty iterator returns true)\n         if sess.opts.prints.iter().all(|&p| p==PrintRequest::NativeStaticLibs) {\n@@ -707,15 +766,14 @@ impl RustcDefaultCalls {\n         };\n         for req in &sess.opts.prints {\n             match *req {\n-                PrintRequest::TargetList => {\n+                TargetList => {\n                     let mut targets = rustc_back::target::get_targets().collect::<Vec<String>>();\n                     targets.sort();\n                     println!(\"{}\", targets.join(\"\\n\"));\n                 },\n-                PrintRequest::Sysroot => println!(\"{}\", sess.sysroot().display()),\n-                PrintRequest::TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n-                PrintRequest::FileNames |\n-                PrintRequest::CrateName => {\n+                Sysroot => println!(\"{}\", sess.sysroot().display()),\n+                TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n+                FileNames | CrateName => {\n                     let input = match input {\n                         Some(input) => input,\n                         None => early_error(ErrorOutputType::default(), \"no input file provided\"),\n@@ -741,7 +799,7 @@ impl RustcDefaultCalls {\n                                       .to_string_lossy());\n                     }\n                 }\n-                PrintRequest::Cfg => {\n+                Cfg => {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n@@ -781,29 +839,8 @@ impl RustcDefaultCalls {\n                         println!(\"{}\", cfg);\n                     }\n                 }\n-                PrintRequest::RelocationModels => {\n-                    println!(\"Available relocation models:\");\n-                    for &(name, _) in rustc_trans::back::write::RELOC_MODEL_ARGS.iter() {\n-                        println!(\"    {}\", name);\n-                    }\n-                    println!(\"\");\n-                }\n-                PrintRequest::CodeModels => {\n-                    println!(\"Available code models:\");\n-                    for &(name, _) in rustc_trans::back::write::CODE_GEN_MODEL_ARGS.iter(){\n-                        println!(\"    {}\", name);\n-                    }\n-                    println!(\"\");\n-                }\n-                PrintRequest::TlsModels => {\n-                    println!(\"Available TLS models:\");\n-                    for &(name, _) in rustc_trans::back::write::TLS_MODEL_ARGS.iter(){\n-                        println!(\"    {}\", name);\n-                    }\n-                    println!(\"\");\n-                }\n-                PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n-                    rustc_trans::print(*req, sess);\n+                RelocationModels | CodeModels | TlsModels | TargetCPUs | TargetFeatures => {\n+                    trans.print(*req, sess);\n                 }\n                 // Any output here interferes with Cargo's parsing of other printed output\n                 PrintRequest::NativeStaticLibs => {}\n@@ -1281,6 +1318,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_trans_utils::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);"}, {"sha": "af3d1e4d4d0108acf1aa555f46f6d7a62d4b3b91", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -228,7 +228,8 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let control = &driver::CompileController::basic();\n-                abort_on_err(driver::phase_3_run_analysis_passes(control,\n+                abort_on_err(driver::phase_3_run_analysis_passes(&*::DefaultTransCrate::new(&sess),\n+                                                                 control,\n                                                                  sess,\n                                                                  cstore,\n                                                                  hir_map.clone(),\n@@ -1080,7 +1081,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     let control = &driver::CompileController::basic();\n-    abort_on_err(driver::phase_3_run_analysis_passes(control,\n+    abort_on_err(driver::phase_3_run_analysis_passes(&*::DefaultTransCrate::new(&sess),\n+                                                     control,\n                                                      sess,\n                                                      cstore,\n                                                      hir_map.clone(),"}, {"sha": "96264472b5f8e53e0fe752afd6f5d174ef6ebcdf", "filename": "src/librustc_driver/target_features.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use rustc::session::Session;\n-use syntax::symbol::Symbol;\n-use rustc_trans;\n-\n-/// Add `target_feature = \"...\"` cfgs for a variety of platform\n-/// specific features (SSE, NEON etc.).\n-///\n-/// This is performed by checking whether a whitelisted set of\n-/// features is available on the target machine, by querying LLVM.\n-pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n-    let tf = Symbol::intern(\"target_feature\");\n-\n-    for feat in rustc_trans::target_features(sess) {\n-        cfg.insert((tf, Some(feat)));\n-    }\n-\n-    if sess.crt_static_feature() {\n-        cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n-    }\n-}"}, {"sha": "306e7e9c16dce2c5b05611fcad78ba6f9b4e9036", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -16,7 +16,6 @@ use std::sync::mpsc;\n use driver;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n-use rustc_trans;\n use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n@@ -29,7 +28,6 @@ use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::{OutputFilenames, OutputTypes};\n-use rustc_trans_utils::trans_crate::TransCrate;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -104,12 +102,11 @@ fn test_env<F>(source_string: &str,\n     options.unstable_features = UnstableFeatures::Allow;\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n-    let cstore = Rc::new(CStore::new(::DefaultTransCrate::metadata_loader()));\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())));\n-    rustc_trans::init(&sess);\n+    let cstore = Rc::new(CStore::new(::get_trans(&sess).metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::Anon,"}, {"sha": "46ba94f2061512963fea18f207c780e38635c6d5", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -40,7 +40,7 @@ const CFG: &'static str = \"cfg\";\n #[derive(Debug, PartialEq, Clone, Copy)]\n enum Disposition { Reused, Translated }\n \n-pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n             return;", "previous_filename": "src/librustc_trans/assert_module_sources.rs"}, {"sha": "b53ee1daada429427c18040a8bdf48619b7972fd", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -32,6 +32,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n mod assert_dep_graph;\n+pub mod assert_module_sources;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;"}, {"sha": "ea05a513f7e7d9c5d7190d3cd00cf91d885eace3", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -24,4 +24,3 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n byteorder = { version = \"1.1\", features = [\"i128\"] }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n-rustc_trans_utils = { path = \"../librustc_trans_utils\" }"}, {"sha": "1699ad0f19cf63eed34c815acd17b523e9a0c9fa", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -57,7 +57,6 @@ extern crate core; // for NonZero\n extern crate log_settings;\n extern crate rustc_apfloat;\n extern crate byteorder;\n-extern crate rustc_trans_utils;\n \n mod diagnostics;\n "}, {"sha": "072c339813490bbd2e0e450de7674a8379b0eb68", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -26,6 +26,7 @@ use std::fmt::{self, Write};\n use std::iter;\n use rustc::mir::mono::Linkage;\n use syntax_pos::symbol::Symbol;\n+use syntax::codemap::Span;\n pub use rustc::mir::mono::MonoItem;\n \n pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n@@ -244,6 +245,18 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             result\n         }\n     }\n+\n+    fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(Instance { def, .. }) => {\n+                tcx.hir.as_local_node_id(def.def_id())\n+            }\n+            MonoItem::Static(node_id) |\n+            MonoItem::GlobalAsm(node_id) => {\n+                Some(node_id)\n+            }\n+        }.map(|node_id| tcx.hir.span(node_id))\n+    }\n }\n \n impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {"}, {"sha": "95ebb6c970a588ec4c3758818f4bd7ff88bec703", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -22,6 +22,54 @@ pub mod collector;\n pub mod item;\n pub mod partitioning;\n \n+#[inline(never)] // give this a place in the profiler\n+pub fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n+    where I: Iterator<Item=&'a MonoItem<'tcx>>\n+{\n+    let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n+        (trans_item, trans_item.symbol_name(tcx))\n+    }).collect();\n+\n+    (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n+        sym1.cmp(sym2)\n+    });\n+\n+    for pair in (&symbols[..]).windows(2) {\n+        let sym1 = &pair[0].1;\n+        let sym2 = &pair[1].1;\n+\n+        if *sym1 == *sym2 {\n+            let trans_item1 = pair[0].0;\n+            let trans_item2 = pair[1].0;\n+\n+            let span1 = trans_item1.local_span(tcx);\n+            let span2 = trans_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo().0 > span2.lo().0 {\n+                        span1\n+                    } else {\n+                        span2\n+                    })\n+                }\n+                (Some(span), None) |\n+                (None, Some(span)) => Some(span),\n+                _ => None\n+            };\n+\n+            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n+\n+            if let Some(span) = span {\n+                tcx.sess.span_fatal(span, &error_message)\n+            } else {\n+                tcx.sess.fatal(&error_message)\n+            }\n+        }\n+    }\n+}\n+\n fn fn_once_adapter_instance<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     closure_did: DefId,"}, {"sha": "fd5aa1364d381951bcf3025a77b4f62164064da5", "filename": "src/librustc_trans/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fallocator.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -19,7 +19,7 @@ use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n use ModuleLlvm;\n use llvm::{self, False, True};\n \n-pub unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n     let llcx = mods.llcx;\n     let llmod = mods.llmod;\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {"}, {"sha": "f93f317a0a0f772ad05aad62cf8c16a4f9b24d8c", "filename": "src/librustc_trans/back/command.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -14,7 +14,7 @@\n use std::ffi::{OsStr, OsString};\n use std::fmt;\n use std::io;\n-use std::process::{self, Output, Child};\n+use std::process::{self, Output};\n \n pub struct Command {\n     program: OsString,\n@@ -81,10 +81,6 @@ impl Command {\n         self.command().output()\n     }\n \n-    pub fn spawn(&mut self) -> io::Result<Child> {\n-        self.command().spawn()\n-    }\n-\n     pub fn command(&self) -> process::Command {\n         let mut ret = process::Command::new(&self.program);\n         ret.args(&self.args);"}, {"sha": "62b65b7952ee29659267e9240230ddea252e98eb", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -141,10 +141,10 @@ pub fn remove(sess: &Session, path: &Path) {\n \n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub fn link_binary(sess: &Session,\n-                   trans: &CrateTranslation,\n-                   outputs: &OutputFilenames,\n-                   crate_name: &str) -> Vec<PathBuf> {\n+pub(crate) fn link_binary(sess: &Session,\n+                          trans: &CrateTranslation,\n+                          outputs: &OutputFilenames,\n+                          crate_name: &str) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-trans, as they will error.\n@@ -201,9 +201,9 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n     out_filename\n }\n \n-pub fn each_linked_rlib(sess: &Session,\n-                        info: &CrateInfo,\n-                        f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n+pub(crate) fn each_linked_rlib(sess: &Session,\n+                               info: &CrateInfo,\n+                               f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = info.used_crates_static.iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n@@ -247,7 +247,7 @@ pub fn each_linked_rlib(sess: &Session,\n /// It's unusual for a crate to not participate in LTO. Typically only\n /// compiler-specific and unstable crates have a reason to not participate in\n /// LTO.\n-pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n+pub(crate) fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n     // If our target enables builtin function lowering in LLVM then the\n     // crates providing these functions don't participate in LTO (e.g.\n     // no_builtins or compiler builtins crates)."}, {"sha": "b612247ffcd42bfbd867cd4677e5ee9000ece992", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -42,7 +42,7 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-pub enum LtoModuleTranslation {\n+pub(crate) enum LtoModuleTranslation {\n     Fat {\n         module: Option<ModuleTranslation>,\n         _serialized_bitcode: Vec<SerializedModule>,\n@@ -65,9 +65,9 @@ impl LtoModuleTranslation {\n     /// points to LLVM data structures owned by this `LtoModuleTranslation`.\n     /// It's intended that the module returned is immediately code generated and\n     /// dropped, and then this LTO module is dropped.\n-    pub unsafe fn optimize(&mut self,\n-                           cgcx: &CodegenContext,\n-                           timeline: &mut Timeline)\n+    pub(crate) unsafe fn optimize(&mut self,\n+                                  cgcx: &CodegenContext,\n+                                  timeline: &mut Timeline)\n         -> Result<ModuleTranslation, FatalError>\n     {\n         match *self {\n@@ -100,7 +100,7 @@ pub enum LTOMode {\n     JustThisCrate,\n }\n \n-pub fn run(cgcx: &CodegenContext,\n+pub(crate) fn run(cgcx: &CodegenContext,\n            modules: Vec<ModuleTranslation>,\n            mode: LTOMode,\n            timeline: &mut Timeline)"}, {"sha": "a013af7a4600ef342218823abbbea1d890e26de1", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -363,15 +363,15 @@ impl CodegenContext {\n         Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n     }\n \n-    pub fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n+    pub(crate) fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n         match kind {\n             ModuleKind::Regular => &self.regular_module_config,\n             ModuleKind::Metadata => &self.metadata_module_config,\n             ModuleKind::Allocator => &self.allocator_module_config,\n         }\n     }\n \n-    pub fn save_temp_bitcode(&self, trans: &ModuleTranslation, name: &str) {\n+    pub(crate) fn save_temp_bitcode(&self, trans: &ModuleTranslation, name: &str) {\n         if !self.save_temps {\n             return\n         }\n@@ -822,7 +822,7 @@ fn binaryen_assemble(cgcx: &CodegenContext,\n     }\n }\n \n-pub struct CompiledModules {\n+pub(crate) struct CompiledModules {\n     pub modules: Vec<CompiledModule>,\n     pub metadata_module: CompiledModule,\n     pub allocator_module: Option<CompiledModule>,\n@@ -1162,7 +1162,7 @@ fn produce_final_output_artifacts(sess: &Session,\n     // These are used in linking steps and will be cleaned up afterward.\n }\n \n-pub fn dump_incremental_data(trans: &CrateTranslation) {\n+pub(crate) fn dump_incremental_data(trans: &CrateTranslation) {\n     println!(\"[incremental] Re-using {} out of {} modules\",\n               trans.modules.iter().filter(|m| m.pre_existing).count(),\n               trans.modules.len());\n@@ -2144,7 +2144,7 @@ pub struct OngoingCrateTranslation {\n }\n \n impl OngoingCrateTranslation {\n-    pub fn join(self, sess: &Session, dep_graph: &DepGraph) -> CrateTranslation {\n+    pub(crate) fn join(self, sess: &Session, dep_graph: &DepGraph) -> CrateTranslation {\n         self.shared_emitter_main.check(sess, true);\n         let compiled_modules = match self.future.join() {\n             Ok(Ok(compiled_modules)) => compiled_modules,\n@@ -2212,9 +2212,9 @@ impl OngoingCrateTranslation {\n         trans\n     }\n \n-    pub fn submit_pre_translated_module_to_llvm(&self,\n-                                                tcx: TyCtxt,\n-                                                mtrans: ModuleTranslation) {\n+    pub(crate) fn submit_pre_translated_module_to_llvm(&self,\n+                                                       tcx: TyCtxt,\n+                                                       mtrans: ModuleTranslation) {\n         self.wait_for_signal_to_translate_item();\n         self.check_for_errors(tcx.sess);\n \n@@ -2247,9 +2247,9 @@ impl OngoingCrateTranslation {\n     }\n }\n \n-pub fn submit_translated_module_to_llvm(tcx: TyCtxt,\n-                                        mtrans: ModuleTranslation,\n-                                        cost: u64) {\n+pub(crate) fn submit_translated_module_to_llvm(tcx: TyCtxt,\n+                                               mtrans: ModuleTranslation,\n+                                               cost: u64) {\n     let llvm_work_item = WorkItem::Optimize(mtrans);\n     drop(tcx.tx_to_llvm_workers.send(Box::new(Message::TranslationDone {\n         llvm_work_item,"}, {"sha": "734ad8f3929ed0d9ac2e130cf940002a4ca319d9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 52, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -29,7 +29,6 @@ use super::ModuleTranslation;\n use super::ModuleKind;\n \n use abi;\n-use assert_module_sources;\n use back::link;\n use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation, create_target_machine};\n@@ -66,7 +65,7 @@ use meth;\n use mir;\n use monomorphize::Instance;\n use monomorphize::partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n-use symbol_names_test;\n+use rustc_trans_utils::symbol_names_test;\n use time_graph;\n use trans_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n use type_::Type;\n@@ -904,7 +903,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             total_trans_time);\n \n     if tcx.sess.opts.incremental.is_some() {\n-        assert_module_sources::assert_module_sources(tcx);\n+        ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n     }\n \n     symbol_names_test::report_symbol_names(tcx);\n@@ -947,54 +946,6 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n          || rustc_incremental::save_dep_graph(tcx));\n }\n \n-#[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n-    where I: Iterator<Item=&'a MonoItem<'tcx>>\n-{\n-    let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-        (trans_item, trans_item.symbol_name(tcx))\n-    }).collect();\n-\n-    (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n-        sym1.cmp(sym2)\n-    });\n-\n-    for pair in (&symbols[..]).windows(2) {\n-        let sym1 = &pair[0].1;\n-        let sym2 = &pair[1].1;\n-\n-        if *sym1 == *sym2 {\n-            let trans_item1 = pair[0].0;\n-            let trans_item2 = pair[1].0;\n-\n-            let span1 = trans_item1.local_span(tcx);\n-            let span2 = trans_item2.local_span(tcx);\n-\n-            // Deterministically select one of the spans for error reporting\n-            let span = match (span1, span2) {\n-                (Some(span1), Some(span2)) => {\n-                    Some(if span1.lo().0 > span2.lo().0 {\n-                        span1\n-                    } else {\n-                        span2\n-                    })\n-                }\n-                (Some(span), None) |\n-                (None, Some(span)) => Some(span),\n-                _ => None\n-            };\n-\n-            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n-\n-            if let Some(span) = span {\n-                tcx.sess.span_fatal(span, &error_message)\n-            } else {\n-                tcx.sess.fatal(&error_message)\n-            }\n-        }\n-    }\n-}\n-\n fn collect_and_partition_translation_items<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cnum: CrateNum,\n@@ -1034,7 +985,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n             collector::collect_crate_mono_items(tcx, collection_mode)\n     });\n \n-    assert_symbols_are_distinct(tcx, items.iter());\n+    ::rustc_mir::monomorphize::assert_symbols_are_distinct(tcx, items.iter());\n \n     let strategy = if tcx.sess.opts.incremental.is_some() {\n         PartitioningStrategy::PerModule"}, {"sha": "57cc33d09bbea94e1f36f7fa1c82fe58ae831ce5", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -47,27 +47,9 @@ unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n ```\n \"##,\n \n-E0558: r##\"\n-The `export_name` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#[export_name] // error: export_name attribute has invalid format\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `export_name` attribute expects a string in order to determine the name of\n-the exported symbol. Example:\n-\n-```\n-#[export_name = \"some_function\"] // ok!\n-pub fn something() {}\n+}\n \n-fn main() {}\n-```\n-\"##,\n \n+register_diagnostics! {\n+    E0558\n }"}, {"sha": "b67997081aa67c04e79688cd2760710e109f53b4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 115, "deletions": 57, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -33,6 +33,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(conservative_impl_trait)]\n+#![feature(optin_builtin_traits)]\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n@@ -66,11 +67,9 @@ extern crate serialize;\n extern crate cc; // Used to locate MSVC\n extern crate tempdir;\n \n-pub use base::trans_crate;\n use back::bytecode::RLIB_BYTECODE_EXTENSION;\n \n-pub use metadata::LlvmMetadataLoader;\n-pub use llvm_util::{init, target_features, print_version, print_passes, print};\n+pub use llvm_util::{target_features, print_version, print_passes};\n \n use std::any::Any;\n use std::path::PathBuf;\n@@ -81,32 +80,31 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::CrateNum;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n-use rustc::session::Session;\n-use rustc::session::config::{OutputFilenames, OutputType};\n+use rustc::session::{Session, CompileIncomplete};\n+use rustc::session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n-\n use rustc_mir::monomorphize;\n+use rustc_trans_utils::trans_crate::TransCrate;\n \n mod diagnostics;\n \n-pub mod back {\n+mod back {\n+    pub use rustc_trans_utils::symbol_names;\n     mod archive;\n     pub mod bytecode;\n     mod command;\n-    pub(crate) mod linker;\n+    pub mod linker;\n     pub mod link;\n     mod lto;\n-    pub(crate) mod symbol_export;\n-    pub(crate) mod symbol_names;\n+    pub mod symbol_export;\n     pub mod write;\n     mod rpath;\n }\n \n mod abi;\n mod allocator;\n mod asm;\n-mod assert_module_sources;\n mod attributes;\n mod base;\n mod builder;\n@@ -139,7 +137,6 @@ mod llvm_util;\n mod metadata;\n mod meth;\n mod mir;\n-mod symbol_names_test;\n mod time_graph;\n mod trans_item;\n mod type_;\n@@ -148,84 +145,145 @@ mod value;\n \n pub struct LlvmTransCrate(());\n \n+impl !Send for LlvmTransCrate {} // Llvm is on a per-thread basis\n+impl !Sync for LlvmTransCrate {}\n+\n impl LlvmTransCrate {\n-    pub fn new() -> Self {\n-        LlvmTransCrate(())\n+    pub fn new(sess: &Session) -> Box<TransCrate> {\n+        llvm_util::init(sess); // Make sure llvm is inited\n+        box LlvmTransCrate(())\n     }\n }\n \n-impl rustc_trans_utils::trans_crate::TransCrate for LlvmTransCrate {\n-    type MetadataLoader = metadata::LlvmMetadataLoader;\n-    type OngoingCrateTranslation = back::write::OngoingCrateTranslation;\n-    type TranslatedCrate = CrateTranslation;\n+impl TransCrate for LlvmTransCrate {\n+    fn print(&self, req: PrintRequest, sess: &Session) {\n+        match req {\n+            PrintRequest::RelocationModels => {\n+                println!(\"Available relocation models:\");\n+                for &(name, _) in back::write::RELOC_MODEL_ARGS.iter() {\n+                    println!(\"    {}\", name);\n+                }\n+                println!(\"\");\n+            }\n+            PrintRequest::CodeModels => {\n+                println!(\"Available code models:\");\n+                for &(name, _) in back::write::CODE_GEN_MODEL_ARGS.iter(){\n+                    println!(\"    {}\", name);\n+                }\n+                println!(\"\");\n+            }\n+            PrintRequest::TlsModels => {\n+                println!(\"Available TLS models:\");\n+                for &(name, _) in back::write::TLS_MODEL_ARGS.iter(){\n+                    println!(\"    {}\", name);\n+                }\n+                println!(\"\");\n+            }\n+            req => llvm_util::print(req, sess),\n+        }\n+    }\n \n-    fn metadata_loader() -> Box<MetadataLoader> {\n+    fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n+        target_features(sess)\n+    }\n+\n+    fn metadata_loader(&self) -> Box<MetadataLoader> {\n         box metadata::LlvmMetadataLoader\n     }\n \n-    fn provide(providers: &mut ty::maps::Providers) {\n+    fn provide(&self, providers: &mut ty::maps::Providers) {\n         back::symbol_names::provide(providers);\n         back::symbol_export::provide(providers);\n         base::provide(providers);\n         attributes::provide(providers);\n     }\n \n-    fn provide_extern(providers: &mut ty::maps::Providers) {\n+    fn provide_extern(&self, providers: &mut ty::maps::Providers) {\n         back::symbol_export::provide_extern(providers);\n     }\n \n     fn trans_crate<'a, 'tcx>(\n+        &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Self::OngoingCrateTranslation {\n-        base::trans_crate(tcx, rx)\n+    ) -> Box<Any> {\n+        box base::trans_crate(tcx, rx)\n     }\n \n-    fn join_trans(\n-        trans: Self::OngoingCrateTranslation,\n+    fn join_trans_and_link(\n+        &self,\n+        trans: Box<Any>,\n         sess: &Session,\n-        dep_graph: &DepGraph\n-    ) -> Self::TranslatedCrate {\n-        trans.join(sess, dep_graph)\n-    }\n+        dep_graph: &DepGraph,\n+        outputs: &OutputFilenames,\n+    ) -> Result<(), CompileIncomplete>{\n+        use rustc::util::common::time;\n+        let trans = trans.downcast::<::back::write::OngoingCrateTranslation>()\n+            .expect(\"Expected LlvmTransCrate's OngoingCrateTranslation, found Box<Any>\")\n+            .join(sess, dep_graph);\n+        if sess.opts.debugging_opts.incremental_info {\n+            back::write::dump_incremental_data(&trans);\n+        }\n \n-    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n-        back::link::link_binary(sess, trans, outputs, &trans.crate_name.as_str());\n-    }\n+        time(sess.time_passes(),\n+             \"serialize work products\",\n+             move || rustc_incremental::save_work_products(sess, &dep_graph));\n \n-    fn dump_incremental_data(trans: &Self::TranslatedCrate) {\n-        back::write::dump_incremental_data(trans);\n+        sess.compile_status()?;\n+\n+        if !sess.opts.output_types.keys().any(|&i| i == OutputType::Exe ||\n+                                                   i == OutputType::Metadata) {\n+            return Ok(());\n+        }\n+\n+        // Run the linker on any artifacts that resulted from the LLVM run.\n+        // This should produce either a finished executable or library.\n+        time(sess.time_passes(), \"linking\", || {\n+            back::link::link_binary(sess, &trans, outputs, &trans.crate_name.as_str());\n+        });\n+\n+        // Now that we won't touch anything in the incremental compilation directory\n+        // any more, we can finalize it (which involves renaming it)\n+        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+\n+        Ok(())\n     }\n }\n \n-pub struct ModuleTranslation {\n+/// This is the entrypoint for a hot plugged rustc_trans\n+#[no_mangle]\n+pub fn __rustc_codegen_backend(sess: &Session) -> Box<TransCrate> {\n+    LlvmTransCrate::new(sess)\n+}\n+\n+struct ModuleTranslation {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n     name: String,\n     llmod_id: String,\n-    pub source: ModuleSource,\n-    pub kind: ModuleKind,\n+    source: ModuleSource,\n+    kind: ModuleKind,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum ModuleKind {\n+enum ModuleKind {\n     Regular,\n     Metadata,\n     Allocator,\n }\n \n impl ModuleTranslation {\n-    pub fn llvm(&self) -> Option<&ModuleLlvm> {\n+    fn llvm(&self) -> Option<&ModuleLlvm> {\n         match self.source {\n             ModuleSource::Translated(ref llvm) => Some(llvm),\n             ModuleSource::Preexisting(_) => None,\n         }\n     }\n \n-    pub fn into_compiled_module(self,\n+    fn into_compiled_module(self,\n                                 emit_obj: bool,\n                                 emit_bc: bool,\n                                 emit_bc_compressed: bool,\n@@ -264,17 +322,17 @@ impl ModuleTranslation {\n }\n \n #[derive(Debug)]\n-pub struct CompiledModule {\n-    pub name: String,\n-    pub llmod_id: String,\n-    pub kind: ModuleKind,\n-    pub pre_existing: bool,\n-    pub object: Option<PathBuf>,\n-    pub bytecode: Option<PathBuf>,\n-    pub bytecode_compressed: Option<PathBuf>,\n+struct CompiledModule {\n+    name: String,\n+    llmod_id: String,\n+    kind: ModuleKind,\n+    pre_existing: bool,\n+    object: Option<PathBuf>,\n+    bytecode: Option<PathBuf>,\n+    bytecode_compressed: Option<PathBuf>,\n }\n \n-pub enum ModuleSource {\n+enum ModuleSource {\n     /// Copy the `.o` files or whatever from the incr. comp. directory.\n     Preexisting(WorkProduct),\n \n@@ -283,9 +341,9 @@ pub enum ModuleSource {\n }\n \n #[derive(Debug)]\n-pub struct ModuleLlvm {\n+struct ModuleLlvm {\n     llcx: llvm::ContextRef,\n-    pub llmod: llvm::ModuleRef,\n+    llmod: llvm::ModuleRef,\n     tm: llvm::TargetMachineRef,\n }\n \n@@ -302,20 +360,20 @@ impl Drop for ModuleLlvm {\n     }\n }\n \n-pub struct CrateTranslation {\n-    pub crate_name: Symbol,\n-    pub modules: Vec<CompiledModule>,\n+struct CrateTranslation {\n+    crate_name: Symbol,\n+    modules: Vec<CompiledModule>,\n     allocator_module: Option<CompiledModule>,\n     metadata_module: CompiledModule,\n-    pub link: rustc::middle::cstore::LinkMeta,\n-    pub metadata: rustc::middle::cstore::EncodedMetadata,\n+    link: rustc::middle::cstore::LinkMeta,\n+    metadata: rustc::middle::cstore::EncodedMetadata,\n     windows_subsystem: Option<String>,\n     linker_info: back::linker::LinkerInfo,\n     crate_info: CrateInfo,\n }\n \n // Misc info we load from metadata to persist beyond the tcx\n-pub struct CrateInfo {\n+struct CrateInfo {\n     panic_runtime: Option<CrateNum>,\n     compiler_builtins: Option<CrateNum>,\n     profiler_runtime: Option<CrateNum>,"}, {"sha": "15988008de2fc6981a4e3c44d9a7fb69cfcc7fd7", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -19,11 +19,12 @@ use std::ffi::{CStr, CString};\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Once;\n \n-pub fn init(sess: &Session) {\n+static POISONED: AtomicBool = AtomicBool::new(false);\n+static INIT: Once = Once::new();\n+\n+pub(crate) fn init(sess: &Session) {\n     unsafe {\n         // Before we touch LLVM, make sure that multithreading is enabled.\n-        static POISONED: AtomicBool = AtomicBool::new(false);\n-        static INIT: Once = Once::new();\n         INIT.call_once(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {\n                 // use an extra bool to make sure that all future usage of LLVM\n@@ -40,6 +41,13 @@ pub fn init(sess: &Session) {\n     }\n }\n \n+fn require_inited() {\n+    INIT.call_once(|| bug!(\"llvm is not initialized\"));\n+    if POISONED.load(Ordering::SeqCst) {\n+        bug!(\"couldn't enable multi-threaded LLVM\");\n+    }\n+}\n+\n unsafe fn configure_llvm(sess: &Session) {\n     let mut llvm_c_strs = Vec::new();\n     let mut llvm_args = Vec::new();\n@@ -125,17 +133,20 @@ pub fn target_feature_whitelist(sess: &Session) -> Vec<&CStr> {\n }\n \n pub fn print_version() {\n+    // Can be called without initializing LLVM\n     unsafe {\n         println!(\"LLVM version: {}.{}\",\n                  llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n     }\n }\n \n pub fn print_passes() {\n+    // Can be called without initializing LLVM\n     unsafe { llvm::LLVMRustPrintPasses(); }\n }\n \n-pub fn print(req: PrintRequest, sess: &Session) {\n+pub(crate) fn print(req: PrintRequest, sess: &Session) {\n+    require_inited();\n     let tm = create_target_machine(sess);\n     unsafe {\n         match req {"}, {"sha": "5eb6679fe252c0480d176e2419f90595d2840dc7", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -25,11 +25,10 @@ use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n use rustc::hir;\n use rustc::mir::mono::{Linkage, Visibility};\n-use rustc::ty::{TyCtxt, TypeFoldable};\n+use rustc::ty::TypeFoldable;\n use rustc::ty::layout::LayoutOf;\n use syntax::ast;\n use syntax::attr;\n-use syntax_pos::Span;\n use std::fmt;\n \n pub use rustc::mir::mono::MonoItem;\n@@ -107,18 +106,6 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                cx.codegen_unit.name());\n     }\n \n-    fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(Instance { def, .. }) => {\n-                tcx.hir.as_local_node_id(def.def_id())\n-            }\n-            MonoItem::Static(node_id) |\n-            MonoItem::GlobalAsm(node_id) => {\n-                Some(node_id)\n-            }\n-        }.map(|node_id| tcx.hir.span(node_id))\n-    }\n-\n     fn to_raw_string(&self) -> String {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {"}, {"sha": "7a01b6d261a34cca1cb90c6c6cad730037aabbb4", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -19,3 +19,5 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "13fa15faf4123048174da692bd8aa276b75a7a26", "filename": "src/librustc_trans_utils/diagnostics.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fdiagnostics.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+E0558: r##\"\n+The `export_name` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#[export_name] // error: export_name attribute has invalid format\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `export_name` attribute expects a string in order to determine the name of\n+the exported symbol. Example:\n+\n+```\n+#[export_name = \"some_function\"] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+}"}, {"sha": "9b7ab204492aeec6e44fa51bd0b5867c47990f96", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -35,18 +35,26 @@ extern crate log;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n+extern crate rustc_mir;\n+extern crate rustc_incremental;\n+#[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n+pub extern crate rustc as __rustc;\n+\n use rustc::ty::{TyCtxt, Instance};\n use rustc::hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::map as hir_map;\n use rustc::util::nodemap::NodeSet;\n \n+pub mod diagnostics;\n pub mod link;\n pub mod trans_crate;\n+pub mod symbol_names;\n+pub mod symbol_names_test;\n \n /// check for the #[rustc_error] annotation, which forces an\n /// error in trans. This is used to write compile-fail tests\n@@ -110,3 +118,6 @@ pub fn find_exported_symbols<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n         }\n     }).collect()\n }\n+\n+#[cfg(not(stage0))] // remove after the next snapshot\n+__build_diagnostic_array! { librustc_trans_utils, DIAGNOSTICS }"}, {"sha": "fb299bf7eea0c4ebadd4bea011c7ca19b7b16036", "filename": "src/librustc_trans_utils/symbol_names.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -97,11 +97,9 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use monomorphize::Instance;\n-use trans_item::{BaseMonoItemExt, InstantiationMode};\n-\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::MonoItem;\n+use rustc_mir::monomorphize::Instance;\n+use rustc_mir::monomorphize::item::{MonoItem, MonoItemExt, InstantiationMode};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};", "previous_filename": "src/librustc_trans/back/symbol_names.rs"}, {"sha": "5d7d4f3055bad6f47a6520561ce861f0eece9751", "filename": "src/librustc_trans_utils/symbol_names_test.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n-use monomorphize::Instance;\n+use rustc_mir::monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n const ITEM_PATH: &'static str = \"rustc_item_path\";", "previous_filename": "src/librustc_trans/symbol_names_test.rs"}, {"sha": "49756d754fe55edead0878dda179bb50d59aa575", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 112, "deletions": 68, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -26,6 +26,7 @@ use std::io::prelude::*;\n use std::io::{self, Cursor};\n use std::fs::File;\n use std::path::Path;\n+use std::rc::Rc;\n use std::sync::mpsc;\n \n use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n@@ -35,83 +36,81 @@ use flate2::write::DeflateEncoder;\n \n use syntax::symbol::Symbol;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::session::Session;\n-use rustc::session::config::{CrateType, OutputFilenames};\n+use rustc::session::{Session, CompileIncomplete};\n+use rustc::session::config::{CrateType, OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n use rustc_back::target::Target;\n+use rustc_mir::monomorphize::collector;\n use link::{build_link_meta, out_filename};\n \n pub trait TransCrate {\n-    type MetadataLoader: MetadataLoaderTrait;\n-    type OngoingCrateTranslation;\n-    type TranslatedCrate;\n+    fn print(&self, _req: PrintRequest, _sess: &Session) {}\n+    fn target_features(&self, _sess: &Session) -> Vec<Symbol> { vec![] }\n \n-    fn metadata_loader() -> Box<MetadataLoaderTrait>;\n-    fn provide(_providers: &mut Providers);\n-    fn provide_extern(_providers: &mut Providers);\n+    fn metadata_loader(&self) -> Box<MetadataLoader>;\n+    fn provide(&self, _providers: &mut Providers);\n+    fn provide_extern(&self, _providers: &mut Providers);\n     fn trans_crate<'a, 'tcx>(\n+        &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Self::OngoingCrateTranslation;\n-    fn join_trans(\n-        trans: Self::OngoingCrateTranslation,\n+    ) -> Box<Any>;\n+\n+    /// This is called on the returned `Box<Any>` from `trans_crate`\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when the passed `Box<Any>` was not returned by `trans_crate`.\n+    fn join_trans_and_link(\n+        &self,\n+        trans: Box<Any>,\n         sess: &Session,\n-        dep_graph: &DepGraph\n-    ) -> Self::TranslatedCrate;\n-    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames);\n-    fn dump_incremental_data(trans: &Self::TranslatedCrate);\n+        dep_graph: &DepGraph,\n+        outputs: &OutputFilenames,\n+    ) -> Result<(), CompileIncomplete>;\n }\n \n pub struct DummyTransCrate;\n \n impl TransCrate for DummyTransCrate {\n-    type MetadataLoader = DummyMetadataLoader;\n-    type OngoingCrateTranslation = ();\n-    type TranslatedCrate = ();\n-\n-    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+    fn metadata_loader(&self) -> Box<MetadataLoader> {\n         box DummyMetadataLoader(())\n     }\n \n-    fn provide(_providers: &mut Providers) {\n+    fn provide(&self, _providers: &mut Providers) {\n         bug!(\"DummyTransCrate::provide\");\n     }\n \n-    fn provide_extern(_providers: &mut Providers) {\n+    fn provide_extern(&self, _providers: &mut Providers) {\n         bug!(\"DummyTransCrate::provide_extern\");\n     }\n \n     fn trans_crate<'a, 'tcx>(\n+        &self,\n         _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Self::OngoingCrateTranslation {\n+    ) -> Box<Any> {\n         bug!(\"DummyTransCrate::trans_crate\");\n     }\n \n-    fn join_trans(\n-        _trans: Self::OngoingCrateTranslation,\n+    fn join_trans_and_link(\n+        &self,\n+        _trans: Box<Any>,\n         _sess: &Session,\n-        _dep_graph: &DepGraph\n-    ) -> Self::TranslatedCrate {\n-        bug!(\"DummyTransCrate::join_trans\");\n-    }\n-\n-    fn link_binary(_sess: &Session, _trans: &Self::TranslatedCrate, _outputs: &OutputFilenames) {\n-        bug!(\"DummyTransCrate::link_binary\");\n-    }\n-\n-    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {\n-        bug!(\"DummyTransCrate::dump_incremental_data\");\n+        _dep_graph: &DepGraph,\n+        _outputs: &OutputFilenames,\n+    ) -> Result<(), CompileIncomplete> {\n+        bug!(\"DummyTransCrate::join_trans_and_link\");\n     }\n }\n \n pub struct DummyMetadataLoader(());\n \n-impl MetadataLoaderTrait for DummyMetadataLoader {\n+impl MetadataLoader for DummyMetadataLoader {\n     fn get_rlib_metadata(\n         &self,\n         _target: &Target,\n@@ -131,7 +130,7 @@ impl MetadataLoaderTrait for DummyMetadataLoader {\n \n pub struct NoLlvmMetadataLoader;\n \n-impl MetadataLoaderTrait for NoLlvmMetadataLoader {\n+impl MetadataLoader for NoLlvmMetadataLoader {\n     fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n         let file = File::open(filename)\n             .map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n@@ -161,87 +160,132 @@ impl MetadataLoaderTrait for NoLlvmMetadataLoader {\n     }\n }\n \n-pub struct MetadataOnlyTransCrate;\n+pub struct MetadataOnlyTransCrate(());\n pub struct OngoingCrateTranslation {\n     metadata: EncodedMetadata,\n     metadata_version: Vec<u8>,\n     crate_name: Symbol,\n }\n-pub struct TranslatedCrate(OngoingCrateTranslation);\n \n impl MetadataOnlyTransCrate {\n-    #[allow(dead_code)]\n-    pub fn new() -> Self {\n-        MetadataOnlyTransCrate\n+    pub fn new(sess: &Session) -> Box<TransCrate> {\n+        for cty in sess.opts.crate_types.iter() {\n+            match *cty {\n+                CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n+                CrateType::CrateTypeExecutable => {},\n+                _ => {\n+                    sess.parse_sess.span_diagnostic.warn(\n+                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n+                    );\n+                },\n+            }\n+        }\n+\n+        box MetadataOnlyTransCrate(())\n     }\n }\n \n impl TransCrate for MetadataOnlyTransCrate {\n-    type MetadataLoader = NoLlvmMetadataLoader;\n-    type OngoingCrateTranslation = OngoingCrateTranslation;\n-    type TranslatedCrate = TranslatedCrate;\n-\n-    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+    fn metadata_loader(&self) -> Box<MetadataLoader> {\n         box NoLlvmMetadataLoader\n     }\n \n-    fn provide(_providers: &mut Providers) {}\n-    fn provide_extern(_providers: &mut Providers) {}\n+    fn provide(&self, providers: &mut Providers) {\n+        ::symbol_names::provide(providers);\n+        providers.target_features_enabled = |_tcx, _id| {\n+            Rc::new(Vec::new()) // Just a dummy\n+        };\n+    }\n+    fn provide_extern(&self, _providers: &mut Providers) {}\n \n     fn trans_crate<'a, 'tcx>(\n+        &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Self::OngoingCrateTranslation {\n+    ) -> Box<Any> {\n+        use rustc_mir::monomorphize::item::MonoItem;\n+\n         ::check_for_rustc_errors_attr(tcx);\n+        ::symbol_names_test::report_symbol_names(tcx);\n+        ::rustc_incremental::assert_dep_graph(tcx);\n+        ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+        ::rustc_mir::monomorphize::assert_symbols_are_distinct(tcx,\n+            collector::collect_crate_mono_items(\n+                tcx,\n+                collector::MonoItemCollectionMode::Eager\n+            ).0.iter()\n+        );\n+        ::rustc::middle::dependency_format::calculate(tcx);\n         let _ = tcx.link_args(LOCAL_CRATE);\n         let _ = tcx.native_libraries(LOCAL_CRATE);\n+        for trans_item in\n+            collector::collect_crate_mono_items(\n+                tcx,\n+                collector::MonoItemCollectionMode::Eager\n+            ).0 {\n+            match trans_item {\n+                MonoItem::Fn(inst) => {\n+                    let def_id = inst.def_id();\n+                    if def_id.is_local()  {\n+                        let _ = tcx.export_name(def_id);\n+                        let _ = tcx.contains_extern_indicator(def_id);\n+                        let _ = inst.def.is_inline(tcx);\n+                        let attrs = inst.def.attrs(tcx);\n+                        let _ =\n+                            ::syntax::attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n         tcx.sess.abort_if_errors();\n \n         let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n         let exported_symbols = ::find_exported_symbols(tcx);\n         let metadata = tcx.encode_metadata(&link_meta, &exported_symbols);\n \n-        OngoingCrateTranslation {\n+        box OngoingCrateTranslation {\n             metadata: metadata,\n             metadata_version: tcx.metadata_encoding_version().to_vec(),\n             crate_name: tcx.crate_name(LOCAL_CRATE),\n         }\n     }\n \n-    fn join_trans(\n-        trans: Self::OngoingCrateTranslation,\n-        _sess: &Session,\n+    fn join_trans_and_link(\n+        &self,\n+        trans: Box<Any>,\n+        sess: &Session,\n         _dep_graph: &DepGraph,\n-    ) -> Self::TranslatedCrate {\n-        TranslatedCrate(trans)\n-    }\n-\n-    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n+        outputs: &OutputFilenames,\n+    ) -> Result<(), CompileIncomplete> {\n+        let trans = trans.downcast::<OngoingCrateTranslation>()\n+            .expect(\"Expected MetadataOnlyTransCrate's OngoingCrateTranslation, found Box<Any>\");\n         for &crate_type in sess.opts.crate_types.iter() {\n             if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n                 continue;\n             }\n             let output_name =\n-                out_filename(sess, crate_type, &outputs, &trans.0.crate_name.as_str());\n-            let mut compressed = trans.0.metadata_version.clone();\n+                out_filename(sess, crate_type, &outputs, &trans.crate_name.as_str());\n+            let mut compressed = trans.metadata_version.clone();\n             let metadata = if crate_type == CrateType::CrateTypeDylib {\n                 DeflateEncoder::new(&mut compressed, Compression::fast())\n-                    .write_all(&trans.0.metadata.raw_data)\n+                    .write_all(&trans.metadata.raw_data)\n                     .unwrap();\n                 &compressed\n             } else {\n-                &trans.0.metadata.raw_data\n+                &trans.metadata.raw_data\n             };\n             let mut builder = Builder::new(File::create(&output_name).unwrap());\n             let header = Header::new(\"rust.metadata.bin\".to_string(), metadata.len() as u64);\n             builder.append(&header, Cursor::new(metadata)).unwrap();\n         }\n \n+        sess.abort_if_errors();\n         if !sess.opts.crate_types.contains(&CrateType::CrateTypeRlib)\n-            && !sess.opts.crate_types.contains(&CrateType::CrateTypeDylib) {\n+            && !sess.opts.crate_types.contains(&CrateType::CrateTypeDylib)\n+        {\n             sess.fatal(\"Executables are not supported by the metadata-only backend.\");\n         }\n+        Ok(())\n     }\n-\n-    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {}\n }"}, {"sha": "ef7d5b5ff84afb8926f1c3743a253d6899034a88", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -19,7 +19,6 @@ use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::util::nodemap::FxHashMap;\n use rustc_trans;\n-use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n@@ -140,22 +139,22 @@ pub fn run_core(search_paths: SearchPaths,\n                                                                false,\n                                                                Some(codemap.clone()));\n \n-    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, cpath, diagnostic_handler, codemap,\n     );\n-    rustc_trans::init(&sess);\n+    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n-    target_features::add_configuration(&mut cfg, &sess);\n+    target_features::add_configuration(&mut cfg, &sess, &*trans);\n     sess.parse_sess.config = cfg;\n \n     let control = &driver::CompileController::basic();\n \n     let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n \n-    let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n+    let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n \n     let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n         let result = driver::phase_2_configure_and_expand(&sess,\n@@ -177,7 +176,8 @@ pub fn run_core(search_paths: SearchPaths,\n                                                           &[],\n                                                           &sess);\n \n-    abort_on_err(driver::phase_3_run_analysis_passes(control,\n+    abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n+                                                     control,\n                                                      &sess,\n                                                      &*cstore,\n                                                      hir_map,"}, {"sha": "2e2dba7681cc39a9c3156bf28028e70b162949e7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -34,7 +34,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_const_math;\n-extern crate rustc_trans;\n+extern crate rustc_trans_utils;\n extern crate rustc_driver;\n extern crate rustc_resolve;\n extern crate rustc_lint;\n@@ -63,6 +63,8 @@ use std::path::{Path, PathBuf};\n use std::process;\n use std::sync::mpsc::channel;\n \n+use rustc_driver::rustc_trans;\n+\n use externalfiles::ExternalHtml;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options,"}, {"sha": "10850f88f2d624d2944d0aef915f9a4ba2f65638", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -34,7 +34,6 @@ use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n-use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n@@ -82,11 +81,11 @@ pub fn run(input_path: &Path,\n                                           true, false,\n                                           Some(codemap.clone()));\n \n-    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n     );\n-    rustc_trans::init(&sess);\n+    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess.parse_sess.config =\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n@@ -108,7 +107,7 @@ pub fn run(input_path: &Path,\n     };\n \n     let crate_name = crate_name.unwrap_or_else(|| {\n-        link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n+        ::rustc_trans_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n     });\n     let opts = scrape_test_config(hir_forest.krate());\n     let mut collector = Collector::new(crate_name,\n@@ -247,11 +246,11 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     // Compile the code\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n-    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, None, diagnostic_handler, codemap,\n     );\n-    rustc_trans::init(&sess);\n+    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n@@ -266,7 +265,17 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     }\n \n     let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-        driver::compile_input(&sess, &cstore, &None, &input, &out, &None, None, &control)\n+        driver::compile_input(\n+            trans,\n+            &sess,\n+            &cstore,\n+            &None,\n+            &input,\n+            &out,\n+            &None,\n+            None,\n+            &control\n+        )\n     }));\n \n     let compile_result = match res {"}, {"sha": "9a216d1d81ff8cf6e2a785a232678fdba2cd445b", "filename": "src/test/run-make/hotplug_codegen_backend/Makefile", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2FMakefile?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -0,0 +1,9 @@\n+include ../tools.mk\n+\n+all:\n+\t/bin/echo || exit 0 # This test requires /bin/echo to exist\n+\t$(RUSTC) the_backend.rs --crate-name the_backend --crate-type dylib \\\n+\t\t-o $(TMPDIR)/the_backend.dylib\n+\t$(RUSTC) some_crate.rs --crate-name some_crate --crate-type bin -o $(TMPDIR)/some_crate \\\n+\t\t-Z codegen-backend=$(TMPDIR)/the_backend.dylib -Z unstable-options\n+\tgrep -x \"This has been \\\"compiled\\\" succesfully.\" $(TMPDIR)/some_crate"}, {"sha": "26ffce01b2e2c0516f319e9527829e6a904793e8", "filename": "src/test/run-make/hotplug_codegen_backend/some_crate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fsome_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fsome_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fsome_crate.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ::std::process::exit(1);\n+}"}, {"sha": "0de404ed249d5eec54acb15d7ef2ab178180bbba", "filename": "src/test/run-make/hotplug_codegen_backend/the_backend.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+extern crate rustc_trans_utils;\n+\n+use std::any::Any;\n+use std::sync::mpsc;\n+use syntax::symbol::Symbol;\n+use rustc::session::{Session, CompileIncomplete};\n+use rustc::session::config::OutputFilenames;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use rustc::middle::cstore::MetadataLoader;\n+use rustc::dep_graph::DepGraph;\n+use rustc_trans_utils::trans_crate::{TransCrate, MetadataOnlyTransCrate};\n+\n+struct TheBackend(Box<TransCrate>);\n+\n+impl TransCrate for TheBackend {\n+    fn metadata_loader(&self) -> Box<MetadataLoader> {\n+        self.0.metadata_loader()\n+    }\n+\n+    fn provide(&self, providers: &mut Providers) {\n+        self.0.provide(providers);\n+    }\n+\n+    fn provide_extern(&self, providers: &mut Providers) {\n+        self.0.provide_extern(providers);\n+    }\n+\n+    fn trans_crate<'a, 'tcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Box<Any> {\n+        use rustc::hir::def_id::LOCAL_CRATE;\n+\n+        Box::new(tcx.crate_name(LOCAL_CRATE) as Symbol)\n+    }\n+\n+    fn join_trans_and_link(\n+        &self,\n+        trans: Box<Any>,\n+        sess: &Session,\n+        _dep_graph: &DepGraph,\n+        outputs: &OutputFilenames,\n+    ) -> Result<(), CompileIncomplete> {\n+        use std::io::Write;\n+        use rustc::session::config::CrateType;\n+        use rustc_trans_utils::link::out_filename;\n+        let crate_name = trans.downcast::<Symbol>()\n+            .expect(\"in join_trans_and_link: trans is not a Symbol\");\n+        for &crate_type in sess.opts.crate_types.iter() {\n+            if crate_type != CrateType::CrateTypeExecutable {\n+                sess.fatal(&format!(\"Crate type is {:?}\", crate_type));\n+            }\n+            let output_name =\n+                out_filename(sess, crate_type, &outputs, &*crate_name.as_str());\n+            let mut out_file = ::std::fs::File::create(output_name).unwrap();\n+            write!(out_file, \"This has been \\\"compiled\\\" succesfully.\").unwrap();\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// This is the entrypoint for a hot plugged rustc_trans\n+#[no_mangle]\n+pub fn __rustc_codegen_backend(sess: &Session) -> Box<TransCrate> {\n+    Box::new(TheBackend(MetadataOnlyTransCrate::new(sess)))\n+}"}, {"sha": "c360dde618ef54f2f2a7167c0081f4643a505716", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -16,6 +16,7 @@ extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n extern crate rustc_trans;\n+extern crate rustc_trans_utils;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n@@ -25,6 +26,7 @@ use rustc_driver::driver::{compile_input, CompileController};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n use syntax::codemap::FileName;\n+use rustc_trans_utils::trans_crate::TransCrate;\n \n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -51,7 +53,7 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n+fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<TransCrate>) {\n     let mut opts = basic_options();\n     opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n     opts.maybe_sysroot = Some(sysroot);\n@@ -60,16 +62,26 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     }\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n-    let cstore = Rc::new(CStore::new(Box::new(rustc_trans::LlvmMetadataLoader)));\n     let sess = build_session(opts, None, descriptions);\n-    rustc_trans::init(&sess);\n+    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    (sess, cstore)\n+    (sess, cstore, trans)\n }\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n-    let (sess, cstore) = basic_sess(sysroot);\n+    let (sess, cstore, trans) = basic_sess(sysroot);\n     let control = CompileController::basic();\n     let input = Input::Str { name: FileName::Anon, input: code };\n-    let _ = compile_input(&sess, &cstore, &None, &input, &None, &Some(output), None, &control);\n+    let _ = compile_input(\n+        trans,\n+        &sess,\n+        &cstore,\n+        &None,\n+        &input,\n+        &None,\n+        &Some(output),\n+        None,\n+        &control\n+    );\n }"}, {"sha": "6a8e1728b20a83773edaac0598ce0e119455cdd0", "filename": "src/test/run-make/llvm-phase/Makefile", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Frun-make%2Fllvm-phase%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Frun-make%2Fllvm-phase%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2FMakefile?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -1,5 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) test.rs\n-\t$(call RUN,test $(RUSTC))"}, {"sha": "2ff4593a801fe74601708e30d9ea0d79a87edf32", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e93beae9562f8b32b7f82c3824389f6ac5bad/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=8d3e93beae9562f8b32b7f82c3824389f6ac5bad", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(plugin, rustc_private, box_syntax)]\n-\n-extern crate rustc;\n-extern crate rustc_driver;\n-extern crate rustc_llvm;\n-extern crate rustc_trans;\n-#[macro_use] extern crate syntax;\n-extern crate getopts;\n-\n-use rustc_driver::{CompilerCalls, Compilation};\n-use rustc_driver::driver::CompileController;\n-use rustc_trans::ModuleSource;\n-use rustc::session::Session;\n-use syntax::codemap::FileLoader;\n-use std::env;\n-use std::io;\n-use std::path::{PathBuf, Path};\n-\n-struct JitLoader;\n-\n-impl FileLoader for JitLoader {\n-    fn file_exists(&self, _: &Path) -> bool { true }\n-    fn abs_path(&self, _: &Path) -> Option<PathBuf> { None }\n-    fn read_file(&self, _: &Path) -> io::Result<String> {\n-        Ok(r#\"\n-#[no_mangle]\n-pub fn test_add(a: i32, b: i32) -> i32 { a + b }\n-\"#.to_string())\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct JitCalls;\n-\n-impl<'a> CompilerCalls<'a> for JitCalls {\n-    fn build_controller(&mut self,\n-                        _: &Session,\n-                        _: &getopts::Matches)\n-                        -> CompileController<'a> {\n-        let mut cc = CompileController::basic();\n-        cc.after_llvm.stop = Compilation::Stop;\n-        cc.after_llvm.run_callback_on_error = true;\n-        cc.after_llvm.callback = Box::new(|state| {\n-            state.session.abort_if_errors();\n-            let trans = state.trans.unwrap();\n-            assert_eq!(trans.modules.len(), 1);\n-            println!(\"name of compiled module = {}\", trans.modules[0].name);\n-        });\n-        cc\n-    }\n-}\n-\n-fn main() {\n-    use rustc_driver;\n-\n-    let mut path = match std::env::args().nth(2) {\n-        Some(path) => PathBuf::from(&path),\n-        None => panic!(\"missing rustc path\")\n-    };\n-\n-    // Remove two segments from rustc path to get sysroot.\n-    path.pop();\n-    path.pop();\n-\n-    let mut args: Vec<String> =\n-        format!(\"_ _ --sysroot {} --crate-type dylib\", path.to_str().unwrap())\n-        .split(' ').map(|s| s.to_string()).collect();\n-    args.push(\"--out-dir\".to_string());\n-    args.push(env::var(\"TMPDIR\").unwrap());\n-    args.push(\"-Ccodegen-units=1\".to_string());\n-\n-    let (result, _) = rustc_driver::run_compiler(\n-        &args, &mut JitCalls, Some(box JitLoader), None);\n-    if let Err(n) = result {\n-        panic!(\"Error {:?}\", n);\n-    }\n-}"}, {"sha": "85aa92ce26076059b10fd46ba0e80d0581f56db6", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9368a1e3e2b5f27438754c149948a877edbcd767/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=9368a1e3e2b5f27438754c149948a877edbcd767", "patch": "@@ -18,13 +18,15 @@\n extern crate getopts;\n extern crate rustc;\n extern crate rustc_driver;\n+extern crate rustc_trans_utils;\n extern crate syntax;\n extern crate rustc_errors as errors;\n \n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n+use rustc_trans_utils::trans_crate::TransCrate;\n use syntax::ast;\n \n use std::path::PathBuf;\n@@ -46,6 +48,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     }\n \n     fn late_callback(&mut self,\n+                     _: &TransCrate,\n                      _: &getopts::Matches,\n                      _: &Session,\n                      _: &CrateStore,"}]}