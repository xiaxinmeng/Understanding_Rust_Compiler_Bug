{"sha": "10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "node_id": "C_kwDOAAsO6NoAKDEwZWMwM2MzZmI0NTA5Zjk2ZGYzYWE4MjY0ODU4Yjc2ZTgxYzlhYTE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-18T17:42:30Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-18T17:42:30Z"}, "message": "Don't transmute `&List<GenericArg>` <-> `&List<Ty>`", "tree": {"sha": "014779de6857edbdd8ce49903c701ee06d7faa3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/014779de6857edbdd8ce49903c701ee06d7faa3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "html_url": "https://github.com/rust-lang/rust/commit/10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8c0c1eafe625dd06872184ed5999ed3ee60b424", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c0c1eafe625dd06872184ed5999ed3ee60b424", "html_url": "https://github.com/rust-lang/rust/commit/e8c0c1eafe625dd06872184ed5999ed3ee60b424"}], "stats": {"total": 85, "additions": 30, "deletions": 55}, "files": [{"sha": "0a0040e22041798a4d5179ad69a987ce5971cdc3", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "patch": "@@ -141,6 +141,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: InternedSet<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>,\n     const_lists: InternedSet<'tcx, List<ty::Const<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n+    type_lists: InternedSet<'tcx, List<Ty<'tcx>>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n     poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n@@ -163,6 +164,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             type_: Default::default(),\n             const_lists: Default::default(),\n             substs: Default::default(),\n+            type_lists: Default::default(),\n             region: Default::default(),\n             poly_existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n@@ -1278,25 +1280,6 @@ macro_rules! nop_lift {\n     };\n }\n \n-// Can't use the macros as we have reuse the `substs` here.\n-//\n-// See `mk_type_list` for more info.\n-impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n-    type Lifted = &'tcx List<Ty<'tcx>>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        if self.is_empty() {\n-            return Some(List::empty());\n-        }\n-\n-        tcx.interners\n-            .substs\n-            .contains_pointer_to(&InternedInSet(self.as_substs()))\n-            // SAFETY: `self` is interned and therefore valid\n-            // for the entire lifetime of the `TyCtxt`.\n-            .then(|| unsafe { mem::transmute::<&'a List<Ty<'a>>, &'tcx List<Ty<'tcx>>>(self) })\n-    }\n-}\n-\n macro_rules! nop_list_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n@@ -1320,6 +1303,7 @@ nop_lift! {const_; Const<'a> => Const<'tcx>}\n nop_lift! {const_allocation; ConstAllocation<'a> => ConstAllocation<'tcx>}\n nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n+nop_list_lift! {type_lists; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {poly_existential_predicates; PolyExistentialPredicate<'a> => PolyExistentialPredicate<'tcx>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n@@ -1594,6 +1578,7 @@ macro_rules! slice_interners {\n slice_interners!(\n     const_lists: pub mk_const_list(Const<'tcx>),\n     substs: pub mk_substs(GenericArg<'tcx>),\n+    type_lists: pub mk_type_list(Ty<'tcx>),\n     canonical_var_infos: pub mk_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates: intern_poly_existential_predicates(PolyExistentialPredicate<'tcx>),\n     predicates: intern_predicates(Predicate<'tcx>),\n@@ -2193,18 +2178,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         T::collect_and_apply(iter, |xs| self.mk_const_list(xs))\n     }\n \n-    pub fn mk_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n-        // Actually intern type lists as lists of `GenericArg`s.\n-        //\n-        // Transmuting from `Ty<'tcx>` to `GenericArg<'tcx>` is sound\n-        // as explained in `ty_slice_as_generic_arg`. With this,\n-        // we guarantee that even when transmuting between `List<Ty<'tcx>>`\n-        // and `List<GenericArg<'tcx>>`, the uniqueness requirement for\n-        // lists is upheld.\n-        let substs = self.mk_substs(ty::subst::ty_slice_as_generic_args(ts));\n-        substs.try_as_type_list().unwrap()\n-    }\n-\n     // Unlike various other `mk_*_from_iter` functions, this one uses `I:\n     // IntoIterator` instead of `I: Iterator`, and it doesn't have a slice\n     // variant, because of the need to combine `inputs` and `output`. This"}, {"sha": "da3cd27f3884451bff484bee2effc800e35c8b28", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "patch": "@@ -67,19 +67,6 @@ pub fn ty_slice_as_generic_args<'a, 'tcx>(ts: &'a [Ty<'tcx>]) -> &'a [GenericArg\n     unsafe { slice::from_raw_parts(ts.as_ptr().cast(), ts.len()) }\n }\n \n-impl<'tcx> List<Ty<'tcx>> {\n-    /// Allows to freely switch between `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>`.\n-    ///\n-    /// As lists are interned, `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>` have\n-    /// be interned together, see `mk_type_list` for more details.\n-    #[inline]\n-    pub fn as_substs(&'tcx self) -> SubstsRef<'tcx> {\n-        assert_eq!(TYPE_TAG, 0);\n-        // SAFETY: `List<T>` is `#[repr(C)]`. `Ty` and `GenericArg` is explained above.\n-        unsafe { &*(self as *const List<Ty<'tcx>> as *const List<GenericArg<'tcx>>) }\n-    }\n-}\n-\n impl<'tcx> GenericArgKind<'tcx> {\n     #[inline]\n     fn pack(self) -> GenericArg<'tcx> {\n@@ -268,13 +255,16 @@ pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'tcx> InternalSubsts<'tcx> {\n-    /// Checks whether all elements of this list are types, if so, transmute.\n-    pub fn try_as_type_list(&'tcx self) -> Option<&'tcx List<Ty<'tcx>>> {\n-        self.iter().all(|arg| matches!(arg.unpack(), GenericArgKind::Type(_))).then(|| {\n-            assert_eq!(TYPE_TAG, 0);\n-            // SAFETY: All elements are types, see `List<Ty<'tcx>>::as_substs`.\n-            unsafe { &*(self as *const List<GenericArg<'tcx>> as *const List<Ty<'tcx>>) }\n-        })\n+    /// Converts substs to a type list.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If any of the generic arguments are not types.\n+    pub fn into_type_list(&self, tcx: TyCtxt<'tcx>) -> &'tcx List<Ty<'tcx>> {\n+        tcx.mk_type_list_from_iter(self.iter().map(|arg| match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+            _ => bug!(\"`into_type_list` called on substs with non-types\"),\n+        }))\n     }\n \n     /// Interpret these substitutions as the substitutions of a closure type."}, {"sha": "4d225e36b22cd4bad80e3873606cbafd55309c98", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ec03c3fb4509f96df3aa8264858b76e81c9aa1/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=10ec03c3fb4509f96df3aa8264858b76e81c9aa1", "patch": "@@ -60,6 +60,20 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>> for Subst\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>>\n+    for &'tcx ty::List<Ty<'tcx>>\n+{\n+    fn lower_into(\n+        self,\n+        interner: RustInterner<'tcx>,\n+    ) -> chalk_ir::Substitution<RustInterner<'tcx>> {\n+        chalk_ir::Substitution::from_iter(\n+            interner,\n+            self.iter().map(|ty| GenericArg::from(ty).lower_into(interner)),\n+        )\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, SubstsRef<'tcx>> for &chalk_ir::Substitution<RustInterner<'tcx>> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> SubstsRef<'tcx> {\n         interner\n@@ -351,9 +365,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             ty::GeneratorWitness(_) => unimplemented!(),\n             ty::GeneratorWitnessMIR(..) => unimplemented!(),\n             ty::Never => chalk_ir::TyKind::Never,\n-            ty::Tuple(types) => {\n-                chalk_ir::TyKind::Tuple(types.len(), types.as_substs().lower_into(interner))\n-            }\n+            ty::Tuple(types) => chalk_ir::TyKind::Tuple(types.len(), types.lower_into(interner)),\n             ty::Alias(ty::Projection, ty::AliasTy { def_id, substs, .. }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n                     associated_ty_id: chalk_ir::AssocTypeId(def_id),\n@@ -435,7 +447,7 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n             TyKind::GeneratorWitness(..) => unimplemented!(),\n             TyKind::Never => ty::Never,\n             TyKind::Tuple(_len, substitution) => {\n-                ty::Tuple(substitution.lower_into(interner).try_as_type_list().unwrap())\n+                ty::Tuple(substitution.lower_into(interner).into_type_list(interner.tcx))\n             }\n             TyKind::Slice(ty) => ty::Slice(ty.lower_into(interner)),\n             TyKind::Raw(mutbl, ty) => ty::RawPtr(ty::TypeAndMut {"}]}