{"sha": "adc7351fb027494ede35d6d3abd7ca02a11c33ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYzczNTFmYjAyNzQ5NGVkZTM1ZDZkM2FiZDdjYTAyYTExYzMzY2U=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-08-28T14:10:16Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-08-28T16:43:25Z"}, "message": "Merge commit '3d0b0e66afdfaa519d8855b338b35b4605775945' into clippyup", "tree": {"sha": "d061eadf7cfee08e7eb16302adec7f0c59221cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d061eadf7cfee08e7eb16302adec7f0c59221cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adc7351fb027494ede35d6d3abd7ca02a11c33ce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl9JNC8ACgkQaTCGhp1Q\nZjc67xAAtsaTDkwKsckzih0VNMw42SdkkIdVIKuTDH+8Lr+w5CXepY1xw8YBI00U\nmuki3q673IFVSCt+yKhZ7Ogz4aEVkMwHTT9g1KrHJILKOhh+BOV2bAoBa5sQ4TEd\nRPHV4Sz5+ZuwQHEcygQsD6V8/0fR2gjYaWMrVjMXAIVc14FSLMUwO0Pci3wunerN\nWwBO7OceCLRrzKxcs/LKEKefzVEAkttGt3YIoT5NweCHFVaFUgIJ2n06SqCQAOmH\ndL3TiHq97Q1we+d8jY5x2euNEoP3dsX/yxWdTg2JWgbL0OM++HUm6DaHFguCB0f9\nU0u1Q97Z3pILqueXI1yXeJugt9FQFmCU0FjTEr1q7KW2DwUSUUypNDJlpflIZj1p\ne3xTHtsUKhtB6fC2YKRydJ2UzLeXBE/jurjJo6EkijUGQgyzcrCeq/pKcaLbxHTk\niHsCIHg+XIUpwkitghOXcDyeelg8xDPSUFPUlpVq+sEvDv00P+g4ZvaDlNRieEn9\nK4yQzac08gLZpu3HY+eE+87bCs7XrwHIoW7wUrRZPEf+dPJcpt//xXMz23mGESbA\nqoscFWlW/Rz4lzdTb2jgSkw9LcdYrDnSiVNlMWTEMSA0jRA0W7Ld/CYTJmyV9XaP\nDqCMAY36Se4FHv1dv4C5YRGz/rdSWewopoKwqzHYunubj445wgk=\n=A2YD\n-----END PGP SIGNATURE-----", "payload": "tree d061eadf7cfee08e7eb16302adec7f0c59221cd1\nparent 3e3c552605180d739eb6c23bc657121679caa456\nparent 3d0b0e66afdfaa519d8855b338b35b4605775945\nauthor flip1995 <hello@philkrones.com> 1598623816 +0200\ncommitter flip1995 <hello@philkrones.com> 1598633005 +0200\n\nMerge commit '3d0b0e66afdfaa519d8855b338b35b4605775945' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adc7351fb027494ede35d6d3abd7ca02a11c33ce", "html_url": "https://github.com/rust-lang/rust/commit/adc7351fb027494ede35d6d3abd7ca02a11c33ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adc7351fb027494ede35d6d3abd7ca02a11c33ce/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e3c552605180d739eb6c23bc657121679caa456", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3c552605180d739eb6c23bc657121679caa456", "html_url": "https://github.com/rust-lang/rust/commit/3e3c552605180d739eb6c23bc657121679caa456"}, {"sha": "3d0b0e66afdfaa519d8855b338b35b4605775945", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0b0e66afdfaa519d8855b338b35b4605775945", "html_url": "https://github.com/rust-lang/rust/commit/3d0b0e66afdfaa519d8855b338b35b4605775945"}], "stats": {"total": 5252, "additions": 4160, "deletions": 1092}, "files": [{"sha": "e70da43ab47abe45cb278e82216729723d7d37b0", "filename": "src/tools/clippy/.cargo/config", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2F.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2F.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.cargo%2Fconfig?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,6 +1,6 @@\n [alias]\n uitest = \"test --test compile-test\"\n-dev = \"run --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n+dev = \"run --target-dir clippy_dev/target --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n \n [build]\n rustflags = [\"-Zunstable-options\"]"}, {"sha": "99e371631b149bbef1b7f537fbfd19fcc20eb982", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -92,6 +92,13 @@ jobs:\n       env:\n         OS: ${{ runner.os }}\n \n+    - name: Test cargo dev new lint\n+      run: |\n+        cargo dev new_lint --name new_early_pass --pass early\n+        cargo dev new_lint --name new_late_pass --pass late\n+        cargo check\n+        git reset --hard HEAD\n+\n     # Cleanup\n     - name: Run cargo-cache --autoclean\n       run: |"}, {"sha": "137b561028a658fae51e18d0a5a16601a1a66e9c", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1498,6 +1498,7 @@ Released 2018-09-13\n [`float_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_arithmetic\n [`float_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp\n [`float_cmp_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp_const\n+[`float_equality_without_abs`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_equality_without_abs\n [`fn_address_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_address_comparisons\n [`fn_params_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_params_excessive_bools\n [`fn_to_numeric_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast\n@@ -1690,6 +1691,7 @@ Released 2018-09-13\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n+[`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse\n [`shadow_same`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_same\n@@ -1699,6 +1701,7 @@ Released 2018-09-13\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n [`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n+[`single_char_push_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_push_str\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n@@ -1723,6 +1726,7 @@ Released 2018-09-13\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n+[`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n [`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines\n@@ -1752,6 +1756,7 @@ Released 2018-09-13\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n+[`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n@@ -1773,6 +1778,7 @@ Released 2018-09-13\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n+[`unwrap_in_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_in_result\n [`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n [`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self"}, {"sha": "54777810abbdfac70346b952f2510388aa1e789c", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -189,6 +189,35 @@ Clippy in the `rust-lang/rust` repository.\n For general information about `subtree`s in the Rust repository see [Rust's\n `CONTRIBUTING.md`][subtree].\n \n+### Patching git-subtree to work with big repos\n+\n+Currently there's a bug in `git-subtree` that prevents it from working properly\n+with the [`rust-lang/rust`] repo. There's an open PR to fix that, but it's stale.\n+Before continuing with the following steps, we need to manually apply that fix to\n+our local copy of `git-subtree`.\n+\n+You can get the patched version of `git-subtree` from [here][gitgitgadget-pr].\n+Put this file under `/usr/lib/git-core` (taking a backup of the previous file)\n+and make sure it has the proper permissions:\n+\n+```bash\n+sudo cp --backup /path/to/patched/git-subtree.sh /usr/lib/git-core/git-subtree\n+sudo chmod --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree\n+sudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree\n+```\n+\n+_Note:_ The first time running `git subtree push` a cache has to be built. This\n+involves going through the complete Clippy history once. For this you have to\n+increase the stack limit though, which you can do with `ulimit -s 60000`.\n+Make sure to run the `ulimit` command from the same session you call git subtree.\n+\n+_Note:_ If you are a Debian user, `dash` is the shell used by default for scripts instead of `sh`.\n+This shell has a hardcoded recursion limit set to 1000. In order to make this process work,\n+you need to force the script to run `bash` instead. You can do this by editing the first\n+line of the `git-subtree` script and changing `sh` to `bash`.\n+\n+### Performing the sync\n+\n Here is a TL;DR version of the sync process (all of the following commands have\n to be run inside the `rust` directory):\n \n@@ -198,6 +227,7 @@ to be run inside the `rust` directory):\n     # Make sure to change `your-github-name` to your github name in the following command\n     git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n     ```\n+\n     _Note:_ This will directly push to the remote repository. You can also push\n     to your local copy by replacing the remote address with `/path/to/rust-clippy`\n     directory.\n@@ -213,14 +243,30 @@ to be run inside the `rust` directory):\n 3. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n    accelerate the process ping the `@rust-lang/clippy` team in your PR and/or\n    ~~annoy~~ ask them in the [Discord] channel.)\n-4. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n+   \n+### Syncing back changes in Clippy to [`rust-lang/rust`]\n+\n+To avoid flooding the [`rust-lang/rust`] PR queue, changes in Clippy's repo are synced back\n+in a bi-weekly basis if there's no urgent changes. This is done starting on the day of\n+the Rust stable release and then every other week. That way we guarantee that\n+every feature in Clippy is available for 2 weeks in nightly, before it can get to beta.\n+For reference, the first sync following this cadence was performed the 2020-08-27.\n+\n+All of the following commands have to be run inside the `rust` directory.\n+\n+1. Make sure Clippy itself is up-to-date by following the steps outlined in the previous\n+section if necessary.\n+\n+2. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n     ```bash\n     git checkout -b sync-from-clippy\n     git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n     ```\n-5. Open a PR to [`rust-lang/rust`]\n+3. Open a PR to [`rust-lang/rust`]\n+\n+### Defining remotes\n \n-Also, you may want to define remotes, so you don't have to type out the remote\n+You may want to define remotes, so you don't have to type out the remote\n addresses on every sync. You can do this with the following commands (these\n commands still have to be run inside the `rust` directory):\n \n@@ -241,12 +287,6 @@ You can then sync with the remote names from above, e.g.:\n $ git subtree push -P src/tools/clippy clippy-local sync-from-rust\n ```\n \n-_Note:_ The first time running `git subtree push` a cache has to be built. This\n-involves going through the complete Clippy history once. For this you have to\n-increase the stack limit though, which you can do with `ulimit -s 60000`. For\n-this to work, you will need the fix of `git subtree` available\n-[here][gitgitgadget-pr].\n-\n [gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n [subtree]: https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust"}, {"sha": "c7a3099b8ab0a4f0857cce4b5d079b359a27e85e", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -31,13 +31,13 @@ path = \"src/driver.rs\"\n # begin automatic update\n clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n # end automatic update\n-semver = \"0.9\"\n+semver = \"0.10\"\n rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n tempfile = { version = \"3.1.0\", optional = true }\n lazy_static = \"1.0\"\n \n [dev-dependencies]\n-cargo_metadata = \"0.9.1\"\n+cargo_metadata = \"0.11.1\"\n compiletest_rs = { version = \"0.5.0\", features = [\"tmp\"] }\n tester = \"0.7\"\n lazy_static = \"1.0\""}, {"sha": "d951ca0e6308d154d8d121b8bf1880067656015d", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -47,7 +47,7 @@ pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str\n fn create_lint(lint: &LintData) -> io::Result<()> {\n     let (pass_type, pass_lifetimes, pass_import, context_import) = match lint.pass {\n         \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n-        \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n+        \"late\" => (\"LateLintPass\", \"<'_>\", \"use rustc_hir::*;\", \"LateContext\"),\n         _ => {\n             unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n         },"}, {"sha": "cc7d3a04f003ee0728feb89aa83ef147fe12e7ac", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -17,7 +17,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2018\"\n \n [dependencies]\n-cargo_metadata = \"0.9.1\"\n+cargo_metadata = \"0.11.1\"\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n lazy_static = \"1.0.2\"\n@@ -28,7 +28,7 @@ serde = { version = \"1.0\", features = [\"derive\"] }\n smallvec = { version = \"1\", features = [\"union\"] }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n-semver = \"0.9.0\"\n+semver = \"0.10.0\"\n # NOTE: cargo requires serde feat in its url dep\n # see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n url = { version =  \"2.1.0\", features = [\"serde\"] }"}, {"sha": "b3185b88840142253648eb1eb033dca657d20aa6", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method,\n };\n use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n@@ -70,11 +70,11 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                         return;\n                     }\n                     // lhs op= l op r\n-                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                    if eq_expr_value(cx, lhs, l) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n                     }\n                     // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n@@ -161,14 +161,12 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n \n                     if visitor.counter == 1 {\n                         // a = a op b\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, l) {\n+                        if eq_expr_value(cx, assignee, l) {\n                             lint(assignee, r);\n                         }\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.typeck_results().expr_ty(assignee).is_primitive_ty()\n-                        {\n+                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n                             match op.node {\n                                 hir::BinOpKind::Add\n                                 | hir::BinOpKind::Mul\n@@ -253,7 +251,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if SpanlessEq::new(self.cx).ignore_fn().eq_expr(self.assignee, expr) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n             self.counter += 1;\n         }\n "}, {"sha": "cfcc1b3c5f356948df9bb333ccc292dd7a12e06e", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -5,8 +5,8 @@ use crate::utils::{\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,"}, {"sha": "280a2c7fe6770c68987354a8c7bfc7f8c527ef02", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt, span_lint_and_sugg,\n-    span_lint_and_then, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt,\n+    span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n-            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n+            if eq_expr_value(self.cx, e, expr) {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n@@ -138,8 +138,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 if implements_ord(self.cx, e_lhs);\n                 if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.kind;\n                 if negate(e_binop.node) == Some(expr_binop.node);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                if eq_expr_value(self.cx, e_lhs, expr_lhs);\n+                if eq_expr_value(self.cx, e_rhs, expr_rhs);\n                 then {\n                     #[allow(clippy::cast_possible_truncation)]\n                     return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));"}, {"sha": "10a64769585e543bdbfd46ae8cd59287080bfd5f", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,5 @@\n+use crate::utils::{eq_expr_value, SpanlessEq, SpanlessHash};\n use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n-use crate::utils::{SpanlessEq, SpanlessHash};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -197,8 +197,7 @@ fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool =\n-        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool { eq_expr_value(cx, lhs, rhs) };\n \n     for (i, j) in search_same(conds, hash, eq) {\n         span_lint_and_note(\n@@ -222,7 +221,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n \n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not spawn warning if `IFS_SAME_COND` already produced it.\n-        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) {\n+        if eq_expr_value(cx, lhs, rhs) {\n             return false;\n         }\n         SpanlessEq::new(cx).eq_expr(lhs, rhs)"}, {"sha": "9555459e240e9f874ba29132cb32eb47fe531161", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,16 +1,22 @@\n use crate::utils::{implements_trait, is_entrypoint_fn, is_type_diagnostic_item, return_ty, span_lint};\n use if_chain::if_chain;\n use itertools::Itertools;\n-use rustc_ast::ast::{AttrKind, Attribute};\n+use rustc_ast::ast::{Async, AttrKind, Attribute, FnRetTy, ItemKind};\n use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::emitter::EmitterWriter;\n+use rustc_errors::Handler;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n+use rustc_parse::maybe_new_parser_from_source_str;\n+use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{BytePos, MultiSpan, Span};\n-use rustc_span::Pos;\n+use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n+use rustc_span::{FileName, Pos};\n+use std::io;\n use std::ops::Range;\n use url::Url;\n \n@@ -431,10 +437,67 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     headers\n }\n \n-static LEAVE_MAIN_PATTERNS: &[&str] = &[\"static\", \"fn main() {}\", \"extern crate\", \"async fn main() {\"];\n-\n fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n-    if text.contains(\"fn main() {\") && !LEAVE_MAIN_PATTERNS.iter().any(|p| text.contains(p)) {\n+    fn has_needless_main(code: &str) -> bool {\n+        let filename = FileName::anon_source_code(code);\n+\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+        let handler = Handler::with_emitter(false, None, box emitter);\n+        let sess = ParseSess::with_span_handler(handler, sm);\n+\n+        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+            Ok(p) => p,\n+            Err(errs) => {\n+                for mut err in errs {\n+                    err.cancel();\n+                }\n+                return false;\n+            },\n+        };\n+\n+        let mut relevant_main_found = false;\n+        loop {\n+            match parser.parse_item() {\n+                Ok(Some(item)) => match &item.kind {\n+                    // Tests with one of these items are ignored\n+                    ItemKind::Static(..)\n+                    | ItemKind::Const(..)\n+                    | ItemKind::ExternCrate(..)\n+                    | ItemKind::ForeignMod(..) => return false,\n+                    // We found a main function ...\n+                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym!(main) => {\n+                        let is_async = matches!(sig.header.asyncness, Async::Yes{..});\n+                        let returns_nothing = match &sig.decl.output {\n+                            FnRetTy::Default(..) => true,\n+                            FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n+                            _ => false,\n+                        };\n+\n+                        if returns_nothing && !is_async && !block.stmts.is_empty() {\n+                            // This main function should be linted, but only if there are no other functions\n+                            relevant_main_found = true;\n+                        } else {\n+                            // This main function should not be linted, we're done\n+                            return false;\n+                        }\n+                    },\n+                    // Another function was found; this case is ignored too\n+                    ItemKind::Fn(..) => return false,\n+                    _ => {},\n+                },\n+                Ok(None) => break,\n+                Err(mut e) => {\n+                    e.cancel();\n+                    return false;\n+                },\n+            }\n+        }\n+\n+        relevant_main_found\n+    }\n+\n+    if has_needless_main(text) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "19f56195ec1b483d693c8e20d6464ca4864c0fa9", "filename": "src/tools/clippy/clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -6,7 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, snippet_with_applicability, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for double comparisons that could be simplified to a single expression.\n@@ -46,8 +46,7 @@ impl<'tcx> DoubleComparisons {\n             },\n             _ => return,\n         };\n-        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n-        if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n+        if !(eq_expr_value(cx, &llhs, &rlhs) && eq_expr_value(cx, &lrhs, &rrhs)) {\n             return;\n         }\n         macro_rules! lint_double_comparison {"}, {"sha": "8ece44878fe32c6c7bcd1777e717cd6e185137ec", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n                     cx,\n                     DURATION_SUBSEC,\n                     expr.span,\n-                    &format!(\"Calling `{}()` is more concise than this calculation\", suggested_fn),\n+                    &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n                     \"try\",\n                     format!(\n                         \"{}.{}()\","}, {"sha": "48caf48dbdb2cab0e80f0e2f4ee70e631c225a62", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                             cx,\n                             ENUM_CLIKE_UNPORTABLE_VARIANT,\n                             var.span,\n-                            \"Clike enum variant discriminant is not portable to 32-bit targets\",\n+                            \"C-like enum variant discriminant is not portable to 32-bit targets\",\n                         );\n                     };\n                 }"}, {"sha": "a9294a87f15d060d23878f0ff1a15705713d8395", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -183,10 +183,10 @@ fn check_variant(\n             && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n             && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n         {\n-            span_lint(cx, lint, var.span, \"Variant name starts with the enum's name\");\n+            span_lint(cx, lint, var.span, \"variant name starts with the enum's name\");\n         }\n         if partial_rmatch(item_name, &name) == item_name_chars {\n-            span_lint(cx, lint, var.span, \"Variant name ends with the enum's name\");\n+            span_lint(cx, lint, var.span, \"variant name ends with the enum's name\");\n         }\n     }\n     let first = &def.variants[0].ident.name.as_str();\n@@ -227,7 +227,7 @@ fn check_variant(\n         cx,\n         lint,\n         span,\n-        &format!(\"All variants have the same {}fix: `{}`\", what, value),\n+        &format!(\"all variants have the same {}fix: `{}`\", what, value),\n         None,\n         &format!(\n             \"remove the {}fixes and use full paths to \\"}, {"sha": "e16ec783fab79c6c6744bcfaa958786ca7e912e5", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq,\n+    eq_expr_value, implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then,\n };\n use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind};\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+            if is_valid_operator(op) && eq_expr_value(cx, left, right) {\n                 span_lint(\n                     cx,\n                     EQ_OP,"}, {"sha": "9ac5a45eb4590c6b65c9e8f29ee74647ebc2a896", "filename": "src/tools/clippy/clippy_lints/src/float_equality_without_abs.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,110 @@\n+use crate::utils::{match_qpath, paths, span_lint_and_then, sugg};\n+use if_chain::if_chain;\n+use rustc_ast::util::parser::AssocOp;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for statements of the form `(a - b) < f32::EPSILON` or\n+     /// `(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n+     ///\n+     /// **Why is this bad?** The code without `.abs()` is more likely to have a bug.\n+     ///\n+     /// **Known problems:** If the user can ensure that b is larger than a, the `.abs()` is\n+     /// technically unneccessary. However, it will make the code more robust and doesn't have any\n+     /// large performance implications. If the abs call was deliberately left out for performance\n+     /// reasons, it is probably better to state this explicitly in the code, which then can be done\n+     /// with an allow.\n+     ///\n+     /// **Example:**\n+     ///\n+     /// ```rust\n+     /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+     ///     (a - b) < f32::EPSILON\n+     /// }\n+     /// ```\n+     /// Use instead:\n+     /// ```rust\n+     /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+     ///     (a - b).abs() < f32::EPSILON\n+     /// }\n+     /// ```\n+    pub FLOAT_EQUALITY_WITHOUT_ABS,\n+    correctness,\n+    \"float equality check without `.abs()`\"\n+}\n+\n+declare_lint_pass!(FloatEqualityWithoutAbs => [FLOAT_EQUALITY_WITHOUT_ABS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let lhs;\n+        let rhs;\n+\n+        // check if expr is a binary expression with a lt or gt operator\n+        if let ExprKind::Binary(op, ref left, ref right) = expr.kind {\n+            match op.node {\n+                BinOpKind::Lt => {\n+                    lhs = left;\n+                    rhs = right;\n+                },\n+                BinOpKind::Gt => {\n+                    lhs = right;\n+                    rhs = left;\n+                },\n+                _ => return,\n+            };\n+        } else {\n+            return;\n+        }\n+\n+        if_chain! {\n+\n+            // left hand side is a substraction\n+            if let ExprKind::Binary(\n+                Spanned {\n+                    node: BinOpKind::Sub,\n+                    ..\n+                },\n+                val_l,\n+                val_r,\n+            ) = lhs.kind;\n+\n+            // right hand side matches either f32::EPSILON or f64::EPSILON\n+            if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n+            if match_qpath(epsilon_path, &paths::F32_EPSILON) || match_qpath(epsilon_path, &paths::F64_EPSILON);\n+\n+            // values of the substractions on the left hand side are of the type float\n+            let t_val_l = cx.typeck_results().expr_ty(val_l);\n+            let t_val_r = cx.typeck_results().expr_ty(val_r);\n+            if let ty::Float(_) = t_val_l.kind;\n+            if let ty::Float(_) = t_val_r.kind;\n+\n+            then {\n+                let sug_l = sugg::Sugg::hir(cx, &val_l, \"..\");\n+                let sug_r = sugg::Sugg::hir(cx, &val_r, \"..\");\n+                // format the suggestion\n+                let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n+                // spans the lint\n+                span_lint_and_then(\n+                    cx,\n+                    FLOAT_EQUALITY_WITHOUT_ABS,\n+                    expr.span,\n+                    \"float equality check without `.abs()`\",\n+                    | diag | {\n+                        diag.span_suggestion(\n+                            lhs.span,\n+                            \"add `.abs()`\",\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "1b02cee126d03b71af78ed69cba56e3cddbd9905", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -2,7 +2,7 @@ use crate::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };\n-use crate::utils::{get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -363,8 +363,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n-            if are_exprs_equal(cx, lmul_lhs, lmul_rhs);\n-            if are_exprs_equal(cx, rmul_lhs, rmul_rhs);\n+            if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n+            if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n             }\n@@ -502,8 +502,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && eq_expr_value(cx, left, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && eq_expr_value(cx, right, test),\n             _ => false,\n         }\n     } else {\n@@ -515,19 +515,15 @@ fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -\n fn is_testing_negative(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && eq_expr_value(cx, right, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && eq_expr_value(cx, left, test),\n             _ => false,\n         }\n     } else {\n         false\n     }\n }\n \n-fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n-    SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n-}\n-\n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match constant_simple(cx, cx.typeck_results(), expr) {\n@@ -546,12 +542,12 @@ fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n /// returns None.\n fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n     if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n-        if are_exprs_equal(cx, expr1_negated, expr2) {\n+        if eq_expr_value(cx, expr1_negated, expr2) {\n             return Some((false, expr2));\n         }\n     }\n     if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n-        if are_exprs_equal(cx, expr1, expr2_negated) {\n+        if eq_expr_value(cx, expr1, expr2_negated) {\n             return Some((true, expr1));\n         }\n     }\n@@ -614,7 +610,7 @@ fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&&*method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && are_exprs_equal(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n                 );\n         }\n     }"}, {"sha": "28b20cdeac343ecdf30c3cf66be49aa909765b96", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -61,8 +61,8 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n                     cx,\n                     IF_LET_SOME_RESULT,\n                     expr.span.with_hi(op.span.hi()),\n-                    \"Matching on `Some` with `ok()` is redundant\",\n-                    &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n+                    \"matching on `Some` with `ok()` is redundant\",\n+                    &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n                     sugg,\n                     applicability,\n                 );"}, {"sha": "b86d2e766566bd16391dde7b738d288d873050ac", "filename": "src/tools/clippy/clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -60,7 +60,7 @@ impl EarlyLintPass for IfNotElse {\n                             cx,\n                             IF_NOT_ELSE,\n                             item.span,\n-                            \"Unnecessary boolean `not` operation\",\n+                            \"unnecessary boolean `not` operation\",\n                             None,\n                             \"remove the `!` and swap the blocks of the `if`/`else`\",\n                         );\n@@ -70,7 +70,7 @@ impl EarlyLintPass for IfNotElse {\n                             cx,\n                             IF_NOT_ELSE,\n                             item.span,\n-                            \"Unnecessary `!=` operation\",\n+                            \"unnecessary `!=` operation\",\n                             None,\n                             \"change to `==` and swap the blocks of the `if`/`else`\",\n                         );"}, {"sha": "b57fe8dc4269e341b7f6299cae07331aff409562", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -158,9 +158,9 @@ fn print_lint_and_sugg(cx: &LateContext<'_>, var_name: &str, expr: &Expr<'_>) {\n         cx,\n         IMPLICIT_SATURATING_SUB,\n         expr.span,\n-        \"Implicitly performing saturating subtraction\",\n+        \"implicitly performing saturating subtraction\",\n         \"try\",\n-        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, 1.to_string()),\n+        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, '1'),\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "4e6bb604785417977320c72d6de98ad623abd59e", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -81,9 +81,9 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n                             cx,\n                             MULTIPLE_INHERENT_IMPL,\n                             *additional_span,\n-                            \"Multiple implementations of this structure\",\n+                            \"multiple implementations of this structure\",\n                             |diag| {\n-                                diag.span_note(*initial_span, \"First implementation here\");\n+                                diag.span_note(*initial_span, \"first implementation here\");\n                             },\n                         )\n                     })"}, {"sha": "c629ee05ab97c1e2740441170c3ad142c857fbb7", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -152,7 +152,7 @@ impl IntPlusOne {\n             cx,\n             INT_PLUS_ONE,\n             block.span,\n-            \"Unnecessary `>= y + 1` or `x - 1 >=`\",\n+            \"unnecessary `>= y + 1` or `x - 1 >=`\",\n             \"change it to\",\n             recommendation,\n             Applicability::MachineApplicable, // snippet\n@@ -163,8 +163,8 @@ impl IntPlusOne {\n impl EarlyLintPass for IntPlusOne {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.kind {\n-            if let Some(ref rec) = Self::check_binop(cx, kind.node, lhs, rhs) {\n-                Self::emit_warning(cx, item, rec.clone());\n+            if let Some(rec) = Self::check_binop(cx, kind.node, lhs, rhs) {\n+                Self::emit_warning(cx, item, rec);\n             }\n         }\n     }"}, {"sha": "b691d363d2f2165ca03be278f0706a82f018e0bb", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_item_name, higher, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -260,17 +260,6 @@ fn check_len(\n \n /// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    /// Special case ranges until `range_is_empty` is stabilized. See issue 3807.\n-    fn should_skip_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-        higher::range(expr).map_or(false, |_| {\n-            !cx.tcx\n-                .features()\n-                .declared_lib_features\n-                .iter()\n-                .any(|(name, _)| name.as_str() == \"range_is_empty\")\n-        })\n-    }\n-\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_>, item: &ty::AssocItem) -> bool {\n         if let ty::AssocKind::Fn = item.kind {\n@@ -296,10 +285,6 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         })\n     }\n \n-    if should_skip_range(cx, expr) {\n-        return false;\n-    }\n-\n     let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n     match ty.kind {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {"}, {"sha": "fa560ffb980c82407d748018b6b12717c7572267", "filename": "src/tools/clippy/clippy_lints/src/let_and_return.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3e3c552605180d739eb6c23bc657121679caa456/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3c552605180d739eb6c23bc657121679caa456/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs?ref=3e3c552605180d739eb6c23bc657121679caa456", "patch": "@@ -1,124 +0,0 @@\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_then};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `let`-bindings, which are subsequently\n-    /// returned.\n-    ///\n-    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo() -> String {\n-    ///     let x = String::new();\n-    ///     x\n-    /// }\n-    /// ```\n-    /// instead, use\n-    /// ```\n-    /// fn foo() -> String {\n-    ///     String::new()\n-    /// }\n-    /// ```\n-    pub LET_AND_RETURN,\n-    style,\n-    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n-}\n-\n-declare_lint_pass!(LetReturn => [LET_AND_RETURN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LetReturn {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        // we need both a let-binding stmt and an expr\n-        if_chain! {\n-            if let Some(retexpr) = block.expr;\n-            if let Some(stmt) = block.stmts.iter().last();\n-            if let StmtKind::Local(local) = &stmt.kind;\n-            if local.ty.is_none();\n-            if local.attrs.is_empty();\n-            if let Some(initexpr) = &local.init;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            if let ExprKind::Path(qpath) = &retexpr.kind;\n-            if match_qpath(qpath, &[&*ident.name.as_str()]);\n-            if !last_statement_borrows(cx, initexpr);\n-            if !in_external_macro(cx.sess(), initexpr.span);\n-            if !in_external_macro(cx.sess(), retexpr.span);\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    LET_AND_RETURN,\n-                    retexpr.span,\n-                    \"returning the result of a `let` binding from a block\",\n-                    |err| {\n-                        err.span_label(local.span, \"unnecessary `let` binding\");\n-\n-                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n-                            err.multipart_suggestion(\n-                                \"return the expression directly\",\n-                                vec![\n-                                    (local.span, String::new()),\n-                                    (retexpr.span, snippet),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n-                .tcx\n-                .fn_sig(def_id)\n-                .output()\n-                .skip_binder()\n-                .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "577ce6523b491f4342a4138f75c229fe61bcd9f5", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -193,6 +193,7 @@ mod excessive_bools;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n+mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n@@ -218,7 +219,6 @@ mod large_const_arrays;\n mod large_enum_variant;\n mod large_stack_arrays;\n mod len_zero;\n-mod let_and_return;\n mod let_if_seq;\n mod let_underscore;\n mod lifetimes;\n@@ -285,6 +285,7 @@ mod reference;\n mod regex;\n mod repeat_once;\n mod returns;\n+mod self_assignment;\n mod serde_api;\n mod shadow;\n mod single_component_path_imports;\n@@ -296,6 +297,7 @@ mod swap;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n mod to_digit_is_some;\n+mod to_string_in_display;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n@@ -310,7 +312,9 @@ mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n+mod unused_unit;\n mod unwrap;\n+mod unwrap_in_result;\n mod use_self;\n mod useless_conversion;\n mod vec;\n@@ -547,6 +551,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &exit::EXIT,\n         &explicit_write::EXPLICIT_WRITE,\n         &fallible_impl_from::FALLIBLE_IMPL_FROM,\n+        &float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n         &float_literal::EXCESSIVE_PRECISION,\n         &float_literal::LOSSY_FLOAT_LITERAL,\n         &floating_point_arithmetic::IMPRECISE_FLOPS,\n@@ -586,7 +591,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &large_stack_arrays::LARGE_STACK_ARRAYS,\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n-        &let_and_return::LET_AND_RETURN,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n         &let_underscore::LET_UNDERSCORE_LOCK,\n         &let_underscore::LET_UNDERSCORE_MUST_USE,\n@@ -677,13 +681,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::SEARCH_IS_SOME,\n         &methods::SHOULD_IMPLEMENT_TRAIT,\n         &methods::SINGLE_CHAR_PATTERN,\n+        &methods::SINGLE_CHAR_PUSH_STR,\n         &methods::SKIP_WHILE_NEXT,\n         &methods::STRING_EXTEND_CHARS,\n         &methods::SUSPICIOUS_MAP,\n         &methods::TEMPORARY_CSTRING_AS_PTR,\n         &methods::UNINIT_ASSUMED_INIT,\n         &methods::UNNECESSARY_FILTER_MAP,\n         &methods::UNNECESSARY_FOLD,\n+        &methods::UNNECESSARY_LAZY_EVALUATIONS,\n         &methods::UNWRAP_USED,\n         &methods::USELESS_ASREF,\n         &methods::WRONG_PUB_SELF_CONVENTION,\n@@ -769,8 +775,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &regex::INVALID_REGEX,\n         &regex::TRIVIAL_REGEX,\n         &repeat_once::REPEAT_ONCE,\n+        &returns::LET_AND_RETURN,\n         &returns::NEEDLESS_RETURN,\n-        &returns::UNUSED_UNIT,\n+        &self_assignment::SELF_ASSIGNMENT,\n         &serde_api::SERDE_API_MISUSE,\n         &shadow::SHADOW_REUSE,\n         &shadow::SHADOW_SAME,\n@@ -788,6 +795,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n         &temporary_assignment::TEMPORARY_ASSIGNMENT,\n         &to_digit_is_some::TO_DIGIT_IS_SOME,\n+        &to_string_in_display::TO_STRING_IN_DISPLAY,\n         &trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n         &trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         &transmute::CROSSPOINTER_TRANSMUTE,\n@@ -840,8 +848,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n         &unused_io_amount::UNUSED_IO_AMOUNT,\n         &unused_self::UNUSED_SELF,\n+        &unused_unit::UNUSED_UNIT,\n         &unwrap::PANICKING_UNWRAP,\n         &unwrap::UNNECESSARY_UNWRAP,\n+        &unwrap_in_result::UNWRAP_IN_RESULT,\n         &use_self::USE_SELF,\n         &useless_conversion::USELESS_CONVERSION,\n         &utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n@@ -930,11 +940,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold));\n     let too_large_for_stack = conf.too_large_for_stack;\n     store.register_late_pass(move || box escape::BoxedLocal{too_large_for_stack});\n+    store.register_late_pass(move || box vec::UselessVec{too_large_for_stack});\n     store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n     store.register_late_pass(|| box strings::StringLitAsBytes);\n     store.register_late_pass(|| box derive::Derive);\n     store.register_late_pass(|| box types::CharLitAsU8);\n-    store.register_late_pass(|| box vec::UselessVec);\n     store.register_late_pass(|| box drop_bounds::DropBounds);\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n@@ -1017,6 +1027,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box reference::DerefAddrOf);\n     store.register_early_pass(|| box reference::RefInDeref);\n     store.register_early_pass(|| box double_parens::DoubleParens);\n+    store.register_late_pass(|| box to_string_in_display::ToStringInDisplay::new());\n     store.register_early_pass(|| box unsafe_removed_from_name::UnsafeNameRemoval);\n     store.register_early_pass(|| box if_not_else::IfNotElse);\n     store.register_early_pass(|| box else_if_without_else::ElseIfWithoutElse);\n@@ -1025,8 +1036,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box misc_early::MiscEarlyLints);\n     store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n     store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_early_pass(|| box returns::Return);\n-    store.register_late_pass(|| box let_and_return::LetReturn);\n+    store.register_early_pass(|| box unused_unit::UnusedUnit);\n+    store.register_late_pass(|| box returns::Return);\n     store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n@@ -1085,6 +1096,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n+    store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n+    store.register_late_pass(|| box self_assignment::SelfAssignment);\n+    store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1122,6 +1136,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&shadow::SHADOW_REUSE),\n         LintId::of(&shadow::SHADOW_SAME),\n         LintId::of(&strings::STRING_ADD),\n+        LintId::of(&unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(&verbose_file_reads::VERBOSE_FILE_READS),\n         LintId::of(&write::PRINT_STDOUT),\n         LintId::of(&write::USE_DEBUG),\n@@ -1260,6 +1275,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&eval_order_dependence::DIVERGING_SUB_EXPRESSION),\n         LintId::of(&eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n         LintId::of(&explicit_write::EXPLICIT_WRITE),\n+        LintId::of(&float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n         LintId::of(&float_literal::EXCESSIVE_PRECISION),\n         LintId::of(&format::USELESS_FORMAT),\n         LintId::of(&formatting::POSSIBLE_MISSING_COMMA),\n@@ -1284,7 +1300,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n@@ -1349,13 +1364,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SHOULD_IMPLEMENT_TRAIT),\n         LintId::of(&methods::SINGLE_CHAR_PATTERN),\n+        LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::SUSPICIOUS_MAP),\n         LintId::of(&methods::TEMPORARY_CSTRING_AS_PTR),\n         LintId::of(&methods::UNINIT_ASSUMED_INIT),\n         LintId::of(&methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n         LintId::of(&methods::USELESS_ASREF),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&methods::ZST_OFFSET),\n@@ -1413,8 +1430,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n-        LintId::of(&returns::UNUSED_UNIT),\n+        LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n@@ -1427,6 +1445,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n+        LintId::of(&to_string_in_display::TO_STRING_IN_DISPLAY),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),\n         LintId::of(&transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n         LintId::of(&transmute::TRANSMUTE_BYTES_TO_STR),\n@@ -1460,6 +1479,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n@@ -1500,7 +1520,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1532,8 +1551,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::OPTION_MAP_OR_NONE),\n         LintId::of(&methods::RESULT_MAP_OR_INTO_OPTION),\n         LintId::of(&methods::SHOULD_IMPLEMENT_TRAIT),\n+        LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&misc::TOPLEVEL_REF_ARG),\n         LintId::of(&misc::ZERO_PTR),\n@@ -1554,8 +1575,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n-        LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n@@ -1564,6 +1585,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::FN_TO_NUMERIC_CAST),\n         LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n         LintId::of(&write::PRINT_WITH_NEWLINE),\n@@ -1672,6 +1694,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n         LintId::of(&eq_op::EQ_OP),\n         LintId::of(&erasing_op::ERASING_OP),\n+        LintId::of(&float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n         LintId::of(&formatting::POSSIBLE_MISSING_COMMA),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n         LintId::of(&if_let_mutex::IF_LET_MUTEX),\n@@ -1704,10 +1727,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::MUT_FROM_REF),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&regex::INVALID_REGEX),\n+        LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),\n+        LintId::of(&to_string_in_display::TO_STRING_IN_DISPLAY),\n         LintId::of(&transmute::UNSOUND_COLLECTION_TRANSMUTE),\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),"}, {"sha": "c95e43a9430446b2470aac5c782c10418b23ac57", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1141,11 +1141,31 @@ fn detect_same_item_push<'tcx>(\n     if same_item_push_visitor.should_lint {\n         if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n             // Make sure that the push does not involve possibly mutating values\n-            if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n-                if let PatKind::Wild = pat.kind {\n-                    let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n-                    let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n-\n+            if let PatKind::Wild = pat.kind {\n+                let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+                let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+                if let ExprKind::Path(ref qpath) = pushed_item.kind {\n+                    if_chain! {\n+                        if let Res::Local(hir_id) = qpath_res(cx, qpath, pushed_item.hir_id);\n+                        let node = cx.tcx.hir().get(hir_id);\n+                        if let Node::Binding(pat) = node;\n+                        if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                        if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                        then {\n+                            span_lint_and_help(\n+                                cx,\n+                                SAME_ITEM_PUSH,\n+                                vec.span,\n+                                \"it looks like the same item is being pushed into this Vec\",\n+                                None,\n+                                &format!(\n+                                    \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                                    item_str, vec_str, item_str\n+                                ),\n+                            )\n+                        }\n+                    }\n+                } else if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n                     span_lint_and_help(\n                         cx,\n                         SAME_ITEM_PUSH,"}, {"sha": "1cd5b2012922f72ac65772a64de3af1f3d38c2e8", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -111,8 +111,8 @@ fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n         cx,\n         MAP_CLONE,\n         root.trim_start(receiver).unwrap(),\n-        \"You are needlessly cloning iterator elements\",\n-        \"Remove the `map` call\",\n+        \"you are needlessly cloning iterator elements\",\n+        \"remove the `map` call\",\n         String::new(),\n         Applicability::MachineApplicable,\n     )\n@@ -125,8 +125,8 @@ fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n             cx,\n             MAP_CLONE,\n             replace,\n-            \"You are using an explicit closure for copying elements\",\n-            \"Consider calling the dedicated `copied` method\",\n+            \"you are using an explicit closure for copying elements\",\n+            \"consider calling the dedicated `copied` method\",\n             format!(\n                 \"{}.copied()\",\n                 snippet_with_applicability(cx, root, \"..\", &mut applicability)\n@@ -138,8 +138,8 @@ fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n             cx,\n             MAP_CLONE,\n             replace,\n-            \"You are using an explicit closure for cloning elements\",\n-            \"Consider calling the dedicated `cloned` method\",\n+            \"you are using an explicit closure for cloning elements\",\n+            \"consider calling the dedicated `cloned` method\",\n             format!(\n                 \"{}.cloned()\",\n                 snippet_with_applicability(cx, root, \"..\", &mut applicability)"}, {"sha": "57966452253d52e75e55367ff540000448324377", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,5 @@\n-use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n use crate::utils::walk_ptrs_ty;\n+use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};"}, {"sha": "9996df69470f0e9242548fb8f41a1e93f93067a4", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 307, "deletions": 96, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -3,6 +3,7 @@ mod inefficient_to_string;\n mod manual_saturating_arithmetic;\n mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n+mod unnecessary_lazy_eval;\n \n use std::borrow::Cow;\n use std::fmt;\n@@ -14,24 +15,24 @@ use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n \n use crate::consts::{constant, Constant};\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro, is_copy,\n-    is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment,\n-    match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, paths,\n-    remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty,\n-    walk_ptrs_ty_depth, SpanlessEq,\n+    contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro,\n+    is_copy, is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats,\n+    last_path_segment, match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls,\n+    method_chain_args, paths, remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n+    span_lint_and_then, sugg, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -723,6 +724,7 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n+    /// In an impl block:\n     /// ```rust\n     /// # struct Foo;\n     /// # struct NotAFoo;\n@@ -735,25 +737,40 @@ declare_clippy_lint! {\n     ///\n     /// ```rust\n     /// # struct Foo;\n-    /// # struct FooError;\n+    /// struct Bar(Foo);\n     /// impl Foo {\n-    ///     // Good. Return type contains `Self`\n-    ///     fn new() -> Result<Foo, FooError> {\n-    ///         # Ok(Foo)\n+    ///     // Bad. The type name must contain `Self`\n+    ///     fn new() -> Bar {\n+    /// # Bar(Foo)\n     ///     }\n     /// }\n     /// ```\n     ///\n     /// ```rust\n     /// # struct Foo;\n-    /// struct Bar(Foo);\n+    /// # struct FooError;\n     /// impl Foo {\n-    ///     // Bad. The type name must contain `Self`.\n-    ///     fn new() -> Bar {\n-    ///         # Bar(Foo)\n+    ///     // Good. Return type contains `Self`\n+    ///     fn new() -> Result<Foo, FooError> {\n+    /// # Ok(Foo)\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// Or in a trait definition:\n+    /// ```rust\n+    /// pub trait Trait {\n+    ///     // Bad. The type name must contain `Self`\n+    ///     fn new();\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// pub trait Trait {\n+    ///     // Good. Return type contains `Self`\n+    ///     fn new() -> Self;\n+    /// }\n+    /// ```\n     pub NEW_RET_NO_SELF,\n     style,\n     \"not returning type containing `Self` in a `new` method\"\n@@ -799,7 +816,7 @@ declare_clippy_lint! {\n     ///     call_some_ffi_func(c_str);\n     /// }\n     /// ```\n-    /// Here `c_str` point to a freed address. The correct use would be:\n+    /// Here `c_str` points to a freed address. The correct use would be:\n     /// ```rust\n     /// # use std::ffi::CString;\n     /// # fn call_some_ffi_func(_: *const i8) {}\n@@ -1306,6 +1323,65 @@ declare_clippy_lint! {\n     \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Warns when using push_str with a single-character string literal,\n+    /// and push with a char would work fine.\n+    ///\n+    /// **Why is this bad?** It's less clear that we are pushing a single character\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```\n+    /// let mut string = String::new();\n+    /// string.push_str(\"R\");\n+    /// ```\n+    /// Could be written as\n+    /// ```\n+    /// let mut string = String::new();\n+    /// string.push('R');\n+    /// ```\n+    pub SINGLE_CHAR_PUSH_STR,\n+    style,\n+    \"`push_str()` used with a single-character string literal as parameter\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** As the counterpart to `or_fun_call`, this lint looks for unnecessary\n+    /// lazily evaluated closures on `Option` and `Result`.\n+    ///\n+    /// This lint suggests changing the following functions, when eager evaluation results in\n+    /// simpler code:\n+    ///  - `unwrap_or_else` to `unwrap_or`\n+    ///  - `and_then` to `and`\n+    ///  - `or_else` to `or`\n+    ///  - `get_or_insert_with` to `get_or_insert`\n+    ///  - `ok_or_else` to `ok_or`\n+    ///\n+    /// **Why is this bad?** Using eager evaluation is shorter and simpler in some cases.\n+    ///\n+    /// **Known problems:** It is possible, but not recommended for `Deref` and `Index` to have\n+    /// side effects. Eagerly evaluating them can change the semantics of the program.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // example code where clippy issues a warning\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or_else(|| 42);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or(42);\n+    /// ```\n+    pub UNNECESSARY_LAZY_EVALUATIONS,\n+    style,\n+    \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\"\n+}\n+\n declare_lint_pass!(Methods => [\n     UNWRAP_USED,\n     EXPECT_USED,\n@@ -1327,6 +1403,7 @@ declare_lint_pass!(Methods => [\n     INEFFICIENT_TO_STRING,\n     NEW_RET_NO_SELF,\n     SINGLE_CHAR_PATTERN,\n+    SINGLE_CHAR_PUSH_STR,\n     SEARCH_IS_SOME,\n     TEMPORARY_CSTRING_AS_PTR,\n     FILTER_NEXT,\n@@ -1354,6 +1431,7 @@ declare_lint_pass!(Methods => [\n     ZST_OFFSET,\n     FILETYPE_IS_FILE,\n     OPTION_AS_REF_DEREF,\n+    UNNECESSARY_LAZY_EVALUATIONS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Methods {\n@@ -1374,13 +1452,19 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n-            [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or_else\", \"map\"] => {\n+                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                }\n+            },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"and\");\n                 bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n                 bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n             },\n             [\"or_else\", ..] => {\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"or\");\n                 bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1424,6 +1508,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"ok_or\"),\n             _ => {},\n         }\n \n@@ -1441,6 +1528,12 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     inefficient_to_string::lint(cx, expr, &args[0], self_ty);\n                 }\n \n+                if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+                    if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n+                        lint_single_char_push_string(cx, expr, args);\n+                    }\n+                }\n+\n                 match self_ty.kind {\n                     ty::Ref(_, ty, _) if ty.kind == ty::Str => {\n                         for &(method, pos) in &PATTERN_METHODS {\n@@ -1470,6 +1563,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         }\n     }\n \n+    #[allow(clippy::too_many_lines)]\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         if in_external_macro(cx.sess(), impl_item.span) {\n             return;\n@@ -1495,16 +1589,31 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             then {\n                 if cx.access_levels.is_exported(impl_item.hir_id) {\n-                // check missing trait implementations\n-                    for &(method_name, n_args, fn_header, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if name == method_name &&\n-                            sig.decl.inputs.len() == n_args &&\n-                            out_type.matches(cx, &sig.decl.output) &&\n-                            self_kind.matches(cx, self_ty, first_arg_ty) &&\n-                            fn_header_equals(*fn_header, sig.header) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                    // check missing trait implementations\n+                    for method_config in &TRAIT_METHODS {\n+                        if name == method_config.method_name &&\n+                            sig.decl.inputs.len() == method_config.param_count &&\n+                            method_config.output_type.matches(cx, &sig.decl.output) &&\n+                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            fn_header_equals(method_config.fn_header, sig.header) &&\n+                            method_config.lifetime_param_cond(&impl_item)\n+                        {\n+                            span_lint_and_help(\n+                                cx,\n+                                SHOULD_IMPLEMENT_TRAIT,\n+                                impl_item.span,\n+                                &format!(\n+                                    \"method `{}` can be confused for the standard trait method `{}::{}`\",\n+                                    method_config.method_name,\n+                                    method_config.trait_name,\n+                                    method_config.method_name\n+                                ),\n+                                None,\n+                                &format!(\n+                                    \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n+                                    method_config.trait_name\n+                                )\n+                            );\n                         }\n                     }\n                 }\n@@ -1538,19 +1647,16 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             }\n         }\n \n+        // if this impl block implements a trait, lint in trait definition instead\n+        if let hir::ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+            return;\n+        }\n+\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n-            let contains_self_ty = |ty: Ty<'tcx>| {\n-                ty.walk().any(|inner| match inner.unpack() {\n-                    GenericArgKind::Type(inner_ty) => TyS::same_type(self_ty, inner_ty),\n-\n-                    GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n-                })\n-            };\n-\n             // walk the return type and check for Self (this does not check associated types)\n-            if contains_self_ty(ret_ty) {\n+            if contains_ty(ret_ty, self_ty) {\n                 return;\n             }\n \n@@ -1560,7 +1666,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n                     if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n                         // walk the associated type and check for Self\n-                        if contains_self_ty(projection_predicate.ty) {\n+                        if contains_ty(projection_predicate.ty, self_ty) {\n                             return;\n                         }\n                     }\n@@ -1577,6 +1683,26 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             }\n         }\n     }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        if_chain! {\n+            if !in_external_macro(cx.tcx.sess, item.span);\n+            if item.ident.name == sym!(new);\n+            if let TraitItemKind::Fn(_, _) = item.kind;\n+            let ret_ty = return_ty(cx, item.hir_id);\n+            let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n+            if !contains_ty(ret_ty, self_ty);\n+\n+            then {\n+                span_lint(\n+                    cx,\n+                    NEW_RET_NO_SELF,\n+                    item.span,\n+                    \"methods called `new` usually return `Self`\",\n+                );\n+            }\n+        }\n+    }\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n@@ -2057,18 +2183,15 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::\n             return;\n         };\n \n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"_\");\n+\n         span_lint_and_sugg(\n             cx,\n             CLONE_ON_REF_PTR,\n             expr.span,\n             \"using `.clone()` on a ref-counted pointer\",\n             \"try this\",\n-            format!(\n-                \"{}::<{}>::clone(&{})\",\n-                caller_type,\n-                subst.type_at(0),\n-                snippet(cx, arg.span, \"_\")\n-            ),\n+            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n             Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n         );\n     }\n@@ -2280,7 +2403,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n                     cx,\n                     ITER_NEXT_SLICE,\n                     expr.span,\n-                    \"Using `.iter().next()` on a Slice without end index.\",\n+                    \"using `.iter().next()` on a Slice without end index\",\n                     \"try calling\",\n                     format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n                     applicability,\n@@ -2299,7 +2422,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n             cx,\n             ITER_NEXT_SLICE,\n             expr.span,\n-            \"Using `.iter().next()` on an array\",\n+            \"using `.iter().next()` on an array\",\n             \"try calling\",\n             format!(\n                 \"{}.get(0)\",\n@@ -2618,12 +2741,13 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n }\n \n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n+/// Return true if lint triggered\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n-) {\n+) -> bool {\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n@@ -2635,10 +2759,10 @@ fn lint_map_unwrap_or_else<'tcx>(\n         let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n         if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n             if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n-                return;\n+                return false;\n             }\n         } else {\n-            return;\n+            return false;\n         }\n \n         // lint message\n@@ -2668,10 +2792,14 @@ fn lint_map_unwrap_or_else<'tcx>(\n                     map_snippet, unwrap_snippet,\n                 ),\n             );\n+            return true;\n         } else if same_span && multiline {\n             span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n-        };\n+            return true;\n+        }\n     }\n+\n+    false\n }\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n@@ -3124,15 +3252,18 @@ fn lint_chars_last_cmp_with_unwrap<'tcx>(cx: &LateContext<'tcx>, info: &BinaryEx\n     }\n }\n \n-/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-fn lint_single_char_pattern<'tcx>(cx: &LateContext<'tcx>, _expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n+fn get_hint_if_single_char_arg(\n+    cx: &LateContext<'_>,\n+    arg: &hir::Expr<'_>,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n     if_chain! {\n         if let hir::ExprKind::Lit(lit) = &arg.kind;\n         if let ast::LitKind::Str(r, style) = lit.node;\n-        if r.as_str().len() == 1;\n+        let string = r.as_str();\n+        if string.len() == 1;\n         then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let snip = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n+            let snip = snippet_with_applicability(cx, arg.span, &string, applicability);\n             let ch = if let ast::StrStyle::Raw(nhash) = style {\n                 let nhash = nhash as usize;\n                 // for raw string: r##\"a\"##\n@@ -3142,19 +3273,47 @@ fn lint_single_char_pattern<'tcx>(cx: &LateContext<'tcx>, _expr: &'tcx hir::Expr\n                 &snip[1..(snip.len() - 1)]\n             };\n             let hint = format!(\"'{}'\", if ch == \"'\" { \"\\\\'\" } else { ch });\n-            span_lint_and_sugg(\n-                cx,\n-                SINGLE_CHAR_PATTERN,\n-                arg.span,\n-                \"single-character string constant used as pattern\",\n-                \"try using a `char` instead\",\n-                hint,\n-                applicability,\n-            );\n+            Some(hint)\n+        } else {\n+            None\n         }\n     }\n }\n \n+/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n+fn lint_single_char_pattern(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PATTERN,\n+            arg.span,\n+            \"single-character string constant used as pattern\",\n+            \"try using a `char` instead\",\n+            hint,\n+            applicability,\n+        );\n+    }\n+}\n+\n+/// lint for length-1 `str`s as argument for `push_str`\n+fn lint_single_char_push_string(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+        let base_string_snippet = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+        let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PUSH_STR,\n+            expr.span,\n+            \"calling `push_str()` using a single-character string literal\",\n+            \"consider using `push` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}\n+\n /// Checks for the `USELESS_ASREF` lint.\n fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n@@ -3292,7 +3451,12 @@ fn lint_option_as_ref_deref<'tcx>(\n     ];\n \n     let is_deref = match map_args[1].kind {\n-        hir::ExprKind::Path(ref expr_qpath) => deref_aliases.iter().any(|path| match_qpath(expr_qpath, path)),\n+        hir::ExprKind::Path(ref expr_qpath) => cx\n+            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .opt_def_id()\n+            .map_or(false, |fun_def_id| {\n+                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+            }),\n         hir::ExprKind::Closure(_, _, body_id, _, _) => {\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n@@ -3403,38 +3567,85 @@ const FN_HEADER: hir::FnHeader = hir::FnHeader {\n     abi: rustc_target::spec::abi::Abi::Rust,\n };\n \n+struct ShouldImplTraitCase {\n+    trait_name: &'static str,\n+    method_name: &'static str,\n+    param_count: usize,\n+    fn_header: hir::FnHeader,\n+    // implicit self kind expected (none, self, &self, ...)\n+    self_kind: SelfKind,\n+    // checks against the output type\n+    output_type: OutType,\n+    // certain methods with explicit lifetimes can't implement the equivalent trait method\n+    lint_explicit_lifetime: bool,\n+}\n+impl ShouldImplTraitCase {\n+    const fn new(\n+        trait_name: &'static str,\n+        method_name: &'static str,\n+        param_count: usize,\n+        fn_header: hir::FnHeader,\n+        self_kind: SelfKind,\n+        output_type: OutType,\n+        lint_explicit_lifetime: bool,\n+    ) -> ShouldImplTraitCase {\n+        ShouldImplTraitCase {\n+            trait_name,\n+            method_name,\n+            param_count,\n+            fn_header,\n+            self_kind,\n+            output_type,\n+            lint_explicit_lifetime,\n+        }\n+    }\n+\n+    fn lifetime_param_cond(&self, impl_item: &hir::ImplItem<'_>) -> bool {\n+        self.lint_explicit_lifetime\n+            || !impl_item.generics.params.iter().any(|p| {\n+                matches!(\n+                    p.kind,\n+                    hir::GenericParamKind::Lifetime {\n+                        kind: hir::LifetimeParamKind::Explicit\n+                    }\n+                )\n+            })\n+    }\n+}\n+\n #[rustfmt::skip]\n-const TRAIT_METHODS: [(&str, usize, &hir::FnHeader, SelfKind, OutType, &str); 30] = [\n-    (\"add\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n-    (\"as_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n-    (\"as_ref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n-    (\"bitand\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n-    (\"bitor\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n-    (\"bitxor\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n-    (\"borrow\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n-    (\"borrow_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n-    (\"clone\", 1, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n-    (\"cmp\", 2, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n-    (\"default\", 0, &FN_HEADER, SelfKind::No, OutType::Any, \"std::default::Default\"),\n-    (\"deref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n-    (\"deref_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n-    (\"div\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n-    (\"drop\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n-    (\"eq\", 2, &FN_HEADER, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n-    (\"from_iter\", 1, &FN_HEADER, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n-    (\"from_str\", 1, &FN_HEADER, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n-    (\"hash\", 2, &FN_HEADER, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n-    (\"index\", 2, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n-    (\"index_mut\", 2, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n-    (\"into_iter\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n-    (\"mul\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n-    (\"neg\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n-    (\"next\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n-    (\"not\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n-    (\"rem\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n-    (\"shl\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n-    (\"shr\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n-    (\"sub\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n+const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n+    ShouldImplTraitCase::new(\"std::ops::Add\", \"add\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::convert::AsMut\", \"as_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::convert::AsRef\", \"as_ref\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitAnd\", \"bitand\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitOr\", \"bitor\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitXor\", \"bitxor\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::borrow::Borrow\", \"borrow\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::borrow::BorrowMut\", \"borrow_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::clone::Clone\", \"clone\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::cmp::Ord\", \"cmp\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n+    // FIXME: default doesn't work\n+    ShouldImplTraitCase::new(\"std::default::Default\", \"default\",  0,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Deref\", \"deref\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::DerefMut\", \"deref_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::Div\", \"div\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Drop\", \"drop\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Unit, true),\n+    ShouldImplTraitCase::new(\"std::cmp::PartialEq\", \"eq\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Bool, true),\n+    ShouldImplTraitCase::new(\"std::iter::FromIterator\", \"from_iter\",  1,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::str::FromStr\", \"from_str\",  1,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::hash::Hash\", \"hash\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Unit, true),\n+    ShouldImplTraitCase::new(\"std::ops::Index\", \"index\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::IndexMut\", \"index_mut\",  2,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::iter::IntoIterator\", \"into_iter\",  1,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Mul\", \"mul\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Neg\", \"neg\",  1,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::iter::Iterator\", \"next\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Any, false),\n+    ShouldImplTraitCase::new(\"std::ops::Not\", \"not\",  1,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Rem\", \"rem\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Shl\", \"shl\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Shr\", \"shr\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Sub\", \"sub\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n ];\n \n #[rustfmt::skip]"}, {"sha": "31517659c34dcbc9efa957fa7ba3c6f06603d1af", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,111 @@\n+use crate::utils::{is_type_diagnostic_item, match_qpath, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::UNNECESSARY_LAZY_EVALUATIONS;\n+\n+// Return true if the expression is an accessor of any of the arguments\n+fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n+    params.iter().any(|arg| {\n+        if_chain! {\n+            if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n+            if let [p, ..] = path.segments;\n+            then {\n+                ident.name == p.ident.name\n+            } else {\n+                false\n+            }\n+        }\n+    })\n+}\n+\n+fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n+    paths.iter().any(|candidate| match_qpath(path, candidate))\n+}\n+\n+fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n+    match expr.kind {\n+        // Closures returning literals can be unconditionally simplified\n+        hir::ExprKind::Lit(_) => true,\n+\n+        hir::ExprKind::Index(ref object, ref index) => {\n+            // arguments are not being indexed into\n+            if expr_uses_argument(object, params) {\n+                false\n+            } else {\n+                // arguments are not used as index\n+                !expr_uses_argument(index, params)\n+            }\n+        },\n+\n+        // Reading fields can be simplified if the object is not an argument of the closure\n+        hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n+\n+        // Paths can be simplified if the root is not the argument, this also covers None\n+        hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n+\n+        // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n+        hir::ExprKind::Call(ref func, ref args) => if_chain! {\n+            if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n+            if let hir::ExprKind::Path(ref path) = func.kind;\n+            if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n+            then {\n+                // Recursively check all arguments\n+                args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n+            } else {\n+                false\n+            }\n+        },\n+\n+        // For anything more complex than the above, a closure is probably the right solution,\n+        // or the case is handled by an other lint\n+        _ => false,\n+    }\n+}\n+\n+/// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n+/// replaced with `<fn>(return value of simple closure)`\n+pub(super) fn lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    args: &'tcx [hir::Expr<'_>],\n+    allow_variant_calls: bool,\n+    simplify_using: &str,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n+\n+    if is_option || is_result {\n+        if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+            let body = cx.tcx.hir().body(eid);\n+            let ex = &body.value;\n+            let params = &body.params;\n+\n+            if can_simplify(ex, params, allow_variant_calls) {\n+                let msg = if is_option {\n+                    \"unnecessary closure used to substitute value for `Option::None`\"\n+                } else {\n+                    \"unnecessary closure used to substitute value for `Result::Err`\"\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_LAZY_EVALUATIONS,\n+                    expr.span,\n+                    msg,\n+                    &format!(\"Use `{}` instead\", simplify_using),\n+                    format!(\n+                        \"{0}.{1}({2})\",\n+                        snippet(cx, args[0].span, \"..\"),\n+                        simplify_using,\n+                        snippet(cx, ex.span, \"..\"),\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "06f367a8b775f99ee7ae9fc610cc315c1170c4e5", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -433,8 +433,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             return;\n         }\n         let binding = match expr.kind {\n-            ExprKind::Path(hir::QPath::LangItem(..)) => None,\n-            ExprKind::Path(ref qpath) => {\n+            ExprKind::Path(ref qpath) if !matches!(qpath, hir::QPath::LangItem(..)) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&"}, {"sha": "c506440ed7987e48c7733262abbc12ac78805826", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -9,8 +9,8 @@ declare_clippy_lint! {\n     /// **What it does:** Detects passing a mutable reference to a function that only\n     /// requires an immutable reference.\n     ///\n-    /// **Why is this bad?** The immutable reference rules out all other references\n-    /// to the value. Also the code misleads about the intent of the call site.\n+    /// **Why is this bad?** The mutable reference rules out all other references to\n+    /// the value. Also the code misleads about the intent of the call site.\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -39,21 +39,28 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                         arguments,\n                         cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n+                        \"function\",\n                     );\n                 }\n             },\n             ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, &path.ident.as_str())\n+                check_arguments(cx, arguments, method_type, &path.ident.as_str(), \"method\")\n             },\n             _ => (),\n         }\n     }\n }\n \n-fn check_arguments<'tcx>(cx: &LateContext<'tcx>, arguments: &[Expr<'_>], type_definition: Ty<'tcx>, name: &str) {\n+fn check_arguments<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    arguments: &[Expr<'_>],\n+    type_definition: Ty<'tcx>,\n+    name: &str,\n+    fn_kind: &str,\n+) {\n     match type_definition.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n@@ -68,7 +75,7 @@ fn check_arguments<'tcx>(cx: &LateContext<'tcx>, arguments: &[Expr<'_>], type_de\n                                 cx,\n                                 UNNECESSARY_MUT_PASSED,\n                                 argument.span,\n-                                &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n+                                &format!(\"the {} `{}` doesn't need a mutable reference\", fn_kind, name),\n                             );\n                         }\n                     },"}, {"sha": "21efee71269862484f60ca618249bb067dd363e5", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -72,8 +72,8 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\n-                        \"Consider using an `{}` instead of a `Mutex` here. If you just want the locking \\\n-                         behavior and not the internal type, consider using `Mutex<()>`.\",\n+                        \"consider using an `{}` instead of a `Mutex` here; if you just want the locking \\\n+                         behavior and not the internal type, consider using `Mutex<()>`\",\n                         atomic_name\n                     );\n                     match mutex_param.kind {"}, {"sha": "f1df634701dd25d5c7a8e5dfcaa31abaad210426", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -211,8 +211,21 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                             needs_check_adjustment = false;\n                         },\n                         ExprKind::Field(..) => {\n-                            dereferenced_expr = parent_expr;\n                             needs_check_adjustment = true;\n+\n+                            // Check whether implicit dereferences happened;\n+                            // if so, no need to go further up\n+                            // because of the same reason as the `ExprKind::Unary` case.\n+                            if cx\n+                                .typeck_results()\n+                                .expr_adjustments(dereferenced_expr)\n+                                .iter()\n+                                .any(|adj| matches!(adj.kind, Adjust::Deref(_)))\n+                            {\n+                                break;\n+                            }\n+\n+                            dereferenced_expr = parent_expr;\n                         },\n                         ExprKind::Index(e, _) if ptr::eq(&**e, cur_expr) => {\n                             // `e[i]` => desugared to `*Index::index(&e, i)`,"}, {"sha": "c9d18c3cb7287551e439bb15d3b57d05d29806e4", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,5 @@\n use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Expr, ExprKind, LitKind, UnOp};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -102,36 +103,36 @@ impl EarlyLintPass for Precedence {\n             }\n         }\n \n-        if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.kind {\n-            if let ExprKind::MethodCall(ref path_segment, ref args, _) = rhs.kind {\n+        if let ExprKind::Unary(UnOp::Neg, operand) = &expr.kind {\n+            let mut arg = operand;\n+\n+            let mut all_odd = true;\n+            while let ExprKind::MethodCall(path_segment, args, _) = &arg.kind {\n                 let path_segment_str = path_segment.ident.name.as_str();\n-                if let Some(slf) = args.first() {\n-                    if let ExprKind::Lit(ref lit) = slf.kind {\n-                        match lit.kind {\n-                            LitKind::Int(..) | LitKind::Float(..) => {\n-                                if ALLOWED_ODD_FUNCTIONS\n-                                    .iter()\n-                                    .any(|odd_function| **odd_function == *path_segment_str)\n-                                {\n-                                    return;\n-                                }\n-                                let mut applicability = Applicability::MachineApplicable;\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    PRECEDENCE,\n-                                    expr.span,\n-                                    \"unary minus has lower precedence than method call\",\n-                                    \"consider adding parentheses to clarify your intent\",\n-                                    format!(\n-                                        \"-({})\",\n-                                        snippet_with_applicability(cx, rhs.span, \"..\", &mut applicability)\n-                                    ),\n-                                    applicability,\n-                                );\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n+                all_odd &= ALLOWED_ODD_FUNCTIONS\n+                    .iter()\n+                    .any(|odd_function| **odd_function == *path_segment_str);\n+                arg = args.first().expect(\"A method always has a receiver.\");\n+            }\n+\n+            if_chain! {\n+                if !all_odd;\n+                if let ExprKind::Lit(lit) = &arg.kind;\n+                if let LitKind::Int(..) | LitKind::Float(..) = &lit.kind;\n+                then {\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    span_lint_and_sugg(\n+                        cx,\n+                        PRECEDENCE,\n+                        expr.span,\n+                        \"unary minus has lower precedence than method call\",\n+                        \"consider adding parentheses to clarify your intent\",\n+                        format!(\n+                            \"-({})\",\n+                            snippet_with_applicability(cx, operand.span, \"..\", &mut applicability)\n+                        ),\n+                        applicability,\n+                    );\n                 }\n             }\n         }"}, {"sha": "7dafb1555dc6e7e187f62e44c1977de7dd2fd81d", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -36,14 +36,27 @@ declare_clippy_lint! {\n     /// argument may also fail to compile if you change the argument. Applying\n     /// this lint on them will fix the problem, but they may be in other crates.\n     ///\n+    /// One notable example of a function that may cause issues, and which cannot\n+    /// easily be changed due to being in the standard library is `Vec::contains`.\n+    /// when called on a `Vec<Vec<T>>`. If a `&Vec` is passed to that method then\n+    /// it will compile, but if a `&[T]` is passed then it will not compile.\n+    ///\n+    /// ```ignore\n+    /// fn cannot_take_a_slice(v: &Vec<u8>) -> bool {\n+    ///     let vec_of_vecs: Vec<Vec<u8>> = some_other_fn();\n+    ///\n+    ///     vec_of_vecs.contains(v)\n+    /// }\n+    /// ```\n+    ///\n     /// Also there may be `fn(&Vec)`-typed references pointing to your function.\n     /// If you have them, you will get a compiler error after applying this lint's\n     /// suggestions. You then have the choice to undo your changes or change the\n     /// type of the reference.\n     ///\n     /// Note that if the function is part of your public interface, there may be\n-    /// other crates referencing it you may not be aware. Carefully deprecate the\n-    /// function before applying the lint suggestions in this case.\n+    /// other crates referencing it, of which you may not be aware. Carefully\n+    /// deprecate the function before applying the lint suggestions in this case.\n     ///\n     /// **Example:**\n     /// ```ignore"}, {"sha": "dbc676ae22408b139172a742361ca9ac7e511003", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -7,8 +7,8 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n-    span_lint_and_sugg, SpanlessEq,\n+    eq_expr_value, higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n+    span_lint_and_sugg,\n };\n \n declare_clippy_lint! {\n@@ -65,7 +65,7 @@ impl QuestionMark {\n                         if let ExprKind::Block(block, None) = &else_.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(subject, block_expr);\n+                        if eq_expr_value(cx, subject, block_expr);\n                         then {\n                             replacement = Some(format!(\"Some({}?)\", receiver_str));\n                         }"}, {"sha": "49cb2ffc4e372a3f765e89e1f9fe4bf0f7740a23", "filename": "src/tools/clippy/clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -77,7 +77,7 @@ impl EarlyLintPass for RedundantClosureCall {\n                         cx,\n                         REDUNDANT_CLOSURE_CALL,\n                         expr.span,\n-                        \"try not to call a closure in the expression where it is declared.\",\n+                        \"try not to call a closure in the expression where it is declared\",\n                         |diag| {\n                             if decl.inputs.is_empty() {\n                                 let mut app = Applicability::MachineApplicable;\n@@ -95,12 +95,17 @@ impl EarlyLintPass for RedundantClosureCall {\n \n impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        fn count_closure_usage<'tcx>(block: &'tcx hir::Block<'_>, path: &'tcx hir::Path<'tcx>) -> usize {\n-            struct ClosureUsageCount<'tcx> {\n+        fn count_closure_usage<'a, 'tcx>(\n+            cx: &'a LateContext<'tcx>,\n+            block: &'tcx hir::Block<'_>,\n+            path: &'tcx hir::Path<'tcx>,\n+        ) -> usize {\n+            struct ClosureUsageCount<'a, 'tcx> {\n+                cx: &'a LateContext<'tcx>,\n                 path: &'tcx hir::Path<'tcx>,\n                 count: usize,\n             };\n-            impl<'tcx> hir_visit::Visitor<'tcx> for ClosureUsageCount<'tcx> {\n+            impl<'a, 'tcx> hir_visit::Visitor<'tcx> for ClosureUsageCount<'a, 'tcx> {\n                 type Map = Map<'tcx>;\n \n                 fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n@@ -117,10 +122,10 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                 }\n \n                 fn nested_visit_map(&mut self) -> hir_visit::NestedVisitorMap<Self::Map> {\n-                    hir_visit::NestedVisitorMap::None\n+                    hir_visit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n                 }\n             };\n-            let mut closure_usage_count = ClosureUsageCount { path, count: 0 };\n+            let mut closure_usage_count = ClosureUsageCount { cx, path, count: 0 };\n             closure_usage_count.visit_block(block);\n             closure_usage_count.count\n         }\n@@ -136,7 +141,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                 if let hir::ExprKind::Call(ref closure, _) = call.kind;\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n                 if ident == path.segments[0].ident;\n-                if count_closure_usage(block, path) == 1;\n+                if count_closure_usage(cx, block, path) == 1;\n                 then {\n                     span_lint(\n                         cx,"}, {"sha": "c0890018d46aba3abe8c9843d8a98cdffadf63dc", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -39,20 +39,20 @@ declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, [receiver, count], _) = &expr.kind;\n             if path.ident.name == sym!(repeat);\n-            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&args[1]);\n-            if !in_macro(args[0].span);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&count);\n+            if !in_macro(receiver.span);\n             then {\n-                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&receiver));\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,\n                         REPEAT_ONCE,\n                         expr.span,\n                         \"calling `repeat(1)` on str\",\n                         \"consider using `.to_string()` instead\",\n-                        format!(\"{}.to_string()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        format!(\"{}.to_string()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n                 } else if ty.builtin_index().is_some() {\n@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n                         expr.span,\n                         \"calling `repeat(1)` on slice\",\n                         \"consider using `.to_vec()` instead\",\n-                        format!(\"{}.to_vec()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        format!(\"{}.to_vec()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n                 } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n                         expr.span,\n                         \"calling `repeat(1)` on a string literal\",\n                         \"consider using `.clone()` instead\",\n-                        format!(\"{}.clone()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        format!(\"{}.clone()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n                 }"}, {"sha": "a6e4252a0c82579b2c332cf8a31c2279ed9fcfcc", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 213, "deletions": 207, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,60 +1,67 @@\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_ast::visit::FnKind;\n+use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n \n-use crate::utils::{snippet_opt, span_lint_and_sugg, span_lint_and_then};\n+use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for return statements at the end of a block.\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n     ///\n-    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n     /// more rusty.\n     ///\n-    /// **Known problems:** If the computation returning the value borrows a local\n-    /// variable, removing the `return` may run afoul of the borrow checker.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     return x;\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n     /// }\n     /// ```\n-    /// simplify to\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     x\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n     /// }\n     /// ```\n-    pub NEEDLESS_RETURN,\n+    pub LET_AND_RETURN,\n     style,\n-    \"using a return statement like `return expr;` where an expression would suffice\"\n+    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    /// **What it does:** Checks for return statements at the end of a block.\n     ///\n-    /// **Why is this bad?** Such expressions add no value, but can make the code\n-    /// less readable. Depending on formatting they can make a `break` or `return`\n-    /// statement look like a function call.\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n     ///\n-    /// **Known problems:** The lint currently misses unit return types in types,\n-    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn return_unit() -> () {\n-    ///     ()\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n     /// }\n     /// ```\n-    pub UNUSED_UNIT,\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RETURN,\n     style,\n-    \"needless unit expression\"\n+    \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n #[derive(PartialEq, Eq, Copy, Clone)]\n@@ -63,221 +70,220 @@ enum RetReplacement {\n     Block,\n }\n \n-declare_lint_pass!(Return => [NEEDLESS_RETURN, UNUSED_UNIT]);\n+declare_lint_pass!(Return => [LET_AND_RETURN, NEEDLESS_RETURN]);\n \n-impl Return {\n-    // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if let Some(stmt) = block.stmts.last() {\n-            match stmt.kind {\n-                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n-                    self.check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-                },\n-                _ => (),\n+impl<'tcx> LateLintPass<'tcx> for Return {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        // we need both a let-binding stmt and an expr\n+        if_chain! {\n+            if let Some(retexpr) = block.expr;\n+            if let Some(stmt) = block.stmts.iter().last();\n+            if let StmtKind::Local(local) = &stmt.kind;\n+            if local.ty.is_none();\n+            if local.attrs.is_empty();\n+            if let Some(initexpr) = &local.init;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            if let ExprKind::Path(qpath) = &retexpr.kind;\n+            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if !last_statement_borrows(cx, initexpr);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n+            if !in_external_macro(cx.sess(), retexpr.span);\n+            if !in_external_macro(cx.sess(), local.span);\n+            if !in_macro(local.span);\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    LET_AND_RETURN,\n+                    retexpr.span,\n+                    \"returning the result of a `let` binding from a block\",\n+                    |err| {\n+                        err.span_label(local.span, \"unnecessary `let` binding\");\n+\n+                        if let Some(mut snippet) = snippet_opt(cx, initexpr.span) {\n+                            if !cx.typeck_results().expr_adjustments(&retexpr).is_empty() {\n+                                snippet.push_str(\" as _\");\n+                            }\n+                            err.multipart_suggestion(\n+                                \"return the expression directly\",\n+                                vec![\n+                                    (local.span, String::new()),\n+                                    (retexpr.span, snippet),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n+                        }\n+                    },\n+                );\n             }\n         }\n     }\n \n-    // Check the final expression in a block if it's a return.\n-    fn check_final_expr(\n+    fn check_fn(\n         &mut self,\n-        cx: &EarlyContext<'_>,\n-        expr: &ast::Expr,\n-        span: Option<Span>,\n-        replacement: RetReplacement,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        _: &'tcx FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        _: HirId,\n     ) {\n-        match expr.kind {\n-            // simple return is always \"bad\"\n-            ast::ExprKind::Ret(ref inner) => {\n-                // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-                if !expr.attrs.iter().any(attr_is_cfg) {\n-                    Self::emit_return_lint(\n-                        cx,\n-                        span.expect(\"`else return` is not possible\"),\n-                        inner.as_ref().map(|i| i.span),\n-                        replacement,\n-                    );\n-                }\n-            },\n-            // a whole block? check it!\n-            ast::ExprKind::Block(ref block, _) => {\n-                self.check_block_return(cx, block);\n-            },\n-            // an if/if let expr, check both exprs\n-            // note, if without else is going to be a type checking error anyways\n-            // (except for unit type functions) so we don't match it\n-            ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n-                self.check_block_return(cx, ifblock);\n-                self.check_final_expr(cx, elsexpr, None, RetReplacement::Empty);\n-            },\n-            // a match expr, check all arms\n-            ast::ExprKind::Match(_, ref arms) => {\n-                for arm in arms {\n-                    self.check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+        match kind {\n+            FnKind::Closure(_) => check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty),\n+            FnKind::ItemFn(..) | FnKind::Method(..) => {\n+                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                    check_block_return(cx, block);\n                 }\n             },\n-            _ => (),\n         }\n     }\n+}\n \n-    fn emit_return_lint(cx: &EarlyContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n-        match inner_span {\n-            Some(inner_span) => {\n-                if in_external_macro(cx.sess(), inner_span) || inner_span.from_expansion() {\n-                    return;\n-                }\n+fn attr_is_cfg(attr: &Attribute) -> bool {\n+    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+}\n \n-                span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n-                    if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                        diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n-                    }\n-                })\n+fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+    if let Some(expr) = block.expr {\n+        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n+    } else if let Some(stmt) = block.stmts.iter().last() {\n+        match stmt.kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n             },\n-            None => match replacement {\n-                RetReplacement::Empty => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"remove `return`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                RetReplacement::Block => {\n-                    span_lint_and_sugg(\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn check_final_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    span: Option<Span>,\n+    replacement: RetReplacement,\n+) {\n+    match expr.kind {\n+        // simple return is always \"bad\"\n+        ExprKind::Ret(ref inner) => {\n+            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n+            if !expr.attrs.iter().any(attr_is_cfg) {\n+                let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n+                if !borrows {\n+                    emit_return_lint(\n                         cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"replace `return` with an empty block\",\n-                        \"{}\".to_string(),\n-                        Applicability::MachineApplicable,\n+                        span.expect(\"`else return` is not possible\"),\n+                        inner.as_ref().map(|i| i.span),\n+                        replacement,\n                     );\n-                },\n+                }\n+            }\n+        },\n+        // a whole block? check it!\n+        ExprKind::Block(ref block, _) => {\n+            check_block_return(cx, block);\n+        },\n+        // a match expr, check all arms\n+        // an if/if let expr, check both exprs\n+        // note, if without else is going to be a type checking error anyways\n+        // (except for unit type functions) so we don't match it\n+        ExprKind::Match(_, ref arms, source) => match source {\n+            MatchSource::Normal => {\n+                for arm in arms.iter() {\n+                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                }\n             },\n-        }\n+            MatchSource::IfDesugar {\n+                contains_else_clause: true,\n+            }\n+            | MatchSource::IfLetDesugar {\n+                contains_else_clause: true,\n+            } => {\n+                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                    check_block_return(cx, ifblock);\n+                }\n+                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n+            },\n+            _ => (),\n+        },\n+        _ => (),\n     }\n }\n \n-impl EarlyLintPass for Return {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n-        match kind {\n-            FnKind::Fn(.., Some(block)) => self.check_block_return(cx, block),\n-            FnKind::Closure(_, body) => self.check_final_expr(cx, body, Some(body.span), RetReplacement::Empty),\n-            FnKind::Fn(.., None) => {},\n-        }\n-        if_chain! {\n-            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n-            if let ast::TyKind::Tup(ref vals) = ty.kind;\n-            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n-            then {\n-                lint_unneeded_unit_return(cx, ty, span);\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    match inner_span {\n+        Some(inner_span) => {\n+            if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {\n+                return;\n             }\n-        }\n-    }\n \n-    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if_chain! {\n-            if let Some(ref stmt) = block.stmts.last();\n-            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n-            if is_unit_expr(expr) && !stmt.span.from_expansion();\n-            then {\n-                let sp = expr.span;\n+            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n+                if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n+                }\n+            })\n+        },\n+        None => match replacement {\n+            RetReplacement::Empty => {\n                 span_lint_and_sugg(\n                     cx,\n-                    UNUSED_UNIT,\n-                    sp,\n-                    \"unneeded unit expression\",\n-                    \"remove the final `()`\",\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"remove `return`\",\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        match e.kind {\n-            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n-                if is_unit_expr(expr) && !expr.span.from_expansion() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNUSED_UNIT,\n-                        expr.span,\n-                        \"unneeded `()`\",\n-                        \"remove the `()`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n             },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n-        let segments = &poly.trait_ref.path.segments;\n-\n-        if_chain! {\n-            if segments.len() == 1;\n-            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n-            if let Some(args) = &segments[0].args;\n-            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n-            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n-            if ty.kind.is_unit();\n-            then {\n-                lint_unneeded_unit_return(cx, ty, generic_args.span);\n-            }\n-        }\n+            RetReplacement::Block => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"replace `return` with an empty block\",\n+                    \"{}\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        },\n     }\n }\n \n-fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    let mut visitor = BorrowVisitor { cx, borrows: false };\n+    walk_expr(&mut visitor, expr);\n+    visitor.borrows\n }\n \n-// get the def site\n-#[must_use]\n-fn get_def(span: Span) -> Option<Span> {\n-    if span.from_expansion() {\n-        Some(span.ctxt().outer_expn_data().def_site)\n-    } else {\n-        None\n-    }\n+struct BorrowVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    borrows: bool,\n }\n \n-// is this expr a `()` unit?\n-fn is_unit_expr(expr: &ast::Expr) -> bool {\n-    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n-        vals.is_empty()\n-    } else {\n-        false\n+impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.borrows {\n+            return;\n+        }\n+\n+        if let Some(def_id) = fn_def_id(self.cx, expr) {\n+            self.borrows = self\n+                .cx\n+                .tcx\n+                .fn_sig(def_id)\n+                .output()\n+                .skip_binder()\n+                .walk()\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+        }\n+\n+        walk_expr(self, expr);\n     }\n-}\n \n-fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n-    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        fn_source\n-            .rfind(\"->\")\n-            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n-                (\n-                    #[allow(clippy::cast_possible_truncation)]\n-                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                    Applicability::MachineApplicable,\n-                )\n-            })\n-    } else {\n-        (ty.span, Applicability::MaybeIncorrect)\n-    };\n-    span_lint_and_sugg(\n-        cx,\n-        UNUSED_UNIT,\n-        ret_span,\n-        \"unneeded unit return type\",\n-        \"remove the `-> ()`\",\n-        String::new(),\n-        appl,\n-    );\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n }"}, {"sha": "e096c9aebc122fe8b7a53ef15d446fce2512d442", "filename": "src/tools/clippy/clippy_lints/src/self_assignment.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,51 @@\n+use crate::utils::{eq_expr_value, snippet, span_lint};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit self-assignments.\n+    ///\n+    /// **Why is this bad?** Self-assignments are redundant and unlikely to be\n+    /// intentional.\n+    ///\n+    /// **Known problems:** If expression contains any deref coercions or\n+    /// indexing operations they are assumed not to have any side effects.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Event {\n+    ///     id: usize,\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = b.x;\n+    ///     a.y = a.y;\n+    /// }\n+    /// ```\n+    pub SELF_ASSIGNMENT,\n+    correctness,\n+    \"explicit self-assignment\"\n+}\n+\n+declare_lint_pass!(SelfAssignment => [SELF_ASSIGNMENT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for SelfAssignment {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Assign(lhs, rhs, _) = &expr.kind {\n+            if eq_expr_value(cx, lhs, rhs) {\n+                let lhs = snippet(cx, lhs.span, \"<lhs>\");\n+                let rhs = snippet(cx, rhs.span, \"<rhs>\");\n+                span_lint(\n+                    cx,\n+                    SELF_ASSIGNMENT,\n+                    expr.span,\n+                    &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "99e4b293ac6809b40e74b2a33b62db8fa41e72ca", "filename": "src/tools/clippy/clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -86,17 +86,18 @@ struct LintDetection {\n     slice_name: String,\n     method: SortingKind,\n     method_args: String,\n+    slice_type: String,\n }\n \n fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n     if_chain! {\n         if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n         if let Some(slice) = &args.get(0);\n         if let Some(method) = SortingKind::from_stable_name(&method_name.ident.name.as_str());\n-        if is_slice_of_primitives(cx, slice);\n+        if let Some(slice_type) = is_slice_of_primitives(cx, slice);\n         then {\n             let args_str = args.iter().skip(1).map(|arg| Sugg::hir(cx, arg, \"..\").to_string()).collect::<Vec<String>>().join(\", \");\n-            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str })\n+            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str, slice_type })\n         } else {\n             None\n         }\n@@ -111,9 +112,10 @@ impl LateLintPass<'_> for StableSortPrimitive {\n                 STABLE_SORT_PRIMITIVE,\n                 expr.span,\n                 format!(\n-                    \"Use {} instead of {}\",\n+                    \"used {} instead of {} to sort primitive type `{}`\",\n+                    detection.method.stable_name(),\n                     detection.method.unstable_name(),\n-                    detection.method.stable_name()\n+                    detection.slice_type,\n                 )\n                 .as_str(),\n                 \"try\","}, {"sha": "3a688a7bbef324cd12a61086ec78fa9d059230ae", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -86,12 +86,20 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n                 cx,\n                 expr,\n                 binop.node,\n-                &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n+                &[\n+                    \"Add\", \"Sub\", \"Mul\", \"Div\", \"Rem\", \"BitAnd\", \"BitOr\", \"BitXor\", \"Shl\", \"Shr\",\n+                ],\n                 &[\n                     hir::BinOpKind::Add,\n                     hir::BinOpKind::Sub,\n                     hir::BinOpKind::Mul,\n                     hir::BinOpKind::Div,\n+                    hir::BinOpKind::Rem,\n+                    hir::BinOpKind::BitAnd,\n+                    hir::BinOpKind::BitOr,\n+                    hir::BinOpKind::BitXor,\n+                    hir::BinOpKind::Shl,\n+                    hir::BinOpKind::Shr,\n                 ],\n             ) {\n                 span_lint("}, {"sha": "cc39f060fc7f3929a69ed1860ca789a6dfbc6e54", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    differing_macro_contexts, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n+    differing_macro_contexts, eq_expr_value, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then,\n+    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -92,8 +92,8 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n+            if eq_expr_value(cx, tmp_init, lhs1);\n+            if eq_expr_value(cx, rhs1, lhs2);\n             then {\n                 if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n                     if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n@@ -193,7 +193,7 @@ enum Slice<'a> {\n fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n+            if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n@@ -221,8 +221,8 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if !differing_macro_contexts(first.span, second.span);\n             if let ExprKind::Assign(ref lhs0, ref rhs0, _) = first.kind;\n             if let ExprKind::Assign(ref lhs1, ref rhs1, _) = second.kind;\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n             then {\n                 let lhs0 = Sugg::hir_opt(cx, lhs0);\n                 let rhs0 = Sugg::hir_opt(cx, rhs0);"}, {"sha": "006d7a3a12d9ae56d06f0774abc75532d97f095f", "filename": "src/tools/clippy/clippy_lints/src/to_string_in_display.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,122 @@\n+use crate::utils::{match_def_path, match_trait_method, paths, qpath_res, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir::def::Res;\n+use rustc_hir::{Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for uses of `to_string()` in `Display` traits.\n+    ///\n+    /// **Why is this bad?** Usually `to_string` is implemented indirectly\n+    /// via `Display`. Hence using it while implementing `Display` would\n+    /// lead to infinite recursion.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.to_string())\n+    ///     }\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    /// ```\n+    pub TO_STRING_IN_DISPLAY,\n+    correctness,\n+    \"`to_string` method used while implementing `Display` trait\"\n+}\n+\n+#[derive(Default)]\n+pub struct ToStringInDisplay {\n+    in_display_impl: bool,\n+    self_hir_id: Option<HirId>,\n+}\n+\n+impl ToStringInDisplay {\n+    pub fn new() -> Self {\n+        Self {\n+            in_display_impl: false,\n+            self_hir_id: None,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ToStringInDisplay => [TO_STRING_IN_DISPLAY]);\n+\n+impl LateLintPass<'_> for ToStringInDisplay {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_display_impl(cx, item) {\n+            self.in_display_impl = true;\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_display_impl(cx, item) {\n+            self.in_display_impl = false;\n+            self.self_hir_id = None;\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &ImplItem<'_>) {\n+        if_chain! {\n+            if self.in_display_impl;\n+            if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n+            let body = cx.tcx.hir().body(*body_id);\n+            if !body.params.is_empty();\n+            then {\n+                let self_param = &body.params[0];\n+                self.self_hir_id = Some(self_param.pat.hir_id);\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref path, _, args, _) = expr.kind;\n+            if path.ident.name == sym!(to_string);\n+            if match_trait_method(cx, expr, &paths::TO_STRING);\n+            if self.in_display_impl;\n+            if let ExprKind::Path(ref qpath) = args[0].kind;\n+            if let Res::Local(hir_id) = qpath_res(cx, qpath, args[0].hir_id);\n+            if let Some(self_hir_id) = self.self_hir_id;\n+            if hir_id == self_hir_id;\n+            then {\n+                span_lint(\n+                    cx,\n+                    TO_STRING_IN_DISPLAY,\n+                    expr.span,\n+                    \"using `to_string` in `fmt::Display` implementation might lead to infinite recursion\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_display_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n+    if_chain! {\n+        if let ItemKind::Impl { of_trait: Some(trait_ref), .. } = &item.kind;\n+        if let Some(did) = trait_ref.trait_def_id();\n+        then {\n+            match_def_path(cx, did, &paths::DISPLAY_TRAIT)\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "50d9c93f9d405f16e956de1c6446fada39ea7b75", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n+    in_constant, is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n     span_lint_and_then, sugg,\n };\n use if_chain::if_chain;\n@@ -331,6 +331,10 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);\n             then {\n+                // Avoid suggesting from/to bits in const contexts.\n+                // See https://github.com/rust-lang/rust/issues/73736 for progress on making them `const fn`.\n+                let const_context = in_constant(cx, e.hir_id);\n+\n                 let from_ty = cx.typeck_results().expr_ty(&args[0]);\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n@@ -544,7 +548,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             },\n                         )\n                     },\n-                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) => span_lint_and_then(\n+                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) if !const_context => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_INT_TO_FLOAT,\n                         e.span,\n@@ -567,7 +571,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             );\n                         },\n                     ),\n-                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) => span_lint_and_then(\n+                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) if !const_context => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_FLOAT_TO_INT,\n                         e.span,"}, {"sha": "92f42168a1eabc56dd5df476d1f5b138211dff57", "filename": "src/tools/clippy/clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -2,6 +2,7 @@ use std::cmp;\n \n use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n+use rustc_ast::attr;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n@@ -155,8 +156,12 @@ impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n                     return;\n                 }\n                 for a in attrs {\n-                    if a.meta_item_list().is_some() && a.has_name(sym!(proc_macro_derive)) {\n-                        return;\n+                    if let Some(meta_items) = a.meta_item_list() {\n+                        if a.has_name(sym!(proc_macro_derive))\n+                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        {\n+                            return;\n+                        }\n                     }\n                 }\n             },"}, {"sha": "a4676e505b6f38e946d0e83b5fdf9a6dee9a7030", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{\n-    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet,\n-    snippet_with_macro_callsite, span_lint_and_sugg,\n+    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet, snippet_with_macro_callsite,\n+    span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, QPath, LangItem, MatchSource};\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};"}, {"sha": "7e9190bef5e78425ac5478cb78e6e2ec24879f12", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -353,14 +353,25 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if let Some(span) = match_type_parameter(cx, qpath, &paths::BOX) {\n+                        if match_type_parameter(cx, qpath, &paths::BOX).is_some() {\n+                            let box_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n+                                GenericArg::Type(ty) => match &ty.kind {\n+                                    TyKind::Path(qpath) => qpath,\n+                                    _ => return,\n+                                },\n+                                _ => return,\n+                            };\n+                            let inner_span = match &last_path_segment(&box_ty).args.unwrap().args[0] {\n+                                GenericArg::Type(ty) => ty.span,\n+                                _ => return,\n+                            };\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Rc<Box<T>>`\",\n                                 \"try\",\n-                                snippet(cx, span, \"..\").to_string(),\n+                                format!(\"Rc<{}>\", snippet(cx, inner_span, \"..\")),\n                                 Applicability::MachineApplicable,\n                             );\n                             return; // don't recurse into the type"}, {"sha": "7f4f16f8faf96225c201528e2d1f9a3804490da8", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -2,9 +2,9 @@\n \n use crate::utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n use crate::utils::{over, span_lint_and_then};\n-use rustc_ast::{self as ast, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -340,7 +340,7 @@ fn take_pat(from: &mut Pat) -> Pat {\n         id: DUMMY_NODE_ID,\n         kind: Wild,\n         span: DUMMY_SP,\n-        tokens: None\n+        tokens: None,\n     };\n     mem::replace(from, dummy)\n }"}, {"sha": "7548c6afa973afec4838369bb06ed8b6bd5efd3c", "filename": "src/tools/clippy/clippy_lints/src/unused_unit.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,144 @@\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_ast::visit::FnKind;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::BytePos;\n+\n+use crate::utils::span_lint_and_sugg;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    ///\n+    /// **Why is this bad?** Such expressions add no value, but can make the code\n+    /// less readable. Depending on formatting they can make a `break` or `return`\n+    /// statement look like a function call.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn return_unit() -> () {\n+    ///     ()\n+    /// }\n+    /// ```\n+    pub UNUSED_UNIT,\n+    style,\n+    \"needless unit expression\"\n+}\n+\n+declare_lint_pass!(UnusedUnit => [UNUSED_UNIT]);\n+\n+impl EarlyLintPass for UnusedUnit {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n+        if_chain! {\n+            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n+            if let ast::TyKind::Tup(ref vals) = ty.kind;\n+            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n+            then {\n+                lint_unneeded_unit_return(cx, ty, span);\n+            }\n+        }\n+    }\n+\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+        if_chain! {\n+            if let Some(ref stmt) = block.stmts.last();\n+            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n+            if is_unit_expr(expr) && !stmt.span.from_expansion();\n+            then {\n+                let sp = expr.span;\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNUSED_UNIT,\n+                    sp,\n+                    \"unneeded unit expression\",\n+                    \"remove the final `()`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        match e.kind {\n+            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n+                if is_unit_expr(expr) && !expr.span.from_expansion() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNUSED_UNIT,\n+                        expr.span,\n+                        \"unneeded `()`\",\n+                        \"remove the `()`\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n+        let segments = &poly.trait_ref.path.segments;\n+\n+        if_chain! {\n+            if segments.len() == 1;\n+            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n+            if let Some(args) = &segments[0].args;\n+            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n+            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n+            if ty.kind.is_unit();\n+            then {\n+                lint_unneeded_unit_return(cx, ty, generic_args.span);\n+            }\n+        }\n+    }\n+}\n+\n+// get the def site\n+#[must_use]\n+fn get_def(span: Span) -> Option<Span> {\n+    if span.from_expansion() {\n+        Some(span.ctxt().outer_expn_data().def_site)\n+    } else {\n+        None\n+    }\n+}\n+\n+// is this expr a `()` unit?\n+fn is_unit_expr(expr: &ast::Expr) -> bool {\n+    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n+        vals.is_empty()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n+    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n+    } else {\n+        (ty.span, Applicability::MaybeIncorrect)\n+    };\n+    span_lint_and_sugg(\n+        cx,\n+        UNUSED_UNIT,\n+        ret_span,\n+        \"unneeded unit return type\",\n+        \"remove the `-> ()`\",\n+        String::new(),\n+        appl,\n+    );\n+}"}, {"sha": "1c7e62ecd3d2c0c1e7fe6e8c149ad8ebbed8d4ae", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,140 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, return_ty, span_lint_and_then, walk_ptrs_ty};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions of type Result that contain `expect()` or `unwrap()`\n+    ///\n+    /// **Why is this bad?** These functions promote recoverable errors to non-recoverable errors which may be undesirable in code bases which wish to avoid panics.\n+    ///\n+    /// **Known problems:** This can cause false positives in functions that handle both recoverable and non recoverable errors.\n+    ///\n+    /// **Example:**\n+    /// Before:\n+    /// ```rust\n+    /// fn divisible_by_3(i_str: String) -> Result<(), String> {\n+    ///     let i = i_str\n+    ///         .parse::<i32>()\n+    ///         .expect(\"cannot divide the input by three\");\n+    ///\n+    ///     if i % 3 != 0 {\n+    ///         Err(\"Number is not divisible by 3\")?\n+    ///     }\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// After:\n+    /// ```rust\n+    /// fn divisible_by_3(i_str: String) -> Result<(), String> {\n+    ///     let i = i_str\n+    ///         .parse::<i32>()\n+    ///         .map_err(|e| format!(\"cannot divide the input by three: {}\", e))?;\n+    ///\n+    ///     if i % 3 != 0 {\n+    ///         Err(\"Number is not divisible by 3\")?\n+    ///     }\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    pub UNWRAP_IN_RESULT,\n+    restriction,\n+    \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\"\n+}\n+\n+declare_lint_pass!(UnwrapInResult=> [UNWRAP_IN_RESULT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n+        if_chain! {\n+            // first check if it's a method or function\n+            if let hir::ImplItemKind::Fn(ref _signature, _) = impl_item.kind;\n+            // checking if its return type is `result` or `option`\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(result_type))\n+                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(option_type));\n+            then {\n+                lint_impl_body(cx, impl_item.span, impl_item);\n+            }\n+        }\n+    }\n+}\n+\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ImplItemKind};\n+\n+struct FindExpectUnwrap<'a, 'tcx> {\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        // check for `expect`\n+        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n+            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            {\n+                self.result.push(expr.span);\n+            }\n+        }\n+\n+        // check for `unwrap`\n+        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            {\n+                self.result.push(expr.span);\n+            }\n+        }\n+\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if_chain! {\n+\n+        if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n+        then {\n+            let body = cx.tcx.hir().body(body_id);\n+            let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+            let mut fpu = FindExpectUnwrap {\n+                lcx: cx,\n+                typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                result: Vec::new(),\n+            };\n+            fpu.visit_expr(&body.value);\n+\n+            // if we've found one, lint\n+            if  !fpu.result.is_empty()  {\n+                span_lint_and_then(\n+                    cx,\n+                    UNWRAP_IN_RESULT,\n+                    impl_span,\n+                    \"used unwrap or expect in a function that returns result or option\",\n+                    move |diag| {\n+                        diag.help(\n+                            \"unwrap and expect should not be used in a function that returns result or option\" );\n+                        diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    });\n+            }\n+        }\n+    }\n+}"}, {"sha": "427a1b6577315c271611a0cd9c5c5d8e721a4346", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -50,7 +50,7 @@ declare_clippy_lint! {\n     /// ```\n     pub USE_SELF,\n     nursery,\n-    \"Unnecessary structure name repetition whereas `Self` is applicable\"\n+    \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n declare_lint_pass!(UseSelf => [USE_SELF]);"}, {"sha": "4ab2b5e796deb75f7361fc466c9d69306e7c7db4", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,3 +1,4 @@\n+use crate::utils::sugg::Sugg;\n use crate::utils::{\n     get_parent_expr, is_type_diagnostic_item, match_def_path, match_trait_method, paths, snippet,\n     snippet_with_macro_callsite, span_lint_and_help, span_lint_and_sugg,\n@@ -158,7 +159,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             if TyS::same_type(a, b);\n \n                             then {\n-                                let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();\n+                                let sugg = Sugg::hir_with_macro_callsite(cx, &args[0], \"<expr>\").maybe_par();\n                                 let sugg_msg =\n                                     format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n                                 span_lint_and_sugg(\n@@ -167,7 +168,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     e.span,\n                                     \"useless conversion to the same type\",\n                                     &sugg_msg,\n-                                    sugg,\n+                                    sugg.to_string(),\n                                     Applicability::MachineApplicable, // snippet\n                                 );\n                             }"}, {"sha": "7b419431c0f51dafe566ad6a29dd46394213ac74", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -5,8 +5,8 @@\n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n use crate::utils::{both, over};\n-use rustc_ast::{self as ast, *};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n use std::mem;\n "}, {"sha": "6eda6d1fa834074abca08450b2ece236c44ba175", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -175,18 +175,15 @@ impl PrintVisitor {\n     }\n \n     fn print_qpath(&mut self, path: &QPath<'_>) {\n-        match  *path {\n-            QPath::LangItem(lang_item, _) => {\n-                println!(\n-                    \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n-                   self.current, lang_item,\n-                );\n-            },\n-            _ => {\n-                print!(\"    if match_qpath({}, &[\", self.current);\n-                print_path(path, &mut true);\n-                println!(\"]);\");\n-            },\n+        if let QPath::LangItem(lang_item, _) = *path {\n+            println!(\n+                \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n+                self.current, lang_item,\n+            );\n+        } else {\n+            print!(\"    if match_qpath({}, &[\", self.current);\n+            print_path(path, &mut true);\n+            println!(\"]);\");\n         }\n     }\n }"}, {"sha": "292dbd7ad6b480babd426aae3dadc51060b419ac", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -138,7 +138,7 @@ define_Conf! {\n     (type_complexity_threshold, \"type_complexity_threshold\": u64, 250),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n     (single_char_binding_names_threshold, \"single_char_binding_names_threshold\": u64, 4),\n-    /// Lint: BOXED_LOCAL. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n+    /// Lint: BOXED_LOCAL, USELESS_VEC. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n     (too_large_for_stack, \"too_large_for_stack\": u64, 200),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n     (enum_variant_name_threshold, \"enum_variant_name_threshold\": u64, 3),"}, {"sha": "8563b469a30dd73772ee71722bdf04520f67575d", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -56,43 +56,45 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     }\n \n     match expr.kind {\n-        hir::ExprKind::Call(ref path, ref args) if matches!(\n-            path.kind,\n-            hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n-        ) => Some(Range {\n-            start: Some(&args[0]),\n-            end: Some(&args[1]),\n-            limits: ast::RangeLimits::Closed,\n-        }),\n-        hir::ExprKind::Struct(ref path, ref fields, None) => {\n-            match path {\n-                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n-                    start: None,\n-                    end: None,\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n-                    start: Some(get_field(\"start\", fields)?),\n-                    end: None,\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n-                    start: Some(get_field(\"start\", fields)?),\n-                    end: Some(get_field(\"end\", fields)?),\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n-                    start: None,\n-                    end: Some(get_field(\"end\", fields)?),\n-                    limits: ast::RangeLimits::Closed,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n-                    start: None,\n-                    end: Some(get_field(\"end\", fields)?),\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                _ => None,\n-            }\n+        hir::ExprKind::Call(ref path, ref args)\n+            if matches!(\n+                path.kind,\n+                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+            ) =>\n+        {\n+            Some(Range {\n+                start: Some(&args[0]),\n+                end: Some(&args[1]),\n+                limits: ast::RangeLimits::Closed,\n+            })\n+        },\n+        hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+            hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n+                start: None,\n+                end: None,\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n+                start: Some(get_field(\"start\", fields)?),\n+                end: None,\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n+                start: Some(get_field(\"start\", fields)?),\n+                end: Some(get_field(\"end\", fields)?),\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n+                start: None,\n+                end: Some(get_field(\"end\", fields)?),\n+                limits: ast::RangeLimits::Closed,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n+                start: None,\n+                end: Some(get_field(\"end\", fields)?),\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            _ => None,\n         },\n         _ => None,\n     }"}, {"sha": "c7263f48965a5a505e0e1f879fda4eaf2d0c5522", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -3,9 +3,9 @@ use crate::utils::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat,\n-    FnRetTy, GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName,\n-    Pat, PatKind, Path, PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat, FnRetTy,\n+    GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n+    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n@@ -23,23 +23,22 @@ pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    /// If is true, never consider as equal expressions containing function\n-    /// calls.\n-    ignore_fn: bool,\n+    allow_side_effects: bool,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_results: cx.maybe_typeck_results(),\n-            ignore_fn: false,\n+            allow_side_effects: true,\n         }\n     }\n \n-    pub fn ignore_fn(self) -> Self {\n+    /// Consider expressions containing potential side effects as not equal.\n+    pub fn deny_side_effects(self) -> Self {\n         Self {\n-            ignore_fn: true,\n+            allow_side_effects: false,\n             ..self\n         }\n     }\n@@ -67,7 +66,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n+        if !self.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n@@ -90,10 +89,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n-                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n-                lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n             (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n@@ -108,7 +107,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n-                !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n+                self.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n             | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n@@ -134,7 +133,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n-                !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+                self.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n@@ -186,10 +185,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n-        match (&left, &right) {\n-            (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) =>\n-                li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp),\n-        }\n+        let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n+        li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n@@ -233,8 +230,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n                 self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n             },\n-            (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) =>\n-                llang_item == rlang_item,\n+            (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) => llang_item == rlang_item,\n             _ => false,\n         }\n     }\n@@ -352,6 +348,11 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n+/// Checks if two expressions evaluate to the same value, and don't contain any side effects.\n+pub fn eq_expr_value(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    SpanlessEq::new(cx).deny_side_effects().eq_expr(left, right)\n+}\n+\n /// Type used to hash an ast element. This is different from the `Hash` trait\n /// on ast types as this\n /// trait would consider IDs and spans.\n@@ -615,7 +616,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             },\n             QPath::LangItem(lang_item, ..) => {\n                 lang_item.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n-            }\n+            },\n         }\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n@@ -727,7 +728,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 },\n                 QPath::LangItem(lang_item, ..) => {\n                     lang_item.hash(&mut self.s);\n-                }\n+                },\n             },\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);"}, {"sha": "8fa5d22210a3691f585b16256dc54e5464827d85", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::SpanlessEq;\n use crate::utils::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty,\n+    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -493,7 +492,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n             if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n             let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-            let mut sle = SpanlessEq::new(cx).ignore_fn();\n+            let mut sle = SpanlessEq::new(cx).deny_side_effects();\n             then {\n                 match &*ps.ident.as_str() {\n                     \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {"}, {"sha": "82005257115642072aa4c26858eeda9532904075", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -21,7 +21,7 @@ pub mod sugg;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n-pub use self::hir_utils::{both, over, SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n use std::mem;\n@@ -42,7 +42,8 @@ use rustc_hir::{\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{self, layout::IntegerExt, subst::GenericArg, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n use rustc_mir::const_eval;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n@@ -574,7 +575,7 @@ pub fn snippet_block<'a, T: LintContext>(\n }\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n-/// `snippet_with_applicabiliy`.\n+/// `snippet_with_applicability`.\n pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     cx: &T,\n     span: Span,\n@@ -866,6 +867,14 @@ pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx>\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n \n+/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n+pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n+    ty.walk().any(|inner| match inner.unpack() {\n+        GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n+        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+    })\n+}\n+\n /// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n@@ -1304,7 +1313,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// check if expr is calling method or function with #[must_use] attribyte\n+// check if expr is calling method or function with #[must_use] attribute\n pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n         ExprKind::Call(ref path, _) => if_chain! {\n@@ -1409,11 +1418,13 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     }\n }\n \n-/// Returns true iff the given expression is a slice of primitives (as defined in the\n-/// `is_recursively_primitive_type` function).\n-pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+/// Returns Option<String> where String is a textual representation of the type encapsulated in the\n+/// slice iff the given expression is a slice of primitives (as defined in the\n+/// `is_recursively_primitive_type` function) and None otherwise.\n+pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n-    match expr_type.kind {\n+    let expr_kind = &expr_type.kind;\n+    let is_primitive = match expr_kind {\n         ty::Slice(ref element_type)\n         | ty::Ref(\n             _,\n@@ -1424,7 +1435,24 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n             _,\n         ) => is_recursively_primitive_type(element_type),\n         _ => false,\n+    };\n+\n+    if is_primitive {\n+        // if we have wrappers like Array, Slice or Tuple, print these\n+        // and get the type enclosed in the slice ref\n+        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind {\n+            ty::Slice(..) => return Some(\"slice\".into()),\n+            ty::Array(..) => return Some(\"array\".into()),\n+            ty::Tuple(..) => return Some(\"tuple\".into()),\n+            _ => {\n+                // is_recursively_primitive_type() should have taken care\n+                // of the rest and we can rely on the type that is found\n+                let refs_peeled = expr_type.peel_refs();\n+                return Some(refs_peeled.walk().last().unwrap().to_string());\n+            },\n+        }\n     }\n+    None\n }\n \n #[macro_export]"}, {"sha": "d44854aefe97acfd2c3943657ac107e428ecde8d", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -35,6 +35,8 @@ pub const DROP_TRAIT: [&str; 4] = [\"core\", \"ops\", \"drop\", \"Drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n+pub const F32_EPSILON: [&str; 2] = [\"f32\", \"EPSILON\"];\n+pub const F64_EPSILON: [&str; 2] = [\"f64\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n@@ -84,6 +86,7 @@ pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n+pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];"}, {"sha": "84e907d7125de8951f291dc201a4c453d417c74d", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,13 +1,20 @@\n-use crate::consts::constant;\n+use crate::consts::{constant, Constant};\n+use crate::rustc_target::abi::LayoutOf;\n use crate::utils::{higher, is_copy, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n \n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Copy, Clone)]\n+pub struct UselessVec {\n+    pub too_large_for_stack: u64,\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n     /// be possible.\n@@ -31,7 +38,7 @@ declare_clippy_lint! {\n     \"useless `vec!`\"\n }\n \n-declare_lint_pass!(UselessVec => [USELESS_VEC]);\n+impl_lint_pass!(UselessVec => [USELESS_VEC]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -42,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n-                check_vec_macro(cx, &vec_args, expr.span);\n+                self.check_vec_macro(cx, &vec_args, expr.span);\n             }\n         }\n \n@@ -60,46 +67,62 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n                     .ctxt()\n                     .outer_expn_data()\n                     .call_site;\n-                check_vec_macro(cx, &vec_args, span);\n+                self.check_vec_macro(cx, &vec_args, span);\n             }\n         }\n     }\n }\n \n-fn check_vec_macro<'tcx>(cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let snippet = match *vec_args {\n-        higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, cx.typeck_results(), len).is_some() {\n-                format!(\n-                    \"&[{}; {}]\",\n-                    snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n-                    snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n-                )\n-            } else {\n-                return;\n-            }\n-        },\n-        higher::VecArgs::Vec(args) => {\n-            if let Some(last) = args.iter().last() {\n-                let span = args[0].span.to(last.span);\n+impl UselessVec {\n+    fn check_vec_macro<'tcx>(self, cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let snippet = match *vec_args {\n+            higher::VecArgs::Repeat(elem, len) => {\n+                if let Some((Constant::Int(len_constant), _)) = constant(cx, cx.typeck_results(), len) {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    if len_constant as u64 * size_of(cx, elem) > self.too_large_for_stack {\n+                        return;\n+                    }\n \n-                format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n-            } else {\n-                \"&[]\".into()\n-            }\n-        },\n-    };\n+                    format!(\n+                        \"&[{}; {}]\",\n+                        snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                        snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                    )\n+                } else {\n+                    return;\n+                }\n+            },\n+            higher::VecArgs::Vec(args) => {\n+                if let Some(last) = args.iter().last() {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    if args.len() as u64 * size_of(cx, last) > self.too_large_for_stack {\n+                        return;\n+                    }\n+                    let span = args[0].span.to(last.span);\n+\n+                    format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n+                } else {\n+                    \"&[]\".into()\n+                }\n+            },\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            USELESS_VEC,\n+            span,\n+            \"useless use of `vec!`\",\n+            \"you can use a slice directly\",\n+            snippet,\n+            applicability,\n+        );\n+    }\n+}\n \n-    span_lint_and_sugg(\n-        cx,\n-        USELESS_VEC,\n-        span,\n-        \"useless use of `vec!`\",\n-        \"you can use a slice directly\",\n-        snippet,\n-        applicability,\n-    );\n+fn size_of(cx: &LateContext<'_>, expr: &Expr<'_>) -> u64 {\n+    let ty = cx.typeck_results().expr_ty_adjusted(expr);\n+    cx.layout_of(ty).map_or(0, |l| l.size.bytes())\n }\n \n /// Returns the item type of the vector (i.e., the `T` in `Vec<T>`)."}, {"sha": "5683a71efea4eff68208fd420aeda4c0d95b73d5", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -195,13 +195,10 @@ impl WildcardImports {\n     }\n }\n \n-// Allow \"...prelude::*\" imports.\n+// Allow \"...prelude::..::*\" imports.\n // Many crates have a prelude, and it is imported as a glob by design.\n fn is_prelude_import(segments: &[PathSegment<'_>]) -> bool {\n-    segments\n-        .iter()\n-        .last()\n-        .map_or(false, |ps| ps.ident.as_str() == \"prelude\")\n+    segments.iter().any(|ps| ps.ident.as_str() == \"prelude\")\n }\n \n // Allow \"super::*\" imports in tests."}, {"sha": "e653240d049170b61d4755cd964185195e2edce7", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -237,7 +237,7 @@ impl EarlyLintPass for Write {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &MacCall) {\n         if mac.path == sym!(println) {\n             span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n-            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), false) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     span_lint_and_sugg(\n                         cx,\n@@ -252,7 +252,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(print) {\n             span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `print!`\");\n-            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), false) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n                 if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n@@ -273,7 +273,7 @@ impl EarlyLintPass for Write {\n                 }\n             }\n         } else if mac.path == sym!(write) {\n-            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n@@ -294,16 +294,17 @@ impl EarlyLintPass for Write {\n                 }\n             }\n         } else if mac.path == sym!(writeln) {\n-            if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), expr) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = expr.map_or_else(\n-                        || {\n-                            applicability = Applicability::HasPlaceholders;\n-                            Cow::Borrowed(\"v\")\n-                        },\n-                        |e| snippet_with_applicability(cx, e.span, \"v\", &mut Applicability::MachineApplicable),\n-                    );\n+                    // FIXME: remove this `#[allow(...)]` once the issue #5822 gets fixed\n+                    #[allow(clippy::option_if_let_else)]\n+                    let suggestion = if let Some(e) = expr {\n+                        snippet_with_applicability(cx, e.span, \"v\", &mut applicability)\n+                    } else {\n+                        applicability = Applicability::HasPlaceholders;\n+                        Cow::Borrowed(\"v\")\n+                    };\n \n                     span_lint_and_sugg(\n                         cx,\n@@ -364,17 +365,11 @@ impl Write {\n     /// (Some(\"string to write: {}\"), Some(buf))\n     /// ```\n     #[allow(clippy::too_many_lines)]\n-    fn check_tts<'a>(\n-        &self,\n-        cx: &EarlyContext<'a>,\n-        tts: &TokenStream,\n-        is_write: bool,\n-    ) -> (Option<StrLit>, Option<Expr>) {\n+    fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n         use rustc_parse_format::{\n             AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, ParseMode, Parser,\n             Piece,\n         };\n-        let tts = tts.clone();\n \n         let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n         let mut expr: Option<Expr> = None;"}, {"sha": "3c782e9b17ff15c0db0947b54b766aa52f8326ef", "filename": "src/tools/clippy/doc/adding_lints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -295,8 +295,14 @@ impl EarlyLintPass for FooFunctions {\n \n Running our UI test should now produce output that contains the lint message.\n \n+According to [the rustc-dev-guide], the text should be matter of fact and avoid\n+capitalization and periods, unless multiple sentences are needed.\n+When code or an identifier must appear in a message or label, it should be\n+surrounded with single acute accents \\`.\n+\n [check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n [diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs\n+[the rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/diagnostics.html\n \n ## Adding the lint logic\n "}, {"sha": "687fac7baa848038e9c5a735728907dd177b37fb", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -661,6 +661,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"misc\",\n     },\n+    Lint {\n+        name: \"float_equality_without_abs\",\n+        group: \"correctness\",\n+        desc: \"float equality check without `.abs()`\",\n+        deprecation: None,\n+        module: \"float_equality_without_abs\",\n+    },\n     Lint {\n         name: \"fn_address_comparisons\",\n         group: \"correctness\",\n@@ -1037,7 +1044,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n         deprecation: None,\n-        module: \"let_and_return\",\n+        module: \"returns\",\n     },\n     Lint {\n         name: \"let_underscore_lock\",\n@@ -1956,6 +1963,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"self_assignment\",\n+        group: \"correctness\",\n+        desc: \"explicit self-assignment\",\n+        deprecation: None,\n+        module: \"self_assignment\",\n+    },\n     Lint {\n         name: \"serde_api_misuse\",\n         group: \"correctness\",\n@@ -2012,6 +2026,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"single_char_push_str\",\n+        group: \"style\",\n+        desc: \"`push_str()` used with a single-character string literal as parameter\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"single_component_path_imports\",\n         group: \"style\",\n@@ -2166,6 +2187,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"to_digit_is_some\",\n     },\n+    Lint {\n+        name: \"to_string_in_display\",\n+        group: \"correctness\",\n+        desc: \"`to_string` method used while implementing `Display` trait\",\n+        deprecation: None,\n+        module: \"to_string_in_display\",\n+    },\n     Lint {\n         name: \"todo\",\n         group: \"restriction\",\n@@ -2369,6 +2397,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"unnecessary_lazy_evaluations\",\n+        group: \"style\",\n+        desc: \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"unnecessary_mut_passed\",\n         group: \"style\",\n@@ -2479,7 +2514,14 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"needless unit expression\",\n         deprecation: None,\n-        module: \"returns\",\n+        module: \"unused_unit\",\n+    },\n+    Lint {\n+        name: \"unwrap_in_result\",\n+        group: \"restriction\",\n+        desc: \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\",\n+        deprecation: None,\n+        module: \"unwrap_in_result\",\n     },\n     Lint {\n         name: \"unwrap_used\",\n@@ -2498,7 +2540,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"use_self\",\n         group: \"nursery\",\n-        desc: \"Unnecessary structure name repetition whereas `Self` is applicable\",\n+        desc: \"unnecessary structure name repetition whereas `Self` is applicable\",\n         deprecation: None,\n         module: \"use_self\",\n     },"}, {"sha": "7616d8001e8853bb8e9de4e44659d01b3253bd6f", "filename": "src/tools/clippy/tests/fmt.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -7,7 +7,7 @@ fn fmt() {\n         return;\n     }\n \n-    // Skip this test if rustup nightly is unavailable\n+    // Skip this test if nightly rustfmt is unavailable\n     let rustup_output = Command::new(\"rustup\")\n         .args(&[\"component\", \"list\", \"--toolchain\", \"nightly\"])\n         .output()\n@@ -19,12 +19,9 @@ fn fmt() {\n     }\n \n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-    let dev_dir = root_dir.join(\"clippy_dev\");\n-    let target_dir = root_dir.join(\"target\");\n-    let target_dir = target_dir.to_str().unwrap();\n     let output = Command::new(\"cargo\")\n-        .current_dir(dev_dir)\n-        .args(&[\"+nightly\", \"run\", \"--target-dir\", target_dir, \"--\", \"fmt\", \"--check\"])\n+        .current_dir(root_dir)\n+        .args(&[\"dev\", \"fmt\", \"--check\"])\n         .output()\n         .unwrap();\n "}, {"sha": "d75cdd625f9ec3de170ff6adae0bad84563d47e3", "filename": "src/tools/clippy/tests/ui/auxiliary/wildcard_imports_helper.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fwildcard_imports_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fwildcard_imports_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fwildcard_imports_helper.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -19,3 +19,9 @@ mod extern_exports {\n         A,\n     }\n }\n+\n+pub mod prelude {\n+    pub mod v1 {\n+        pub struct PreludeModAnywhere;\n+    }\n+}"}, {"sha": "a414832bcd36200765be6b70ae3fe59588d64586", "filename": "src/tools/clippy/tests/ui/borrow_interior_mutable_const.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -2,7 +2,7 @@\n #![allow(clippy::declare_interior_mutable_const, clippy::ref_in_deref)]\n \n use std::borrow::Cow;\n-use std::cell::Cell;\n+use std::cell::{Cell, UnsafeCell};\n use std::fmt::Display;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::Once;\n@@ -30,6 +30,37 @@ impl Trait<u32> for u64 {\n     const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n }\n \n+// This is just a pointer that can be safely dereferended,\n+// it's semantically the same as `&'static T`;\n+// but it isn't allowed to make a static reference from an arbitrary integer value at the moment.\n+// For more information, please see the issue #5918.\n+pub struct StaticRef<T> {\n+    ptr: *const T,\n+}\n+\n+impl<T> StaticRef<T> {\n+    /// Create a new `StaticRef` from a raw pointer\n+    ///\n+    /// ## Safety\n+    ///\n+    /// Callers must pass in a reference to statically allocated memory which\n+    /// does not overlap with other values.\n+    pub const unsafe fn new(ptr: *const T) -> StaticRef<T> {\n+        StaticRef { ptr }\n+    }\n+}\n+\n+impl<T> std::ops::Deref for StaticRef<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &'static T {\n+        unsafe { &*self.ptr }\n+    }\n+}\n+\n+// use a tuple to make sure referencing a field behind a pointer isn't linted.\n+const CELL_REF: StaticRef<(UnsafeCell<u32>,)> = unsafe { StaticRef::new(std::ptr::null()) };\n+\n fn main() {\n     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n@@ -82,4 +113,6 @@ fn main() {\n     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n \n     assert_eq!(NO_ANN.to_string(), \"70\"); // should never lint this.\n+\n+    let _ = &CELL_REF.0;\n }"}, {"sha": "1e0b3e4d20a5236c6b7c72162f0490bd8eb54345", "filename": "src/tools/clippy/tests/ui/borrow_interior_mutable_const.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,5 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:34:5\n+  --> $DIR/borrow_interior_mutable_const.rs:65:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n@@ -8,119 +8,119 @@ LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:35:16\n+  --> $DIR/borrow_interior_mutable_const.rs:66:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:38:22\n+  --> $DIR/borrow_interior_mutable_const.rs:69:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:39:25\n+  --> $DIR/borrow_interior_mutable_const.rs:70:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:40:27\n+  --> $DIR/borrow_interior_mutable_const.rs:71:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:41:26\n+  --> $DIR/borrow_interior_mutable_const.rs:72:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:52:14\n+  --> $DIR/borrow_interior_mutable_const.rs:83:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:53:14\n+  --> $DIR/borrow_interior_mutable_const.rs:84:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:54:19\n+  --> $DIR/borrow_interior_mutable_const.rs:85:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:55:14\n+  --> $DIR/borrow_interior_mutable_const.rs:86:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:56:13\n+  --> $DIR/borrow_interior_mutable_const.rs:87:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:62:13\n+  --> $DIR/borrow_interior_mutable_const.rs:93:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:67:5\n+  --> $DIR/borrow_interior_mutable_const.rs:98:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:68:16\n+  --> $DIR/borrow_interior_mutable_const.rs:99:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:81:5\n+  --> $DIR/borrow_interior_mutable_const.rs:112:5\n    |\n LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:82:16\n+  --> $DIR/borrow_interior_mutable_const.rs:113:16\n    |\n LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n    |                ^^^^^^^^^^^"}, {"sha": "5caf29c619735384ea91d3b304dcd490a12c57eb", "filename": "src/tools/clippy/tests/ui/crashes/ice-5944.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5944.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5944.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5944.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,13 @@\n+#![warn(clippy::repeat_once)]\n+\n+trait Repeat {\n+    fn repeat(&self) {}\n+}\n+\n+impl Repeat for usize {\n+    fn repeat(&self) {}\n+}\n+\n+fn main() {\n+    let _ = 42.repeat();\n+}"}, {"sha": "cdbeff6a037834f818e717ddc8ae24842dc8b412", "filename": "src/tools/clippy/tests/ui/duration_subsec.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,30 +1,30 @@\n-error: Calling `subsec_millis()` is more concise than this calculation\n+error: calling `subsec_millis()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:10:24\n    |\n LL |     let bad_millis_1 = dur.subsec_micros() / 1_000;\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `dur.subsec_millis()`\n    |\n    = note: `-D clippy::duration-subsec` implied by `-D warnings`\n \n-error: Calling `subsec_millis()` is more concise than this calculation\n+error: calling `subsec_millis()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:11:24\n    |\n LL |     let bad_millis_2 = dur.subsec_nanos() / 1_000_000;\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `dur.subsec_millis()`\n \n-error: Calling `subsec_micros()` is more concise than this calculation\n+error: calling `subsec_micros()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:16:22\n    |\n LL |     let bad_micros = dur.subsec_nanos() / 1_000;\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `dur.subsec_micros()`\n \n-error: Calling `subsec_micros()` is more concise than this calculation\n+error: calling `subsec_micros()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:21:13\n    |\n LL |     let _ = (&dur).subsec_nanos() / 1_000;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(&dur).subsec_micros()`\n \n-error: Calling `subsec_micros()` is more concise than this calculation\n+error: calling `subsec_micros()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:25:13\n    |\n LL |     let _ = dur.subsec_nanos() / NANOS_IN_MICRO;"}, {"sha": "5935eea5e036e74845b71e7020526cd1d4426195", "filename": "src/tools/clippy/tests/ui/enum_clike_unportable_variant.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_clike_unportable_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_clike_unportable_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_clike_unportable_variant.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,54 +1,54 @@\n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:8:5\n    |\n LL |     X = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::enum-clike-unportable-variant` implied by `-D warnings`\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:15:5\n    |\n LL |     X = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:18:5\n    |\n LL |     A = 0xFFFF_FFFF,\n    |     ^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:25:5\n    |\n LL |     Z = 0xFFFF_FFFF,\n    |     ^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:26:5\n    |\n LL |     A = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:28:5\n    |\n LL |     C = (i32::MIN as isize) - 1,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:34:5\n    |\n LL |     Z = 0xFFFF_FFFF,\n    |     ^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:35:5\n    |\n LL |     A = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:40:5\n    |\n LL |     X = <usize as Trait>::Number,"}, {"sha": "b1d481190ff53bdfa68e41934fa668c49edb05f6", "filename": "src/tools/clippy/tests/ui/enum_variants.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,30 +1,30 @@\n-error: Variant name ends with the enum's name\n+error: variant name ends with the enum's name\n   --> $DIR/enum_variants.rs:16:5\n    |\n LL |     cFoo,\n    |     ^^^^\n    |\n    = note: `-D clippy::enum-variant-names` implied by `-D warnings`\n \n-error: Variant name starts with the enum's name\n+error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:27:5\n    |\n LL |     FoodGood,\n    |     ^^^^^^^^\n \n-error: Variant name starts with the enum's name\n+error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:28:5\n    |\n LL |     FoodMiddle,\n    |     ^^^^^^^^^^\n \n-error: Variant name starts with the enum's name\n+error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:29:5\n    |\n LL |     FoodBad,\n    |     ^^^^^^^\n \n-error: All variants have the same prefix: `Food`\n+error: all variants have the same prefix: `Food`\n   --> $DIR/enum_variants.rs:26:1\n    |\n LL | / enum Food {\n@@ -36,7 +36,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `CallType`\n+error: all variants have the same prefix: `CallType`\n   --> $DIR/enum_variants.rs:36:1\n    |\n LL | / enum BadCallType {\n@@ -48,7 +48,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `Constant`\n+error: all variants have the same prefix: `Constant`\n   --> $DIR/enum_variants.rs:48:1\n    |\n LL | / enum Consts {\n@@ -60,7 +60,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `With`\n+error: all variants have the same prefix: `With`\n   --> $DIR/enum_variants.rs:82:1\n    |\n LL | / enum Seallll {\n@@ -72,7 +72,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `Prefix`\n+error: all variants have the same prefix: `Prefix`\n   --> $DIR/enum_variants.rs:88:1\n    |\n LL | / enum NonCaps {\n@@ -84,7 +84,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `With`\n+error: all variants have the same prefix: `With`\n   --> $DIR/enum_variants.rs:94:1\n    |\n LL | / pub enum PubSeall {"}, {"sha": "d40fa00c315518f891cd3165604c1ae8b8f62862", "filename": "src/tools/clippy/tests/ui/float_equality_without_abs.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_equality_without_abs.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,31 @@\n+#![warn(clippy::float_equality_without_abs)]\n+\n+pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    (a - b) < f32::EPSILON\n+}\n+\n+pub fn main() {\n+    // all errors\n+    is_roughly_equal(1.0, 2.0);\n+    let a = 0.05;\n+    let b = 0.0500001;\n+\n+    let _ = (a - b) < f32::EPSILON;\n+    let _ = a - b < f32::EPSILON;\n+    let _ = a - b.abs() < f32::EPSILON;\n+    let _ = (a as f64 - b as f64) < f64::EPSILON;\n+    let _ = 1.0 - 2.0 < f32::EPSILON;\n+\n+    let _ = f32::EPSILON > (a - b);\n+    let _ = f32::EPSILON > a - b;\n+    let _ = f32::EPSILON > a - b.abs();\n+    let _ = f64::EPSILON > (a as f64 - b as f64);\n+    let _ = f32::EPSILON > 1.0 - 2.0;\n+\n+    // those are correct\n+    let _ = (a - b).abs() < f32::EPSILON;\n+    let _ = (a as f64 - b as f64).abs() < f64::EPSILON;\n+\n+    let _ = f32::EPSILON > (a - b).abs();\n+    let _ = f64::EPSILON > (a as f64 - b as f64).abs();\n+}"}, {"sha": "b34c8159da04db8c2258f29d1214418d166e9676", "filename": "src/tools/clippy/tests/ui/float_equality_without_abs.stderr", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_equality_without_abs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_equality_without_abs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_equality_without_abs.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,92 @@\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:4:5\n+   |\n+LL |     (a - b) < f32::EPSILON\n+   |     -------^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: add `.abs()`: `(a - b).abs()`\n+   |\n+   = note: `-D clippy::float-equality-without-abs` implied by `-D warnings`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:13:13\n+   |\n+LL |     let _ = (a - b) < f32::EPSILON;\n+   |             -------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:14:13\n+   |\n+LL |     let _ = a - b < f32::EPSILON;\n+   |             -----^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:15:13\n+   |\n+LL |     let _ = a - b.abs() < f32::EPSILON;\n+   |             -----------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a - b.abs()).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:16:13\n+   |\n+LL |     let _ = (a as f64 - b as f64) < f64::EPSILON;\n+   |             ---------------------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a as f64 - b as f64).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:17:13\n+   |\n+LL |     let _ = 1.0 - 2.0 < f32::EPSILON;\n+   |             ---------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(1.0 - 2.0).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:19:13\n+   |\n+LL |     let _ = f32::EPSILON > (a - b);\n+   |             ^^^^^^^^^^^^^^^-------\n+   |                            |\n+   |                            help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:20:13\n+   |\n+LL |     let _ = f32::EPSILON > a - b;\n+   |             ^^^^^^^^^^^^^^^-----\n+   |                            |\n+   |                            help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:21:13\n+   |\n+LL |     let _ = f32::EPSILON > a - b.abs();\n+   |             ^^^^^^^^^^^^^^^-----------\n+   |                            |\n+   |                            help: add `.abs()`: `(a - b.abs()).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:22:13\n+   |\n+LL |     let _ = f64::EPSILON > (a as f64 - b as f64);\n+   |             ^^^^^^^^^^^^^^^---------------------\n+   |                            |\n+   |                            help: add `.abs()`: `(a as f64 - b as f64).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:23:13\n+   |\n+LL |     let _ = f32::EPSILON > 1.0 - 2.0;\n+   |             ^^^^^^^^^^^^^^^---------\n+   |                            |\n+   |                            help: add `.abs()`: `(1.0 - 2.0).abs()`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "6afee0f36b9da21b592e78b947cdc07140b14015", "filename": "src/tools/clippy/tests/ui/if_let_some_result.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,22 +1,22 @@\n-error: Matching on `Some` with `ok()` is redundant\n+error: matching on `Some` with `ok()` is redundant\n   --> $DIR/if_let_some_result.rs:6:5\n    |\n LL |     if let Some(y) = x.parse().ok() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::if-let-some-result` implied by `-D warnings`\n-help: Consider matching on `Ok(y)` and removing the call to `ok` instead\n+help: consider matching on `Ok(y)` and removing the call to `ok` instead\n    |\n LL |     if let Ok(y) = x.parse() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Matching on `Some` with `ok()` is redundant\n+error: matching on `Some` with `ok()` is redundant\n   --> $DIR/if_let_some_result.rs:24:9\n    |\n LL |         if let Some(y) = x   .   parse()   .   ok   ()    {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: Consider matching on `Ok(y)` and removing the call to `ok` instead\n+help: consider matching on `Ok(y)` and removing the call to `ok` instead\n    |\n LL |         if let Ok(y) = x   .   parse()       {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "53d1b86d02a962a639631ea29c6415573cb8ee51", "filename": "src/tools/clippy/tests/ui/if_not_else.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_not_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_not_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_not_else.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,4 @@\n-error: Unnecessary boolean `not` operation\n+error: unnecessary boolean `not` operation\n   --> $DIR/if_not_else.rs:9:5\n    |\n LL | /     if !bla() {\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: `-D clippy::if-not-else` implied by `-D warnings`\n    = help: remove the `!` and swap the blocks of the `if`/`else`\n \n-error: Unnecessary `!=` operation\n+error: unnecessary `!=` operation\n   --> $DIR/if_not_else.rs:14:5\n    |\n LL | /     if 4 != 5 {"}, {"sha": "aab688cc2d8b2b87d77ca9eb864a699a191edc3c", "filename": "src/tools/clippy/tests/ui/impl.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimpl.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,4 @@\n-error: Multiple implementations of this structure\n+error: multiple implementations of this structure\n   --> $DIR/impl.rs:10:1\n    |\n LL | / impl MyStruct {\n@@ -7,23 +7,23 @@ LL | | }\n    | |_^\n    |\n    = note: `-D clippy::multiple-inherent-impl` implied by `-D warnings`\n-note: First implementation here\n+note: first implementation here\n   --> $DIR/impl.rs:6:1\n    |\n LL | / impl MyStruct {\n LL | |     fn first() {}\n LL | | }\n    | |_^\n \n-error: Multiple implementations of this structure\n+error: multiple implementations of this structure\n   --> $DIR/impl.rs:24:5\n    |\n LL | /     impl super::MyStruct {\n LL | |         fn third() {}\n LL | |     }\n    | |_____^\n    |\n-note: First implementation here\n+note: first implementation here\n   --> $DIR/impl.rs:6:1\n    |\n LL | / impl MyStruct {"}, {"sha": "5bb9a606422a13fdb740663f33850c3d3181f34b", "filename": "src/tools/clippy/tests/ui/implicit_saturating_sub.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,4 @@\n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:13:5\n    |\n LL | /     if u_8 > 0 {\n@@ -8,175 +8,175 @@ LL | |     }\n    |\n    = note: `-D clippy::implicit-saturating-sub` implied by `-D warnings`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:20:13\n    |\n LL | /             if u_8 > 0 {\n LL | |                 u_8 -= 1;\n LL | |             }\n    | |_____________^ help: try: `u_8 = u_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:34:5\n    |\n LL | /     if u_16 > 0 {\n LL | |         u_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_16 = u_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:44:5\n    |\n LL | /     if u_32 != 0 {\n LL | |         u_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_32 = u_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:65:5\n    |\n LL | /     if u_64 > 0 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:70:5\n    |\n LL | /     if 0 < u_64 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:75:5\n    |\n LL | /     if 0 != u_64 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:96:5\n    |\n LL | /     if u_usize > 0 {\n LL | |         u_usize -= 1;\n LL | |     }\n    | |_____^ help: try: `u_usize = u_usize.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:108:5\n    |\n LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:113:5\n    |\n LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:118:5\n    |\n LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:123:5\n    |\n LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:133:5\n    |\n LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:138:5\n    |\n LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:143:5\n    |\n LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:148:5\n    |\n LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:158:5\n    |\n LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:163:5\n    |\n LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:168:5\n    |\n LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:173:5\n    |\n LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:183:5\n    |\n LL | /     if i64::MIN < i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:188:5\n    |\n LL | /     if i64::MIN != i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:193:5\n    |\n LL | /     if i64::MIN < i_64 {"}, {"sha": "c5b020ba8ced51bce578f1337fe5ac52c7801662", "filename": "src/tools/clippy/tests/ui/int_plus_one.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fint_plus_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fint_plus_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fint_plus_one.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,24 +1,24 @@\n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:9:13\n    |\n LL |     let _ = x >= y + 1;\n    |             ^^^^^^^^^^ help: change it to: `x > y`\n    |\n    = note: `-D clippy::int-plus-one` implied by `-D warnings`\n \n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:10:13\n    |\n LL |     let _ = y + 1 <= x;\n    |             ^^^^^^^^^^ help: change it to: `y < x`\n \n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:12:13\n    |\n LL |     let _ = x - 1 >= y;\n    |             ^^^^^^^^^^ help: change it to: `x > y`\n \n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:13:13\n    |\n LL |     let _ = y <= x - 1;"}, {"sha": "8c10a252ee01b427ead6cc1b2c2432a505003e49", "filename": "src/tools/clippy/tests/ui/iter_next_slice.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,24 +1,24 @@\n-error: Using `.iter().next()` on an array\n+error: using `.iter().next()` on an array\n   --> $DIR/iter_next_slice.rs:9:5\n    |\n LL |     s.iter().next();\n    |     ^^^^^^^^^^^^^^^ help: try calling: `s.get(0)`\n    |\n    = note: `-D clippy::iter-next-slice` implied by `-D warnings`\n \n-error: Using `.iter().next()` on a Slice without end index.\n+error: using `.iter().next()` on a Slice without end index\n   --> $DIR/iter_next_slice.rs:12:5\n    |\n LL |     s[2..].iter().next();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: try calling: `s.get(2)`\n \n-error: Using `.iter().next()` on a Slice without end index.\n+error: using `.iter().next()` on a Slice without end index\n   --> $DIR/iter_next_slice.rs:15:5\n    |\n LL |     v[5..].iter().next();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: try calling: `v.get(5)`\n \n-error: Using `.iter().next()` on an array\n+error: using `.iter().next()` on an array\n   --> $DIR/iter_next_slice.rs:18:5\n    |\n LL |     v.iter().next();"}, {"sha": "1f3b8ac99b19146f766e6758d0cd799d37dc92c0", "filename": "src/tools/clippy/tests/ui/len_zero.fixed", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -141,11 +141,3 @@ fn main() {\n fn test_slice(b: &[u8]) {\n     if !b.is_empty() {}\n }\n-\n-mod issue_3807 {\n-    // Avoid suggesting changes to ranges if the user did not enable `range_is_empty`.\n-    // See https://github.com/rust-lang/rust/issues/48111#issuecomment-445132965\n-    fn no_suggestion() {\n-        let _ = (0..42).len() == 0;\n-    }\n-}"}, {"sha": "dc21de0001b6c76eb2f57cdba4e7416319d5b756", "filename": "src/tools/clippy/tests/ui/len_zero.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -141,11 +141,3 @@ fn main() {\n fn test_slice(b: &[u8]) {\n     if b.len() != 0 {}\n }\n-\n-mod issue_3807 {\n-    // Avoid suggesting changes to ranges if the user did not enable `range_is_empty`.\n-    // See https://github.com/rust-lang/rust/issues/48111#issuecomment-445132965\n-    fn no_suggestion() {\n-        let _ = (0..42).len() == 0;\n-    }\n-}"}, {"sha": "7978176624274ab7626f9c45be5d383daf7cde36", "filename": "src/tools/clippy/tests/ui/len_zero_ranges.fixed", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,15 +1,17 @@\n // run-rustfix\n \n-#![feature(range_is_empty)]\n #![warn(clippy::len_zero)]\n #![allow(unused)]\n-#![allow(stable_features)] // TODO: https://github.com/rust-lang/rust-clippy/issues/5956\n \n+// Now that `Range(Inclusive)::is_empty` is stable (1.47), we can always suggest this\n mod issue_3807 {\n-    // With the feature enabled, `is_empty` should be suggested\n-    fn suggestion_is_fine() {\n+    fn suggestion_is_fine_range() {\n         let _ = (0..42).is_empty();\n     }\n+\n+    fn suggestion_is_fine_range_inclusive() {\n+        let _ = (0_u8..=42).is_empty();\n+    }\n }\n \n fn main() {}"}, {"sha": "a0eb51cc9760c462372dddaaa31819db94541efe", "filename": "src/tools/clippy/tests/ui/len_zero_ranges.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,15 +1,17 @@\n // run-rustfix\n \n-#![feature(range_is_empty)]\n #![warn(clippy::len_zero)]\n #![allow(unused)]\n-#![allow(stable_features)] // TODO: https://github.com/rust-lang/rust-clippy/issues/5956\n \n+// Now that `Range(Inclusive)::is_empty` is stable (1.47), we can always suggest this\n mod issue_3807 {\n-    // With the feature enabled, `is_empty` should be suggested\n-    fn suggestion_is_fine() {\n+    fn suggestion_is_fine_range() {\n         let _ = (0..42).len() == 0;\n     }\n+\n+    fn suggestion_is_fine_range_inclusive() {\n+        let _ = (0_u8..=42).len() == 0;\n+    }\n }\n \n fn main() {}"}, {"sha": "d0defb5a79edcb582ca4b5711ce40ee3a4af0e9f", "filename": "src/tools/clippy/tests/ui/len_zero_ranges.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,10 +1,16 @@\n error: length comparison to zero\n-  --> $DIR/len_zero_ranges.rs:11:17\n+  --> $DIR/len_zero_ranges.rs:9:17\n    |\n LL |         let _ = (0..42).len() == 0;\n    |                 ^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `(0..42).is_empty()`\n    |\n    = note: `-D clippy::len-zero` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: length comparison to zero\n+  --> $DIR/len_zero_ranges.rs:13:17\n+   |\n+LL |         let _ = (0_u8..=42).len() == 0;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `(0_u8..=42).is_empty()`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "73e550b3df891864fac7c2cd2a46920efbf890f9", "filename": "src/tools/clippy/tests/ui/let_and_return.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -135,4 +135,25 @@ mod no_lint_if_stmt_borrows {\n     }\n }\n \n+mod issue_5729 {\n+    use std::sync::Arc;\n+\n+    trait Foo {}\n+\n+    trait FooStorage {\n+        fn foo_cloned(&self) -> Arc<dyn Foo>;\n+    }\n+\n+    struct FooStorageImpl<T: Foo> {\n+        foo: Arc<T>,\n+    }\n+\n+    impl<T: Foo + 'static> FooStorage for FooStorageImpl<T> {\n+        fn foo_cloned(&self) -> Arc<dyn Foo> {\n+            let clone = Arc::clone(&self.foo);\n+            clone\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "fe878e5f20601ff68d80908aaf95711f52463d9e", "filename": "src/tools/clippy/tests/ui/let_and_return.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -27,5 +27,19 @@ LL |\n LL |         5\n    |\n \n-error: aborting due to 2 previous errors\n+error: returning the result of a `let` binding from a block\n+  --> $DIR/let_and_return.rs:154:13\n+   |\n+LL |             let clone = Arc::clone(&self.foo);\n+   |             ---------------------------------- unnecessary `let` binding\n+LL |             clone\n+   |             ^^^^^\n+   |\n+help: return the expression directly\n+   |\n+LL |             \n+LL |             Arc::clone(&self.foo) as _\n+   |\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "4f43cff50244449b93b23b76db601285132eab85", "filename": "src/tools/clippy/tests/ui/map_clone.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_clone.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,40 +1,40 @@\n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:10:22\n    |\n LL |     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `vec![5_i8; 6].iter().copied()`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `vec![5_i8; 6].iter().copied()`\n    |\n    = note: `-D clippy::map-clone` implied by `-D warnings`\n \n-error: You are using an explicit closure for cloning elements\n+error: you are using an explicit closure for cloning elements\n   --> $DIR/map_clone.rs:11:26\n    |\n LL |     let _: Vec<String> = vec![String::new()].iter().map(|x| x.clone()).collect();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n \n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:12:23\n    |\n LL |     let _: Vec<u32> = vec![42, 43].iter().map(|&x| x).collect();\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `vec![42, 43].iter().copied()`\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `vec![42, 43].iter().copied()`\n \n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:14:26\n    |\n LL |     let _: Option<u64> = Some(&16).map(|b| *b);\n-   |                          ^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `Some(&16).copied()`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `Some(&16).copied()`\n \n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:15:25\n    |\n LL |     let _: Option<u8> = Some(&1).map(|x| x.clone());\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `Some(&1).copied()`\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `Some(&1).copied()`\n \n-error: You are needlessly cloning iterator elements\n+error: you are needlessly cloning iterator elements\n   --> $DIR/map_clone.rs:26:29\n    |\n LL |     let _ = std::env::args().map(|v| v.clone());\n-   |                             ^^^^^^^^^^^^^^^^^^^ help: Remove the `map` call\n+   |                             ^^^^^^^^^^^^^^^^^^^ help: remove the `map` call\n \n error: aborting due to 6 previous errors\n "}, {"sha": "80dd2f744b3a1137c06f513a4329afee18f9de9f", "filename": "src/tools/clippy/tests/ui/methods.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -10,6 +10,7 @@\n     clippy::non_ascii_literal,\n     clippy::new_without_default,\n     clippy::needless_pass_by_value,\n+    clippy::needless_lifetimes,\n     clippy::print_stdout,\n     clippy::must_use_candidate,\n     clippy::use_self,\n@@ -33,71 +34,6 @@ use std::sync::{self, Arc};\n \n use option_helpers::IteratorFalsePositives;\n \n-pub struct T;\n-\n-impl T {\n-    pub fn add(self, other: T) -> T {\n-        self\n-    }\n-\n-    // no error, not public interface\n-    pub(crate) fn drop(&mut self) {}\n-\n-    // no error, private function\n-    fn neg(self) -> Self {\n-        self\n-    }\n-\n-    // no error, private function\n-    fn eq(&self, other: T) -> bool {\n-        true\n-    }\n-\n-    // No error; self is a ref.\n-    fn sub(&self, other: T) -> &T {\n-        self\n-    }\n-\n-    // No error; different number of arguments.\n-    fn div(self) -> T {\n-        self\n-    }\n-\n-    // No error; wrong return type.\n-    fn rem(self, other: T) {}\n-\n-    // Fine\n-    fn into_u32(self) -> u32 {\n-        0\n-    }\n-\n-    fn into_u16(&self) -> u16 {\n-        0\n-    }\n-\n-    fn to_something(self) -> u32 {\n-        0\n-    }\n-\n-    fn new(self) -> Self {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct T1;\n-\n-impl T1 {\n-    // Shouldn't trigger lint as it is unsafe.\n-    pub unsafe fn add(self, rhs: T1) -> T1 {\n-        self\n-    }\n-\n-    // Should not trigger lint since this is an async function.\n-    pub async fn next(&mut self) -> Option<T1> {\n-        None\n-    }\n-}\n-\n struct Lt<'a> {\n     foo: &'a u32,\n }\n@@ -171,6 +107,8 @@ impl BadNew {\n     }\n }\n \n+struct T;\n+\n impl Mul<T> for T {\n     type Output = T;\n     // No error, obviously."}, {"sha": "2a0a43e83a653089158ed99ac5e80d4d729ad8f7", "filename": "src/tools/clippy/tests/ui/methods.stderr", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,15 +1,5 @@\n-error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:39:5\n-   |\n-LL | /     pub fn add(self, other: T) -> T {\n-LL | |         self\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n-\n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:169:5\n+  --> $DIR/methods.rs:105:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:188:13\n+  --> $DIR/methods.rs:126:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -28,7 +18,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:191:13\n+  --> $DIR/methods.rs:129:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -38,33 +28,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:208:22\n+  --> $DIR/methods.rs:146:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:209:20\n+  --> $DIR/methods.rs:147:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:210:20\n+  --> $DIR/methods.rs:148:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:211:22\n+  --> $DIR/methods.rs:149:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:214:13\n+  --> $DIR/methods.rs:152:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -74,13 +64,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:220:22\n+  --> $DIR/methods.rs:158:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:223:13\n+  --> $DIR/methods.rs:161:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -90,13 +80,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:229:22\n+  --> $DIR/methods.rs:167:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:232:13\n+  --> $DIR/methods.rs:170:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -105,5 +95,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "062d30b262c1be2dc62988f12e535e70972afa7b", "filename": "src/tools/clippy/tests/ui/mut_reference.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_reference.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,18 +1,18 @@\n-error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n+error: the function `takes_an_immutable_reference` doesn't need a mutable reference\n   --> $DIR/mut_reference.rs:17:34\n    |\n LL |     takes_an_immutable_reference(&mut 42);\n    |                                  ^^^^^^^\n    |\n    = note: `-D clippy::unnecessary-mut-passed` implied by `-D warnings`\n \n-error: The function/method `as_ptr` doesn't need a mutable reference\n+error: the function `as_ptr` doesn't need a mutable reference\n   --> $DIR/mut_reference.rs:19:12\n    |\n LL |     as_ptr(&mut 42);\n    |            ^^^^^^^\n \n-error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n+error: the method `takes_an_immutable_reference` doesn't need a mutable reference\n   --> $DIR/mut_reference.rs:23:44\n    |\n LL |     my_struct.takes_an_immutable_reference(&mut 42);"}, {"sha": "a3511ba708a885f808e6f4afd7d257149951c891", "filename": "src/tools/clippy/tests/ui/mutex_atomic.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,44 +1,44 @@\n-error: Consider using an `AtomicBool` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicBool` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:6:5\n    |\n LL |     Mutex::new(true);\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutex-atomic` implied by `-D warnings`\n \n-error: Consider using an `AtomicUsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicUsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:7:5\n    |\n LL |     Mutex::new(5usize);\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicIsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicIsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:8:5\n    |\n LL |     Mutex::new(9isize);\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicPtr` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicPtr` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:10:5\n    |\n LL |     Mutex::new(&x as *const u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicPtr` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicPtr` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:11:5\n    |\n LL |     Mutex::new(&mut x as *mut u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicUsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicUsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:12:5\n    |\n LL |     Mutex::new(0u32);\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutex-integer` implied by `-D warnings`\n \n-error: Consider using an `AtomicIsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicIsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:13:5\n    |\n LL |     Mutex::new(0i32);"}, {"sha": "883683e08a2aa83b4356d0a31bef4a7983cdf570", "filename": "src/tools/clippy/tests/ui/needless_doc_main.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -9,16 +9,21 @@\n /// }\n /// ```\n ///\n-/// This should, too.\n+/// With an explicit return type it should lint too\n+/// ```\n+/// fn main() -> () {\n+///     unimplemented!();\n+/// }\n+/// ```\n ///\n+/// This should, too.\n /// ```rust\n /// fn main() {\n ///     unimplemented!();\n /// }\n /// ```\n ///\n /// This one too.\n-///\n /// ```no_run\n /// fn main() {\n ///     unimplemented!();\n@@ -33,6 +38,20 @@ fn bad_doctests() {}\n /// fn main(){}\n /// ```\n ///\n+/// This shouldn't lint either, because main is async:\n+/// ```\n+/// async fn main() {\n+///     assert_eq!(42, ANSWER);\n+/// }\n+/// ```\n+///\n+/// Same here, because the return type is not the unit type:\n+/// ```\n+/// fn main() -> Result<()> {\n+///     Ok(())\n+/// }\n+/// ```\n+///\n /// This shouldn't lint either, because there's a `static`:\n /// ```\n /// static ANSWER: i32 = 42;\n@@ -42,6 +61,15 @@ fn bad_doctests() {}\n /// }\n /// ```\n ///\n+/// This shouldn't lint either, because there's a `const`:\n+/// ```\n+/// fn main() {\n+///     assert_eq!(42, ANSWER);\n+/// }\n+///\n+/// const ANSWER: i32 = 42;\n+/// ```\n+///\n /// Neither should this lint because of `extern crate`:\n /// ```\n /// #![feature(test)]\n@@ -51,16 +79,48 @@ fn bad_doctests() {}\n /// }\n /// ```\n ///\n-/// We should not lint ignored examples:\n+/// Neither should this lint because it has an extern block:\n+/// ```\n+/// extern {}\n+/// fn main() {\n+///     unimplemented!();\n+/// }\n+/// ```\n+///\n+/// This should not lint because there is another function defined:\n+/// ```\n+/// fn fun() {}\n+///\n+/// fn main() {\n+///     unimplemented!();\n+/// }\n+/// ```\n ///\n+/// We should not lint inside raw strings ...\n+/// ```\n+/// let string = r#\"\n+/// fn main() {\n+///     unimplemented!();\n+/// }\n+/// \"#;\n+/// ```\n+///\n+/// ... or comments\n+/// ```\n+/// // fn main() {\n+/// //     let _inception = 42;\n+/// // }\n+/// let _inception = 42;\n+/// ```\n+///\n+/// We should not lint ignored examples:\n /// ```rust,ignore\n /// fn main() {\n ///     unimplemented!();\n /// }\n /// ```\n ///\n /// Or even non-rust examples:\n-///\n /// ```text\n /// fn main() {\n ///     is what starts the program"}, {"sha": "05c7f9d33a7924f3d1ea642b0ad665f7edbf06d7", "filename": "src/tools/clippy/tests/ui/needless_doc_main.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -7,16 +7,22 @@ LL | /// fn main() {\n    = note: `-D clippy::needless-doctest-main` implied by `-D warnings`\n \n error: needless `fn main` in doctest\n-  --> $DIR/needless_doc_main.rs:15:4\n+  --> $DIR/needless_doc_main.rs:14:4\n+   |\n+LL | /// fn main() -> () {\n+   |    ^^^^^^^^^^^^^^^^^^\n+\n+error: needless `fn main` in doctest\n+  --> $DIR/needless_doc_main.rs:21:4\n    |\n LL | /// fn main() {\n    |    ^^^^^^^^^^^^\n \n error: needless `fn main` in doctest\n-  --> $DIR/needless_doc_main.rs:23:4\n+  --> $DIR/needless_doc_main.rs:28:4\n    |\n LL | /// fn main() {\n    |    ^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "d849e093da7bb821a765122d0d966ba78adf4a39", "filename": "src/tools/clippy/tests/ui/needless_return.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -69,6 +69,23 @@ fn test_void_match(x: u32) {\n     }\n }\n \n+fn read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n+}\n+\n+fn borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        String::from(\"test\")\n+    } else {\n+        String::new()\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "29f2bd1852af00e9f1df68916f1f7624046e4c93", "filename": "src/tools/clippy/tests/ui/needless_return.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -69,6 +69,23 @@ fn test_void_match(x: u32) {\n     }\n }\n \n+fn read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n+}\n+\n+fn borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        return String::from(\"test\");\n+    } else {\n+        return String::new();\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "f73c833a801f3dc143bb92545a5e7ad41b566916", "filename": "src/tools/clippy/tests/ui/needless_return.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -72,5 +72,17 @@ error: unneeded `return` statement\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n-error: aborting due to 12 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:83:9\n+   |\n+LL |         return String::from(\"test\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:85:9\n+   |\n+LL |         return String::new();\n+   |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "e82873629a54b0de91ad1068fff7d552001fe81b", "filename": "src/tools/clippy/tests/ui/new_ret_no_self.rs", "status": "modified", "additions": 132, "deletions": 2, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnew_ret_no_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnew_ret_no_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnew_ret_no_self.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -137,9 +137,9 @@ impl MutPointerReturnerOk {\n     }\n }\n \n-struct MutPointerReturnerOk2;\n+struct ConstPointerReturnerOk2;\n \n-impl MutPointerReturnerOk2 {\n+impl ConstPointerReturnerOk2 {\n     // should not trigger lint\n     pub fn new() -> *const Self {\n         unimplemented!();\n@@ -210,3 +210,133 @@ impl<'a> WithLifetime<'a> {\n         unimplemented!();\n     }\n }\n+\n+mod issue5435 {\n+    struct V;\n+\n+    pub trait TraitRetSelf {\n+        // should not trigger lint\n+        fn new() -> Self;\n+    }\n+\n+    pub trait TraitRet {\n+        // should trigger lint as we are in trait definition\n+        fn new() -> String;\n+    }\n+    pub struct StructRet;\n+    impl TraitRet for StructRet {\n+        // should not trigger lint as we are in the impl block\n+        fn new() -> String {\n+            unimplemented!();\n+        }\n+    }\n+\n+    pub trait TraitRet2 {\n+        // should trigger lint\n+        fn new(_: String) -> String;\n+    }\n+\n+    trait TupleReturnerOk {\n+        // should not trigger lint\n+        fn new() -> (Self, u32)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait TupleReturnerOk2 {\n+        // should not trigger lint (it doesn't matter which element in the tuple is Self)\n+        fn new() -> (u32, Self)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait TupleReturnerOk3 {\n+        // should not trigger lint (tuple can contain multiple Self)\n+        fn new() -> (Self, Self)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait TupleReturnerBad {\n+        // should trigger lint\n+        fn new() -> (u32, u32) {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait MutPointerReturnerOk {\n+        // should not trigger lint\n+        fn new() -> *mut Self\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait ConstPointerReturnerOk2 {\n+        // should not trigger lint\n+        fn new() -> *const Self\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait MutPointerReturnerBad {\n+        // should trigger lint\n+        fn new() -> *mut V {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait GenericReturnerOk {\n+        // should not trigger lint\n+        fn new() -> Option<Self>\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait NestedReturnerOk {\n+        // should not trigger lint\n+        fn new() -> (Option<Self>, u32)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait NestedReturnerOk2 {\n+        // should not trigger lint\n+        fn new() -> ((Self, u32), u32)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait NestedReturnerOk3 {\n+        // should not trigger lint\n+        fn new() -> Option<(Self, u32)>\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+}"}, {"sha": "8217bc6187f93aa5cfce1ddbc5ce7ed4788b6173", "filename": "src/tools/clippy/tests/ui/new_ret_no_self.stderr", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnew_ret_no_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnew_ret_no_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnew_ret_no_self.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -48,5 +48,33 @@ LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n \n-error: aborting due to 6 previous errors\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:224:9\n+   |\n+LL |         fn new() -> String;\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:236:9\n+   |\n+LL |         fn new(_: String) -> String;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:271:9\n+   |\n+LL | /         fn new() -> (u32, u32) {\n+LL | |             unimplemented!();\n+LL | |         }\n+   | |_________^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:298:9\n+   |\n+LL | /         fn new() -> *mut V {\n+LL | |             unimplemented!();\n+LL | |         }\n+   | |_________^\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "07d7f0b45b0c2f2171cd29c29a4360deb7cff1ed", "filename": "src/tools/clippy/tests/ui/option_as_ref_deref.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -38,4 +38,7 @@ fn main() {\n \n     let _ = opt.as_deref();\n     let _ = opt.as_deref_mut();\n+\n+    // Issue #5927\n+    let _ = opt.as_deref();\n }"}, {"sha": "6ae059c9425d35480c7afcc00ab7e6b63b0db3cf", "filename": "src/tools/clippy/tests/ui/option_as_ref_deref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -41,4 +41,7 @@ fn main() {\n \n     let _ = opt.as_ref().map(|x| &**x);\n     let _ = opt.as_mut().map(|x| &mut **x);\n+\n+    // Issue #5927\n+    let _ = opt.as_ref().map(std::ops::Deref::deref);\n }"}, {"sha": "62f28232475282a1a51ade866365560ec6031386", "filename": "src/tools/clippy/tests/ui/option_as_ref_deref.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_as_ref_deref.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -100,5 +100,11 @@ error: called `.as_mut().map(|x| &mut **x)` on an Option value. This can be done\n LL |     let _ = opt.as_mut().map(|x| &mut **x);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.as_deref_mut()`\n \n-error: aborting due to 16 previous errors\n+error: called `.as_ref().map(std::ops::Deref::deref)` on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n+  --> $DIR/option_as_ref_deref.rs:46:13\n+   |\n+LL |     let _ = opt.as_ref().map(std::ops::Deref::deref);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.as_deref()`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "163bd044c178ee37fdcbc91763aec383e78b69bd", "filename": "src/tools/clippy/tests/ui/precedence.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -48,6 +48,14 @@ fn main() {\n     let _ = -1f64.to_degrees();\n     let _ = -1f64.to_radians();\n \n+    // Chains containing any non-odd function should trigger (issue #5924)\n+    let _ = -(1.0_f64.cos().cos());\n+    let _ = -(1.0_f64.cos().sin());\n+    let _ = -(1.0_f64.sin().cos());\n+\n+    // Chains of odd functions shouldn't trigger\n+    let _ = -1f64.sin().sin();\n+\n     let b = 3;\n     trip!(b * 8);\n }"}, {"sha": "8c849e3209b088909668d26df45246472be9defc", "filename": "src/tools/clippy/tests/ui/precedence.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -48,6 +48,14 @@ fn main() {\n     let _ = -1f64.to_degrees();\n     let _ = -1f64.to_radians();\n \n+    // Chains containing any non-odd function should trigger (issue #5924)\n+    let _ = -1.0_f64.cos().cos();\n+    let _ = -1.0_f64.cos().sin();\n+    let _ = -1.0_f64.sin().cos();\n+\n+    // Chains of odd functions shouldn't trigger\n+    let _ = -1f64.sin().sin();\n+\n     let b = 3;\n     trip!(b * 8);\n }"}, {"sha": "03d585b39750a6cc3932fdf8c539063c76e28b1d", "filename": "src/tools/clippy/tests/ui/precedence.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprecedence.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -54,5 +54,23 @@ error: unary minus has lower precedence than method call\n LL |     -1f32.abs();\n    |     ^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1f32.abs())`\n \n-error: aborting due to 9 previous errors\n+error: unary minus has lower precedence than method call\n+  --> $DIR/precedence.rs:52:13\n+   |\n+LL |     let _ = -1.0_f64.cos().cos();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1.0_f64.cos().cos())`\n+\n+error: unary minus has lower precedence than method call\n+  --> $DIR/precedence.rs:53:13\n+   |\n+LL |     let _ = -1.0_f64.cos().sin();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1.0_f64.cos().sin())`\n+\n+error: unary minus has lower precedence than method call\n+  --> $DIR/precedence.rs:54:13\n+   |\n+LL |     let _ = -1.0_f64.sin().cos();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1.0_f64.sin().cos())`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "6514fd6d1ac76bbe7ebbbd37453af5002e3c3308", "filename": "src/tools/clippy/tests/ui/redundant_allocation.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -33,7 +33,7 @@ pub fn test5(a: Rc<bool>) {}\n \n // Rc<Box<T>>\n \n-pub fn test6(a: Box<bool>) {}\n+pub fn test6(a: Rc<bool>) {}\n \n // Box<&T>\n "}, {"sha": "92e4f67f5db6e40e6f2f0f9bd8ed422b3ec32c0c", "filename": "src/tools/clippy/tests/ui/redundant_allocation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -28,7 +28,7 @@ error: usage of `Rc<Box<T>>`\n   --> $DIR/redundant_allocation.rs:36:17\n    |\n LL | pub fn test6(a: Rc<Box<bool>>) {}\n-   |                 ^^^^^^^^^^^^^ help: try: `Box<bool>`\n+   |                 ^^^^^^^^^^^^^ help: try: `Rc<bool>`\n \n error: usage of `Box<&T>`\n   --> $DIR/redundant_allocation.rs:40:22"}, {"sha": "2735e41738f0d0ef4555759f74260fa5e82bca38", "filename": "src/tools/clippy/tests/ui/redundant_closure_call_early.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_early.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,12 +1,12 @@\n-error: try not to call a closure in the expression where it is declared.\n+error: try not to call a closure in the expression where it is declared\n   --> $DIR/redundant_closure_call_early.rs:9:17\n    |\n LL |     let mut k = (|m| m + 1)(i);\n    |                 ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::redundant-closure-call` implied by `-D warnings`\n \n-error: try not to call a closure in the expression where it is declared.\n+error: try not to call a closure in the expression where it is declared\n   --> $DIR/redundant_closure_call_early.rs:12:9\n    |\n LL |     k = (|a, b| a * b)(1, 5);"}, {"sha": "afd704ef12a934f913454334a42bd68c5a95a954", "filename": "src/tools/clippy/tests/ui/redundant_closure_call_fixable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_fixable.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,4 @@\n-error: try not to call a closure in the expression where it is declared.\n+error: try not to call a closure in the expression where it is declared\n   --> $DIR/redundant_closure_call_fixable.rs:7:13\n    |\n LL |     let a = (|| 42)();"}, {"sha": "1f4864b72895bf10142574e214bdfe352eba896a", "filename": "src/tools/clippy/tests/ui/redundant_closure_call_late.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_closure_call_late.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -24,4 +24,16 @@ fn main() {\n     let shadowed_closure = || 2;\n     i = shadowed_closure();\n     i = shadowed_closure();\n+\n+    // Fix FP in #5916\n+    let mut x;\n+    let create = || 2 * 2;\n+    x = create();\n+    fun(move || {\n+        x = create();\n+    })\n+}\n+\n+fn fun<T: 'static + FnMut()>(mut f: T) {\n+    f();\n }"}, {"sha": "bfe27e020445c77b83c4ddfb14f773eb4ee36b85", "filename": "src/tools/clippy/tests/ui/same_item_push.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_item_push.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -86,4 +86,12 @@ fn main() {\n     for a in vec_a {\n         vec12.push(2u8.pow(a.kind));\n     }\n+\n+    // Fix #5902\n+    let mut vec13: Vec<u8> = Vec::new();\n+    let mut item = 0;\n+    for _ in 0..10 {\n+        vec13.push(item);\n+        item += 10;\n+    }\n }"}, {"sha": "a7cbb9cd78b151cb82b9f415c59a170be1541e2e", "filename": "src/tools/clippy/tests/ui/self_assignment.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fself_assignment.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,67 @@\n+#![warn(clippy::self_assignment)]\n+\n+pub struct S<'a> {\n+    a: i32,\n+    b: [i32; 10],\n+    c: Vec<Vec<i32>>,\n+    e: &'a mut i32,\n+    f: &'a mut i32,\n+}\n+\n+pub fn positives(mut a: usize, b: &mut u32, mut s: S) {\n+    a = a;\n+    *b = *b;\n+    s = s;\n+    s.a = s.a;\n+    s.b[10] = s.b[5 + 5];\n+    s.c[0][1] = s.c[0][1];\n+    s.b[a] = s.b[a];\n+    *s.e = *s.e;\n+    s.b[a + 10] = s.b[10 + a];\n+\n+    let mut t = (0, 1);\n+    t.1 = t.1;\n+    t.0 = (t.0);\n+}\n+\n+pub fn negatives_not_equal(mut a: usize, b: &mut usize, mut s: S) {\n+    dbg!(&a);\n+    a = *b;\n+    dbg!(&a);\n+    s.b[1] += s.b[1];\n+    s.b[1] = s.b[2];\n+    s.c[1][0] = s.c[0][1];\n+    s.b[a] = s.b[*b];\n+    s.b[a + 10] = s.b[a + 11];\n+    *s.e = *s.f;\n+\n+    let mut t = (0, 1);\n+    t.0 = t.1;\n+}\n+\n+#[allow(clippy::eval_order_dependence)]\n+pub fn negatives_side_effects() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let mut i = 0;\n+    v[{\n+        i += 1;\n+        i\n+    }] = v[{\n+        i += 1;\n+        i\n+    }];\n+\n+    fn next(n: &mut usize) -> usize {\n+        let v = *n;\n+        *n += 1;\n+        v\n+    }\n+\n+    let mut w = vec![1, 2, 3, 4, 5];\n+    let mut i = 0;\n+    let i = &mut i;\n+    w[next(i)] = w[next(i)];\n+    w[next(i)] = w[next(i)];\n+}\n+\n+fn main() {}"}, {"sha": "826e0d0ba888dacda4a21b006fed23157c67f22f", "filename": "src/tools/clippy/tests/ui/self_assignment.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fself_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fself_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fself_assignment.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,70 @@\n+error: self-assignment of `a` to `a`\n+  --> $DIR/self_assignment.rs:12:5\n+   |\n+LL |     a = a;\n+   |     ^^^^^\n+   |\n+   = note: `-D clippy::self-assignment` implied by `-D warnings`\n+\n+error: self-assignment of `*b` to `*b`\n+  --> $DIR/self_assignment.rs:13:5\n+   |\n+LL |     *b = *b;\n+   |     ^^^^^^^\n+\n+error: self-assignment of `s` to `s`\n+  --> $DIR/self_assignment.rs:14:5\n+   |\n+LL |     s = s;\n+   |     ^^^^^\n+\n+error: self-assignment of `s.a` to `s.a`\n+  --> $DIR/self_assignment.rs:15:5\n+   |\n+LL |     s.a = s.a;\n+   |     ^^^^^^^^^\n+\n+error: self-assignment of `s.b[5 + 5]` to `s.b[10]`\n+  --> $DIR/self_assignment.rs:16:5\n+   |\n+LL |     s.b[10] = s.b[5 + 5];\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `s.c[0][1]` to `s.c[0][1]`\n+  --> $DIR/self_assignment.rs:17:5\n+   |\n+LL |     s.c[0][1] = s.c[0][1];\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `s.b[a]` to `s.b[a]`\n+  --> $DIR/self_assignment.rs:18:5\n+   |\n+LL |     s.b[a] = s.b[a];\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `*s.e` to `*s.e`\n+  --> $DIR/self_assignment.rs:19:5\n+   |\n+LL |     *s.e = *s.e;\n+   |     ^^^^^^^^^^^\n+\n+error: self-assignment of `s.b[10 + a]` to `s.b[a + 10]`\n+  --> $DIR/self_assignment.rs:20:5\n+   |\n+LL |     s.b[a + 10] = s.b[10 + a];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `t.1` to `t.1`\n+  --> $DIR/self_assignment.rs:23:5\n+   |\n+LL |     t.1 = t.1;\n+   |     ^^^^^^^^^\n+\n+error: self-assignment of `(t.0)` to `t.0`\n+  --> $DIR/self_assignment.rs:24:5\n+   |\n+LL |     t.0 = (t.0);\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "6c5ffe6aba8b7b7c1e4923c957617f6df31ffc64", "filename": "src/tools/clippy/tests/ui/should_impl_trait/corner_cases.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,83 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+pub struct T1;\n+impl T1 {\n+    // corner cases: should not lint\n+\n+    // no error, not public interface\n+    pub(crate) fn drop(&mut self) {}\n+\n+    // no error, private function\n+    fn neg(self) -> Self {\n+        self\n+    }\n+\n+    // no error, private function\n+    fn eq(&self, other: Self) -> bool {\n+        true\n+    }\n+\n+    // No error; self is a ref.\n+    fn sub(&self, other: Self) -> &Self {\n+        self\n+    }\n+\n+    // No error; different number of arguments.\n+    fn div(self) -> Self {\n+        self\n+    }\n+\n+    // No error; wrong return type.\n+    fn rem(self, other: Self) {}\n+\n+    // Fine\n+    fn into_u32(self) -> u32 {\n+        0\n+    }\n+\n+    fn into_u16(&self) -> u16 {\n+        0\n+    }\n+\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n+\n+    fn new(self) -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn next<'b>(&'b mut self) -> Option<&'b mut T1> {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct T2;\n+impl T2 {\n+    // Shouldn't trigger lint as it is unsafe.\n+    pub unsafe fn add(self, rhs: Self) -> Self {\n+        self\n+    }\n+\n+    // Should not trigger lint since this is an async function.\n+    pub async fn next(&mut self) -> Option<Self> {\n+        None\n+    }\n+}"}, {"sha": "f8d248fc98d82a2db4ac7ae5d106bfe10d7fe782", "filename": "src/tools/clippy/tests/ui/should_impl_trait/method_list_1.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,87 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+pub struct T;\n+\n+impl T {\n+    // *****************************************\n+    // trait method list part 1, should lint all\n+    // *****************************************\n+    pub fn add(self, other: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_mut(&mut self) -> &mut T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_ref(&self) -> &T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitand(self, rhs: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitxor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow(&self) -> &str {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow_mut(&mut self) -> &mut str {\n+        unimplemented!()\n+    }\n+\n+    pub fn clone(&self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn cmp(&self, other: &Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn default() -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref(&self) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref_mut(&mut self) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn div(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn drop(&mut self) {\n+        unimplemented!()\n+    }\n+    // **********\n+    // part 1 end\n+    // **********\n+}"}, {"sha": "2b7d4628c3fa02b703e9a58cb98b73d4a1dd6489", "filename": "src/tools/clippy/tests/ui/should_impl_trait/method_list_1.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,143 @@\n+error: method `add` can be confused for the standard trait method `std::ops::Add::add`\n+  --> $DIR/method_list_1.rs:25:5\n+   |\n+LL | /     pub fn add(self, other: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n+   = help: consider implementing the trait `std::ops::Add` or choosing a less ambiguous method name\n+\n+error: method `as_mut` can be confused for the standard trait method `std::convert::AsMut::as_mut`\n+  --> $DIR/method_list_1.rs:29:5\n+   |\n+LL | /     pub fn as_mut(&mut self) -> &mut T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::convert::AsMut` or choosing a less ambiguous method name\n+\n+error: method `as_ref` can be confused for the standard trait method `std::convert::AsRef::as_ref`\n+  --> $DIR/method_list_1.rs:33:5\n+   |\n+LL | /     pub fn as_ref(&self) -> &T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::convert::AsRef` or choosing a less ambiguous method name\n+\n+error: method `bitand` can be confused for the standard trait method `std::ops::BitAnd::bitand`\n+  --> $DIR/method_list_1.rs:37:5\n+   |\n+LL | /     pub fn bitand(self, rhs: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitAnd` or choosing a less ambiguous method name\n+\n+error: method `bitor` can be confused for the standard trait method `std::ops::BitOr::bitor`\n+  --> $DIR/method_list_1.rs:41:5\n+   |\n+LL | /     pub fn bitor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitOr` or choosing a less ambiguous method name\n+\n+error: method `bitxor` can be confused for the standard trait method `std::ops::BitXor::bitxor`\n+  --> $DIR/method_list_1.rs:45:5\n+   |\n+LL | /     pub fn bitxor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitXor` or choosing a less ambiguous method name\n+\n+error: method `borrow` can be confused for the standard trait method `std::borrow::Borrow::borrow`\n+  --> $DIR/method_list_1.rs:49:5\n+   |\n+LL | /     pub fn borrow(&self) -> &str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::borrow::Borrow` or choosing a less ambiguous method name\n+\n+error: method `borrow_mut` can be confused for the standard trait method `std::borrow::BorrowMut::borrow_mut`\n+  --> $DIR/method_list_1.rs:53:5\n+   |\n+LL | /     pub fn borrow_mut(&mut self) -> &mut str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::borrow::BorrowMut` or choosing a less ambiguous method name\n+\n+error: method `clone` can be confused for the standard trait method `std::clone::Clone::clone`\n+  --> $DIR/method_list_1.rs:57:5\n+   |\n+LL | /     pub fn clone(&self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name\n+\n+error: method `cmp` can be confused for the standard trait method `std::cmp::Ord::cmp`\n+  --> $DIR/method_list_1.rs:61:5\n+   |\n+LL | /     pub fn cmp(&self, other: &Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::cmp::Ord` or choosing a less ambiguous method name\n+\n+error: method `deref` can be confused for the standard trait method `std::ops::Deref::deref`\n+  --> $DIR/method_list_1.rs:69:5\n+   |\n+LL | /     pub fn deref(&self) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Deref` or choosing a less ambiguous method name\n+\n+error: method `deref_mut` can be confused for the standard trait method `std::ops::DerefMut::deref_mut`\n+  --> $DIR/method_list_1.rs:73:5\n+   |\n+LL | /     pub fn deref_mut(&mut self) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::DerefMut` or choosing a less ambiguous method name\n+\n+error: method `div` can be confused for the standard trait method `std::ops::Div::div`\n+  --> $DIR/method_list_1.rs:77:5\n+   |\n+LL | /     pub fn div(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Div` or choosing a less ambiguous method name\n+\n+error: method `drop` can be confused for the standard trait method `std::ops::Drop::drop`\n+  --> $DIR/method_list_1.rs:81:5\n+   |\n+LL | /     pub fn drop(&mut self) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Drop` or choosing a less ambiguous method name\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "ed5e0d384bf5040c0d90135bc6cd65ab5832306d", "filename": "src/tools/clippy/tests/ui/should_impl_trait/method_list_2.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,88 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+pub struct T;\n+\n+impl T {\n+    // *****************************************\n+    // trait method list part 2, should lint all\n+    // *****************************************\n+\n+    pub fn eq(&self, other: &Self) -> bool {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_iter<T>(iter: T) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_str(s: &str) -> Result<Self, Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn hash(&self, state: &mut T) {\n+        unimplemented!()\n+    }\n+\n+    pub fn index(&self, index: usize) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn into_iter(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn mul(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn neg(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn next(&mut self) -> Option<Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn not(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn rem(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shl(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shr(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn sub(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+    // **********\n+    // part 2 end\n+    // **********\n+}"}, {"sha": "b6fd435695698e6ca47adee8a423824472e6b14d", "filename": "src/tools/clippy/tests/ui/should_impl_trait/method_list_2.stderr", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,153 @@\n+error: method `eq` can be confused for the standard trait method `std::cmp::PartialEq::eq`\n+  --> $DIR/method_list_2.rs:26:5\n+   |\n+LL | /     pub fn eq(&self, other: &Self) -> bool {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n+   = help: consider implementing the trait `std::cmp::PartialEq` or choosing a less ambiguous method name\n+\n+error: method `from_iter` can be confused for the standard trait method `std::iter::FromIterator::from_iter`\n+  --> $DIR/method_list_2.rs:30:5\n+   |\n+LL | /     pub fn from_iter<T>(iter: T) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::FromIterator` or choosing a less ambiguous method name\n+\n+error: method `from_str` can be confused for the standard trait method `std::str::FromStr::from_str`\n+  --> $DIR/method_list_2.rs:34:5\n+   |\n+LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::str::FromStr` or choosing a less ambiguous method name\n+\n+error: method `hash` can be confused for the standard trait method `std::hash::Hash::hash`\n+  --> $DIR/method_list_2.rs:38:5\n+   |\n+LL | /     pub fn hash(&self, state: &mut T) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::hash::Hash` or choosing a less ambiguous method name\n+\n+error: method `index` can be confused for the standard trait method `std::ops::Index::index`\n+  --> $DIR/method_list_2.rs:42:5\n+   |\n+LL | /     pub fn index(&self, index: usize) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Index` or choosing a less ambiguous method name\n+\n+error: method `index_mut` can be confused for the standard trait method `std::ops::IndexMut::index_mut`\n+  --> $DIR/method_list_2.rs:46:5\n+   |\n+LL | /     pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::IndexMut` or choosing a less ambiguous method name\n+\n+error: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`\n+  --> $DIR/method_list_2.rs:50:5\n+   |\n+LL | /     pub fn into_iter(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name\n+\n+error: method `mul` can be confused for the standard trait method `std::ops::Mul::mul`\n+  --> $DIR/method_list_2.rs:54:5\n+   |\n+LL | /     pub fn mul(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Mul` or choosing a less ambiguous method name\n+\n+error: method `neg` can be confused for the standard trait method `std::ops::Neg::neg`\n+  --> $DIR/method_list_2.rs:58:5\n+   |\n+LL | /     pub fn neg(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Neg` or choosing a less ambiguous method name\n+\n+error: method `next` can be confused for the standard trait method `std::iter::Iterator::next`\n+  --> $DIR/method_list_2.rs:62:5\n+   |\n+LL | /     pub fn next(&mut self) -> Option<Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::Iterator` or choosing a less ambiguous method name\n+\n+error: method `not` can be confused for the standard trait method `std::ops::Not::not`\n+  --> $DIR/method_list_2.rs:66:5\n+   |\n+LL | /     pub fn not(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Not` or choosing a less ambiguous method name\n+\n+error: method `rem` can be confused for the standard trait method `std::ops::Rem::rem`\n+  --> $DIR/method_list_2.rs:70:5\n+   |\n+LL | /     pub fn rem(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Rem` or choosing a less ambiguous method name\n+\n+error: method `shl` can be confused for the standard trait method `std::ops::Shl::shl`\n+  --> $DIR/method_list_2.rs:74:5\n+   |\n+LL | /     pub fn shl(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Shl` or choosing a less ambiguous method name\n+\n+error: method `shr` can be confused for the standard trait method `std::ops::Shr::shr`\n+  --> $DIR/method_list_2.rs:78:5\n+   |\n+LL | /     pub fn shr(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Shr` or choosing a less ambiguous method name\n+\n+error: method `sub` can be confused for the standard trait method `std::ops::Sub::sub`\n+  --> $DIR/method_list_2.rs:82:5\n+   |\n+LL | /     pub fn sub(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Sub` or choosing a less ambiguous method name\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "0812c026a644fbdd84f05569edc5cf954a8a109f", "filename": "src/tools/clippy/tests/ui/single_char_push_str.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![warn(clippy::single_char_push_str)]\n+\n+fn main() {\n+    let mut string = String::new();\n+    string.push('R');\n+    string.push('\\'');\n+\n+    string.push('u');\n+    string.push_str(\"st\");\n+    string.push_str(\"\");\n+    string.push('\\x52');\n+    string.push('\\u{0052}');\n+    string.push('a');\n+}"}, {"sha": "ab293bbe4eeb5ce8171ec28f610410a45f2d5cb8", "filename": "src/tools/clippy/tests/ui/single_char_push_str.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![warn(clippy::single_char_push_str)]\n+\n+fn main() {\n+    let mut string = String::new();\n+    string.push_str(\"R\");\n+    string.push_str(\"'\");\n+\n+    string.push('u');\n+    string.push_str(\"st\");\n+    string.push_str(\"\");\n+    string.push_str(\"\\x52\");\n+    string.push_str(\"\\u{0052}\");\n+    string.push_str(r##\"a\"##);\n+}"}, {"sha": "0e9bdaa23e7e8474accd8321884cc0861db8405c", "filename": "src/tools/clippy/tests/ui/single_char_push_str.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,34 @@\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:6:5\n+   |\n+LL |     string.push_str(\"R\");\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('R')`\n+   |\n+   = note: `-D clippy::single-char-push-str` implied by `-D warnings`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:7:5\n+   |\n+LL |     string.push_str(\"'\");\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/'')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:12:5\n+   |\n+LL |     string.push_str(\"/x52\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/x52')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:13:5\n+   |\n+LL |     string.push_str(\"/u{0052}\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/u{0052}')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:14:5\n+   |\n+LL |     string.push_str(r##\"a\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('a')`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "780389f32bc1c6c721e7549880146870c53dd685", "filename": "src/tools/clippy/tests/ui/stable_sort_primitive.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstable_sort_primitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstable_sort_primitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstable_sort_primitive.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,42 +1,42 @@\n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `i32`\n   --> $DIR/stable_sort_primitive.rs:7:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n    = note: `-D clippy::stable-sort-primitive` implied by `-D warnings`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `bool`\n   --> $DIR/stable_sort_primitive.rs:9:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `char`\n   --> $DIR/stable_sort_primitive.rs:11:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `str`\n   --> $DIR/stable_sort_primitive.rs:13:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `tuple`\n   --> $DIR/stable_sort_primitive.rs:15:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `array`\n   --> $DIR/stable_sort_primitive.rs:17:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable to sort primitive type `i32`\n   --> $DIR/stable_sort_primitive.rs:19:5\n    |\n LL |     arr.sort();"}, {"sha": "5c280efac1a876dbb849b7c81940b6d3db1b48ad", "filename": "src/tools/clippy/tests/ui/suspicious_arithmetic_impl.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::suspicious_arithmetic_impl)]\n-use std::ops::{Add, AddAssign, BitOrAssign, Div, DivAssign, Mul, MulAssign, Sub};\n+use std::ops::{\n+    Add, AddAssign, BitAnd, BitOr, BitOrAssign, BitXor, Div, DivAssign, Mul, MulAssign, Rem, Shl, Shr, Sub,\n+};\n \n #[derive(Copy, Clone)]\n struct Foo(u32);\n@@ -61,6 +63,54 @@ impl Div for Foo {\n     }\n }\n \n+impl Rem for Foo {\n+    type Output = Foo;\n+\n+    fn rem(self, other: Self) -> Self {\n+        Foo(self.0 / other.0)\n+    }\n+}\n+\n+impl BitAnd for Foo {\n+    type Output = Foo;\n+\n+    fn bitand(self, other: Self) -> Self {\n+        Foo(self.0 | other.0)\n+    }\n+}\n+\n+impl BitOr for Foo {\n+    type Output = Foo;\n+\n+    fn bitor(self, other: Self) -> Self {\n+        Foo(self.0 ^ other.0)\n+    }\n+}\n+\n+impl BitXor for Foo {\n+    type Output = Foo;\n+\n+    fn bitxor(self, other: Self) -> Self {\n+        Foo(self.0 & other.0)\n+    }\n+}\n+\n+impl Shl for Foo {\n+    type Output = Foo;\n+\n+    fn shl(self, other: Self) -> Self {\n+        Foo(self.0 >> other.0)\n+    }\n+}\n+\n+impl Shr for Foo {\n+    type Output = Foo;\n+\n+    fn shr(self, other: Self) -> Self {\n+        Foo(self.0 << other.0)\n+    }\n+}\n+\n struct Bar(i32);\n \n impl Add for Bar {"}, {"sha": "388fc7400820947ab912c088099d94e20391995d", "filename": "src/tools/clippy/tests/ui/suspicious_arithmetic_impl.stderr", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,24 +1,60 @@\n error: suspicious use of binary operator in `Add` impl\n-  --> $DIR/suspicious_arithmetic_impl.rs:11:20\n+  --> $DIR/suspicious_arithmetic_impl.rs:13:20\n    |\n LL |         Foo(self.0 - other.0)\n    |                    ^\n    |\n    = note: `-D clippy::suspicious-arithmetic-impl` implied by `-D warnings`\n \n error: suspicious use of binary operator in `AddAssign` impl\n-  --> $DIR/suspicious_arithmetic_impl.rs:17:23\n+  --> $DIR/suspicious_arithmetic_impl.rs:19:23\n    |\n LL |         *self = *self - other;\n    |                       ^\n    |\n    = note: `#[deny(clippy::suspicious_op_assign_impl)]` on by default\n \n error: suspicious use of binary operator in `MulAssign` impl\n-  --> $DIR/suspicious_arithmetic_impl.rs:30:16\n+  --> $DIR/suspicious_arithmetic_impl.rs:32:16\n    |\n LL |         self.0 /= other.0;\n    |                ^^\n \n-error: aborting due to 3 previous errors\n+error: suspicious use of binary operator in `Rem` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:70:20\n+   |\n+LL |         Foo(self.0 / other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `BitAnd` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:78:20\n+   |\n+LL |         Foo(self.0 | other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `BitOr` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:86:20\n+   |\n+LL |         Foo(self.0 ^ other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `BitXor` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:94:20\n+   |\n+LL |         Foo(self.0 & other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `Shl` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:102:20\n+   |\n+LL |         Foo(self.0 >> other.0)\n+   |                    ^^\n+\n+error: suspicious use of binary operator in `Shr` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:110:20\n+   |\n+LL |         Foo(self.0 << other.0)\n+   |                    ^^\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "eb8105c6b6da0f28a50ee521f4550e065a96de55", "filename": "src/tools/clippy/tests/ui/to_string_in_display.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,69 @@\n+#![warn(clippy::to_string_in_display)]\n+#![allow(clippy::inherent_to_string_shadow_display)]\n+\n+use std::fmt;\n+\n+struct A;\n+impl A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+trait B {\n+    fn fmt(&self) {}\n+}\n+\n+impl B for A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+fn fmt(a: A) {\n+    a.to_string();\n+}\n+\n+struct C;\n+\n+impl C {\n+    fn to_string(&self) -> String {\n+        String::from(\"I am C\")\n+    }\n+}\n+\n+impl fmt::Display for C {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+enum D {\n+    E(String),\n+    F,\n+}\n+\n+impl std::fmt::Display for D {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match &self {\n+            Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+            Self::F => write!(f, \"F\"),\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let a = A;\n+    a.to_string();\n+    a.fmt();\n+    fmt(a);\n+\n+    let c = C;\n+    c.to_string();\n+}"}, {"sha": "5f26ef413e239f331c60305fcab910173752b5ee", "filename": "src/tools/clippy/tests/ui/to_string_in_display.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,10 @@\n+error: using `to_string` in `fmt::Display` implementation might lead to infinite recursion\n+  --> $DIR/to_string_in_display.rs:25:25\n+   |\n+LL |         write!(f, \"{}\", self.to_string())\n+   |                         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::to-string-in-display` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "9f1948359e7d585d6d8ca2eacd26022d7330eeb8", "filename": "src/tools/clippy/tests/ui/transmute.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,3 +1,4 @@\n+#![feature(const_fn_transmute)]\n #![allow(dead_code)]\n \n extern crate core;\n@@ -81,9 +82,26 @@ fn int_to_bool() {\n }\n \n #[warn(clippy::transmute_int_to_float)]\n-fn int_to_float() {\n-    let _: f32 = unsafe { std::mem::transmute(0_u32) };\n-    let _: f32 = unsafe { std::mem::transmute(0_i32) };\n+mod int_to_float {\n+    fn test() {\n+        let _: f32 = unsafe { std::mem::transmute(0_u32) };\n+        let _: f32 = unsafe { std::mem::transmute(0_i32) };\n+        let _: f64 = unsafe { std::mem::transmute(0_u64) };\n+        let _: f64 = unsafe { std::mem::transmute(0_i64) };\n+    }\n+\n+    mod issue_5747 {\n+        const VALUE32: f32 = unsafe { std::mem::transmute(0_u32) };\n+        const VALUE64: f64 = unsafe { std::mem::transmute(0_i64) };\n+\n+        const fn from_bits_32(v: i32) -> f32 {\n+            unsafe { std::mem::transmute(v) }\n+        }\n+\n+        const fn from_bits_64(v: u64) -> f64 {\n+            unsafe { std::mem::transmute(v) }\n+        }\n+    }\n }\n \n fn bytes_to_str(b: &[u8], mb: &mut [u8]) {"}, {"sha": "ad9953d12bcc626fb93c7849d0e8b6957406c76b", "filename": "src/tools/clippy/tests/ui/transmute.stderr", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,146 +1,158 @@\n error: transmute from a type (`&T`) to itself\n-  --> $DIR/transmute.rs:19:20\n+  --> $DIR/transmute.rs:20:20\n    |\n LL |     let _: &'a T = core::intrinsics::transmute(t);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::useless-transmute` implied by `-D warnings`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmute.rs:23:23\n+  --> $DIR/transmute.rs:24:23\n    |\n LL |     let _: *const T = core::intrinsics::transmute(t);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `t as *const T`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmute.rs:25:21\n+  --> $DIR/transmute.rs:26:21\n    |\n LL |     let _: *mut T = core::intrinsics::transmute(t);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `t as *const T as *mut T`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmute.rs:27:23\n+  --> $DIR/transmute.rs:28:23\n    |\n LL |     let _: *const U = core::intrinsics::transmute(t);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `t as *const T as *const U`\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:33:27\n+  --> $DIR/transmute.rs:34:27\n    |\n LL |         let _: Vec<i32> = core::intrinsics::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:35:27\n+  --> $DIR/transmute.rs:36:27\n    |\n LL |         let _: Vec<i32> = core::mem::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:37:27\n+  --> $DIR/transmute.rs:38:27\n    |\n LL |         let _: Vec<i32> = std::intrinsics::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:39:27\n+  --> $DIR/transmute.rs:40:27\n    |\n LL |         let _: Vec<i32> = std::mem::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:41:27\n+  --> $DIR/transmute.rs:42:27\n    |\n LL |         let _: Vec<i32> = my_transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from an integer to a pointer\n-  --> $DIR/transmute.rs:43:31\n+  --> $DIR/transmute.rs:44:31\n    |\n LL |         let _: *const usize = std::mem::transmute(5_isize);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `5_isize as *const usize`\n \n error: transmute from an integer to a pointer\n-  --> $DIR/transmute.rs:47:31\n+  --> $DIR/transmute.rs:48:31\n    |\n LL |         let _: *const usize = std::mem::transmute(1 + 1usize);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(1 + 1usize) as *const usize`\n \n error: transmute from a type (`*const Usize`) to the type that it points to (`Usize`)\n-  --> $DIR/transmute.rs:62:24\n+  --> $DIR/transmute.rs:63:24\n    |\n LL |         let _: Usize = core::intrinsics::transmute(int_const_ptr);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::crosspointer-transmute` implied by `-D warnings`\n \n error: transmute from a type (`*mut Usize`) to the type that it points to (`Usize`)\n-  --> $DIR/transmute.rs:64:24\n+  --> $DIR/transmute.rs:65:24\n    |\n LL |         let _: Usize = core::intrinsics::transmute(int_mut_ptr);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`Usize`) to a pointer to that type (`*const Usize`)\n-  --> $DIR/transmute.rs:66:31\n+  --> $DIR/transmute.rs:67:31\n    |\n LL |         let _: *const Usize = core::intrinsics::transmute(my_int());\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`Usize`) to a pointer to that type (`*mut Usize`)\n-  --> $DIR/transmute.rs:68:29\n+  --> $DIR/transmute.rs:69:29\n    |\n LL |         let _: *mut Usize = core::intrinsics::transmute(my_int());\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a `u32` to a `char`\n-  --> $DIR/transmute.rs:74:28\n+  --> $DIR/transmute.rs:75:28\n    |\n LL |     let _: char = unsafe { std::mem::transmute(0_u32) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::char::from_u32(0_u32).unwrap()`\n    |\n    = note: `-D clippy::transmute-int-to-char` implied by `-D warnings`\n \n error: transmute from a `i32` to a `char`\n-  --> $DIR/transmute.rs:75:28\n+  --> $DIR/transmute.rs:76:28\n    |\n LL |     let _: char = unsafe { std::mem::transmute(0_i32) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::char::from_u32(0_i32 as u32).unwrap()`\n \n error: transmute from a `u8` to a `bool`\n-  --> $DIR/transmute.rs:80:28\n+  --> $DIR/transmute.rs:81:28\n    |\n LL |     let _: bool = unsafe { std::mem::transmute(0_u8) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `0_u8 != 0`\n    |\n    = note: `-D clippy::transmute-int-to-bool` implied by `-D warnings`\n \n error: transmute from a `u32` to a `f32`\n-  --> $DIR/transmute.rs:85:27\n+  --> $DIR/transmute.rs:87:31\n    |\n-LL |     let _: f32 = unsafe { std::mem::transmute(0_u32) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_u32)`\n+LL |         let _: f32 = unsafe { std::mem::transmute(0_u32) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_u32)`\n    |\n    = note: `-D clippy::transmute-int-to-float` implied by `-D warnings`\n \n error: transmute from a `i32` to a `f32`\n-  --> $DIR/transmute.rs:86:27\n+  --> $DIR/transmute.rs:88:31\n+   |\n+LL |         let _: f32 = unsafe { std::mem::transmute(0_i32) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_i32 as u32)`\n+\n+error: transmute from a `u64` to a `f64`\n+  --> $DIR/transmute.rs:89:31\n+   |\n+LL |         let _: f64 = unsafe { std::mem::transmute(0_u64) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f64::from_bits(0_u64)`\n+\n+error: transmute from a `i64` to a `f64`\n+  --> $DIR/transmute.rs:90:31\n    |\n-LL |     let _: f32 = unsafe { std::mem::transmute(0_i32) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_i32 as u32)`\n+LL |         let _: f64 = unsafe { std::mem::transmute(0_i64) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f64::from_bits(0_i64 as u64)`\n \n error: transmute from a `&[u8]` to a `&str`\n-  --> $DIR/transmute.rs:90:28\n+  --> $DIR/transmute.rs:108:28\n    |\n LL |     let _: &str = unsafe { std::mem::transmute(b) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8(b).unwrap()`\n    |\n    = note: `-D clippy::transmute-bytes-to-str` implied by `-D warnings`\n \n error: transmute from a `&mut [u8]` to a `&mut str`\n-  --> $DIR/transmute.rs:91:32\n+  --> $DIR/transmute.rs:109:32\n    |\n LL |     let _: &mut str = unsafe { std::mem::transmute(mb) };\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8_mut(mb).unwrap()`\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "1040fee4b34d00c3b2cff7c9106ac16338d8ade7", "filename": "src/tools/clippy/tests/ui/transmute_float_to_int.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_float_to_int.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,4 +1,5 @@\n-#[warn(clippy::transmute_float_to_int)]\n+#![feature(const_fn_transmute)]\n+#![warn(clippy::transmute_float_to_int)]\n \n fn float_to_int() {\n     let _: u32 = unsafe { std::mem::transmute(1f32) };\n@@ -9,4 +10,17 @@ fn float_to_int() {\n     let _: u64 = unsafe { std::mem::transmute(-1.0) };\n }\n \n+mod issue_5747 {\n+    const VALUE32: i32 = unsafe { std::mem::transmute(1f32) };\n+    const VALUE64: u64 = unsafe { std::mem::transmute(1f64) };\n+\n+    const fn to_bits_32(v: f32) -> u32 {\n+        unsafe { std::mem::transmute(v) }\n+    }\n+\n+    const fn to_bits_64(v: f64) -> i64 {\n+        unsafe { std::mem::transmute(v) }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "5a40cf381d6147ee464da4cdcbe0e72ab1e75721", "filename": "src/tools/clippy/tests/ui/transmute_float_to_int.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_float_to_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_float_to_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_float_to_int.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,37 +1,37 @@\n error: transmute from a `f32` to a `u32`\n-  --> $DIR/transmute_float_to_int.rs:4:27\n+  --> $DIR/transmute_float_to_int.rs:5:27\n    |\n LL |     let _: u32 = unsafe { std::mem::transmute(1f32) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f32.to_bits()`\n    |\n    = note: `-D clippy::transmute-float-to-int` implied by `-D warnings`\n \n error: transmute from a `f32` to a `i32`\n-  --> $DIR/transmute_float_to_int.rs:5:27\n+  --> $DIR/transmute_float_to_int.rs:6:27\n    |\n LL |     let _: i32 = unsafe { std::mem::transmute(1f32) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f32.to_bits() as i32`\n \n error: transmute from a `f64` to a `u64`\n-  --> $DIR/transmute_float_to_int.rs:6:27\n+  --> $DIR/transmute_float_to_int.rs:7:27\n    |\n LL |     let _: u64 = unsafe { std::mem::transmute(1f64) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f64.to_bits()`\n \n error: transmute from a `f64` to a `i64`\n-  --> $DIR/transmute_float_to_int.rs:7:27\n+  --> $DIR/transmute_float_to_int.rs:8:27\n    |\n LL |     let _: i64 = unsafe { std::mem::transmute(1f64) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f64.to_bits() as i64`\n \n error: transmute from a `f64` to a `u64`\n-  --> $DIR/transmute_float_to_int.rs:8:27\n+  --> $DIR/transmute_float_to_int.rs:9:27\n    |\n LL |     let _: u64 = unsafe { std::mem::transmute(1.0) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1.0f64.to_bits()`\n \n error: transmute from a `f64` to a `u64`\n-  --> $DIR/transmute_float_to_int.rs:9:27\n+  --> $DIR/transmute_float_to_int.rs:10:27\n    |\n LL |     let _: u64 = unsafe { std::mem::transmute(-1.0) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-1.0f64).to_bits()`"}, {"sha": "e7e0a31febc45919ca44408c7772a83cc162126c", "filename": "src/tools/clippy/tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -97,6 +97,24 @@ mod issue3992 {\n     pub fn c(d: &u16) {}\n }\n \n+mod issue5876 {\n+    // Don't lint here as it is always inlined\n+    #[inline(always)]\n+    fn foo_always(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+\n+    #[inline(never)]\n+    fn foo_never(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+\n+    #[inline]\n+    fn foo(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);"}, {"sha": "ccc3cdb2b74264fec42b9741312f627315ee906b", "filename": "src/tools/clippy/tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -94,5 +94,17 @@ error: this argument (N byte) is passed by reference, but would be more efficien\n LL |     fn trait_method2(&self, _color: &Color);\n    |                                     ^^^^^^ help: consider passing by value instead: `Color`\n \n-error: aborting due to 15 previous errors\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:108:21\n+   |\n+LL |     fn foo_never(x: &i32) {\n+   |                     ^^^^ help: consider passing by value instead: `i32`\n+\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:113:15\n+   |\n+LL |     fn foo(x: &i32) {\n+   |               ^^^^ help: consider passing by value instead: `i32`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "e785ac02feb320e4c4fb1c54e671a335a4a3d3fc", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -90,3 +90,21 @@ mod many_derefs {\n         let _ = &encoded.clone();\n     }\n }\n+\n+mod issue2076 {\n+    use std::rc::Rc;\n+\n+    macro_rules! try_opt {\n+        ($expr: expr) => {\n+            match $expr {\n+                Some(value) => value,\n+                None => return None,\n+            }\n+        };\n+    }\n+\n+    fn func() -> Option<Rc<u8>> {\n+        let rc = Rc::new(42);\n+        Some(try_opt!(Some(rc)).clone())\n+    }\n+}"}, {"sha": "5ffa6c4fd06167ce0c7e68545fef718f97c00418", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -96,5 +96,11 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |         let _ = &<&[u8]>::clone(encoded);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 11 previous errors\n+error: using `.clone()` on a ref-counted pointer\n+  --> $DIR/unnecessary_clone.rs:108:14\n+   |\n+LL |         Some(try_opt!(Some(rc)).clone())\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Rc::<u8>::clone(&try_opt!(Some(rc)))`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "fa66e68794e4be0d6b1ac082c2c9b2044b0e36bb", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval.fixed", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,117 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> usize {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_arr: [usize; 1] = [2];\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let nested_opt = Some(Some(42));\n+    let nested_tuple_opt = Some(Some((42, 43)));\n+\n+    // Should lint - Option\n+    let _ = opt.unwrap_or(2);\n+    let _ = opt.unwrap_or(astronomers_pi);\n+    let _ = opt.unwrap_or(ext_str.some_field);\n+    let _ = opt.unwrap_or(ext_arr[0]);\n+    let _ = opt.and(ext_opt);\n+    let _ = opt.or(ext_opt);\n+    let _ = opt.or(None);\n+    let _ = opt.get_or_insert(2);\n+    let _ = opt.ok_or(2);\n+    let _ = opt.ok_or(ext_arr[0]);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or(2);\n+    let _ = Some(10).and(ext_opt);\n+    let _: Option<usize> = None.or(ext_opt);\n+    let _ = None.get_or_insert(2);\n+    let _: Result<usize, usize> = None.ok_or(2);\n+    let _: Option<usize> = None.or(None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or(2);\n+    let _ = deep.0.and(ext_opt);\n+    let _ = deep.0.or(None);\n+    let _ = deep.0.get_or_insert(2);\n+    let _ = deep.0.ok_or(2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n+    let _ = Some(10).and_then(|idx| Some(idx));\n+    let _: Option<usize> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<usize, usize> = Err(5);\n+    let res2: Result<usize, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or(2);\n+    let _ = res2.unwrap_or(astronomers_pi);\n+    let _ = res2.unwrap_or(ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res.unwrap_or_else(|err| ext_arr[err]);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+    let _: Result<usize, usize> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "04f47d1aa2978f8afb54126b6d2cd97532f20521", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,117 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> usize {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_arr: [usize; 1] = [2];\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let nested_opt = Some(Some(42));\n+    let nested_tuple_opt = Some(Some((42, 43)));\n+\n+    // Should lint - Option\n+    let _ = opt.unwrap_or_else(|| 2);\n+    let _ = opt.unwrap_or_else(|| astronomers_pi);\n+    let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+    let _ = opt.unwrap_or_else(|| ext_arr[0]);\n+    let _ = opt.and_then(|_| ext_opt);\n+    let _ = opt.or_else(|| ext_opt);\n+    let _ = opt.or_else(|| None);\n+    let _ = opt.get_or_insert_with(|| 2);\n+    let _ = opt.ok_or_else(|| 2);\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or_else(|| 2);\n+    let _ = Some(10).and_then(|_| ext_opt);\n+    let _: Option<usize> = None.or_else(|| ext_opt);\n+    let _ = None.get_or_insert_with(|| 2);\n+    let _: Result<usize, usize> = None.ok_or_else(|| 2);\n+    let _: Option<usize> = None.or_else(|| None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or_else(|| 2);\n+    let _ = deep.0.and_then(|_| ext_opt);\n+    let _ = deep.0.or_else(|| None);\n+    let _ = deep.0.get_or_insert_with(|| 2);\n+    let _ = deep.0.ok_or_else(|| 2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n+    let _ = Some(10).and_then(|idx| Some(idx));\n+    let _: Option<usize> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<usize, usize> = Err(5);\n+    let res2: Result<usize, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or_else(|_| 2);\n+    let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+    let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res.unwrap_or_else(|err| ext_arr[err]);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+    let _: Result<usize, usize> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "5c1b2eb1f14e833bd7aecb01e58c78a7699641da", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval.stderr", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,148 @@\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:34:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n+   |\n+   = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:35:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:36:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:37:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_arr[0]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_arr[0])`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:38:13\n+   |\n+LL |     let _ = opt.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:39:13\n+   |\n+LL |     let _ = opt.or_else(|| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:40:13\n+   |\n+LL |     let _ = opt.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:41:13\n+   |\n+LL |     let _ = opt.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:42:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:43:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| ext_arr[0]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(ext_arr[0])`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:46:13\n+   |\n+LL |     let _ = Some(10).unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:47:13\n+   |\n+LL |     let _ = Some(10).and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:48:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:49:13\n+   |\n+LL |     let _ = None.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:50:35\n+   |\n+LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:51:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| None);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:54:13\n+   |\n+LL |     let _ = deep.0.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:55:13\n+   |\n+LL |     let _ = deep.0.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:56:13\n+   |\n+LL |     let _ = deep.0.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:57:13\n+   |\n+LL |     let _ = deep.0.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:58:13\n+   |\n+LL |     let _ = deep.0.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:84:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:85:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:86:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "2aa842adc85609690dfbc6f09875fb4b5541f338", "filename": "src/tools/clippy/tests/ui/unwrap_in_result.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_in_result.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::unwrap_in_result)]\n+\n+struct A;\n+\n+impl A {\n+    // should not be detected\n+    fn good_divisible_by_3(i_str: String) -> Result<bool, String> {\n+        // checks whether a string represents a number divisible by 3\n+        let i_result = i_str.parse::<i32>();\n+        match i_result {\n+            Err(_e) => Err(\"Not a number\".to_string()),\n+            Ok(i) => {\n+                if i % 3 == 0 {\n+                    return Ok(true);\n+                }\n+                Err(\"Number is not divisible by 3\".to_string())\n+            },\n+        }\n+    }\n+\n+    // should be detected\n+    fn bad_divisible_by_3(i_str: String) -> Result<bool, String> {\n+        // checks whether a string represents a number divisible by 3\n+        let i = i_str.parse::<i32>().unwrap();\n+        if i % 3 == 0 {\n+            Ok(true)\n+        } else {\n+            Err(\"Number is not divisible by 3\".to_string())\n+        }\n+    }\n+\n+    fn example_option_expect(i_str: String) -> Option<bool> {\n+        let i = i_str.parse::<i32>().expect(\"not a number\");\n+        if i % 3 == 0 {\n+            return Some(true);\n+        }\n+        None\n+    }\n+}\n+\n+fn main() {\n+    A::bad_divisible_by_3(\"3\".to_string());\n+    A::good_divisible_by_3(\"3\".to_string());\n+}"}, {"sha": "56bc2f2d1c00edfe1665a9b532e2edd4ab299d7c", "filename": "src/tools/clippy/tests/ui/unwrap_in_result.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_in_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_in_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_in_result.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -0,0 +1,41 @@\n+error: used unwrap or expect in a function that returns result or option\n+  --> $DIR/unwrap_in_result.rs:22:5\n+   |\n+LL | /     fn bad_divisible_by_3(i_str: String) -> Result<bool, String> {\n+LL | |         // checks whether a string represents a number divisible by 3\n+LL | |         let i = i_str.parse::<i32>().unwrap();\n+LL | |         if i % 3 == 0 {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::unwrap-in-result` implied by `-D warnings`\n+   = help: unwrap and expect should not be used in a function that returns result or option\n+note: potential non-recoverable error(s)\n+  --> $DIR/unwrap_in_result.rs:24:17\n+   |\n+LL |         let i = i_str.parse::<i32>().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: used unwrap or expect in a function that returns result or option\n+  --> $DIR/unwrap_in_result.rs:32:5\n+   |\n+LL | /     fn example_option_expect(i_str: String) -> Option<bool> {\n+LL | |         let i = i_str.parse::<i32>().expect(\"not a number\");\n+LL | |         if i % 3 == 0 {\n+LL | |             return Some(true);\n+LL | |         }\n+LL | |         None\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: unwrap and expect should not be used in a function that returns result or option\n+note: potential non-recoverable error(s)\n+  --> $DIR/unwrap_in_result.rs:33:17\n+   |\n+LL |         let i = i_str.parse::<i32>().expect(\"not a number\");\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8a9b0cd3cf019466d3786f7be3eb08ceda2f0509", "filename": "src/tools/clippy/tests/ui/useless_conversion.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -64,4 +64,9 @@ fn main() {\n     let _ = \"\".lines();\n     let _ = vec![1, 2, 3].into_iter();\n     let _: String = format!(\"Hello {}\", \"world\");\n+\n+    // keep parenthesis around `a + b` for suggestion (see #4750)\n+    let a: i32 = 1;\n+    let b: i32 = 1;\n+    let _ = (a + b) * 3;\n }"}, {"sha": "4faa1572973bc0ff5df24d3c2fe392e49d219c0d", "filename": "src/tools/clippy/tests/ui/useless_conversion.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -64,4 +64,9 @@ fn main() {\n     let _ = \"\".lines().into_iter();\n     let _ = vec![1, 2, 3].into_iter().into_iter();\n     let _: String = format!(\"Hello {}\", \"world\").into();\n+\n+    // keep parenthesis around `a + b` for suggestion (see #4750)\n+    let a: i32 = 1;\n+    let b: i32 = 1;\n+    let _ = i32::from(a + b) * 3;\n }"}, {"sha": "f1e880d2696c40c430e23e11f2a60aec52e5dc7f", "filename": "src/tools/clippy/tests/ui/useless_conversion.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -64,5 +64,11 @@ error: useless conversion to the same type\n LL |     let _: String = format!(\"Hello {}\", \"world\").into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `format!(\"Hello {}\", \"world\")`\n \n-error: aborting due to 10 previous errors\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion.rs:71:13\n+   |\n+LL |     let _ = i32::from(a + b) * 3;\n+   |             ^^^^^^^^^^^^^^^^ help: consider removing `i32::from()`: `(a + b)`\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "856771596202efb47f1c755759ccf60040133d00", "filename": "src/tools/clippy/tests/ui/vec.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -52,4 +52,11 @@ fn main() {\n     for a in vec![NonCopy, NonCopy] {\n         println!(\"{:?}\", a);\n     }\n+\n+    on_vec(&vec![1; 201]); // Ok, size of `vec` higher than `too_large_for_stack`\n+\n+    // Ok\n+    for a in vec![1; 201] {\n+        println!(\"{:?}\", a);\n+    }\n }"}, {"sha": "03b8ee816658ccefbebb278a89e278cc36945691", "filename": "src/tools/clippy/tests/ui/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -52,4 +52,11 @@ fn main() {\n     for a in vec![NonCopy, NonCopy] {\n         println!(\"{:?}\", a);\n     }\n+\n+    on_vec(&vec![1; 201]); // Ok, size of `vec` higher than `too_large_for_stack`\n+\n+    // Ok\n+    for a in vec![1; 201] {\n+        println!(\"{:?}\", a);\n+    }\n }"}, {"sha": "287f8935327c561f0dd7b8543597fbfe5095b9ae", "filename": "src/tools/clippy/tests/ui/wildcard_imports.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -20,6 +20,7 @@ use wildcard_imports_helper::inner::inner_for_self_import::inner_extern_bar;\n use wildcard_imports_helper::{ExternA, extern_foo};\n \n use std::io::prelude::*;\n+use wildcard_imports_helper::prelude::v1::*;\n \n struct ReadFoo;\n \n@@ -75,6 +76,7 @@ fn main() {\n     let _ = A;\n     let _ = inner_struct_mod::C;\n     let _ = ExternA;\n+    let _ = PreludeModAnywhere;\n \n     double_struct_import_test!();\n     double_struct_import_test!();"}, {"sha": "1f261159f4a94e2f32b2c44237e66e2ea62510d7", "filename": "src/tools/clippy/tests/ui/wildcard_imports.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -20,6 +20,7 @@ use wildcard_imports_helper::inner::inner_for_self_import::*;\n use wildcard_imports_helper::*;\n \n use std::io::prelude::*;\n+use wildcard_imports_helper::prelude::v1::*;\n \n struct ReadFoo;\n \n@@ -75,6 +76,7 @@ fn main() {\n     let _ = A;\n     let _ = inner_struct_mod::C;\n     let _ = ExternA;\n+    let _ = PreludeModAnywhere;\n \n     double_struct_import_test!();\n     double_struct_import_test!();"}, {"sha": "351988f31ead5b881c5086951cb42fc2e6af9b69", "filename": "src/tools/clippy/tests/ui/wildcard_imports.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -37,87 +37,87 @@ LL | use wildcard_imports_helper::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternA, extern_foo}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:89:13\n+  --> $DIR/wildcard_imports.rs:91:13\n    |\n LL |         use crate::fn_mod::*;\n    |             ^^^^^^^^^^^^^^^^ help: try: `crate::fn_mod::foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:95:75\n+  --> $DIR/wildcard_imports.rs:97:75\n    |\n LL |         use wildcard_imports_helper::inner::inner_for_self_import::{self, *};\n    |                                                                           ^ help: try: `inner_extern_foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:96:13\n+  --> $DIR/wildcard_imports.rs:98:13\n    |\n LL |         use wildcard_imports_helper::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternA, extern_foo}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:107:20\n+  --> $DIR/wildcard_imports.rs:109:20\n    |\n LL |         use self::{inner::*, inner2::*};\n    |                    ^^^^^^^^ help: try: `inner::inner_foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:107:30\n+  --> $DIR/wildcard_imports.rs:109:30\n    |\n LL |         use self::{inner::*, inner2::*};\n    |                              ^^^^^^^^^ help: try: `inner2::inner_bar`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:114:13\n+  --> $DIR/wildcard_imports.rs:116:13\n    |\n LL |         use wildcard_imports_helper::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternExportedEnum, ExternExportedStruct, extern_exported}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:143:9\n+  --> $DIR/wildcard_imports.rs:145:9\n    |\n LL |     use crate::in_fn_test::*;\n    |         ^^^^^^^^^^^^^^^^^^^^ help: try: `crate::in_fn_test::{ExportedEnum, ExportedStruct, exported}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:152:9\n+  --> $DIR/wildcard_imports.rs:154:9\n    |\n LL |     use crate:: in_fn_test::  * ;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `crate:: in_fn_test::exported`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:153:9\n+  --> $DIR/wildcard_imports.rs:155:9\n    |\n LL |       use crate:: fn_mod::\n    |  _________^\n LL | |         *;\n    | |_________^ help: try: `crate:: fn_mod::foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:164:13\n+  --> $DIR/wildcard_imports.rs:166:13\n    |\n LL |         use super::*;\n    |             ^^^^^^^^ help: try: `super::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:199:17\n+  --> $DIR/wildcard_imports.rs:201:17\n    |\n LL |             use super::*;\n    |                 ^^^^^^^^ help: try: `super::insidefoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:207:13\n+  --> $DIR/wildcard_imports.rs:209:13\n    |\n LL |         use super_imports::*;\n    |             ^^^^^^^^^^^^^^^^ help: try: `super_imports::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:216:17\n+  --> $DIR/wildcard_imports.rs:218:17\n    |\n LL |             use super::super::*;\n    |                 ^^^^^^^^^^^^^^^ help: try: `super::super::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:225:13\n+  --> $DIR/wildcard_imports.rs:227:13\n    |\n LL |         use super::super::super_imports::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `super::super::super_imports::foofoo`"}, {"sha": "f44305d7e483855614d8ce52a5ea3cb15bea0492", "filename": "src/tools/clippy/tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n #![warn(clippy::wrong_self_convention)]\n #![warn(clippy::wrong_pub_self_convention)]\n #![allow(dead_code)]\n@@ -75,3 +76,15 @@ mod issue4293 {\n         fn into_t3(self: Arc<T>) {}\n     }\n }\n+\n+// False positive for async (see #4037)\n+mod issue4037 {\n+    pub struct Foo;\n+    pub struct Bar;\n+\n+    impl Foo {\n+        pub async fn into_bar(self) -> Bar {\n+            Bar\n+        }\n+    }\n+}"}, {"sha": "ef3ad73ebc7c18cada8aaf7825cb843318343af3", "filename": "src/tools/clippy/tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc7351fb027494ede35d6d3abd7ca02a11c33ce/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr?ref=adc7351fb027494ede35d6d3abd7ca02a11c33ce", "patch": "@@ -1,73 +1,73 @@\n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:17:17\n+  --> $DIR/wrong_self_convention.rs:18:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:23:21\n+  --> $DIR/wrong_self_convention.rs:24:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:35:15\n+  --> $DIR/wrong_self_convention.rs:36:15\n    |\n LL |     fn as_i32(self) {}\n    |               ^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:37:17\n+  --> $DIR/wrong_self_convention.rs:38:17\n    |\n LL |     fn into_i32(&self) {}\n    |                 ^^^^^\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:39:15\n+  --> $DIR/wrong_self_convention.rs:40:15\n    |\n LL |     fn is_i32(self) {}\n    |               ^^^^\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:41:15\n+  --> $DIR/wrong_self_convention.rs:42:15\n    |\n LL |     fn to_i32(self) {}\n    |               ^^^^\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:43:17\n+  --> $DIR/wrong_self_convention.rs:44:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:45:19\n+  --> $DIR/wrong_self_convention.rs:46:19\n    |\n LL |     pub fn as_i64(self) {}\n    |                   ^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:46:21\n+  --> $DIR/wrong_self_convention.rs:47:21\n    |\n LL |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:47:19\n+  --> $DIR/wrong_self_convention.rs:48:19\n    |\n LL |     pub fn is_i64(self) {}\n    |                   ^^^^\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:48:19\n+  --> $DIR/wrong_self_convention.rs:49:19\n    |\n LL |     pub fn to_i64(self) {}\n    |                   ^^^^\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:49:21\n+  --> $DIR/wrong_self_convention.rs:50:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^"}]}