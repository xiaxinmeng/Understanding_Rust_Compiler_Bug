{"sha": "54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZWMwNGYxYzEyYzdmYjRkYmU1ZjAxZmRlYjczZDEwNzlmZWY1M2Q=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-14T10:04:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-16T02:45:00Z"}, "message": "Use the unsigned integer types for bitwise intrinsics.\n\nExposing ctpop, ctlz, cttz and bswap as taking signed i8/i16/... is just\nexposing the internal LLVM names pointlessly (LLVM doesn't have \"signed\nintegers\" or \"unsigned integers\", it just has sized integer types\nwith (un)signed *operations*).\n\nThese operations are semantically working with raw bytes, which the\nunsigned types model better.", "tree": {"sha": "efe91e930ac4527e3057fe65571df112ef5b8607", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efe91e930ac4527e3057fe65571df112ef5b8607"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "html_url": "https://github.com/rust-lang/rust/commit/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93dc55518840ee3cbd570c0d85aa7a445752af8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/93dc55518840ee3cbd570c0d85aa7a445752af8b", "html_url": "https://github.com/rust-lang/rust/commit/93dc55518840ee3cbd570c0d85aa7a445752af8b"}], "stats": {"total": 457, "additions": 238, "deletions": 219}, "files": [{"sha": "2e64b82a84a31d1e7e1fb4c319761878df134359", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -26,10 +26,10 @@ use super::{IoResult, retry, keep_going};\n #[cfg(unix)]    pub type sock_t = super::file::fd_t;\n \n pub fn htons(u: u16) -> u16 {\n-    mem::to_be16(u as i16) as u16\n+    mem::to_be16(u)\n }\n pub fn ntohs(u: u16) -> u16 {\n-    mem::from_be16(u as i16) as u16\n+    mem::from_be16(u)\n }\n \n enum InAddr {"}, {"sha": "cff8c149bb6ef8fbba88e229792bce95ef75ba0b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -4143,21 +4143,21 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"nearbyintf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"roundf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n             \"roundf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"ctpop8\"       => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n-            \"ctpop16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"ctpop32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"ctpop64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n-            \"ctlz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n-            \"ctlz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"ctlz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"ctlz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n-            \"cttz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n-            \"cttz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"cttz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"cttz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n-            \"bswap16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"bswap32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"bswap64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"ctpop8\"       => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n+            \"ctpop16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"ctpop32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"ctpop64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+            \"ctlz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n+            \"ctlz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"ctlz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"ctlz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+            \"cttz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n+            \"cttz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"cttz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"cttz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+            \"bswap16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"bswap32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"bswap64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n \n             \"volatile_load\" =>\n                 (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),"}, {"sha": "4571e6328cf24e056a1739b221e74af8a1cd9da7", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -20,23 +20,21 @@ use serialize::hex::ToHex;\n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n /// format.\n fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n     use std::mem::to_be32;\n     assert!(dst.len() == 4);\n     unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be32(input as i32);\n+        let x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n+        *x = to_be32(input);\n     }\n }\n \n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n     use std::mem::to_be32;\n     assert!(dst.len() * 4 == input.len());\n     unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        let mut x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n+        let mut y = input.unsafe_ref(0) as *_ as *u32;\n         for _ in range(0, dst.len()) {\n             *x = to_be32(*y);\n             x = x.offset(1);"}, {"sha": "280cd4bd592eef8795e41ea831a1c58f121fc8e4", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -32,8 +32,8 @@ use uvll;\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub fn htons(u: u16) -> u16 { mem::to_be16(u as i16) as u16 }\n-pub fn ntohs(u: u16) -> u16 { mem::from_be16(u as i16) as u16 }\n+pub fn htons(u: u16) -> u16 { mem::to_be16(u) }\n+pub fn ntohs(u: u16) -> u16 { mem::from_be16(u) }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n                         len: uint) -> ip::SocketAddr {"}, {"sha": "0efa93011fc6687bf921986f636a46becd508613", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -179,8 +179,8 @@ pub mod reader {\n         ];\n \n         unsafe {\n-            let ptr = data.as_ptr().offset(start as int) as *i32;\n-            let val = from_be32(*ptr) as u32;\n+            let ptr = data.as_ptr().offset(start as int) as *u32;\n+            let val = from_be32(*ptr);\n \n             let i = (val >> 28u) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];"}, {"sha": "175c7fe57b319c9cd0e7fa43edf084fd7be0b8c9", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -394,26 +394,50 @@ extern \"rust-intrinsic\" {\n \n     pub fn roundf32(x: f32) -> f32;\n     pub fn roundf64(x: f64) -> f64;\n+}\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    pub fn ctpop8(x: u8) -> u8;\n+    pub fn ctpop16(x: u16) -> u16;\n+    pub fn ctpop32(x: u32) -> u32;\n+    pub fn ctpop64(x: u64) -> u64;\n+\n+    pub fn ctlz8(x: u8) -> u8;\n+    pub fn ctlz16(x: u16) -> u16;\n+    pub fn ctlz32(x: u32) -> u32;\n+    pub fn ctlz64(x: u64) -> u64;\n+\n+    pub fn cttz8(x: u8) -> u8;\n+    pub fn cttz16(x: u16) -> u16;\n+    pub fn cttz32(x: u32) -> u32;\n+    pub fn cttz64(x: u64) -> u64;\n+\n+    pub fn bswap16(x: u16) -> u16;\n+    pub fn bswap32(x: u32) -> u32;\n+    pub fn bswap64(x: u64) -> u64;\n+}\n \n-    pub fn ctpop8(x: i8) -> i8;\n-    pub fn ctpop16(x: i16) -> i16;\n-    pub fn ctpop32(x: i32) -> i32;\n-    pub fn ctpop64(x: i64) -> i64;\n-\n-    pub fn ctlz8(x: i8) -> i8;\n-    pub fn ctlz16(x: i16) -> i16;\n-    pub fn ctlz32(x: i32) -> i32;\n-    pub fn ctlz64(x: i64) -> i64;\n-\n-    pub fn cttz8(x: i8) -> i8;\n-    pub fn cttz16(x: i16) -> i16;\n-    pub fn cttz32(x: i32) -> i32;\n-    pub fn cttz64(x: i64) -> i64;\n-\n-    pub fn bswap16(x: i16) -> i16;\n-    pub fn bswap32(x: i32) -> i32;\n-    pub fn bswap64(x: i64) -> i64;\n+// NOTE: remove this after a snap, and merge the extern block above\n+macro_rules! stage0_hack {\n+    ($( $u_ty:ty, $i_ty:ty => $($name:ident),*);*) => {\n+        $(\n+            $(\n+                #[cfg(stage0)]\n+                pub unsafe fn $name(x: $u_ty) -> $u_ty {\n+                    extern \"rust-intrinsic\" { fn $name(x: $i_ty) -> $i_ty; }\n+                    $name(x as $i_ty) as $u_ty\n+                }\n+            )*)*\n+    }\n+}\n+stage0_hack! {\n+    u8, i8 => ctpop8, ctlz8, cttz8;\n+    u16, i16 => ctpop16, ctlz16, cttz16, bswap16;\n+    u32, i32 => ctpop32, ctlz32, cttz32, bswap32;\n+    u64, i64 => ctpop64, ctlz64, cttz64, bswap64\n+}\n \n+extern \"rust-intrinsic\" {\n     pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);\n     pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);\n     pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);"}, {"sha": "d8022b1e26c6d48df5040711d33d5d82ee8a77d6", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -83,9 +83,9 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<i16, [u8, ..2]>(to_le16(n as i16)) }),\n-      4u => f(unsafe { transmute::<i32, [u8, ..4]>(to_le32(n as i32)) }),\n-      8u => f(unsafe { transmute::<i64, [u8, ..8]>(to_le64(n as i64)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_le16(n as u16)) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_le32(n as u32)) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_le64(n)) }),\n       _ => {\n \n         let mut bytes = vec!();\n@@ -123,9 +123,9 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<i16, [u8, ..2]>(to_be16(n as i16)) }),\n-      4u => f(unsafe { transmute::<i32, [u8, ..4]>(to_be32(n as i32)) }),\n-      8u => f(unsafe { transmute::<i64, [u8, ..8]>(to_be64(n as i64)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_be16(n as u16)) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_be32(n as u32)) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_be64(n)) }),\n       _ => {\n         let mut bytes = vec!();\n         let mut i = size;\n@@ -166,7 +166,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n         let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n         copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n-        from_be64(*(out as *i64)) as u64\n+        from_be64(*(out as *u64))\n     }\n }\n "}, {"sha": "282cfe517823bd9e2077b3756b713836527bcf14", "filename": "src/libstd/mem.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -99,128 +99,128 @@ pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n     intrinsics::move_val_init(dst, src)\n }\n \n-/// Convert an i16 to little endian from the target's endianness.\n+/// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_le16(x: u16) -> u16 { x }\n \n-/// Convert an i16 to little endian from the target's endianness.\n+/// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i32 to little endian from the target's endianness.\n+/// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_le32(x: u32) -> u32 { x }\n \n-/// Convert an i32 to little endian from the target's endianness.\n+/// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i64 to little endian from the target's endianness.\n+/// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_le64(x: u64) -> u64 { x }\n \n-/// Convert an i64 to little endian from the target's endianness.\n+/// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n \n-/// Convert an i16 to big endian from the target's endianness.\n+/// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i16 to big endian from the target's endianness.\n+/// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be16(x: u16) -> u16 { x }\n \n-/// Convert an i32 to big endian from the target's endianness.\n+/// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i32 to big endian from the target's endianness.\n+/// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be32(x: u32) -> u32 { x }\n \n-/// Convert an i64 to big endian from the target's endianness.\n+/// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n-/// Convert an i64 to big endian from the target's endianness.\n+/// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be64(x: u64) -> u64 { x }\n \n \n-/// Convert an i16 from little endian to the target's endianness.\n+/// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_le16(x: u16) -> u16 { x }\n \n-/// Convert an i16 from little endian to the target's endianness.\n+/// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i32 from little endian to the target's endianness.\n+/// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_le32(x: u32) -> u32 { x }\n \n-/// Convert an i32 from little endian to the target's endianness.\n+/// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i64 from little endian to the target's endianness.\n+/// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_le64(x: u64) -> u64 { x }\n \n-/// Convert an i64 from little endian to the target's endianness.\n+/// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n \n-/// Convert an i16 from big endian to the target's endianness.\n+/// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i16 from big endian to the target's endianness.\n+/// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be16(x: u16) -> u16 { x }\n \n-/// Convert an i32 from big endian to the target's endianness.\n+/// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i32 from big endian to the target's endianness.\n+/// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be32(x: u32) -> u32 { x }\n \n-/// Convert an i64 from big endian to the target's endianness.\n+/// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n-/// Convert an i64 from big endian to the target's endianness.\n+/// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be64(x: u64) -> u64 { x }\n \n \n /**"}, {"sha": "79827421f9222c37c743c302752c26eb2d3264fc", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -28,17 +28,17 @@ int_module!(i16, 16)\n impl Bitwise for i16 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n+    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n+    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n \n     /// Returns the number of trailing zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n+    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n }\n \n impl CheckedAdd for i16 {"}, {"sha": "97f03299b8765374016d878474c9e48bccc6228c", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -28,17 +28,17 @@ int_module!(i32, 32)\n impl Bitwise for i32 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n+    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n+    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n \n     /// Returns the number of trailing zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n+    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n }\n \n impl CheckedAdd for i32 {"}, {"sha": "00823aa22c28ec8d6139609b2b585bc4d50cd376", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -30,16 +30,16 @@ int_module!(i64, 64)\n impl Bitwise for i64 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n+    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n+    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n \n     /// Counts the number of trailing zeros.\n     #[inline]\n-    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n+    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n }\n \n impl CheckedAdd for i64 {"}, {"sha": "2d349fa7f4f1da240fd750de8a1d96a8f93bddc1", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -28,17 +28,17 @@ int_module!(i8, 8)\n impl Bitwise for i8 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n+    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n+    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n \n     /// Returns the number of trailing zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n+    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n }\n \n impl CheckedAdd for i8 {"}, {"sha": "559edd587fd7e0e18283fc350bc6e66b6f4063fc", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -220,9 +220,9 @@ impl Uuid {\n                 data4: [0, ..8]\n         };\n \n-        fields.data1 = to_be32(d1 as i32) as u32;\n-        fields.data2 = to_be16(d2 as i16) as u16;\n-        fields.data3 = to_be16(d3 as i16) as u16;\n+        fields.data1 = to_be32(d1);\n+        fields.data2 = to_be16(d2);\n+        fields.data3 = to_be16(d3);\n         slice::bytes::copy_memory(fields.data4, d4);\n \n         unsafe {\n@@ -343,9 +343,9 @@ impl Uuid {\n         unsafe {\n             uf = transmute_copy(&self.bytes);\n         }\n-        uf.data1 = to_be32(uf.data1 as i32) as u32;\n-        uf.data2 = to_be16(uf.data2 as i16) as u16;\n-        uf.data3 = to_be16(uf.data3 as i16) as u16;\n+        uf.data1 = to_be32(uf.data1);\n+        uf.data2 = to_be16(uf.data2);\n+        uf.data3 = to_be16(uf.data3);\n         let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n                          {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n             uf.data1,"}, {"sha": "f5724fc1324d5725ea3e5653711c59e49eca35f2", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -16,7 +16,7 @@ use std::io;\n use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n use std::os;\n-use std::intrinsics::cttz16;\n+use std::num::Bitwise;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -187,9 +187,7 @@ impl Colors {\n         if (0u16 == val) {\n             return 0u8;\n         } else {\n-            unsafe {\n-                return cttz16(val as i16) as u8;\n-            }\n+            return val.trailing_zeros() as u8\n         }\n     }\n "}, {"sha": "e31b941f956eb6893f2a36fc06ab3235aad1531d", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 96, "deletions": 97, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=54ec04f1c12c7fb4dbe5f01fdeb73d1079fef53d", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -13,108 +12,108 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn ctpop8(x: i8) -> i8;\n-        pub fn ctpop16(x: i16) -> i16;\n-        pub fn ctpop32(x: i32) -> i32;\n-        pub fn ctpop64(x: i64) -> i64;\n-\n-        pub fn ctlz8(x: i8) -> i8;\n-        pub fn ctlz16(x: i16) -> i16;\n-        pub fn ctlz32(x: i32) -> i32;\n-        pub fn ctlz64(x: i64) -> i64;\n-\n-        pub fn cttz8(x: i8) -> i8;\n-        pub fn cttz16(x: i16) -> i16;\n-        pub fn cttz32(x: i32) -> i32;\n-        pub fn cttz64(x: i64) -> i64;\n-\n-        pub fn bswap16(x: i16) -> i16;\n-        pub fn bswap32(x: i32) -> i32;\n-        pub fn bswap64(x: i64) -> i64;\n+        pub fn ctpop8(x: u8) -> u8;\n+        pub fn ctpop16(x: u16) -> u16;\n+        pub fn ctpop32(x: u32) -> u32;\n+        pub fn ctpop64(x: u64) -> u64;\n+\n+        pub fn ctlz8(x: u8) -> u8;\n+        pub fn ctlz16(x: u16) -> u16;\n+        pub fn ctlz32(x: u32) -> u32;\n+        pub fn ctlz64(x: u64) -> u64;\n+\n+        pub fn cttz8(x: u8) -> u8;\n+        pub fn cttz16(x: u16) -> u16;\n+        pub fn cttz32(x: u32) -> u32;\n+        pub fn cttz64(x: u64) -> u64;\n+\n+        pub fn bswap16(x: u16) -> u16;\n+        pub fn bswap32(x: u32) -> u32;\n+        pub fn bswap64(x: u64) -> u64;\n     }\n }\n \n pub fn main() {\n     unsafe {\n         use rusti::*;\n \n-        assert_eq!(ctpop8(0i8), 0i8);\n-        assert_eq!(ctpop16(0i16), 0i16);\n-        assert_eq!(ctpop32(0i32), 0i32);\n-        assert_eq!(ctpop64(0i64), 0i64);\n-\n-        assert_eq!(ctpop8(1i8), 1i8);\n-        assert_eq!(ctpop16(1i16), 1i16);\n-        assert_eq!(ctpop32(1i32), 1i32);\n-        assert_eq!(ctpop64(1i64), 1i64);\n-\n-        assert_eq!(ctpop8(10i8), 2i8);\n-        assert_eq!(ctpop16(10i16), 2i16);\n-        assert_eq!(ctpop32(10i32), 2i32);\n-        assert_eq!(ctpop64(10i64), 2i64);\n-\n-        assert_eq!(ctpop8(100i8), 3i8);\n-        assert_eq!(ctpop16(100i16), 3i16);\n-        assert_eq!(ctpop32(100i32), 3i32);\n-        assert_eq!(ctpop64(100i64), 3i64);\n-\n-        assert_eq!(ctpop8(-1i8), 8i8);\n-        assert_eq!(ctpop16(-1i16), 16i16);\n-        assert_eq!(ctpop32(-1i32), 32i32);\n-        assert_eq!(ctpop64(-1i64), 64i64);\n-\n-        assert_eq!(ctlz8(0i8), 8i8);\n-        assert_eq!(ctlz16(0i16), 16i16);\n-        assert_eq!(ctlz32(0i32), 32i32);\n-        assert_eq!(ctlz64(0i64), 64i64);\n-\n-        assert_eq!(ctlz8(1i8), 7i8);\n-        assert_eq!(ctlz16(1i16), 15i16);\n-        assert_eq!(ctlz32(1i32), 31i32);\n-        assert_eq!(ctlz64(1i64), 63i64);\n-\n-        assert_eq!(ctlz8(10i8), 4i8);\n-        assert_eq!(ctlz16(10i16), 12i16);\n-        assert_eq!(ctlz32(10i32), 28i32);\n-        assert_eq!(ctlz64(10i64), 60i64);\n-\n-        assert_eq!(ctlz8(100i8), 1i8);\n-        assert_eq!(ctlz16(100i16), 9i16);\n-        assert_eq!(ctlz32(100i32), 25i32);\n-        assert_eq!(ctlz64(100i64), 57i64);\n-\n-        assert_eq!(cttz8(-1i8), 0i8);\n-        assert_eq!(cttz16(-1i16), 0i16);\n-        assert_eq!(cttz32(-1i32), 0i32);\n-        assert_eq!(cttz64(-1i64), 0i64);\n-\n-        assert_eq!(cttz8(0i8), 8i8);\n-        assert_eq!(cttz16(0i16), 16i16);\n-        assert_eq!(cttz32(0i32), 32i32);\n-        assert_eq!(cttz64(0i64), 64i64);\n-\n-        assert_eq!(cttz8(1i8), 0i8);\n-        assert_eq!(cttz16(1i16), 0i16);\n-        assert_eq!(cttz32(1i32), 0i32);\n-        assert_eq!(cttz64(1i64), 0i64);\n-\n-        assert_eq!(cttz8(10i8), 1i8);\n-        assert_eq!(cttz16(10i16), 1i16);\n-        assert_eq!(cttz32(10i32), 1i32);\n-        assert_eq!(cttz64(10i64), 1i64);\n-\n-        assert_eq!(cttz8(100i8), 2i8);\n-        assert_eq!(cttz16(100i16), 2i16);\n-        assert_eq!(cttz32(100i32), 2i32);\n-        assert_eq!(cttz64(100i64), 2i64);\n-\n-        assert_eq!(cttz8(-1i8), 0i8);\n-        assert_eq!(cttz16(-1i16), 0i16);\n-        assert_eq!(cttz32(-1i32), 0i32);\n-        assert_eq!(cttz64(-1i64), 0i64);\n-\n-        assert_eq!(bswap16(0x0A0Bi16), 0x0B0Ai16);\n-        assert_eq!(bswap32(0x0ABBCC0Di32), 0x0DCCBB0Ai32);\n-        assert_eq!(bswap64(0x0122334455667708i64), 0x0877665544332201i64);\n+        assert_eq!(ctpop8(0u8), 0u8);\n+        assert_eq!(ctpop16(0u16), 0u16);\n+        assert_eq!(ctpop32(0u32), 0u32);\n+        assert_eq!(ctpop64(0u64), 0u64);\n+\n+        assert_eq!(ctpop8(1u8), 1u8);\n+        assert_eq!(ctpop16(1u16), 1u16);\n+        assert_eq!(ctpop32(1u32), 1u32);\n+        assert_eq!(ctpop64(1u64), 1u64);\n+\n+        assert_eq!(ctpop8(10u8), 2u8);\n+        assert_eq!(ctpop16(10u16), 2u16);\n+        assert_eq!(ctpop32(10u32), 2u32);\n+        assert_eq!(ctpop64(10u64), 2u64);\n+\n+        assert_eq!(ctpop8(100u8), 3u8);\n+        assert_eq!(ctpop16(100u16), 3u16);\n+        assert_eq!(ctpop32(100u32), 3u32);\n+        assert_eq!(ctpop64(100u64), 3u64);\n+\n+        assert_eq!(ctpop8(-1u8), 8u8);\n+        assert_eq!(ctpop16(-1u16), 16u16);\n+        assert_eq!(ctpop32(-1u32), 32u32);\n+        assert_eq!(ctpop64(-1u64), 64u64);\n+\n+        assert_eq!(ctlz8(0u8), 8u8);\n+        assert_eq!(ctlz16(0u16), 16u16);\n+        assert_eq!(ctlz32(0u32), 32u32);\n+        assert_eq!(ctlz64(0u64), 64u64);\n+\n+        assert_eq!(ctlz8(1u8), 7u8);\n+        assert_eq!(ctlz16(1u16), 15u16);\n+        assert_eq!(ctlz32(1u32), 31u32);\n+        assert_eq!(ctlz64(1u64), 63u64);\n+\n+        assert_eq!(ctlz8(10u8), 4u8);\n+        assert_eq!(ctlz16(10u16), 12u16);\n+        assert_eq!(ctlz32(10u32), 28u32);\n+        assert_eq!(ctlz64(10u64), 60u64);\n+\n+        assert_eq!(ctlz8(100u8), 1u8);\n+        assert_eq!(ctlz16(100u16), 9u16);\n+        assert_eq!(ctlz32(100u32), 25u32);\n+        assert_eq!(ctlz64(100u64), 57u64);\n+\n+        assert_eq!(cttz8(-1u8), 0u8);\n+        assert_eq!(cttz16(-1u16), 0u16);\n+        assert_eq!(cttz32(-1u32), 0u32);\n+        assert_eq!(cttz64(-1u64), 0u64);\n+\n+        assert_eq!(cttz8(0u8), 8u8);\n+        assert_eq!(cttz16(0u16), 16u16);\n+        assert_eq!(cttz32(0u32), 32u32);\n+        assert_eq!(cttz64(0u64), 64u64);\n+\n+        assert_eq!(cttz8(1u8), 0u8);\n+        assert_eq!(cttz16(1u16), 0u16);\n+        assert_eq!(cttz32(1u32), 0u32);\n+        assert_eq!(cttz64(1u64), 0u64);\n+\n+        assert_eq!(cttz8(10u8), 1u8);\n+        assert_eq!(cttz16(10u16), 1u16);\n+        assert_eq!(cttz32(10u32), 1u32);\n+        assert_eq!(cttz64(10u64), 1u64);\n+\n+        assert_eq!(cttz8(100u8), 2u8);\n+        assert_eq!(cttz16(100u16), 2u16);\n+        assert_eq!(cttz32(100u32), 2u32);\n+        assert_eq!(cttz64(100u64), 2u64);\n+\n+        assert_eq!(cttz8(-1u8), 0u8);\n+        assert_eq!(cttz16(-1u16), 0u16);\n+        assert_eq!(cttz32(-1u32), 0u32);\n+        assert_eq!(cttz64(-1u64), 0u64);\n+\n+        assert_eq!(bswap16(0x0A0Bu16), 0x0B0Au16);\n+        assert_eq!(bswap32(0x0ABBCC0Du32), 0x0DCCBB0Au32);\n+        assert_eq!(bswap64(0x0122334455667708u64), 0x0877665544332201u64);\n     }\n }"}]}