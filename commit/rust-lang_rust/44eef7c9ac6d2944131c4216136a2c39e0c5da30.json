{"sha": "44eef7c9ac6d2944131c4216136a2c39e0c5da30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZWVmN2M5YWM2ZDI5NDQxMzFjNDIxNjEzNmEyYzM5ZTBjNWRhMzA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-10T14:15:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:28Z"}, "message": "rustc: do not inject discriminant fields into Layout::General's variants.", "tree": {"sha": "d1f28b28fda764097267bca70700a4f09889d5a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1f28b28fda764097267bca70700a4f09889d5a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44eef7c9ac6d2944131c4216136a2c39e0c5da30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44eef7c9ac6d2944131c4216136a2c39e0c5da30", "html_url": "https://github.com/rust-lang/rust/commit/44eef7c9ac6d2944131c4216136a2c39e0c5da30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44eef7c9ac6d2944131c4216136a2c39e0c5da30/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8afa3a01e61906459a25d305176137e14ba3f835", "url": "https://api.github.com/repos/rust-lang/rust/commits/8afa3a01e61906459a25d305176137e14ba3f835", "html_url": "https://github.com/rust-lang/rust/commit/8afa3a01e61906459a25d305176137e14ba3f835"}], "stats": {"total": 159, "additions": 70, "deletions": 89}, "files": [{"sha": "4fea7ee082c0012776601758c31efd3c71214e5d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 35, "deletions": 47, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -651,14 +651,14 @@ pub struct Struct {\n }\n \n /// Info required to optimize struct layout.\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+#[derive(Copy, Clone, Debug)]\n enum StructKind {\n     /// A tuple, closure, or univariant which cannot be coerced to unsized.\n     AlwaysSizedUnivariant,\n     /// A univariant, the last field of which may be coerced to unsized.\n     MaybeUnsizedUnivariant,\n     /// A univariant, but part of an enum.\n-    EnumVariant,\n+    EnumVariant(Integer),\n }\n \n impl<'a, 'tcx> Struct {\n@@ -692,30 +692,27 @@ impl<'a, 'tcx> Struct {\n         // Neither do  1-member and 2-member structs.\n         // In addition, code in trans assume that 2-element structs can become pairs.\n         // It's easier to just short-circuit here.\n-        let can_optimize = (fields.len() > 2 || StructKind::EnumVariant == kind)\n-            && (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n-\n-        let (optimize, sort_ascending) = match kind {\n-            StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n-            StructKind::MaybeUnsizedUnivariant => (can_optimize, false),\n-            StructKind::EnumVariant => {\n-                assert!(fields.len() >= 1, \"Enum variants must have discriminants.\");\n-                (can_optimize && fields[0].size(dl).bytes() == 1, true)\n+        let (mut optimize, sort_ascending) = match kind {\n+            StructKind::AlwaysSizedUnivariant |\n+            StructKind::MaybeUnsizedUnivariant => (fields.len() > 2, false),\n+            StructKind::EnumVariant(discr) => {\n+                (discr.size().bytes() == 1, true)\n             }\n         };\n \n+        optimize &= (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n+\n         ret.offsets = vec![Size::from_bytes(0); fields.len()];\n         let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n         if optimize {\n-            let start = if let StructKind::EnumVariant = kind { 1 } else { 0 };\n             let end = if let StructKind::MaybeUnsizedUnivariant = kind {\n                 fields.len() - 1\n             } else {\n                 fields.len()\n             };\n-            if end > start {\n-                let optimizing  = &mut inverse_memory_index[start..end];\n+            if end > 0 {\n+                let optimizing  = &mut inverse_memory_index[..end];\n                 if sort_ascending {\n                     optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n                 } else {\n@@ -734,13 +731,17 @@ impl<'a, 'tcx> Struct {\n         // field 5 with offset 0 puts 0 in offsets[5].\n         // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n-        if let StructKind::EnumVariant = kind {\n-            assert_eq!(inverse_memory_index[0], 0,\n-              \"Enum variant discriminants must have the lowest offset.\");\n-        }\n-\n         let mut offset = Size::from_bytes(0);\n \n+        if let StructKind::EnumVariant(discr) = kind {\n+            offset = discr.size();\n+            if !ret.packed {\n+                let align = discr.align(dl);\n+                ret.align = ret.align.max(align);\n+                ret.primitive_align = ret.primitive_align.max(align);\n+            }\n+        }\n+\n         for i in inverse_memory_index.iter() {\n             let field = fields[*i as usize];\n             if !ret.sized {\n@@ -1112,8 +1113,9 @@ pub enum Layout {\n         variants: Union,\n     },\n \n-    /// General-case enums: for each case there is a struct, and they\n-    /// all start with a field for the discriminant.\n+    /// General-case enums: for each case there is a struct, and they all have\n+    /// all space reserved for the discriminant, and their first field starts\n+    /// at a non-0 offset, after where the discriminant would go.\n     General {\n         discr: Integer,\n         variants: Vec<Struct>,\n@@ -1495,21 +1497,17 @@ impl<'a, 'tcx> Layout {\n                 // We're interested in the smallest alignment, so start large.\n                 let mut start_align = Align::from_bytes(256, 256).unwrap();\n \n-                // Create the set of structs that represent each variant\n-                // Use the minimum integer type we figured out above\n-                let discr = Scalar { value: Int(min_ity), non_zero: false };\n+                // Create the set of structs that represent each variant.\n                 let mut variants = variants.into_iter().map(|fields| {\n-                    let mut fields = fields.into_iter().map(|field| {\n+                    let fields = fields.into_iter().map(|field| {\n                         field.layout(tcx, param_env)\n                     }).collect::<Result<Vec<_>, _>>()?;\n-                    fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n                         &fields,\n-                        &def.repr, StructKind::EnumVariant, ty)?;\n+                        &def.repr, StructKind::EnumVariant(min_ity), ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n-                    // It is important to skip the first field.\n-                    for i in st.field_index_by_increasing_offset().skip(1) {\n+                    for i in st.field_index_by_increasing_offset() {\n                         let field = fields[i];\n                         let field_align = field.align(dl);\n                         if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n@@ -1569,9 +1567,8 @@ impl<'a, 'tcx> Layout {\n                     let new_ity_size = Int(ity).size(dl);\n                     for variant in &mut variants {\n                         for i in variant.offsets.iter_mut() {\n-                            // The first field is the discrimminant, at offset 0.\n-                            // These aren't in order, and we need to skip it.\n-                            if *i <= old_ity_size && *i > Size::from_bytes(0) {\n+                            if *i <= old_ity_size {\n+                                assert_eq!(*i, old_ity_size);\n                                 *i = new_ity_size;\n                             }\n                         }\n@@ -1759,7 +1756,7 @@ impl<'a, 'tcx> Layout {\n \n             General { ref variants, .. } => {\n                 let v = variant_index.expect(\"variant index required\");\n-                variants[v].offsets[i + 1]\n+                variants[v].offsets[i]\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n@@ -1857,21 +1854,12 @@ impl<'a, 'tcx> Layout {\n             }\n         };\n \n-        enum Fields<'a> {\n-            WithDiscrim(&'a Struct),\n-            NoDiscrim(&'a Struct),\n-        }\n-\n         let build_variant_info = |n: Option<ast::Name>,\n                                   flds: &[(ast::Name, Ty<'tcx>)],\n-                                  layout: Fields| {\n-            let (s, field_offsets) = match layout {\n-                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n-                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n-            };\n+                                  s: &Struct| {\n             let field_info: Vec<_> =\n                 flds.iter()\n-                    .zip(field_offsets.iter())\n+                    .zip(&s.offsets)\n                     .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n                     .collect();\n \n@@ -1904,7 +1892,7 @@ impl<'a, 'tcx> Layout {\n                        None,\n                        vec![build_variant_info(Some(variant_def.name),\n                                                &fields,\n-                                               Fields::NoDiscrim(variant_layout))]);\n+                                               variant_layout)]);\n             }\n             Layout::RawNullablePointer { nndiscr, value } => {\n                 debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n@@ -1931,7 +1919,7 @@ impl<'a, 'tcx> Layout {\n                            None,\n                            vec![build_variant_info(Some(variant_def.name),\n                                                    &fields,\n-                                                   Fields::NoDiscrim(variant_layout))]);\n+                                                   variant_layout)]);\n                 } else {\n                     // (This case arises for *empty* enums; so give it\n                     // zero variants.)\n@@ -1953,7 +1941,7 @@ impl<'a, 'tcx> Layout {\n                                                        .collect();\n                                         build_variant_info(Some(variant_def.name),\n                                                            &fields,\n-                                                           Fields::WithDiscrim(variant_layout))\n+                                                           variant_layout)\n                                     })\n                                     .collect();\n                 record(adt_kind.into(), Some(discr.size()), variant_infos);"}, {"sha": "9c492ca52d2a3a7a33db5388cb524d2612282178", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -90,8 +90,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (l.for_variant(nndiscr as usize), nonnull),\n                 _ => unreachable!()\n             };\n-            llty.set_struct_body(&struct_llfields(cx, variant_layout, variant, None),\n-                                 variant.packed)\n+            llty.set_struct_body(&struct_llfields(cx, variant_layout, variant), variant.packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n     }\n@@ -116,7 +115,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match name {\n                 None => {\n                     Type::struct_(cx, &struct_llfields(cx, l.for_variant(nndiscr as usize),\n-                                                       nonnull, None),\n+                                                       nonnull),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n@@ -127,7 +126,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         layout::Univariant { ref variant, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, l, &variant, None),\n+                    Type::struct_(cx, &struct_llfields(cx, l, &variant),\n                                   variant.packed)\n                 }\n                 Some(name) => {\n@@ -209,23 +208,16 @@ pub fn memory_index_to_gep(index: u64) -> u64 {\n \n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  layout: TyLayout<'tcx>,\n-                                 variant: &layout::Struct,\n-                                 discr: Option<Ty<'tcx>>) -> Vec<Type> {\n-    let field_count = (discr.is_some() as usize) + layout.field_count();\n+                                 variant: &layout::Struct) -> Vec<Type> {\n+    let field_count = layout.field_count();\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n-    let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n-        let ty = if i == 0 && discr.is_some() {\n-            cx.layout_of(discr.unwrap())\n-        } else {\n-            layout.field(cx, i - discr.is_some() as usize)\n-        };\n-        (i, ty, variant.offsets[i as usize])\n-    });\n-    for (index, field, target_offset) in field_iter {\n+    for i in variant.field_index_by_increasing_offset() {\n+        let field = layout.field(cx, i);\n+        let target_offset = variant.offsets[i as usize];\n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n-            index, field, offset, target_offset);\n+            i, field, offset, target_offset);\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n         result.push(Type::array(&Type::i8(cx), padding.bytes()));"}, {"sha": "879a74678579fb9a26934a5a40c6bb93b3489fdb", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -1340,7 +1340,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n // Creates MemberDescriptions for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory<'tcx> {\n     // Cloned from the layout::Struct describing the variant.\n-    offsets: &'tcx [layout::Size],\n+    offsets: Vec<layout::Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n@@ -1436,8 +1436,12 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // If this is not a univariant enum, there is also the discriminant field.\n+    let mut offsets = struct_def.offsets.clone();\n     match discriminant_info {\n-        RegularDiscriminant(_) => arg_names.insert(0, \"RUST$ENUM$DISR\".to_string()),\n+        RegularDiscriminant(_) => {\n+            arg_names.insert(0, \"RUST$ENUM$DISR\".to_string());\n+            offsets.insert(0, Size::from_bytes(0));\n+        }\n         _ => { /* do nothing */ }\n     };\n \n@@ -1449,7 +1453,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {\n-            offsets: &struct_def.offsets[..],\n+            offsets,\n             args,\n             discriminant_type_metadata: match discriminant_info {\n                 RegularDiscriminant(discriminant_type_metadata) => {"}, {"sha": "ab8749f56110e3a564d93a2f3043e0acf716ba54", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -1108,11 +1108,8 @@ fn trans_const_adt<'a, 'tcx>(\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];\n             let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n-            let mut vals_with_discr = vec![\n-                Const::new(lldiscr, d.to_ty(ccx.tcx(), false))\n-            ];\n-            vals_with_discr.extend_from_slice(vals);\n-            build_const_struct(ccx, l, &variant, &vals_with_discr)\n+            build_const_struct(ccx, l, &variant, vals,\n+                Some(Const::new(lldiscr, d.to_ty(ccx.tcx(), false))))\n         }\n         layout::UntaggedUnion { ref variants, .. }=> {\n             assert_eq!(variant_index, 0);\n@@ -1125,7 +1122,7 @@ fn trans_const_adt<'a, 'tcx>(\n         }\n         layout::Univariant { ref variant, .. } => {\n             assert_eq!(variant_index, 0);\n-            build_const_struct(ccx, l, &variant, vals)\n+            build_const_struct(ccx, l, &variant, vals, None)\n         }\n         layout::Vector { .. } => {\n             Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n@@ -1140,7 +1137,7 @@ fn trans_const_adt<'a, 'tcx>(\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n-                build_const_struct(ccx, l, &nonnull, vals)\n+                build_const_struct(ccx, l, &nonnull, vals, None)\n             } else {\n                 // Always use null even if it's not the `discrfield`th\n                 // field; see #8506.\n@@ -1162,14 +1159,20 @@ fn trans_const_adt<'a, 'tcx>(\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 layout: layout::TyLayout<'tcx>,\n                                 st: &layout::Struct,\n-                                vals: &[Const<'tcx>])\n+                                vals: &[Const<'tcx>],\n+                                discr: Option<Const<'tcx>>)\n                                 -> Const<'tcx> {\n     assert_eq!(vals.len(), st.offsets.len());\n \n     // offset of current value\n     let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();\n-    cfields.reserve(st.offsets.len()*2);\n+    cfields.reserve(discr.is_some() as usize + 1 + st.offsets.len() * 2);\n+\n+    if let Some(discr) = discr {\n+        cfields.push(discr.llval);\n+        offset = ccx.size_of(discr.ty);\n+    }\n \n     let parts = st.field_index_by_increasing_offset().map(|i| {\n         (vals[i], st.offsets[i])"}, {"sha": "c11596b01403ed26d55c184711d5deebadfe1cb7", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -236,14 +236,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             _ => {}\n         }\n \n-        // Adjust the index to account for enum discriminants in variants.\n-        let mut ix = ix;\n-        if let layout::General { .. } = *l {\n-            if l.variant_index.is_some() {\n-                ix += 1;\n-            }\n-        }\n-\n         let simple = || {\n             LvalueRef {\n                 llval: bcx.struct_gep(self.llval, l.llvm_field_index(ix)),\n@@ -474,11 +466,10 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n             // If this is an enum, cast to the appropriate variant struct type.\n             let layout = bcx.ccx.layout_of(ty).for_variant(variant_index);\n-            if let layout::General { discr, ref variants, .. } = *layout {\n+            if let layout::General { ref variants, .. } = *layout {\n                 let st = &variants[variant_index];\n                 let variant_ty = Type::struct_(bcx.ccx,\n-                    &adt::struct_llfields(bcx.ccx, layout, st,\n-                        Some(discr.to_ty(bcx.tcx(), false))), st.packed);\n+                    &adt::struct_llfields(bcx.ccx, layout, st), st.packed);\n                 downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n             }\n "}, {"sha": "a75b8f3992d0795ea76697d761dd7f596dfbf80e", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -54,14 +54,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ [0 x i8], i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ [0 x i8], i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n     *&E::A(0)\n }"}, {"sha": "8557c065dc69c0694c18f20b0b9abe67820bdcf8", "filename": "src/test/run-pass/enum-discrim-manual-sizing.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eef7c9ac6d2944131c4216136a2c39e0c5da30/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs?ref=44eef7c9ac6d2944131c4216136a2c39e0c5da30", "patch": "@@ -108,6 +108,9 @@ pub fn main() {\n     let array_expected_size = round_up(28, align_of::<Eu64NonCLike<[u32; 5]>>());\n     assert_eq!(size_of::<Eu64NonCLike<[u32; 5]>>(), array_expected_size);\n     assert_eq!(size_of::<Eu64NonCLike<[u32; 6]>>(), 32);\n+\n+    assert_eq!(align_of::<Eu32>(), align_of::<u32>());\n+    assert_eq!(align_of::<Eu64NonCLike<u8>>(), align_of::<u64>());\n }\n \n // Rounds x up to the next multiple of a"}]}