{"sha": "3abe3671bd39a359de3421b062b98d3adaa1942d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYmUzNjcxYmQzOWEzNTlkZTM0MjFiMDYyYjk4ZDNhZGFhMTk0MmQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T14:15:17Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T14:15:17Z"}, "message": "Require the parameter that will be referenced to be noted\n\nIssue #918", "tree": {"sha": "a6a95df9c3ab53b55cc902cf736b0a282be98da0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6a95df9c3ab53b55cc902cf736b0a282be98da0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3abe3671bd39a359de3421b062b98d3adaa1942d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3abe3671bd39a359de3421b062b98d3adaa1942d", "html_url": "https://github.com/rust-lang/rust/commit/3abe3671bd39a359de3421b062b98d3adaa1942d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3abe3671bd39a359de3421b062b98d3adaa1942d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75eee8b194231c2fe808242a9828253125b854c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/75eee8b194231c2fe808242a9828253125b854c8", "html_url": "https://github.com/rust-lang/rust/commit/75eee8b194231c2fe808242a9828253125b854c8"}], "stats": {"total": 112, "additions": 74, "deletions": 38}, "files": [{"sha": "250522dda4fea25900ad7690fec2af6f6ecdcec0", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -55,8 +55,11 @@ fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n fn parse_ret_ty(st: @pstate, sd: str_def) -> (ast::ret_style, ty::t) {\n     alt peek(st) as char {\n       '!' { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n-      '&' { next(st); (ast::return_ref(false), parse_ty(st, sd)) }\n-      '^' { next(st); (ast::return_ref(true), parse_ty(st, sd)) }\n+      '&' | '^' {\n+        let mut = next(st) == '^' as u8;\n+        let arg = next(st) as uint;\n+        (ast::return_ref(mut, arg), parse_ty(st, sd))\n+      }\n       _ { (ast::return_val, parse_ty(st, sd)) }\n     }\n }"}, {"sha": "99f171907dee96f07ee91c4426d1131b07a36dd4", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -220,8 +220,9 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n     }\n     alt cf {\n       noreturn. { w.write_char('!'); }\n-      return_ref(mut) {\n+      return_ref(mut, arg) {\n         w.write_char(mut ? '^' : '&');\n+        w.write_bytes([arg as u8]);\n         enc_ty(w, cx, out);\n       }\n       _ { enc_ty(w, cx, out); }"}, {"sha": "2c1cac9ec8db47a4cbc0252f51014c0721fefb97", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -22,8 +22,10 @@ type binding = @{node_id: node_id,\n                  unsafe_tys: [ty::t],\n                  mutable ok: valid,\n                  mutable copied: copied};\n+\n+tag ret_info { by_ref(bool, node_id); other; }\n // FIXME it may be worthwhile to use a linked list of bindings instead\n-type scope = {bs: [binding], ret_style: ast::ret_style};\n+type scope = {bs: [binding], ret_info: ret_info};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n               unsafe: [ty::t]) -> binding {\n@@ -49,8 +51,7 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> copy_map {\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n-    visit::visit_crate(*crate, {bs: [], ret_style: ast::return_val},\n-                       visit::mk_vt(v));\n+    visit::visit_crate(*crate, {bs: [], ret_info: other}, visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n     ret cx.copy_map;\n }\n@@ -70,7 +71,11 @@ fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], _sp: span,\n                              \"reference-returning functions may not \" +\n                              \"return implicitly\");\n     }\n-    v.visit_block(f.body, {bs: bs, ret_style: f.decl.cf}, v);\n+    let ret_info = alt f.decl.cf {\n+      ast::return_ref(mut, n_arg) { by_ref(mut, f.decl.inputs[n_arg].id) }\n+      _ { other }\n+    };\n+    v.visit_block(f.body, {bs: bs, ret_info: ret_info}, v);\n }\n \n fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n@@ -117,9 +122,9 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n       }\n       ast::expr_ret(oexpr) {\n         if !is_none(oexpr) {\n-            alt sc.ret_style {\n-              ast::return_ref(mut) {\n-                check_ret_ref(*cx, sc, mut, option::get(oexpr));\n+            alt sc.ret_info {\n+              by_ref(mut, arg_node_id) {\n+                check_ret_ref(*cx, sc, mut, arg_node_id, option::get(oexpr));\n               }\n               _ {}\n             }\n@@ -180,20 +185,20 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n             alt root.ex.node {\n               ast::expr_call(f, args) {\n                 let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n-                let ret_style = ty::ty_fn_ret_style(cx.tcx, fty);\n-                if ast_util::ret_by_ref(ret_style) {\n-                    // FIXME pick right arg\n-                    let arg = args[0];\n+                alt ty::ty_fn_ret_style(cx.tcx, fty) {\n+                  ast::return_ref(mut, arg_n) {\n+                    let arg = args[arg_n];\n                     let arg_root = expr_root(cx.tcx, arg, false);\n                     root_var = path_def_id(cx, arg_root.ex);\n                     if !is_none(root_var) {\n                         is_temp = false;\n-                        if ret_style == ast::return_ref(true) {\n+                        if mut {\n                             outer_ds = [@{mut: true, kind: unbox,\n                                           outer_t: ty::expr_ty(cx.tcx, arg)}];\n                         }\n                         outer_ds = *arg_root.ds + outer_ds;\n                     }\n+                  }\n                 }\n               }\n               _ {}\n@@ -333,20 +338,24 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     ret bindings;\n }\n \n-fn check_ret_ref(cx: ctx, sc: scope, mut: bool, expr: @ast::expr) {\n+fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n+                 expr: @ast::expr) {\n     let root = expr_root(cx.tcx, expr, false);\n     let bad = none;\n     let mut_field = mut_field(root.ds);\n     alt path_def(cx, root.ex) {\n-      none. { bad = some(\"temporary\"); }\n+      none. { bad = some(\"a temporary\"); }\n       some(ast::def_local(did, _)) | some(ast::def_binding(did)) |\n       some(ast::def_arg(did, _)) {\n         let cur_node = did.node;\n         while true {\n             alt cx.tcx.items.find(cur_node) {\n               some(ast_map::node_arg(arg, _)) {\n                 if arg.mode == ast::by_move {\n-                    bad = some(\"move-mode parameter\");\n+                    bad = some(\"a move-mode parameter\");\n+                }\n+                if cur_node != arg_node_id {\n+                    bad = some(\"the wrong parameter\");\n                 }\n                 break;\n               }\n@@ -359,31 +368,30 @@ fn check_ret_ref(cx: ctx, sc: scope, mut: bool, expr: @ast::expr) {\n                     break;\n                 }\n                 if is_none(b.root_var) {\n-                    bad = some(\"function-local value\");\n+                    bad = some(\"a function-local value\");\n                     break;\n                 }\n                 if b.copied == copied {\n-                    bad = some(\"implicitly copied reference\");\n+                    bad = some(\"an implicitly copied reference\");\n                     break;\n                 }\n                 b.copied = not_allowed;\n                 cur_node = option::get(b.root_var);\n               }\n               none. {\n-                bad = some(\"function-local value\");\n+                bad = some(\"a function-local value\");\n                 break;\n               }\n             }\n         }\n       }\n-      // FIXME allow references to constants and static items?\n-      _ { bad = some(\"non-local value\"); }\n+      _ { bad = some(\"a non-local value\"); }\n     }\n-    if mut_field && !mut { bad = some(\"mutable field\"); }\n+    if mut_field && !mut { bad = some(\"a mutable field\"); }\n     alt bad {\n       some(name) {\n-        cx.tcx.sess.span_err(expr.span, \"can not return a reference \" +\n-                             \"to a \" + name);\n+        cx.tcx.sess.span_err(expr.span, \"can not return a reference to \" +\n+                             name);\n       }\n       _ {}\n     }\n@@ -402,8 +410,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n         for pat in a.pats {\n             for proot in *pattern_roots(cx.tcx, *root.ds, pat) {\n                 let canon_id = pat_id_map.get(proot.name);\n-                // FIXME I wanted to use a block, but that hit a\n-                // typestate bug.\n+                // FIXME I wanted to use a block here, but that hit bug #913\n                 fn match(x: info, canon: node_id) -> bool { x.id == canon }\n                 alt vec::find(bind match(_, canon_id), binding_info) {\n                   some(s) { s.unsafe += inner_mut(proot.ds); }"}, {"sha": "a71811fccf74dabe66e2429974131ea7ef9f3385", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -2459,7 +2459,10 @@ fn type_err_to_str(err: ty::type_err) -> str {\n             alt s {\n               ast::noreturn. { \"non-returning\" }\n               ast::return_val. { \"return-by-value\" }\n-              ast::return_ref(_) { \"return-by-reference\" }\n+              ast::return_ref(mut, arg) {\n+                #fmt(\"return-by-%sreference on arg %u\",\n+                     mut ? \"mutable-\" : \"\", arg)\n+              }\n             }\n         }\n         ret to_str(actual) + \" function found where \" + to_str(expect) +"}, {"sha": "5a34d1a4c16183ed8d55d29c5b4197166d75b672", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -383,7 +383,7 @@ tag ret_style {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val; // everything else\n-    return_ref(bool);\n+    return_ref(bool, uint);\n }\n \n type _fn = {decl: fn_decl, proto: proto, body: blk};"}, {"sha": "aebf9b3e680fd73b923b0c4ed81120c1c7076adf", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -215,7 +215,7 @@ fn ternary_to_if(e: @expr) -> @expr {\n \n fn ret_by_ref(style: ret_style) -> bool {\n     alt style {\n-      return_ref(_) { true }\n+      return_ref(_, _) { true }\n       _ { false }\n     }\n }"}, {"sha": "b2da68b0cd955f72f554da0c42219d454d53279f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -285,7 +285,7 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n     // FIXME: there's no syntax for this right now anyway\n     //  auto constrs = parse_constrs(~[], p);\n     let constrs: [@ast::constr] = [];\n-    let (ret_style, ret_ty) = parse_ret_ty(p);\n+    let (ret_style, ret_ty) = parse_ret_ty(p, vec::len(inputs.node));\n     ret ast::ty_fn(proto, inputs.node, ret_ty, ret_style, constrs);\n }\n \n@@ -437,15 +437,28 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool)\n     }\n }\n \n-fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n+fn parse_ret_ty(p: parser, n_args: uint) -> (ast::ret_style, @ast::ty) {\n     ret if eat(p, token::RARROW) {\n         let lo = p.get_lo_pos();\n         if eat(p, token::NOT) {\n             (ast::noreturn, @spanned(lo, p.get_last_hi_pos(), ast::ty_bot))\n         } else {\n             let style = ast::return_val;\n             if eat(p, token::BINOP(token::AND)) {\n-                style = ast::return_ref(eat(p, token::NOT));\n+                if n_args == 0u {\n+                    p.fatal(\"can not return reference from argument-less fn\");\n+                }\n+                let mut_root = eat(p, token::NOT), arg = 0u;\n+                alt p.peek() {\n+                  token::LIT_INT(val) { p.bump(); arg = val as uint; }\n+                  _ { if n_args > 1u {\n+                      p.fatal(\"must specify referenced parameter\");\n+                  } }\n+                }\n+                if arg >= n_args {\n+                    p.fatal(\"referenced argument does not exist\");\n+                }\n+                style = ast::return_ref(mut_root, arg);\n             };\n             (style, parse_ty(p, false))\n         }\n@@ -1734,7 +1747,7 @@ fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n         p.bump();\n         constrs = parse_constrs(bind parse_ty_constr(inputs.node, _), p);\n     }\n-    let (ret_style, ret_ty) = parse_ret_ty(p);\n+    let (ret_style, ret_ty) = parse_ret_ty(p, vec::len(inputs.node));\n     ret {inputs: inputs.node,\n          output: ret_ty,\n          purity: purity,"}, {"sha": "d6af92cca0dbe515f00e4309064851d93d163068", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -1145,7 +1145,12 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n         space_if_not_bol(s);\n         word_space(s, \"->\");\n         alt decl.cf {\n-          ast::return_ref(mut) { word(s.s, mut ? \"&!\" : \"&\"); }\n+          ast::return_ref(mut, arg) {\n+            word(s.s, mut ? \"&!\" : \"&\");\n+            if vec::len(decl.inputs) > 1u {\n+                word(s.s, std::uint::str(arg));\n+            }\n+          }\n           _ {}\n         }\n         print_type(s, decl.output);\n@@ -1347,7 +1352,10 @@ fn print_ty_fn(s: ps, proto: ast::proto, id: option::t<ast::ident>,\n             word_nbsp(s, \"!\");\n         } else {\n             alt cf {\n-              ast::return_ref(mut) { word(s.s, mut ? \"&!\" : \"&\"); }\n+              ast::return_ref(mut, arg) {\n+                word(s.s, mut ? \"&!\" : \"&\");\n+                if vec::len(inputs) > 1u { word(s.s, std::uint::str(arg)); }\n+              }\n               _ {}\n             }\n             print_type(s, output);"}, {"sha": "44cf92ea1b9805b3f1d211adc5f4fffdcb602f2f", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abe3671bd39a359de3421b062b98d3adaa1942d/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=3abe3671bd39a359de3421b062b98d3adaa1942d", "patch": "@@ -61,8 +61,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n             s += \" -> \";\n             alt cf {\n               ast::noreturn. { s += \"!\"; }\n-              ast::return_ref(mut) {\n+              ast::return_ref(mut, arg) {\n                 s += mut ? \"&!\" : \"&\";\n+                if vec::len(inputs) > 1u { s += std::uint::str(arg); }\n                 s += ty_to_str(cx, output);\n               }\n               ast::return_val. { s += ty_to_str(cx, output); }"}]}