{"sha": "3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNTBiNDFkYTRjYmIxMzVmYzc0Y2RjOGViZjJiMDllZGIzOTZmODc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-25T15:58:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-13T15:22:05Z"}, "message": "introduce `infcx.at(..).normalize(..)` operation [VIC]\n\nIt is backed by the new `normalize_projection_ty` query, which uses\ncanonicalization.", "tree": {"sha": "2077454061d7c42a70d684158228ccc3a5ffd13b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2077454061d7c42a70d684158228ccc3a5ffd13b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "html_url": "https://github.com/rust-lang/rust/commit/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c024fdafb6339c5375543ef400a33419d65a19b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c024fdafb6339c5375543ef400a33419d65a19b", "html_url": "https://github.com/rust-lang/rust/commit/8c024fdafb6339c5375543ef400a33419d65a19b"}], "stats": {"total": 647, "additions": 637, "deletions": 10}, "files": [{"sha": "ed32984bb5844b3d2870853d1c0515185897e24f", "filename": "src/Cargo.lock", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -1884,6 +1884,7 @@ dependencies = [\n  \"rustc_privacy 0.0.0\",\n  \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n+ \"rustc_traits 0.0.0\",\n  \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -2068,6 +2069,19 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_traits\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_trans\"\n version = \"0.0.0\""}, {"sha": "caef3a8acc44c7b9c3734b62ef5e7e67b47d10fa", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -67,11 +67,12 @@ use hir::{HirId, ItemLocalId};\n \n use ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n-use ty::subst::Substs;\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n+use traits::query::CanonicalProjectionGoal;\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n+use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e. which sub-expression of the macro we are in) but don't need\n@@ -635,6 +636,7 @@ define_dep_nodes!( <'tcx>\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,\n     [anon] NormalizeTy,\n+    [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n "}, {"sha": "89dbc76c8a65c2b58306e8d3ea1d95f2de912d29", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -40,9 +40,9 @@ use super::*;\n use ty::relate::{Relate, TypeRelation};\n \n pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    cause: &'a ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub cause: &'a ObligationCause<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {"}, {"sha": "2c58e17b2833c9ed9c451dc60cb97cd1a8e5132b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -69,6 +69,7 @@ pub mod type_variable;\n pub mod unify_key;\n \n #[must_use]\n+#[derive(Debug)]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n     pub obligations: PredicateObligations<'tcx>,\n@@ -1224,6 +1225,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.borrow_region_constraints().take_and_reset_data()\n     }\n \n+    /// Gives temporary access to the region constraint data.\n+    #[allow(non_camel_case_types)] // bug with impl trait\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let region_constraints = self.borrow_region_constraints();\n+        op(region_constraints.data())\n+    }\n+\n     /// Takes ownership of the list of variable regions. This implies\n     /// that all the region constriants have already been taken, and\n     /// hence that `resolve_regions_and_report_errors` can never be"}, {"sha": "e5461685bd470bd21a744008698bf75013d6f0ac", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -99,6 +99,16 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             .push((body_id, obligation));\n     }\n \n+    /// Trait queries just want to pass back type obligations \"as is\"\n+    pub fn take_registered_region_obligations(\n+        &self,\n+    ) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+        ::std::mem::replace(\n+            &mut *self.region_obligations.borrow_mut(),\n+            vec![],\n+        )\n+    }\n+\n     /// Process the region obligations that must be proven (during\n     /// `regionck`) for the given `body_id`, given information about\n     /// the region bounds in scope and so forth. This function must be"}, {"sha": "0c8e49fda1840d7cab10569ee946bfebd5be85e9", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -350,6 +350,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         mem::replace(data, RegionConstraintData::default())\n     }\n \n+    pub fn data(&self) -> &RegionConstraintData<'tcx> {\n+        &self.data\n+    }\n+\n     fn in_snapshot(&self) -> bool {\n         !self.undo_log.is_empty()\n     }"}, {"sha": "b986445ff849d2c6f36d73c73957f76aad04190f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -175,6 +175,11 @@ pub struct PerfStats {\n     pub decode_def_path_tables_time: Cell<Duration>,\n     /// Total number of values canonicalized queries constructed.\n     pub queries_canonicalized: Cell<usize>,\n+    /// Number of times we canonicalized a value and found that the\n+    /// result had already been canonicalized.\n+    pub canonicalized_values_allocated: Cell<usize>,\n+    /// Number of times this query is invoked.\n+    pub normalize_projection_ty: Cell<usize>,\n }\n \n /// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n@@ -862,6 +867,10 @@ impl Session {\n         );\n         println!(\"Total queries canonicalized:                   {}\",\n                  self.perf_stats.queries_canonicalized.get());\n+        println!(\"Total canonical values interned:               {}\",\n+                 self.perf_stats.canonicalized_values_allocated.get());\n+        println!(\"normalize_projection_ty:                       {}\",\n+                 self.perf_stats.normalize_projection_ty.get());\n     }\n \n     /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n@@ -1149,6 +1158,8 @@ pub fn build_session_(\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n             queries_canonicalized: Cell::new(0),\n+            canonicalized_values_allocated: Cell::new(0),\n+            normalize_projection_ty: Cell::new(0),\n         },\n         code_stats: RefCell::new(CodeStats::new()),\n         optimization_fuel_crate,"}, {"sha": "3e23e3823470cb5f45e1e2c1f8ef43c8e78d6e56", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -63,6 +63,8 @@ mod structural_impls;\n pub mod trans;\n mod util;\n \n+pub mod query;\n+\n // Whether to enable bug compatibility with issue #43355\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {"}, {"sha": "bba2c1555832eb16f8d86ae0f512529e074bf310", "filename": "src/librustc/traits/query/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental types for the trait query interface. The methods\n+//! defined in this module are all based on **canonicalization**,\n+//! which makes a canonical query by replacing unbound inference\n+//! variables and regions, so that results can be reused more broadly.\n+//! The providers for the queries defined here can be found in\n+//! `librustc_traits`.\n+\n+use infer::canonical::Canonical;\n+use ty;\n+\n+pub mod normalize;\n+\n+pub type CanonicalProjectionGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct NoSolution;\n+\n+pub type Fallible<T> = Result<T, NoSolution>;\n+\n+impl_stable_hash_for!(struct NoSolution { });"}, {"sha": "030e630f23f830200a860659704424a0cbb90b61", "filename": "src/librustc/traits/query/normalize.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for the 'normalization' query. This consists of a wrapper\n+//! which folds deeply, invoking the underlying\n+//! `normalize_projection_ty` query when it encounters projections.\n+\n+use infer::{InferCtxt, InferOk};\n+use infer::at::At;\n+use infer::canonical::{Canonical, Canonicalize, QueryResult};\n+use middle::const_val::ConstVal;\n+use mir::interpret::GlobalId;\n+use std::rc::Rc;\n+use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use traits::query::CanonicalProjectionGoal;\n+use traits::project::Normalized;\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::subst::{Subst, Substs};\n+\n+use super::NoSolution;\n+\n+impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n+    /// Normalize `value` in the context of the inference context,\n+    /// yielding a resulting type, or an error if `value` cannot be\n+    /// normalized. If you don't care about regions, you should prefer\n+    /// `normalize_erasing_regions`, which is more efficient.\n+    ///\n+    /// If the normalization succeeds and is unambigious, returns back\n+    /// the normalized value along with various outlives relations (in\n+    /// the form of obligations that must be discharged).\n+    ///\n+    /// NB. This will *eventually* be the main means of\n+    /// normalizing, but for now should be used only when we actually\n+    /// know that normalization will succeed, since error reporting\n+    /// and other details are still \"under development\".\n+    pub fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let mut normalizer = QueryNormalizer {\n+            infcx: self.infcx,\n+            cause: self.cause,\n+            param_env: self.param_env,\n+            obligations: vec![],\n+            error: false,\n+            anon_depth: 0,\n+        };\n+        if !value.has_projections() {\n+            return Ok(Normalized {\n+                value: value.clone(),\n+                obligations: vec![],\n+            });\n+        }\n+\n+        let value1 = value.fold_with(&mut normalizer);\n+        if normalizer.error {\n+            Err(NoSolution)\n+        } else {\n+            Ok(Normalized {\n+                value: value1,\n+                obligations: normalizer.obligations,\n+            })\n+        }\n+    }\n+}\n+\n+/// Result from the `normalize_projection_ty` query.\n+#[derive(Clone, Debug)]\n+pub struct NormalizationResult<'tcx> {\n+    /// Result of normalization.\n+    pub normalized_ty: Ty<'tcx>,\n+}\n+\n+struct QueryNormalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    cause: &'cx ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+    error: bool,\n+    anon_depth: usize,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = ty.super_fold_with(self);\n+        match ty.sty {\n+            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => {\n+                // (*)\n+                // Only normalize `impl Trait` after type-checking, usually in trans.\n+                match self.param_env.reveal {\n+                    Reveal::UserFacing => ty,\n+\n+                    Reveal::All => {\n+                        let recursion_limit = self.tcx().sess.recursion_limit.get();\n+                        if self.anon_depth >= recursion_limit {\n+                            let obligation = Obligation::with_depth(\n+                                self.cause.clone(),\n+                                recursion_limit,\n+                                self.param_env,\n+                                ty,\n+                            );\n+                            self.infcx.report_overflow_error(&obligation, true);\n+                        }\n+\n+                        let generic_ty = self.tcx().type_of(def_id);\n+                        let concrete_ty = generic_ty.subst(self.tcx(), substs);\n+                        self.anon_depth += 1;\n+                        let folded_ty = self.fold_ty(concrete_ty);\n+                        self.anon_depth -= 1;\n+                        folded_ty\n+                    }\n+                }\n+            }\n+\n+            ty::TyProjection(ref data) if !data.has_escaping_regions() => {\n+                // (*)\n+                // (*) This is kind of hacky -- we need to be able to\n+                // handle normalization within binders because\n+                // otherwise we wind up a need to normalize when doing\n+                // trait matching (since you can have a trait\n+                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n+                // we can't normalize with bound regions in scope. So\n+                // far now we just ignore binders but only normalize\n+                // if all bound regions are gone (and then we still\n+                // have to renormalize whenever we instantiate a\n+                // binder). It would be better to normalize in a\n+                // binding-aware fashion.\n+\n+                let gcx = self.infcx.tcx.global_tcx();\n+\n+                let (c_data, orig_values) =\n+                    self.infcx.canonicalize_query(&self.param_env.and(*data));\n+                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n+                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n+                match gcx.normalize_projection_ty(c_data) {\n+                    Ok(result) => {\n+                        // We don't expect ambiguity.\n+                        if result.is_ambiguous() {\n+                            self.error = true;\n+                            return ty;\n+                        }\n+\n+                        match self.infcx.instantiate_query_result(\n+                            self.cause,\n+                            self.param_env,\n+                            &orig_values,\n+                            &result,\n+                        ) {\n+                            Ok(InferOk {\n+                                value: result,\n+                                obligations,\n+                            }) => {\n+                                debug!(\"QueryNormalizer: result = {:#?}\", result);\n+                                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n+                                self.obligations.extend(obligations);\n+                                return result.normalized_ty;\n+                            }\n+\n+                            Err(_) => {\n+                                self.error = true;\n+                                return ty;\n+                            }\n+                        }\n+                    }\n+\n+                    Err(NoSolution) => {\n+                        self.error = true;\n+                        ty\n+                    }\n+                }\n+            }\n+\n+            _ => ty,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n+            let tcx = self.infcx.tcx.global_tcx();\n+            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+                if substs.needs_infer() {\n+                    let identity_substs = Substs::identity_for_item(tcx, def_id);\n+                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n+                    if let Some(instance) = instance {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n+                        match tcx.const_eval(param_env.and(cid)) {\n+                            Ok(evaluated) => {\n+                                let evaluated = evaluated.subst(self.tcx(), substs);\n+                                return self.fold_const(evaluated);\n+                            }\n+                            Err(_) => {}\n+                        }\n+                    }\n+                } else {\n+                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n+                        if let Some(instance) = instance {\n+                            let cid = GlobalId {\n+                                instance,\n+                                promoted: None,\n+                            };\n+                            match tcx.const_eval(param_env.and(cid)) {\n+                                Ok(evaluated) => return self.fold_const(evaluated),\n+                                Err(_) => {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        constant\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for NormalizationResult<'tcx> {\n+        normalized_ty\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for NormalizationResult<'a> {\n+        type Lifted = NormalizationResult<'tcx>;\n+        normalized_ty\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>> {\n+    type Canonicalized = CanonicalProjectionGoal<'gcx>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, NormalizationResult<'tcx>> {\n+    // we ought to intern this, but I'm too lazy just now\n+    type Canonicalized = Rc<Canonical<'gcx, QueryResult<'gcx, NormalizationResult<'gcx>>>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        Rc::new(value)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct NormalizationResult<'tcx> {\n+    normalized_ty\n+});"}, {"sha": "d85a95e87ea8eed18568b4482120240dee30c815", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -106,6 +106,7 @@ pub struct GlobalArenas<'tcx> {\n     tables: TypedArena<ty::TypeckTables<'tcx>>,\n     /// miri allocations\n     const_allocs: TypedArena<interpret::Allocation>,\n+\n }\n \n impl<'tcx> GlobalArenas<'tcx> {"}, {"sha": "95865d5eab0bc9c093efc67a6bbfead481330ffc", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -11,6 +11,7 @@\n use dep_graph::SerializedDepNodeIndex;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n+use traits::query::CanonicalProjectionGoal;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n@@ -51,6 +52,15 @@ impl<'tcx, M: QueryConfig<Key=DefId>> QueryDescription<'tcx> for M {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt,\n+        goal: CanonicalProjectionGoal<'tcx>,\n+    ) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)"}, {"sha": "1f040522fda98fc907ea68dce9e26ce16b5ccc03", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -11,6 +11,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use traits::query::CanonicalProjectionGoal;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -170,3 +171,13 @@ impl Key for InternedString {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for CanonicalProjectionGoal<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "2dc6cd7a4eb4171e1d965525294fe04003e304bc", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n+use infer::canonical::{Canonical, QueryResult};\n use lint;\n use middle::borrowck::BorrowCheckResult;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n@@ -33,6 +34,8 @@ use mir::interpret::{GlobalId};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::Vtable;\n+use traits::query::{CanonicalProjectionGoal, NoSolution};\n+use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::steal::Steal;\n@@ -380,6 +383,14 @@ define_maps! { <'tcx>\n     [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n     [] fn fully_normalize_monormophic_ty: normalize_ty_node(Ty<'tcx>) -> Ty<'tcx>,\n \n+    /// Do not call this query directly: invoke `normalize` instead.\n+    [] fn normalize_projection_ty: NormalizeProjectionTy(\n+        CanonicalProjectionGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n \n@@ -537,6 +548,7 @@ fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::VtableMethods{ trait_ref }\n }\n+\n fn normalize_ty_node<'tcx>(_: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::NormalizeTy\n }"}, {"sha": "2124b6296aab19c372e8565326c70a211a2ed5d9", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -773,6 +773,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::VtableMethods |\n         DepKind::EraseRegionsTy |\n         DepKind::NormalizeTy |\n+        DepKind::NormalizeProjectionTy |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::InstanceDefSizeEstimate |\n "}, {"sha": "3bff79ed3a6fce0c2ebf5dc662397835f5ff2564", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -28,6 +28,7 @@ rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n+rustc_traits = { path = \"../librustc_traits\" }\n rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "542f818c3818a3db39dc66c90dd2a562cd9bc138", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -31,6 +31,7 @@ use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver, ResolverArenas};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n+use rustc_traits;\n use rustc_trans_utils::trans_crate::TransCrate;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -942,6 +943,7 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     traits::provide(providers);\n     reachable::provide(providers);\n     rustc_passes::provide(providers);\n+    rustc_traits::provide(providers);\n     middle::region::provide(providers);\n     cstore::provide(providers);\n     lint::provide(providers);"}, {"sha": "746f2db4767f92842ea4372284a350ca39ab944e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -46,6 +46,7 @@ extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n+extern crate rustc_traits;\n extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;"}, {"sha": "06e6be5cd56a35c6ca1c73127689484892e714f4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -20,7 +20,8 @@ use dataflow::move_paths::MoveData;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n-use rustc::traits::{self, FulfillmentContext};\n+use rustc::traits::{self, Normalized, FulfillmentContext};\n+use rustc::traits::query::NoSolution;\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n@@ -1553,10 +1554,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         self.fully_perform_op(location.at_self(), |this| {\n-            let mut selcx = traits::SelectionContext::new(this.infcx);\n-            let cause = this.misc(this.last_span);\n-            let traits::Normalized { value, obligations } =\n-                traits::normalize(&mut selcx, this.param_env, cause, value);\n+            let Normalized { value, obligations } = this.infcx\n+                .at(&this.misc(this.last_span), this.param_env)\n+                .normalize(value)\n+                .unwrap_or_else(|NoSolution| {\n+                    span_bug!(\n+                        this.last_span,\n+                        \"normalization of `{:?}` failed at {:?}\",\n+                        value,\n+                        location,\n+                    );\n+                });\n             Ok(InferOk { value, obligations })\n         }).unwrap()\n     }"}, {"sha": "dc2a21cdab256db89eff1f3b9cf1b3b7a9baa4ce", "filename": "src/librustc_traits/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_traits\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_traits\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+bitflags = \"1.0\"\n+graphviz = { path = \"../libgraphviz\" }\n+log = { version = \"0.4\" }\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "0d92404d24b08cfce1c885196515d3dd481ab0aa", "filename": "src/librustc_traits/lib.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! New recursive solver modeled on Chalk's recursive solver. Most of\n+//! the guts are broken up into modules; see the comments in those modules.\n+\n+#![deny(warnings)]\n+\n+#![feature(crate_visibility_modifier)]\n+#![feature(match_default_bindings)]\n+#![feature(underscore_lifetimes)]\n+\n+#[macro_use]\n+extern crate log;\n+extern crate rustc;\n+extern crate rustc_data_structures;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+mod normalize_projection_ty;\n+mod util;\n+\n+use rustc::ty::maps::Providers;\n+\n+pub fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        normalize_projection_ty: normalize_projection_ty::normalize_projection_ty,\n+        ..*p\n+    };\n+}"}, {"sha": "55785d9586cc37cebbd46479b1fcecf9293ec0ba", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::traits::{self, FulfillmentContext, Normalized, ObligationCause,\n+                    SelectionContext};\n+use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n+use rustc::util::common::CellUsizeExt;\n+use std::rc::Rc;\n+use syntax::ast::DUMMY_NODE_ID;\n+use syntax_pos::DUMMY_SP;\n+use util;\n+\n+crate fn normalize_projection_ty<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalProjectionGoal<'tcx>,\n+) -> Result<Rc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>, NoSolution> {\n+    debug!(\"normalize_provider(goal={:#?})\", goal);\n+\n+    tcx.sess.perf_stats.normalize_projection_ty.increment();\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let (\n+            ParamEnvAnd {\n+                param_env,\n+                value: goal,\n+            },\n+            canonical_inference_vars,\n+        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+        let fulfill_cx = &mut FulfillmentContext::new();\n+        let selcx = &mut SelectionContext::new(infcx);\n+        let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+        let Normalized {\n+            value: answer,\n+            obligations,\n+        } = traits::normalize_projection_type(selcx, param_env, goal, cause, 0);\n+        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+        // Now that we have fulfilled as much as we can, create a solution\n+        // from what we've learned.\n+        util::make_query_response(\n+            infcx,\n+            canonical_inference_vars,\n+            NormalizationResult { normalized_ty: answer },\n+            fulfill_cx,\n+        )\n+    })\n+}"}, {"sha": "976eb442a0d13ee0dc1b833fe80dcc319f8e6487", "filename": "src/librustc_traits/util.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::InferCtxt;\n+use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryRegionConstraints,\n+                              QueryResult};\n+use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n+use rustc::traits::FulfillmentContext;\n+use rustc::traits::query::NoSolution;\n+use rustc::ty;\n+use std::fmt::Debug;\n+\n+/// The canonicalization form of `QueryResult<'tcx, T>`.\n+type CanonicalizedQueryResult<'gcx, 'tcx, T> =\n+    <QueryResult<'tcx, T> as Canonicalize<'gcx, 'tcx>>::Canonicalized;\n+\n+crate fn make_query_response<'gcx, 'tcx, T>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    inference_vars: CanonicalVarValues<'tcx>,\n+    answer: T,\n+    fulfill_cx: &mut FulfillmentContext<'tcx>,\n+) -> Result<CanonicalizedQueryResult<'gcx, 'tcx, T>, NoSolution>\n+where\n+    T: Debug,\n+    QueryResult<'tcx, T>: Canonicalize<'gcx, 'tcx>,\n+{\n+    let tcx = infcx.tcx;\n+\n+    debug!(\n+        \"make_query_response(\\\n+         inference_vars={:?}, \\\n+         answer={:?})\",\n+        inference_vars, answer,\n+    );\n+\n+    // Select everything, returning errors.\n+    let true_errors = match fulfill_cx.select_where_possible(infcx) {\n+        Ok(()) => vec![],\n+        Err(errors) => errors,\n+    };\n+    debug!(\"true_errors = {:#?}\", true_errors);\n+\n+    if !true_errors.is_empty() {\n+        // FIXME -- we don't indicate *why* we failed to solve\n+        debug!(\"make_query_response: true_errors={:#?}\", true_errors);\n+        return Err(NoSolution);\n+    }\n+\n+    // Anything left unselected *now* must be an ambiguity.\n+    let ambig_errors = match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => vec![],\n+        Err(errors) => errors,\n+    };\n+    debug!(\"ambig_errors = {:#?}\", ambig_errors);\n+\n+    let region_obligations = infcx.take_registered_region_obligations();\n+\n+    let (region_outlives, ty_outlives) = infcx.with_region_constraints(|region_constraints| {\n+        let RegionConstraintData {\n+            constraints,\n+            verifys,\n+            givens,\n+        } = region_constraints;\n+\n+        assert!(verifys.is_empty());\n+        assert!(givens.is_empty());\n+\n+        let region_outlives: Vec<_> = constraints\n+            .into_iter()\n+            .map(|(k, _)| match *k {\n+                Constraint::VarSubVar(v1, v2) => {\n+                    (tcx.mk_region(ty::ReVar(v1)), tcx.mk_region(ty::ReVar(v2)))\n+                }\n+                Constraint::VarSubReg(v1, r2) => (tcx.mk_region(ty::ReVar(v1)), r2),\n+                Constraint::RegSubVar(r1, v2) => (r1, tcx.mk_region(ty::ReVar(v2))),\n+                Constraint::RegSubReg(r1, r2) => (r1, r2),\n+            })\n+            .collect();\n+\n+        let ty_outlives: Vec<_> = region_obligations\n+            .into_iter()\n+            .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n+            .collect();\n+\n+        (region_outlives, ty_outlives)\n+    });\n+\n+    let certainty = if ambig_errors.is_empty() {\n+        Certainty::Proven\n+    } else {\n+        Certainty::Ambiguous\n+    };\n+\n+    let (canonical_result, _) = infcx.canonicalize_response(&QueryResult {\n+        var_values: inference_vars,\n+        region_constraints: QueryRegionConstraints {\n+            region_outlives,\n+            ty_outlives,\n+        },\n+        certainty,\n+        value: answer,\n+    });\n+\n+    debug!(\n+        \"make_query_response: canonical_result = {:#?}\",\n+        canonical_result\n+    );\n+\n+    Ok(canonical_result)\n+}"}]}