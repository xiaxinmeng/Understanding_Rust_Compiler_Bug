{"sha": "36f1b38f8067503ef3936f9cb2b3b07012e681a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZjFiMzhmODA2NzUwM2VmMzkzNmY5Y2IyYjNiMDcwMTJlNjgxYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-07T08:56:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-07T08:56:31Z"}, "message": "auto merge of #12062 : kballard/rust/from_utf8_lossy, r=huonw\n\n`from_utf8_lossy()` takes a byte vector and produces a `~str`, converting\r\nany invalid UTF-8 sequence into the U+FFFD REPLACEMENT CHARACTER.\r\n\r\nThe replacement follows the guidelines in \u00a75.22 Best Practice for U+FFFD\r\nSubstitution from the Unicode Standard (Version 6.2)[1], which also\r\nmatches the WHATWG rules for utf-8 decoding[2].\r\n\r\n[1]: http://www.unicode.org/versions/Unicode6.2.0/ch05.pdf\r\n[2]: http://encoding.spec.whatwg.org/#utf-8\r\n\r\nCloses #9516.", "tree": {"sha": "ece5c265ae8d2e9dc76a2a437a7390895117af6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ece5c265ae8d2e9dc76a2a437a7390895117af6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36f1b38f8067503ef3936f9cb2b3b07012e681a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36f1b38f8067503ef3936f9cb2b3b07012e681a6", "html_url": "https://github.com/rust-lang/rust/commit/36f1b38f8067503ef3936f9cb2b3b07012e681a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36f1b38f8067503ef3936f9cb2b3b07012e681a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21b856d2dc6ae2e4b40c73958d34501358707b39", "url": "https://api.github.com/repos/rust-lang/rust/commits/21b856d2dc6ae2e4b40c73958d34501358707b39", "html_url": "https://github.com/rust-lang/rust/commit/21b856d2dc6ae2e4b40c73958d34501358707b39"}, {"sha": "544cb42d7aeaec230e10471820f48e561e3cd33d", "url": "https://api.github.com/repos/rust-lang/rust/commits/544cb42d7aeaec230e10471820f48e561e3cd33d", "html_url": "https://github.com/rust-lang/rust/commit/544cb42d7aeaec230e10471820f48e561e3cd33d"}], "stats": {"total": 212, "additions": 181, "deletions": 31}, "files": [{"sha": "3af42db194e4ddcca2e498a3cfa79b8f16cb18a1", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36f1b38f8067503ef3936f9cb2b3b07012e681a6/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f1b38f8067503ef3936f9cb2b3b07012e681a6/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=36f1b38f8067503ef3936f9cb2b3b07012e681a6", "patch": "@@ -508,10 +508,10 @@ impl<'a, P: GenericPath> ToStr for Display<'a, P> {\n         if self.filename {\n             match self.path.filename() {\n                 None => ~\"\",\n-                Some(v) => from_utf8_with_replacement(v)\n+                Some(v) => str::from_utf8_lossy(v)\n             }\n         } else {\n-            from_utf8_with_replacement(self.path.as_vec())\n+            str::from_utf8_lossy(self.path.as_vec())\n         }\n     }\n }\n@@ -596,29 +596,6 @@ fn contains_nul(v: &[u8]) -> bool {\n     v.iter().any(|&x| x == 0)\n }\n \n-#[inline(always)]\n-fn from_utf8_with_replacement(mut v: &[u8]) -> ~str {\n-    // FIXME (#9516): Don't decode utf-8 manually here once we have a good way to do it in str\n-    // This is a truly horrifically bad implementation, done as a functionality stopgap until\n-    // we have a proper utf-8 decoder. I don't really want to write one here.\n-    static REPLACEMENT_CHAR: char = '\\uFFFD';\n-\n-    let mut s = str::with_capacity(v.len());\n-    while !v.is_empty() {\n-        let w = str::utf8_char_width(v[0]);\n-        if w == 0u {\n-            s.push_char(REPLACEMENT_CHAR);\n-            v = v.slice_from(1);\n-        } else if v.len() < w || !str::is_utf8(v.slice_to(w)) {\n-            s.push_char(REPLACEMENT_CHAR);\n-            v = v.slice_from(1);\n-        } else {\n-            s.push_str(unsafe { ::cast::transmute(v.slice_to(w)) });\n-            v = v.slice_from(w);\n-        }\n-    }\n-    s\n-}\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "25e15fc16018e7c7e6dda796415e3e5280be3305", "filename": "src/libstd/str.rs", "status": "modified", "additions": 179, "deletions": 6, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/36f1b38f8067503ef3936f9cb2b3b07012e681a6/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f1b38f8067503ef3936f9cb2b3b07012e681a6/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=36f1b38f8067503ef3936f9cb2b3b07012e681a6", "patch": "@@ -900,16 +900,122 @@ pub struct CharRange {\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n macro_rules! utf8_first_byte(\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n )\n \n // return the value of $ch updated with continuation byte $byte\n macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n )\n \n static TAG_CONT_U8: u8 = 128u8;\n \n+/// Converts a vector of bytes to a new utf-8 string.\n+/// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let input = bytes!(\"Hello \", 0xF0, 0x90, 0x80, \"World\");\n+/// let output = std::str::from_utf8_lossy(input);\n+/// assert_eq!(output, ~\"Hello \\uFFFDWorld\");\n+/// ```\n+pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n+    static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n+    let mut i = 0u;\n+    let mut lastgood = 0u;\n+    let total = v.len();\n+    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+        unsafe { *xs.unsafe_ref(i) }\n+    }\n+    fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n+        if i >= total {\n+            0\n+        } else {\n+            unsafe_get(xs, i)\n+        }\n+    }\n+    let mut res = with_capacity(total);\n+\n+    while i < total {\n+        let i_ = i;\n+        let byte = unsafe_get(v, i);\n+        i += 1;\n+\n+        macro_rules! error(() => {\n+            unsafe {\n+                if lastgood != i_ {\n+                    raw::push_bytes(&mut res, v.slice(lastgood, i_));\n+                }\n+                lastgood = i;\n+                raw::push_bytes(&mut res, REPLACEMENT);\n+            }\n+        })\n+\n+        if byte < 128u8 {\n+            // lastgood handles this\n+        } else {\n+            let w = utf8_char_width(byte);\n+\n+            match w {\n+                2 => {\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                }\n+                3 => {\n+                    match (byte, safe_get(v, i, total)) {\n+                        (0xE0        , 0xA0 .. 0xBF) => (),\n+                        (0xE1 .. 0xEC, 0x80 .. 0xBF) => (),\n+                        (0xED        , 0x80 .. 0x9F) => (),\n+                        (0xEE .. 0xEF, 0x80 .. 0xBF) => (),\n+                        _ => {\n+                            error!();\n+                            continue;\n+                        }\n+                    }\n+                    i += 1;\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                }\n+                4 => {\n+                    match (byte, safe_get(v, i, total)) {\n+                        (0xF0        , 0x90 .. 0xBF) => (),\n+                        (0xF1 .. 0xF3, 0x80 .. 0xBF) => (),\n+                        (0xF4        , 0x80 .. 0x8F) => (),\n+                        _ => {\n+                            error!();\n+                            continue;\n+                        }\n+                    }\n+                    i += 1;\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                }\n+                _ => {\n+                    error!();\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+    unsafe { raw::push_bytes(&mut res, v.slice(lastgood, total)) };\n+    res\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -2211,7 +2317,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n         // Multibyte case is a fn to allow char_range_at to inline cleanly\n         fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s[i] as uint;\n+            let mut val = s[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val] as uint;\n             assert!((w != 0));\n \n@@ -2220,7 +2326,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: unsafe { transmute(val as u32) }, next: i + w};\n+            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n         }\n \n         return multibyte_char_range_at(*self, i);\n@@ -2243,7 +2349,7 @@ impl<'a> StrSlice<'a> for &'a str {\n                 i -= 1u;\n             }\n \n-            let mut val = s[i] as uint;\n+            let mut val = s[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val] as uint;\n             assert!((w != 0));\n \n@@ -2252,7 +2358,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: unsafe { transmute(val as u32) }, next: i};\n+            return CharRange {ch: unsafe { transmute(val) }, next: i};\n         }\n \n         return multibyte_char_range_at_reverse(*self, prev);\n@@ -3834,6 +3940,37 @@ mod tests {\n         assert_eq!(from_utf8_owned(xs), None);\n     }\n \n+    #[test]\n+    fn test_str_from_utf8_lossy() {\n+        let xs = bytes!(\"hello\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"hello\");\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+\n+        let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD There\\uFFFD Goodbye\");\n+\n+        let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\");\n+\n+        let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\");\n+\n+        let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\");\n+\n+        let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\");\n+\n+        let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\");\n+\n+        // surrogates\n+        let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\");\n+    }\n+\n     #[test]\n     fn test_to_send_str() {\n         assert_eq!(\"abcde\".to_send_str(), SendStrStatic(\"abcde\"));\n@@ -3992,6 +4129,42 @@ mod bench {\n         });\n     }\n \n+    #[bench]\n+    fn from_utf8_lossy_100_ascii(bh: &mut BenchHarness) {\n+        let s = bytes!(\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                        Lorem ipsum dolor sit amet, consectetur. \");\n+\n+        assert_eq!(100, s.len());\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_multibyte(bh: &mut BenchHarness) {\n+        let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n+        assert_eq!(100, s.len());\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_invalid(bh: &mut BenchHarness) {\n+        let s = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_invalid(bh: &mut BenchHarness) {\n+        let s = ::vec::from_elem(100, 0xF5u8);\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n     #[bench]\n     fn bench_with_capacity(bh: &mut BenchHarness) {\n         bh.iter(|| {"}]}