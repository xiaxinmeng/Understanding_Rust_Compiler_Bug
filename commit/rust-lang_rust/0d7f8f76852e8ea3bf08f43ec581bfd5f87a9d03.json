{"sha": "0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkN2Y4Zjc2ODUyZThlYTNiZjA4ZjQzZWM1ODFiZmQ1Zjg3YTlkMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T15:03:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T15:03:57Z"}, "message": "auto merge of #7166 : brson/rust/fuzzer, r=pcwalton\n\nIt is suffering from a bad case of megabitrot. #5247", "tree": {"sha": "1ca6bfbe2e8b73e664bc1d374c23cf58681b8398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ca6bfbe2e8b73e664bc1d374c23cf58681b8398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "html_url": "https://github.com/rust-lang/rust/commit/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "html_url": "https://github.com/rust-lang/rust/commit/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2"}, {"sha": "069086cdb42d432d2354e6b894c5b1bf80320eec", "url": "https://api.github.com/repos/rust-lang/rust/commits/069086cdb42d432d2354e6b894c5b1bf80320eec", "html_url": "https://github.com/rust-lang/rust/commit/069086cdb42d432d2354e6b894c5b1bf80320eec"}], "stats": {"total": 1146, "additions": 0, "deletions": 1146}, "files": [{"sha": "fa4c327f06145c7ad518f0fa869b1933bbd7122c", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "patch": "@@ -208,7 +208,6 @@ CFG_STDLIB_$(1) :=$(call CFG_LIB_NAME_$(1),std)\n CFG_EXTRALIB_$(1) :=$(call CFG_LIB_NAME_$(1),extra)\n CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n-CFG_LIBFUZZER_$(1) :=$(call CFG_LIB_NAME_$(1),fuzzer)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n CFG_LIBRUSTI_$(1) :=$(call CFG_LIB_NAME_$(1),rusti)\n@@ -218,7 +217,6 @@ EXTRALIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),extra)\n STDLIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),std)\n LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n-LIBFUZZER_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),fuzzer)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n LIBRUSTI_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rusti)\n@@ -227,7 +225,6 @@ EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n STDLIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),std)\n LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n-LIBFUZZER_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),fuzzer)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n LIBRUSTI_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rusti)\n@@ -402,12 +399,10 @@ SREQ$(1)_T_$(2)_H_$(3) = \\\n # Prerequisites for a working stageN compiler and libraries, for a specific target\n CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(HBIN$(1)_H_$(3))/fuzzer$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustpkg$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rusti$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rust$$(X_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/$(CFG_LIBFUZZER_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTPKG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOC_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTI_$(3)) \\\n@@ -416,7 +411,6 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBFUZZER_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2)) \\"}, {"sha": "23efbb3ee15c44957df4664d41580d7346f88136", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "patch": "@@ -63,13 +63,11 @@ define CLEAN_HOST_STAGE_N\n \n clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustc$(X_$(2))\n-\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/fuzzer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/serializer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rusti$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rust$(X_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBFUZZER_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUNTIME_$(2))\n@@ -83,7 +81,6 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBFUZZER_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB_$(2))\n@@ -101,13 +98,11 @@ define CLEAN_TARGET_STAGE_N\n \n clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$(X_$(2))\n-\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/fuzzer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/serializer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rusti$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rust$(X_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBFUZZER_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME_$(2))\n@@ -121,7 +116,6 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBFUZZER_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTI_GLOB_$(2))"}, {"sha": "912b692a247e2be0254432049b50740b287f41e2", "filename": "mk/dist.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "patch": "@@ -32,7 +32,6 @@ PKG_FILES := \\\n       librustc                                 \\\n       compiletest                              \\\n       etc                                      \\\n-      libfuzzer                                \\\n       libextra                                 \\\n       libstd                                   \\\n       libsyntax                                \\"}, {"sha": "f86bbb7f2812b0d10707b9535c90d475f62b2e8f", "filename": "mk/pp.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Fpp.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Fpp.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fpp.mk?ref=0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "patch": "@@ -17,7 +17,6 @@ else\n               $(wildcard $(addprefix $(S)src/rustc/,*.rs */*.rs */*/*.rs)) \\\n               $(wildcard $(S)src/test/*/*.rs    \\\n                          $(S)src/test/*/*/*.rs) \\\n-              $(wildcard $(S)src/fuzzer/*.rs)   \\\n               $(wildcard $(S)src/rustpkg/*.rs) \\\n               $(wildcard $(S)src/rusti/*.rs) \\\n               $(wildcard $(S)src/rust/*.rs)"}, {"sha": "8319d8d4e4835fee4c1879d6038358b3aedbe4a0", "filename": "mk/tools.mk", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "patch": "@@ -11,9 +11,6 @@\n # Rules for non-core tools built with the compiler, both for target\n # and host architectures\n \n-FUZZER_LIB := $(S)src/libfuzzer/fuzzer.rc\n-FUZZER_INPUTS := $(wildcard $(addprefix $(S)src/libfuzzer/, *.rs))\n-\n # The test runner that runs the cfail/rfail/rpass and bxench tests\n COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rc\n COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*rs)\n@@ -38,21 +35,6 @@ RUST_INPUTS := $(wildcard $(S)src/librust/*.rs)\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N_TARGET\n \n-$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBFUZZER_$(4)):          \\\n-\t\t$$(FUZZER_LIB) $$(FUZZER_INPUTS)\t\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_STDLIB_$(4))\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_EXTRALIB_$(4))\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n-\n-$$(TBIN$(1)_T_$(4)_H_$(3))/fuzzer$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(DRIVER_CRATE)\t\t\t\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBFUZZER_$(4))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg fuzzer -o $$@ $$<\n-\n $$(TBIN$(1)_T_$(4)_H_$(3))/compiletest$$(X_$(4)):\t\t\t\\\n \t\t$$(COMPILETEST_CRATE) $$(COMPILETEST_INPUTS)\t\\\n \t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\t\\\n@@ -128,27 +110,6 @@ endef\n \n define TOOLS_STAGE_N_HOST\n \n-\n-# Promote the stageN target to stageN+1 host\n-# FIXME: Shouldn't need to depend on host/librustc.so once\n-# rpath is working\n-$$(HLIB$(2)_H_$(4))/$(CFG_LIBFUZZER_$(4)):\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBFUZZER_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4))\t\t\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBFUZZER_GLOB_$(4)) \\\n-\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBFUZZER_DSYM_GLOB_$(4))) \\\n-\t        $$(HLIB$(2)_H_$(4))\n-\n-$$(HBIN$(2)_H_$(4))/fuzzer$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/fuzzer$$(X_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBFUZZER_$(4))\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n $$(HBIN$(2)_H_$(4))/compiletest$$(X_$(4)):\t\t\t\t\\\n \t\t$$(TBIN$(1)_T_$(4)_H_$(3))/compiletest$$(X_$(4))\t\\\n \t\t$$(HSREQ$(2)_H_$(4))"}, {"sha": "ccedd3adbaa9bcc7b59fca673a474df317ab00c8", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=0d7f8f76852e8ea3bf08f43ec581bfd5f87a9d03", "patch": "@@ -16,9 +16,6 @@ extern mod core(name = \"std\", vers = \"0.7-pre\");\n #[cfg(rustpkg)]\n extern mod this(name = \"rustpkg\");\n \n-#[cfg(fuzzer)]\n-extern mod this(name = \"fuzzer\");\n-\n #[cfg(rustdoc)]\n extern mod this(name = \"rustdoc\");\n "}, {"sha": "7d623919ff9365f70c36f3689e248ec0fff6cc7a", "filename": "src/libfuzzer/ast_match.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::prelude::*;\n-\n-use vec;\n-\n-fn vec_equal<T>(v: ~[T],\n-                u: ~[T],\n-                element_equality_test: @fn(&&T, &&T) -> bool) ->\n-   bool {\n-    let Lv = v.len();\n-    if Lv != u.len() { return false; }\n-    let i = 0u;\n-    while i < Lv {\n-        if !element_equality_test(v[i], u[i]) { return false; }\n-        i += 1u;\n-    }\n-    return true;\n-}\n-\n-fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n-fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n-\n-fn main() {\n-    assert!((builtin_equal(5, 5)));\n-    assert!((!builtin_equal(5, 4)));\n-    assert!((!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _))));\n-    assert!((!vec_equal(~[5, 5], ~[5], builtin_equal_int)));\n-    assert!((!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int)));\n-    assert!((!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int)));\n-    assert!((vec_equal(~[5, 5], ~[5, 5], builtin_equal_int)));\n-\n-    error!(\"Pass\");\n-}"}, {"sha": "2256325fa43765103dc7b57eae8eb5b6404fcb27", "filename": "src/libfuzzer/cycles.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "patch": "@@ -1,108 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use extra;\n-use extra::rand;\n-use uint::range;\n-\n-// random uint less than n\n-fn under(r : rand::rng, n : uint) -> uint {\n-    assert!(n != 0u); r.next() as uint % n\n-}\n-\n-// random choice from a vec\n-fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n-    assert!(v.len() != 0u); v[under(r, v.len())]\n-}\n-\n-// k in n chance of being true\n-fn likelihood(r : rand::rng, k : uint, n : uint) -> bool { under(r, n) < k }\n-\n-\n-static iters : uint = 1000u;\n-static vlen  : uint = 100u;\n-\n-enum maybe_pointy {\n-    none,\n-    p(@pointy)\n-}\n-\n-type pointy = {\n-    mut a : maybe_pointy,\n-    mut b : ~maybe_pointy,\n-    mut c : @maybe_pointy,\n-\n-    mut f : @fn()->(),\n-    mut g : ~fn()->(),\n-\n-    mut m : ~[maybe_pointy],\n-    mut n : ~[maybe_pointy],\n-    mut o : {x : int, y : maybe_pointy}\n-};\n-// To add: objects; traits; anything type-parameterized?\n-\n-fn empty_pointy() -> @pointy {\n-    return @{\n-        mut a : none,\n-        mut b : ~none,\n-        mut c : @none,\n-\n-        mut f : || {},\n-        mut g : || {},\n-\n-        mut m : ~[],\n-        mut n : ~[],\n-        mut o : {x : 0, y : none}\n-    }\n-}\n-\n-fn nopP(_x : @pointy) { }\n-fn nop<T>(_x: T) { }\n-\n-fn test_cycles(r : rand::rng, k: uint, n: uint)\n-{\n-    let mut v : ~[@pointy] = ~[];\n-\n-    // Create a graph with no edges\n-    range(0u, vlen) {|_i|\n-        v.push(empty_pointy());\n-    }\n-\n-    // Fill in the graph with random edges, with density k/n\n-    range(0u, vlen) {|i|\n-        if (likelihood(r, k, n)) { v[i].a = p(choice(r, v)); }\n-        if (likelihood(r, k, n)) { v[i].b = ~p(choice(r, v)); }\n-        if (likelihood(r, k, n)) { v[i].c = @p(choice(r, v)); }\n-\n-        if (likelihood(r, k, n)) { v[i].f = bind nopP(choice(r, v)); }\n-        //if (false)               { v[i].g = bind (|_: @pointy| { })(\n-        // choice(r, v)); }\n-          // https://github.com/mozilla/rust/issues/1899\n-\n-        if (likelihood(r, k, n)) { v[i].m = [p(choice(r, v))]; }\n-        if (likelihood(r, k, n)) { v[i].n.push(mut p(choice(r, v))); }\n-        if (likelihood(r, k, n)) { v[i].o = {x: 0, y: p(choice(r, v))}; }\n-    }\n-\n-    // Drop refs one at a time\n-    range(0u, vlen) {|i|\n-        v[i] = empty_pointy()\n-    }\n-}\n-\n-fn main()\n-{\n-    let r = rand::rng();\n-    range(0u, iters) {|i|\n-        test_cycles(r, i, iters);\n-    }\n-}"}, {"sha": "4e2103fcd7047ba4dbf15e70776f2e2be0f87a0f", "filename": "src/libfuzzer/fuzzer.rc", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "patch": "@@ -1,713 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#[link(name = \"fuzzer\",\n-       vers = \"0.7-pre\",\n-       uuid = \"d6418797-2736-4833-bd82-d3c684b7c1b0\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/libfuzzer\")];\n-\n-#[comment = \"The Rust fuzzer library\"];\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-#[allow(non_camel_case_types)];\n-\n-#[no_std];\n-\n-extern mod std(name = \"std\", vers = \"0.7-pre\");\n-extern mod extra(name = \"extra\", vers = \"0.7-pre\");\n-\n-extern mod syntax(vers = \"0.7-pre\");\n-\n-use std::prelude::*;\n-\n-use std::int;\n-use std::io;\n-use std::option;\n-use std::os;\n-use std::result;\n-use std::run;\n-use std::str;\n-use std::uint;\n-\n-use syntax::diagnostic;\n-use syntax::parse::token::ident_interner;\n-use syntax::parse::token;\n-use syntax::parse;\n-use syntax::print::pprust;\n-use syntax::{ast, fold, visit, codemap};\n-\n-#[deriving(Eq)]\n-pub enum test_mode { tm_converge, tm_run, }\n-\n-pub struct Context { mode: test_mode } // + rng\n-\n-pub fn write_file(filename: &Path, content: &str) {\n-    result::get(&io::file_writer(filename, [io::Create, io::Truncate]))\n-                    .write_str(content);\n-}\n-\n-pub fn contains(haystack: &str, needle: &str) -> bool {\n-    haystack.contains(needle)\n-}\n-\n-pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n-    if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), \"utf8\") {\n-        // ignoring \"utf8\" tests because something is broken\n-        files.push(path.clone());\n-    } else if os::path_is_dir(path)\n-        && !contains(path.to_str(), \"compile-fail\")\n-        && !contains(path.to_str(), \"build\") {\n-        for os::list_dir_path(path).each |p| {\n-            find_rust_files(&mut *files, *p);\n-        }\n-    }\n-}\n-\n-\n-pub fn common_exprs() -> ~[@ast::expr] {\n-    fn dse(e: ast::expr_) -> @ast::expr {\n-        @ast::expr {\n-            id: 0,\n-            node: e,\n-            span: codemap::dummy_sp(),\n-        }\n-    }\n-\n-    fn dsl(l: ast::lit_) -> ast::lit {\n-        codemap::spanned { node: l, span: codemap::dummy_sp() }\n-    }\n-\n-    ~[dse(ast::expr_break(option::None)),\n-     dse(ast::expr_again(option::None)),\n-     dse(ast::expr_ret(option::None)),\n-     dse(ast::expr_lit(@dsl(ast::lit_nil))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(-1, ast::box(ast::m_imm),\n-                         dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(-1, ast::uniq(ast::m_imm),\n-                         dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n-    ]\n-}\n-\n-pub fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    safe_to_use_expr(e, tm)\n-}\n-\n-pub fn safe_to_use_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    match tm {\n-      tm_converge => {\n-        match e.node {\n-          // If the fuzzer moves a block-ending-in-semicolon into callee\n-          // position, the pretty-printer can't preserve this even by\n-          // parenthesizing!!  See email to marijn.\n-          ast::expr_if(*) | ast::expr_block(*)\n-          | ast::expr_match(*) | ast::expr_while(*)  => { false }\n-\n-          // https://github.com/mozilla/rust/issues/929\n-          ast::expr_cast(*) | ast::expr_binary(*) | ast::expr_assign(*) |\n-          ast::expr_assign_op(*) => { false }\n-\n-          ast::expr_ret(option::None) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/953\n-          //ast::expr_fail(option::Some(_)) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/928\n-          //ast::expr_cast(_, _) { false }\n-\n-          // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(*) => { false }\n-\n-          _ => { true }\n-        }\n-      }\n-      tm_run => { true }\n-    }\n-}\n-\n-pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n-    // Restrictions happen to be the same.\n-    safe_to_replace_ty(&t.node, tm)\n-}\n-\n-// Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n-pub fn stash_expr_if(c: @fn(@ast::expr, test_mode)->bool,\n-                     es: @mut ~[@ast::expr],\n-                     e: @ast::expr,\n-                     tm: test_mode) {\n-    if c(e, tm) {\n-        *es = *es + [e];\n-    } else {\n-        /* now my indices are wrong :( */\n-    }\n-}\n-\n-pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode) -> bool,\n-                   es: @mut ~[@ast::Ty],\n-                   e: @ast::Ty,\n-                   tm: test_mode) {\n-    if c(e, tm) {\n-        es.push(e);\n-    } else {\n-        /* now my indices are wrong :( */\n-    }\n-}\n-\n-pub struct StolenStuff {\n-    exprs: ~[@ast::expr],\n-    tys: ~[@ast::Ty]\n-}\n-\n-pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n-    let exprs = @mut ~[];\n-    let tys = @mut ~[];\n-    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n-        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n-        .. *visit::default_simple_visitor()\n-    });\n-    visit::visit_crate(crate, ((), v));\n-    StolenStuff {\n-        exprs: (*exprs).clone(),\n-        tys: (*tys).clone(),\n-    }\n-}\n-\n-\n-pub fn safe_to_replace_expr(e: &ast::expr_, _tm: test_mode) -> bool {\n-    match *e {\n-        // https://github.com/mozilla/rust/issues/652\n-        ast::expr_if(*) => false,\n-        ast::expr_block(_) => false,\n-\n-        // expr_call is also missing a constraint\n-        ast::expr_fn_block(*) => false,\n-\n-        _ => true,\n-    }\n-}\n-\n-pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n-    match *t {\n-      ast::ty_infer => { false } // always implicit, always top level\n-      ast::ty_bot => { false }   // in source, can only appear\n-                              // as the out type of a function\n-      ast::ty_mac(_) => { false }\n-      _ => { true }\n-    }\n-}\n-\n-// Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-pub fn replace_expr_in_crate(crate: @ast::crate,\n-                             i: uint,\n-                             newexpr: @ast::expr,\n-                             tm: test_mode)\n-                             -> @ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_expr_rep(j_: @mut uint,\n-                     i_: uint,\n-                     newexpr_: &ast::expr_,\n-                     original: &ast::expr_,\n-                     fld: @fold::ast_fold,\n-                     tm_: test_mode)\n-                     -> ast::expr_ {\n-        *j_ += 1;\n-        if i_ + 1 == *j_ && safe_to_replace_expr(original, tm_) {\n-            copy *newexpr_\n-        } else {\n-            fold::noop_fold_expr(original, fld)\n-        }\n-    }\n-    let afp = @fold::AstFoldFns {\n-        fold_expr: fold::wrap(|a,b| {\n-            fold_expr_rep(j, i, &newexpr.node, a, b, tm)\n-        }),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    crate2\n-}\n-\n-\n-// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-pub fn replace_ty_in_crate(crate: @ast::crate,\n-                           i: uint,\n-                           newty: @ast::Ty,\n-                           tm: test_mode)\n-                           -> @ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_ty_rep(j_: @mut uint,\n-                   i_: uint,\n-                   newty_: &ast::ty_,\n-                   original: &ast::ty_,\n-                   fld: @fold::ast_fold,\n-                   tm_: test_mode)\n-                   -> ast::ty_ {\n-        *j_ += 1;\n-        if i_ + 1 == *j_ && safe_to_replace_ty(original, tm_) {\n-            copy *newty_\n-        } else {\n-            fold::noop_fold_ty(original, fld)\n-        }\n-    }\n-    let afp = @fold::AstFoldFns {\n-        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, &newty.node, a, b, tm)),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    crate2\n-}\n-\n-pub fn under(n: uint, it: &fn(uint)) {\n-    let mut i: uint = 0u;\n-    while i < n { it(i); i += 1u; }\n-}\n-\n-pub fn as_str(f: @fn(x: @io::Writer)) -> ~str {\n-    io::with_str_writer(f)\n-}\n-\n-pub fn check_variants_of_ast(crate: @ast::crate,\n-                             codemap: @codemap::CodeMap,\n-                             filename: &Path,\n-                             cx: Context) {\n-    let stolen = steal(crate, cx.mode);\n-    let extra_exprs = do common_exprs().filtered |&a| {\n-        safe_to_use_expr(a, cx.mode)\n-    };\n-    check_variants_T(crate,\n-                     codemap,\n-                     filename,\n-                     ~\"expr\",\n-                     extra_exprs + stolen.exprs,\n-                     pprust::expr_to_str,\n-                     replace_expr_in_crate,\n-                     cx);\n-    check_variants_T(crate,\n-                     codemap,\n-                     filename,\n-                     ~\"ty\",\n-                     stolen.tys,\n-                     pprust::ty_to_str,\n-                     replace_ty_in_crate,\n-                     cx);\n-}\n-\n-pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n-                                codemap: @codemap::CodeMap,\n-                                filename: &Path,\n-                                thing_label: ~str,\n-                                things: &[T],\n-                                stringifier: @fn(T, @ident_interner) -> ~str,\n-                                replacer: @fn(@ast::crate,\n-                                              uint,\n-                                              T,\n-                                              test_mode)\n-                                              -> @ast::crate,\n-                                cx: Context) {\n-    error!(\"%s contains %u %s objects\", filename.to_str(),\n-           things.len(), thing_label);\n-\n-    // Assuming we're not generating any token_trees\n-    let intr = syntax::parse::token::mk_fake_ident_interner();\n-\n-    let L = things.len();\n-\n-    if L < 100 {\n-        do under(uint::min(L, 20)) |i| {\n-            error!(\"Replacing... #%?\", uint::to_str(i));\n-            let fname = str::to_owned(filename.to_str());\n-            do under(uint::min(L, 30)) |j| {\n-                let fname = fname.to_str();\n-                error!(\"With... %?\", stringifier(things[j], intr));\n-                let crate2 = replacer(crate, i, things[j], cx.mode);\n-                // It would be best to test the *crate* for stability, but\n-                // testing the string for stability is easier and ok for now.\n-                let handler = diagnostic::mk_handler(None);\n-                let str3 = do io::with_str_reader(\"\") |rdr| {\n-                    let fname = fname.to_str();\n-                    let string = do as_str |a| {\n-                        let span_handler =\n-                            diagnostic::mk_span_handler(handler, codemap);\n-                        pprust::print_crate(codemap,\n-                                            intr,\n-                                            span_handler,\n-                                            crate2,\n-                                            fname.to_managed(),\n-                                            rdr,\n-                                            a,\n-                                            pprust::no_ann(),\n-                                            false)\n-                    };\n-                    string.to_managed()\n-                };\n-                match cx.mode {\n-                    tm_converge => check_roundtrip_convergence(str3, 1),\n-                    tm_run => {\n-                        let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                              last_part(filename.to_str()),\n-                                              thing_label,\n-                                              i,\n-                                              j);\n-                        let safe_to_run = !(content_is_dangerous_to_run(str3)\n-                                            || has_raw_pointers(crate2));\n-                        check_whole_compiler(str3,\n-                                             &Path(file_label),\n-                                             safe_to_run);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn last_part(filename: ~str) -> ~str {\n-    let ix = filename.rfind('/').get();\n-    filename.slice(ix + 1u, filename.len() - 3u).to_owned()\n-}\n-\n-pub enum happiness {\n-    passed,\n-    cleanly_rejected(~str),\n-    known_bug(~str),\n-    failed(~str),\n-}\n-\n-// We'd find more bugs if we could take an AST here, but\n-// - that would find many \"false positives\" or unimportant bugs\n-// - that would be tricky, requiring use of tasks or serialization\n-//   or randomness.\n-// This seems to find plenty of bugs as it is :)\n-pub fn check_whole_compiler(code: &str,\n-                            suggested_filename_prefix: &Path,\n-                            allow_running: bool) {\n-    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n-    write_file(filename, code);\n-\n-    let compile_result = check_compiling(filename);\n-\n-    let run_result = match (compile_result, allow_running) {\n-      (passed, true) => { check_running(suggested_filename_prefix) }\n-      (h, _) => { h }\n-    };\n-\n-    match run_result {\n-      passed | cleanly_rejected(_) | known_bug(_) => {\n-        removeIfExists(suggested_filename_prefix);\n-        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n-        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n-      }\n-      failed(s) => {\n-        error!(\"check_whole_compiler failure: %?\", s);\n-        error!(\"Saved as: %?\", filename.to_str());\n-      }\n-    }\n-}\n-\n-pub fn removeIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert!(!contains(filename.to_str(), \" \"));\n-    run::process_status(\"bash\", [~\"-c\", ~\"rm \" + filename.to_str()]);\n-}\n-\n-pub fn removeDirIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert!(!contains(filename.to_str(), \" \"));\n-    run::process_status(\"bash\", [~\"-c\", ~\"rm -r \" + filename.to_str()]);\n-}\n-\n-pub fn check_running(exe_filename: &Path) -> happiness {\n-    let p = run::process_output(\n-        \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n-        [exe_filename.to_str()]);\n-    let comb = str::from_bytes(p.output) + \"\\n\" + str::from_bytes(p.error);\n-    if comb.len() > 1u {\n-        error!(\"comb comb comb: %?\", comb);\n-    }\n-\n-    if contains(comb, \"Assertion failed:\") {\n-        failed(~\"C++ assertion failure\")\n-    } else if contains(comb, \"leaked memory in rust main loop\") {\n-        // might also use exit code 134\n-        //failed(\"Leaked\")\n-        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n-    } else if contains(comb, \"src/rt/\") {\n-        failed(~\"Mentioned src/rt/\")\n-    } else if contains(comb, \"malloc\") {\n-        failed(~\"Mentioned malloc\")\n-    } else {\n-        match p.status {\n-            0         => { passed }\n-            100       => { cleanly_rejected(~\"running: explicit fail\") }\n-            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n-            245 | 246 | 138 | 252 => {\n-              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n-            }\n-            136 | 248 => {\n-              known_bug(\n-                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n-            }\n-            rc => {\n-              failed(~\"Rust program ran but exited with status \" +\n-                     int::to_str(rc))\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check_compiling(filename: &Path) -> happiness {\n-    let p = run::process_output(\n-        \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/stage1/bin/rustc\",\n-        [filename.to_str()]);\n-\n-    let out = str::from_bytes(p.output);\n-    let err = str::from_bytes(p.error);\n-\n-    //error!(\"Status: %d\", p.status);\n-    if p.status == 0 {\n-        passed\n-    } else if !err.is_empty() {\n-        if err.contains(\"error:\") {\n-            cleanly_rejected(~\"rejected with span_error\")\n-        } else {\n-            error!(\"Stderr: %?\", err);\n-            failed(~\"Unfamiliar error message\")\n-        }\n-    } else if out.contains(\"Assertion\") && out.contains(\"failed\") {\n-        error!(\"Stdout: %?\", out);\n-        failed(~\"Looks like an llvm assertion failure\")\n-    } else if out.contains(\"internal compiler error unimplemented\") {\n-        known_bug(~\"Something unimplemented\")\n-    } else if out.contains(\"internal compiler error\") {\n-        error!(\"Stdout: %?\", out);\n-        failed(~\"internal compiler error\")\n-\n-    } else {\n-        error!(\"%?\", p.status);\n-        error!(\"!Stdout: %?\", out);\n-        failed(~\"What happened?\")\n-    }\n-}\n-\n-\n-pub fn parse_and_print(code: @str) -> @str {\n-    let filename = Path(\"tmp.rs\");\n-    let sess = parse::new_parse_sess(option::None);\n-    write_file(&filename, code);\n-    let crate = parse::parse_crate_from_source_str(filename.to_str().to_managed(),\n-                                                   code,\n-                                                   ~[],\n-                                                   sess);\n-    do io::with_str_reader(code) |rdr| {\n-        let filename = filename.to_str();\n-        do as_str |a| {\n-            pprust::print_crate(sess.cm,\n-                                // Assuming there are no token_trees\n-                                token::mk_fake_ident_interner(),\n-                                copy sess.span_diagnostic,\n-                                crate,\n-                                filename.to_managed(),\n-                                rdr,\n-                                a,\n-                                pprust::no_ann(),\n-                                false)\n-        }.to_managed()\n-    }\n-}\n-\n-pub fn has_raw_pointers(c: @ast::crate) -> bool {\n-    let has_rp = @mut false;\n-    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n-        match t.node {\n-          ast::ty_ptr(_) => { *flag = true; }\n-          _ => { }\n-        }\n-    }\n-    let v =\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_ty: |a| visit_ty(has_rp, a),\n-            .. *visit::default_simple_visitor()});\n-    visit::visit_crate(c, ((), v));\n-    return *has_rp;\n-}\n-\n-pub fn content_is_dangerous_to_run(code: &str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"import\",  // espeically fs, run\n-         ~\"extern\",\n-         ~\"unsafe\",\n-         ~\"log\"];    // python --> rust pipe deadlock?\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-pub fn content_is_dangerous_to_compile(code: &str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\"];\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-pub fn content_might_not_converge(code: &str) -> bool {\n-    let confusing_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"xfail-pretty\",\n-         ~\"self\",       // crazy rules enforced by parser not typechecker?\n-         ~\"spawn\",      // precedence issues?\n-         ~\"bind\",       // precedence issues?\n-         ~\" be \",       // don't want to replace its child with a non-call:\n-                       // \"Non-call expression in tail call\"\n-         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n-        ];\n-\n-    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-pub fn file_might_not_converge(filename: &Path) -> bool {\n-    let confusing_files = ~[\n-      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n-                     // vs \"a = b = c\" and wrapping\n-      ~\"block-arg-in-ternary.rs\", // wrapping\n-      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n-      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n-    ];\n-\n-\n-    for confusing_files.each |f| {\n-        if contains(filename.to_str(), *f) {\n-            return true;\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-pub fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n-    let mut i = 0u;\n-    let mut newv = code;\n-    let mut oldv = code;\n-\n-    while i < maxIters {\n-        oldv = newv;\n-        if content_might_not_converge(oldv) { return; }\n-        newv = parse_and_print(oldv);\n-        if oldv == newv { break; }\n-        i += 1u;\n-    }\n-\n-    if oldv == newv {\n-        error!(\"Converged after %u iterations\", i);\n-    } else {\n-        error!(\"Did not converge after %u iterations!\", i);\n-        write_file(&Path(\"round-trip-a.rs\"), oldv);\n-        write_file(&Path(\"round-trip-b.rs\"), newv);\n-        run::process_status(\"diff\", [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\", ~\"round-trip-b.rs\"]);\n-        fail!(\"Mismatch\");\n-    }\n-}\n-\n-pub fn check_convergence(files: &[Path]) {\n-    error!(\"pp convergence tests: %u files\", files.len());\n-    for files.each |file| {\n-        if !file_might_not_converge(file) {\n-            let s = result::get(&io::read_whole_file_str(file)).to_managed();\n-            if !content_might_not_converge(s) {\n-                error!(\"pp converge: %s\", file.to_str());\n-                // Change from 7u to 2u once\n-                // https://github.com/mozilla/rust/issues/850 is fixed\n-                check_roundtrip_convergence(s, 7u);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check_variants(files: &[Path], cx: Context) {\n-    for files.each |file| {\n-        if cx.mode == tm_converge &&\n-            file_might_not_converge(file) {\n-            error!(\"Skipping convergence test based on\\\n-                    file_might_not_converge\");\n-            loop;\n-        }\n-\n-        let s = result::get(&io::read_whole_file_str(file)).to_managed();\n-        if s.contains_char('#') {\n-            loop; // Macros are confusing\n-        }\n-        if cx.mode == tm_converge && content_might_not_converge(s) {\n-            loop;\n-        }\n-        if cx.mode == tm_run && content_is_dangerous_to_compile(s) {\n-            loop;\n-        }\n-\n-        let file_str = file.to_str();\n-\n-        error!(\"check_variants: %?\", file_str);\n-        let sess = parse::new_parse_sess(None);\n-        let crate = parse::parse_crate_from_source_str(file_str.to_managed(),\n-                                                       s,\n-                                                       ~[],\n-                                                       sess);\n-        io::with_str_reader(s, |rdr| {\n-            let file_str = file_str.to_str();\n-            error!(\"%s\",\n-                   as_str(|a| {\n-                    pprust::print_crate(\n-                        sess.cm,\n-                        // Assuming no token_trees\n-                        token::mk_fake_ident_interner(),\n-                        copy sess.span_diagnostic,\n-                        crate,\n-                        file_str.to_managed(),\n-                        rdr,\n-                        a,\n-                        pprust::no_ann(),\n-                        false)\n-                    }))\n-        });\n-        check_variants_of_ast(crate, sess.cm, file, cx);\n-    }\n-}\n-\n-pub fn main() {\n-    let args = os::args();\n-    if args.len() != 2u {\n-        error!(\"usage: %s <testdir>\", args[0]);\n-        return;\n-    }\n-    let mut files = ~[];\n-    let root = Path(args[1]);\n-\n-    find_rust_files(&mut files, &root);\n-    error!(\"== check_convergence ==\");\n-    check_convergence(files);\n-    error!(\"== check_variants: converge ==\");\n-    check_variants(files, Context { mode: tm_converge });\n-    error!(\"== check_variants: run ==\");\n-    check_variants(files, Context { mode: tm_run });\n-\n-    error!(\"Fuzzer done\");\n-}\n-\n-// For bootstrapping purposes...\n-pub mod core {\n-    pub use std::cmp;\n-    pub use std::sys;\n-}"}, {"sha": "8f019a14eedb3f6fb4341b57bb21450c19637463", "filename": "src/libfuzzer/ivec_fuzz.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fivec_fuzz.rs?ref=ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "patch": "@@ -1,121 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-\n-Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n-\n-  two functions, \"return all edits\" and \"return a random edit\" = move-\n-    leaning toward this model or two functions, \"return the number of\n-    possible edits\" and \"return edit #n\"\n-\n-It would be nice if this could be data-driven, so the two functions\n-could share information:\n-  type vec_modifier = rec(fn (<T> v, uint i) -> ~[T] fun, uint lo, uint di);\n-  const ~[vec_modifier] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...]/~;\n-But that gives me \"error: internal compiler error unimplemented consts\n-that's not a plain literal\".\n-https://github.com/graydon/rust/issues/570\n-\n-vec_edits is not an iter because iters might go away.\n-\n-*/\n-\n-use std::prelude::*;\n-\n-use vec::slice;\n-use vec::len;\n-\n-fn vec_omit<T:copy>(v: ~[T], i: uint) -> ~[T] {\n-    slice(v, 0u, i) + slice(v, i + 1u, len(v))\n-}\n-fn vec_dup<T:copy>(v: ~[T], i: uint) -> ~[T] {\n-    slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n-}\n-fn vec_swadj<T:copy>(v: ~[T], i: uint) -> ~[T] {\n-    slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n-}\n-fn vec_prefix<T:copy>(v: ~[T], i: uint) -> ~[T] { slice(v, 0u, i) }\n-fn vec_suffix<T:copy>(v: ~[T], i: uint) -> ~[T] { slice(v, i, len(v)) }\n-\n-fn vec_poke<T:copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n-    slice(v, 0u, i) + ~[x] + slice(v, i + 1u, len(v))\n-}\n-fn vec_insert<T:copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n-    slice(v, 0u, i) + ~[x] + slice(v, i, len(v))\n-}\n-\n-// Iterates over 0...length, skipping the specified number on each side.\n-fn ix(skip_low: uint, skip_high: uint, length: uint, it: block(uint)) {\n-    let i: uint = skip_low;\n-    while i + skip_high <= length { it(i); i += 1u; }\n-}\n-\n-// Returns a bunch of modified versions of v, some of which introduce\n-// new elements (borrowed from xs).\n-fn vec_edits<T:copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n-    let edits: ~[~[T]] = ~[];\n-    let Lv: uint = len(v);\n-\n-    if Lv != 1u {\n-        // When Lv == 1u, this is redundant with omit.\n-        edits.push(~[]);\n-    }\n-    if Lv >= 3u {\n-        // When Lv == 2u, this is redundant with swap.\n-        edits.push(vec::reversed(v));\n-    }\n-    ix(0u, 1u, Lv) {|i| edits += ~[vec_omit(v, i)]; }\n-    ix(0u, 1u, Lv) {|i| edits += ~[vec_dup(v, i)]; }\n-    ix(0u, 2u, Lv) {|i| edits += ~[vec_swadj(v, i)]; }\n-    ix(1u, 2u, Lv) {|i| edits += ~[vec_prefix(v, i)]; }\n-    ix(2u, 1u, Lv) {|i| edits += ~[vec_suffix(v, i)]; }\n-\n-    ix(0u, 1u, len(xs)) {|j|\n-        ix(0u, 1u, Lv) {|i|\n-            edits.push(vec_poke(v, i, xs[j]));\n-        }\n-        ix(0u, 0u, Lv) {|i|\n-            edits.push(vec_insert(v, i, xs[j]));\n-        }\n-    }\n-\n-    edits\n-}\n-\n-// Would be nice if this were built in:\n-// https://github.com/graydon/rust/issues/424\n-fn vec_to_str(v: ~[int]) -> str {\n-    let i = 0u;\n-    let s = \"[\";\n-    while i < len(v) {\n-        s += int::str(v[i]);\n-        if i + 1u < len(v) { s += \", \"; }\n-        i += 1u;\n-    }\n-    return s + \"]\";\n-}\n-\n-fn show_edits(a: ~[int], xs: ~[int]) {\n-    log(error, \"=== Edits of \" + vec_to_str(a) + \" ===\");\n-    let b = vec_edits(a, xs);\n-    ix(0u, 1u, len(b)) {|i| log(error, vec_to_str(b[i])); }\n-}\n-\n-fn demo_edits() {\n-    let xs = ~[7, 8];\n-    show_edits(~[], xs);\n-    show_edits(~[1], xs);\n-    show_edits(~[1, 2], xs);\n-    show_edits(~[1, 2, 3], xs);\n-    show_edits(~[1, 2, 3, 4], xs);\n-}\n-\n-fn main() { demo_edits(); }"}, {"sha": "abc6b1cfc0af1361536a0e066f8b11186fce3f6f", "filename": "src/libfuzzer/rand_util.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebca26cd542e2e733bf11c7be7b541b54b0f9ef2/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=ebca26cd542e2e733bf11c7be7b541b54b0f9ef2", "patch": "@@ -1,106 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::prelude::*;\n-use extra::rand;\n-\n-// random uint less than n\n-fn under(r : rand::rng, n : uint) -> uint {\n-    assert!(n != 0u); r.next() as uint % n\n-}\n-\n-// random choice from a vec\n-fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n-    assert!(v.len() != 0u); v[under(r, v.len())]\n-}\n-\n-// 1 in n chance of being true\n-fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n-\n-// shuffle a vec in place\n-fn shuffle<T>(r : rand::rng, &v : ~[T]) {\n-    let i = v.len();\n-    while i >= 2u {\n-        // Loop invariant: elements with index >= i have been locked in place.\n-        i -= 1u;\n-        vec::swap(v, i, under(r, i + 1u)); // Lock element i in place.\n-    }\n-}\n-\n-// create a shuffled copy of a vec\n-fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n-    let w = vec::to_mut(v);\n-    shuffle(r, w);\n-    vec::from_mut(w) // Shouldn't this happen automatically?\n-}\n-\n-// sample from a population without replacement\n-//fn sample<T>(r : rand::rng, pop : ~[T], k : uint) -> ~[T] { fail!() }\n-\n-// Two ways to make a weighted choice.\n-// * weighted_choice is O(number of choices) time\n-// * weighted_vec is O(total weight) space\n-type weighted<T> = { weight: uint, item: T };\n-fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n-    assert!(v.len() != 0u);\n-    let total = 0u;\n-    for {weight: weight, item: _} in v {\n-        total += weight;\n-    }\n-    assert!(total >= 0u);\n-    let chosen = under(r, total);\n-    let so_far = 0u;\n-    for {weight: weight, item: item} in v {\n-        so_far += weight;\n-        if so_far > chosen {\n-            return item;\n-        }\n-    }\n-    std::unreachable();\n-}\n-\n-fn weighted_vec<T:copy>(v : ~[weighted<T>]) -> ~[T] {\n-    let r = ~[];\n-    for {weight: weight, item: item} in v {\n-        let i = 0u;\n-        while i < weight {\n-            r.push(item);\n-            i += 1u;\n-        }\n-    }\n-    r\n-}\n-\n-fn main()\n-{\n-    let r = rand::mk_rng();\n-\n-    log(error, under(r, 5u));\n-    log(error, choice(r, ~[10, 20, 30]));\n-    log(error, if unlikely(r, 5u) { \"unlikely\" } else { \"likely\" });\n-\n-    let mut a = ~[1, 2, 3];\n-    shuffle(r, a);\n-    log(error, a);\n-\n-    let i = 0u;\n-    let v = ~[\n-        {weight:1u, item:\"low\"},\n-        {weight:8u, item:\"middle\"},\n-        {weight:1u, item:\"high\"}\n-    ];\n-    let w = weighted_vec(v);\n-\n-    while i < 1000u {\n-        log(error, \"Immed: \" + weighted_choice(r, v));\n-        log(error, \"Fast:  \" + choice(r, w));\n-        i += 1u;\n-    }\n-}"}]}