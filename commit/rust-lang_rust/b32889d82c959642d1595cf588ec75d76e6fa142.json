{"sha": "b32889d82c959642d1595cf588ec75d76e6fa142", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMjg4OWQ4MmM5NTk2NDJkMTU5NWNmNTg4ZWM3NWQ3NmU2ZmExNDI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-11T22:27:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T19:08:26Z"}, "message": "Remove vecs from simplext", "tree": {"sha": "65a8ce3341fda072e1d6994a03ff533b93a6eb6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65a8ce3341fda072e1d6994a03ff533b93a6eb6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b32889d82c959642d1595cf588ec75d76e6fa142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b32889d82c959642d1595cf588ec75d76e6fa142", "html_url": "https://github.com/rust-lang/rust/commit/b32889d82c959642d1595cf588ec75d76e6fa142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b32889d82c959642d1595cf588ec75d76e6fa142/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f195814df3209f57e31a9c3e42a08d0ea32e6f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/f195814df3209f57e31a9c3e42a08d0ea32e6f44", "html_url": "https://github.com/rust-lang/rust/commit/f195814df3209f57e31a9c3e42a08d0ea32e6f44"}], "stats": {"total": 50, "additions": 21, "deletions": 29}, "files": [{"sha": "addae3515b51e09df8ae5229c0c96dd972b120ca", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b32889d82c959642d1595cf588ec75d76e6fa142/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32889d82c959642d1595cf588ec75d76e6fa142/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=b32889d82c959642d1595cf588ec75d76e6fa142", "patch": "@@ -45,7 +45,7 @@ fn path_to_ident(pth: &path) -> option::t[ident] {\n type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n-tag arb_depth[T] { leaf(T); seq(vec[arb_depth[T]], span); }\n+tag arb_depth[T] { leaf(T); seq(@[arb_depth[T]], span); }\n \n \n tag matchable {\n@@ -118,11 +118,11 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n     ret {fixed: elts, rep: none};\n }\n \n-fn option_flatten_map[T, U](f: &fn(&T) -> option::t[U] , v: &vec[T]) ->\n-   option::t[vec[U]] {\n-    let res = vec::alloc[U](vec::len(v));\n+fn option_flatten_map[T, U](f: &fn(&T) -> option::t[U] , v: &[T]) ->\n+   option::t[[U]] {\n+    let res = ~[];\n     for elem: T  in v {\n-        alt f(elem) { none. { ret none; } some(fv) { res += [fv]; } }\n+        alt f(elem) { none. { ret none; } some(fv) { res += ~[fv]; } }\n     }\n     ret some(res);\n }\n@@ -131,9 +131,9 @@ fn a_d_map(ad: &arb_depth[matchable], f: &selector) -> match_result {\n     alt ad {\n       leaf(x) { ret f(x); }\n       seq(ads, span) {\n-        alt option_flatten_map(bind a_d_map(_, f), ads) {\n+        alt option_flatten_map(bind a_d_map(_, f), *ads) {\n           none. { ret none; }\n-          some(ts) { ret some(seq(ts, span)); }\n+          some(ts) { ret some(seq(@ts, span)); }\n         }\n       }\n     }\n@@ -200,7 +200,7 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t[bindings] {\n /* use the bindings on the body to generate the expanded code */\n \n fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n-    let idx_path: @mutable vec[uint] = @mutable [];\n+    let idx_path: @mutable [uint] = @mutable ~[];\n     let afp = default_ast_fold();\n     let f_pre =\n         {fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n@@ -220,7 +220,7 @@ fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n \n \n /* helper: descend into a matcher */\n-fn follow(m: &arb_depth[matchable], idx_path: @mutable vec[uint]) ->\n+fn follow(m: &arb_depth[matchable], idx_path: @mutable [uint]) ->\n    arb_depth[matchable] {\n     let res: arb_depth[matchable] = m;\n     for idx: uint  in *idx_path {\n@@ -233,7 +233,7 @@ fn follow(m: &arb_depth[matchable], idx_path: @mutable vec[uint]) ->\n }\n \n fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t[arb_depth[matchable]],\n-                    idx_path: @mutable vec[uint]) -> option::t[matchable] {\n+                    idx_path: @mutable [uint]) -> option::t[matchable] {\n     alt mmaybe {\n       none. { ret none }\n       some(m) {\n@@ -271,7 +271,7 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n \n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n-fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n+fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     recur: fn(&@expr) -> @expr , exprs: [@expr])\n     -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n@@ -290,10 +290,10 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n                   seq(ms, _) {\n                     alt repeat {\n                       none. {\n-                        repeat = some({rep_count: vec::len(ms), name: fv});\n+                        repeat = some({rep_count: ivec::len(*ms), name: fv});\n                       }\n                       some({rep_count: old_len, name: old_name}) {\n-                        let len = vec::len(ms);\n+                        let len = ivec::len(*ms);\n                         if old_len != len {\n                             let msg = #fmt(\"'%s' occurs %u times, but \", fv,\n                                            len) + #fmt(\"'%s' occurs %u times\",\n@@ -315,9 +315,9 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n                 /* Whew, we now know how how many times to repeat */\n                 let idx: uint = 0u;\n                 while idx < rc {\n-                    vec::push(*idx_path, idx);\n+                    *idx_path += ~[idx];\n                     res += ~[recur(repeat_me)]; // whew!\n-                    vec::pop(*idx_path);\n+                    ivec::pop(*idx_path);\n                     idx += 1u;\n                 }\n               }\n@@ -332,7 +332,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n \n \n // substitute, in a position that's required to be an ident\n-fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n+fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     i: &ident, fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n@@ -342,7 +342,7 @@ fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n }\n \n \n-fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n+fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    p: &path_, fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n     if ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u { ret p; }\n@@ -357,7 +357,7 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n }\n \n \n-fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n+fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    e: &ast::expr_, fld: ast_fold,\n                    orig: fn(&ast::expr_, ast_fold) -> ast::expr_ ) ->\n    ast::expr_ {\n@@ -385,7 +385,7 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n         }\n }\n \n-fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n+fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    t: &ast::ty_, fld: ast_fold,\n                    orig: fn(&ast::ty_, ast_fold) -> ast::ty_ ) -> ast::ty_ {\n     ret alt t {\n@@ -409,7 +409,7 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n /* for parsing reasons, syntax variables bound to blocks must be used like\n `{v}` */\n \n-fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n+fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     blk: &blk_, fld: ast_fold,\n                     orig: fn(&blk_, ast_fold) -> blk_ ) -> blk_ {\n     ret alt block_to_ident(blk) {\n@@ -578,14 +578,6 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n     }\n }\n \n-/* TODO: move this to vec.rs */\n-\n-fn ivec_to_vec[T](v: &[T]) -> vec[T] {\n-    let rs: vec[T] = vec::alloc[T](ivec::len(v));\n-    for ve: T  in v { rs += [ve]; }\n-    ret rs;\n-}\n-\n fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n                     s: &selector, b: &binders) {\n     fn select(cx: &ext_ctxt, repeat_me: @expr, offset: uint, m: &matchable) ->\n@@ -602,7 +594,7 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n                     }\n                     // using repeat_me.span is a little wacky, but the\n                     // error we want to report is one in the macro def\n-                    some(seq(elts, repeat_me.span))\n+                    some(seq(@ivec::from_vec(elts), repeat_me.span))\n                   }\n                   _ { none }\n                 }"}]}