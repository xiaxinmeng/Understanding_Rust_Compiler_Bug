{"sha": "e64efc91f49affb265328e354c8c8f0544daa462", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NGVmYzkxZjQ5YWZmYjI2NTMyOGUzNTRjOGM4ZjA1NDRkYWE0NjI=", "commit": {"author": {"name": "Alex Burka", "email": "alex@alexburka.com", "date": "2017-09-19T05:40:04Z"}, "committer": {"name": "Badel2", "email": "2badel2@gmail.com", "date": "2017-09-22T20:05:18Z"}, "message": "Add support for `..=` syntax\n\nAdd ..= to the parser\n\nAdd ..= to libproc_macro\n\nAdd ..= to ICH\n\nHighlight ..= in rustdoc\n\nUpdate impl Debug for RangeInclusive to ..=\n\nReplace `...` to `..=` in range docs\n\nMake the dotdoteq warning point to the ...\n\nAdd warning for ... in expressions\n\nUpdated more tests to the ..= syntax\n\nUpdated even more tests to the ..= syntax\n\nUpdated the inclusive_range entry in unstable book", "tree": {"sha": "ab6832194ec3c23ab7033941b885f164ebc37686", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab6832194ec3c23ab7033941b885f164ebc37686"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64efc91f49affb265328e354c8c8f0544daa462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64efc91f49affb265328e354c8c8f0544daa462", "html_url": "https://github.com/rust-lang/rust/commit/e64efc91f49affb265328e354c8c8f0544daa462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64efc91f49affb265328e354c8c8f0544daa462/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Badel2", "id": 15879619, "node_id": "MDQ6VXNlcjE1ODc5NjE5", "avatar_url": "https://avatars.githubusercontent.com/u/15879619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Badel2", "html_url": "https://github.com/Badel2", "followers_url": "https://api.github.com/users/Badel2/followers", "following_url": "https://api.github.com/users/Badel2/following{/other_user}", "gists_url": "https://api.github.com/users/Badel2/gists{/gist_id}", "starred_url": "https://api.github.com/users/Badel2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Badel2/subscriptions", "organizations_url": "https://api.github.com/users/Badel2/orgs", "repos_url": "https://api.github.com/users/Badel2/repos", "events_url": "https://api.github.com/users/Badel2/events{/privacy}", "received_events_url": "https://api.github.com/users/Badel2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eb19bf9b160825cd338b9419551670a30962c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb19bf9b160825cd338b9419551670a30962c4e", "html_url": "https://github.com/rust-lang/rust/commit/3eb19bf9b160825cd338b9419551670a30962c4e"}], "stats": {"total": 426, "additions": 244, "deletions": 182}, "files": [{"sha": "56f58803150ca6ca274b5b9046f771f92e1c0627", "filename": "src/doc/unstable-book/src/language-features/inclusive-range-syntax.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -7,13 +7,13 @@ The tracking issue for this feature is: [#28237]\n ------------------------\n \n To get a range that goes from 0 to 10 and includes the value 10, you\n-can write `0...10`:\n+can write `0..=10`:\n \n ```rust\n #![feature(inclusive_range_syntax)]\n \n fn main() {\n-    for i in 0...10 {\n+    for i in 0..=10 {\n         println!(\"{}\", i);\n     }\n }"}, {"sha": "2393101040d9f9d3781df9a0f396026775be4d23", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -182,7 +182,7 @@ fn test_range_small() {\n fn test_range_inclusive() {\n     let size = 500;\n \n-    let map: BTreeMap<_, _> = (0...size).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (0..=size).map(|i| (i, i)).collect();\n \n     fn check<'a, L, R>(lhs: L, rhs: R)\n         where L: IntoIterator<Item=(&'a i32, &'a i32)>,\n@@ -193,26 +193,26 @@ fn test_range_inclusive() {\n         assert_eq!(lhs, rhs);\n     }\n \n-    check(map.range(size + 1...size + 1), vec![]);\n-    check(map.range(size...size), vec![(&size, &size)]);\n-    check(map.range(size...size + 1), vec![(&size, &size)]);\n-    check(map.range(0...0), vec![(&0, &0)]);\n-    check(map.range(0...size - 1), map.range(..size));\n-    check(map.range(-1...-1), vec![]);\n-    check(map.range(-1...size), map.range(..));\n-    check(map.range(...size), map.range(..));\n-    check(map.range(...200), map.range(..201));\n-    check(map.range(5...8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n-    check(map.range(-1...0), vec![(&0, &0)]);\n-    check(map.range(-1...2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n+    check(map.range(size + 1..=size + 1), vec![]);\n+    check(map.range(size..=size), vec![(&size, &size)]);\n+    check(map.range(size..=size + 1), vec![(&size, &size)]);\n+    check(map.range(0..=0), vec![(&0, &0)]);\n+    check(map.range(0..=size - 1), map.range(..size));\n+    check(map.range(-1..=-1), vec![]);\n+    check(map.range(-1..=size), map.range(..));\n+    check(map.range(..=size), map.range(..));\n+    check(map.range(..=200), map.range(..201));\n+    check(map.range(5..=8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n+    check(map.range(-1..=0), vec![(&0, &0)]);\n+    check(map.range(-1..=2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n }\n \n #[test]\n fn test_range_inclusive_max_value() {\n     let max = ::std::usize::MAX;\n     let map: BTreeMap<_, _> = vec![(max, 0)].into_iter().collect();\n \n-    assert_eq!(map.range(max...max).collect::<Vec<_>>(), &[(&max, &0)]);\n+    assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);\n }\n \n #[test]"}, {"sha": "b3178064505e8683f0bbeacd77b01b3c36ccca89", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -361,43 +361,43 @@ fn test_slice_fail() {\n #[test]\n #[should_panic]\n fn test_str_slice_rangetoinclusive_max_panics() {\n-    &\"hello\"[...usize::max_value()];\n+    &\"hello\"[..=usize::max_value()];\n }\n \n #[test]\n #[should_panic]\n fn test_str_slice_rangeinclusive_max_panics() {\n-    &\"hello\"[1...usize::max_value()];\n+    &\"hello\"[1..=usize::max_value()];\n }\n \n #[test]\n #[should_panic]\n fn test_str_slicemut_rangetoinclusive_max_panics() {\n     let mut s = \"hello\".to_owned();\n     let s: &mut str = &mut s;\n-    &mut s[...usize::max_value()];\n+    &mut s[..=usize::max_value()];\n }\n \n #[test]\n #[should_panic]\n fn test_str_slicemut_rangeinclusive_max_panics() {\n     let mut s = \"hello\".to_owned();\n     let s: &mut str = &mut s;\n-    &mut s[1...usize::max_value()];\n+    &mut s[1..=usize::max_value()];\n }\n \n #[test]\n fn test_str_get_maxinclusive() {\n     let mut s = \"hello\".to_owned();\n     {\n         let s: &str = &s;\n-        assert_eq!(s.get(...usize::max_value()), None);\n-        assert_eq!(s.get(1...usize::max_value()), None);\n+        assert_eq!(s.get(..=usize::max_value()), None);\n+        assert_eq!(s.get(1..=usize::max_value()), None);\n     }\n     {\n         let s: &mut str = &mut s;\n-        assert_eq!(s.get(...usize::max_value()), None);\n-        assert_eq!(s.get(1...usize::max_value()), None);\n+        assert_eq!(s.get(..=usize::max_value()), None);\n+        assert_eq!(s.get(1..=usize::max_value()), None);\n     }\n }\n "}, {"sha": "ef6f5e10a72de9094dbf6cf4c31a8fcaebba8546", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -456,9 +456,9 @@ fn test_splice_char_boundary() {\n #[test]\n fn test_splice_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    v.splice(2...3, \"789\");\n+    v.splice(2..=3, \"789\");\n     assert_eq!(v, \"127895\");\n-    v.splice(1...2, \"A\");\n+    v.splice(1..=2, \"A\");\n     assert_eq!(v, \"1A895\");\n }\n \n@@ -473,7 +473,7 @@ fn test_splice_out_of_bounds() {\n #[should_panic]\n fn test_splice_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n-    s.splice(5...5, \"789\");\n+    s.splice(5..=5, \"789\");\n }\n \n #[test]"}, {"sha": "0e25da5bd3077f099034e6deaaabdba5e7adf5ac", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -537,27 +537,27 @@ fn test_drain_range() {\n #[test]\n fn test_drain_inclusive_range() {\n     let mut v = vec!['a', 'b', 'c', 'd', 'e'];\n-    for _ in v.drain(1...3) {\n+    for _ in v.drain(1..=3) {\n     }\n     assert_eq!(v, &['a', 'e']);\n \n-    let mut v: Vec<_> = (0...5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(1...5) {\n+    let mut v: Vec<_> = (0..=5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1..=5) {\n     }\n     assert_eq!(v, &[\"0\".to_string()]);\n \n-    let mut v: Vec<String> = (0...5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(0...5) {\n+    let mut v: Vec<String> = (0..=5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(0..=5) {\n     }\n     assert_eq!(v, Vec::<String>::new());\n \n-    let mut v: Vec<_> = (0...5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(0...3) {\n+    let mut v: Vec<_> = (0..=5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(0..=3) {\n     }\n     assert_eq!(v, &[\"4\".to_string(), \"5\".to_string()]);\n \n-    let mut v: Vec<_> = (0...1).map(|x| x.to_string()).collect();\n-    for _ in v.drain(...0) {\n+    let mut v: Vec<_> = (0..=1).map(|x| x.to_string()).collect();\n+    for _ in v.drain(..=0) {\n     }\n     assert_eq!(v, &[\"1\".to_string()]);\n }\n@@ -572,7 +572,7 @@ fn test_drain_max_vec_size() {\n \n     let mut v = Vec::<()>::with_capacity(usize::max_value());\n     unsafe { v.set_len(usize::max_value()); }\n-    for _ in v.drain(usize::max_value() - 1...usize::max_value() - 1) {\n+    for _ in v.drain(usize::max_value() - 1..=usize::max_value() - 1) {\n     }\n     assert_eq!(v.len(), usize::max_value() - 1);\n }\n@@ -581,7 +581,7 @@ fn test_drain_max_vec_size() {\n #[should_panic]\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n-    v.drain(5...5);\n+    v.drain(5..=5);\n }\n \n #[test]\n@@ -598,10 +598,10 @@ fn test_splice() {\n fn test_splice_inclusive_range() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    let t1: Vec<_> = v.splice(2...3, a.iter().cloned()).collect();\n+    let t1: Vec<_> = v.splice(2..=3, a.iter().cloned()).collect();\n     assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n     assert_eq!(t1, &[3, 4]);\n-    let t2: Vec<_> = v.splice(1...2, Some(20)).collect();\n+    let t2: Vec<_> = v.splice(1..=2, Some(20)).collect();\n     assert_eq!(v, &[1, 20, 11, 12, 5]);\n     assert_eq!(t2, &[2, 10]);\n }\n@@ -619,7 +619,7 @@ fn test_splice_out_of_bounds() {\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    v.splice(5...5, a.iter().cloned());\n+    v.splice(5..=5, a.iter().cloned());\n }\n \n #[test]"}, {"sha": "3f573f7c7eb69b73ef38eb69c31e463d3988682d", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -241,22 +241,22 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     }\n }\n \n-/// An range bounded inclusively below and above (`start...end`).\n+/// An range bounded inclusively below and above (`start..=end`).\n ///\n-/// The `RangeInclusive` `start...end` contains all values with `x >= start`\n+/// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n /// and `x <= end`.\n ///\n /// # Examples\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n ///\n-/// assert_eq!((3...5), std::ops::RangeInclusive { start: 3, end: 5 });\n-/// assert_eq!(3 + 4 + 5, (3...5).sum());\n+/// assert_eq!((3..=5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3..=5).sum());\n ///\n /// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ...2], [0,1,2  ]);\n-/// assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// assert_eq!(arr[ ..=2], [0,1,2  ]);\n+/// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n@@ -276,7 +276,7 @@ pub struct RangeInclusive<Idx> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n+        write!(fmt, \"{:?}..={:?}\", self.start, self.end)\n     }\n }\n \n@@ -289,32 +289,32 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n     ///\n-    /// assert!(!(3...5).contains(2));\n-    /// assert!( (3...5).contains(3));\n-    /// assert!( (3...5).contains(4));\n-    /// assert!( (3...5).contains(5));\n-    /// assert!(!(3...5).contains(6));\n+    /// assert!(!(3..=5).contains(2));\n+    /// assert!( (3..=5).contains(3));\n+    /// assert!( (3..=5).contains(4));\n+    /// assert!( (3..=5).contains(5));\n+    /// assert!(!(3..=5).contains(6));\n     ///\n-    /// assert!( (3...3).contains(3));\n-    /// assert!(!(3...2).contains(3));\n+    /// assert!( (3..=3).contains(3));\n+    /// assert!(!(3..=2).contains(3));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n }\n \n-/// A range only bounded inclusively above (`...end`).\n+/// A range only bounded inclusively above (`..=end`).\n ///\n-/// The `RangeToInclusive` `...end` contains all values with `x <= end`.\n+/// The `RangeToInclusive` `..=end` contains all values with `x <= end`.\n /// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `...end` syntax is a `RangeToInclusive`:\n+/// The `..=end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// assert_eq!((..=5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n /// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n@@ -325,7 +325,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n ///\n /// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n /// // std::iter::Iterator` is not satisfied\n-/// for i in ...5 {\n+/// for i in ..=5 {\n ///     // ...\n /// }\n /// ```\n@@ -337,8 +337,8 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// #![feature(inclusive_range_syntax)]\n ///\n /// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n-/// assert_eq!(arr[1...2], [  1,2  ]);\n+/// assert_eq!(arr[ ..=2], [0,1,2  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1..=2], [  1,2  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -357,7 +357,7 @@ pub struct RangeToInclusive<Idx> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"...{:?}\", self.end)\n+        write!(fmt, \"..={:?}\", self.end)\n     }\n }\n \n@@ -370,9 +370,9 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n     ///\n-    /// assert!( (...5).contains(-1_000_000_000));\n-    /// assert!( (...5).contains(5));\n-    /// assert!(!(...5).contains(6));\n+    /// assert!( (..=5).contains(-1_000_000_000));\n+    /// assert!( (..=5).contains(5));\n+    /// assert!(!(..=5).contains(6));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item <= self.end)"}, {"sha": "c52e88170aeb70af90ec9a46e4554c8846cb01a2", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -16,6 +16,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+// FIXME: replace remaining ... by ..= after next stage0\n+// Silence warning: \"... is being replaced by ..=\"\n+#![cfg_attr(not(stage0), allow(warnings))]\n+\n // How this module is organized.\n //\n // The library infrastructure for slices is fairly messy. There's"}, {"sha": "3c4ea974fc9f28fb8b773897c72385ceac2a538e", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -1094,21 +1094,21 @@ fn test_range() {\n \n #[test]\n fn test_range_inclusive_exhaustion() {\n-    let mut r = 10...10;\n+    let mut r = 10..=10;\n     assert_eq!(r.next(), Some(10));\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n-    let mut r = 10...10;\n+    let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n-    let mut r = 10...12;\n+    let mut r = 10..=12;\n     assert_eq!(r.nth(2), Some(12));\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n-    let mut r = 10...12;\n+    let mut r = 10..=12;\n     assert_eq!(r.nth(5), None);\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n }\n \n@@ -1145,20 +1145,20 @@ fn test_range_from_nth() {\n \n #[test]\n fn test_range_inclusive_nth() {\n-    assert_eq!((10...15).nth(0), Some(10));\n-    assert_eq!((10...15).nth(1), Some(11));\n-    assert_eq!((10...15).nth(5), Some(15));\n-    assert_eq!((10...15).nth(6), None);\n+    assert_eq!((10..=15).nth(0), Some(10));\n+    assert_eq!((10..=15).nth(1), Some(11));\n+    assert_eq!((10..=15).nth(5), Some(15));\n+    assert_eq!((10..=15).nth(6), None);\n \n-    let mut r = 10_u8...20;\n+    let mut r = 10_u8..=20;\n     assert_eq!(r.nth(2), Some(12));\n-    assert_eq!(r, 13...20);\n+    assert_eq!(r, 13..=20);\n     assert_eq!(r.nth(2), Some(15));\n-    assert_eq!(r, 16...20);\n+    assert_eq!(r, 16..=20);\n     assert_eq!(r.is_empty(), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n-    assert_eq!(r, 1...0);  // We may not want to document/promise this detail\n+    assert_eq!(r, 1..=0);  // We may not want to document/promise this detail\n }\n \n #[test]"}, {"sha": "2c540c8de8fc8bc8d749cb870d371fcc7915cfe0", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -509,6 +509,7 @@ impl TokenTree {\n             Dot => op!('.'),\n             DotDot => joint!('.', Dot),\n             DotDotDot => joint!('.', DotDot),\n+            DotDotEq => joint!('.', DotEq),\n             Comma => op!(','),\n             Semi => op!(';'),\n             Colon => op!(':'),\n@@ -531,6 +532,7 @@ impl TokenTree {\n                 })\n             }\n \n+            DotEq => unreachable!(),\n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n         };"}, {"sha": "8c1f6bfc11a5fcff35deb04e966c2b80e9ac5d78", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -202,8 +202,8 @@ impl Quote for Token {\n \n         gen_match! {\n             Eq, Lt, Le, EqEq, Ne, Ge, Gt, AndAnd, OrOr, Not, Tilde, At, Dot, DotDot, DotDotDot,\n-            Comma, Semi, Colon, ModSep, RArrow, LArrow, FatArrow, Pound, Dollar, Question,\n-            Underscore;\n+            DotDotEq, Comma, Semi, Colon, ModSep, RArrow, LArrow, FatArrow, Pound, Dollar,\n+            Question, Underscore;\n \n             Token::OpenDelim(delim) => quote!(rt::token::OpenDelim((quote delim))),\n             Token::CloseDelim(delim) => quote!(rt::token::CloseDelim((quote delim))),"}, {"sha": "669e1ba773e2384de512b9f0edd379e231af5834", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -272,6 +272,8 @@ fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n         token::Token::Dot |\n         token::Token::DotDot |\n         token::Token::DotDotDot |\n+        token::Token::DotDotEq |\n+        token::Token::DotEq |\n         token::Token::Comma |\n         token::Token::Semi |\n         token::Token::Colon |"}, {"sha": "98863b229b51100d73e86410cfe6f637fc4415c3", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -249,8 +249,8 @@ impl<'a> Classifier<'a> {\n                 token::BinOpEq(..) | token::FatArrow => Class::Op,\n \n             // Miscellaneous, no highlighting.\n-            token::Dot | token::DotDot | token::DotDotDot | token::Comma | token::Semi |\n-                token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n+            token::Dot | token::DotDot | token::DotDotDot | token::DotDotEq | token::Comma |\n+                token::Semi | token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n                 token::CloseDelim(token::Brace) | token::CloseDelim(token::Paren) |\n                 token::CloseDelim(token::NoDelim) => Class::None,\n \n@@ -353,7 +353,7 @@ impl<'a> Classifier<'a> {\n             token::Lifetime(..) => Class::Lifetime,\n \n             token::Underscore | token::Eof | token::Interpolated(..) |\n-            token::Tilde | token::At => Class::None,\n+            token::Tilde | token::At | token::DotEq => Class::None,\n         };\n \n         // Anything that didn't return above is the simple case where we the"}, {"sha": "c3cf474783505d2d0b3f8a3d086ed92a5ea0e446", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -291,7 +291,7 @@ Erroneous code example:\n \n fn main() {\n     let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1...]; // error: inclusive range was used with no end\n+    let x = &tmp[1..=]; // error: inclusive range was used with no end\n }\n ```\n \n@@ -312,7 +312,7 @@ Or put an end to your inclusive range:\n \n fn main() {\n     let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1...3]; // ok!\n+    let x = &tmp[1..=3]; // ok!\n }\n ```\n \"##,"}, {"sha": "bd8c9a0ed40b24b133d69c1e24c149a3d010227f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -686,7 +686,9 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::At           => \"At\",\n         token::Dot          => \"Dot\",\n         token::DotDot       => \"DotDot\",\n+        token::DotEq        => \"DotEq\",\n         token::DotDotDot    => \"DotDotDot\",\n+        token::DotDotEq     => \"DotDotEq\",\n         token::Comma        => \"Comma\",\n         token::Semi         => \"Semi\",\n         token::Colon        => \"Colon\","}, {"sha": "2fc451d5d004aef5de84a6560cc17795fdf8aad5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -261,7 +261,7 @@ declare_features! (\n     // rustc internal\n     (active, abi_vectorcall, \"1.7.0\", None),\n \n-    // a...b and ...b\n+    // a..=b and ..=b\n     (active, inclusive_range_syntax, \"1.7.0\", Some(28237)),\n \n     // X..Y patterns"}, {"sha": "1cb7b0eca58d0de722846320e2b88e675fb04c96", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -1131,6 +1131,9 @@ impl<'a> StringReader<'a> {\n                     if self.ch_is('.') {\n                         self.bump();\n                         Ok(token::DotDotDot)\n+                    } else if self.ch_is('=') {\n+                        self.bump();\n+                        Ok(token::DotDotEq)\n                     } else {\n                         Ok(token::DotDot)\n                     }"}, {"sha": "80c976abd19d7fc2c4461e1adfb10db3b0bd4431", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -432,7 +432,7 @@ impl Error {\n             Error::InclusiveRangeWithNoEnd => {\n                 let mut err = struct_span_err!(handler, sp, E0586,\n                                                \"inclusive range with no end\");\n-                err.help(\"inclusive ranges must be bounded at the end (`...b` or `a...b`)\");\n+                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n                 err\n             }\n         }\n@@ -2710,7 +2710,7 @@ impl<'a> Parser<'a> {\n                 LhsExpr::AttributesParsed(attrs) => Some(attrs),\n                 _ => None,\n             };\n-            if self.token == token::DotDot || self.token == token::DotDotDot {\n+            if [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token) {\n                 return self.parse_prefix_range_expr(attrs);\n             } else {\n                 self.parse_prefix_expr(attrs)?\n@@ -2744,6 +2744,10 @@ impl<'a> Parser<'a> {\n             if op.precedence() < min_prec {\n                 break;\n             }\n+            // Warn about deprecated ... syntax (until SNAP)\n+            if self.token == token::DotDotDot {\n+                self.warn_dotdoteq(self.span);\n+            }\n             self.bump();\n             if op.is_comparison() {\n                 self.check_no_chained_comparison(&lhs, &op);\n@@ -2770,12 +2774,13 @@ impl<'a> Parser<'a> {\n                     }\n                 };\n                 continue\n-            } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n-                // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n+            } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n+                // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n                 //\n-                // We have 2 alternatives here: `x..y`/`x...y` and `x..`/`x...` The other\n+                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n                 // two variants are handled with `parse_prefix_range_expr` call above.\n+                // (and `x...y`/`x...` until SNAP)\n                 let rhs = if self.is_at_start_of_range_notation_rhs() {\n                     Some(self.parse_assoc_expr_with(op.precedence() + 1,\n                                                     LhsExpr::NotYetParsed)?)\n@@ -2852,8 +2857,8 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(span, aopexpr, ThinVec::new())\n                 }\n-                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n-                    self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n+                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n+                    self.bug(\"AssocOp should have been handled by special case\")\n                 }\n             };\n \n@@ -2949,17 +2954,22 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n+    /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr` (and `...expr` until SNAP)\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n-        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot,\n-                      \"parse_prefix_range_expr: token {:?} is not DotDot or DotDotDot\",\n+        // SNAP remove DotDotDot\n+        debug_assert!([token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token),\n+                      \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotDot/DotDotEq\",\n                       self.token);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span;\n         let mut hi = self.span;\n+        // Warn about deprecated ... syntax (until SNAP)\n+        if tok == token::DotDotDot {\n+            self.warn_dotdoteq(self.span);\n+        }\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than the dots.\n@@ -3450,7 +3460,7 @@ impl<'a> Parser<'a> {\n     fn parse_as_ident(&mut self) -> bool {\n         self.look_ahead(1, |t| match *t {\n             token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n-            token::DotDotDot | token::ModSep | token::Not => Some(false),\n+            token::DotDotDot | token::DotDotEq | token::ModSep | token::Not => Some(false),\n             // ensure slice patterns [a, b.., c] and [a, b, c..] don't go into the\n             // range pattern branch\n             token::DotDot => None,\n@@ -3544,11 +3554,12 @@ impl<'a> Parser<'a> {\n                         let mac = respan(lo.to(self.prev_span), Mac_ { path: path, tts: tts });\n                         pat = PatKind::Mac(mac);\n                     }\n-                    token::DotDotDot | token::DotDot => {\n+                    token::DotDotDot | token::DotDotEq | token::DotDot => {\n                         let end_kind = match self.token {\n                             token::DotDot => RangeEnd::Excluded,\n-                            token::DotDotDot => RangeEnd::Included,\n-                            _ => panic!(\"can only parse `..` or `...` for ranges (checked above)\"),\n+                            token::DotDotDot | token::DotDotEq => RangeEnd::Included,\n+                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n+                                         (checked above)\"),\n                         };\n                         // Parse range\n                         let span = lo.to(self.prev_span);\n@@ -3590,6 +3601,9 @@ impl<'a> Parser<'a> {\n                         if self.eat(&token::DotDotDot) {\n                             let end = self.parse_pat_range_end()?;\n                             pat = PatKind::Range(begin, end, RangeEnd::Included);\n+                        } else if self.eat(&token::DotDotEq) {\n+                            let end = self.parse_pat_range_end()?;\n+                            pat = PatKind::Range(begin, end, RangeEnd::Included);\n                         } else if self.eat(&token::DotDot) {\n                             let end = self.parse_pat_range_end()?;\n                             pat = PatKind::Range(begin, end, RangeEnd::Excluded);\n@@ -3973,7 +3987,7 @@ impl<'a> Parser<'a> {\n                     token::BinOp(token::Minus) | token::BinOp(token::Star) |\n                     token::BinOp(token::And) | token::BinOp(token::Or) |\n                     token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot => false,\n+                    token::DotDot | token::DotDotDot | token::DotDotEq => false,\n                     _ => true,\n                 } {\n                     self.warn_missing_semicolon();\n@@ -4195,6 +4209,12 @@ impl<'a> Parser<'a> {\n         }).emit();\n     }\n \n+    fn warn_dotdoteq(&self, span: Span) {\n+        self.diagnostic().struct_span_warn(span, {\n+            \"`...` is being replaced by `..=`\"\n+        }).emit();\n+    }\n+\n     // Parse bounds of a type parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     // BOUND = TY_BOUND | LT_BOUND\n     // LT_BOUND = LIFETIME (e.g. `'a`)"}, {"sha": "4888654fac9d0ed09c9454ee6f23b92731757b40", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -152,6 +152,8 @@ pub enum Token {\n     Dot,\n     DotDot,\n     DotDotDot,\n+    DotDotEq,\n+    DotEq, // HACK(durka42) never produced by the parser, only used for libproc_macro\n     Comma,\n     Semi,\n     Colon,\n@@ -212,18 +214,19 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             Ident(ident)                => ident_can_begin_expr(ident), // value name or keyword\n-            OpenDelim(..)               | // tuple, array or block\n-            Literal(..)                 | // literal\n-            Not                         | // operator not\n-            BinOp(Minus)                | // unary minus\n-            BinOp(Star)                 | // dereference\n-            BinOp(Or) | OrOr            | // closure\n-            BinOp(And)                  | // reference\n-            AndAnd                      | // double reference\n-            DotDot | DotDotDot          | // range notation\n-            Lt | BinOp(Shl)             | // associated path\n-            ModSep                      | // global path\n-            Pound                       => true, // expression attributes\n+            OpenDelim(..)                     | // tuple, array or block\n+            Literal(..)                       | // literal\n+            Not                               | // operator not\n+            BinOp(Minus)                      | // unary minus\n+            BinOp(Star)                       | // dereference\n+            BinOp(Or) | OrOr                  | // closure\n+            BinOp(And)                        | // reference\n+            AndAnd                            | // double reference\n+            DotDot | DotDotDot | DotDotEq     | // range notation\n+                // SNAP remove DotDotDot\n+            Lt | BinOp(Shl)                   | // associated path\n+            ModSep                            | // global path\n+            Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match nt.0 {\n                 NtIdent(..) | NtExpr(..) | NtBlock(..) | NtPath(..) => true,\n                 _ => false,\n@@ -402,20 +405,22 @@ impl Token {\n             Dot => match joint {\n                 Dot => DotDot,\n                 DotDot => DotDotDot,\n+                DotEq => DotDotEq,\n                 _ => return None,\n             },\n             DotDot => match joint {\n                 Dot => DotDotDot,\n+                Eq => DotDotEq,\n                 _ => return None,\n             },\n             Colon => match joint {\n                 Colon => ModSep,\n                 _ => return None,\n             },\n \n-            Le | EqEq | Ne | Ge | AndAnd | OrOr | Tilde | BinOpEq(..) | At | DotDotDot | Comma |\n-            Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar | Question |\n-            OpenDelim(..) | CloseDelim(..) | Underscore => return None,\n+            Le | EqEq | Ne | Ge | AndAnd | OrOr | Tilde | BinOpEq(..) | At | DotDotDot | DotEq |\n+            DotDotEq | Comma | Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar |\n+            Question | OpenDelim(..) | CloseDelim(..) | Underscore => return None,\n \n             Literal(..) | Ident(..) | Lifetime(..) | Interpolated(..) | DocComment(..) |\n             Whitespace | Comment | Shebang(..) | Eof => return None,"}, {"sha": "cc4b34854fcd3b43e15a85dc6c902eb756f44912", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -203,6 +203,8 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Dot                  => \".\".to_string(),\n         token::DotDot               => \"..\".to_string(),\n         token::DotDotDot            => \"...\".to_string(),\n+        token::DotDotEq             => \"..=\".to_string(),\n+        token::DotEq                => \".=\".to_string(),\n         token::Comma                => \",\".to_string(),\n         token::Semi                 => \";\".to_string(),\n         token::Colon                => \":\".to_string(),"}, {"sha": "590874806d7b5b1d7ade4780d8bc320eeb96ddd0", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -62,8 +62,8 @@ pub enum AssocOp {\n     As,\n     /// `..` range\n     DotDot,\n-    /// `...` range\n-    DotDotDot,\n+    /// `..=` range\n+    DotDotEq,\n     /// `:`\n     Colon,\n }\n@@ -105,7 +105,8 @@ impl AssocOp {\n             Token::AndAnd => Some(LAnd),\n             Token::OrOr => Some(LOr),\n             Token::DotDot => Some(DotDot),\n-            Token::DotDotDot => Some(DotDotDot),\n+            Token::DotDotEq => Some(DotDotEq),\n+            Token::DotDotDot => Some(DotDotEq), // remove this after SNAP\n             Token::Colon => Some(Colon),\n             _ if t.is_keyword(keywords::As) => Some(As),\n             _ => None\n@@ -151,7 +152,7 @@ impl AssocOp {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => 7,\n             LAnd => 6,\n             LOr => 5,\n-            DotDot | DotDotDot => 4,\n+            DotDot | DotDotEq => 4,\n             Inplace => 3,\n             Assign | AssignOp(_) => 2,\n         }\n@@ -166,7 +167,7 @@ impl AssocOp {\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n             BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n             LAnd | LOr | Colon => Fixity::Left,\n-            DotDot | DotDotDot => Fixity::None\n+            DotDot | DotDotEq => Fixity::None\n         }\n     }\n \n@@ -176,7 +177,7 @@ impl AssocOp {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n             ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr |\n-            DotDot | DotDotDot | Colon => false\n+            DotDot | DotDotEq | Colon => false\n         }\n     }\n \n@@ -186,7 +187,7 @@ impl AssocOp {\n             Assign | AssignOp(_) | Inplace => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n             Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd |\n-            LOr | DotDot | DotDotDot | Colon => false\n+            LOr | DotDot | DotDotEq | Colon => false\n         }\n     }\n \n@@ -211,7 +212,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotDot | Colon => None\n+            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None\n         }\n     }\n }"}, {"sha": "c1bfc5c73a1b37accd40004a3368112b57e0039c", "filename": "src/test/compile-fail/E0586.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fcompile-fail%2FE0586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fcompile-fail%2FE0586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0586.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1...]; //~ ERROR E0586\n+    let x = &tmp[1..=]; //~ ERROR E0586\n }"}, {"sha": "e4465e9f6b6115c5451fce0b855472abc7fe67ab", "filename": "src/test/compile-fail/impossible_range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -18,12 +18,12 @@ pub fn main() {\n     ..1;\n     0..1;\n \n-    ...; //~ERROR inclusive range with no end\n+    ..=; //~ERROR inclusive range with no end\n          //~^HELP bounded at the end\n-    0...; //~ERROR inclusive range with no end\n+    0..=; //~ERROR inclusive range with no end\n           //~^HELP bounded at the end\n-    ...1;\n-    0...1;\n+    ..=1;\n+    0..=1;\n }\n \n "}, {"sha": "69b9a4c67adc3bc253d54d240b5d9976e0c11894", "filename": "src/test/compile-fail/range_inclusive_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -14,7 +14,7 @@\n // #![feature(inclusive_range)]\n \n pub fn main() {\n-    let _: std::ops::RangeInclusive<_> = { use std::intrinsics; 1 } ... { use std::intrinsics; 2 };\n+    let _: std::ops::RangeInclusive<_> = { use std::intrinsics; 1 } ..= { use std::intrinsics; 2 };\n     //~^ ERROR use of unstable library feature 'inclusive_range'\n     //~| ERROR core_intrinsics\n     //~| ERROR core_intrinsics"}, {"sha": "a12624d083248db39badc601bfc7e4c2859659cc", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -153,5 +153,5 @@ fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n-    &slice[3...7]\n+    &slice[3..=7]\n }"}, {"sha": "857a3924aec01e8c69dade08869a98d8b2ed28d5", "filename": "src/test/parse-fail/pat-ranges-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-1.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -11,5 +11,5 @@\n // Parsing of range patterns\n \n fn main() {\n-    let macropus!() ... 11 = 12; //~ error: expected one of `:`, `;`, or `=`, found `...`\n+    let macropus!() ..= 11 = 12; //~ error: expected one of `:`, `;`, or `=`, found `..=`\n }"}, {"sha": "64c749333cf4acc68307f2aa17b9b3e386e5d56f", "filename": "src/test/parse-fail/pat-ranges-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-2.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -11,5 +11,5 @@\n // Parsing of range patterns\n \n fn main() {\n-    let 10 ... makropulos!() = 12; //~ error: expected one of `::`, `:`, `;`, or `=`, found `!`\n+    let 10 ..= makropulos!() = 12; //~ error: expected one of `::`, `:`, `;`, or `=`, found `!`\n }"}, {"sha": "1327a9fab366180ca80f2ca6f1215de0b2087796", "filename": "src/test/parse-fail/pat-ranges-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-3.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -11,5 +11,5 @@\n // Parsing of range patterns\n \n fn main() {\n-    let 10 ... 10 + 3 = 12; //~ expected one of `:`, `;`, or `=`, found `+`\n+    let 10 ..= 10 + 3 = 12; //~ expected one of `:`, `;`, or `=`, found `+`\n }"}, {"sha": "c159c7702502d5127cd2370641894ca38b9ceacf", "filename": "src/test/parse-fail/pat-ranges-4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Fpat-ranges-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-4.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -11,5 +11,6 @@\n // Parsing of range patterns\n \n fn main() {\n-    let 10 - 3 ... 10 = 8; //~ error: expected one of `...`, `..`, `:`, `;`, or `=`, found `-`\n+    let 10 - 3 ..= 10 = 8;\n+    //~^ error: expected one of `...`, `..=`, `..`, `:`, `;`, or `=`, found `-`\n }"}, {"sha": "cc32b9903b5acc81141d430c6863af5c15c6a4f4", "filename": "src/test/parse-fail/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -13,7 +13,7 @@\n #![feature(inclusive_range_syntax, inclusive_range)]\n \n pub fn main() {\n-    for _ in 1... {} //~ERROR inclusive range with no end\n+    for _ in 1..= {} //~ERROR inclusive range with no end\n                      //~^HELP bounded at the end\n }\n "}, {"sha": "de690c3fea3cf4ce5193bd475a3d63c19dab5e61", "filename": "src/test/parse-fail/range_inclusive_gate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -15,21 +15,21 @@\n // #![feature(inclusive_range_syntax, inclusive_range)]\n \n macro_rules! m {\n-    () => { for _ in 1...10 {} } //~ ERROR inclusive range syntax is experimental\n+    () => { for _ in 1..=10 {} } //~ ERROR inclusive range syntax is experimental\n }\n \n #[cfg(nope)]\n fn f() {}\n #[cfg(not(nope))]\n fn f() {\n-    for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n }\n \n #[cfg(nope)]\n macro_rules! n { () => {} }\n #[cfg(not(nope))]\n macro_rules! n {\n-    () => { for _ in 1...10 {} } //~ ERROR inclusive range syntax is experimental\n+    () => { for _ in 1..=10 {} } //~ ERROR inclusive range syntax is experimental\n }\n \n macro_rules! o {\n@@ -38,7 +38,7 @@ macro_rules! o {\n         fn g() {}\n         #[cfg(not(nope))]\n         fn g() {\n-            for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+            for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n         }\n \n         g();\n@@ -54,16 +54,16 @@ macro_rules! p {\n         fn h() {}\n         #[cfg(not(nope))]\n         fn h() {\n-            for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+            for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n         }\n \n         h();\n     }}\n }\n \n pub fn main() {\n-    for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n-    for _ in ...10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in ..=10 {} //~ ERROR inclusive range syntax is experimental\n \n     f(); // not allowed in cfg'ed functions\n "}, {"sha": "237b41b6128cf8a8405bd750bdcee71ee75b0b5b", "filename": "src/test/run-pass/inc-range-pat.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Frun-pass%2Finc-range-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Frun-pass%2Finc-range-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finc-range-pat.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test old and new syntax for inclusive range patterns.\n+\n+fn main() {\n+    assert!(match 42 { 0 ... 100 => true, _ => false });\n+    assert!(match 42 { 0 ..= 100 => true, _ => false });\n+\n+    assert!(match 'x' { 'a' ... 'z' => true, _ => false });\n+    assert!(match 'x' { 'a' ..= 'z' => true, _ => false });\n+}\n+"}, {"sha": "71e11804052dbbcbce57519f6fb70099ad7b0741", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -17,72 +17,72 @@ use std::ops::{RangeInclusive, RangeToInclusive};\n fn foo() -> isize { 42 }\n \n // Test that range syntax works in return statements\n-fn return_range_to() -> RangeToInclusive<i32> { return ...1; }\n+fn return_range_to() -> RangeToInclusive<i32> { return ..=1; }\n \n pub fn main() {\n     let mut count = 0;\n-    for i in 0_usize...10 {\n+    for i in 0_usize..=10 {\n         assert!(i >= 0 && i <= 10);\n         count += i;\n     }\n     assert_eq!(count, 55);\n \n     let mut count = 0;\n-    let mut range = 0_usize...10;\n+    let mut range = 0_usize..=10;\n     for i in range {\n         assert!(i >= 0 && i <= 10);\n         count += i;\n     }\n     assert_eq!(count, 55);\n \n     let mut count = 0;\n-    for i in (0_usize...10).step_by(2) {\n+    for i in (0_usize..=10).step_by(2) {\n         assert!(i >= 0 && i <= 10 && i % 2 == 0);\n         count += i;\n     }\n     assert_eq!(count, 30);\n \n-    let _ = 0_usize...4+4-3;\n-    let _ = 0...foo();\n+    let _ = 0_usize..=4+4-3;\n+    let _ = 0..=foo();\n \n-    let _ = { &42...&100 }; // references to literals are OK\n-    let _ = ...42_usize;\n+    let _ = { &42..=&100 }; // references to literals are OK\n+    let _ = ..=42_usize;\n \n     // Test we can use two different types with a common supertype.\n     let x = &42;\n     {\n         let y = 42;\n-        let _ = x...&y;\n+        let _ = x..=&y;\n     }\n \n     // test collection indexing\n-    let vec = (0...10).collect::<Vec<_>>();\n+    let vec = (0..=10).collect::<Vec<_>>();\n     let slice: &[_] = &*vec;\n     let string = String::from(\"hello world\");\n     let stir = \"hello world\";\n \n-    assert_eq!(&vec[3...6], &[3, 4, 5, 6]);\n-    assert_eq!(&vec[ ...6], &[0, 1, 2, 3, 4, 5, 6]);\n+    assert_eq!(&vec[3..=6], &[3, 4, 5, 6]);\n+    assert_eq!(&vec[ ..=6], &[0, 1, 2, 3, 4, 5, 6]);\n \n-    assert_eq!(&slice[3...6], &[3, 4, 5, 6]);\n-    assert_eq!(&slice[ ...6], &[0, 1, 2, 3, 4, 5, 6]);\n+    assert_eq!(&slice[3..=6], &[3, 4, 5, 6]);\n+    assert_eq!(&slice[ ..=6], &[0, 1, 2, 3, 4, 5, 6]);\n \n-    assert_eq!(&string[3...6], \"lo w\");\n-    assert_eq!(&string[ ...6], \"hello w\");\n+    assert_eq!(&string[3..=6], \"lo w\");\n+    assert_eq!(&string[ ..=6], \"hello w\");\n \n-    assert_eq!(&stir[3...6], \"lo w\");\n-    assert_eq!(&stir[ ...6], \"hello w\");\n+    assert_eq!(&stir[3..=6], \"lo w\");\n+    assert_eq!(&stir[ ..=6], \"hello w\");\n \n     // test the size hints and emptying\n-    let mut long = 0...255u8;\n-    let mut short = 42...42u8;\n+    let mut long = 0..=255u8;\n+    let mut short = 42..=42u8;\n     assert_eq!(long.size_hint(), (256, Some(256)));\n     assert_eq!(short.size_hint(), (1, Some(1)));\n     long.next();\n     short.next();\n     assert_eq!(long.size_hint(), (255, Some(255)));\n     assert_eq!(short.size_hint(), (0, Some(0)));\n-    assert_eq!(short, 1...0);\n+    assert_eq!(short, 1..=0);\n \n     assert_eq!(long.len(), 255);\n     assert_eq!(short.len(), 0);\n@@ -94,31 +94,31 @@ pub fn main() {\n     assert_eq!(long.next(), Some(1));\n     assert_eq!(long.next(), Some(2));\n     assert_eq!(long.next_back(), Some(252));\n-    for i in 3...251 {\n+    for i in 3..=251 {\n         assert_eq!(long.next(), Some(i));\n     }\n-    assert_eq!(long, 1...0);\n+    assert_eq!(long, 1..=0);\n \n     // check underflow\n-    let mut narrow = 1...0;\n+    let mut narrow = 1..=0;\n     assert_eq!(narrow.next_back(), None);\n-    assert_eq!(narrow, 1...0);\n-    let mut zero = 0u8...0;\n+    assert_eq!(narrow, 1..=0);\n+    let mut zero = 0u8..=0;\n     assert_eq!(zero.next_back(), Some(0));\n     assert_eq!(zero.next_back(), None);\n-    assert_eq!(zero, 1...0);\n-    let mut high = 255u8...255;\n+    assert_eq!(zero, 1..=0);\n+    let mut high = 255u8..=255;\n     assert_eq!(high.next_back(), Some(255));\n     assert_eq!(high.next_back(), None);\n-    assert_eq!(high, 1...0);\n+    assert_eq!(high, 1..=0);\n \n     // what happens if you have a nonsense range?\n-    let mut nonsense = 10...5;\n+    let mut nonsense = 10..=5;\n     assert_eq!(nonsense.next(), None);\n-    assert_eq!(nonsense, 10...5);\n+    assert_eq!(nonsense, 10..=5);\n \n     // output\n-    assert_eq!(format!(\"{:?}\", 0...10), \"0...10\");\n-    assert_eq!(format!(\"{:?}\", ...10), \"...10\");\n-    assert_eq!(format!(\"{:?}\", long), \"1...0\");\n+    assert_eq!(format!(\"{:?}\", 0..=10), \"0..=10\");\n+    assert_eq!(format!(\"{:?}\", ..=10), \"..=10\");\n+    assert_eq!(format!(\"{:?}\", long), \"1..=0\");\n }"}, {"sha": "570087aedbbaaae993791baca2758f8a04780771", "filename": "src/test/run-pass/range_inclusive_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Frun-pass%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64efc91f49affb265328e354c8c8f0544daa462/src%2Ftest%2Frun-pass%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive_gate.rs?ref=e64efc91f49affb265328e354c8c8f0544daa462", "patch": "@@ -14,7 +14,7 @@\n \n fn main() {\n     let mut count = 0;\n-    for i in 0_usize...10 {\n+    for i in 0_usize..=10 {\n         assert!(i >= 0 && i <= 10);\n         count += i;\n     }"}]}