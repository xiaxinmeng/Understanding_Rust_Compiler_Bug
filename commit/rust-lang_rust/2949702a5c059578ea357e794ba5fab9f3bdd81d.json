{"sha": "2949702a5c059578ea357e794ba5fab9f3bdd81d", "node_id": "C_kwDOAAsO6NoAKDI5NDk3MDJhNWMwNTk1NzhlYTM1N2U3OTRiYTVmYWI5ZjNiZGQ4MWQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-11T21:34:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-12T10:16:52Z"}, "message": "Windows targets: make sure current_dir is absolute", "tree": {"sha": "1121ff11498e29e4c8ac4ace8fe6f1eaa23ad3a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1121ff11498e29e4c8ac4ace8fe6f1eaa23ad3a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2949702a5c059578ea357e794ba5fab9f3bdd81d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2949702a5c059578ea357e794ba5fab9f3bdd81d", "html_url": "https://github.com/rust-lang/rust/commit/2949702a5c059578ea357e794ba5fab9f3bdd81d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2949702a5c059578ea357e794ba5fab9f3bdd81d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "802987dc9e5e6cacc1a59b9095717665f5311924", "url": "https://api.github.com/repos/rust-lang/rust/commits/802987dc9e5e6cacc1a59b9095717665f5311924", "html_url": "https://github.com/rust-lang/rust/commit/802987dc9e5e6cacc1a59b9095717665f5311924"}], "stats": {"total": 45, "additions": 33, "deletions": 12}, "files": [{"sha": "0375a228a2148833b3153ed092169c64efb0aa83", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2949702a5c059578ea357e794ba5fab9f3bdd81d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2949702a5c059578ea357e794ba5fab9f3bdd81d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=2949702a5c059578ea357e794ba5fab9f3bdd81d", "patch": "@@ -232,6 +232,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.alloc_os_str_as_c_str(&os_str, memkind)\n     }\n \n+    #[allow(clippy::get_first)]\n     fn convert_path<'a>(\n         &self,\n         os_str: Cow<'a, OsStr>,\n@@ -260,20 +261,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     // If this is an absolute Windows path that starts with a drive letter (`C:/...`\n                     // after separator conversion), it would not be considered absolute by Unix\n                     // target code.\n-                    if converted.get(1).copied() == Some(':' as u16)\n-                        && converted.get(2).copied() == Some('/' as u16)\n+                    if converted.get(1).copied() == Some(b':' as u16)\n+                        && converted.get(2).copied() == Some(b'/' as u16)\n                     {\n                         // We add a `/` at the beginning, to store the absolute Windows\n                         // path in something that looks like an absolute Unix path.\n-                        converted.insert(0, '/' as u16);\n+                        converted.insert(0, b'/' as u16);\n                     }\n                 }\n                 PathConversion::TargetToHost => {\n                     // If the path is `\\C:\\`, the leading backslash was probably added by the above code\n                     // and we should get rid of it again.\n-                    if converted.get(0).copied() == Some('\\\\' as u16)\n-                        && converted.get(2).copied() == Some(':' as u16)\n-                        && converted.get(3).copied() == Some('\\\\' as u16)\n+                    if converted.get(0).copied() == Some(b'\\\\' as u16)\n+                        && converted.get(2).copied() == Some(b':' as u16)\n+                        && converted.get(3).copied() == Some(b'\\\\' as u16)\n                     {\n                         converted.remove(0);\n                     }\n@@ -285,16 +286,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         return if target_os == \"windows\" {\n             // Windows target, Unix host.\n             let (from, to) = match direction {\n-                PathConversion::HostToTarget => ('/', '\\\\'),\n-                PathConversion::TargetToHost => ('\\\\', '/'),\n+                PathConversion::HostToTarget => (b'/', b'\\\\'),\n+                PathConversion::TargetToHost => (b'\\\\', b'/'),\n             };\n-            let converted = os_str\n+            let mut converted = os_str\n                 .as_bytes()\n                 .iter()\n-                .map(|&wchar| if wchar == from as u8 { to as u8 } else { wchar })\n+                .map(|&wchar| if wchar == from { to } else { wchar })\n                 .collect::<Vec<_>>();\n-            // TODO: Once we actually support file system things on Windows targets, we'll probably\n-            // have to also do something clever for absolute path preservation here, like above.\n+            // We also have to ensure that absolute paths remain absolute.\n+            match direction {\n+                PathConversion::HostToTarget => {\n+                    // If this start withs a `\\`, we add `\\\\?` so it starts with `\\\\?\\` which is\n+                    // some magic path on Windos that *is* considered absolute.\n+                    if converted.get(0).copied() == Some(b'\\\\') {\n+                        converted.splice(0..0, b\"\\\\\\\\?\".iter().copied());\n+                    }\n+                }\n+                PathConversion::TargetToHost => {\n+                    // If this starts with `//?/`, it was probably produced by the above code and we\n+                    // remove the `//?` that got added to get the Unix path back out.\n+                    if converted.get(0).copied() == Some(b'/')\n+                        && converted.get(1).copied() == Some(b'/')\n+                        && converted.get(2).copied() == Some(b'?')\n+                        && converted.get(3).copied() == Some(b'/')\n+                    {\n+                        // Remove first 3 characters\n+                        converted.splice(0..3, std::iter::empty());\n+                    }\n+                }\n+            }\n             Cow::Owned(OsString::from_vec(converted))\n         } else {\n             // Unix-on-Unix, all is fine."}]}