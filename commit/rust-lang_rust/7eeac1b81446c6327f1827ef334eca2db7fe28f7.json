{"sha": "7eeac1b81446c6327f1827ef334eca2db7fe28f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZWFjMWI4MTQ0NmM2MzI3ZjE4MjdlZjMzNGVjYTJkYjdmZTI4Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-30T20:12:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-30T20:12:25Z"}, "message": "Auto merge of #43932 - eddyb:const-scoping, r=nikomatsakis\n\nForward-compatibly deny drops in constants if they *could* actually run.\n\nThis is part of #40036, specifically the checks for user-defined destructor invocations on locals which *may not* have been moved away, the motivating example being:\n```rust\nconst FOO: i32 = (HasDrop {...}, 0).1;\n```\nThe evaluation of constant MIR will continue to create `'static` slots for more locals than is necessary (if `Storage{Live,Dead}` statements are ignored), but it shouldn't be misusable.\n\nr? @nikomatsakis", "tree": {"sha": "5bef3331d201a6eb12d723d6f4c825a8206b3bb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bef3331d201a6eb12d723d6f4c825a8206b3bb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7eeac1b81446c6327f1827ef334eca2db7fe28f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7eeac1b81446c6327f1827ef334eca2db7fe28f7", "html_url": "https://github.com/rust-lang/rust/commit/7eeac1b81446c6327f1827ef334eca2db7fe28f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7eeac1b81446c6327f1827ef334eca2db7fe28f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51a54b6dc0b51d270d46d9d388e627201f0986db", "url": "https://api.github.com/repos/rust-lang/rust/commits/51a54b6dc0b51d270d46d9d388e627201f0986db", "html_url": "https://github.com/rust-lang/rust/commit/51a54b6dc0b51d270d46d9d388e627201f0986db"}, {"sha": "c76a024121d8d92af8c5c44651bc72a177565281", "url": "https://api.github.com/repos/rust-lang/rust/commits/c76a024121d8d92af8c5c44651bc72a177565281", "html_url": "https://github.com/rust-lang/rust/commit/c76a024121d8d92af8c5c44651bc72a177565281"}], "stats": {"total": 231, "additions": 177, "deletions": 54}, "files": [{"sha": "8b01d5045c6b06b39f2e3d3634e9cc29a890482f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7eeac1b81446c6327f1827ef334eca2db7fe28f7", "patch": "@@ -223,7 +223,9 @@ pub struct RegionMaps {\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: NodeMap<CodeExtent>,\n+    /// In constants, None is used to indicate that certain expressions\n+    /// escape into 'static and should have no local cleanup scope.\n+    rvalue_scopes: NodeMap<Option<CodeExtent>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -358,9 +360,11 @@ impl<'tcx> RegionMaps {\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: Option<CodeExtent>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        if let Some(lifetime) = lifetime {\n+            assert!(var != lifetime.node_id());\n+        }\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n@@ -389,7 +393,7 @@ impl<'tcx> RegionMaps {\n         // check for a designated rvalue scope\n         if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n-            return Some(s);\n+            return s;\n         }\n \n         // else, locate the innermost terminating scope\n@@ -803,16 +807,11 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n }\n \n fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n-                           local: &'tcx hir::Local) {\n-    debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n-           local.id,local.init.is_some());\n+                           pat: Option<&'tcx hir::Pat>,\n+                           init: Option<&'tcx hir::Expr>) {\n+    debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n-    // For convenience in trans, associate with the local-id the var\n-    // scope that will be used for any bindings declared in this\n-    // pattern.\n     let blk_scope = visitor.cx.var_parent;\n-    let blk_scope = blk_scope.expect(\"locals must be within a block\");\n-    visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n     // lifetimes, initializers in a let have a temporary lifetime\n@@ -872,15 +871,22 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     //\n     // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n-    if let Some(ref expr) = local.init {\n+    if let Some(expr) = init {\n         record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n-        if is_binding_pat(&local.pat) {\n-            record_rvalue_scope(visitor, &expr, blk_scope);\n+        if let Some(pat) = pat {\n+            if is_binding_pat(pat) {\n+                record_rvalue_scope(visitor, &expr, blk_scope);\n+            }\n         }\n     }\n \n-    intravisit::walk_local(visitor, local);\n+    if let Some(pat) = pat {\n+        visitor.visit_pat(pat);\n+    }\n+    if let Some(expr) = init {\n+        visitor.visit_expr(expr);\n+    }\n \n     /// True if `pat` match the `P&` nonterminal:\n     ///\n@@ -954,7 +960,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n         visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         expr: &hir::Expr,\n-        blk_id: CodeExtent)\n+        blk_id: Option<CodeExtent>)\n     {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n@@ -1004,7 +1010,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n-                                     blk_scope: CodeExtent) {\n+                                     blk_scope: Option<CodeExtent>) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n@@ -1077,12 +1083,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         let outer_cx = self.cx;\n         let outer_ts = mem::replace(&mut self.terminating_scopes, NodeSet());\n-\n-        // Only functions have an outer terminating (drop) scope,\n-        // while temporaries in constant initializers are 'static.\n-        if let MirSource::Fn(_) = MirSource::from_node(self.tcx, owner_id) {\n-            self.terminating_scopes.insert(body_id.node_id);\n-        }\n+        self.terminating_scopes.insert(body_id.node_id);\n \n         if let Some(root_id) = self.cx.root_id {\n             self.region_maps.record_fn_parent(body_id.node_id, root_id);\n@@ -1100,7 +1101,30 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         // The body of the every fn is a root scope.\n         self.cx.parent = self.cx.var_parent;\n-        self.visit_expr(&body.value);\n+        if let MirSource::Fn(_) = MirSource::from_node(self.tcx, owner_id) {\n+            self.visit_expr(&body.value);\n+        } else {\n+            // Only functions have an outer terminating (drop) scope, while\n+            // temporaries in constant initializers may be 'static, but only\n+            // according to rvalue lifetime semantics, using the same\n+            // syntactical rules used for let initializers.\n+            //\n+            // E.g. in `let x = &f();`, the temporary holding the result from\n+            // the `f()` call lives for the entirety of the surrounding block.\n+            //\n+            // Similarly, `const X: ... = &f();` would have the result of `f()`\n+            // live for `'static`, implying (if Drop restrictions on constants\n+            // ever get lifted) that the value *could* have a destructor, but\n+            // it'd get leaked instead of the destructor running during the\n+            // evaluation of `X` (if at all allowed by CTFE).\n+            //\n+            // However, `const Y: ... = g(&f());`, like `let y = g(&f());`,\n+            // would *not* let the `f()` temporary escape into an outer scope\n+            // (i.e. `'static`), which means that after `g` returns, it drops,\n+            // and all the associated destruction scope rules apply.\n+            self.cx.var_parent = None;\n+            resolve_local(self, None, Some(&body.value));\n+        }\n \n         // Restore context we had at the start.\n         self.cx = outer_cx;\n@@ -1120,7 +1144,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local) {\n-        resolve_local(self, l);\n+        resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n     }\n }\n "}, {"sha": "2198b533ea07a753b5241400ccfc1d73b0b2abbd", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=7eeac1b81446c6327f1827ef334eca2db7fe28f7", "patch": "@@ -120,6 +120,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n     const_fn_arg_vars: BitVector,\n+    local_needs_drop: IndexVec<Local, Option<Span>>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -146,6 +147,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             return_qualif: None,\n             qualif: Qualif::empty(),\n             const_fn_arg_vars: BitVector::new(mir.local_decls.len()),\n+            local_needs_drop: IndexVec::from_elem(None, &mir.local_decls),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -193,16 +195,26 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         self.add(original);\n     }\n \n+    /// Check for NEEDS_DROP (from an ADT or const fn call) and\n+    /// error, unless we're in a function.\n+    fn always_deny_drop(&self) {\n+        self.deny_drop_with_feature_gate_override(false);\n+    }\n+\n     /// Check for NEEDS_DROP (from an ADT or const fn call) and\n     /// error, unless we're in a function, or the feature-gate\n     /// for globals with destructors is enabled.\n     fn deny_drop(&self) {\n+        self.deny_drop_with_feature_gate_override(true);\n+    }\n+\n+    fn deny_drop_with_feature_gate_override(&self, allow_gate: bool) {\n         if self.mode == Mode::Fn || !self.qualif.intersects(Qualif::NEEDS_DROP) {\n             return;\n         }\n \n         // Static and const fn's allow destructors, but they're feature-gated.\n-        let msg = if self.mode != Mode::Const {\n+        let msg = if allow_gate && self.mode != Mode::Const {\n             // Feature-gate for globals with destructors is enabled.\n             if self.tcx.sess.features.borrow().drop_types_in_const {\n                 return;\n@@ -223,15 +235,16 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         let mut err =\n             struct_span_err!(self.tcx.sess, self.span, E0493, \"{}\", msg);\n \n-        if self.mode != Mode::Const {\n+        if allow_gate && self.mode != Mode::Const {\n             help!(&mut err,\n                   \"in Nightly builds, add `#![feature(drop_types_in_const)]` \\\n                    to the crate attributes to enable\");\n         } else {\n             self.find_drop_implementation_method_span()\n                 .map(|span| err.span_label(span, \"destructor defined here\"));\n \n-            err.span_label(self.span, \"constants cannot have destructors\");\n+            err.span_label(self.span,\n+                format!(\"{}s cannot have destructors\", self.mode));\n         }\n \n         err.emit();\n@@ -314,6 +327,15 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             return;\n         }\n \n+        // When initializing a local, record whether the *value* being\n+        // stored in it needs dropping, which it may not, even if its\n+        // type does, e.g. `None::<String>`.\n+        if let Lvalue::Local(local) = *dest {\n+            if qualif.intersects(Qualif::NEEDS_DROP) {\n+                self.local_needs_drop[local] = Some(self.span);\n+            }\n+        }\n+\n         match *dest {\n             Lvalue::Local(index) if self.mir.local_kind(index) == LocalKind::Temp => {\n                 debug!(\"store to temp {:?}\", index);\n@@ -360,7 +382,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n             let target = match mir[bb].terminator().kind {\n                 TerminatorKind::Goto { target } |\n-                // Drops are considered noops.\n                 TerminatorKind::Drop { target, .. } |\n                 TerminatorKind::Assert { target, .. } |\n                 TerminatorKind::Call { destination: Some((_, target)), .. } => {\n@@ -560,22 +581,32 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         match *operand {\n-            Operand::Consume(_) => {\n+            Operand::Consume(ref lvalue) => {\n                 self.nest(|this| {\n                     this.super_operand(operand, location);\n                     this.try_consume();\n                 });\n+\n+                // Mark the consumed locals to indicate later drops are noops.\n+                if let Lvalue::Local(local) = *lvalue {\n+                    self.local_needs_drop[local] = None;\n+                }\n             }\n             Operand::Constant(ref constant) => {\n-                if let Literal::Item { def_id, substs } = constant.literal {\n-                    // Don't peek inside generic (associated) constants.\n-                    if substs.types().next().is_some() {\n+                if let Literal::Item { def_id, substs: _ } = constant.literal {\n+                    // Don't peek inside trait associated constants.\n+                    if self.tcx.trait_of_item(def_id).is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n                         let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n                         self.add(qualif);\n+\n+                        // Just in case the type is more specific than\n+                        // the definition, e.g. impl associated const\n+                        // with type parameters, take it into account.\n+                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n                     }\n \n                     // Let `const fn` transitively have destructors,\n@@ -866,6 +897,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n                 self.assign(dest, location);\n             }\n+        } else if let TerminatorKind::Drop { location: ref lvalue, .. } = *kind {\n+            self.super_terminator_kind(bb, kind, location);\n+\n+            // Deny *any* live drops anywhere other than functions.\n+            if self.mode != Mode::Fn {\n+                // HACK(eddyb) Emulate a bit of dataflow analysis,\n+                // conservatively, that drop elaboration will do.\n+                let needs_drop = if let Lvalue::Local(local) = *lvalue {\n+                    self.local_needs_drop[local]\n+                } else {\n+                    None\n+                };\n+\n+                if let Some(span) = needs_drop {\n+                    let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    self.add_type(ty);\n+\n+                    // Use the original assignment span to be more precise.\n+                    let old_span = self.span;\n+                    self.span = span;\n+                    self.always_deny_drop();\n+                    self.span = old_span;\n+                }\n+            }\n         } else {\n             // Qualify any operands inside other terminators.\n             self.super_terminator_kind(bb, kind, location);"}, {"sha": "41ba7d678e88a34b9930d078be09ab0827f9f24f", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7eeac1b81446c6327f1827ef334eca2db7fe28f7", "patch": "@@ -87,19 +87,14 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n     }\n \n-    // Adds the worst effect out of all the values of one type.\n-    fn add_type(&mut self, ty: Ty<'gcx>) {\n-        if !ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n-            self.promotable = false;\n-        }\n-\n-        if ty.needs_drop(self.tcx, self.param_env) {\n-            self.promotable = false;\n-        }\n+    // Returns true iff all the values of the type are promotable.\n+    fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n+        ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n+        !ty.needs_drop(self.tcx, self.param_env)\n     }\n \n     fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>) {\n-        self.add_type(ret_ty);\n+        self.promotable &= self.type_has_only_promotable_values(ret_ty);\n \n         self.promotable &= if let Some(fn_id) = self.tcx.hir.as_local_node_id(def_id) {\n             FnLikeNode::from_node(self.tcx.hir.get(fn_id)).map_or(false, |fn_like| {\n@@ -333,20 +328,30 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n-                Def::AssociatedConst(_) => v.add_type(node_ty),\n-                Def::Const(did) => {\n-                    v.promotable &= if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n-                        match v.tcx.hir.expect_item(node_id).node {\n-                            hir::ItemConst(_, body) => {\n+\n+                Def::Const(did) |\n+                Def::AssociatedConst(did) => {\n+                    let promotable = if v.tcx.trait_of_item(did).is_some() {\n+                        // Don't peek inside trait associated constants.\n+                        false\n+                    } else if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n+                        match v.tcx.hir.maybe_body_owned_by(node_id) {\n+                            Some(body) => {\n                                 v.visit_nested_body(body);\n                                 v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]\n                             }\n-                            _ => false\n+                            None => false\n                         }\n                     } else {\n                         v.tcx.const_is_rvalue_promotable_to_static(did)\n                     };\n+\n+                    // Just in case the type is more specific than the definition,\n+                    // e.g. impl associated const with type parameters, check it.\n+                    // Also, trait associated consts are relaxed by this.\n+                    v.promotable &= promotable || v.type_has_only_promotable_values(node_ty);\n                 }\n+\n                 _ => {\n                     v.promotable = false;\n                 }"}, {"sha": "c349aababd6c01e2448d2c759e15cf8b64eaa515", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=7eeac1b81446c6327f1827ef334eca2db7fe28f7", "patch": "@@ -86,8 +86,9 @@ static STATIC8: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n // This example should fail because field1 in the base struct is not safe\n static STATIC9: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n                                         ..SafeStruct{field1: SafeEnum::Variant3(WithDtor),\n+//~^ ERROR destructors in statics are an unstable feature\n+//~| ERROR statics are not allowed to have destructors\n                                                      field2: SafeEnum::Variant1}};\n-//~^^ ERROR destructors in statics are an unstable feature\n \n struct UnsafeStruct;\n "}, {"sha": "e5f10b65ceed7ef0d001130fa3ea54d01bb92428", "filename": "src/test/compile-fail/static-drop-scope.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Ftest%2Fcompile-fail%2Fstatic-drop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Ftest%2Fcompile-fail%2Fstatic-drop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-drop-scope.rs?ref=7eeac1b81446c6327f1827ef334eca2db7fe28f7", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(drop_types_in_const)]\n+\n+struct WithDtor;\n+\n+impl Drop for WithDtor {\n+    fn drop(&mut self) {}\n+}\n+\n+static FOO: Option<&'static WithDtor> = Some(&WithDtor);\n+//~^ ERROR statics are not allowed to have destructors\n+//~| ERROR borrowed value does not live long enoug\n+\n+static BAR: i32 = (WithDtor, 0).1;\n+//~^ ERROR statics are not allowed to have destructors\n+\n+fn main () {}"}, {"sha": "acf96b566df840165a7023244ae8f9c21dd17d29", "filename": "src/test/run-pass/rvalue-static-promotion.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Ftest%2Frun-pass%2Frvalue-static-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eeac1b81446c6327f1827ef334eca2db7fe28f7/src%2Ftest%2Frun-pass%2Frvalue-static-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frvalue-static-promotion.rs?ref=7eeac1b81446c6327f1827ef334eca2db7fe28f7", "patch": "@@ -8,8 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(unused_variables)]\n+use std::cell::Cell;\n+\n+const NONE_CELL_STRING: Option<Cell<String>> = None;\n+\n+struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    const FOO: Option<Box<T>> = None;\n+}\n+\n fn main() {\n-    let x: &'static u32 = &42;\n-    let y: &'static Option<u32> = &None;\n+    let _: &'static u32 = &42;\n+    let _: &'static Option<u32> = &None;\n+\n+    // We should be able to peek at consts and see they're None.\n+    let _: &'static Option<Cell<String>> = &NONE_CELL_STRING;\n+    let _: &'static Option<Box<()>> = &Foo::FOO;\n }"}]}