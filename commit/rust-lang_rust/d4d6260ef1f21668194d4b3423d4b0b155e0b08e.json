{"sha": "d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZDYyNjBlZjFmMjE2NjgxOTRkNGIzNDIzZDRiMGIxNTVlMGIwOGU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-09T18:27:36Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-10T11:50:13Z"}, "message": "don't be a breaking change, even in presence of overflowing literals", "tree": {"sha": "ec337f291ac28d8e756d05c741e6ef96b607571f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec337f291ac28d8e756d05c741e6ef96b607571f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "html_url": "https://github.com/rust-lang/rust/commit/d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7003ed3fa75f714bd636392ad4c40968652f6320", "url": "https://api.github.com/repos/rust-lang/rust/commits/7003ed3fa75f714bd636392ad4c40968652f6320", "html_url": "https://github.com/rust-lang/rust/commit/7003ed3fa75f714bd636392ad4c40968652f6320"}], "stats": {"total": 140, "additions": 57, "deletions": 83}, "files": [{"sha": "d97df585edc053e9c3a56fd859ab3b96108b6066", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 37, "deletions": 73, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "patch": "@@ -855,10 +855,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           try!(eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args)))\n       },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety, lit.span) {\n-          Ok(val) => val,\n-          Err(err) => signal!(e, Math(err)),\n-      },\n+      hir::ExprLit(ref lit) => try!(lit_to_const(&lit.node, tcx, ety, lit.span)),\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)),\n@@ -926,7 +923,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         if let Tuple(tup_id) = c {\n             if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                 if index.node < fields.len() {\n-                    return eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args)\n+                    try!(eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args))\n                 } else {\n                     signal!(e, TupleIndexOutOfBounds);\n                 }\n@@ -947,7 +944,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 // if the idents are compared run-pass/issue-19244 fails\n                 if let Some(f) = fields.iter().find(|f| f.name.node\n                                                      == field_name.node) {\n-                    return eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args)\n+                    try!(eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args))\n                 } else {\n                     signal!(e, MissingStructField);\n                 }\n@@ -974,22 +971,6 @@ fn infer<'tcx>(\n     span: Span\n ) -> Result<ConstInt, ConstEvalErr> {\n     use syntax::ast::*;\n-    const I8MAX: u64 = ::std::i8::MAX as u64;\n-    const I16MAX: u64 = ::std::i16::MAX as u64;\n-    const I32MAX: u64 = ::std::i32::MAX as u64;\n-    const I64MAX: u64 = ::std::i64::MAX as u64;\n-\n-    const U8MAX: u64 = ::std::u8::MAX as u64;\n-    const U16MAX: u64 = ::std::u16::MAX as u64;\n-    const U32MAX: u64 = ::std::u32::MAX as u64;\n-\n-    const I8MAXI: i64 = ::std::i8::MAX as i64;\n-    const I16MAXI: i64 = ::std::i16::MAX as i64;\n-    const I32MAXI: i64 = ::std::i32::MAX as i64;\n-\n-    const I8MINI: i64 = ::std::i8::MIN as i64;\n-    const I16MINI: i64 = ::std::i16::MIN as i64;\n-    const I32MINI: i64 = ::std::i32::MIN as i64;\n \n     let err = |e| ConstEvalErr {\n         span: span,\n@@ -1009,41 +990,38 @@ fn infer<'tcx>(\n         (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n         (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n \n-        (&ty::TyInt(IntTy::I8), Infer(i @ 0...I8MAX)) => Ok(I8(i as i8)),\n-        (&ty::TyInt(IntTy::I16), Infer(i @ 0...I16MAX)) => Ok(I16(i as i16)),\n-        (&ty::TyInt(IntTy::I32), Infer(i @ 0...I32MAX)) => Ok(I32(i as i32)),\n-        (&ty::TyInt(IntTy::I64), Infer(i @ 0...I64MAX)) => Ok(I64(i as i64)),\n-        (&ty::TyInt(IntTy::Is), Infer(i @ 0...I64MAX)) => {\n+        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i64 as i8)),\n+        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i64 as i16)),\n+        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i64 as i32)),\n+        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::Is), Infer(i)) => {\n             match ConstIsize::new(i as i64, tcx.sess.target.int_type) {\n                 Ok(val) => Ok(Isize(val)),\n-                Err(e) => Err(err(e.into())),\n+                Err(_) => Ok(Isize(ConstIsize::Is32(i as i64 as i32))),\n             }\n         },\n-        (&ty::TyInt(_), Infer(_)) => Err(err(Math(ConstMathErr::NotInRange))),\n \n-        (&ty::TyInt(IntTy::I8), InferSigned(i @ I8MINI...I8MAXI)) => Ok(I8(i as i8)),\n-        (&ty::TyInt(IntTy::I16), InferSigned(i @ I16MINI...I16MAXI)) => Ok(I16(i as i16)),\n-        (&ty::TyInt(IntTy::I32), InferSigned(i @ I32MINI...I32MAXI)) => Ok(I32(i as i32)),\n+        (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n+        (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n+        (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n         (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i)),\n         (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n             match ConstIsize::new(i, tcx.sess.target.int_type) {\n                 Ok(val) => Ok(Isize(val)),\n-                Err(e) => Err(err(e.into())),\n+                Err(_) => Ok(Isize(ConstIsize::Is32(i as i32))),\n             }\n         },\n-        (&ty::TyInt(_), InferSigned(_)) => Err(err(Math(ConstMathErr::NotInRange))),\n \n-        (&ty::TyUint(UintTy::U8), Infer(i @ 0...U8MAX)) => Ok(U8(i as u8)),\n-        (&ty::TyUint(UintTy::U16), Infer(i @ 0...U16MAX)) => Ok(U16(i as u16)),\n-        (&ty::TyUint(UintTy::U32), Infer(i @ 0...U32MAX)) => Ok(U32(i as u32)),\n+        (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n+        (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n+        (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n         (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i)),\n         (&ty::TyUint(UintTy::Us), Infer(i)) => {\n             match ConstUsize::new(i, tcx.sess.target.uint_type) {\n                 Ok(val) => Ok(Usize(val)),\n-                Err(e) => Err(err(e.into())),\n+                Err(_) => Ok(Usize(ConstUsize::Us32(i as u32))),\n             }\n         },\n-        (&ty::TyUint(_), Infer(_)) => Err(err(Math(ConstMathErr::NotInRange))),\n         (&ty::TyUint(_), InferSigned(_)) => Err(err(IntermediateUnsignedNegative)),\n \n         (&ty::TyInt(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n@@ -1115,19 +1093,25 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n         ty::TyBool if v == 1 => Ok(Bool(true)),\n-        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i8))),\n-        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i16))),\n-        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i32))),\n+        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i64 as i8))),\n+        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i64 as i16))),\n+        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i64 as i32))),\n         ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i64))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(try!(ConstIsize::new(v as i64, tcx.sess.target.int_type)))))\n+            match ConstIsize::new(v as i64, tcx.sess.target.int_type) {\n+                Ok(val) => Ok(Integral(Isize(val))),\n+                Err(_) => Ok(Integral(Isize(ConstIsize::Is32(v as i64 as i32)))),\n+            }\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n-        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n+        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v))),\n         ty::TyUint(ast::UintTy::Us) => {\n-            Ok(Integral(Usize(try!(ConstUsize::new(v, tcx.sess.target.uint_type)))))\n+            match ConstUsize::new(v, tcx.sess.target.uint_type) {\n+                Ok(val) => Ok(Integral(Usize(val))),\n+                Err(_) => Ok(Integral(Usize(ConstUsize::Us32(v as u32)))),\n+            }\n         },\n         ty::TyFloat(ast::FloatTy::F64) if val.is_negative() => {\n             // FIXME: this could probably be prettier\n@@ -1174,57 +1158,37 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                       tcx: &TyCtxt<'tcx>,\n                       ty_hint: Option<Ty<'tcx>>,\n                       span: Span,\n-                      ) -> Result<ConstVal, ConstMathErr> {\n+                      ) -> Result<ConstVal, ConstEvalErr> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n-    const I8MAX: u64 = ::std::i8::MAX as u64;\n-    const I16MAX: u64 = ::std::i16::MAX as u64;\n-    const I32MAX: u64 = ::std::i32::MAX as u64;\n-    const I64MAX: u64 = ::std::i64::MAX as u64;\n-    const U8MAX: u64 = ::std::u8::MAX as u64;\n-    const U16MAX: u64 = ::std::u16::MAX as u64;\n-    const U32MAX: u64 = ::std::u32::MAX as u64;\n-    const U64MAX: u64 = ::std::u64::MAX as u64;\n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n-        LitKind::Int(n @ 0...I8MAX, Signed(IntTy::I8)) => Ok(Integral(I8(n as i8))),\n-        LitKind::Int(n @ 0...I16MAX, Signed(IntTy::I16)) => Ok(Integral(I16(n as i16))),\n-        LitKind::Int(n @ 0...I32MAX, Signed(IntTy::I32)) => Ok(Integral(I32(n as i32))),\n-        LitKind::Int(n @ 0...I64MAX, Signed(IntTy::I64)) => Ok(Integral(I64(n as i64))),\n-        LitKind::Int(n, Signed(IntTy::Is)) => {\n-            Ok(Integral(Isize(try!(ConstIsize::new(n as i64, tcx.sess.target.int_type)))))\n+        LitKind::Int(n, Signed(ity)) => {\n+            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n         },\n \n-        LitKind::Int(_, Signed(ty)) => Err(ConstMathErr::LitOutOfRange(ty)),\n-\n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    lit_to_const(&LitKind::Int(n, Signed(ity)), tcx, ty_hint, span)\n+                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    lit_to_const(&LitKind::Int(n, Unsigned(uty)), tcx, ty_hint, span)\n+                    infer(Infer(n), tcx, &ty::TyUint(uty), span).map(Integral)\n                 },\n                 None => Ok(Integral(Infer(n))),\n                 Some(&ty::TyEnum(ref adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    lit_to_const(lit, tcx, Some(int_ty.to_ty(tcx)), span)\n+                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n                 },\n                 Some(ty_hint) => panic!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n-        LitKind::Int(n @ 0...U8MAX, Unsigned(UintTy::U8)) => Ok(Integral(U8(n as u8))),\n-        LitKind::Int(n @ 0...U16MAX, Unsigned(UintTy::U16)) => Ok(Integral(U16(n as u16))),\n-        LitKind::Int(n @ 0...U32MAX, Unsigned(UintTy::U32)) => Ok(Integral(U32(n as u32))),\n-        LitKind::Int(n @ 0...U64MAX, Unsigned(UintTy::U64)) => Ok(Integral(U64(n as u64))),\n-\n-        LitKind::Int(n, Unsigned(UintTy::Us)) => {\n-            Ok(Integral(Usize(try!(ConstUsize::new(n as u64, tcx.sess.target.uint_type)))))\n+        LitKind::Int(n, Unsigned(ity)) => {\n+            infer(Infer(n), tcx, &ty::TyUint(ity), span).map(Integral)\n         },\n-        LitKind::Int(_, Unsigned(ty)) => Err(ConstMathErr::ULitOutOfRange(ty)),\n \n         LitKind::Float(ref n, _) |\n         LitKind::FloatUnsuffixed(ref n) => {"}, {"sha": "15253987bf2b230b2bd1b7276932b60478a41a4d", "filename": "src/librustc_const_eval/int.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Flibrustc_const_eval%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Flibrustc_const_eval%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fint.rs?ref=d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "patch": "@@ -73,11 +73,11 @@ impl ConstInt {\n             (_, InferSigned(_))\n             | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n \n-            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i8),\n-            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i16),\n-            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i32),\n+            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i64 as i8),\n+            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i64 as i16),\n+            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i64 as i32),\n             (Infer(a @ 0...as_u64::I64MAX), I64(_)) => I64(a as i64),\n-            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i32)),\n+            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n             (Infer(a @ 0...as_u64::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n             (Infer(a @ 0...as_u64::U8MAX), U8(_)) => U8(a as u8),\n             (Infer(a @ 0...as_u64::U16MAX), U16(_)) => U16(a as u16),"}, {"sha": "d66716c14c3d5ee15b42e1ffb75ebc72fe691219", "filename": "src/test/compile-fail/enum-discrim-too-small2.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs?ref=d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "patch": "@@ -8,32 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(overflowing_literals)]\n+#![allow(dead_code)]\n+\n #[repr(i8)]\n enum Ei8 {\n     Ai8 = 23,\n     Bi8 = -23,\n-    Ci8 = 223, //~ ERROR literal out of range for i8 [E0080]\n+    Ci8 = 223, //~ ERROR literal out of range for i8\n }\n \n #[repr(i16)]\n enum Ei16 {\n     Ai16 = 23,\n     Bi16 = -22333,\n-    Ci16 = 55555, //~ ERROR literal out of range for i16 [E0080]\n+    Ci16 = 55555, //~ ERROR literal out of range for i16\n }\n \n #[repr(i32)]\n enum Ei32 {\n     Ai32 = 23,\n     Bi32 = -2_000_000_000,\n-    Ci32 = 3_000_000_000, //~ ERROR literal out of range for i32 [E0080]\n+    Ci32 = 3_000_000_000, //~ ERROR literal out of range for i32\n }\n \n #[repr(i64)]\n enum Ei64 {\n     Ai64 = 23,\n     Bi64 = -9223372036854775808,\n-    Ci64 = 9223372036854775809, //~ ERROR literal out of range for i64 [E0080]\n+    Ci64 = 9223372036854775809, //~ ERROR literal out of range for i64\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "8fc18d16469e37d3356736bff1cccd097005c0dc", "filename": "src/test/compile-fail/lint-type-limits2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs?ref=d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "patch": "@@ -19,5 +19,6 @@ fn bar() -> i8 {\n }\n \n fn baz() -> bool {\n-    128 > bar() //~ ERROR literal out of range for i8\n+    128 > bar() //~ ERROR comparison is useless due to type limits\n+                //~| WARN literal out of range for i8\n }"}, {"sha": "b09dc0acdbf91f41e9f50551a6c7f2c8893d7b15", "filename": "src/test/compile-fail/lint-type-limits3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs?ref=d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "patch": "@@ -15,7 +15,8 @@ fn main() { }\n \n fn qux() {\n     let mut i = 1i8;\n-    while 200 != i { //~ ERROR literal out of range for i8\n+    while 200 != i { //~ ERROR comparison is useless due to type limits\n+                     //~| WARN literal out of range for i8\n         i += 1;\n     }\n }"}, {"sha": "96f4217e4cb8023f6c9b6ac4bc9435484a7cb062", "filename": "src/test/run-pass/const-negation.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d6260ef1f21668194d4b3423d4b0b155e0b08e/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negation.rs?ref=d4d6260ef1f21668194d4b3423d4b0b155e0b08e", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(stmt_expr_attributes)]\n+\n #[deny(const_err)]\n \n fn main() {\n@@ -18,7 +20,10 @@ fn main() {\n     assert_eq!(::std::i32::MIN as u64, 0xffffffff80000000);\n     assert_eq!(-2147483648isize as u64, 0xffffffff80000000);\n     assert_eq!(::std::i64::MIN as u64, 0x8000000000000000);\n+    #[cfg(target_pointer_width = \"64\")]\n     assert_eq!(-9223372036854775808isize as u64, 0x8000000000000000);\n+    #[cfg(target_pointer_width = \"32\")]\n+    assert_eq!(-9223372036854775808isize as u64, 0);\n     const J: usize = ::std::i32::MAX as usize;\n     const K: usize = -1i32 as u32 as usize;\n     const L: usize = ::std::i32::MIN as usize;"}]}