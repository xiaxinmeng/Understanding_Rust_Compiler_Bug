{"sha": "db13e6fa34707c62c5d87aa057813a40c67e29c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMTNlNmZhMzQ3MDdjNjJjNWQ4N2FhMDU3ODEzYTQwYzY3ZTI5YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T13:31:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T13:31:44Z"}, "message": "Auto merge of #3756 - g-bartoszek:redundant-closure-for-methods, r=oli-obk\n\nRedundant closure for methods\n\nfixes  #3469", "tree": {"sha": "e18e177754a422f7bc0fab1581e36fcb65ed866d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e18e177754a422f7bc0fab1581e36fcb65ed866d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db13e6fa34707c62c5d87aa057813a40c67e29c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db13e6fa34707c62c5d87aa057813a40c67e29c4", "html_url": "https://github.com/rust-lang/rust/commit/db13e6fa34707c62c5d87aa057813a40c67e29c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db13e6fa34707c62c5d87aa057813a40c67e29c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed3287605d9e773744cb41305efcf6402c30936a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3287605d9e773744cb41305efcf6402c30936a", "html_url": "https://github.com/rust-lang/rust/commit/ed3287605d9e773744cb41305efcf6402c30936a"}, {"sha": "f7c0df9183f194f60b541965b3aac3e034a400d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c0df9183f194f60b541965b3aac3e034a400d9", "html_url": "https://github.com/rust-lang/rust/commit/f7c0df9183f194f60b541965b3aac3e034a400d9"}], "stats": {"total": 318, "additions": 251, "deletions": 67}, "files": [{"sha": "7fad43029acab67eafbb3289c062bf5943ea571e", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -47,7 +47,7 @@ impl Lint {\n             name: name.to_lowercase(),\n             group: group.to_string(),\n             desc: NL_ESCAPE_RE.replace(&desc.replace(\"\\\\\\\"\", \"\\\"\"), \"\").to_string(),\n-            deprecation: deprecation.map(|d| d.to_string()),\n+            deprecation: deprecation.map(std::string::ToString::to_string),\n             module: module.to_string(),\n         }\n     }\n@@ -178,7 +178,7 @@ fn lint_files() -> impl Iterator<Item = walkdir::DirEntry> {\n     // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n     WalkDir::new(\"../clippy_lints/src\")\n         .into_iter()\n-        .filter_map(|f| f.ok())\n+        .filter_map(std::result::Result::ok)\n         .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n }\n "}, {"sha": "a72944bbe028f8e518156d914dc0e9a557d9c347", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -326,7 +326,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n                     lint.span,\n                     &format!(\"unknown clippy lint: clippy::{}\", name),\n                     |db| {\n-                        if name.as_str().chars().any(|c| c.is_uppercase()) {\n+                        if name.as_str().chars().any(char::is_uppercase) {\n                             let name_lower = name.as_str().to_lowercase();\n                             match lint_store.check_lint_name(\n                                 &name_lower,"}, {"sha": "1d37c03ff45459cff91fb293c159edfbf9299df7", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -53,7 +53,7 @@ fn is_empty_str(value: &Option<String>) -> bool {\n \n fn is_empty_vec(value: &[String]) -> bool {\n     // This works because empty iterators return true\n-    value.iter().all(|v| v.is_empty())\n+    value.iter().all(std::string::String::is_empty)\n }\n \n pub struct Pass;"}, {"sha": "83aca243275b2e2f39ac3f0fd58fc0f3bfe8366d", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 123, "deletions": 42, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -1,4 +1,5 @@\n-use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n+use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n@@ -59,56 +60,136 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n-        if let ExprKind::Call(ref caller, ref args) = ex.node {\n-            if args.len() != decl.inputs.len() {\n-                // Not the same number of arguments, there\n-                // is no way the closure is the same as the function\n-                return;\n-            }\n-            if is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)) {\n-                // Are the expression or the arguments type-adjusted? Then we need the closure\n-                return;\n-            }\n+\n+        if_chain!(\n+            if let ExprKind::Call(ref caller, ref args) = ex.node;\n+\n+            // Not the same number of arguments, there is no way the closure is the same as the function return;\n+            if args.len() == decl.inputs.len();\n+\n+            // Are the expression or the arguments type-adjusted? Then we need the closure\n+            if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n+\n             let fn_ty = cx.tables.expr_ty(caller);\n-            match fn_ty.sty {\n-                // Is it an unsafe function? They don't implement the closure traits\n-                ty::FnDef(..) | ty::FnPtr(_) => {\n-                    let sig = fn_ty.fn_sig(cx.tcx);\n-                    if sig.skip_binder().unsafety == Unsafety::Unsafe || sig.skip_binder().output().sty == ty::Never {\n-                        return;\n+            if !type_is_unsafe_function(cx, fn_ty);\n+\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.into_iter());\n+\n+            then {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n+                    if let Some(snippet) = snippet_opt(cx, caller.span) {\n+                        db.span_suggestion(\n+                            expr.span,\n+                            \"remove closure as shown\",\n+                            snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n                     }\n-                },\n-                _ => (),\n+                });\n             }\n-            for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n-                if let PatKind::Binding(.., ident, _) = a1.pat.node {\n-                    // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprKind::Path(QPath::Resolved(None, ref p)) = a2.node {\n-                        if p.segments.len() != 1 {\n-                            // If it's a proper path, it can't be a local variable\n-                            return;\n-                        }\n-                        if p.segments[0].ident.name != ident.name {\n-                            // The two idents should be the same\n-                            return;\n-                        }\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            }\n-            span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n-                if let Some(snippet) = snippet_opt(cx, caller.span) {\n+        );\n+\n+        if_chain!(\n+            if let ExprKind::MethodCall(ref path, _, ref args) = ex.node;\n+\n+            // Not the same number of arguments, there is no way the closure is the same as the function return;\n+            if args.len() == decl.inputs.len();\n+\n+            // Are the expression or the arguments type-adjusted? Then we need the closure\n+            if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n+\n+            let method_def_id = cx.tables.type_dependent_defs()[ex.hir_id].def_id();\n+            if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n+\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.into_iter());\n+\n+            if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n+\n+            then {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n                     db.span_suggestion(\n                         expr.span,\n                         \"remove closure as shown\",\n-                        snippet,\n+                        format!(\"{}::{}\", name, path.ident.name),\n                         Applicability::MachineApplicable,\n                     );\n+                });\n+            }\n+        );\n+    }\n+}\n+\n+/// Tries to determine the type for universal function call to be used instead of the closure\n+fn get_ufcs_type_name(\n+    cx: &LateContext<'_, '_>,\n+    method_def_id: def_id::DefId,\n+    self_arg: &Expr,\n+) -> std::option::Option<String> {\n+    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0].sty;\n+    let actual_type_of_self = &cx.tables.node_id_to_type(self_arg.hir_id).sty;\n+\n+    if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n+        //if the method expectes &self, ufcs requires explicit borrowing so closure can't be removed\n+        return match (expected_type_of_self, actual_type_of_self) {\n+            (ty::Ref(_, _, _), ty::Ref(_, _, _)) => Some(cx.tcx.item_path_str(trait_id)),\n+            (l, r) => match (l, r) {\n+                (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => None,\n+                (_, _) => Some(cx.tcx.item_path_str(trait_id)),\n+            },\n+        };\n+    }\n+\n+    cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n+        //a type may implicitly implement other types methods (e.g. Deref)\n+        if match_types(expected_type_of_self, actual_type_of_self) {\n+            return Some(get_type_name(cx, &actual_type_of_self));\n+        }\n+        None\n+    })\n+}\n+\n+fn match_types(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n+    match (lhs, rhs) {\n+        (ty::Bool, ty::Bool)\n+        | (ty::Char, ty::Char)\n+        | (ty::Int(_), ty::Int(_))\n+        | (ty::Uint(_), ty::Uint(_))\n+        | (ty::Str, ty::Str) => true,\n+        (ty::Ref(_, t1, _), ty::Ref(_, t2, _))\n+        | (ty::Array(t1, _), ty::Array(t2, _))\n+        | (ty::Slice(t1), ty::Slice(t2)) => match_types(&t1.sty, &t2.sty),\n+        (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n+        (_, _) => false,\n+    }\n+}\n+\n+fn get_type_name(cx: &LateContext<'_, '_>, kind: &ty::TyKind<'_>) -> String {\n+    match kind {\n+        ty::Adt(t, _) => cx.tcx.item_path_str(t.did),\n+        ty::Ref(_, r, _) => get_type_name(cx, &r.sty),\n+        _ => kind.to_string(),\n+    }\n+}\n+\n+fn compare_inputs(closure_inputs: &mut dyn Iterator<Item = &Arg>, call_args: &mut dyn Iterator<Item = &Expr>) -> bool {\n+    for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n+        if let PatKind::Binding(_, _, _, ident, _) = closure_input.pat.node {\n+            // XXXManishearth Should I be checking the binding mode here?\n+            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.node {\n+                if p.segments.len() != 1 {\n+                    // If it's a proper path, it can't be a local variable\n+                    return false;\n                 }\n-            });\n+                if p.segments[0].ident.name != ident.name {\n+                    // The two idents should be the same\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            return false;\n         }\n     }\n+    true\n }"}, {"sha": "88224763f0c469e841528d4c00d84c55706a7f80", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -321,7 +321,7 @@ pub fn read_conf(reg: &rustc_plugin::Registry<'_>) -> Conf {\n                 }\n             });\n \n-            let (conf, errors) = utils::conf::read(file_name.as_ref().map(|p| p.as_ref()));\n+            let (conf, errors) = utils::conf::read(file_name.as_ref().map(std::convert::AsRef::as_ref));\n \n             // all conf errors are non-fatal, we just use the default conf in case of error\n             for error in errors {"}, {"sha": "c9b27ef161526c2500fa6969cd97ea18aa61fc56", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -829,7 +829,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         let (method_names, arg_lists) = method_calls(expr, 2);\n         let method_names: Vec<LocalInternedString> = method_names.iter().map(|s| s.as_str()).collect();\n-        let method_names: Vec<&str> = method_names.iter().map(|s| s.as_ref()).collect();\n+        let method_names: Vec<&str> = method_names.iter().map(std::convert::AsRef::as_ref).collect();\n \n         match method_names.as_slice() {\n             [\"unwrap\", \"get\"] => lint_get_unwrap(cx, expr, arg_lists[1], false),\n@@ -1695,7 +1695,7 @@ fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Op\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n         if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n-            sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n+            sugg::Sugg::hir_opt(cx, &args[0]).map(sugg::Sugg::addr)\n         } else {\n             None\n         }"}, {"sha": "b1cd1910f5b131f973a21008725921b38f6bff3b", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                         // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)\n                         continue;\n                     }\n-                    split_at = interned_name.chars().next().map(|c| c.len_utf8());\n+                    split_at = interned_name.chars().next().map(char::len_utf8);\n                 }\n             }\n             span_lint_and_then("}, {"sha": "ff802dbb3a8aa41759047ffeb00eb7cae481acfa", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -14,7 +14,7 @@ use toml;\n pub fn file_from_args(\n     args: &[source_map::Spanned<ast::NestedMetaItemKind>],\n ) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n-    for arg in args.iter().filter_map(|a| a.meta_item()) {\n+    for arg in args.iter().filter_map(syntax::source_map::Spanned::meta_item) {\n         if arg.name() == \"conf_file\" {\n             return match arg.node {\n                 ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {"}, {"sha": "b5221bca0073f73d42aa4625e53380cbf66809c7", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -142,7 +142,10 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n pub fn get_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Vec<&'static str> {\n     let mut apb = AbsolutePathBuffer { names: vec![] };\n     tcx.push_item_path(&mut apb, def_id, false);\n-    apb.names.iter().map(|n| n.get()).collect()\n+    apb.names\n+        .iter()\n+        .map(syntax_pos::symbol::LocalInternedString::get)\n+        .collect()\n }\n \n /// Check if type is struct, enum or union type with given def path."}, {"sha": "19c27754839e7fc22e3dfee804b16821b0bc999b", "filename": "rustc_tools_util/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/rustc_tools_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/rustc_tools_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2Fsrc%2Flib.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -9,8 +9,8 @@ macro_rules! get_version_info {\n         let crate_name = String::from(env!(\"CARGO_PKG_NAME\"));\n \n         let host_compiler = $crate::get_channel();\n-        let commit_hash = option_env!(\"GIT_HASH\").map(|s| s.to_string());\n-        let commit_date = option_env!(\"COMMIT_DATE\").map(|s| s.to_string());\n+        let commit_hash = option_env!(\"GIT_HASH\").map(str::to_string);\n+        let commit_date = option_env!(\"COMMIT_DATE\").map(str::to_string);\n \n         VersionInfo {\n             major,"}, {"sha": "34fc6fc7f9fb5e7511157110762b0b825f90f223", "filename": "src/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -47,7 +47,7 @@ fn arg_value<'a>(\n fn test_arg_value() {\n     let args: Vec<_> = [\"--bar=bar\", \"--foobar\", \"123\", \"--foo\"]\n         .iter()\n-        .map(|s| s.to_string())\n+        .map(std::string::ToString::to_string)\n         .collect();\n \n     assert_eq!(arg_value(None, \"--foobar\", |_| true), None);\n@@ -84,7 +84,7 @@ pub fn main() {\n             let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n             let have_sys_root_arg = sys_root_arg.is_some();\n             let sys_root = sys_root_arg\n-                .map(|s| s.to_string())\n+                .map(std::string::ToString::to_string)\n                 .or_else(|| std::env::var(\"SYSROOT\").ok())\n                 .or_else(|| {\n                     let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));"}, {"sha": "d87bb4be3c3f976e26e94ddfad4135d6993cf45d", "filename": "tests/missing-test-files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fmissing-test-files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fmissing-test-files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmissing-test-files.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -32,7 +32,7 @@ fn explore_directory(dir: &Path) -> Vec<String> {\n     let mut missing_files: Vec<String> = Vec::new();\n     let mut current_file = String::new();\n     let mut files: Vec<DirEntry> = fs::read_dir(dir).unwrap().filter_map(Result::ok).collect();\n-    files.sort_by_key(|e| e.path());\n+    files.sort_by_key(std::fs::DirEntry::path);\n     for entry in &files {\n         let path = entry.path();\n         if path.is_dir() {"}, {"sha": "6eeb093eae992cd01d45328743aaed6bde79abab", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -9,6 +9,8 @@\n )]\n #![warn(clippy::redundant_closure, clippy::needless_borrow)]\n \n+use std::path::PathBuf;\n+\n fn main() {\n     let a = Some(1u8).map(|a| foo(a));\n     meta(|a| foo(a));\n@@ -28,6 +30,66 @@ fn main() {\n         Some(vec![1i32, 2]).map(|v| -> Box<::std::ops::Deref<Target = [i32]>> { Box::new(v) });\n }\n \n+trait TestTrait {\n+    fn trait_foo(self) -> bool;\n+    fn trait_foo_ref(&self) -> bool;\n+}\n+\n+struct TestStruct<'a> {\n+    some_ref: &'a i32,\n+}\n+\n+impl<'a> TestStruct<'a> {\n+    fn foo(self) -> bool {\n+        false\n+    }\n+    unsafe fn foo_unsafe(self) -> bool {\n+        true\n+    }\n+}\n+\n+impl<'a> TestTrait for TestStruct<'a> {\n+    fn trait_foo(self) -> bool {\n+        false\n+    }\n+    fn trait_foo_ref(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'a> std::ops::Deref for TestStruct<'a> {\n+    type Target = char;\n+    fn deref(&self) -> &char {\n+        &'a'\n+    }\n+}\n+\n+fn test_redundant_closures_containing_method_calls() {\n+    let i = 10;\n+    let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n+    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n+    let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n+    let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n+    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n+    let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n+    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n+    unsafe {\n+        let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n+    }\n+    let e = Some(\"str\").map(|s| s.to_string());\n+    let e = Some(\"str\").map(str::to_string);\n+    let e = Some('a').map(|s| s.to_uppercase());\n+    let e = Some('a').map(char::to_uppercase);\n+    let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n+    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n+    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n+    let p = Some(PathBuf::new());\n+    let e = p.as_ref().and_then(|s| s.to_str());\n+    let c = Some(TestStruct { some_ref: &i })\n+        .as_ref()\n+        .map(|c| c.to_ascii_uppercase());\n+}\n+\n fn meta<F>(f: F)\n where\n     F: Fn(u8),"}, {"sha": "5f56cd7912a7ba92018f8402303255533fa1e3a9", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -1,36 +1,72 @@\n error: redundant closure found\n-  --> $DIR/eta.rs:13:27\n+  --> $DIR/eta.rs:15:27\n    |\n LL |     let a = Some(1u8).map(|a| foo(a));\n    |                           ^^^^^^^^^^ help: remove closure as shown: `foo`\n    |\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure found\n-  --> $DIR/eta.rs:14:10\n+  --> $DIR/eta.rs:16:10\n    |\n LL |     meta(|a| foo(a));\n    |          ^^^^^^^^^^ help: remove closure as shown: `foo`\n \n error: redundant closure found\n-  --> $DIR/eta.rs:15:27\n+  --> $DIR/eta.rs:17:27\n    |\n LL |     let c = Some(1u8).map(|a| {1+2; foo}(a));\n    |                           ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `{1+2; foo}`\n \n error: this expression borrows a reference that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:17:21\n+  --> $DIR/eta.rs:19:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                     ^^^ help: change this to: `&2`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: redundant closure found\n-  --> $DIR/eta.rs:24:27\n+  --> $DIR/eta.rs:26:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: remove closure as shown: `generic`\n \n-error: aborting due to 5 previous errors\n+error: redundant closure found\n+  --> $DIR/eta.rs:69:51\n+   |\n+LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n+   |                                                   ^^^^^^^^^^^ help: remove closure as shown: `TestStruct::foo`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:71:51\n+   |\n+LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n+   |                                                   ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `TestTrait::trait_foo`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:74:42\n+   |\n+LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n+   |                                          ^^^^^^^^^^^^^ help: remove closure as shown: `std::vec::Vec::clear`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:79:29\n+   |\n+LL |     let e = Some(\"str\").map(|s| s.to_string());\n+   |                             ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `std::string::ToString::to_string`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:81:27\n+   |\n+LL |     let e = Some('a').map(|s| s.to_uppercase());\n+   |                           ^^^^^^^^^^^^^^^^^^^^ help: remove closure as shown: `char::to_uppercase`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:84:65\n+   |\n+LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n+   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove closure as shown: `char::to_ascii_uppercase`\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "d804e838d5a68fbb1ed0c9dbfa49487bc5f1592e", "filename": "tests/ui/map_clone.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Fmap_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Fmap_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.fixed?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -3,6 +3,7 @@\n #![allow(clippy::iter_cloned_collect)]\n #![allow(clippy::clone_on_copy)]\n #![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::redundant_closure)]\n \n fn main() {\n     let _: Vec<i8> = vec![5_i8; 6].iter().cloned().collect();"}, {"sha": "d98cd939d8cc5f45a04e4cb0bf4c2c8406e718a3", "filename": "tests/ui/map_clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.rs?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -3,6 +3,7 @@\n #![allow(clippy::iter_cloned_collect)]\n #![allow(clippy::clone_on_copy)]\n #![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::redundant_closure)]\n \n fn main() {\n     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();"}, {"sha": "db7fa4f52fce1eff3c396c1c559aed48630bc18d", "filename": "tests/ui/map_clone.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Fmap_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db13e6fa34707c62c5d87aa057813a40c67e29c4/tests%2Fui%2Fmap_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.stderr?ref=db13e6fa34707c62c5d87aa057813a40c67e29c4", "patch": "@@ -1,25 +1,25 @@\n error: You are using an explicit closure for cloning elements\n-  --> $DIR/map_clone.rs:8:22\n+  --> $DIR/map_clone.rs:9:22\n    |\n LL |     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![5_i8; 6].iter().cloned()`\n    |\n    = note: `-D clippy::map-clone` implied by `-D warnings`\n \n error: You are using an explicit closure for cloning elements\n-  --> $DIR/map_clone.rs:9:26\n+  --> $DIR/map_clone.rs:10:26\n    |\n LL |     let _: Vec<String> = vec![String::new()].iter().map(|x| x.clone()).collect();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n \n error: You are using an explicit closure for cloning elements\n-  --> $DIR/map_clone.rs:10:23\n+  --> $DIR/map_clone.rs:11:23\n    |\n LL |     let _: Vec<u32> = vec![42, 43].iter().map(|&x| x).collect();\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![42, 43].iter().cloned()`\n \n error: You are needlessly cloning iterator elements\n-  --> $DIR/map_clone.rs:22:29\n+  --> $DIR/map_clone.rs:23:29\n    |\n LL |     let _ = std::env::args().map(|v| v.clone());\n    |                             ^^^^^^^^^^^^^^^^^^^ help: Remove the map call"}]}