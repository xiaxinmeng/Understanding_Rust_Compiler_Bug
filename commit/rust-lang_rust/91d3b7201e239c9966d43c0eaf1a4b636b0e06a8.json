{"sha": "91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "node_id": "C_kwDOAAsO6NoAKDkxZDNiNzIwMWUyMzljOTk2NmQ0M2MwZWFmMWE0YjYzNmIwZTA2YTg", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-08-24T17:15:19Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-09-30T20:52:58Z"}, "message": "Use `Path` instead of `Type` in `PolyTrait`\n\nThe change to `impl Clean<Path> for hir::TraitRef<'_>` was necessary to\nfix a test failure for `src/test/rustdoc/trait-alias-mention.rs`.\nHere's why:\n\nThe old code path was through `impl Clean<Type> for hir::TraitRef<'_>`,\nwhich called `resolve_type`, which in turn called `register_res`. Now,\nbecause `PolyTrait` uses a `Path` instead of a `Type`, the impl of\n`Clean<Path>` was being run, which did not call `register_res`, causing\nthe trait alias to not be recorded in the `external_paths` cache.", "tree": {"sha": "32ec8b52de84f5e045e6098385d952bc7fee828d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ec8b52de84f5e045e6098385d952bc7fee828d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "html_url": "https://github.com/rust-lang/rust/commit/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c6385ff935d8121c5cc4c44b62a2b0ae0118a35", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c6385ff935d8121c5cc4c44b62a2b0ae0118a35", "html_url": "https://github.com/rust-lang/rust/commit/4c6385ff935d8121c5cc4c44b62a2b0ae0118a35"}], "stats": {"total": 514, "additions": 208, "deletions": 306}, "files": [{"sha": "fe3edd4112bce6c41738956aed4228ab245c0431", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 86, "deletions": 122, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 span: Span::dummy(),\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n-                trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap().expect_path()),\n+                trait_: Some(trait_ref.clean(self.cx).get_trait_path().unwrap()),\n                 for_: ty.clean(self.cx),\n                 items: Vec::new(),\n                 negative_polarity,\n@@ -353,48 +353,35 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 if let Some(data) = ty_to_fn.get(&ty) {\n                     let (poly_trait, output) =\n                         (data.0.as_ref().unwrap().clone(), data.1.as_ref().cloned().map(Box::new));\n-                    let new_ty = match poly_trait.trait_ {\n-                        Type::ResolvedPath { ref path, ref did } => {\n-                            let mut new_path = path.clone();\n-                            let last_segment =\n-                                new_path.segments.pop().expect(\"segments were empty\");\n-\n-                            let (old_input, old_output) = match last_segment.args {\n-                                GenericArgs::AngleBracketed { args, .. } => {\n-                                    let types = args\n-                                        .iter()\n-                                        .filter_map(|arg| match arg {\n-                                            GenericArg::Type(ty) => Some(ty.clone()),\n-                                            _ => None,\n-                                        })\n-                                        .collect();\n-                                    (types, None)\n-                                }\n-                                GenericArgs::Parenthesized { inputs, output, .. } => {\n-                                    (inputs, output)\n-                                }\n-                            };\n+                    let mut new_path = poly_trait.trait_.clone();\n+                    let last_segment = new_path.segments.pop().expect(\"segments were empty\");\n+\n+                    let (old_input, old_output) = match last_segment.args {\n+                        GenericArgs::AngleBracketed { args, .. } => {\n+                            let types = args\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericArg::Type(ty) => Some(ty.clone()),\n+                                    _ => None,\n+                                })\n+                                .collect();\n+                            (types, None)\n+                        }\n+                        GenericArgs::Parenthesized { inputs, output } => (inputs, output),\n+                    };\n \n-                            if old_output.is_some() && old_output != output {\n-                                panic!(\n-                                    \"Output mismatch for {:?} {:?} {:?}\",\n-                                    ty, old_output, data.1\n-                                );\n-                            }\n+                    if old_output.is_some() && old_output != output {\n+                        panic!(\"Output mismatch for {:?} {:?} {:?}\", ty, old_output, data.1);\n+                    }\n \n-                            let new_params =\n-                                GenericArgs::Parenthesized { inputs: old_input, output };\n+                    let new_params = GenericArgs::Parenthesized { inputs: old_input, output };\n \n-                            new_path\n-                                .segments\n-                                .push(PathSegment { name: last_segment.name, args: new_params });\n+                    new_path\n+                        .segments\n+                        .push(PathSegment { name: last_segment.name, args: new_params });\n \n-                            Type::ResolvedPath { path: new_path, did: *did }\n-                        }\n-                        _ => panic!(\"Unexpected data: {:?}, {:?}\", ty, data),\n-                    };\n                     bounds.insert(GenericBound::TraitBound(\n-                        PolyTrait { trait_: new_ty, generic_params: poly_trait.generic_params },\n+                        PolyTrait { trait_: new_path, generic_params: poly_trait.generic_params },\n                         hir::TraitBoundModifier::None,\n                     ));\n                 }\n@@ -476,7 +463,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let mut has_sized = FxHashSet::default();\n         let mut ty_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n         let mut lifetime_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n-        let mut ty_to_traits: FxHashMap<Type, FxHashSet<Type>> = Default::default();\n+        let mut ty_to_traits: FxHashMap<Type, FxHashSet<Path>> = Default::default();\n \n         let mut ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)> = Default::default();\n \n@@ -511,11 +498,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     if b.is_sized_bound(self.cx) {\n                         has_sized.insert(ty.clone());\n                     } else if !b\n-                        .get_trait_type()\n-                        .and_then(|t| {\n+                        .get_trait_path()\n+                        .and_then(|trait_| {\n                             ty_to_traits\n                                 .get(&ty)\n-                                .map(|bounds| bounds.contains(&strip_type(t.clone())))\n+                                .map(|bounds| bounds.contains(&strip_path(trait_.clone())))\n                         })\n                         .unwrap_or(false)\n                     {\n@@ -532,7 +519,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 // that we don't end up with duplicate bounds (e.g., for<'b, 'b>)\n                                 for_generics.extend(p.generic_params.clone());\n                                 p.generic_params = for_generics.into_iter().collect();\n-                                self.is_fn_ty(&p.trait_)\n+                                self.is_fn_trait(&p.trait_)\n                             }\n                             _ => false,\n                         };\n@@ -558,78 +545,59 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     match lhs {\n                         Type::QPath { name: left_name, ref self_type, ref trait_, .. } => {\n                             let ty = &*self_type;\n-                            match **trait_ {\n-                                Type::ResolvedPath { path: ref trait_path, ref did } => {\n-                                    let mut new_trait_path = trait_path.clone();\n-\n-                                    if self.is_fn_ty(trait_) && left_name == sym::Output {\n-                                        ty_to_fn\n-                                            .entry(*ty.clone())\n-                                            .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n-                                            .or_insert((None, Some(rhs)));\n-                                        continue;\n-                                    }\n-\n-                                    let args = &mut new_trait_path\n-                                        .segments\n-                                        .last_mut()\n-                                        .expect(\"segments were empty\")\n-                                        .args;\n-\n-                                    match args {\n-                                        // Convert something like '<T as Iterator::Item> = u8'\n-                                        // to 'T: Iterator<Item=u8>'\n-                                        GenericArgs::AngleBracketed {\n-                                            ref mut bindings, ..\n-                                        } => {\n-                                            bindings.push(TypeBinding {\n-                                                name: left_name,\n-                                                kind: TypeBindingKind::Equality { ty: rhs },\n-                                            });\n-                                        }\n-                                        GenericArgs::Parenthesized { .. } => {\n-                                            existing_predicates.push(WherePredicate::EqPredicate {\n-                                                lhs: lhs.clone(),\n-                                                rhs,\n-                                            });\n-                                            continue; // If something other than a Fn ends up\n-                                            // with parenthesis, leave it alone\n-                                        }\n-                                    }\n-\n-                                    let bounds = ty_to_bounds.entry(*ty.clone()).or_default();\n-\n-                                    bounds.insert(GenericBound::TraitBound(\n-                                        PolyTrait {\n-                                            trait_: Type::ResolvedPath {\n-                                                path: new_trait_path,\n-                                                did: *did,\n-                                            },\n-                                            generic_params: Vec::new(),\n-                                        },\n-                                        hir::TraitBoundModifier::None,\n-                                    ));\n-\n-                                    // Remove any existing 'plain' bound (e.g., 'T: Iterator`) so\n-                                    // that we don't see a\n-                                    // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n-                                    // on the docs page.\n-                                    bounds.remove(&GenericBound::TraitBound(\n-                                        PolyTrait {\n-                                            trait_: *trait_.clone(),\n-                                            generic_params: Vec::new(),\n-                                        },\n-                                        hir::TraitBoundModifier::None,\n-                                    ));\n-                                    // Avoid creating any new duplicate bounds later in the outer\n-                                    // loop\n-                                    ty_to_traits\n-                                        .entry(*ty.clone())\n-                                        .or_default()\n-                                        .insert(*trait_.clone());\n+                            let mut new_trait = *trait_.clone();\n+\n+                            if self.is_fn_trait(trait_) && left_name == sym::Output {\n+                                ty_to_fn\n+                                    .entry(*ty.clone())\n+                                    .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n+                                    .or_insert((None, Some(rhs)));\n+                                continue;\n+                            }\n+\n+                            let args = &mut new_trait\n+                                .segments\n+                                .last_mut()\n+                                .expect(\"segments were empty\")\n+                                .args;\n+\n+                            match args {\n+                                // Convert something like '<T as Iterator::Item> = u8'\n+                                // to 'T: Iterator<Item=u8>'\n+                                GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n+                                    bindings.push(TypeBinding {\n+                                        name: left_name,\n+                                        kind: TypeBindingKind::Equality { ty: rhs },\n+                                    });\n+                                }\n+                                GenericArgs::Parenthesized { .. } => {\n+                                    existing_predicates.push(WherePredicate::EqPredicate {\n+                                        lhs: lhs.clone(),\n+                                        rhs,\n+                                    });\n+                                    continue; // If something other than a Fn ends up\n+                                    // with parenthesis, leave it alone\n                                 }\n-                                _ => panic!(\"Unexpected trait {:?} for {:?}\", trait_, item_def_id),\n                             }\n+\n+                            let bounds = ty_to_bounds.entry(*ty.clone()).or_default();\n+\n+                            bounds.insert(GenericBound::TraitBound(\n+                                PolyTrait { trait_: new_trait, generic_params: Vec::new() },\n+                                hir::TraitBoundModifier::None,\n+                            ));\n+\n+                            // Remove any existing 'plain' bound (e.g., 'T: Iterator`) so\n+                            // that we don't see a\n+                            // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n+                            // on the docs page.\n+                            bounds.remove(&GenericBound::TraitBound(\n+                                PolyTrait { trait_: *trait_.clone(), generic_params: Vec::new() },\n+                                hir::TraitBoundModifier::None,\n+                            ));\n+                            // Avoid creating any new duplicate bounds later in the outer\n+                            // loop\n+                            ty_to_traits.entry(*ty.clone()).or_default().insert(*trait_.clone());\n                         }\n                         _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, item_def_id),\n                     }\n@@ -721,16 +689,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         vec.sort_by_cached_key(|x| format!(\"{:?}\", x))\n     }\n \n-    fn is_fn_ty(&self, ty: &Type) -> bool {\n+    fn is_fn_trait(&self, path: &Path) -> bool {\n         let tcx = self.cx.tcx;\n-        match ty {\n-            &Type::ResolvedPath { did, .. } => {\n-                did == tcx.require_lang_item(LangItem::Fn, None)\n-                    || did == tcx.require_lang_item(LangItem::FnMut, None)\n-                    || did == tcx.require_lang_item(LangItem::FnOnce, None)\n-            }\n-            _ => false,\n-        }\n+        let did = path.res.def_id();\n+        did == tcx.require_lang_item(LangItem::Fn, None)\n+            || did == tcx.require_lang_item(LangItem::FnMut, None)\n+            || did == tcx.require_lang_item(LangItem::FnOnce, None)\n     }\n }\n "}, {"sha": "410b6a42d76102c54529aaa7c0c14e7c1b085071", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -114,9 +114,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .clean(self.cx),\n                         // FIXME(eddyb) compute both `trait_` and `for_` from\n                         // the post-inference `trait_ref`, as it's more accurate.\n-                        trait_: Some(\n-                            trait_ref.clean(self.cx).get_trait_type().unwrap().expect_path(),\n-                        ),\n+                        trait_: Some(trait_ref.clean(self.cx).get_trait_path().unwrap()),\n                         for_: ty.clean(self.cx),\n                         items: self\n                             .cx"}, {"sha": "bee10e72fa056982454f0fb68e1a22bd5f74de10", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -455,11 +455,20 @@ crate fn build_impl(\n     }\n \n     // Return if the trait itself or any types of the generic parameters are doc(hidden).\n-    let mut stack: Vec<&Type> = trait_.iter().collect();\n-    stack.push(&for_);\n+    let mut stack: Vec<&Type> = vec![&for_];\n+\n+    if let Some(did) = trait_.as_ref().map(|t| t.res.def_id()) {\n+        if tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n+            return;\n+        }\n+    }\n+    if let Some(generics) = trait_.as_ref().and_then(|t| t.generics()) {\n+        stack.extend(generics);\n+    }\n+\n     while let Some(ty) = stack.pop() {\n         if let Some(did) = ty.def_id() {\n-            if cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n+            if tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n                 return;\n             }\n         }\n@@ -468,8 +477,8 @@ crate fn build_impl(\n         }\n     }\n \n-    if let Some(trait_did) = trait_.def_id() {\n-        record_extern_trait(cx, trait_did);\n+    if let Some(did) = trait_.as_ref().map(|t| t.res.def_id()) {\n+        record_extern_trait(cx, did);\n     }\n \n     let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n@@ -483,7 +492,7 @@ crate fn build_impl(\n             span: clean::types::rustc_span(did, cx.tcx),\n             unsafety: hir::Unsafety::Normal,\n             generics,\n-            trait_: trait_.map(|t| t.expect_path()),\n+            trait_,\n             for_,\n             items: trait_items,\n             negative_polarity: polarity.clean(cx),\n@@ -620,30 +629,23 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n                 ref mut bounds,\n                 ..\n             } if *s == kw::SelfUpper => {\n-                bounds.retain(|bound| match *bound {\n-                    clean::GenericBound::TraitBound(\n-                        clean::PolyTrait { trait_: clean::ResolvedPath { did, .. }, .. },\n-                        _,\n-                    ) => did != trait_did,\n+                bounds.retain(|bound| match bound {\n+                    clean::GenericBound::TraitBound(clean::PolyTrait { trait_, .. }, _) => {\n+                        trait_.res.def_id() != trait_did\n+                    }\n                     _ => true,\n                 });\n             }\n             _ => {}\n         }\n     }\n \n-    g.where_predicates.retain(|pred| match *pred {\n+    g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty:\n-                clean::QPath {\n-                    self_type: box clean::Generic(ref s),\n-                    trait_: box clean::ResolvedPath { did, .. },\n-                    name: ref _name,\n-                    ..\n-                },\n-            ref bounds,\n+            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, name: _, .. },\n+            bounds,\n             ..\n-        } => !(bounds.is_empty() || *s == kw::SelfUpper && did == trait_did),\n+        } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.res.def_id() == trait_did),\n         _ => true,\n     });\n     g"}, {"sha": "285314a5cb6124aa371b14a66d1286b6e9dee3e8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -152,8 +152,8 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl Clean<Path> for (ty::TraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n         let (trait_ref, bounds) = *self;\n         let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n         if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n@@ -168,7 +168,7 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n-        ResolvedPath { path, did: trait_ref.def_id }\n+        path\n     }\n }\n \n@@ -905,7 +905,9 @@ impl Clean<Type> for hir::TraitRef<'_> {\n \n impl Clean<Path> for hir::TraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        self.path.clean(cx)\n+        let path = self.path.clean(cx);\n+        register_res(cx, path.res);\n+        path\n     }\n }\n \n@@ -1111,9 +1113,8 @@ impl Clean<Item> for ty::AssocItem {\n                             if *name != my_name {\n                                 return None;\n                             }\n-                            match **trait_ {\n-                                ResolvedPath { did, .. } if did == self.container.id() => {}\n-                                _ => return None,\n+                            if trait_.res.def_id() != self.container.id() {\n+                                return None;\n                             }\n                             match **self_type {\n                                 Generic(ref s) if *s == kw::SelfUpper => {}\n@@ -1286,11 +1287,12 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 res: Res::Def(DefKind::Trait, trait_def),\n                 segments: trait_segments.clean(cx),\n             };\n+            register_res(cx, trait_path.res);\n             Type::QPath {\n                 name: p.segments.last().expect(\"segments were empty\").ident.name,\n                 self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n                 self_type: box qself.clean(cx),\n-                trait_: box resolve_type(cx, trait_path),\n+                trait_: box trait_path,\n             }\n         }\n         hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -1302,11 +1304,12 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 _ => bug!(\"clean: expected associated type, found `{:?}`\", ty),\n             };\n             let trait_path = hir::Path { span, res, segments: &[] }.clean(cx);\n+            register_res(cx, trait_path.res);\n             Type::QPath {\n                 name: segment.ident.name,\n                 self_def_id: res.opt_def_id(),\n                 self_type: box qself.clean(cx),\n-                trait_: box resolve_type(cx, trait_path),\n+                trait_: box trait_path,\n             }\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n@@ -1475,10 +1478,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     let empty = cx.tcx.intern_substs(&[]);\n                     let path = external_path(cx, did, false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, ItemType::Trait);\n-                    let bound = PolyTrait {\n-                        trait_: ResolvedPath { path, did },\n-                        generic_params: Vec::new(),\n-                    };\n+                    let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n                     bounds.push(bound);\n                 }\n \n@@ -1491,10 +1491,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }\n \n                 let path = external_path(cx, did, false, bindings, substs);\n-                bounds.insert(\n-                    0,\n-                    PolyTrait { trait_: ResolvedPath { path, did }, generic_params: Vec::new() },\n-                );\n+                bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n \n                 DynTrait(bounds, lifetime)\n             }"}, {"sha": "101fdd465b70d26adc7ba4fbe73d40c9b98d493b", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -99,17 +99,13 @@ crate fn merge_bounds(\n             clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n             clean::GenericBound::Outlives(..) => return false,\n         };\n-        let (did, path) = match trait_ref.trait_ {\n-            clean::ResolvedPath { did, ref mut path, .. } => (did, path),\n-            _ => return false,\n-        };\n         // If this QPath's trait `trait_did` is the same as, or a supertrait\n         // of, the bound's trait `did` then we can keep going, otherwise\n         // this is just a plain old equality bound.\n-        if !trait_is_same_or_supertrait(cx, did, trait_did) {\n+        if !trait_is_same_or_supertrait(cx, trait_ref.trait_.res.def_id(), trait_did) {\n             return false;\n         }\n-        let last = path.segments.last_mut().expect(\"segments were empty\");\n+        let last = trait_ref.trait_.segments.last_mut().expect(\"segments were empty\");\n         match last.args {\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {"}, {"sha": "da06737394d5373042be8a0737082e55dac04fab", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -1114,7 +1114,7 @@ impl GenericBound {\n         let path = external_path(cx, did, false, vec![], empty);\n         inline::record_extern_fqn(cx, did, ItemType::Trait);\n         GenericBound::TraitBound(\n-            PolyTrait { trait_: ResolvedPath { path, did }, generic_params: Vec::new() },\n+            PolyTrait { trait_: path, generic_params: Vec::new() },\n             hir::TraitBoundModifier::Maybe,\n         )\n     }\n@@ -1136,7 +1136,7 @@ impl GenericBound {\n         None\n     }\n \n-    crate fn get_trait_type(&self) -> Option<Type> {\n+    crate fn get_trait_path(&self) -> Option<Path> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             Some(trait_.clone())\n         } else {\n@@ -1368,7 +1368,7 @@ crate struct TraitAlias {\n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct PolyTrait {\n-    crate trait_: Type,\n+    crate trait_: Path,\n     crate generic_params: Vec<GenericParamDef>,\n }\n \n@@ -1408,7 +1408,8 @@ crate enum Type {\n         name: Symbol,\n         self_type: Box<Type>,\n         self_def_id: Option<DefId>,\n-        trait_: Box<Type>,\n+        // FIXME: remove this `Box`; it's unnecessary\n+        trait_: Box<Path>,\n     },\n \n     // `_`\n@@ -1473,15 +1474,6 @@ impl Type {\n         }\n     }\n \n-    // FIXME: temporary\n-    #[track_caller]\n-    crate fn expect_path(self) -> Path {\n-        match self {\n-            ResolvedPath { path, .. } => path,\n-            _ => panic!(\"not a ResolvedPath: {:?}\", self),\n-        }\n-    }\n-\n     crate fn is_self_type(&self) -> bool {\n         match *self {\n             Generic(name) => name == kw::SelfUpper,\n@@ -1496,19 +1488,6 @@ impl Type {\n         }\n     }\n \n-    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n-        match *self {\n-            ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n-                if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n-                    Some(&**bindings)\n-                } else {\n-                    None\n-                }\n-            }),\n-            _ => None,\n-        }\n-    }\n-\n     crate fn is_full_generic(&self) -> bool {\n         matches!(self, Type::Generic(_))\n     }\n@@ -1522,17 +1501,13 @@ impl Type {\n             QPath { self_type, trait_, name, .. } => (self_type, trait_, name),\n             _ => return None,\n         };\n-        let trait_did = match **trait_ {\n-            ResolvedPath { did, .. } => did,\n-            _ => return None,\n-        };\n-        Some((&self_, trait_did, *name))\n+        Some((&self_, trait_.res.def_id(), *name))\n     }\n \n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n             ResolvedPath { did, .. } => return Some(did),\n-            DynTrait(ref bounds, _) => return bounds[0].trait_.inner_def_id(cache),\n+            DynTrait(ref bounds, _) => return Some(bounds[0].trait_.res.def_id()),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,\n             BorrowedRef { ref type_, .. } => return type_.inner_def_id(cache),\n@@ -2006,6 +1981,16 @@ impl Path {\n             }\n         })\n     }\n+\n+    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n+        self.segments.last().and_then(|seg| {\n+            if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n+                Some(&**bindings)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n }\n \n // FIXME: this is temporary"}, {"sha": "487efdc060f09ca11fd0e020eb9e9b5927a13ed5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -2,7 +2,7 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n-    ItemKind, Lifetime, Path, PathSegment, PolyTrait, Primitive, PrimitiveType, ResolvedPath, Type,\n+    ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type,\n     TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n@@ -156,39 +156,7 @@ pub(super) fn external_path(\n     }\n }\n \n-crate fn strip_type(ty: Type) -> Type {\n-    match ty {\n-        Type::ResolvedPath { path, did } => Type::ResolvedPath { path: strip_path(&path), did },\n-        Type::DynTrait(mut bounds, lt) => {\n-            let first = bounds.remove(0);\n-            let stripped_trait = strip_type(first.trait_);\n-\n-            bounds.insert(\n-                0,\n-                PolyTrait { trait_: stripped_trait, generic_params: first.generic_params },\n-            );\n-            Type::DynTrait(bounds, lt)\n-        }\n-        Type::Tuple(inner_tys) => {\n-            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n-        }\n-        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n-        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n-        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n-        Type::BorrowedRef { lifetime, mutability, type_ } => {\n-            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n-        }\n-        Type::QPath { name, self_type, trait_, self_def_id } => Type::QPath {\n-            name,\n-            self_def_id,\n-            self_type: Box::new(strip_type(*self_type)),\n-            trait_: Box::new(strip_type(*trait_)),\n-        },\n-        _ => ty,\n-    }\n-}\n-\n-crate fn strip_path(path: &Path) -> Path {\n+crate fn strip_path(path: Path) -> Path {\n     let segments = path\n         .segments\n         .iter()"}, {"sha": "7093bcf6adf1cec4e9cf81d934e25bd676038718", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -18,9 +18,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{\n-    self, utils::find_nearest_parent_module, ExternalCrate, GetDefId, ItemId, PrimitiveType,\n-};\n+use crate::clean::{self, utils::find_nearest_parent_module, ExternalCrate, ItemId, PrimitiveType};\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n@@ -914,15 +912,10 @@ fn fmt_type<'cx>(\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_, ref self_def_id } => {\n-            let should_show_cast = match *trait_ {\n-                box clean::ResolvedPath { ref path, .. } => {\n-                    !path.segments.is_empty()\n-                        && self_def_id\n-                            .zip(trait_.def_id())\n-                            .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_)\n-                }\n-                _ => true,\n-            };\n+            let should_show_cast = !trait_.segments.is_empty()\n+                && self_def_id\n+                    .zip(Some(trait_.res.def_id()))\n+                    .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_);\n             if f.alternate() {\n                 if should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n@@ -936,36 +929,31 @@ fn fmt_type<'cx>(\n                     write!(f, \"{}::\", self_type.print(cx))?\n                 }\n             };\n-            match *trait_ {\n-                // It's pretty unsightly to look at `<A as B>::C` in output, and\n-                // we've got hyperlinking on our side, so try to avoid longer\n-                // notation as much as possible by making `C` a hyperlink to trait\n-                // `B` to disambiguate.\n-                //\n-                // FIXME: this is still a lossy conversion and there should probably\n-                //        be a better way of representing this in general? Most of\n-                //        the ugliness comes from inlining across crates where\n-                //        everything comes in as a fully resolved QPath (hard to\n-                //        look at).\n-                box clean::ResolvedPath { did, .. } => {\n-                    match href(did, cx) {\n-                        Ok((ref url, _, ref path)) if !f.alternate() => {\n-                            write!(\n-                                f,\n-                                \"<a class=\\\"type\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n+            // It's pretty unsightly to look at `<A as B>::C` in output, and\n+            // we've got hyperlinking on our side, so try to avoid longer\n+            // notation as much as possible by making `C` a hyperlink to trait\n+            // `B` to disambiguate.\n+            //\n+            // FIXME: this is still a lossy conversion and there should probably\n+            //        be a better way of representing this in general? Most of\n+            //        the ugliness comes from inlining across crates where\n+            //        everything comes in as a fully resolved QPath (hard to\n+            //        look at).\n+            match href(trait_.res.def_id(), cx) {\n+                Ok((ref url, _, ref path)) if !f.alternate() => {\n+                    write!(\n+                        f,\n+                        \"<a class=\\\"type\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n                                     title=\\\"type {path}::{name}\\\">{name}</a>\",\n-                                url = url,\n-                                shortty = ItemType::AssocType,\n-                                name = name,\n-                                path = path.join(\"::\")\n-                            )?;\n-                        }\n-                        _ => write!(f, \"{}\", name)?,\n-                    }\n-                    Ok(())\n+                        url = url,\n+                        shortty = ItemType::AssocType,\n+                        name = name,\n+                        path = path.join(\"::\")\n+                    )?;\n                 }\n-                _ => write!(f, \"{}\", name),\n+                _ => write!(f, \"{}\", name)?,\n             }\n+            Ok(())\n         }\n     }\n }"}, {"sha": "7336b8b41ac161d4c3232374b9fa194756f767cb", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -226,16 +226,13 @@ fn get_index_type(clean_type: &clean::Type) -> RenderType {\n fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<Symbol> {\n     match *clean_type {\n         clean::ResolvedPath { ref path, .. } => {\n-            let segments = &path.segments;\n-            let path_segment = segments.iter().last().unwrap_or_else(|| {\n-                panic!(\n-                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n-                clean_type, accept_generic\n-            )\n-            });\n+            let path_segment = path.segments.last().unwrap();\n             Some(path_segment.name)\n         }\n-        clean::DynTrait(ref bounds, _) => get_index_type_name(&bounds[0].trait_, accept_generic),\n+        clean::DynTrait(ref bounds, _) => {\n+            let path = &bounds[0].trait_;\n+            Some(path.segments.last().unwrap().name)\n+        }\n         clean::Generic(s) if accept_generic => Some(s),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n         clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n@@ -324,7 +321,8 @@ crate fn get_real_types<'tcx>(\n         }\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n-                if let Some(ty) = bound.get_trait_type() {\n+                if let Some(path) = bound.get_trait_path() {\n+                    let ty = Type::ResolvedPath { did: path.res.def_id(), path };\n                     let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n                     nb_added += adds;\n                     if adds == 0 && !ty.is_full_generic() {"}, {"sha": "74236999003198e7b7009043bac2eb7c5995a505", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -2370,6 +2370,15 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     let mut visited = FxHashSet::default();\n     let mut work = VecDeque::new();\n \n+    let mut process_path = |did: DefId| {\n+        let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n+        let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n+\n+        if let Some(path) = fqp {\n+            out.push(path.join(\"::\"));\n+        }\n+    };\n+\n     work.push_back(first_ty);\n \n     while let Some(ty) = work.pop_front() {\n@@ -2378,14 +2387,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n         }\n \n         match ty {\n-            clean::Type::ResolvedPath { did, .. } => {\n-                let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n-                let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n-\n-                if let Some(path) = fqp {\n-                    out.push(path.join(\"::\"));\n-                }\n-            }\n+            clean::Type::ResolvedPath { did, .. } => process_path(did),\n             clean::Type::Tuple(tys) => {\n                 work.extend(tys.into_iter());\n             }\n@@ -2403,7 +2405,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             }\n             clean::Type::QPath { self_type, trait_, .. } => {\n                 work.push_back(*self_type);\n-                work.push_back(*trait_);\n+                process_path(trait_.res.def_id());\n             }\n             _ => {}\n         }"}, {"sha": "10320baaf93d07c9e4e9e742fda93b366f0d0695", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d3b7201e239c9966d43c0eaf1a4b636b0e06a8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=91d3b7201e239c9966d43c0eaf1a4b636b0e06a8", "patch": "@@ -363,8 +363,11 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n         use clean::GenericBound::*;\n         match bound {\n             TraitBound(clean::PolyTrait { trait_, generic_params }, modifier) => {\n+                // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n+                let trait_ =\n+                    clean::ResolvedPath { did: trait_.res.def_id(), path: trait_ }.into_tcx(tcx);\n                 GenericBound::TraitBound {\n-                    trait_: trait_.into_tcx(tcx),\n+                    trait_,\n                     generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n                     modifier: from_trait_bound_modifier(modifier),\n                 }\n@@ -394,15 +397,12 @@ impl FromWithTcx<clean::Type> for Type {\n                 param_names: Vec::new(),\n             },\n             DynTrait(mut bounds, lt) => {\n-                let (path, id) = match bounds.remove(0).trait_ {\n-                    ResolvedPath { path, did, .. } => (path, did),\n-                    _ => unreachable!(),\n-                };\n+                let first_trait = bounds.remove(0).trait_;\n \n                 Type::ResolvedPath {\n-                    name: path.whole_name(),\n-                    id: from_item_id(id.into()),\n-                    args: path\n+                    name: first_trait.whole_name(),\n+                    id: from_item_id(first_trait.res.def_id().into()),\n+                    args: first_trait\n                         .segments\n                         .last()\n                         .map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n@@ -434,11 +434,15 @@ impl FromWithTcx<clean::Type> for Type {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n-            QPath { name, self_type, trait_, .. } => Type::QualifiedPath {\n-                name: name.to_string(),\n-                self_type: Box::new((*self_type).into_tcx(tcx)),\n-                trait_: Box::new((*trait_).into_tcx(tcx)),\n-            },\n+            QPath { name, self_type, trait_, .. } => {\n+                // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n+                let trait_ = ResolvedPath { did: trait_.res.def_id(), path: *trait_ }.into_tcx(tcx);\n+                Type::QualifiedPath {\n+                    name: name.to_string(),\n+                    self_type: Box::new((*self_type).into_tcx(tcx)),\n+                    trait_: Box::new(trait_),\n+                }\n+            }\n         }\n     }\n }\n@@ -507,7 +511,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n             blanket_impl,\n             span: _span,\n         } = impl_;\n-        // FIXME: should `trait_` be a Path in JSON?\n+        // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n         let trait_ = trait_.map(|path| {\n             let did = path.res.def_id();\n             clean::ResolvedPath { path, did }.into_tcx(tcx)"}]}