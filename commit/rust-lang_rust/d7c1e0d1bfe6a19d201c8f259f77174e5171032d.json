{"sha": "d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YzFlMGQxYmZlNmExOWQyMDFjOGYyNTlmNzcxNzRlNTE3MTAzMmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-13T20:18:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-13T20:18:12Z"}, "message": "Rollup merge of #57366 - estebank:point-match-discrim, r=varkor\n\nPoint at match discriminant on type error in match arm pattern\n\n```\nerror[E0308]: mismatched types\n --> src/main.rs:5:9\n  |\n4 |    let temp: usize = match a + b {\n  |                            ----- this expression has type `usize`\n5 |         Ok(num) => num,\n  |         ^^^^^^^ expected usize, found enum `std::result::Result`\n  |\n  = note: expected type `usize`\n             found type `std::result::Result<_, _>`\n```\nFix #57279.", "tree": {"sha": "4d4508e6361a1165fd7eeac9d2092b7ba5876768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d4508e6361a1165fd7eeac9d2092b7ba5876768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcO50ECRBK7hj4Ov3rIwAAdHIIAJlPGbkTGwDXwCYEhyniPLBK\n21+XpAvuctQlqQMisw3NvmdH9W9IGU6BU2NUCBorMZCiBfqvsgerPRmUJ/3xJDXU\nsYzywkHQOpfvnwl4iNP411xqmp4ca3DZdVL6xMr0e6ORsLwtm6njUsYD9KWejiOb\n2hkCYlzdX1zlJHRupJE+1GjYaUCqQnsAUyh2K/qxmDtlSzZSpMiXigts/0ALZiT+\nHbbbrVvecW/JL4KUxa7rBxSw6xgcmae0UiQwEjjwnSKaBr3RfZGSLQC7ddTBn7pn\nm5lud7xKQjohkiKzvvAUbIekv53lSGa1AMbMcxfKJT+Q4VGTd5Q+uJDxpnNhfFE=\n=nbeN\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d4508e6361a1165fd7eeac9d2092b7ba5876768\nparent 45d357265a350afdc34fe866c2cf30bc575990a6\nparent 10fbdbf949f3ca171a52010eb2c53547c3e5b4f5\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547410692 +0100\ncommitter GitHub <noreply@github.com> 1547410692 +0100\n\nRollup merge of #57366 - estebank:point-match-discrim, r=varkor\n\nPoint at match discriminant on type error in match arm pattern\n\n```\nerror[E0308]: mismatched types\n --> src/main.rs:5:9\n  |\n4 |    let temp: usize = match a + b {\n  |                            ----- this expression has type `usize`\n5 |         Ok(num) => num,\n  |         ^^^^^^^ expected usize, found enum `std::result::Result`\n  |\n  = note: expected type `usize`\n             found type `std::result::Result<_, _>`\n```\nFix #57279.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "html_url": "https://github.com/rust-lang/rust/commit/d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45d357265a350afdc34fe866c2cf30bc575990a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/45d357265a350afdc34fe866c2cf30bc575990a6", "html_url": "https://github.com/rust-lang/rust/commit/45d357265a350afdc34fe866c2cf30bc575990a6"}, {"sha": "10fbdbf949f3ca171a52010eb2c53547c3e5b4f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/10fbdbf949f3ca171a52010eb2c53547c3e5b4f5", "html_url": "https://github.com/rust-lang/rust/commit/10fbdbf949f3ca171a52010eb2c53547c3e5b4f5"}], "stats": {"total": 274, "additions": 194, "deletions": 80}, "files": [{"sha": "f71cce8273c46db336fee0eb92e96708457bf842", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -487,6 +487,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn note_error_origin(&self, err: &mut DiagnosticBuilder<'tcx>, cause: &ObligationCause<'tcx>) {\n         match cause.code {\n+            ObligationCauseCode::MatchExpressionArmPattern { span, ty } => {\n+                if ty.is_suggestable() {  // don't show type `_`\n+                    err.span_label(span, format!(\"this match expression has type `{}`\", ty));\n+                }\n+            }\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";"}, {"sha": "7d9e80fd60f5c345020a1e72739539d3703f62a4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1444,15 +1444,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable |\n             ObligationCauseCode::MatchExpressionArm { .. } |\n+            ObligationCauseCode::MatchExpressionArmPattern { .. } |\n             ObligationCauseCode::IfExpression |\n             ObligationCauseCode::IfExpressionWithNoElse |\n             ObligationCauseCode::MainFunctionType |\n             ObligationCauseCode::StartFunctionType |\n             ObligationCauseCode::IntrinsicType |\n             ObligationCauseCode::MethodReceiver |\n             ObligationCauseCode::ReturnNoExpression |\n-            ObligationCauseCode::MiscObligation => {\n-            }\n+            ObligationCauseCode::MiscObligation => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "14c25b77a1b8213f855f2dfde4dc3129c2a7e3c2", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -220,8 +220,13 @@ pub enum ObligationCauseCode<'tcx> {\n     ExprAssignable,\n \n     /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm { arm_span: Span,\n-                         source: hir::MatchSource },\n+    MatchExpressionArm {\n+        arm_span: Span,\n+        source: hir::MatchSource,\n+    },\n+\n+    /// Computing common supertype in the pattern guard for the arms of a match expression\n+    MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n     /// Computing common supertype in an if expression\n     IfExpression,"}, {"sha": "277e2ed0e87d26980ba2f021a23a891847c7a3c5", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -517,6 +517,9 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 arm_span,\n                 source: source,\n             }),\n+            super::MatchExpressionArmPattern { span, ty } => {\n+                tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n+            }\n             super::IfExpression => Some(super::IfExpression),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),"}, {"sha": "1767af4870d3b27eca2564d33b461a746e2f54d4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 104, "deletions": 69, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -20,21 +20,33 @@ use std::cmp;\n use super::report_unexpected_variant_def;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    /// The `is_arg` argument indicates whether this pattern is the\n-    /// *outermost* pattern in an argument (e.g., in `fn foo(&x:\n-    /// &u32)`, it is true for the `&x` pattern but not `x`). This is\n-    /// used to tailor error reporting.\n+    /// `match_discrim_span` argument having a `Span` indicates that this pattern is part of\n+    /// a match expression arm guard, and it points to the match discriminant to add context\n+    /// in type errors. In the folloowing example, `match_discrim_span` corresponds to the\n+    /// `a + b` expression:\n+    ///\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///  --> src/main.rs:5:9\n+    ///   |\n+    /// 4 |    let temp: usize = match a + b {\n+    ///   |                            ----- this expression has type `usize`\n+    /// 5 |         Ok(num) => num,\n+    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n+    ///   |\n+    ///   = note: expected type `usize`\n+    ///              found type `std::result::Result<_, _>`\n+    /// ```\n     pub fn check_pat_walk(\n         &self,\n         pat: &'gcx hir::Pat,\n         mut expected: Ty<'tcx>,\n         mut def_bm: ty::BindingMode,\n-        is_arg: bool)\n-    {\n+        match_discrim_span: Option<Span>,\n+    ) {\n         let tcx = self.tcx;\n \n-        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?},is_arg={})\",\n-            pat, expected, def_bm, is_arg);\n+        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n         let is_non_ref_pat = match pat.node {\n             PatKind::Struct(..) |\n@@ -210,8 +222,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n-                self.demand_eqtype(pat.span, expected, lhs_ty);\n-                self.demand_eqtype(pat.span, expected, rhs_ty);\n+                self.demand_eqtype_pat(pat.span, expected, lhs_ty, match_discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, rhs_ty, match_discrim_span);\n                 common_type\n             }\n             PatKind::Binding(ba, var_id, _, ref sub) => {\n@@ -240,37 +252,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n                         // an explanation.\n-                        self.demand_eqtype(pat.span, region_ty, local_ty);\n+                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, match_discrim_span);\n                     }\n                     // otherwise the type of x is the expected type T\n                     ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n-                        self.demand_eqtype(pat.span, expected, local_ty);\n+                        self.demand_eqtype_pat(pat.span, expected, local_ty, match_discrim_span);\n                     }\n                 }\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 if var_id != pat.id {\n                     let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype(pat.span, vt, local_ty);\n+                    self.demand_eqtype_pat(pat.span, vt, local_ty, match_discrim_span);\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, true);\n+                    self.check_pat_walk(&p, expected, def_bm, match_discrim_span);\n                 }\n \n                 local_ty\n             }\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected, def_bm)\n+                self.check_pat_tuple_struct(\n+                    pat,\n+                    qpath,\n+                    &subpats,\n+                    ddpos,\n+                    expected,\n+                    def_bm,\n+                    match_discrim_span,\n+                )\n             }\n             PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, qpath, expected)\n             }\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm)\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, match_discrim_span)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -295,12 +315,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // further errors being emitted when using the bindings. #50333\n                     let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n                     for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, true);\n+                        self.check_pat_walk(elem, &tcx.types.err, def_bm, match_discrim_span);\n                     }\n                     tcx.mk_tup(element_tys_iter)\n                 } else {\n                     for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n+                        self.check_pat_walk(elem, &element_tys[i], def_bm, match_discrim_span);\n                     }\n                     pat_ty\n                 }\n@@ -313,11 +333,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Here, `demand::subtype` is good enough, but I don't\n                     // think any errors can be introduced by using\n                     // `demand::eqtype`.\n-                    self.demand_eqtype(pat.span, expected, uniq_ty);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, true);\n+                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, match_discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n                     uniq_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, true);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -349,15 +369,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // Look for a case like `fn foo(&foo: u32)` and suggest\n                             // `fn foo(foo: &u32)`\n                             if let Some(mut err) = err {\n-                                if is_arg {\n-                                    if let PatKind::Binding(..) = inner.node {\n-                                        if let Ok(snippet) = tcx.sess.source_map()\n-                                                                     .span_to_snippet(pat.span)\n-                                        {\n-                                            err.help(&format!(\"did you mean `{}: &{}`?\",\n-                                                              &snippet[1..],\n-                                                              expected));\n-                                        }\n+                                if let PatKind::Binding(..) = inner.node {\n+                                    if let Ok(snippet) = tcx.sess.source_map()\n+                                                                    .span_to_snippet(pat.span)\n+                                    {\n+                                        err.help(&format!(\"did you mean `{}: &{}`?\",\n+                                                            &snippet[1..],\n+                                                            expected));\n                                     }\n                                 }\n                                 err.emit();\n@@ -366,10 +384,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     };\n \n-                    self.check_pat_walk(&inner, inner_ty, def_bm, true);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n                     rptr_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, true);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -427,13 +445,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, true);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, true);\n+                    self.check_pat_walk(&slice, slice_ty, def_bm, match_discrim_span);\n                 }\n                 for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, true);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n                 }\n                 expected_ty\n             }\n@@ -524,12 +542,14 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         true\n     }\n \n-    pub fn check_match(&self,\n-                       expr: &'gcx hir::Expr,\n-                       discrim: &'gcx hir::Expr,\n-                       arms: &'gcx [hir::Arm],\n-                       expected: Expectation<'tcx>,\n-                       match_src: hir::MatchSource) -> Ty<'tcx> {\n+    pub fn check_match(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        discrim: &'gcx hir::Expr,\n+        arms: &'gcx [hir::Arm],\n+        expected: Expectation<'tcx>,\n+        match_src: hir::MatchSource,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         // Not entirely obvious: if matches may create ref bindings, we want to\n@@ -624,8 +644,12 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat_walk(&p, discrim_ty,\n-                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable), true);\n+                self.check_pat_walk(\n+                    &p,\n+                    discrim_ty,\n+                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+                    Some(discrim.span),\n+                );\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -703,26 +727,34 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         coercion.complete(self)\n     }\n \n-    fn check_pat_struct(&self,\n-                        pat: &'gcx hir::Pat,\n-                        qpath: &hir::QPath,\n-                        fields: &'gcx [Spanned<hir::FieldPat>],\n-                        etc: bool,\n-                        expected: Ty<'tcx>,\n-                        def_bm: ty::BindingMode) -> Ty<'tcx>\n+    fn check_pat_struct(\n+        &self,\n+        pat: &'gcx hir::Pat,\n+        qpath: &hir::QPath,\n+        fields: &'gcx [Spanned<hir::FieldPat>],\n+        etc: bool,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        match_discrim_span: Option<Span>,\n+    ) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, true);\n+                self.check_pat_walk(\n+                    &field.node.pat,\n+                    self.tcx.types.err,\n+                    def_bm,\n+                    match_discrim_span,\n+                );\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_discrim_span);\n \n         // Type-check subpatterns.\n         if self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc, def_bm) {\n@@ -732,11 +764,12 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n     }\n \n-    fn check_pat_path(&self,\n-                      pat: &hir::Pat,\n-                      qpath: &hir::QPath,\n-                      expected: Ty<'tcx>) -> Ty<'tcx>\n-    {\n+    fn check_pat_path(\n+        &self,\n+        pat: &hir::Pat,\n+        qpath: &hir::QPath,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         // Resolve the path and check the definition for errors.\n@@ -767,18 +800,20 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         pat_ty\n     }\n \n-    fn check_pat_tuple_struct(&self,\n-                              pat: &hir::Pat,\n-                              qpath: &hir::QPath,\n-                              subpats: &'gcx [P<hir::Pat>],\n-                              ddpos: Option<usize>,\n-                              expected: Ty<'tcx>,\n-                              def_bm: ty::BindingMode) -> Ty<'tcx>\n-    {\n+    fn check_pat_tuple_struct(\n+        &self,\n+        pat: &hir::Pat,\n+        qpath: &hir::QPath,\n+        subpats: &'gcx [P<hir::Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        match_arm_pat_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat_walk(&pat, tcx.types.err, def_bm, true);\n+                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n             }\n         };\n         let report_unexpected_def = |def: Def| {\n@@ -826,7 +861,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n         let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n-        self.demand_eqtype(pat.span, expected, pat_ty);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n \n         // Type-check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n@@ -837,7 +872,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat_walk(&subpat, field_ty, def_bm, true);\n+                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.id), subpat.span);\n             }\n@@ -917,7 +952,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 }\n             };\n \n-            self.check_pat_walk(&field.pat, field_ty, def_bm, true);\n+            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n         }\n         let mut unmentioned_fields = variant.fields\n                 .iter()"}, {"sha": "c0cedd77440d9898e47352a5fb717cc918a51512", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,6 @@\n use check::FnCtxt;\n use rustc::infer::InferOk;\n-use rustc::traits::ObligationCause;\n+use rustc::traits::{ObligationCause, ObligationCauseCode};\n \n use syntax::ast;\n use syntax::util::parser::PREC_POSTFIX;\n@@ -66,6 +66,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn demand_eqtype_pat(\n+        &self,\n+        cause_span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        match_expr_span: Option<Span>,\n+    ) {\n+        let cause = if let Some(span) = match_expr_span {\n+            self.cause(\n+                cause_span,\n+                ObligationCauseCode::MatchExpressionArmPattern { span, ty: expected },\n+            )\n+        } else {\n+            self.misc(cause_span)\n+        };\n+        self.demand_eqtype_with_origin(&cause, expected, actual).map(|mut err| err.emit());\n+    }\n+\n+\n     pub fn demand_coerce(&self,\n                          expr: &hir::Expr,\n                          checked_ty: Ty<'tcx>,"}, {"sha": "4d4486a348ebf43ef2afe4210b8e1c08225b5152", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1084,8 +1084,12 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n         // Check the pattern.\n-        fcx.check_pat_walk(&arg.pat, arg_ty,\n-            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable), true);\n+        fcx.check_pat_walk(\n+            &arg.pat,\n+            arg_ty,\n+            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+            None,\n+        );\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n@@ -4723,9 +4727,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.check_pat_walk(&local.pat, t,\n-                            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-                            true);\n+        self.check_pat_walk(\n+            &local.pat,\n+            t,\n+            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+            None,\n+        );\n         let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n             self.write_ty(local.hir_id, pat_ty);"}, {"sha": "417667a5354fd723d445c5e9271bb60ccf7d59e1", "filename": "src/test/ui/block-result/issue-13624.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -12,6 +12,8 @@ LL |     Enum::EnumStructVariant { x: 1, y: 2, z: 3 }\n error[E0308]: mismatched types\n   --> $DIR/issue-13624.rs:22:9\n    |\n+LL |       match enum_struct_variant {\n+   |             ------------------- this match expression has type `()`\n LL |         a::Enum::EnumStructVariant { x, y, z } => {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum `a::Enum`\n    |"}, {"sha": "f69a389336590817614194480b0a7f037ada8ca2", "filename": "src/test/ui/error-codes/E0308-4.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/E0308-4.rs:4:9\n    |\n+LL |     match x {\n+   |           - this match expression has type `u8`\n LL |         0u8..=3i8 => (), //~ ERROR E0308\n    |         ^^^^^^^^^ expected u8, found i8\n "}, {"sha": "683ad48ff52c0b4249eefe376f2474f353961678", "filename": "src/test/ui/issues/issue-11844.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-11844.rs:6:9\n    |\n+LL |     match a {\n+   |           - this match expression has type `std::option::Option<std::boxed::Box<{integer}>>`\n LL |         Ok(a) => //~ ERROR: mismatched types\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "768d11bf899a1f333f33f22c15aeb0c8769305aa", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:6:5\n    |\n+LL |   match t {\n+   |         - this match expression has type `std::result::Result<_, {integer}>`\n LL |     Some(k) => match k { //~ ERROR mismatched types\n    |     ^^^^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n    |"}, {"sha": "66255891f469a01534d355464546a796ca3c14f1", "filename": "src/test/ui/issues/issue-13466.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:8:9\n    |\n+LL |     let _x: usize = match Some(1) {\n+   |                           ------- this match expression has type `std::option::Option<{integer}>`\n LL |         Ok(u) => u,\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |\n@@ -10,6 +12,9 @@ LL |         Ok(u) => u,\n error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:14:9\n    |\n+LL |     let _x: usize = match Some(1) {\n+   |                           ------- this match expression has type `std::option::Option<{integer}>`\n+...\n LL |         Err(e) => panic!(e)\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "de9757d5d32ed912e4cc322177d84d0b9b74e658", "filename": "src/test/ui/issues/issue-15896.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-15896.rs:11:11\n    |\n+LL |     let u = match e {\n+   |                   - this match expression has type `main::R`\n+LL |         E::B(\n LL |           Tau{t: x},\n    |           ^^^^^^^^^ expected enum `main::R`, found struct `main::Tau`\n    |"}, {"sha": "1779d0befd871faab0eb4d6751dcb64ce5fa8d9f", "filename": "src/test/ui/issues/issue-16401.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-16401.rs:8:9\n    |\n+LL |     match () {\n+   |           -- this match expression has type `()`\n LL |         Slice { data: data, len: len } => (),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found struct `Slice`\n    |"}, {"sha": "51903cfadab15e4ee9096679d32a83cb3a1a4634", "filename": "src/test/ui/issues/issue-3680.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-3680.rs:3:9\n    |\n+LL |     match None {\n+   |           ---- this match expression has type `std::option::Option<_>`\n LL |         Err(_) => ()\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "0a918a789703e5f0e66725373b2e78026dfe3575", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -28,6 +28,8 @@ LL |         (true, false, false) => ()\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:33:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this match expression has type `(bool, bool)`\n LL |         box (true, false) => ()\n    |         ^^^^^^^^^^^^^^^^^ expected tuple, found struct `std::boxed::Box`\n    |"}, {"sha": "649a0c1581a687e0069b1e2504d13e5d7722d46c", "filename": "src/test/ui/issues/issue-5358-1.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5358-1.rs:6:9\n    |\n+LL |     match S(Either::Left(5)) {\n+   |           ------------------ this match expression has type `S`\n LL |         Either::Right(_) => {}\n    |         ^^^^^^^^^^^^^^^^ expected struct `S`, found enum `Either`\n    |"}, {"sha": "7bb682028748706ea5aa1c406e11c5de8035d7b6", "filename": "src/test/ui/issues/issue-7092.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-7092.rs:6:9\n    |\n+LL |     match x {\n+   |           - this match expression has type `Whatever`\n LL |         Some(field) =>\n    |         ^^^^^^^^^^^ expected enum `Whatever`, found enum `std::option::Option`\n    |"}, {"sha": "2a24a293e98364e68c6a3a4c47fbecac7ace3e05", "filename": "src/test/ui/match/match-struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/match-struct.rs:6:9\n    |\n+LL |     match (S { a: 1 }) {\n+   |           ------------ this match expression has type `S`\n LL |         E::C(_) => (),\n    |         ^^^^^^^ expected struct `S`, found enum `E`\n    |"}, {"sha": "53b663513696626d0b3a3a09eafb8fa17dc5bd9f", "filename": "src/test/ui/match/match-tag-unary.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/match-tag-unary.rs:4:43\n    |\n LL | fn main() { let x: A = A::A(0); match x { B::B(y) => { } } } //~ ERROR mismatched types\n-   |                                           ^^^^^^^ expected enum `A`, found enum `B`\n+   |                                       -   ^^^^^^^ expected enum `A`, found enum `B`\n+   |                                       |\n+   |                                       this match expression has type `A`\n    |\n    = note: expected type `A`\n               found type `B`"}, {"sha": "c2810d764c2ceba3d2247485e1f357aa962d755b", "filename": "src/test/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -21,6 +21,8 @@ LL |         A::B(_, _, _) => (), //~ ERROR this pattern has 3 fields, but\n error[E0308]: mismatched types\n   --> $DIR/pattern-error-continue.rs:22:9\n    |\n+LL |     match 'c' {\n+   |           --- this match expression has type `char`\n LL |         S { .. } => (),\n    |         ^^^^^^^^ expected char, found struct `S`\n    |"}, {"sha": "69cd552aabd1bf56c29f311977558064e6daa56a", "filename": "src/test/ui/pattern/pattern-tyvar.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/pattern-tyvar.rs:5:18\n    |\n+LL |     match t {\n+   |           - this match expression has type `std::option::Option<std::vec::Vec<isize>>`\n LL |       Bar::T1(_, Some::<isize>(x)) => { //~ ERROR mismatched types\n    |                  ^^^^^^^^^^^^^^^^ expected struct `std::vec::Vec`, found isize\n    |"}, {"sha": "cc62316bec1851c82be12ddd0c97d37f075e199b", "filename": "src/test/ui/structs/structure-constructor-type-mismatch.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7c1e0d1bfe6a19d201c8f259f77174e5171032d/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr?ref=d7c1e0d1bfe6a19d201c8f259f77174e5171032d", "patch": "@@ -109,6 +109,8 @@ LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:54:9\n    |\n+LL |     match (Point { x: 1, y: 2 }) {\n+   |           ---------------------- this match expression has type `Point<{integer}>`\n LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n    |         ^^^^^^^^^^^^^^^^^^^^ expected integer, found f32\n    |\n@@ -118,6 +120,8 @@ LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:59:9\n    |\n+LL |     match (Point { x: 1, y: 2 }) {\n+   |           ---------------------- this match expression has type `Point<{integer}>`\n LL |         PointF { .. } => {} //~ ERROR mismatched types\n    |         ^^^^^^^^^^^^^ expected integer, found f32\n    |\n@@ -127,6 +131,8 @@ LL |         PointF { .. } => {} //~ ERROR mismatched types\n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:67:9\n    |\n+LL |     match (Pair { x: 1, y: 2 }) {\n+   |           --------------------- this match expression has type `Pair<{integer}, {integer}>`\n LL |         PairF::<u32> { .. } => {} //~ ERROR mismatched types\n    |         ^^^^^^^^^^^^^^^^^^^ expected integer, found f32\n    |"}]}