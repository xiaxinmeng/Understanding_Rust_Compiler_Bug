{"sha": "c27f7568bc74c418996892028a629eed5a7f5f00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyN2Y3NTY4YmM3NGM0MTg5OTY4OTIwMjhhNjI5ZWVkNWE3ZjVmMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-13T17:18:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-13T17:18:56Z"}, "message": "Auto merge of #65388 - Centril:rollup-rhg0dvs, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #65214 (Split non-CAS atomic support off into target_has_atomic_load_store)\n - #65246 (vxWorks: implement get_path() and get_mode() for File fmt::Debug)\n - #65312 (improve performance of signed saturating_mul)\n - #65336 (Fix typo in task::Waker)\n - #65346 (nounwind tests and cleanup)\n - #65347 (Fix #[unwind(abort)] with Rust ABI)\n - #65366 (Implement Error::source on IntoStringError + Remove superfluous cause impls)\n - #65369 (Don't discard value names when using address or memory sanitizer)\n - #65370 (Add `dyn` to `Any` documentation)\n - #65373 (Fix typo in docs for `Rc`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "444af2d13953edc31348d22a374490f95b40210b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/444af2d13953edc31348d22a374490f95b40210b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c27f7568bc74c418996892028a629eed5a7f5f00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c27f7568bc74c418996892028a629eed5a7f5f00", "html_url": "https://github.com/rust-lang/rust/commit/c27f7568bc74c418996892028a629eed5a7f5f00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c27f7568bc74c418996892028a629eed5a7f5f00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa2ae564d391a3da10bca2a79ab529a9925fbe58", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ae564d391a3da10bca2a79ab529a9925fbe58", "html_url": "https://github.com/rust-lang/rust/commit/aa2ae564d391a3da10bca2a79ab529a9925fbe58"}, {"sha": "92b36ce4a7d08930411e43d6aa3c8cf07a8d2701", "url": "https://api.github.com/repos/rust-lang/rust/commits/92b36ce4a7d08930411e43d6aa3c8cf07a8d2701", "html_url": "https://github.com/rust-lang/rust/commit/92b36ce4a7d08930411e43d6aa3c8cf07a8d2701"}], "stats": {"total": 468, "additions": 269, "deletions": 199}, "files": [{"sha": "3684162d8b18741782e38e7ede8f13fa6088c417", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -153,7 +153,7 @@ mod boxed {\n #[cfg(test)]\n mod tests;\n pub mod collections;\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"ptr\")]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "b0651f16484d7a625985d0a178bf9a7c31c5e96c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -773,7 +773,7 @@ impl<T: Clone> Rc<T> {\n     /// referred to as clone-on-write.\n     ///\n     /// If there are no other `Rc` pointers to this value, then [`Weak`]\n-    /// pointers to this value will be dissassociated.\n+    /// pointers to this value will be disassociated.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n@@ -799,7 +799,7 @@ impl<T: Clone> Rc<T> {\n     /// assert_eq!(*other_data, 12);\n     /// ```\n     ///\n-    /// [`Weak`] pointers will be dissassociated:\n+    /// [`Weak`] pointers will be disassociated:\n     ///\n     /// ```\n     /// use std::rc::Rc;"}, {"sha": "f75b7a454438406c25bbf0025fc26ac6e8644367", "filename": "src/libcore/any.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -2,14 +2,14 @@\n //! of any `'static` type through runtime reflection.\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used\n-//! as a trait object. As `&Any` (a borrowed trait object), it has the `is` and\n-//! `downcast_ref` methods, to test if the contained value is of a given type,\n-//! and to get a reference to the inner value as a type. As `&mut Any`, there\n+//! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n+//! and `downcast_ref` methods, to test if the contained value is of a given type,\n+//! and to get a reference to the inner value as a type. As `&mut dyn Any`, there\n //! is also the `downcast_mut` method, for getting a mutable reference to the\n-//! inner value. `Box<Any>` adds the `downcast` method, which attempts to\n+//! inner value. `Box<dyn Any>` adds the `downcast` method, which attempts to\n //! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n //!\n-//! Note that &Any is limited to testing whether a value is of a specified\n+//! Note that `&dyn Any` is limited to testing whether a value is of a specified\n //! concrete type, and cannot be used to test whether a type implements a trait.\n //!\n //! [`Box`]: ../../std/boxed/struct.Box.html"}, {"sha": "998c8f81652045752056da106734acef7532a673", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -1058,7 +1058,7 @@ $EndFeature, \"\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or_else(|| {\n-                    if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n+                    if (self < 0) == (rhs < 0) {\n                         Self::max_value()\n                     } else {\n                         Self::min_value()"}, {"sha": "73d5abf1aed2378a27c50a8c56fbc271a9cfb889", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 92, "deletions": 70, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -113,8 +113,8 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n \n use self::Ordering::*;\n \n@@ -160,14 +160,14 @@ pub fn spin_loop_hint() {\n /// This type has the same in-memory representation as a [`bool`].\n ///\n /// [`bool`]: ../../../std/primitive.bool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n pub struct AtomicBool {\n     v: UnsafeCell<u8>,\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n@@ -177,14 +177,14 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n #[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n@@ -193,7 +193,7 @@ pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n@@ -202,10 +202,10 @@ impl<T> Default for AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -306,7 +306,7 @@ pub enum Ordering {\n /// An [`AtomicBool`] initialized to `false`.\n ///\n /// [`AtomicBool`]: struct.AtomicBool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n     since = \"1.34.0\",\n@@ -315,7 +315,7 @@ pub enum Ordering {\n )]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -464,7 +464,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -502,7 +502,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -553,7 +553,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -609,7 +609,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -660,7 +660,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -702,7 +702,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -755,7 +755,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -796,13 +796,13 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -953,7 +953,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -989,7 +989,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1031,7 +1031,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1091,7 +1091,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1112,7 +1112,7 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n@@ -1128,16 +1128,17 @@ impl From<bool> for AtomicBool {\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n     #[inline]\n     fn from(p: *mut T) -> Self { Self::new(p) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n-    ($stable:meta,\n+    ($cfg_cas:meta,\n+     $stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n@@ -1358,7 +1359,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1398,7 +1399,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1456,7 +1457,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1508,7 +1509,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1546,7 +1547,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1578,7 +1579,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1613,7 +1614,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1649,7 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1684,7 +1685,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1719,7 +1720,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1769,7 +1770,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1830,7 +1831,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1882,7 +1883,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1892,8 +1893,9 @@ assert_eq!(min_foo, 12);\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1908,8 +1910,9 @@ atomic_int! {\n     \"AtomicI8::new(0)\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1924,8 +1927,9 @@ atomic_int! {\n     \"AtomicU8::new(0)\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1940,8 +1944,9 @@ atomic_int! {\n     \"AtomicI16::new(0)\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1956,8 +1961,9 @@ atomic_int! {\n     \"AtomicU16::new(0)\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1972,8 +1978,9 @@ atomic_int! {\n     \"AtomicI32::new(0)\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1988,8 +1995,12 @@ atomic_int! {\n     \"AtomicU32::new(0)\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2004,8 +2015,12 @@ atomic_int! {\n     \"AtomicI64::new(0)\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2020,8 +2035,9 @@ atomic_int! {\n     \"AtomicU64::new(0)\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2036,8 +2052,9 @@ atomic_int! {\n     \"AtomicI128::new(0)\",\n     i128 AtomicI128 ATOMIC_I128_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2052,20 +2069,24 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"16\")]\n macro_rules! ptr_width {\n     () => { 2 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"32\")]\n macro_rules! ptr_width {\n     () => { 4 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"64\")]\n macro_rules! ptr_width {\n     () => { 8 }\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2080,8 +2101,9 @@ atomic_int!{\n     \"AtomicIsize::new(0)\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2098,7 +2120,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -2132,7 +2154,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -2145,7 +2167,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -2158,7 +2180,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2170,7 +2192,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n@@ -2195,7 +2217,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2220,7 +2242,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2232,7 +2254,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2244,7 +2266,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2256,7 +2278,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2269,7 +2291,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2282,7 +2304,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2295,7 +2317,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2308,7 +2330,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),\n@@ -2506,23 +2528,23 @@ pub fn compiler_fence(order: Ordering) {\n }\n \n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n impl<T> fmt::Pointer for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "6f841bd2adf41a9be45c16512042475952e85512", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -217,7 +217,7 @@ impl fmt::Debug for Context<'_> {\n /// This handle encapsulates a [`RawWaker`] instance, which defines the\n /// executor-specific wakeup behavior.\n ///\n-/// Implements [`Clone`], [`trait@Send`], and [`trait@Sync`].\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n ///\n /// [`RawWaker`]: struct.RawWaker.html\n #[repr(transparent)]"}, {"sha": "0facf30b6274bbef1f1b6de99bdb1324894c6365", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -1513,22 +1513,25 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n-            let s = i.to_string();\n-            ret.insert((\n-                sym::target_has_atomic,\n-                Some(Symbol::intern(&s)),\n-            ));\n-            if &s == wordsz {\n+            let mut insert_atomic = |s| {\n                 ret.insert((\n-                    sym::target_has_atomic,\n-                    Some(Symbol::intern(\"ptr\")),\n+                    sym::target_has_atomic_load_store,\n+                    Some(Symbol::intern(s)),\n                 ));\n+                if atomic_cas {\n+                    ret.insert((\n+                        sym::target_has_atomic,\n+                        Some(Symbol::intern(s))\n+                    ));\n+                }\n+            };\n+            let s = i.to_string();\n+            insert_atomic(&s);\n+            if &s == wordsz {\n+              insert_atomic(\"ptr\");\n             }\n         }\n     }\n-    if atomic_cas {\n-        ret.insert((sym::target_has_atomic, Some(Symbol::intern(\"cas\"))));\n-    }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }"}, {"sha": "fa2902e4f0edef0d55424bc8394b79ae783e9b16", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n+use crate::session::config::{OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n@@ -626,6 +626,14 @@ impl Session {\n             .output_types\n             .contains_key(&OutputType::LlvmAssembly)\n             || self.opts.output_types.contains_key(&OutputType::Bitcode);\n+\n+        // Address sanitizer and memory sanitizer use alloca name when reporting an issue.\n+        let more_names = match self.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => true,\n+            Some(Sanitizer::Memory) => true,\n+            _ => more_names,\n+        };\n+\n         self.opts.debugging_opts.fewer_names || !more_names\n     }\n "}, {"sha": "6a36a4a50cbf3f2210b81c9dbfd244d8778a5dcb", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -270,23 +270,12 @@ pub fn from_fn_attrs(\n         // optimize based on this!\n         false\n     } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n-        // If a specific #[unwind] attribute is present, use that\n+        // If a specific #[unwind] attribute is present, use that.\n         true\n     } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n-        // Special attribute for allocator functions, which can't unwind\n+        // Special attribute for allocator functions, which can't unwind.\n         false\n-    } else if let Some(_) = id {\n-        // rust-lang/rust#64655, rust-lang/rust#63909: to minimize\n-        // risk associated with changing cases where nounwind\n-        // attribute is attached, this code is deliberately mimicking\n-        // old control flow based on whether `id` is `Some` or `None`.\n-        //\n-        // However, in the long term we should either:\n-        // - fold this into final else (i.e. stop inspecting `id`)\n-        // - or, adopt Rust PR #63909.\n-        //\n-        // see also Rust RFC 2753.\n-\n+    } else {\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         if sig.abi == Abi::Rust || sig.abi == Abi::RustCall {\n             // Any Rust method (or `extern \"Rust\" fn` or `extern\n@@ -312,15 +301,6 @@ pub fn from_fn_attrs(\n             // In either case, we mark item as explicitly nounwind.\n             false\n         }\n-    } else {\n-        // assume this can possibly unwind, avoiding the application of a\n-        // `nounwind` attribute below.\n-        //\n-        // (But: See comments in previous branch. Specifically, it is\n-        // unclear whether there is real value in the assumption this\n-        // can unwind. The conservatism here may just be papering over\n-        // a real problem by making some UB a bit harder to hit.)\n-        true\n     });\n \n     // Always annotate functions with the target-cpu they are compiled for."}, {"sha": "ffb70180bbb4b7676f1c88098e7fcf21071a756c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -502,24 +502,21 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n-    // Not callable from C, so we can safely unwind through these\n-    if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n-\n-    // Validate `#[unwind]` syntax regardless of platform-specific panic strategy\n+fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n+    // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n     let attrs = &tcx.get_attrs(fn_def_id);\n     let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n \n-    // We never unwind, so it's not relevant to stop an unwind\n+    // We never unwind, so it's not relevant to stop an unwind.\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind { return false; }\n \n-    // We cannot add landing pads, so don't add one\n+    // We cannot add landing pads, so don't add one.\n     if tcx.sess.no_landing_pads() { return false; }\n \n     // This is a special case: some functions have a C abi but are meant to\n     // unwind anyway. Don't stop them.\n     match unwind_attr {\n-        None => false, // FIXME(#58794)\n+        None => false, // FIXME(#58794); should be `!(abi == Abi::Rust || abi == Abi::RustCall)`\n         Some(UnwindAttr::Allowed) => false,\n         Some(UnwindAttr::Aborts) => true,\n     }"}, {"sha": "6b9a35fccc4dcaa6278a75ffaca46ebdaff4bc34", "filename": "src/libstd/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -269,8 +269,8 @@ impl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync + 'a> {\n-    /// Converts a type of [`Error`] + [`trait@Send`] + [`trait@Sync`] into a box of\n-    /// dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n+    /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of\n+    /// dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n     /// [`Error`]: ../error/trait.Error.html\n     ///\n@@ -313,7 +313,7 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<String> for Box<dyn Error + Send + Sync> {\n-    /// Converts a [`String`] into a box of dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n+    /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n     /// [`Error`]: ../error/trait.Error.html\n     ///\n@@ -377,7 +377,7 @@ impl From<String> for Box<dyn Error> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n-    /// Converts a [`str`] into a box of dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n+    /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n     /// [`Error`]: ../error/trait.Error.html\n     ///\n@@ -420,7 +420,7 @@ impl From<&str> for Box<dyn Error> {\n \n #[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\n impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n-    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n+    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n     /// [`Error`]: ../error/trait.Error.html"}, {"sha": "483f2ba52eca658c5516f27a7e0adab2213d96ef", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -919,7 +919,7 @@ impl Error for IntoStringError {\n         \"C string contained non-utf8 bytes\"\n     }\n \n-    fn cause(&self) -> Option<&dyn Error> {\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n         Some(&self.error)\n     }\n }"}, {"sha": "24c693790e84bcf239a57e3bff233604b595e36d", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -12,7 +12,9 @@ use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n use crate::ptr::{Unique, NonNull};\n use crate::rc::Rc;\n-use crate::sync::{Arc, Mutex, RwLock, atomic};\n+use crate::sync::{Arc, Mutex, RwLock};\n+#[cfg(not(bootstrap))]\n+use crate::sync::atomic;\n use crate::task::{Context, Poll};\n use crate::thread::Result;\n \n@@ -240,49 +242,49 @@ impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicIsize {}\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI8 {}\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI16 {}\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI32 {}\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI64 {}\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI128 {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_hastarget_has_atomic_load_store_atomic = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU8 {}\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU16 {}\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU32 {}\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU64 {}\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU128 {}\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicBool {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n "}, {"sha": "c2884a28f3ccdb57ceda20b368f3cfcea59d9c59", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -1581,10 +1581,6 @@ impl<T: Send> error::Error for SendError<T> {\n     fn description(&self) -> &str {\n         \"sending on a closed channel\"\n     }\n-\n-    fn cause(&self) -> Option<&dyn error::Error> {\n-        None\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1624,10 +1620,6 @@ impl<T: Send> error::Error for TrySendError<T> {\n             }\n         }\n     }\n-\n-    fn cause(&self) -> Option<&dyn error::Error> {\n-        None\n-    }\n }\n \n #[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\n@@ -1652,10 +1644,6 @@ impl error::Error for RecvError {\n     fn description(&self) -> &str {\n         \"receiving on a closed channel\"\n     }\n-\n-    fn cause(&self) -> Option<&dyn error::Error> {\n-        None\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1685,10 +1673,6 @@ impl error::Error for TryRecvError {\n             }\n         }\n     }\n-\n-    fn cause(&self) -> Option<&dyn error::Error> {\n-        None\n-    }\n }\n \n #[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\n@@ -1726,10 +1710,6 @@ impl error::Error for RecvTimeoutError {\n             }\n         }\n     }\n-\n-    fn cause(&self) -> Option<&dyn error::Error> {\n-        None\n-    }\n }\n \n #[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]"}, {"sha": "adb08d8005ad486ed3c7701de7812a90c498b9fb", "filename": "src/libstd/sys/vxworks/fs.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -400,13 +400,27 @@ impl FromInner<c_int> for File {\n \n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fn get_path(_fd: c_int) -> Option<PathBuf> {\n-            // FIXME(#:(): implement this for VxWorks\n-            None\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            let mut buf = vec![0;libc::PATH_MAX as usize];\n+            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n+            if n == -1 {\n+                return None;\n+            }\n+            let l = buf.iter().position(|&c| c == 0).unwrap();\n+            buf.truncate(l as usize);\n+            Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n-        fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n-            // FIXME(#:(): implement this for VxWorks\n-            None\n+        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n+            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n+            if mode == -1 {\n+                return None;\n+            }\n+            match mode & libc::O_ACCMODE {\n+                libc::O_RDONLY => Some((true, false)),\n+                libc::O_RDWR => Some((true, true)),\n+                libc::O_WRONLY => Some((false, true)),\n+                _ => None\n+            }\n         }\n \n         let fd = self.0.raw();"}, {"sha": "ab1620b95249151baf50576577b6ea15e8e069bb", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -29,6 +29,7 @@ const GATED_CFGS: &[(Symbol, Symbol, GateFn)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n     (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n     (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n     (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n ];"}, {"sha": "c37efde9923a73de3b694114c560ceaf877391ca", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -658,6 +658,7 @@ symbols! {\n         suggestion,\n         target_feature,\n         target_has_atomic,\n+        target_has_atomic_load_store,\n         target_thread_local,\n         task,\n         tbm_target_feature,"}, {"sha": "a935d8865226777371e97ea07c52039f46ddaead", "filename": "src/test/codegen/extern-functions.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fcodegen%2Fextern-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fcodegen%2Fextern-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fextern-functions.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -1,19 +0,0 @@\n-// compile-flags: -C no-prepopulate-passes\n-\n-#![crate_type = \"lib\"]\n-#![feature(unwind_attributes)]\n-\n-extern {\n-// CHECK: Function Attrs: nounwind\n-// CHECK-NEXT: declare void @extern_fn\n-    fn extern_fn();\n-// CHECK-NOT: Function Attrs: nounwind\n-// CHECK: declare void @unwinding_extern_fn\n-    #[unwind(allowed)]\n-    fn unwinding_extern_fn();\n-}\n-\n-pub unsafe fn force_declare() {\n-    extern_fn();\n-    unwinding_extern_fn();\n-}"}, {"sha": "54d6a8d2794ba368b4ecfb27595c12a515a57a15", "filename": "src/test/codegen/nounwind-extern.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fcodegen%2Fnounwind-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fcodegen%2Fnounwind-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnounwind-extern.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -1,6 +0,0 @@\n-// compile-flags: -O\n-\n-#![crate_type = \"lib\"]\n-\n-// CHECK: Function Attrs: norecurse nounwind\n-pub extern fn foo() {}"}, {"sha": "ddb3a4f6b4dd811aaa1cff563763924716c53b23", "filename": "src/test/codegen/unwind-extern-exports.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Fcodegen%2Funwind-extern-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Fcodegen%2Funwind-extern-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-extern-exports.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -C opt-level=0\n+\n+#![crate_type = \"lib\"]\n+#![feature(unwind_attributes)]\n+\n+// Make sure these all do *not* get the attribute.\n+// We disable optimizations to prevent LLVM from infering the attribute.\n+// CHECK-NOT: nounwind\n+\n+// \"C\" ABI\n+// pub extern fn foo() {} // FIXME right now we don't abort-on-panic but add `nounwind` nevertheless\n+#[unwind(allowed)]\n+pub extern fn foo_allowed() {}\n+\n+// \"Rust\"\n+// (`extern \"Rust\"` could be removed as all `fn` get it implicitly; we leave it in for clarity.)\n+pub extern \"Rust\" fn bar() {}\n+#[unwind(allowed)]\n+pub extern \"Rust\" fn bar_allowed() {}"}, {"sha": "485e8bbcd4289a231376bde1588ff96e62288f7a", "filename": "src/test/codegen/unwind-extern-imports.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Fcodegen%2Funwind-extern-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Fcodegen%2Funwind-extern-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-extern-imports.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -0,0 +1,41 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(unwind_attributes)]\n+\n+extern {\n+// CHECK: Function Attrs:{{.*}}nounwind\n+// CHECK-NEXT: declare void @extern_fn\n+    fn extern_fn();\n+// CHECK-NOT: Function Attrs:{{.*}}nounwind\n+// CHECK: declare void @unwinding_extern_fn\n+    #[unwind(allowed)]\n+    fn unwinding_extern_fn();\n+// CHECK-NOT: nounwind\n+// CHECK: declare void @aborting_extern_fn\n+    #[unwind(aborts)]\n+    fn aborting_extern_fn(); // FIXME: we want to have the attribute here\n+}\n+\n+extern \"Rust\" {\n+// CHECK-NOT: nounwind\n+// CHECK: declare void @rust_extern_fn\n+    fn rust_extern_fn();\n+// CHECK-NOT: nounwind\n+// CHECK: declare void @rust_unwinding_extern_fn\n+    #[unwind(allowed)]\n+    fn rust_unwinding_extern_fn();\n+// CHECK-NOT: nounwind\n+// CHECK: declare void @rust_aborting_extern_fn\n+    #[unwind(aborts)]\n+    fn rust_aborting_extern_fn(); // FIXME: we want to have the attribute here\n+}\n+\n+pub unsafe fn force_declare() {\n+    extern_fn();\n+    unwinding_extern_fn();\n+    aborting_extern_fn();\n+    rust_extern_fn();\n+    rust_unwinding_extern_fn();\n+    rust_aborting_extern_fn();\n+}"}, {"sha": "3a377c32993d5497ef982964a1198944b3c9df4d", "filename": "src/test/run-make-fulldeps/sanitizer-address/Makefile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -24,4 +24,7 @@ endif\n \n all:\n \t$(RUSTC) -g -Z sanitizer=address -Z print-link-args $(EXTRA_RUSTFLAG) overflow.rs | $(CGREP) librustc_asan\n+\t# Verify that stack buffer overflow is detected:\n \t$(TMPDIR)/overflow 2>&1 | $(CGREP) stack-buffer-overflow\n+\t# Verify that variable name is included in address sanitizer report:\n+\t$(TMPDIR)/overflow 2>&1 | $(CGREP) \"'xs'\""}, {"sha": "9868fc1d41700ab5b1f66d2b80a5edf2614f4b9c", "filename": "src/test/run-make-fulldeps/target-without-atomic-cas/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -2,4 +2,4 @@\n \n # The target used below doesn't support atomic CAS operations. Verify that's the case\n all:\n-\t$(RUSTC) --print cfg --target thumbv6m-none-eabi | $(CGREP) -v 'target_has_atomic=\"cas\"'\n+\t$(RUSTC) --print cfg --target thumbv6m-none-eabi | $(CGREP) -v 'target_has_atomic=\"ptr\"'"}, {"sha": "c6e8dbf012cf3d42d6443ba7435e9f6cb80eb81a", "filename": "src/test/ui/panics/abort-on-panic.rs", "status": "renamed", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27f7568bc74c418996892028a629eed5a7f5f00/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs?ref=c27f7568bc74c418996892028a629eed5a7f5f00", "patch": "@@ -14,27 +14,51 @@ use std::io::prelude::*;\n use std::io;\n use std::process::{Command, Stdio};\n \n-#[unwind(aborts)] // FIXME(#58794)\n+#[unwind(aborts)] // FIXME(#58794) should work even without the attribute\n extern \"C\" fn panic_in_ffi() {\n     panic!(\"Test\");\n }\n \n+#[unwind(aborts)]\n+extern \"Rust\" fn panic_in_rust_abi() {\n+    panic!(\"TestRust\");\n+}\n+\n fn test() {\n     let _ = panic::catch_unwind(|| { panic_in_ffi(); });\n     // The process should have aborted by now.\n     io::stdout().write(b\"This should never be printed.\\n\");\n     let _ = io::stdout().flush();\n }\n \n+fn testrust() {\n+    let _ = panic::catch_unwind(|| { panic_in_rust_abi(); });\n+    // The process should have aborted by now.\n+    io::stdout().write(b\"This should never be printed.\\n\");\n+    let _ = io::stdout().flush();\n+}\n+\n fn main() {\n     let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"test\" {\n-        return test();\n+    if args.len() > 1 {\n+        // This is inside the self-executed command.\n+        match &*args[1] {\n+            \"test\" => return test(),\n+            \"testrust\" => return testrust(),\n+            _ => panic!(\"bad test\"),\n+        }\n     }\n \n+    // These end up calling the self-execution branches above.\n     let mut p = Command::new(&args[0])\n                         .stdout(Stdio::piped())\n                         .stdin(Stdio::piped())\n                         .arg(\"test\").spawn().unwrap();\n     assert!(!p.wait().unwrap().success());\n+\n+    let mut p = Command::new(&args[0])\n+                        .stdout(Stdio::piped())\n+                        .stdin(Stdio::piped())\n+                        .arg(\"testrust\").spawn().unwrap();\n+    assert!(!p.wait().unwrap().success());\n }", "previous_filename": "src/test/ui/abi/abort-on-c-abi.rs"}]}