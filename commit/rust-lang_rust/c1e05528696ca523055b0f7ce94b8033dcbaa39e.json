{"sha": "c1e05528696ca523055b0f7ce94b8033dcbaa39e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZTA1NTI4Njk2Y2E1MjMwNTViMGY3Y2U5NGI4MDMzZGNiYWEzOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T23:35:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T23:35:09Z"}, "message": "Auto merge of #71807 - Dylan-DPC:rollup-jvb8sd9, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #69274 (Implement RFC 2396: `#[target_feature]` 1.1)\n - #71767 (doc: make Stack and StackElement a little pretty)\n - #71772 (Mark query function as must_use.)\n - #71777 (cleanup: `config::CrateType` -> `CrateType`)\n - #71784 (Remove recommendation for unmaintained dirs crate)\n - #71785 (Update comment regarding SO_REUSEADDR on Windows)\n - #71787 (fix rustdoc warnings)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5ef41fa793e67902ae17dfc43fb52756b5000cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ef41fa793e67902ae17dfc43fb52756b5000cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1e05528696ca523055b0f7ce94b8033dcbaa39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e05528696ca523055b0f7ce94b8033dcbaa39e", "html_url": "https://github.com/rust-lang/rust/commit/c1e05528696ca523055b0f7ce94b8033dcbaa39e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1e05528696ca523055b0f7ce94b8033dcbaa39e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05a5240440b3eaef1684a7965860fab40301947", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a5240440b3eaef1684a7965860fab40301947", "html_url": "https://github.com/rust-lang/rust/commit/f05a5240440b3eaef1684a7965860fab40301947"}, {"sha": "97cf378f543813aeb3a87551915737a136d64aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/97cf378f543813aeb3a87551915737a136d64aec", "html_url": "https://github.com/rust-lang/rust/commit/97cf378f543813aeb3a87551915737a136d64aec"}], "stats": {"total": 544, "additions": 271, "deletions": 273}, "files": [{"sha": "23980a2db8d42febcd21a78d7212cdf3becb077b", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -98,7 +98,7 @@ pub enum Ty<'a> {\n     Self_,\n     /// &/Box/ Ty\n     Ptr(Box<Ty<'a>>, PtrTy),\n-    /// mod::mod::Type<[lifetime], [Params...]>, including a plain type\n+    /// `mod::mod::Type<[lifetime], [Params...]>`, including a plain type\n     /// parameter, and things like `i32`\n     Literal(Path<'a>),\n     /// includes unit"}, {"sha": "fa5993471c44a5ae17a30fcd95610b981190af6c", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -233,6 +233,7 @@ fn generate_test_harness(\n ///\n /// By default this expands to\n ///\n+/// ```\n /// #[main]\n /// pub fn main() {\n ///     extern crate test;\n@@ -242,6 +243,7 @@ fn generate_test_harness(\n ///         &test_const3,\n ///     ]);\n /// }\n+/// ```\n ///\n /// Most of the Ident have the usual def-site hygiene for the AST pass. The\n /// exception is the `test_const`s. These have a syntax context that has two"}, {"sha": "d3e3441b087c21e61ecba2d044f802e4ef7d36eb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::bug;\n use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{self, Lto};\n+use rustc_session::config::{self, CrateType, Lto};\n \n use std::ffi::{CStr, CString};\n use std::fs::File;\n@@ -33,13 +33,10 @@ use std::sync::Arc;\n /// compilation session.\n pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-imports.bin\";\n \n-pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n+pub fn crate_type_allows_lto(crate_type: CrateType) -> bool {\n     match crate_type {\n-        config::CrateType::Executable\n-        | config::CrateType::Staticlib\n-        | config::CrateType::Cdylib => true,\n-\n-        config::CrateType::Dylib | config::CrateType::Rlib | config::CrateType::ProcMacro => false,\n+        CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => true,\n+        CrateType::Dylib | CrateType::Rlib | CrateType::ProcMacro => false,\n     }\n }\n "}, {"sha": "01f90cae7a5fcb23539cfe8d271b97d38e834668", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutError, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n-use rustc_session::config::{self, CFGuard, DebugInfo};\n+use rustc_session::config::{CFGuard, CrateType, DebugInfo};\n use rustc_session::Session;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::Symbol;\n@@ -49,12 +49,13 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub const_cstr_cache: RefCell<FxHashMap<Symbol, &'ll Value>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n-    /// Key is a Value holding a *T,\n-    /// Val is a Value holding a *[T].\n+    ///\n+    /// Key is a Value holding a `*T`,\n+    /// Val is a Value holding a `*[T]`.\n     ///\n     /// Needed because LLVM loses pointer->pointee association\n     /// when we ptrcast, and we have to ptrcast during codegen\n-    /// of a [T] const because we form a slice, a (*T,usize) pair, not\n+    /// of a `[T]` const because we form a slice, a `(*T,usize)` pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n     pub const_unsized: RefCell<FxHashMap<&'ll Value, &'ll Value>>,\n \n@@ -101,9 +102,10 @@ fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n /// If the list of crate types is not yet known we conservatively return `false`.\n pub fn all_outputs_are_pic_executables(sess: &Session) -> bool {\n     sess.relocation_model() == RelocModel::Pic\n-        && sess.crate_types.try_get().map_or(false, |crate_types| {\n-            crate_types.iter().all(|ty| *ty == config::CrateType::Executable)\n-        })\n+        && sess\n+            .crate_types\n+            .try_get()\n+            .map_or(false, |crate_types| crate_types.iter().all(|ty| *ty == CrateType::Executable))\n }\n \n fn strip_function_ptr_alignment(data_layout: String) -> String {"}, {"sha": "7a0e1e2c63887f63e901bb423f099e473d5a28a6", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -3,9 +3,8 @@ use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n use rustc_middle::middle::dependency_format::Linkage;\n-use rustc_session::config::{\n-    self, CFGuard, DebugInfo, OutputFilenames, OutputType, PrintRequest, Sanitizer,\n-};\n+use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, Sanitizer};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n /// For all the linkers we support, and information they might\n@@ -55,7 +54,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen())\n             && !output_metadata\n-            && crate_type == config::CrateType::Executable\n+            && crate_type == CrateType::Executable\n         {\n             continue;\n         }\n@@ -82,7 +81,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         if outputs.outputs.should_codegen() {\n             let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n             match crate_type {\n-                config::CrateType::Rlib => {\n+                CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n                     link_rlib::<B>(\n                         sess,\n@@ -93,7 +92,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                     )\n                     .build();\n                 }\n-                config::CrateType::Staticlib => {\n+                CrateType::Staticlib => {\n                     link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n                 }\n                 _ => {\n@@ -236,10 +235,10 @@ pub fn each_linked_rlib(\n     let mut fmts = None;\n     for (ty, list) in info.dependency_formats.iter() {\n         match ty {\n-            config::CrateType::Executable\n-            | config::CrateType::Staticlib\n-            | config::CrateType::Cdylib\n-            | config::CrateType::ProcMacro => {\n+            CrateType::Executable\n+            | CrateType::Staticlib\n+            | CrateType::Cdylib\n+            | CrateType::ProcMacro => {\n                 fmts = Some(list);\n                 break;\n             }\n@@ -461,7 +460,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n // links to all upstream files as well.\n fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n@@ -664,13 +663,13 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n-fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker: &mut dyn Linker) {\n+fn link_sanitizer_runtime(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {\n     let sanitizer = match &sess.opts.debugging_opts.sanitizer {\n         Some(s) => s,\n         None => return,\n     };\n \n-    if crate_type != config::CrateType::Executable {\n+    if crate_type != CrateType::Executable {\n         return;\n     }\n \n@@ -826,7 +825,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n         .crate_types\n         .borrow()\n         .iter()\n-        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n+        .any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n     if !output_linked {\n         return false;\n     }\n@@ -1132,8 +1131,8 @@ fn exec_linker(\n }\n \n /// Add begin object files defined by the target spec.\n-fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: CrateType) {\n+    let pre_link_objects = if crate_type == CrateType::Executable {\n         &sess.target.target.options.pre_link_objects_exe\n     } else {\n         &sess.target.target.options.pre_link_objects_dll\n@@ -1142,15 +1141,15 @@ fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config\n         cmd.add_object(&get_object_file_path(sess, obj));\n     }\n \n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+    if crate_type == CrateType::Executable && sess.crt_static(Some(crate_type)) {\n         for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n             cmd.add_object(&get_object_file_path(sess, obj));\n         }\n     }\n }\n \n /// Add end object files defined by the target spec.\n-fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n+fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: CrateType) {\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.add_object(&get_object_file_path(sess, obj));\n     }\n@@ -1167,7 +1166,7 @@ fn add_pre_link_args(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     flavor: LinkerFlavor,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n ) {\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n@@ -1197,13 +1196,13 @@ fn add_late_link_args(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     flavor: LinkerFlavor,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n-    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n+    let any_dynamic_crate = crate_type == CrateType::Dylib\n         || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n             *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n         });\n@@ -1243,13 +1242,13 @@ fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &Cod\n /// Add object files containing metadata for the current crate.\n fn add_local_crate_metadata_objects(\n     cmd: &mut dyn Linker,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n-    if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n+    if crate_type == CrateType::Dylib || crate_type == CrateType::ProcMacro {\n         if let Some(obj) = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref())\n         {\n             cmd.add_object(obj);\n@@ -1263,7 +1262,7 @@ fn add_local_crate_metadata_objects(\n fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'a>>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n ) {\n@@ -1326,10 +1325,10 @@ fn add_position_independent_executable_args(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     flavor: LinkerFlavor,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n-    if crate_type != config::CrateType::Executable {\n+    if crate_type != CrateType::Executable {\n         return;\n     }\n \n@@ -1407,7 +1406,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     path: &Path,\n     flavor: LinkerFlavor,\n     sess: &'a Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     tmpdir: &Path,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n@@ -1463,7 +1462,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.output_filename(out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if crate_type == config::CrateType::Executable && sess.target.target.options.is_like_windows {\n+    if crate_type == CrateType::Executable && sess.target.target.options.is_like_windows {\n         if let Some(ref s) = codegen_results.windows_subsystem {\n             cmd.subsystem(s);\n         }\n@@ -1486,7 +1485,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n     if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        let keep_metadata = crate_type == CrateType::Dylib;\n         cmd.gc_sections(keep_metadata);\n     }\n \n@@ -1522,10 +1521,10 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     // Tell the linker what we're doing.\n-    if crate_type != config::CrateType::Executable {\n+    if crate_type != CrateType::Executable {\n         cmd.build_dylib(out_filename);\n     }\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+    if crate_type == CrateType::Executable && sess.crt_static(Some(crate_type)) {\n         cmd.build_static_executable();\n     }\n \n@@ -1619,7 +1618,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     tmpdir: &Path,\n ) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1780,7 +1779,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         sess: &'a Session,\n         codegen_results: &CodegenResults,\n         tmpdir: &Path,\n-        crate_type: config::CrateType,\n+        crate_type: CrateType,\n         cnum: CrateNum,\n     ) {\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n@@ -1796,7 +1795,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n \n         if (!are_upstream_rust_objects_already_included(sess)\n             || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && crate_type != config::CrateType::Dylib\n+            && crate_type != CrateType::Dylib\n             && !skip_native\n         {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1857,7 +1856,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             // Note, though, that we don't want to include the whole of a\n             // compiler-builtins crate (e.g., compiler-rt) because it'll get\n             // repeatedly linked anyway.\n-            if crate_type == config::CrateType::Dylib\n+            if crate_type == CrateType::Dylib\n                 && codegen_results.crate_info.compiler_builtins != Some(cnum)\n             {\n                 cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n@@ -1905,7 +1904,7 @@ fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n ) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,"}, {"sha": "c0272e1cd2d6ba205f616904ce306e4f57c40443", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -15,23 +15,22 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{SymbolName, TyCtxt};\n-use rustc_session::config::{self, Sanitizer};\n+use rustc_session::config::{CrateType, Sanitizer};\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n-fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n+fn crate_export_threshold(crate_type: CrateType) -> SymbolExportLevel {\n     match crate_type {\n-        config::CrateType::Executable\n-        | config::CrateType::Staticlib\n-        | config::CrateType::ProcMacro\n-        | config::CrateType::Cdylib => SymbolExportLevel::C,\n-        config::CrateType::Rlib | config::CrateType::Dylib => SymbolExportLevel::Rust,\n+        CrateType::Executable | CrateType::Staticlib | CrateType::ProcMacro | CrateType::Cdylib => {\n+            SymbolExportLevel::C\n+        }\n+        CrateType::Rlib | CrateType::Dylib => SymbolExportLevel::Rust,\n     }\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExportLevel {\n+pub fn crates_export_threshold(crate_types: &[CrateType]) -> SymbolExportLevel {\n     if crate_types\n         .iter()\n         .any(|&crate_type| crate_export_threshold(crate_type) == SymbolExportLevel::Rust)\n@@ -213,7 +212,7 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n-    if tcx.sess.crate_types.borrow().contains(&config::CrateType::Dylib) {\n+    if tcx.sess.crate_types.borrow().contains(&CrateType::Dylib) {\n         let symbol_name = metadata_symbol_name(tcx);\n         let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n "}, {"sha": "c53fc5551fdfb5f20d6f93e2b69ec5ea773b6b84", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -28,9 +28,8 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n-use rustc_session::config::{\n-    self, Lto, OutputFilenames, OutputType, Passes, Sanitizer, SwitchWithOptPath,\n-};\n+use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n+use rustc_session::config::{Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::SourceMap;\n@@ -288,7 +287,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub fewer_names: bool,\n     pub exported_symbols: Option<Arc<ExportedSymbols>>,\n     pub opts: Arc<config::Options>,\n-    pub crate_types: Vec<config::CrateType>,\n+    pub crate_types: Vec<CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n     pub output_filenames: Arc<OutputFilenames>,\n     pub regular_module_config: Arc<ModuleConfig>,\n@@ -375,7 +374,7 @@ pub struct CompiledModules {\n \n fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.cg.embed_bitcode\n-        && sess.crate_types.borrow().contains(&config::CrateType::Rlib)\n+        && sess.crate_types.borrow().contains(&CrateType::Rlib)\n         && sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n@@ -760,7 +759,7 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     // require LTO so the request for LTO is always unconditionally\n     // passed down to the backend, but we don't actually want to do\n     // anything about it yet until we've got a final product.\n-    let is_rlib = cgcx.crate_types.len() == 1 && cgcx.crate_types[0] == config::CrateType::Rlib;\n+    let is_rlib = cgcx.crate_types.len() == 1 && cgcx.crate_types[0] == CrateType::Rlib;\n \n     // Metadata modules never participate in LTO regardless of the lto\n     // settings.\n@@ -1813,7 +1812,7 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     );\n \n     tcx.sess.target.target.options.is_like_msvc &&\n-        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateType::Rlib) &&\n+        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n     // dynamic linking when linker plugin LTO is enabled."}, {"sha": "c5b95905ea01246616986b52582e442668ba1622", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -539,7 +539,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // unnecessarily.\n     if tcx.dep_graph.is_fully_enabled() {\n         for cgu in codegen_units {\n-            tcx.codegen_unit(cgu.name());\n+            tcx.ensure().codegen_unit(cgu.name());\n         }\n     }\n "}, {"sha": "690aacd20566b627d8ed5ec7eb1f24b0f4802e31", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -31,7 +31,7 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     /// Use this function when you intend to define a global. This function will\n     /// return `None` if the name already has a definition associated with it. In that\n     /// case an error should be reported to the user, because it usually happens due\n-    /// to user\u2019s fault (e.g., misuse of #[no_mangle] or #[export_name] attributes).\n+    /// to user\u2019s fault (e.g., misuse of `#[no_mangle]` or `#[export_name]` attributes).\n     fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n \n     /// Declare a private global"}, {"sha": "197169b7036e020eeff83ead4d06b27904a7ff03", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -173,7 +173,7 @@ struct Node<O> {\n     /// must all be in a non-pending state.\n     dependents: Vec<usize>,\n \n-    /// If true, dependents[0] points to a \"parent\" node, which requires\n+    /// If true, `dependents[0]` points to a \"parent\" node, which requires\n     /// special treatment upon error but is otherwise treated the same.\n     /// (It would be more idiomatic to store the parent node in a separate\n     /// `Option<usize>` field, but that slows down the common case of"}, {"sha": "de503fe8228aaa87d004b5bf4cfed82e49a63108", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -289,7 +289,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     ///\n     /// - A != B\n     /// - A R B is true\n-    /// - for each i, j: B[i] R B[j] does not hold\n+    /// - for each i, j: `B[i]` R `B[j]` does not hold\n     ///\n     /// The intuition is that this moves \"one step up\" through a lattice\n     /// (where the relation is encoding the `<=` relation for the lattice)."}, {"sha": "a0b19f61906ed93235a797791890e146ef25cdcc", "filename": "src/librustc_hir/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_hir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_hir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Farena.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -5,8 +5,8 @@\n /// Leaving `few` out will cause the type to get its own dedicated `TypedArena` which is\n /// faster and more memory efficient if there is lots of allocations.\n ///\n-/// Specifying the `decode` modifier will add decode impls for &T and &[T] where T is the type\n-/// listed. These impls will appear in the implement_ty_decoder! macro.\n+/// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]`,\n+/// where `T` is the type listed. These impls will appear in the implement_ty_decoder! macro.\n #[macro_export]\n macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => ("}, {"sha": "50e97c8fb7a0236c538a33ce51ea62aee23ed754", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -843,7 +843,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// For the following code:\n     ///\n-    /// ```norun\n+    /// ```no_run\n     /// let x: Foo<Bar<Qux>> = foo::<Bar<Qux>>();\n     /// ```\n     ///"}, {"sha": "54f80e8f3881208c96190f1332d2185772e683a9", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1482,7 +1482,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n     }\n \n-    /// See the [`region_constraints::verify_generic_bound`] method.\n+    /// See the [`region_constraints::RegionConstraintCollector::verify_generic_bound`] method.\n     pub fn verify_generic_bound(\n         &self,\n         origin: SubregionOrigin<'tcx>,"}, {"sha": "2be6ec4481c6be8c0e39120f78cb8041a9b415ef", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -810,7 +810,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         )\n     }\n \n-    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n+    /// See `InferCtxt::region_constraints_added_in_snapshot`.\n     pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n         self.undo_log[mark.length..]\n             .iter()"}, {"sha": "801c8e9329b24571a98746c3037ae92af449029f", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -27,9 +27,7 @@ use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n use rustc_resolve::{Resolver, ResolverArenas};\n-use rustc_session::config::{\n-    self, CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode,\n-};\n+use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n@@ -361,7 +359,7 @@ fn configure_and_expand_inner<'a>(\n     });\n \n     let crate_types = sess.crate_types.borrow();\n-    let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n+    let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n \n     // For backwards compatibility, we don't try to run proc macro injection\n     // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being"}, {"sha": "c5a4d28d151b3b3173a3ed7b52556dea077a6d5d", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -16,11 +16,12 @@ use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc_middle::ty;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n+use rustc_session::config::{self, CrateType};\n use rustc_session::config::{ErrorOutputType, Input, OutputFilenames};\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::CrateDisambiguator;\n-use rustc_session::{config, early_error, filesearch, output, DiagnosticOutput, Session};\n+use rustc_session::{early_error, filesearch, output, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, SourceMap};\n use rustc_span::symbol::{sym, Symbol};\n@@ -409,7 +410,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n \n     // Also incorporate crate type, so that we don't get symbol conflicts when\n     // linking against a library of the same name, if this is an executable.\n-    let is_exe = session.crate_types.borrow().contains(&config::CrateType::Executable);\n+    let is_exe = session.crate_types.borrow().contains(&CrateType::Executable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n@@ -457,23 +458,23 @@ pub(crate) fn check_attr_crate_type(attrs: &[ast::Attribute], lint_buffer: &mut\n     }\n }\n \n-const CRATE_TYPES: &[(Symbol, config::CrateType)] = &[\n-    (sym::rlib, config::CrateType::Rlib),\n-    (sym::dylib, config::CrateType::Dylib),\n-    (sym::cdylib, config::CrateType::Cdylib),\n+const CRATE_TYPES: &[(Symbol, CrateType)] = &[\n+    (sym::rlib, CrateType::Rlib),\n+    (sym::dylib, CrateType::Dylib),\n+    (sym::cdylib, CrateType::Cdylib),\n     (sym::lib, config::default_lib_output()),\n-    (sym::staticlib, config::CrateType::Staticlib),\n-    (sym::proc_dash_macro, config::CrateType::ProcMacro),\n-    (sym::bin, config::CrateType::Executable),\n+    (sym::staticlib, CrateType::Staticlib),\n+    (sym::proc_dash_macro, CrateType::ProcMacro),\n+    (sym::bin, CrateType::Executable),\n ];\n \n-fn categorize_crate_type(s: Symbol) -> Option<config::CrateType> {\n+fn categorize_crate_type(s: Symbol) -> Option<CrateType> {\n     Some(CRATE_TYPES.iter().find(|(key, _)| *key == s)?.1)\n }\n \n-pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n+pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<CrateType> {\n     // Unconditionally collect crate types from attributes to make them used\n-    let attr_types: Vec<config::CrateType> = attrs\n+    let attr_types: Vec<CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n             if a.check_name(sym::crate_type) {\n@@ -490,7 +491,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return vec![config::CrateType::Executable];\n+        return vec![CrateType::Executable];\n     }\n \n     // Only check command line flags if present. If no types are specified by"}, {"sha": "12f4cd33689e650d882c054ba87d79ea09eeb7df", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -103,8 +103,8 @@ impl<'s> LintLevelsBuilder<'s> {\n     /// * It'll validate all lint-related attributes in `attrs`\n     /// * It'll mark all lint-related attributes as used\n     /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n-    ///   #[allow]\n+    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n+    ///   `#[allow]`\n     ///\n     /// Don't forget to call `pop`!\n     pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {"}, {"sha": "a9e7a9f35dc365b9277bc57810c5391378fffc7e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::middle::cstore::{\n     CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n };\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n+use rustc_session::config::{self, CrateType};\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{CrateDisambiguator, Session};\n@@ -615,8 +615,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n-        let any_non_rlib =\n-            self.sess.crate_types.borrow().iter().any(|ct| *ct != config::CrateType::Rlib);\n+        let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| *ct != CrateType::Rlib);\n         if !any_non_rlib {\n             info!(\"panic runtime injection skipped, only generating rlib\");\n             return;\n@@ -736,7 +735,7 @@ impl<'a> CrateLoader<'a> {\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n         let all_rlib = self.sess.crate_types.borrow().iter().all(|ct| match *ct {\n-            config::CrateType::Rlib => true,\n+            CrateType::Rlib => true,\n             _ => false,\n         });\n         if all_rlib {"}, {"sha": "0876cd1e638357f6fdd592bcc612fa7cd69de12b", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -59,7 +59,7 @@ use rustc_middle::middle::cstore::LinkagePreference::{self, RequireDynamic, Requ\n use rustc_middle::middle::cstore::{self, DepKind};\n use rustc_middle::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n use rustc_target::spec::PanicStrategy;\n \n crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n@@ -75,7 +75,7 @@ crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n         .collect::<Vec<_>>()\n }\n \n-fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n+fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n     let sess = &tcx.sess;\n \n     if !sess.opts.output_types.should_codegen() {\n@@ -90,29 +90,25 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n         // Treat cdylibs similarly. If `-C prefer-dynamic` is set, the caller may\n         // be code-size conscious, but without it, it makes sense to statically\n         // link a cdylib.\n-        config::CrateType::Dylib | config::CrateType::Cdylib if !sess.opts.cg.prefer_dynamic => {\n-            Linkage::Static\n-        }\n-        config::CrateType::Dylib | config::CrateType::Cdylib => Linkage::Dynamic,\n+        CrateType::Dylib | CrateType::Cdylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n+        CrateType::Dylib | CrateType::Cdylib => Linkage::Dynamic,\n \n         // If the global prefer_dynamic switch is turned off, or the final\n         // executable will be statically linked, prefer static crate linkage.\n-        config::CrateType::Executable\n-            if !sess.opts.cg.prefer_dynamic || sess.crt_static(Some(ty)) =>\n-        {\n+        CrateType::Executable if !sess.opts.cg.prefer_dynamic || sess.crt_static(Some(ty)) => {\n             Linkage::Static\n         }\n-        config::CrateType::Executable => Linkage::Dynamic,\n+        CrateType::Executable => Linkage::Dynamic,\n \n         // proc-macro crates are mostly cdylibs, but we also need metadata.\n-        config::CrateType::ProcMacro => Linkage::Static,\n+        CrateType::ProcMacro => Linkage::Static,\n \n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n-        config::CrateType::Rlib => Linkage::NotLinked,\n+        CrateType::Rlib => Linkage::NotLinked,\n \n         // staticlibs must have all static dependencies.\n-        config::CrateType::Staticlib => Linkage::Static,\n+        CrateType::Staticlib => Linkage::Static,\n     };\n \n     if preferred_linkage == Linkage::NotLinked {\n@@ -129,8 +125,8 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n \n         // Staticlibs and static executables must have all static dependencies.\n         // If any are not found, generate some nice pretty errors.\n-        if ty == config::CrateType::Staticlib\n-            || (ty == config::CrateType::Executable\n+        if ty == CrateType::Staticlib\n+            || (ty == CrateType::Executable\n                 && sess.crt_static(Some(ty))\n                 && !sess.target.target.options.crt_static_allows_dylibs)\n         {"}, {"sha": "f78f3c5d8d40f45fd44782f15964195dafac0163", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -220,9 +220,10 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_middle::middle::cstore::{CrateSource, MetadataLoader};\n+use rustc_session::config::{self, CrateType};\n use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n use rustc_session::search_paths::PathKind;\n-use rustc_session::{config, CrateDisambiguator, Session};\n+use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n@@ -669,7 +670,7 @@ impl<'a> CrateLocator<'a> {\n \n         // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n         // legal and produces both inside this type.\n-        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == config::CrateType::Rlib);\n+        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == CrateType::Rlib);\n         let needs_object_code = self.sess.opts.output_types.should_codegen();\n         // If we're producing an rlib, then we don't need object code.\n         // Or, if we're not producing object code, then we don't need it either"}, {"sha": "4ac2092bb069aad8febb0ccb81e2c27335d669a7", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n-use rustc_session::config::{self, CrateType};\n+use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n@@ -1499,7 +1499,7 @@ impl EncodeContext<'tcx> {\n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n         let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n         for (ty, arr) in formats.iter() {\n-            if *ty != config::CrateType::Dylib {\n+            if *ty != CrateType::Dylib {\n                 continue;\n             }\n             return self.lazy(arr.iter().map(|slot| match *slot {\n@@ -1729,8 +1729,8 @@ struct PrefetchVisitor<'tcx> {\n impl<'tcx> PrefetchVisitor<'tcx> {\n     fn prefetch_mir(&self, def_id: LocalDefId) {\n         if self.mir_keys.contains(&def_id) {\n-            self.tcx.optimized_mir(def_id);\n-            self.tcx.promoted_mir(def_id);\n+            self.tcx.ensure().optimized_mir(def_id);\n+            self.tcx.ensure().promoted_mir(def_id);\n         }\n     }\n }"}, {"sha": "96ef4b3741200984fdad9f6050dc640909aff26d", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -5,7 +5,7 @@\n /// Leaving `few` out will cause the type to get its own dedicated `TypedArena` which is\n /// faster and more memory efficient if there is lots of allocations.\n ///\n-/// Specifying the `decode` modifier will add decode impls for &T and &[T] where T is the type\n+/// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]` where `T` is the type\n /// listed. These impls will appear in the implement_ty_decoder! macro.\n #[macro_export]\n macro_rules! arena_types {"}, {"sha": "16ce315368a05d139330346b3b894ee8529d07b9", "filename": "src/librustc_middle/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -4,7 +4,7 @@\n //! For all the gory details, see the provider of the `dependency_formats`\n //! query.\n \n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -17,7 +17,7 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = Vec<(config::CrateType, DependencyList)>;\n+pub type Dependencies = Vec<(CrateType, DependencyList)>;\n \n #[derive(Copy, Clone, PartialEq, Debug, HashStable, RustcEncodable, RustcDecodable)]\n pub enum Linkage {"}, {"sha": "8d416536155acc6d4c0368f74365a9f14e41aae7", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -158,10 +158,10 @@ pub struct Body<'tcx> {\n     /// We hold in this field all the constants we are not able to evaluate yet.\n     pub required_consts: Vec<Constant<'tcx>>,\n \n-    /// The user may be writing e.g. &[(SOME_CELL, 42)][i].1 and this would get promoted, because\n+    /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n     /// we'd statically know that no thing with interior mutability will ever be available to the\n     /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// &[(SOME_CELL, 42)] and the MIR using it will do the &promoted[i].1 projection because the\n+    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because the\n     /// index may be a runtime value. Such a promoted value is illegal because it has reachable\n     /// interior mutability. This flag just makes this situation very obvious where the previous\n     /// implementation without the flag hid this situation silently.\n@@ -2124,7 +2124,7 @@ pub enum Rvalue<'tcx> {\n     /// or when casting a reference to a raw pointer.\n     AddressOf(Mutability, Place<'tcx>),\n \n-    /// length of a [X] or [X;n] value\n+    /// length of a `[X]` or `[X;n]` value\n     Len(Place<'tcx>),\n \n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),"}, {"sha": "63b8d8c8da782812bff15993e4d4dfc5e30ccb9e", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -167,7 +167,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n /// are interesting (for error reporting). Order of variants indicates sort\n /// order of the category, thereby influencing diagnostic output.\n ///\n-/// See also [rustc_mir::borrow_check::nll::constraints].\n+/// See also `rustc_mir::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ConstraintCategory {"}, {"sha": "e43eb01ad96f7edae3fe096a87831fb56985830b", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -54,8 +54,7 @@ use rustc_hir::{HirId, Node, TraitCandidate};\n use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n-use rustc_session::config::CrateType;\n-use rustc_session::config::{BorrowckMode, OutputFilenames};\n+use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;"}, {"sha": "4cdcd5320e7612c1875432343924a3a96cf64ac8", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -70,8 +70,8 @@ impl IntegerExt for Integer {\n     }\n \n     /// Finds the appropriate Integer type and signedness for the given\n-    /// signed discriminant range and #[repr] attribute.\n-    /// N.B.: u128 values above i128::MAX will be treated as signed, but\n+    /// signed discriminant range and `#[repr]` attribute.\n+    /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n     fn repr_discr<'tcx>(\n         tcx: TyCtxt<'tcx>,"}, {"sha": "7064b24240ef6df47c62dead219b19156d30255a", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -2696,7 +2696,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `true` if the impls are the same polarity and the trait either\n-    /// has no items or is annotated #[marker] and prevents item overrides.\n+    /// has no items or is annotated `#[marker]` and prevents item overrides.\n     pub fn impls_are_allowed_to_overlap(\n         self,\n         def_id1: DefId,"}, {"sha": "82ee8ca29fa026cceda4cd94a04318615da5287e", "filename": "src/librustc_middle/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -424,6 +424,7 @@ macro_rules! define_queries_inner {\n \n             $($(#[$attr])*\n             #[inline(always)]\n+            #[must_use]\n             pub fn $name(self, key: query_helper_param_ty!($($K)*))\n                 -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n             {"}, {"sha": "5bc9f6df889c7276ea75c91834680213473d7c27", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -582,8 +582,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///\n     /// This is used when creating error messages like below:\n     ///\n-    /// >  cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n-    /// >  mutable (via `a.u.s.b`) [E0502]\n+    /// ```text\n+    /// cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n+    /// mutable (via `a.u.s.b`) [E0502]\n+    /// ```\n     pub(in crate::borrow_check) fn describe_place_for_conflicting_borrow(\n         &self,\n         first_borrowed_place: Place<'tcx>,"}, {"sha": "a8487be77def3ef6e4a478372cdbfbe431a4ab65", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -641,7 +641,7 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n             }\n             UnsafetyViolationKind::BorrowPacked(lint_hir_id) => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n-                    tcx.unsafe_derive_on_repr_packed(impl_def_id);\n+                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id);\n                 } else {\n                     tcx.struct_span_lint_hir(\n                         SAFE_PACKED_BORROWS,"}, {"sha": "e80da4f756c64abb5750a694f87509226d3ecd4c", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -7,13 +7,15 @@\n //!\n //! The `CleanFakeReadsAndBorrows` \"pass\" is actually implemented as two\n //! traversals (aka visits) of the input MIR. The first traversal,\n-//! [`DeleteAndRecordFakeReads`], deletes the fake reads and finds the\n-//! temporaries read by [`ForMatchGuard`] reads, and [`DeleteFakeBorrows`]\n+//! `DeleteAndRecordFakeReads`, deletes the fake reads and finds the\n+//! temporaries read by [`ForMatchGuard`] reads, and `DeleteFakeBorrows`\n //! deletes the initialization of those temporaries.\n //!\n //! [`AscribeUserType`]: rustc_middle::mir::StatementKind::AscribeUserType\n //! [`Shallow`]: rustc_middle::mir::BorrowKind::Shallow\n //! [`FakeRead`]: rustc_middle::mir::StatementKind::FakeRead\n+//! [`Assign`]: rustc_middle::mir::StatementKind::Assign\n+//! [`ForMatchGuard`]: rustc_middle::mir::FakeReadCause::ForMatchGuard\n //! [`Nop`]: rustc_middle::mir::StatementKind::Nop\n \n use crate::transform::{MirPass, MirSource};"}, {"sha": "de3ae2e961f427b4b242670d5891df04e8929104", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -513,6 +513,8 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n }\n \n /// Pretty-printer for matrices of patterns, example:\n+///\n+/// ```text\n /// +++++++++++++++++++++++++++++\n /// + _     + []                +\n /// +++++++++++++++++++++++++++++"}, {"sha": "b54731d8881d190cf2d39d0ec596e6231948223e", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -77,7 +77,7 @@ impl CheckAttrVisitor<'tcx> {\n         }\n \n         if matches!(target, Target::Fn | Target::Method(_) | Target::ForeignFn) {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n+            self.tcx.ensure().codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n         }\n \n         self.check_repr(attrs, span, target, item, hir_id);\n@@ -390,7 +390,7 @@ impl CheckAttrVisitor<'tcx> {\n             }\n         }\n         if target == Target::Closure {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(expr.hir_id));\n+            self.tcx.ensure().codegen_fn_attrs(self.tcx.hir().local_def_id(expr.hir_id));\n         }\n     }\n "}, {"sha": "d2f1d11256bf21f35a145b947188e91e2eafd444", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -7,8 +7,8 @@ use rustc_hir::{HirId, ImplItem, Item, ItemKind, TraitItem};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::EntryFnType;\n-use rustc_session::{config, Session};\n+use rustc_session::config::{CrateType, EntryFnType};\n+use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -51,8 +51,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let any_exe =\n-        tcx.sess.crate_types.borrow().iter().any(|ty| *ty == config::CrateType::Executable);\n+    let any_exe = tcx.sess.crate_types.borrow().iter().any(|ty| *ty == CrateType::Executable);\n     if !any_exe {\n         // No need to find a main function.\n         return None;"}, {"sha": "7c169d6813282c014ebbfe69c207e7550596c2a0", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs}\n use rustc_middle::middle::privacy;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n use rustc_target::spec::abi::Abi;\n \n // Returns true if the given item must be inlined because it may be\n@@ -375,11 +375,10 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-        *ty == config::CrateType::Rlib\n-            || *ty == config::CrateType::Dylib\n-            || *ty == config::CrateType::ProcMacro\n-    });\n+    let any_library =\n+        tcx.sess.crate_types.borrow().iter().any(|ty| {\n+            *ty == CrateType::Rlib || *ty == CrateType::Dylib || *ty == CrateType::ProcMacro\n+        });\n     let mut reachable_context = ReachableContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),"}, {"sha": "8a581626862a2a94b100ddd1dd52bd032e9e8d61", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::lang_items;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::whitelisted;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -38,12 +38,12 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n     let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| match *kind {\n-        config::CrateType::Dylib\n-        | config::CrateType::ProcMacro\n-        | config::CrateType::Cdylib\n-        | config::CrateType::Executable\n-        | config::CrateType::Staticlib => true,\n-        config::CrateType::Rlib => false,\n+        CrateType::Dylib\n+        | CrateType::ProcMacro\n+        | CrateType::Cdylib\n+        | CrateType::Executable\n+        | CrateType::Staticlib => true,\n+        CrateType::Rlib => false,\n     });\n     if !needs_check {\n         return;"}, {"sha": "450293b991bde075f4025db9e1e4a89fa9e3667a", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1051,7 +1051,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n     /// Suggests a missing `crate::` if that resolves to an correct module.\n     ///\n-    /// ```\n+    /// ```text\n     ///    |\n     /// LL | use foo::Bar;\n     ///    |     ^^^ did you mean `crate::foo`?\n@@ -1147,7 +1147,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Suggests importing a macro from the root of the crate rather than a module within\n     /// the crate.\n     ///\n-    /// ```\n+    /// ```text\n     /// help: a macro with this name exists at the root of the crate\n     ///    |\n     /// LL | use issue_59764::makro;"}, {"sha": "d33eaf5a827db6d41cb896a7a522bfb21751ae90", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -2669,7 +2669,7 @@ impl<'a> Resolver<'a> {\n     /// This function adds a suggestion to change the binding name of a new import that conflicts\n     /// with an existing import.\n     ///\n-    /// ```ignore (diagnostic)\n+    /// ```text,ignore (diagnostic)\n     /// help: you can use `as` to change the binding name of the import\n     ///    |\n     /// LL | use foo::bar as other_bar;"}, {"sha": "52216188397d7eb5d5a07c530bf090d9c67d893a", "filename": "src/librustc_session/output.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_session%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_session%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foutput.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1,5 +1,5 @@\n //! Related to out filenames of compilation (e.g. save analysis, binaries).\n-use crate::config::{self, Input, OutputFilenames, OutputType};\n+use crate::config::{CrateType, Input, OutputFilenames, OutputType};\n use crate::Session;\n use rustc_ast::{ast, attr};\n use rustc_span::symbol::sym;\n@@ -8,7 +8,7 @@ use std::path::{Path, PathBuf};\n \n pub fn out_filename(\n     sess: &Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     outputs: &OutputFilenames,\n     crate_name: &str,\n ) -> PathBuf {\n@@ -146,27 +146,27 @@ pub fn filename_for_metadata(\n \n pub fn filename_for_input(\n     sess: &Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     crate_name: &str,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n     let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n \n     match crate_type {\n-        config::CrateType::Rlib => outputs.out_directory.join(&format!(\"lib{}.rlib\", libname)),\n-        config::CrateType::Cdylib | config::CrateType::ProcMacro | config::CrateType::Dylib => {\n+        CrateType::Rlib => outputs.out_directory.join(&format!(\"lib{}.rlib\", libname)),\n+        CrateType::Cdylib | CrateType::ProcMacro | CrateType::Dylib => {\n             let (prefix, suffix) =\n                 (&sess.target.target.options.dll_prefix, &sess.target.target.options.dll_suffix);\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n-        config::CrateType::Staticlib => {\n+        CrateType::Staticlib => {\n             let (prefix, suffix) = (\n                 &sess.target.target.options.staticlib_prefix,\n                 &sess.target.target.options.staticlib_suffix,\n             );\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n-        config::CrateType::Executable => {\n+        CrateType::Executable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n             let out_filename = outputs.path(OutputType::Exe);\n             if suffix.is_empty() { out_filename } else { out_filename.with_extension(&suffix[1..]) }\n@@ -183,18 +183,18 @@ pub fn filename_for_input(\n /// way to run iOS binaries anyway without jailbreaking and\n /// interaction with Rust code through static library is the only\n /// option for now\n-pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n+pub fn default_output_for_target(sess: &Session) -> CrateType {\n     if !sess.target.target.options.executables {\n-        config::CrateType::Staticlib\n+        CrateType::Staticlib\n     } else {\n-        config::CrateType::Executable\n+        CrateType::Executable\n     }\n }\n \n /// Checks if target supports crate_type as output\n-pub fn invalid_output_for_target(sess: &Session, crate_type: config::CrateType) -> bool {\n+pub fn invalid_output_for_target(sess: &Session, crate_type: CrateType) -> bool {\n     match crate_type {\n-        config::CrateType::Cdylib | config::CrateType::Dylib | config::CrateType::ProcMacro => {\n+        CrateType::Cdylib | CrateType::Dylib | CrateType::ProcMacro => {\n             if !sess.target.target.options.dynamic_linking {\n                 return true;\n             }\n@@ -208,12 +208,12 @@ pub fn invalid_output_for_target(sess: &Session, crate_type: config::CrateType)\n     }\n     if sess.target.target.options.only_cdylib {\n         match crate_type {\n-            config::CrateType::ProcMacro | config::CrateType::Dylib => return true,\n+            CrateType::ProcMacro | CrateType::Dylib => return true,\n             _ => {}\n         }\n     }\n     if !sess.target.target.options.executables {\n-        if crate_type == config::CrateType::Executable {\n+        if crate_type == CrateType::Executable {\n             return true;\n         }\n     }"}, {"sha": "69e1b46de4df75adfdbe791c4ac93f2b5f502534", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1,7 +1,7 @@\n use crate::cgu_reuse_tracker::CguReuseTracker;\n use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n-use crate::config::{self, OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n+use crate::config::{self, CrateType, OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n use crate::filesearch;\n use crate::lint;\n use crate::parse::ParseSess;\n@@ -73,7 +73,7 @@ pub struct Session {\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n-    pub crate_types: Once<Vec<config::CrateType>>,\n+    pub crate_types: Once<Vec<CrateType>>,\n     /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n@@ -552,7 +552,7 @@ impl Session {\n     }\n \n     /// Check whether this compile session and crate type use static crt.\n-    pub fn crt_static(&self, crate_type: Option<config::CrateType>) -> bool {\n+    pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n         // If the target does not opt in to crt-static support, use its default.\n         if self.target.target.options.crt_static_respected {\n             self.crt_static_feature(crate_type)\n@@ -562,15 +562,15 @@ impl Session {\n     }\n \n     /// Check whether this compile session and crate type use `crt-static` feature.\n-    pub fn crt_static_feature(&self, crate_type: Option<config::CrateType>) -> bool {\n+    pub fn crt_static_feature(&self, crate_type: Option<CrateType>) -> bool {\n         let requested_features = self.opts.cg.target_feature.split(',');\n         let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n         let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n \n         if found_positive || found_negative {\n             found_positive\n-        } else if crate_type == Some(config::CrateType::ProcMacro)\n-            || crate_type == None && self.opts.crate_types.contains(&config::CrateType::ProcMacro)\n+        } else if crate_type == Some(CrateType::ProcMacro)\n+            || crate_type == None && self.opts.crate_types.contains(&CrateType::ProcMacro)\n         {\n             // FIXME: When crate_type is not available,\n             // we use compiler options to determine the crate_type."}, {"sha": "23c3dccb130f6ddd5339293b3a06b0a256b4bf89", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -661,7 +661,7 @@ pub struct ExpnData {\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// List of #[unstable]/feature-gated features that the macro is allowed to use\n+    /// List of `#[unstable]`/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n     /// to them.\n     pub allow_internal_unstable: Option<Lrc<[Symbol]>>,"}, {"sha": "f9ff772900bbd53f9ea3ced1530fde3780beeef8", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -327,12 +327,12 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n ///    try to implement this trait-ref. To check for this, we use InCrate::Remote\n ///    mode. That is sound because we already know all the impls from known crates.\n ///\n-/// 3. For non-#[fundamental] traits, they guarantee that parent crates can\n+/// 3. For non-`#[fundamental]` traits, they guarantee that parent crates can\n ///    add \"non-blanket\" impls without breaking negative reasoning in dependent\n ///    crates. This is the \"rebalancing coherence\" (RFC 1023) restriction.\n ///\n ///    For that, we only a allow crate to perform negative reasoning on\n-///    non-local-non-#[fundamental] only if there's a local key parameter as per (2).\n+///    non-local-non-`#[fundamental]` only if there's a local key parameter as per (2).\n ///\n ///    Because we never perform negative reasoning generically (coherence does\n ///    not involve type parameters), this can be interpreted as doing the full"}, {"sha": "c5ead053a7f8950c6abb6f394d29fcdb94f520d2", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -307,7 +307,7 @@ fn instance_def_size_estimate<'tcx>(\n \n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n-/// See [`ImplOverlapKind::Issue33140`] for more details.\n+/// See [`ty::ImplOverlapKind::Issue33140`] for more details.\n fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n "}, {"sha": "c431745198822e260226322ae40002c9c92ee5da", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1748,11 +1748,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n-            tcx.typeck_tables_of(def_id);\n+            tcx.ensure().typeck_tables_of(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.typeck_tables_of(tcx.hir().local_def_id(it.hir_id));\n+            tcx.ensure().typeck_tables_of(tcx.hir().local_def_id(it.hir_id));\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n             check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n@@ -2670,7 +2670,7 @@ pub fn check_enum<'tcx>(\n \n     for v in vs {\n         if let Some(ref e) = v.disr_expr {\n-            tcx.typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n+            tcx.ensure().typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n         }\n     }\n "}, {"sha": "049f4767247c5429d171030d83fdd9ec73677d02", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1105,19 +1105,21 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// itself the referent of a borrowed pointer. Let me give an\n     /// example fragment of code to make clear(er) the situation:\n     ///\n-    ///    let r: &'a mut T = ...;  // the original reference \"r\" has lifetime 'a\n-    ///    ...\n-    ///    &'z *r                   // the reborrow has lifetime 'z\n+    /// ```ignore (incomplete Rust code)\n+    /// let r: &'a mut T = ...;  // the original reference \"r\" has lifetime 'a\n+    /// ...\n+    /// &'z *r                   // the reborrow has lifetime 'z\n+    /// ```\n     ///\n     /// Now, in this case, our primary job is to add the inference\n     /// constraint that `'z <= 'a`. Given this setup, let's clarify the\n     /// parameters in (roughly) terms of the example:\n     ///\n     /// ```plain,ignore (pseudo-Rust)\n-    ///     A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n-    ///     borrow_region   ^~                 ref_region    ^~\n-    ///     borrow_kind        ^~               ref_kind        ^~\n-    ///     ref_cmt                 ^\n+    /// A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n+    /// borrow_region   ^~                 ref_region    ^~\n+    /// borrow_kind        ^~               ref_kind        ^~\n+    /// ref_cmt                 ^\n     /// ```\n     ///\n     /// Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n@@ -1193,7 +1195,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     ///   a `FnMut` or `Fn` closure.\n     ///\n     /// This function links the lifetimes of those references to the lifetime\n-    /// of the borrow that's provided. See [link_reborrowed_region] for some\n+    /// of the borrow that's provided. See [RegionCtxt::link_reborrowed_region] for some\n     /// more explanation of this in the general case.\n     ///\n     /// We also supply a *cause*, and in this case we set the cause to"}, {"sha": "05d5a81217ce12d9fd8f33351c7f5196cd9eb751", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -156,7 +156,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n     // Trigger building the specialization graph for the trait. This will detect and report any\n     // overlap errors.\n-    tcx.specialization_graph_of(def_id);\n+    tcx.ensure().specialization_graph_of(def_id);\n \n     let impls = tcx.hir().trait_impls(def_id);\n     for &hir_id in impls {"}, {"sha": "f7318e3b9fe2f692da913b26b1f234d5e0212724", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -207,12 +207,12 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n                 hir::GenericParamKind::Type { default: Some(_), .. } => {\n                     let def_id = self.tcx.hir().local_def_id(param.hir_id);\n-                    self.tcx.type_of(def_id);\n+                    self.tcx.ensure().type_of(def_id);\n                 }\n                 hir::GenericParamKind::Type { .. } => {}\n                 hir::GenericParamKind::Const { .. } => {\n                     let def_id = self.tcx.hir().local_def_id(param.hir_id);\n-                    self.tcx.type_of(def_id);\n+                    self.tcx.ensure().type_of(def_id);\n                 }\n             }\n         }\n@@ -222,8 +222,8 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n             let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-            self.tcx.generics_of(def_id);\n-            self.tcx.type_of(def_id);\n+            self.tcx.ensure().generics_of(def_id);\n+            self.tcx.ensure().type_of(def_id);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -635,47 +635,47 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in foreign_mod.items {\n                 let def_id = tcx.hir().local_def_id(item.hir_id);\n-                tcx.generics_of(def_id);\n-                tcx.type_of(def_id);\n-                tcx.predicates_of(def_id);\n+                tcx.ensure().generics_of(def_id);\n+                tcx.ensure().type_of(def_id);\n+                tcx.ensure().predicates_of(def_id);\n                 if let hir::ForeignItemKind::Fn(..) = item.kind {\n-                    tcx.fn_sig(def_id);\n+                    tcx.ensure().fn_sig(def_id);\n                 }\n             }\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n-            tcx.generics_of(def_id);\n-            tcx.type_of(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id.to_def_id(), &enum_definition.variants);\n         }\n         hir::ItemKind::Impl { .. } => {\n-            tcx.generics_of(def_id);\n-            tcx.type_of(def_id);\n-            tcx.impl_trait_ref(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().impl_trait_ref(def_id);\n+            tcx.ensure().predicates_of(def_id);\n         }\n         hir::ItemKind::Trait(..) => {\n-            tcx.generics_of(def_id);\n-            tcx.trait_def(def_id);\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().trait_def(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n         }\n         hir::ItemKind::TraitAlias(..) => {\n-            tcx.generics_of(def_id);\n+            tcx.ensure().generics_of(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n         }\n         hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-            tcx.generics_of(def_id);\n-            tcx.type_of(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n \n             for f in struct_def.fields() {\n                 let def_id = tcx.hir().local_def_id(f.hir_id);\n-                tcx.generics_of(def_id);\n-                tcx.type_of(def_id);\n-                tcx.predicates_of(def_id);\n+                tcx.ensure().generics_of(def_id);\n+                tcx.ensure().type_of(def_id);\n+                tcx.ensure().predicates_of(def_id);\n             }\n \n             if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n@@ -691,11 +691,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         | hir::ItemKind::Static(..)\n         | hir::ItemKind::Const(..)\n         | hir::ItemKind::Fn(..) => {\n-            tcx.generics_of(def_id);\n-            tcx.type_of(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n             if let hir::ItemKind::Fn(..) = it.kind {\n-                tcx.fn_sig(def_id);\n+                tcx.ensure().fn_sig(def_id);\n             }\n         }\n     }\n@@ -704,20 +704,20 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n     let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n     let def_id = tcx.hir().local_def_id(trait_item.hir_id);\n-    tcx.generics_of(def_id);\n+    tcx.ensure().generics_of(def_id);\n \n     match trait_item.kind {\n         hir::TraitItemKind::Fn(..) => {\n-            tcx.type_of(def_id);\n-            tcx.fn_sig(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().fn_sig(def_id);\n         }\n \n         hir::TraitItemKind::Const(.., Some(_)) => {\n-            tcx.type_of(def_id);\n+            tcx.ensure().type_of(def_id);\n         }\n \n         hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(_, Some(_)) => {\n-            tcx.type_of(def_id);\n+            tcx.ensure().type_of(def_id);\n             // Account for `const C: _;` and `type T = _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n@@ -727,18 +727,18 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n         hir::TraitItemKind::Type(_, None) => {}\n     };\n \n-    tcx.predicates_of(def_id);\n+    tcx.ensure().predicates_of(def_id);\n }\n \n fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id(impl_item_id);\n-    tcx.generics_of(def_id);\n-    tcx.type_of(def_id);\n-    tcx.predicates_of(def_id);\n+    tcx.ensure().generics_of(def_id);\n+    tcx.ensure().type_of(def_id);\n+    tcx.ensure().predicates_of(def_id);\n     let impl_item = tcx.hir().expect_impl_item(impl_item_id);\n     match impl_item.kind {\n         hir::ImplItemKind::Fn(..) => {\n-            tcx.fn_sig(def_id);\n+            tcx.ensure().fn_sig(def_id);\n         }\n         hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => {\n             // Account for `type T = _;`\n@@ -752,9 +752,9 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n \n fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id(ctor_id);\n-    tcx.generics_of(def_id);\n-    tcx.type_of(def_id);\n-    tcx.predicates_of(def_id);\n+    tcx.ensure().generics_of(def_id);\n+    tcx.ensure().type_of(def_id);\n+    tcx.ensure().predicates_of(def_id);\n }\n \n fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n@@ -790,9 +790,9 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::V\n \n         for f in variant.data.fields() {\n             let def_id = tcx.hir().local_def_id(f.hir_id);\n-            tcx.generics_of(def_id);\n-            tcx.type_of(def_id);\n-            tcx.predicates_of(def_id);\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as"}, {"sha": "ffe9f1c7d7a71c38d018ef256d8eb3d45669bb02", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -30,7 +30,7 @@\n //! - `ty`: the type of data found at the address `A`.\n //!\n //! The resulting categorization tree differs somewhat from the expressions\n-//! themselves. For example, auto-derefs are explicit. Also, an index a[b] is\n+//! themselves. For example, auto-derefs are explicit. Also, an index `a[b]` is\n //! decomposed into two operations: a dereference to reach the array data and\n //! then an index to jump forward to the relevant item.\n //!"}, {"sha": "03d1dc21816c320c5e6ebb1b0723a3248d2e427b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast::ast::CRATE_NODE_ID;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::{self, Lrc};\n use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n@@ -13,15 +14,14 @@ use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_resolve as resolve;\n-use rustc_session::config::ErrorOutputType;\n+use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n use rustc_session::DiagnosticOutput;\n-use rustc_session::{config, Session};\n+use rustc_session::Session;\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n \n-use rustc_data_structures::sync::{self, Lrc};\n use std::cell::RefCell;\n use std::mem;\n use std::rc::Rc;\n@@ -30,7 +30,6 @@ use crate::clean;\n use crate::clean::{AttributesExt, MAX_DEF_ID};\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::html::render::RenderInfo;\n-\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n@@ -301,11 +300,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         })\n         .collect();\n \n-    let crate_types = if proc_macro_crate {\n-        vec![config::CrateType::ProcMacro]\n-    } else {\n-        vec![config::CrateType::Rlib]\n-    };\n+    let crate_types =\n+        if proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };\n     // plays with error output here!\n     let sessopts = config::Options {\n         maybe_sysroot,"}, {"sha": "721988e29a67867bc750b59bb3ffa9846bb634bb", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -5,7 +5,7 @@\n pub struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n-    /// entries[0].level >= entries[1].level >= ...\n+    /// `entries[0].level >= entries[1].level >= ...`\n     ///\n     /// Normally they are equal, but can differ in cases like A and B,\n     /// both of which end up in the same `Toc` as they have the same\n@@ -39,8 +39,8 @@ pub struct TocEntry {\n pub struct TocBuilder {\n     top_level: Toc,\n     /// The current hierarchy of parent headings, the levels are\n-    /// strictly increasing (i.e., chain[0].level < chain[1].level <\n-    /// ...) with each entry being the most recent occurrence of a\n+    /// strictly increasing (i.e., `chain[0].level < chain[1].level <\n+    /// ...`) with each entry being the most recent occurrence of a\n     /// heading with that level (it doesn't include the most recent\n     /// occurrences of every level, just, if it *is* in `chain` then\n     /// it is the most recent one)."}, {"sha": "5028bb46b006695dfd051cd0c4bd5b5c3182238d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -9,20 +9,22 @@ use rustc_hir::{HirId, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::{self, config, lint, DiagnosticOutput, Session};\n+use rustc_session::config::{self, CrateType};\n+use rustc_session::{lint, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, FileName, Pos, Span, DUMMY_SP};\n use rustc_target::spec::TargetTriple;\n+use tempfile::Builder as TempFileBuilder;\n+\n use std::collections::HashMap;\n use std::env;\n use std::io::{self, Write};\n use std::panic;\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use tempfile::Builder as TempFileBuilder;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n@@ -82,11 +84,8 @@ pub fn run(options: Options) -> i32 {\n         })\n         .collect();\n \n-    let crate_types = if options.proc_macro_crate {\n-        vec![config::CrateType::ProcMacro]\n-    } else {\n-        vec![config::CrateType::Rlib]\n-    };\n+    let crate_types =\n+        if options.proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };\n \n     let sessopts = config::Options {\n         maybe_sysroot: options.maybe_sysroot.clone(),"}, {"sha": "8f46649048aa991d7aab67b1b11d2c3e0447a92b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -1417,16 +1417,18 @@ enum ParserState {\n \n /// A Stack represents the current position of the parser in the logical\n /// structure of the JSON stream.\n-/// For example foo.bar[3].x\n+///\n+/// An example is `foo.bar[3].x`.\n pub struct Stack {\n     stack: Vec<InternalStackElement>,\n     str_buffer: Vec<u8>,\n }\n \n /// StackElements compose a Stack.\n-/// For example, StackElement::Key(\"foo\"), StackElement::Key(\"bar\"),\n-/// StackElement::Index(3) and StackElement::Key(\"x\") are the\n-/// StackElements compositing the stack that represents foo.bar[3].x\n+///\n+/// As an example, `StackElement::Key(\"foo\")`, `StackElement::Key(\"bar\")`,\n+/// `StackElement::Index(3)`, and `StackElement::Key(\"x\")` are the\n+/// StackElements composing the stack that represents `foo.bar[3].x`.\n #[derive(PartialEq, Clone, Debug)]\n pub enum StackElement<'l> {\n     Index(u32),"}, {"sha": "97c20ca9459ef43d4953bcd19d0aa37547d0faa9", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -567,7 +567,7 @@ impl Error for JoinPathsError {\n #[rustc_deprecated(\n     since = \"1.29.0\",\n     reason = \"This function's behavior is unexpected and probably not what you want. \\\n-              Consider using the home_dir function from https://crates.io/crates/dirs instead.\"\n+              Consider using a crate from crates.io instead.\"\n )]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn home_dir() -> Option<PathBuf> {"}, {"sha": "6115d652b0cea3975ff26d5d60e4d0c92df38d00", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -216,7 +216,6 @@ pub const SOCK_STREAM: c_int = 1;\n pub const SOL_SOCKET: c_int = 0xffff;\n pub const SO_RCVTIMEO: c_int = 0x1006;\n pub const SO_SNDTIMEO: c_int = 0x1005;\n-pub const SO_REUSEADDR: c_int = 0x0004;\n pub const IPPROTO_IP: c_int = 0;\n pub const IPPROTO_TCP: c_int = 6;\n pub const IPPROTO_IPV6: c_int = 41;"}, {"sha": "1c03bc923444873ab5b82249881a02f5a7a1b78b", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e05528696ca523055b0f7ce94b8033dcbaa39e/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=c1e05528696ca523055b0f7ce94b8033dcbaa39e", "patch": "@@ -368,12 +368,15 @@ impl TcpListener {\n \n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n \n-        // On platforms with Berkeley-derived sockets, this allows\n-        // to quickly rebind a socket, without needing to wait for\n-        // the OS to clean up the previous one.\n-        if !cfg!(windows) {\n-            setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR, 1 as c_int)?;\n-        }\n+        // On platforms with Berkeley-derived sockets, this allows to quickly\n+        // rebind a socket, without needing to wait for the OS to clean up the\n+        // previous one.\n+        //\n+        // On Windows, this allows rebinding sockets which are actively in use,\n+        // which allows \u201csocket hijacking\u201d, so we explicitly don't set it here.\n+        // https://docs.microsoft.com/en-us/windows/win32/winsock/using-so-reuseaddr-and-so-exclusiveaddruse\n+        #[cfg(not(windows))]\n+        setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR, 1 as c_int)?;\n \n         // Bind our new socket\n         let (addrp, len) = addr.into_inner();"}]}