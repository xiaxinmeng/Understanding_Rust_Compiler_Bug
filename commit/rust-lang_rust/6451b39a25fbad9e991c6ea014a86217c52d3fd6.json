{"sha": "6451b39a25fbad9e991c6ea014a86217c52d3fd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NTFiMzlhMjVmYmFkOWU5OTFjNmVhMDE0YTg2MjE3YzUyZDNmZDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-09-21T03:52:37Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-10-21T01:43:56Z"}, "message": "rustc_mir: support MIR-inlining #[track_caller] functions.", "tree": {"sha": "531f1ad894352d33f202076d33b006a98e26b4e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/531f1ad894352d33f202076d33b006a98e26b4e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6451b39a25fbad9e991c6ea014a86217c52d3fd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6451b39a25fbad9e991c6ea014a86217c52d3fd6", "html_url": "https://github.com/rust-lang/rust/commit/6451b39a25fbad9e991c6ea014a86217c52d3fd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6451b39a25fbad9e991c6ea014a86217c52d3fd6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb36440b7a0d2444dd079876d4fde6b0ee9d5670", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb36440b7a0d2444dd079876d4fde6b0ee9d5670", "html_url": "https://github.com/rust-lang/rust/commit/fb36440b7a0d2444dd079876d4fde6b0ee9d5670"}], "stats": {"total": 196, "additions": 144, "deletions": 52}, "files": [{"sha": "da4637b1afcfbdaea24f01ec0a6dd657a3407ff4", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -405,7 +405,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n-        let location = self.get_caller_location(&mut bx, span).immediate();\n+        let location = self.get_caller_location(&mut bx, terminator.source_info).immediate();\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n@@ -442,7 +442,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         intrinsic: Option<Symbol>,\n         instance: Option<Instance<'tcx>>,\n-        span: Span,\n+        source_info: mir::SourceInfo,\n         destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n     ) -> bool {\n@@ -484,11 +484,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 });\n                 let msg = bx.const_str(Symbol::intern(&msg_str));\n-                let location = self.get_caller_location(bx, span).immediate();\n+                let location = self.get_caller_location(bx, source_info).immediate();\n \n                 // Obtain the panic entry point.\n                 // FIXME: dedup this with `codegen_assert_terminator` above.\n-                let def_id = common::langcall(bx.tcx(), Some(span), \"\", LangItem::Panic);\n+                let def_id =\n+                    common::langcall(bx.tcx(), Some(source_info.span), \"\", LangItem::Panic);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n@@ -529,7 +530,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         cleanup: Option<mir::BasicBlock>,\n         fn_span: Span,\n     ) {\n-        let span = terminator.source_info.span;\n+        let source_info = terminator.source_info;\n+        let span = source_info.span;\n+\n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n         let callee = self.codegen_operand(&mut bx, func);\n \n@@ -606,7 +609,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             &mut bx,\n             intrinsic,\n             instance,\n-            span,\n+            source_info,\n             destination,\n             cleanup,\n         ) {\n@@ -627,7 +630,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic == Some(sym::caller_location) {\n             if let Some((_, target)) = destination.as_ref() {\n-                let location = self.get_caller_location(&mut bx, fn_span);\n+                let location = self\n+                    .get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n \n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n                     location.val.store(&mut bx, tmp);\n@@ -686,7 +690,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &fn_abi,\n                 &args,\n                 dest,\n-                terminator.source_info.span,\n+                span,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -793,7 +797,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args.len() + 1,\n                 \"#[track_caller] fn's must have 1 more argument in their ABI than in their MIR\",\n             );\n-            let location = self.get_caller_location(&mut bx, fn_span);\n+            let location =\n+                self.get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n             debug!(\n                 \"codegen_call_terminator({:?}): location={:?} (fn_span {:?})\",\n                 terminator, location, fn_span\n@@ -1179,17 +1184,49 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn get_caller_location(&mut self, bx: &mut Bx, span: Span) -> OperandRef<'tcx, Bx::Value> {\n-        self.caller_location.unwrap_or_else(|| {\n+    fn get_caller_location(\n+        &mut self,\n+        bx: &mut Bx,\n+        mut source_info: mir::SourceInfo,\n+    ) -> OperandRef<'tcx, Bx::Value> {\n+        let tcx = bx.tcx();\n+\n+        let mut span_to_caller_location = |span: Span| {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n-            let caller = bx.tcx().sess.source_map().lookup_char_pos(topmost.lo());\n-            let const_loc = bx.tcx().const_caller_location((\n+            let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n+            let const_loc = tcx.const_caller_location((\n                 Symbol::intern(&caller.file.name.to_string()),\n                 caller.line as u32,\n                 caller.col_display as u32 + 1,\n             ));\n             OperandRef::from_const(bx, const_loc, bx.tcx().caller_location_ty())\n-        })\n+        };\n+\n+        // Walk up the `SourceScope`s, in case some of them are from MIR inlining.\n+        // If so, the starting `source_info.span` is in the innermost inlined\n+        // function, and will be replaced with outer callsite spans as long\n+        // as the inlined functions were `#[track_caller]`.\n+        loop {\n+            let scope_data = &self.mir.source_scopes[source_info.scope];\n+\n+            if let Some((callee, callsite_span)) = scope_data.inlined {\n+                // Stop inside the most nested non-`#[track_caller]` function,\n+                // before ever reaching its caller (which is irrelevant).\n+                if !callee.def.requires_caller_location(tcx) {\n+                    return span_to_caller_location(source_info.span);\n+                }\n+                source_info.span = callsite_span;\n+            }\n+\n+            // Skip past all of the parents with `inlined: None`.\n+            match scope_data.inlined_parent_scope {\n+                Some(parent) => source_info.scope = parent,\n+                None => break,\n+            }\n+        }\n+\n+        // No inlined `SourceScope`s, or all of them were `#[track_caller]`.\n+        self.caller_location.unwrap_or_else(|| span_to_caller_location(source_info.span))\n     }\n \n     fn get_personality_slot(&mut self, bx: &mut Bx) -> PlaceRef<'tcx, Bx::Value> {"}, {"sha": "fb7fb4957e56ac9432ef67655182ed6695f5138c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -1878,6 +1878,11 @@ pub struct SourceScopeData<'tcx> {\n     /// `ty::Instance` is the callee, and the `Span` is the call site.\n     pub inlined: Option<(ty::Instance<'tcx>, Span)>,\n \n+    /// Nearest (transitive) parent scope (if any) which is inlined.\n+    /// This is an optimization over walking up `parent_scope`\n+    /// until a scope with `inlined: Some(...)` is found.\n+    pub inlined_parent_scope: Option<SourceScope>,\n+\n     /// Crate-local information for this source scope, that can't (and\n     /// needn't) be tracked across crates.\n     pub local_data: ClearCrossCrate<SourceScopeLocalData>,"}, {"sha": "d8d639ab73451c8c838ed3e561bbded87a7dc871", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -325,6 +325,7 @@ macro_rules! make_mir_visitor {\n                     span,\n                     parent_scope,\n                     inlined,\n+                    inlined_parent_scope,\n                     local_data: _,\n                 } = scope_data;\n \n@@ -357,6 +358,9 @@ macro_rules! make_mir_visitor {\n                     }\n                     self.visit_substs(callee_substs, location);\n                 }\n+                if let Some(inlined_parent_scope) = inlined_parent_scope {\n+                    self.visit_source_scope(inlined_parent_scope);\n+                }\n             }\n \n             fn super_statement(&mut self,"}, {"sha": "5c917f00d157bd9080c52c9443f275d25f48c08b", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -15,38 +15,61 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n     crate fn find_closest_untracked_caller_location(&self) -> Span {\n-        let frame = self\n-            .stack()\n-            .iter()\n-            .rev()\n-            // Find first non-`#[track_caller]` frame.\n-            .find(|frame| {\n+        for frame in self.stack().iter().rev() {\n+            debug!(\"find_closest_untracked_caller_location: checking frame {:?}\", frame.instance);\n+\n+            // Assert that the frame we look at is actually executing code currently\n+            // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n+            let loc = frame.loc.unwrap();\n+\n+            // This could be a non-`Call` terminator (such as `Drop`), or not a terminator at all\n+            // (such as `box`). Use the normal span by default.\n+            let mut source_info = *frame.body.source_info(loc);\n+\n+            // If this is a `Call` terminator, use the `fn_span` instead.\n+            let block = &frame.body.basic_blocks()[loc.block];\n+            if loc.statement_index == block.statements.len() {\n                 debug!(\n-                    \"find_closest_untracked_caller_location: checking frame {:?}\",\n-                    frame.instance\n+                    \"find_closest_untracked_caller_location: got terminator {:?} ({:?})\",\n+                    block.terminator(),\n+                    block.terminator().kind\n                 );\n-                !frame.instance.def.requires_caller_location(*self.tcx)\n-            })\n-            // Assert that there is always such a frame.\n-            .unwrap();\n-        // Assert that the frame we look at is actually executing code currently\n-        // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n-        let loc = frame.loc.unwrap();\n-        // If this is a `Call` terminator, use the `fn_span` instead.\n-        let block = &frame.body.basic_blocks()[loc.block];\n-        if loc.statement_index == block.statements.len() {\n-            debug!(\n-                \"find_closest_untracked_caller_location:: got terminator {:?} ({:?})\",\n-                block.terminator(),\n-                block.terminator().kind\n-            );\n-            if let TerminatorKind::Call { fn_span, .. } = block.terminator().kind {\n-                return fn_span;\n+                if let TerminatorKind::Call { fn_span, .. } = block.terminator().kind {\n+                    source_info.span = fn_span;\n+                }\n+            }\n+\n+            // Walk up the `SourceScope`s, in case some of them are from MIR inlining.\n+            // If so, the starting `source_info.span` is in the innermost inlined\n+            // function, and will be replaced with outer callsite spans as long\n+            // as the inlined functions were `#[track_caller]`.\n+            loop {\n+                let scope_data = &frame.body.source_scopes[source_info.scope];\n+\n+                if let Some((callee, callsite_span)) = scope_data.inlined {\n+                    // Stop inside the most nested non-`#[track_caller]` function,\n+                    // before ever reaching its caller (which is irrelevant).\n+                    if !callee.def.requires_caller_location(*self.tcx) {\n+                        return source_info.span;\n+                    }\n+                    source_info.span = callsite_span;\n+                }\n+\n+                // Skip past all of the parents with `inlined: None`.\n+                match scope_data.inlined_parent_scope {\n+                    Some(parent) => source_info.scope = parent,\n+                    None => break,\n+                }\n+            }\n+\n+            // Stop inside the most nested non-`#[track_caller]` function,\n+            // before ever reaching its caller (which is irrelevant).\n+            if !frame.instance.def.requires_caller_location(*self.tcx) {\n+                return source_info.span;\n             }\n         }\n-        // This is a different terminator (such as `Drop`) or not a terminator at all\n-        // (such as `box`). Use the normal span.\n-        frame.body.source_info(loc).span\n+\n+        bug!(\"no non-`#[track_caller]` frame found\")\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers."}, {"sha": "b2fa4b11f36589fb5b46068eadc46cead1eef544", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -216,6 +216,7 @@ fn new_body<'tcx>(\n                 span,\n                 parent_scope: None,\n                 inlined: None,\n+                inlined_parent_scope: None,\n                 local_data: ClearCrossCrate::Clear,\n             },\n             1,"}, {"sha": "96df6023c7195dc8ac9fa086c2b8ffecedec7d9f", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -246,11 +246,6 @@ impl Inliner<'tcx> {\n \n         let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee.def_id());\n \n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::TRACK_CALLER) {\n-            debug!(\"`#[track_caller]` present - not inlining\");\n-            return false;\n-        }\n-\n         let self_features = &self.codegen_fn_attrs.target_features;\n         let callee_features = &codegen_fn_attrs.target_features;\n         if callee_features.iter().any(|feature| !self_features.contains(feature)) {\n@@ -441,11 +436,24 @@ impl Inliner<'tcx> {\n \n                 for mut scope in callee_body.source_scopes.iter().cloned() {\n                     if scope.parent_scope.is_none() {\n+                        let callsite_scope = &caller_body.source_scopes[callsite.source_info.scope];\n+\n+                        // Attach the outermost callee scope as a child of the callsite\n+                        // scope, via the `parent_scope` and `inlined_parent_scope` chains.\n                         scope.parent_scope = Some(callsite.source_info.scope);\n+                        assert_eq!(scope.inlined_parent_scope, None);\n+                        scope.inlined_parent_scope = if callsite_scope.inlined.is_some() {\n+                            Some(callsite.source_info.scope)\n+                        } else {\n+                            callsite_scope.inlined_parent_scope\n+                        };\n \n                         // Mark the outermost callee scope as an inlined one.\n                         assert_eq!(scope.inlined, None);\n                         scope.inlined = Some((callsite.callee, callsite.source_info.span));\n+                    } else if scope.inlined_parent_scope.is_none() {\n+                        // Make it easy to find the scope with `inlined` set above.\n+                        scope.inlined_parent_scope = Some(scope_map[OUTERMOST_SOURCE_SCOPE]);\n                     }\n \n                     let idx = caller_body.source_scopes.push(scope);"}, {"sha": "ac4d6563d6c24c9e4177f61fdef83992baf97e88", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -551,18 +551,31 @@ fn write_scope_tree(\n         let child_data = &body.source_scopes[child];\n         assert_eq!(child_data.parent_scope, Some(parent));\n \n-        if let Some((callee, callsite_span)) = child_data.inlined {\n-            let indented_header =\n-                format!(\"{0:1$}scope {2} (inlined {3}) {{\", \"\", indent, child.index(), callee);\n+        let (special, span) = if let Some((callee, callsite_span)) = child_data.inlined {\n+            (\n+                format!(\n+                    \" (inlined {}{})\",\n+                    if callee.def.requires_caller_location(tcx) { \"#[track_caller] \" } else { \"\" },\n+                    callee\n+                ),\n+                Some(callsite_span),\n+            )\n+        } else {\n+            (String::new(), None)\n+        };\n+\n+        let indented_header = format!(\"{0:1$}scope {2}{3} {{\", \"\", indent, child.index(), special);\n+\n+        if let Some(span) = span {\n             writeln!(\n                 w,\n                 \"{0:1$} // at {2}\",\n                 indented_header,\n                 ALIGN,\n-                tcx.sess.source_map().span_to_string(callsite_span),\n+                tcx.sess.source_map().span_to_string(span),\n             )?;\n         } else {\n-            writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n+            writeln!(w, \"{}\", indented_header)?;\n         }\n \n         write_scope_tree(tcx, body, scope_tree, w, child, depth + 1)?;"}, {"sha": "b6321c3bf670274c61ff2bb4f113e2ef6b6bd543", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6451b39a25fbad9e991c6ea014a86217c52d3fd6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=6451b39a25fbad9e991c6ea014a86217c52d3fd6", "patch": "@@ -706,6 +706,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             span,\n             parent_scope: Some(parent),\n             inlined: None,\n+            inlined_parent_scope: None,\n             local_data: ClearCrossCrate::Set(scope_local_data),\n         })\n     }"}]}