{"sha": "65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZGQ1ZTZhODRhYThkOWFmNDc3ZjIxZmE5Nzk3ZTNkMDc3NGEyYzE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-29T18:42:02Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-04T13:56:04Z"}, "message": "Remove the CallKind\n\nWe used to have CallKind only because there was a requirement to have all successors in a\ncontiguous memory block. Now that the requirement is gone, remove the CallKind and instead just\nhave the necessary information inline.\n\nAwesome!", "tree": {"sha": "38203cf1a91d9cef039b76f1df7d0ac380fc944d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38203cf1a91d9cef039b76f1df7d0ac380fc944d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "html_url": "https://github.com/rust-lang/rust/commit/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02365fe753708534229ff780e80133e256f3bbe3", "url": "https://api.github.com/repos/rust-lang/rust/commits/02365fe753708534229ff780e80133e256f3bbe3", "html_url": "https://github.com/rust-lang/rust/commit/02365fe753708534229ff780e80133e256f3bbe3"}], "stats": {"total": 198, "additions": 53, "deletions": 145}, "files": [{"sha": "59d00b436c88620db3bb2abbef76cb6381fb6db8", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 20, "deletions": 76, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "patch": "@@ -268,71 +268,13 @@ pub enum Terminator<'tcx> {\n         func: Operand<'tcx>,\n         /// Arguments the function is called with\n         args: Vec<Operand<'tcx>>,\n-        /// The kind of call with associated information\n-        kind: CallKind<'tcx>,\n+        /// Destination for the return value. If some, the call is converging.\n+        destination: Option<(Lvalue<'tcx>, BasicBlock)>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlock>\n     },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum CallKind<'tcx> {\n-    /// Diverging function without associated cleanup\n-    Diverging,\n-    /// Diverging function with associated cleanup\n-    DivergingCleanup(BasicBlock),\n-    /// Converging function without associated cleanup\n-    Converging {\n-        /// Destination where the call result is written\n-        destination: Lvalue<'tcx>,\n-        /// Block to branch into on successful return\n-        target: BasicBlock,\n-    },\n-    ConvergingCleanup {\n-        /// Destination where the call result is written\n-        destination: Lvalue<'tcx>,\n-        /// First target is branched to on successful return.\n-        /// Second block contains the cleanups to do on unwind.\n-        targets: (BasicBlock, BasicBlock)\n-    }\n-}\n-\n-impl<'tcx> CallKind<'tcx> {\n-    pub fn successors(&self) -> &[BasicBlock] {\n-        match *self {\n-            CallKind::Diverging => &[],\n-            CallKind::DivergingCleanup(ref b) |\n-            CallKind::Converging { target: ref b, .. } => slice::ref_slice(b),\n-            CallKind::ConvergingCleanup { ref targets, .. } => targets.as_slice(),\n-        }\n-    }\n-\n-    pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n-        match *self {\n-            CallKind::Diverging => &mut [],\n-            CallKind::DivergingCleanup(ref mut b) |\n-            CallKind::Converging { target: ref mut b, .. } => slice::mut_ref_slice(b),\n-            CallKind::ConvergingCleanup { ref mut targets, .. } => targets.as_mut_slice(),\n-        }\n-    }\n-\n-    pub fn destination(&self) -> Option<&Lvalue<'tcx>> {\n-        match *self {\n-            CallKind::Converging { ref destination, .. } |\n-            CallKind::ConvergingCleanup { ref destination, .. } => Some(destination),\n-            CallKind::Diverging |\n-            CallKind::DivergingCleanup(_) => None\n-        }\n-    }\n-\n-    pub fn destination_mut(&mut self) -> Option<&mut Lvalue<'tcx>> {\n-        match *self {\n-            CallKind::Converging { ref mut destination, .. } |\n-            CallKind::ConvergingCleanup { ref mut destination, .. } => Some(destination),\n-            CallKind::Diverging |\n-            CallKind::DivergingCleanup(_) => None\n-        }\n-    }\n-}\n-\n impl<'tcx> Terminator<'tcx> {\n     pub fn successors(&self) -> Cow<[BasicBlock]> {\n         use self::Terminator::*;\n@@ -343,7 +285,11 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n             Resume => (&[]).into_cow(),\n             Return => (&[]).into_cow(),\n-            Call { ref kind, .. } => kind.successors()[..].into_cow(),\n+            Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n+            Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n+                slice::ref_slice(t).into_cow(),\n+            Call { destination: None, cleanup: Some(ref c), .. } => slice::ref_slice(c).into_cow(),\n+            Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n         }\n     }\n \n@@ -358,7 +304,10 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n             Resume => Vec::new(),\n             Return => Vec::new(),\n-            Call { ref mut kind, .. } => kind.successors_mut().iter_mut().collect(),\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n+            Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n+            Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n         }\n     }\n }\n@@ -425,8 +374,8 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n-            Call { ref kind, ref func, ref args } => {\n-                if let Some(destination) = kind.destination() {\n+            Call { ref func, ref args, ref destination, .. } => {\n+                if let Some((ref destination, _)) = *destination {\n                     try!(write!(fmt, \"{:?} = \", destination));\n                 }\n                 try!(write!(fmt, \"{:?}(\", func));\n@@ -464,16 +413,11 @@ impl<'tcx> Terminator<'tcx> {\n                       .chain(iter::once(String::from(\"otherwise\").into()))\n                       .collect()\n             }\n-            Call { ref kind, .. } => match *kind {\n-                CallKind::Diverging =>\n-                    vec![],\n-                CallKind::DivergingCleanup(..) =>\n-                    vec![\"unwind\".into_cow()],\n-                CallKind::Converging { .. } =>\n-                    vec![\"return\".into_cow()],\n-                CallKind::ConvergingCleanup { .. } =>\n-                    vec![\"return\".into_cow(), \"unwind\".into_cow()],\n-            },\n+            Call { destination: Some(_), cleanup: Some(_), .. } =>\n+                vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n+            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n         }\n     }\n }"}, {"sha": "73dd0de1c041d596b373eb354373a04711bccbd8", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "patch": "@@ -179,28 +179,17 @@ macro_rules! make_mir_visitor {\n \n                     Terminator::Call { ref $($mutability)* func,\n                                        ref $($mutability)* args,\n-                                       ref $($mutability)* kind } => {\n+                                       ref $($mutability)* destination,\n+                                       ref $($mutability)* cleanup } => {\n                         self.visit_operand(func);\n                         for arg in args {\n                             self.visit_operand(arg);\n                         }\n-                        match *kind {\n-                            CallKind::Converging {\n-                                ref $($mutability)* destination,\n-                                ..\n-                            }        |\n-                            CallKind::ConvergingCleanup {\n-                                ref $($mutability)* destination,\n-                                ..\n-                            } => {\n-                                self.visit_lvalue(destination, LvalueContext::Store);\n-                            }\n-                            CallKind::Diverging           |\n-                            CallKind::DivergingCleanup(_) => {}\n-                        }\n-                        for &target in kind.successors() {\n+                        if let Some((ref $($mutability)* destination, target)) = *destination {\n+                            self.visit_lvalue(destination, LvalueContext::Store);\n                             self.visit_branch(block, target);\n                         }\n+                        cleanup.map(|t| self.visit_branch(block, t));\n                     }\n                 }\n             }"}, {"sha": "3b453a214b6eedc3e5d1d6cdb4904f0c6879cb17", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "patch": "@@ -253,17 +253,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.cfg.terminate(block, Terminator::Call {\n                     func: fun,\n                     args: args,\n-                    kind: match (cleanup, diverges) {\n-                        (None, true) => CallKind::Diverging,\n-                        (Some(c), true) => CallKind::DivergingCleanup(c),\n-                        (None, false) => CallKind::Converging {\n-                            destination: destination.clone(),\n-                            target: success\n-                        },\n-                        (Some(c), false) => CallKind::ConvergingCleanup {\n-                            destination: destination.clone(),\n-                            targets: (success, c)\n-                        }\n+                    cleanup: cleanup,\n+                    destination: if diverges {\n+                        None\n+                    } else {\n+                        Some ((destination.clone(), success))\n                     }\n                 });\n                 success.unit()"}, {"sha": "fef6837f3f77ea7d754d80c4d208ae30bb203838", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "patch": "@@ -273,7 +273,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     ));\n                     let func = Constant {\n                         span: item.1,\n-                        ty: tcx.lookup_item_type(item.0).ty.subst(substs),\n+                        ty: tcx.lookup_item_type(item.0).ty,\n                         literal: Literal::Item {\n                             def_id: item.0,\n                             kind: ItemKind::Function,\n@@ -285,10 +285,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     self.cfg.terminate(new_block, Terminator::Call {\n                         func: Operand::Constant(func),\n                         args: vec![Operand::Consume(lvalue.clone())],\n-                        kind: CallKind::Converging {\n-                            target: old_block,\n-                            destination: unit_tmp.clone()\n-                        }\n+                        destination: Some((unit_tmp.clone(), old_block)),\n+                        cleanup: None // we\u2019re already doing divergence cleanups\n                     });\n                     terminator = Terminator::Goto { target: new_block };\n                 }\n@@ -383,10 +381,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(block, Terminator::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref), index, len],\n-            kind: match cleanup {\n-                None => CallKind::Diverging,\n-                Some(c) => CallKind::DivergingCleanup(c)\n-            }\n+            destination: None,\n+            cleanup: cleanup,\n         });\n     }\n \n@@ -423,10 +419,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(block, Terminator::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n-            kind: match cleanup {\n-                None => CallKind::Diverging,\n-                Some(c) => CallKind::DivergingCleanup(c)\n-            }\n+            cleanup: cleanup,\n+            destination: None,\n         });\n     }\n "}, {"sha": "00162be816b88f785b25b34c8529dd535b40caab", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "patch": "@@ -93,8 +93,8 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(discr);\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n-            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n-                if let Some(destination) = kind.destination_mut() {\n+            Terminator::Call { ref mut func, ref mut args, ref mut destination, .. } => {\n+                if let Some((ref mut destination, _)) = *destination {\n                     self.erase_regions_lvalue(destination);\n                 }\n                 self.erase_regions_operand(func);"}, {"sha": "c1ab55f9f53d751eea8ac1e0d19d423134d1c1fe", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "patch": "@@ -94,7 +94,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n-            mir::Terminator::Call { ref func, ref args, ref kind } => {\n+            mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n                 let callee = self.trans_operand(bcx, func);\n                 let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n@@ -115,7 +115,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 // Prepare the return value destination\n-                let (ret_dest_ty, must_copy_dest) = if let Some(d) = kind.destination() {\n+                let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n                     let dest = self.trans_lvalue(bcx, d);\n                     let ret_ty = dest.ty.to_ty(bcx.tcx());\n                     if !is_foreign && type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n@@ -144,9 +144,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n \n                 // Many different ways to call a function handled here\n-                match (is_foreign, base::avoid_invoke(bcx), kind) {\n+                match (is_foreign, base::avoid_invoke(bcx), cleanup, destination) {\n                     // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n-                    (false, false, &mir::CallKind::DivergingCleanup(cleanup)) => {\n+                    (false, false, &Some(cleanup), &None) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n@@ -158,14 +158,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                       Some(attrs),\n                                       debugloc);\n                     },\n-                    (false, false, &mir::CallKind::ConvergingCleanup { ref targets, .. }) => {\n-                        let cleanup = self.bcx(targets.1);\n+                    (false, false, &Some(cleanup), &Some((_, success))) => {\n+                        let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let (target, postinvoke) = if must_copy_dest {\n-                            (bcx.fcx.new_block(\"\", None),\n-                             Some(self.bcx(targets.0)))\n+                            (bcx.fcx.new_block(\"\", None), Some(self.bcx(success)))\n                         } else {\n-                            (self.bcx(targets.0), None)\n+                            (self.bcx(success), None)\n                         };\n                         let invokeret = build::Invoke(bcx,\n                                                       callee.immediate(),\n@@ -205,19 +204,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             build::Br(target, postinvoketarget.llbb, debugloc);\n                         }\n                     },\n-                    (false, _, &mir::CallKind::DivergingCleanup(_)) |\n-                    (false, _, &mir::CallKind::Diverging) => {\n+                    (false, _, _, &None) => {\n                         build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n                         build::Unreachable(bcx);\n                     }\n-                    (false, _, k@&mir::CallKind::ConvergingCleanup { .. }) |\n-                    (false, _, k@&mir::CallKind::Converging { .. }) => {\n-                        // FIXME: Bug #20046\n-                        let target = match *k {\n-                            mir::CallKind::ConvergingCleanup { targets, .. } => targets.0,\n-                            mir::CallKind::Converging { target, .. } => target,\n-                            _ => unreachable!()\n-                        };\n+                    (false, _, _, &Some((_, target))) => {\n                         let llret = build::Call(bcx,\n                                                 callee.immediate(),\n                                                 &llargs[..],\n@@ -231,7 +222,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         build::Br(bcx, self.llblock(target), debugloc);\n                     }\n                     // Foreign functions\n-                    (true, _, k) => {\n+                    (true, _, _, destination) => {\n                         let (dest, _) = ret_dest_ty\n                             .expect(\"return destination is not set\");\n                         bcx = foreign::trans_native_call(bcx,\n@@ -241,13 +232,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                    &llargs[..],\n                                                    arg_tys,\n                                                    debugloc);\n-                        match *k {\n-                            mir::CallKind::ConvergingCleanup { targets, .. } =>\n-                                build::Br(bcx, self.llblock(targets.0), debugloc),\n-                            mir::CallKind::Converging { target, .. } =>\n-                                build::Br(bcx, self.llblock(target), debugloc),\n-                            _ => ()\n-                        };\n+                        if let Some((_, target)) = *destination {\n+                            build::Br(bcx, self.llblock(target), debugloc);\n+                        }\n                     },\n                 }\n             }"}]}