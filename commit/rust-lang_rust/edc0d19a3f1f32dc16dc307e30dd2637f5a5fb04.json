{"sha": "edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzBkMTlhM2YxZjMyZGMxNmRjMzA3ZTMwZGQyNjM3ZjVhNWZiMDQ=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-13T00:42:46Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-13T00:42:46Z"}, "message": "Add `new` to WRONG_SELF_CONVENTION", "tree": {"sha": "3aada38feb1e785b7ef17c3337fa19b184c9953c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3aada38feb1e785b7ef17c3337fa19b184c9953c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04", "html_url": "https://github.com/rust-lang/rust/commit/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f567ce1d18a3d4579567fae33bfceaa0b18a9ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f567ce1d18a3d4579567fae33bfceaa0b18a9ff", "html_url": "https://github.com/rust-lang/rust/commit/7f567ce1d18a3d4579567fae33bfceaa0b18a9ff"}], "stats": {"total": 95, "additions": 61, "deletions": 34}, "files": [{"sha": "3787474e28cc0d8a0bd816dc7623572b36c6454f", "filename": "src/methods.rs", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04", "patch": "@@ -1,11 +1,11 @@\n-use rustc_front::hir::*;\n use rustc::lint::*;\n-use rustc::middle::ty;\n use rustc::middle::subst::{Subst, TypeSpace};\n-use std::iter;\n+use rustc::middle::ty;\n+use rustc_front::hir::*;\n use std::borrow::Cow;\n-use syntax::ptr::P;\n+use std::{fmt, iter};\n use syntax::codemap::Span;\n+use syntax::ptr::P;\n \n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n             match_type, method_chain_args, snippet, snippet_opt, span_lint, span_lint_and_then, span_note_and_lint,\n@@ -367,10 +367,11 @@ impl LateLintPass for MethodsPass {\n                             }\n                         }\n                     }\n+\n                     // check conventions w.r.t. conversion method names and predicates\n                     let is_copy = is_copy(cx, &ty, &item);\n-                    for &(prefix, self_kinds) in &CONVENTIONS {\n-                        if name.as_str().starts_with(prefix) &&\n+                    for &(ref conv, self_kinds) in &CONVENTIONS {\n+                        if conv.check(&name.as_str()) &&\n                            !self_kinds.iter().any(|k| k.matches(&sig.explicit_self.node, is_copy)) {\n                             let lint = if item.vis == Visibility::Public {\n                                 WRONG_PUB_SELF_CONVENTION\n@@ -380,9 +381,9 @@ impl LateLintPass for MethodsPass {\n                             span_lint(cx,\n                                       lint,\n                                       sig.explicit_self.span,\n-                                      &format!(\"methods called `{}*` usually take {}; consider choosing a less \\\n+                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n                                                 ambiguous name\",\n-                                               prefix,\n+                                               conv,\n                                                &self_kinds.iter()\n                                                           .map(|k| k.description())\n                                                           .collect::<Vec<_>>()\n@@ -796,47 +797,53 @@ fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     }\n }\n \n+enum Convention {\n+    Eq(&'static str),\n+    StartsWith(&'static str),\n+}\n+\n #[cfg_attr(rustfmt, rustfmt_skip)]\n-const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n-    (\"into_\", &[SelfKind::Value]),\n-    (\"to_\", &[SelfKind::Ref]),\n-    (\"as_\", &[SelfKind::Ref, SelfKind::RefMut]),\n-    (\"is_\", &[SelfKind::Ref, SelfKind::No]),\n-    (\"from_\", &[SelfKind::No]),\n+const CONVENTIONS: [(Convention, &'static [SelfKind]); 6] = [\n+    (Convention::Eq(\"new\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"as_\"), &[SelfKind::Ref, SelfKind::RefMut]),\n+    (Convention::StartsWith(\"from_\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"into_\"), &[SelfKind::Value]),\n+    (Convention::StartsWith(\"is_\"), &[SelfKind::Ref, SelfKind::No]),\n+    (Convention::StartsWith(\"to_\"), &[SelfKind::Ref]),\n ];\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n     (\"add\", 2, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n-    (\"sub\", 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n-    (\"mul\", 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n-    (\"div\", 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n-    (\"rem\", 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n-    (\"shl\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n-    (\"shr\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n+    (\"as_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n+    (\"as_ref\", 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n     (\"bitand\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n     (\"bitor\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n     (\"bitxor\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n-    (\"neg\", 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n-    (\"not\", 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n-    (\"drop\", 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n-    (\"index\", 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n-    (\"index_mut\", 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n-    (\"deref\", 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n-    (\"deref_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n-    (\"clone\", 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n     (\"borrow\", 1, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n     (\"borrow_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n-    (\"as_ref\", 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n-    (\"as_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n-    (\"eq\", 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n+    (\"clone\", 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n     (\"cmp\", 2, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n     (\"default\", 0, SelfKind::No, OutType::Any, \"std::default::Default\"),\n-    (\"hash\", 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n-    (\"next\", 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n-    (\"into_iter\", 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n+    (\"deref\", 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n+    (\"deref_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n+    (\"div\", 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n+    (\"drop\", 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n+    (\"eq\", 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n     (\"from_iter\", 1, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n     (\"from_str\", 1, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n+    (\"hash\", 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n+    (\"index\", 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n+    (\"index_mut\", 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n+    (\"into_iter\", 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n+    (\"mul\", 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n+    (\"neg\", 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n+    (\"next\", 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n+    (\"not\", 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n+    (\"rem\", 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n+    (\"shl\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n+    (\"shr\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n+    (\"sub\", 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n ];\n \n #[derive(Clone, Copy)]\n@@ -881,6 +888,24 @@ impl SelfKind {\n     }\n }\n \n+impl Convention {\n+    fn check(&self, other: &str) -> bool {\n+        match *self {\n+            Convention::Eq(this) => this == other,\n+            Convention::StartsWith(this) => other.starts_with(this),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Convention {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        match *self {\n+            Convention::Eq(this) => this.fmt(f),\n+            Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy)]\n enum OutType {\n     Unit,"}, {"sha": "9a10b336e0ecef0c84eca53e257476e84855d3a3", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=edc0d19a3f1f32dc16dc307e30dd2637f5a5fb04", "patch": "@@ -22,6 +22,8 @@ impl T {\n     fn into_u16(&self) -> u16 { 0 } //~ERROR methods called `into_*` usually take self by value\n \n     fn to_something(self) -> u32 { 0 } //~ERROR methods called `to_*` usually take self by reference\n+\n+    fn new(self) {} //~ERROR methods called `new` usually take no self\n }\n \n #[derive(Clone,Copy)]"}]}