{"sha": "8a13fc494d4365e57d8f343219f0201458b68591", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMTNmYzQ5NGQ0MzY1ZTU3ZDhmMzQzMjE5ZjAyMDE0NThiNjg1OTE=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-13T21:15:40Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-13T21:15:40Z"}, "message": "Require `module_id` param to `resolve` to be non-empty\n\nPreviously, `resolve` would immediately check that `module_id` was\nnon-empty and give an error if not. This had two downsides:\n\n- It introduced `Option`s everywhere, even if the calling function knew\nit had a valid module, and\n- It checked the module on each namespace, which is unnecessary: it only\nneeded to be checked once.\n\nThis makes the caller responsible for checking the module exists, making\nthe code a lot simpler.", "tree": {"sha": "8c63766b5fa5b5c54a498f5e4a49263d3d31a8ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c63766b5fa5b5c54a498f5e4a49263d3d31a8ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a13fc494d4365e57d8f343219f0201458b68591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a13fc494d4365e57d8f343219f0201458b68591", "html_url": "https://github.com/rust-lang/rust/commit/8a13fc494d4365e57d8f343219f0201458b68591", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a13fc494d4365e57d8f343219f0201458b68591/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dc0d335bcc819c770320635a055c9cfe076339a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc0d335bcc819c770320635a055c9cfe076339a", "html_url": "https://github.com/rust-lang/rust/commit/7dc0d335bcc819c770320635a055c9cfe076339a"}], "stats": {"total": 574, "additions": 279, "deletions": 295}, "files": [{"sha": "5a9eeec4dfec334566f2fa407431dad8f77e7667", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 279, "deletions": 295, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/8a13fc494d4365e57d8f343219f0201458b68591/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a13fc494d4365e57d8f343219f0201458b68591/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8a13fc494d4365e57d8f343219f0201458b68591", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 let kind = if let Some(intermediate) = self.check_full_res(\n                     TypeNS,\n                     &intermediate_path,\n-                    Some(module_id),\n+                    module_id,\n                     current_item,\n                     extra_fragment,\n                 ) {\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn macro_resolve(\n         &self,\n         path_str: &'a str,\n-        parent_id: Option<DefId>,\n+        module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n@@ -254,28 +254,23 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n                 return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n             }\n-            if let Some(module_id) = parent_id {\n-                debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n-                if let Ok((_, res)) =\n-                    resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n-                {\n-                    // don't resolve builtins like `#[derive]`\n-                    if let Res::Def(..) = res {\n-                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                        return Some(Ok(res));\n-                    }\n+            debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n+            if let Ok((_, res)) =\n+                resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n+            {\n+                // don't resolve builtins like `#[derive]`\n+                if let Res::Def(..) = res {\n+                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                    return Some(Ok(res));\n                 }\n-            } else {\n-                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-                return Some(Err(ResolutionFailure::NoParentItem));\n             }\n             None\n         })\n         // This weird control flow is so we don't borrow the resolver more than once at a time\n         .unwrap_or_else(|| {\n             let mut split = path_str.rsplitn(2, \"::\");\n             if let Some((parent, base)) = split.next().and_then(|x| Some((split.next()?, x))) {\n-                if let Some(res) = self.check_full_res(TypeNS, parent, parent_id, &None, &None) {\n+                if let Some(res) = self.check_full_res(TypeNS, parent, module_id, &None, &None) {\n                     return Err(if matches!(res, Res::PrimTy(_)) {\n                         ResolutionFailure::NoPrimitiveAssocItem {\n                             res,\n@@ -287,306 +282,282 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     });\n                 }\n             }\n-            Err(ResolutionFailure::NotInScope {\n-                module_id: parent_id.expect(\"already saw `Some` when resolving as a macro\"),\n-                name: path_str.into(),\n-            })\n+            Err(ResolutionFailure::NotInScope { module_id, name: path_str.into() })\n         })\n     }\n+\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n         &self,\n         path_str: &'path str,\n         ns: Namespace,\n         current_item: &Option<String>,\n-        parent_id: Option<DefId>,\n+        module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n-        // In case we're in a module, try to resolve the relative path.\n-        if let Some(module_id) = parent_id {\n-            let result = cx.enter_resolver(|resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n-            });\n-            debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-            let result = match result {\n-                Ok((_, Res::Err)) => Err(()),\n-                x => x,\n-            };\n+        let result = cx.enter_resolver(|resolver| {\n+            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+        });\n+        debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n+        let result = match result {\n+            Ok((_, Res::Err)) => Err(()),\n+            x => x,\n+        };\n \n-            if let Ok((_, res)) = result {\n-                let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                // In case this is a trait item, skip the\n-                // early return and try looking for the trait.\n-                let value = match res {\n-                    Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => true,\n-                    Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => {\n-                        return handle_variant(cx, res, extra_fragment);\n-                    }\n-                    // Not a trait item; just return what we found.\n-                    Res::PrimTy(..) => {\n-                        if extra_fragment.is_some() {\n-                            return Err(ErrorKind::AnchorFailure(\n-                                AnchorFailure::RustdocAnchorConflict(res),\n-                            ));\n-                        }\n-                        return Ok((res, Some(path_str.to_owned())));\n-                    }\n-                    Res::Def(DefKind::Mod, _) => {\n-                        return Ok((res, extra_fragment.clone()));\n-                    }\n-                    _ => {\n-                        return Ok((res, extra_fragment.clone()));\n+        if let Ok((_, res)) = result {\n+            let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+            // In case this is a trait item, skip the\n+            // early return and try looking for the trait.\n+            let value = match res {\n+                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => true,\n+                Res::Def(DefKind::AssocTy, _) => false,\n+                Res::Def(DefKind::Variant, _) => {\n+                    return handle_variant(cx, res, extra_fragment);\n+                }\n+                // Not a trait item; just return what we found.\n+                Res::PrimTy(..) => {\n+                    if extra_fragment.is_some() {\n+                        return Err(ErrorKind::AnchorFailure(\n+                            AnchorFailure::RustdocAnchorConflict(res),\n+                        ));\n                     }\n-                };\n-\n-                if value != (ns == ValueNS) {\n-                    return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n+                    return Ok((res, Some(path_str.to_owned())));\n+                }\n+                Res::Def(DefKind::Mod, _) => {\n+                    return Ok((res, extra_fragment.clone()));\n                 }\n-            } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n-                if extra_fragment.is_some() {\n-                    return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                        prim,\n-                    )));\n+                _ => {\n+                    return Ok((res, extra_fragment.clone()));\n                 }\n-                return Ok((prim, Some(path.to_owned())));\n+            };\n+\n+            if value != (ns == ValueNS) {\n+                return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n             }\n+        } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n+            if extra_fragment.is_some() {\n+                return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(prim)));\n+            }\n+            return Ok((prim, Some(path.to_owned())));\n+        }\n \n-            // Try looking for methods and associated items.\n-            let mut split = path_str.rsplitn(2, \"::\");\n-            // this can be an `unwrap()` because we ensure the link is never empty\n-            let item_name = Symbol::intern(split.next().unwrap());\n-            let path_root = split\n-                .next()\n-                .map(|f| {\n-                    if f == \"self\" || f == \"Self\" {\n-                        if let Some(name) = current_item.as_ref() {\n-                            return name.clone();\n-                        }\n-                    }\n-                    f.to_owned()\n-                })\n-                // If there's no `::`, it's not an associated item.\n-                // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n-                .ok_or_else(|| {\n-                    debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                    ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n-                })?;\n-\n-            if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n-                let impls = primitive_impl(cx, &path)\n-                    .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n-                for &impl_ in impls {\n-                    let link = cx\n-                        .tcx\n-                        .associated_items(impl_)\n-                        .find_by_name_and_namespace(\n-                            cx.tcx,\n-                            Ident::with_dummy_span(item_name),\n-                            ns,\n-                            impl_,\n-                        )\n-                        .map(|item| match item.kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        })\n-                        .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n-                    if let Some(link) = link {\n-                        return Ok(link);\n+        // Try looking for methods and associated items.\n+        let mut split = path_str.rsplitn(2, \"::\");\n+        // this can be an `unwrap()` because we ensure the link is never empty\n+        let item_name = Symbol::intern(split.next().unwrap());\n+        let path_root = split\n+            .next()\n+            .map(|f| {\n+                if f == \"self\" || f == \"Self\" {\n+                    if let Some(name) = current_item.as_ref() {\n+                        return name.clone();\n                     }\n                 }\n-                debug!(\n-                    \"returning primitive error for {}::{} in {} namespace\",\n-                    path,\n-                    item_name,\n-                    ns.descr()\n-                );\n-                return Err(ResolutionFailure::NoPrimitiveAssocItem {\n-                    res: prim,\n-                    prim_name: path,\n-                    assoc_item: item_name,\n+                f.to_owned()\n+            })\n+            // If there's no `::`, it's not an associated item.\n+            // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n+            .ok_or_else(|| {\n+                debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n+                ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n+            })?;\n+\n+        if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n+            let impls = primitive_impl(cx, &path)\n+                .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n+            for &impl_ in impls {\n+                let link = cx\n+                    .tcx\n+                    .associated_items(impl_)\n+                    .find_by_name_and_namespace(\n+                        cx.tcx,\n+                        Ident::with_dummy_span(item_name),\n+                        ns,\n+                        impl_,\n+                    )\n+                    .map(|item| match item.kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    })\n+                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n+                if let Some(link) = link {\n+                    return Ok(link);\n                 }\n-                .into());\n             }\n+            debug!(\n+                \"returning primitive error for {}::{} in {} namespace\",\n+                path,\n+                item_name,\n+                ns.descr()\n+            );\n+            return Err(ResolutionFailure::NoPrimitiveAssocItem {\n+                res: prim,\n+                prim_name: path,\n+                assoc_item: item_name,\n+            }\n+            .into());\n+        }\n \n-            let ty_res = cx\n-                .enter_resolver(|resolver| {\n-                    // only types can have associated items\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n-                })\n-                .map(|(_, res)| res);\n-            let ty_res = match ty_res {\n-                Err(()) | Ok(Res::Err) => {\n-                    return if ns == Namespace::ValueNS {\n-                        self.variant_field(path_str, current_item, module_id, extra_fragment)\n-                    } else {\n-                        // See if it only broke because of the namespace.\n-                        let kind = cx.enter_resolver(|resolver| {\n-                            // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n-                            for &ns in &[MacroNS, ValueNS] {\n-                                match resolver\n-                                    .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n-                                {\n-                                    Ok((_, Res::Err)) | Err(()) => {}\n-                                    Ok((_, res)) => {\n-                                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                                        return ResolutionFailure::CannotHaveAssociatedItems(\n-                                            res, ns,\n-                                        );\n-                                    }\n+        let ty_res = cx\n+            .enter_resolver(|resolver| {\n+                // only types can have associated items\n+                resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n+            })\n+            .map(|(_, res)| res);\n+        let ty_res = match ty_res {\n+            Err(()) | Ok(Res::Err) => {\n+                return if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                } else {\n+                    // See if it only broke because of the namespace.\n+                    let kind = cx.enter_resolver(|resolver| {\n+                        // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n+                        for &ns in &[MacroNS, ValueNS] {\n+                            match resolver\n+                                .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n+                            {\n+                                Ok((_, Res::Err)) | Err(()) => {}\n+                                Ok((_, res)) => {\n+                                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                                    return ResolutionFailure::CannotHaveAssociatedItems(res, ns);\n                                 }\n                             }\n-                            ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n-                        });\n-                        Err(kind.into())\n-                    };\n-                }\n-                Ok(res) => res,\n-            };\n-            let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n-            let res = match ty_res {\n-                Res::Def(\n-                    DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n-                    did,\n-                ) => {\n-                    debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n-                    // Checks if item_name belongs to `impl SomeItem`\n-                    let assoc_item = cx\n-                        .tcx\n-                        .inherent_impls(did)\n-                        .iter()\n-                        .flat_map(|&imp| {\n-                            cx.tcx.associated_items(imp).find_by_name_and_namespace(\n-                                cx.tcx,\n-                                Ident::with_dummy_span(item_name),\n-                                ns,\n-                                imp,\n-                            )\n-                        })\n-                        .map(|item| (item.kind, item.def_id))\n-                        // There should only ever be one associated item that matches from any inherent impl\n-                        .next()\n-                        // Check if item_name belongs to `impl SomeTrait for SomeItem`\n-                        // This gives precedence to `impl SomeItem`:\n-                        // Although having both would be ambiguous, use impl version for compat. sake.\n-                        // To handle that properly resolve() would have to support\n-                        // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                        .or_else(|| {\n-                            let kind = resolve_associated_trait_item(\n-                                did, module_id, item_name, ns, &self.cx,\n-                            );\n-                            debug!(\"got associated item kind {:?}\", kind);\n-                            kind\n-                        });\n-\n-                    if let Some((kind, id)) = assoc_item {\n-                        let out = match kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        };\n-                        Some(if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                                ty_res,\n-                            )))\n-                        } else {\n-                            // HACK(jynelson): `clean` expects the type, not the associated item.\n-                            // but the disambiguator logic expects the associated item.\n-                            // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                            self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                            Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n-                        })\n-                    } else if ns == Namespace::ValueNS {\n-                        debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n-                        match cx.tcx.type_of(did).kind() {\n-                            ty::Adt(def, _) => {\n-                                let field = if def.is_enum() {\n-                                    def.all_fields().find(|item| item.ident.name == item_name)\n-                                } else {\n-                                    def.non_enum_variant()\n-                                        .fields\n-                                        .iter()\n-                                        .find(|item| item.ident.name == item_name)\n-                                };\n-                                field.map(|item| {\n-                                    if extra_fragment.is_some() {\n-                                        let res = Res::Def(\n-                                            if def.is_enum() {\n-                                                DefKind::Variant\n-                                            } else {\n-                                                DefKind::Field\n-                                            },\n-                                            item.did,\n-                                        );\n-                                        Err(ErrorKind::AnchorFailure(\n-                                            AnchorFailure::RustdocAnchorConflict(res),\n-                                        ))\n-                                    } else {\n-                                        Ok((\n-                                            ty_res,\n-                                            Some(format!(\n-                                                \"{}.{}\",\n-                                                if def.is_enum() {\n-                                                    \"variant\"\n-                                                } else {\n-                                                    \"structfield\"\n-                                                },\n-                                                item.ident\n-                                            )),\n-                                        ))\n-                                    }\n-                                })\n-                            }\n-                            _ => None,\n                         }\n-                    } else {\n-                        // We already know this isn't in ValueNS, so no need to check variant_field\n-                        return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n-                    }\n-                }\n-                Res::Def(DefKind::Trait, did) => cx\n+                        ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n+                    });\n+                    Err(kind.into())\n+                };\n+            }\n+            Ok(res) => res,\n+        };\n+        let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+        let res = match ty_res {\n+            Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias, did) => {\n+                debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n+                // Checks if item_name belongs to `impl SomeItem`\n+                let assoc_item = cx\n                     .tcx\n-                    .associated_items(did)\n-                    .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n-                    .map(|item| {\n-                        let kind = match item.kind {\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                            ty::AssocKind::Fn => {\n-                                if item.defaultness.has_value() {\n-                                    \"method\"\n+                    .inherent_impls(did)\n+                    .iter()\n+                    .flat_map(|&imp| {\n+                        cx.tcx.associated_items(imp).find_by_name_and_namespace(\n+                            cx.tcx,\n+                            Ident::with_dummy_span(item_name),\n+                            ns,\n+                            imp,\n+                        )\n+                    })\n+                    .map(|item| (item.kind, item.def_id))\n+                    // There should only ever be one associated item that matches from any inherent impl\n+                    .next()\n+                    // Check if item_name belongs to `impl SomeTrait for SomeItem`\n+                    // This gives precedence to `impl SomeItem`:\n+                    // Although having both would be ambiguous, use impl version for compat. sake.\n+                    // To handle that properly resolve() would have to support\n+                    // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                    .or_else(|| {\n+                        let kind =\n+                            resolve_associated_trait_item(did, module_id, item_name, ns, &self.cx);\n+                        debug!(\"got associated item kind {:?}\", kind);\n+                        kind\n+                    });\n+\n+                if let Some((kind, id)) = assoc_item {\n+                    let out = match kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    };\n+                    Some(if extra_fragment.is_some() {\n+                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n+                    } else {\n+                        // HACK(jynelson): `clean` expects the type, not the associated item.\n+                        // but the disambiguator logic expects the associated item.\n+                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                        self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n+                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                    })\n+                } else if ns == Namespace::ValueNS {\n+                    debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                    match cx.tcx.type_of(did).kind() {\n+                        ty::Adt(def, _) => {\n+                            let field = if def.is_enum() {\n+                                def.all_fields().find(|item| item.ident.name == item_name)\n+                            } else {\n+                                def.non_enum_variant()\n+                                    .fields\n+                                    .iter()\n+                                    .find(|item| item.ident.name == item_name)\n+                            };\n+                            field.map(|item| {\n+                                if extra_fragment.is_some() {\n+                                    let res = Res::Def(\n+                                        if def.is_enum() {\n+                                            DefKind::Variant\n+                                        } else {\n+                                            DefKind::Field\n+                                        },\n+                                        item.did,\n+                                    );\n+                                    Err(ErrorKind::AnchorFailure(\n+                                        AnchorFailure::RustdocAnchorConflict(res),\n+                                    ))\n                                 } else {\n-                                    \"tymethod\"\n+                                    Ok((\n+                                        ty_res,\n+                                        Some(format!(\n+                                            \"{}.{}\",\n+                                            if def.is_enum() { \"variant\" } else { \"structfield\" },\n+                                            item.ident\n+                                        )),\n+                                    ))\n                                 }\n-                            }\n-                        };\n-\n-                        if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                                ty_res,\n-                            )))\n-                        } else {\n-                            let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                            Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n+                            })\n                         }\n-                    }),\n-                _ => None,\n-            };\n-            res.unwrap_or_else(|| {\n-                if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                        _ => None,\n+                    }\n                 } else {\n-                    Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n+                    // We already know this isn't in ValueNS, so no need to check variant_field\n+                    return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n                 }\n-            })\n-        } else {\n-            debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(ResolutionFailure::NoParentItem.into())\n-        }\n+            }\n+            Res::Def(DefKind::Trait, did) => cx\n+                .tcx\n+                .associated_items(did)\n+                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                .map(|item| {\n+                    let kind = match item.kind {\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                        ty::AssocKind::Fn => {\n+                            if item.defaultness.has_value() {\n+                                \"method\"\n+                            } else {\n+                                \"tymethod\"\n+                            }\n+                        }\n+                    };\n+\n+                    if extra_fragment.is_some() {\n+                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n+                    } else {\n+                        let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                        Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n+                    }\n+                }),\n+            _ => None,\n+        };\n+        res.unwrap_or_else(|| {\n+            if ns == Namespace::ValueNS {\n+                self.variant_field(path_str, current_item, module_id, extra_fragment)\n+            } else {\n+                Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n+            }\n+        })\n     }\n \n     /// Used for reporting better errors.\n@@ -599,7 +570,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         ns: Namespace,\n         path_str: &str,\n-        base_node: Option<DefId>,\n+        module_id: DefId,\n         current_item: &Option<String>,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n@@ -616,11 +587,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n         // cannot be used for macro namespace\n         let check_full_res = |this: &Self, ns| {\n-            let result = this.resolve(path_str, ns, current_item, base_node, extra_fragment);\n+            let result = this.resolve(path_str, ns, current_item, module_id, extra_fragment);\n             check_full_res_inner(this, result.map(|(res, _)| res))\n         };\n         let check_full_res_macro = |this: &Self| {\n-            let result = this.macro_resolve(path_str, base_node);\n+            let result = this.macro_resolve(path_str, module_id);\n             check_full_res_inner(this, result.map_err(ErrorKind::from))\n         };\n         match ns {\n@@ -990,6 +961,23 @@ impl LinkCollector<'_, '_> {\n                 parent_node\n             };\n \n+            let module_id = if let Some(id) = base_node {\n+                id\n+            } else {\n+                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+                let err_kind = ResolutionFailure::NoParentItem.into();\n+                resolution_failure(\n+                    self,\n+                    &item,\n+                    path_str,\n+                    disambiguator,\n+                    dox,\n+                    link_range,\n+                    smallvec![err_kind],\n+                );\n+                return;\n+            };\n+\n             // replace `Self` with suitable item's parent name\n             if path_str.starts_with(\"Self::\") {\n                 if let Some(ref name) = parent_name {\n@@ -1004,7 +992,7 @@ impl LinkCollector<'_, '_> {\n                 dox,\n                 path_str,\n                 current_item,\n-                base_node,\n+                module_id,\n                 extra_fragment,\n                 &ori_link,\n                 link_range.clone(),\n@@ -1132,7 +1120,7 @@ impl LinkCollector<'_, '_> {\n         dox: &str,\n         path_str: &str,\n         current_item: &Option<String>,\n-        base_node: Option<DefId>,\n+        base_node: DefId,\n         extra_fragment: Option<String>,\n         ori_link: &str,\n         link_range: Option<Range<usize>>,\n@@ -1580,13 +1568,9 @@ fn resolution_failure(\n                                 break;\n                             }\n                         };\n-                        if let Some(res) = collector.check_full_res(\n-                            TypeNS,\n-                            &current,\n-                            Some(*module_id),\n-                            &None,\n-                            &None,\n-                        ) {\n+                        if let Some(res) =\n+                            collector.check_full_res(TypeNS, &current, *module_id, &None, &None)\n+                        {\n                             failure = ResolutionFailure::NoAssocItem(res, Symbol::intern(current));\n                             break;\n                         }"}]}