{"sha": "f7e3a4e036cbe84677a924548c2ecbb49b551265", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZTNhNGUwMzZjYmU4NDY3N2E5MjQ1NDhjMmVjYmI0OWI1NTEyNjU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-05T13:40:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: EADDRINUSE and EACCES err tests for tcp server + more cleanup\n\n.. confounded resolve!", "tree": {"sha": "fce8bcb3f6958560a8f83db9c88d634f2ad0ad85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fce8bcb3f6958560a8f83db9c88d634f2ad0ad85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7e3a4e036cbe84677a924548c2ecbb49b551265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e3a4e036cbe84677a924548c2ecbb49b551265", "html_url": "https://github.com/rust-lang/rust/commit/f7e3a4e036cbe84677a924548c2ecbb49b551265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7e3a4e036cbe84677a924548c2ecbb49b551265/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "235f6c7ab75f2f3e0506cca03c38b84f10e003a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/235f6c7ab75f2f3e0506cca03c38b84f10e003a0", "html_url": "https://github.com/rust-lang/rust/commit/235f6c7ab75f2f3e0506cca03c38b84f10e003a0"}], "stats": {"total": 600, "additions": 278, "deletions": 322}, "files": [{"sha": "b51058b24998e6a2b5caec2b9579e0135d71a12c", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 278, "deletions": 322, "changes": 600, "blob_url": "https://github.com/rust-lang/rust/blob/f7e3a4e036cbe84677a924548c2ecbb49b551265/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e3a4e036cbe84677a924548c2ecbb49b551265/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=f7e3a4e036cbe84677a924548c2ecbb49b551265", "patch": "@@ -23,8 +23,7 @@ export listen, accept;\n // tcp client stuff\n export connect;\n // helper methods\n-import methods = net_tcp_methods;\n-export methods;\n+export methods_tcp_socket;\n \n #[nolink]\n native mod rustrt {\n@@ -57,6 +56,38 @@ type tcp_err_data = {\n     err_name: str,\n     err_msg: str\n };\n+#[doc=\"\n+Details returned as part of a `result::err` result from `tcp::listen`\n+\"]\n+enum tcp_listen_err_data {\n+    #[doc=\"\n+    Some unplanned-for error. The first and second fields correspond\n+    to libuv's `err_name` and `err_msg` fields, respectively.\n+    \"]\n+    generic_listen_err(str, str),\n+    #[doc=\"\n+    Failed to bind to the requested IP/Port, because it is already in use.\n+\n+    # Possible Causes\n+\n+    * Attempting to bind to a port already bound to another listener\n+    \"]\n+    address_in_use,\n+    #[doc=\"\n+    Request to bind to an IP/Port was denied by the system.\n+\n+    # Possible Causes\n+\n+    * Attemping to binding to an IP/Port as a non-Administrator\n+      on Windows Vista+\n+    * Attempting to bind, as a non-priv'd\n+      user, to 'privileged' ports (< 1024) on *nix\n+    \"]\n+    access_denied\n+}\n+#[doc=\"\n+Details returned as part of a `result::err` result from `tcp::connect`\n+\"]\n enum tcp_connect_err_data {\n     #[doc=\"\n     Some unplanned-for error. The first and second fields correspond\n@@ -333,185 +364,6 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n }\n \n #[doc=\"\n-<<<<<<< HEAD\n-Bind to a given IP/port and listen for new connections\n-\n-# Arguments\n-\n-* `host_ip` - a `net::ip::ip_addr` representing a unique IP\n-(versions 4 or 6)\n-* `port` - a uint representing the port to listen on\n-* `backlog` - a uint representing the number of incoming connections\n-to cache in memory\n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n-\n-# Returns\n-\n-A `result` instance containing either a `tcp_conn_port` which can used\n-to listen for, and accept, new connections, or a `tcp_err_data` if\n-failure to create the tcp listener occurs\n-\"]\n-fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n-                iotask: iotask)\n-    -> result::result<tcp_conn_port, tcp_err_data> unsafe {\n-    let stream_closed_po = comm::port::<()>();\n-    let stream_closed_ch = comm::chan(stream_closed_po);\n-    let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n-                                                  tcp_err_data>>();\n-    let new_conn_ch = comm::chan(new_conn_po);\n-    // FIXME (#2656): This shared box should not be captured in the i/o\n-    // task Make it a unique pointer.\n-    let server_data: @tcp_conn_port_data = @{\n-        server_stream: uv::ll::tcp_t(),\n-        stream_closed_po: stream_closed_po,\n-        stream_closed_ch: stream_closed_ch,\n-        iotask: iotask,\n-        new_conn_po: new_conn_po,\n-        new_conn_ch: new_conn_ch\n-    };\n-    let server_data_ptr = ptr::addr_of(*server_data);\n-    let server_stream_ptr = ptr::addr_of((*server_data_ptr)\n-                                         .server_stream);\n-\n-    let setup_po = comm::port::<option<tcp_err_data>>();\n-    let setup_ch = comm::chan(setup_po);\n-    iotask::interact(iotask) {|loop_ptr|\n-        let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n-                                                   port);\n-        alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-          0i32 {\n-            alt uv::ll::tcp_bind(server_stream_ptr,\n-                                 ptr::addr_of(tcp_addr)) {\n-              0i32 {\n-                alt uv::ll::listen(server_stream_ptr,\n-                                   backlog as libc::c_int,\n-                                   tcp_nl_on_connection_cb) {\n-                  0i32 {\n-                    uv::ll::set_data_for_uv_handle(\n-                        server_stream_ptr,\n-                        server_data_ptr);\n-                    comm::send(setup_ch, none);\n-                  }\n-                  _ {\n-                    log(debug, \"failure to uv_listen()\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    comm::send(setup_ch, some(err_data));\n-                  }\n-                }\n-              }\n-              _ {\n-                log(debug, \"failure to uv_tcp_bind\");\n-                let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                comm::send(setup_ch, some(err_data));\n-              }\n-            }\n-          }\n-          _ {\n-            log(debug, \"failure to uv_tcp_init\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(setup_ch, some(err_data));\n-          }\n-        }\n-    };\n-    alt comm::recv(setup_po) {\n-      some(err_data) {\n-        // we failed to bind/list w/ libuv\n-        result::err(err_data.to_tcp_err())\n-      }\n-      none {\n-        result::ok(tcp_conn_port(server_data))\n-      }\n-    }\n-}\n-\n-#[doc=\"\n-Block on a `net::tcp::tcp_conn_port` until a new connection arrives\n-\n-This function behaves similarly to `comm::recv()`\n-\n-# Arguments\n-\n-* server_port -- a `net::tcp::tcp_conn_port` that you wish to listen\n-on for an incoming connection\n-\n-# Returns\n-\n-A `result` object containing a `net::tcp::tcp_socket`, ready for immediate\n-use, as the `ok` varient, or a `net::tcp::tcp_err_data` for the `err`\n-variant\n-\"]\n-fn conn_recv(server_port: tcp_conn_port)\n-    -> result::result<tcp_socket, tcp_err_data> {\n-    let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n-    let iotask = (*(server_port.conn_data)).iotask;\n-    let new_conn_result = comm::recv(new_conn_po);\n-    alt new_conn_result {\n-      ok(client_stream_ptr) {\n-        conn_port_new_tcp_socket(client_stream_ptr, iotask)\n-      }\n-      err(err_data) {\n-        result::err(err_data)\n-      }\n-    }\n-}\n-\n-#[doc=\"\n-Identical to `net::tcp::conn_recv`, but ran on a new task\n-\n-The recv'd tcp_socket is created with a new task on the current scheduler,\n-and given as a parameter to the provided callback\n-\n-# Arguments\n-\n-* `server_port` -- a `net::tcp::tcp_conn_port` that you wish to listen\n-on for an incoming connection\n-* `cb` -- a callback that will be ran, in a new task on the current scheduler,\n-once a new connection is recv'd. Its parameter:\n-  * A `result` object containing a `net::tcp::tcp_socket`, ready for immediate\n-    use, as the `ok` varient, or a `net::tcp::tcp_err_data` for the `err`\n-    variant\n-\"]\n-fn conn_recv_spawn(server_port: tcp_conn_port,\n-                   +cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n-    let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n-    let iotask = (*(server_port.conn_data)).iotask;\n-    let new_conn_result = comm::recv(new_conn_po);\n-    task::spawn {||\n-        let sock_create_result = alt new_conn_result {\n-          ok(client_stream_ptr) {\n-            conn_port_new_tcp_socket(client_stream_ptr, iotask)\n-          }\n-          err(err_data) {\n-            result::err(err_data)\n-          }\n-        };\n-        cb(sock_create_result);\n-    };\n-}\n-\n-#[doc=\"\n-Check if a `net::tcp::tcp_conn_port` has one-or-more pending, new connections\n-\n-This function behaves similarly to `comm::peek()`\n-\n-# Arguments\n-\n-* `server_port` -- a `net::tcp::tcp_conn_port` representing a server\n-connection\n-\n-# Returns\n-\n-`true` if there are one-or-more pending connections, `false` if there are\n-none.\n-\"]\n-fn conn_peek(server_port: tcp_conn_port) -> bool {\n-    let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n-    comm::peek(new_conn_po)\n-}\n-\n-#[doc=\"\n-=======\n->>>>>>> std: dump the tcp::new_listener server API\n Bind an incoming client connection to a `net::tcp::tcp_socket`\n \n # Notes\n@@ -681,7 +533,7 @@ fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n                                comm::chan<option<tcp_err_data>>))\n-    -> result::result<(), tcp_err_data> unsafe {\n+    -> result::result<(), tcp_listen_err_data> unsafe {\n     listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n         // on_connect_cb\n         {|handle|\n@@ -697,7 +549,7 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n-    -> result::result<(), tcp_err_data> unsafe {\n+    -> result::result<(), tcp_listen_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n     let kill_po = comm::port::<option<tcp_err_data>>();\n     let kill_ch = comm::chan(kill_po);\n@@ -719,16 +571,16 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n                                                        port);\n             alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n               0i32 {\n+                uv::ll::set_data_for_uv_handle(\n+                    server_stream_ptr,\n+                    server_data_ptr);\n                 alt uv::ll::tcp_bind(server_stream_ptr,\n                                      ptr::addr_of(tcp_addr)) {\n                   0i32 {\n                     alt uv::ll::listen(server_stream_ptr,\n                                        backlog as libc::c_int,\n                                        tcp_lfc_on_connection_cb) {\n                       0i32 {\n-                        uv::ll::set_data_for_uv_handle(\n-                            server_stream_ptr,\n-                            server_data_ptr);\n                         comm::send(setup_ch, none);\n                       }\n                       _ {\n@@ -756,8 +608,29 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     };\n     alt setup_result {\n       some(err_data) {\n-        // we failed to bind/list w/ libuv\n-        result::err(err_data.to_tcp_err())\n+        iotask::interact(iotask) {|loop_ptr|\n+            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr));\n+            (*server_data_ptr).active = false;\n+            uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+        };\n+        stream_closed_po.recv();\n+        alt err_data.err_name {\n+          \"EACCES\" {\n+            log(debug, \"Got EACCES error\");\n+            result::err(access_denied)\n+          }\n+          \"EADDRINUSE\" {\n+            log(debug, \"Got EADDRINUSE error\");\n+            result::err(address_in_use)\n+          }\n+          _ {\n+            log(debug, #fmt(\"Got '%s' '%s' libuv error\",\n+                            err_data.err_name, err_data.err_msg));\n+            result::err(\n+                generic_listen_err(err_data.err_name, err_data.err_msg))\n+          }\n+        }\n       }\n       none {\n         on_establish_cb(kill_ch);\n@@ -768,11 +641,12 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n             (*server_data_ptr).active = false;\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n-        comm::recv(stream_closed_po);\n+        stream_closed_po.recv();\n         alt kill_result {\n           // some failure post bind/listen\n           some(err_data) {\n-            result::err(err_data)\n+            result::err(generic_listen_err(err_data.err_name,\n+                                            err_data.err_msg))\n           }\n           // clean exit\n           none {\n@@ -783,35 +657,33 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     }\n }\n \n-mod net_tcp_methods {\n-    #[doc=\"\n-    Convenience methods extending `net::tcp::tcp_socket`\n-    \"]\n-    impl methods_tcp_socket for tcp_socket {\n-        fn read_start() -> result::result<comm::port<\n-            result::result<[u8]/~, tcp_err_data>>, tcp_err_data> {\n-            read_start(self)\n-        }\n-        fn read_stop() ->\n-            result::result<(), tcp_err_data> {\n-            read_stop(self)\n-        }\n-        fn read(timeout_msecs: uint) ->\n-            result::result<[u8]/~, tcp_err_data> {\n-            read(self, timeout_msecs)\n-        }\n-        fn read_future(timeout_msecs: uint) ->\n-            future::future<result::result<[u8]/~, tcp_err_data>> {\n-            read_future(self, timeout_msecs)\n-        }\n-        fn write(raw_write_data: [u8]/~)\n-            -> result::result<(), tcp_err_data> {\n-            write(self, raw_write_data)\n-        }\n-        fn write_future(raw_write_data: [u8]/~)\n-            -> future::future<result::result<(), tcp_err_data>> {\n-            write_future(self, raw_write_data)\n-        }\n+#[doc=\"\n+Convenience methods extending `net::tcp::tcp_socket`\n+\"]\n+impl methods_tcp_socket for tcp_socket {\n+    fn read_start() -> result::result<comm::port<\n+        result::result<[u8]/~, tcp_err_data>>, tcp_err_data> {\n+        read_start(self)\n+    }\n+    fn read_stop() ->\n+        result::result<(), tcp_err_data> {\n+        read_stop(self)\n+    }\n+    fn read(timeout_msecs: uint) ->\n+        result::result<[u8]/~, tcp_err_data> {\n+        read(self, timeout_msecs)\n+    }\n+    fn read_future(timeout_msecs: uint) ->\n+        future::future<result::result<[u8]/~, tcp_err_data>> {\n+        read_future(self, timeout_msecs)\n+    }\n+    fn write(raw_write_data: [u8]/~)\n+        -> result::result<(), tcp_err_data> {\n+        write(self, raw_write_data)\n+    }\n+    fn write_future(raw_write_data: [u8]/~)\n+        -> future::future<result::result<(), tcp_err_data>> {\n+        write_future(self, raw_write_data)\n     }\n }\n // INTERNAL API\n@@ -984,38 +856,6 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     }\n }\n \n-<<<<<<< HEAD\n-// various recv_* can use a tcp_conn_port can re-use this..\n-fn conn_port_new_tcp_socket(\n-    stream_handle_ptr: *uv::ll::uv_tcp_t,\n-    iotask: iotask)\n-    -> result::result<tcp_socket,tcp_err_data> unsafe {\n-    // tcp_nl_on_connection_cb\n-    let reader_po = comm::port::<result::result<[u8]/~, tcp_err_data>>();\n-    let client_socket_data = @{\n-        reader_po : reader_po,\n-        reader_ch : comm::chan(reader_po),\n-        stream_handle_ptr : stream_handle_ptr,\n-        connect_req : uv::ll::connect_t(),\n-        write_req : uv::ll::write_t(),\n-        iotask : iotask\n-    };\n-    let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n-    comm::listen {|cont_ch|\n-        iotask::interact(iotask) {|loop_ptr|\n-            log(debug, #fmt(\"in interact cb 4 conn_port_new_tcp.. loop %?\",\n-                loop_ptr));\n-            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                           client_socket_data_ptr);\n-            cont_ch.send(());\n-        };\n-        cont_ch.recv()\n-    };\n-    result::ok(tcp_socket(client_socket_data))\n-}\n-\n-=======\n->>>>>>> std: dump the tcp::new_listener server API\n enum tcp_new_connection {\n     new_tcp_conn(*uv::ll::uv_tcp_t)\n }\n@@ -1260,6 +1100,18 @@ mod test {\n             fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n                 impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n+            #[test]\n+            fn test_gl_tcp_server_address_in_use() unsafe {\n+                impl_gl_tcp_ipv4_server_address_in_use();\n+            }\n+            #[test]\n+            // FIXME: this probably needs to be ignored on windows.\n+            // ... need to verify (someday we'll have 64bit windows! :)\n+            //#[ignore(cfg(target_os = \"win32\"))]\n+            fn test_gl_tcp_server_access_denied() unsafe {\n+                impl_gl_tcp_ipv4_server_access_denied();\n+            }\n+\n         }\n         #[cfg(target_arch=\"x86\")]\n         mod impl32 {\n@@ -1273,6 +1125,19 @@ mod test {\n             fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n                 impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_server_address_in_use() unsafe {\n+                impl_gl_tcp_ipv4_server_address_in_use();\n+            }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            // FIXME: this probably needs to be ignored on windows.\n+            // ... need to verify\n+            //#[ignore(cfg(target_os = \"win32\"))]\n+            fn test_gl_tcp_server_access_denied() unsafe {\n+                impl_gl_tcp_ipv4_server_access_denied();\n+            }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_and_client() {\n@@ -1324,7 +1189,7 @@ mod test {\n     fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = uv::global_loop::get();\n         let server_ip = \"127.0.0.1\";\n-        let server_port = 8890u;\n+        let server_port = 8889u;\n         let expected_req = \"ping\";\n         // client\n         log(debug, \"firing up client..\");\n@@ -1344,85 +1209,181 @@ mod test {\n           }\n         }\n     }\n+    fn impl_gl_tcp_ipv4_server_address_in_use() {\n+        let hl_loop = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8890u;\n+        let expected_req = \"ping\";\n+        let expected_resp = \"pong\";\n+\n+        let server_result_po = comm::port::<str>();\n+        let server_result_ch = comm::chan(server_result_po);\n+\n+        let cont_po = comm::port::<()>();\n+        let cont_ch = comm::chan(cont_po);\n+        // server\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let actual_req = comm::listen {|server_ch|\n+                run_tcp_test_server(\n+                    server_ip,\n+                    server_port,\n+                    expected_resp,\n+                    server_ch,\n+                    cont_ch,\n+                    hl_loop)\n+            };\n+            server_result_ch.send(actual_req);\n+        };\n+        comm::recv(cont_po);\n+        // this one should fail..\n+        let listen_err = run_tcp_test_server_fail(\n+                            server_ip,\n+                            server_port,\n+                            hl_loop);\n+        // client.. just doing this so that the first server tears down\n+        log(debug, \"server started, firing up client..\");\n+        comm::listen {|client_ch|\n+            run_tcp_test_client(\n+                server_ip,\n+                server_port,\n+                expected_req,\n+                client_ch,\n+                hl_loop)\n+        };\n+        alt listen_err {\n+          address_in_use {\n+            assert true;\n+          }\n+          _ {\n+            fail \"expected address_in_use listen error,\"+\n+                      \"but got a different error varient. check logs.\";\n+          }\n+        }\n+    }\n+    fn impl_gl_tcp_ipv4_server_access_denied() {\n+        let hl_loop = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 80u;\n+        // this one should fail..\n+        let listen_err = run_tcp_test_server_fail(\n+                            server_ip,\n+                            server_port,\n+                            hl_loop);\n+        alt listen_err {\n+          access_denied {\n+            assert true;\n+          }\n+          _ {\n+            fail \"expected address_in_use listen error,\"+\n+                      \"but got a different error varient. check logs.\";\n+          }\n+        }\n+    }\n \n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n                           cont_ch: comm::chan<()>,\n                           iotask: iotask) -> str {\n-\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            let server_ip_addr = ip::v4::parse_addr(server_ip);\n-            let listen_result =\n-                listen(server_ip_addr, server_port, 128u,\n-                iotask,\n-                // on_establish_cb -- called when listener is set up\n-                {|kill_ch|\n-                    log(debug, #fmt(\"establish_cb %?\",\n-                        kill_ch));\n-                    comm::send(cont_ch, ());\n-                },\n-                // risky to run this on the loop, but some users\n-                // will want the POWER\n-                {|new_conn, kill_ch|\n-                log(debug, \"SERVER: new connection!\");\n-                comm::listen {|cont_ch|\n-                    task::spawn_sched(task::manual_threads(1u)) {||\n-                        log(debug, \"SERVER: starting worker for new req\");\n-\n-                        let accept_result = accept(new_conn);\n-                        log(debug, \"SERVER: after accept()\");\n-                        if result::is_err(accept_result) {\n-                            log(debug, \"SERVER: error accept connection\");\n-                            let err_data = result::get_err(accept_result);\n+        let server_ip_addr = ip::v4::parse_addr(server_ip);\n+        let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n+            // on_establish_cb -- called when listener is set up\n+            {|kill_ch|\n+                log(debug, #fmt(\"establish_cb %?\",\n+                    kill_ch));\n+                comm::send(cont_ch, ());\n+            },\n+            // risky to run this on the loop, but some users\n+            // will want the POWER\n+            {|new_conn, kill_ch|\n+            log(debug, \"SERVER: new connection!\");\n+            comm::listen {|cont_ch|\n+                task::spawn_sched(task::manual_threads(1u)) {||\n+                    log(debug, \"SERVER: starting worker for new req\");\n+\n+                    let accept_result = accept(new_conn);\n+                    log(debug, \"SERVER: after accept()\");\n+                    if result::is_err(accept_result) {\n+                        log(debug, \"SERVER: error accept connection\");\n+                        let err_data = result::get_err(accept_result);\n+                        comm::send(kill_ch, some(err_data));\n+                        log(debug,\n+                            \"SERVER/WORKER: send on err cont ch\");\n+                        cont_ch.send(());\n+                    }\n+                    else {\n+                        log(debug,\n+                            \"SERVER/WORKER: send on cont ch\");\n+                        cont_ch.send(());\n+                        let sock = result::unwrap(accept_result);\n+                        log(debug, \"SERVER: successfully accepted\"+\n+                            \"connection!\");\n+                        let received_req_bytes = read(sock, 0u);\n+                        alt received_req_bytes {\n+                          result::ok(data) {\n+                            server_ch.send(\n+                                str::from_bytes(data));\n+                            log(debug, \"SERVER: before write\");\n+                            tcp_write_single(sock, str::bytes(resp));\n+                            log(debug, \"SERVER: after write.. die\");\n+                            comm::send(kill_ch, none);\n+                          }\n+                          result::err(err_data) {\n+                            log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n+                                err_data.err_name, err_data.err_msg));\n                             comm::send(kill_ch, some(err_data));\n-                            log(debug,\n-                                \"SERVER/WORKER: send on err cont ch\");\n-                            cont_ch.send(());\n-                        }\n-                        else {\n-                            log(debug,\n-                                \"SERVER/WORKER: send on cont ch\");\n-                            cont_ch.send(());\n-                            let sock = result::unwrap(accept_result);\n-                            log(debug, \"SERVER: successfully accepted\"+\n-                                \"connection!\");\n-                            let received_req_bytes = read(sock, 0u);\n-                            alt received_req_bytes {\n-                              result::ok(data) {\n-                                server_ch.send(\n-                                    str::from_bytes(data));\n-                                log(debug, \"SERVER: before write\");\n-                                tcp_write_single(sock, str::bytes(resp));\n-                                log(debug, \"SERVER: after write.. die\");\n-                                comm::send(kill_ch, none);\n-                              }\n-                              result::err(err_data) {\n-                                log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n-                                    err_data.err_name, err_data.err_msg));\n-                                comm::send(kill_ch, some(err_data));\n-                                server_ch.send(\"\");\n-                              }\n-                            }\n-                            log(debug, \"SERVER: worker spinning down\");\n+                            server_ch.send(\"\");\n+                          }\n                         }\n+                        log(debug, \"SERVER: worker spinning down\");\n                     }\n-                    log(debug, \"SERVER: waiting to recv on cont_ch\");\n-                    cont_ch.recv()\n-                };\n-                log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n-            });\n-            // err check on listen_result\n-            if result::is_err(listen_result) {\n-                let err_data = result::get_err(listen_result);\n-                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                err_data.err_name, err_data.err_msg));\n+                }\n+                log(debug, \"SERVER: waiting to recv on cont_ch\");\n+                cont_ch.recv()\n+            };\n+            log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n+        });\n+        // err check on listen_result\n+        if result::is_err(listen_result) {\n+            alt result::get_err(listen_result) {\n+              generic_listen_err(name, msg) {\n+                fail #fmt(\"SERVER: exited abnormally name %s msg %s\",\n+                                name, msg);\n+              }\n+              access_denied {\n+                fail \"SERVER: exited abnormally, got access denied..\";\n+              }\n+              address_in_use {\n+                fail \"SERVER: exited abnormally, got address in use...\";\n+              }\n             }\n-        };\n+        }\n         let ret_val = server_ch.recv();\n         log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n         ret_val\n     }\n \n+    fn run_tcp_test_server_fail(server_ip: str, server_port: uint,\n+                          iotask: iotask) -> tcp_listen_err_data {\n+        let server_ip_addr = ip::v4::parse_addr(server_ip);\n+        let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n+            // on_establish_cb -- called when listener is set up\n+            {|kill_ch|\n+                log(debug, #fmt(\"establish_cb %?\",\n+                    kill_ch));\n+            },\n+            {|new_conn, kill_ch|\n+                fail #fmt(\"SERVER: shouldn't be called.. %? %?\",\n+                           new_conn, kill_ch);\n+        });\n+        // err check on listen_result\n+        if result::is_failure(listen_result) {\n+            result::get_err(listen_result)\n+        }\n+        else {\n+            fail \"SERVER: did not fail as expected\"\n+        }\n+    }\n+\n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n                           client_ch: comm::chan<str>,\n                           iotask: iotask) -> result::result<str,\n@@ -1455,13 +1416,8 @@ mod test {\n         }\n     }\n \n-<<<<<<< HEAD\n     fn tcp_write_single(sock: tcp_socket, val: [u8]/~) {\n         let write_result_future = sock.write_future(val);\n-=======\n-    fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n-        let write_result_future = write_future(sock, val);\n->>>>>>> std: mod cleanup, impl/test for conn. refused err + mem leak fix\n         let write_result = write_result_future.get();\n         if result::is_err(write_result) {\n             log(debug, \"tcp_write_single: write failed!\");"}]}