{"sha": "19dcecb2258dcbc6f02be9beac105b57fd43472f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZGNlY2IyMjU4ZGNiYzZmMDJiZTliZWFjMTA1YjU3ZmQ0MzQ3MmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-16T02:11:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T17:08:36Z"}, "message": "Refactor object-safety into its own (cached) module so that we can\ncheck it more easily; also extend object safety to cover sized types\nas well as static methods.  This makes it sufficient so that we can\nalways ensure that `Foo : Foo` holds for any trait `Foo`.", "tree": {"sha": "c07a4e631f2b9d9ea461cbc11838f8e2f35fe3a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07a4e631f2b9d9ea461cbc11838f8e2f35fe3a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19dcecb2258dcbc6f02be9beac105b57fd43472f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19dcecb2258dcbc6f02be9beac105b57fd43472f", "html_url": "https://github.com/rust-lang/rust/commit/19dcecb2258dcbc6f02be9beac105b57fd43472f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19dcecb2258dcbc6f02be9beac105b57fd43472f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c1d7a7caa279ae3dc284940eebf08cbac75df1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1d7a7caa279ae3dc284940eebf08cbac75df1e", "html_url": "https://github.com/rust-lang/rust/commit/2c1d7a7caa279ae3dc284940eebf08cbac75df1e"}], "stats": {"total": 871, "additions": 600, "deletions": 271}, "files": [{"sha": "d7d16556acdc476816eb44a4a92347a77aa94682", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -29,6 +29,10 @@ pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::normalize;\n pub use self::project::Normalized;\n+pub use self::object_safety::is_object_safe;\n+pub use self::object_safety::object_safety_violations;\n+pub use self::object_safety::ObjectSafetyViolation;\n+pub use self::object_safety::MethodViolationCode;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n@@ -45,6 +49,7 @@ mod coherence;\n mod error_reporting;\n mod fulfill;\n mod project;\n+mod object_safety;\n mod select;\n mod util;\n "}, {"sha": "203330437957e7cb8e4d19f59bfd541c9c524a9a", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -0,0 +1,302 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! \"Object safety\" refers to the ability for a trait to be converted\n+//! to an object. In general, traits may only be converted to an\n+//! object if all of their methods meet certain criteria. In particular,\n+//! they must:\n+//!\n+//!   - have a suitable receiver from which we can extract a vtable;\n+//!   - not reference the erased type `Self` except for in this receiver;\n+//!   - not have generic type parameters\n+\n+use super::supertraits;\n+use super::elaborate_predicates;\n+\n+use middle::subst::{mod, SelfSpace};\n+use middle::traits;\n+use middle::ty::{mod, Ty};\n+use std::rc::Rc;\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub enum ObjectSafetyViolation<'tcx> {\n+    /// Self : Sized declared on the trait\n+    SizedSelf,\n+\n+    /// Method has someting illegal\n+    Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n+}\n+\n+/// Reasons a method might not be object-safe.\n+#[deriving(Copy,Clone,Show)]\n+pub enum MethodViolationCode {\n+    /// fn(self),\n+    ByValueSelf,\n+\n+    // fn foo()\n+    StaticMethod,\n+\n+    // fn foo(&self, x: Self)\n+    // fn foo(&self) -> Self\n+    ReferencesSelf,\n+\n+    // fn foo<A>(),\n+    Generic,\n+}\n+\n+pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            -> bool\n+{\n+    // Because we query yes/no results frequently, we keep a cache:\n+    let cached_result =\n+        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).map(|&r| r);\n+\n+    let result =\n+        cached_result.unwrap_or_else(|| {\n+            let result = object_safety_violations(tcx, trait_ref.clone()).is_empty();\n+\n+            // Record just a yes/no result in the cache; this is what is\n+            // queried most frequently. Note that this may overwrite a\n+            // previous result, but always with the same thing.\n+            tcx.object_safety_cache.borrow_mut().insert(trait_ref.def_id(), result);\n+\n+            result\n+        });\n+\n+    debug!(\"is_object_safe({}) = {}\", trait_ref.repr(tcx), result);\n+\n+    result\n+}\n+\n+pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      sub_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      -> Vec<ObjectSafetyViolation<'tcx>>\n+{\n+    supertraits(tcx, sub_trait_ref)\n+        .flat_map(|tr| object_safety_violations_for_trait(tcx, tr.def_id()).into_iter())\n+        .collect()\n+}\n+\n+fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_def_id: ast::DefId)\n+                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+{\n+    // Check methods for violations.\n+    let mut violations: Vec<_> =\n+        ty::trait_items(tcx, trait_def_id).iter()\n+        .flat_map(|item| {\n+            match *item {\n+                ty::MethodTraitItem(ref m) => {\n+                    object_safety_violations_for_method(tcx, trait_def_id, &**m)\n+                        .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n+                        .into_iter()\n+                }\n+                ty::TypeTraitItem(_) => {\n+                    None.into_iter()\n+                }\n+            }\n+        })\n+        .collect();\n+\n+    // Check the trait itself.\n+    if trait_has_sized_self(tcx, trait_def_id) {\n+        violations.push(ObjectSafetyViolation::SizedSelf);\n+    }\n+\n+    debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n+           trait_def_id.repr(tcx),\n+           violations.repr(tcx));\n+\n+    violations\n+}\n+\n+fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              trait_def_id: ast::DefId)\n+                              -> bool\n+{\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let param_env = ty::construct_parameter_environment(tcx,\n+                                                        &trait_def.generics,\n+                                                        ast::DUMMY_NODE_ID);\n+    let predicates = param_env.caller_bounds.predicates.as_slice().to_vec();\n+    let sized_def_id = match tcx.lang_items.sized_trait() {\n+        Some(def_id) => def_id,\n+        None => { return false; /* No Sized trait, can't require it! */ }\n+    };\n+\n+    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    elaborate_predicates(tcx, predicates)\n+        .any(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                    let self_ty = trait_pred.0.self_ty();\n+                    match self_ty.sty {\n+                        ty::ty_param(ref data) => data.space == subst::SelfSpace,\n+                        _ => false,\n+                    }\n+                }\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::TypeOutlives(..) => {\n+                    false\n+                }\n+            }\n+        })\n+}\n+\n+fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                             trait_def_id: ast::DefId,\n+                                             method: &ty::Method<'tcx>)\n+                                             -> Option<MethodViolationCode>\n+{\n+    // The method's first parameter must be something that derefs to\n+    // `&self`. For now, we only accept `&self` and `Box<Self>`.\n+    match method.explicit_self {\n+        ty::ByValueExplicitSelfCategory => {\n+            return Some(MethodViolationCode::ByValueSelf);\n+        }\n+\n+        ty::StaticExplicitSelfCategory => {\n+            return Some(MethodViolationCode::StaticMethod);\n+        }\n+\n+        ty::ByReferenceExplicitSelfCategory(..) |\n+        ty::ByBoxExplicitSelfCategory => {\n+        }\n+    }\n+\n+    // The `Self` type is erased, so it should not appear in list of\n+    // arguments or return type apart from the receiver.\n+    let ref sig = method.fty.sig;\n+    for &input_ty in sig.0.inputs[1..].iter() {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n+        }\n+    }\n+    if let ty::FnConverging(result_type) = sig.0.output {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, result_type) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n+        }\n+    }\n+\n+    // We can't monomorphize things like `fn foo<A>(...)`.\n+    if !method.generics.types.is_empty_in(subst::FnSpace) {\n+        return Some(MethodViolationCode::Generic);\n+    }\n+\n+    None\n+}\n+\n+fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                              trait_def_id: ast::DefId,\n+                                              ty: Ty<'tcx>)\n+                                              -> bool\n+{\n+    // This is somewhat subtle. In general, we want to forbid\n+    // references to `Self` in the argument and return types,\n+    // since the value of `Self` is erased. However, there is one\n+    // exception: it is ok to reference `Self` in order to access\n+    // an associated type of the current trait, since we retain\n+    // the value of those associated types in the object type\n+    // itself.\n+    //\n+    // ```rust\n+    // trait SuperTrait {\n+    //     type X;\n+    // }\n+    //\n+    // trait Trait : SuperTrait {\n+    //     type Y;\n+    //     fn foo(&self, x: Self) // bad\n+    //     fn foo(&self) -> Self // bad\n+    //     fn foo(&self) -> Option<Self> // bad\n+    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as Trait>::Y // OK\n+    //     fn foo(&self) -> Self::X // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+    // }\n+    // ```\n+    //\n+    // However, it is not as simple as allowing `Self` in a projected\n+    // type, because there are illegal ways to use `Self` as well:\n+    //\n+    // ```rust\n+    // trait Trait : SuperTrait {\n+    //     ...\n+    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+    // }\n+    // ```\n+    //\n+    // Here we will not have the type of `X` recorded in the\n+    // object type, and we cannot resolve `Self as SomeOtherTrait`\n+    // without knowing what `Self` is.\n+\n+    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+    let mut error = false;\n+    ty::maybe_walk_ty(ty, |ty| {\n+        match ty.sty {\n+            ty::ty_param(ref param_ty) => {\n+                if param_ty.space == SelfSpace {\n+                    error = true;\n+                }\n+\n+                false // no contained types to walk\n+            }\n+\n+            ty::ty_projection(ref data) => {\n+                // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                // Compute supertraits of current trait lazilly.\n+                if supertraits.is_none() {\n+                    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                    let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+                }\n+\n+                // Determine whether the trait reference `Foo as\n+                // SomeTrait` is in fact a supertrait of the\n+                // current trait. In that case, this type is\n+                // legal, because the type `X` will be specified\n+                // in the object type.  Note that we can just use\n+                // direct equality here because all of these types\n+                // are part of the formal parameter listing, and\n+                // hence there should be no inference variables.\n+                let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                let is_supertrait_of_current_trait =\n+                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                if is_supertrait_of_current_trait {\n+                    false // do not walk contained types, do not report error, do collect $200\n+                } else {\n+                    true // DO walk contained types, POSSIBLY reporting an error\n+                }\n+            }\n+\n+            _ => true, // walk contained types, if any\n+        }\n+    });\n+\n+    error\n+}\n+\n+impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf =>\n+                format!(\"SizedSelf\"),\n+            ObjectSafetyViolation::Method(ref m, code) =>\n+                format!(\"Method({},{})\", m.repr(tcx), code),\n+        }\n+    }\n+}"}, {"sha": "89a2f94aa044266105834d7b40c1b39fb916502a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -827,6 +827,9 @@ pub struct ctxt<'tcx> {\n     /// parameters are never placed into this cache, because their\n     /// results are dependent on the parameter environment.\n     pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+\n+    /// Caches whether traits are object safe\n+    pub object_safety_cache: RefCell<DefIdMap<bool>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2384,6 +2387,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n+        object_safety_cache: RefCell::new(DefIdMap::new()),\n    }\n }\n "}, {"sha": "a046d9d5d39c5e5323fc2c4e5fbfc6383173f269", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -141,7 +141,7 @@ impl PpSourceMode {\n     }\n }\n \n-trait PrinterSupport<'ast>: pprust::PpAnn + Sized {\n+trait PrinterSupport<'ast>: pprust::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n     fn sess<'a>(&'a self) -> &'a Session;\n@@ -154,7 +154,7 @@ trait PrinterSupport<'ast>: pprust::PpAnn + Sized {\n     ///\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n }\n \n struct NoAnn<'ast> {\n@@ -168,6 +168,8 @@ impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n@@ -183,6 +185,8 @@ impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n@@ -232,6 +236,8 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n@@ -265,6 +271,8 @@ impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n         Some(&self.analysis.ty_cx.map)\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {"}, {"sha": "65f8ee4990861a224c71ed44780f60a6f6f03f5a", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 76, "deletions": 199, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -10,7 +10,7 @@\n \n use check::{FnCtxt, structurally_resolved_type};\n use middle::subst::{FnSpace, SelfSpace};\n-use middle::traits;\n+use middle::traits::{mod, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{mod, Ty, AsPredicate};\n@@ -133,217 +133,56 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    // Also check that the type `object_trait` specifies all\n-    // associated types for all supertraits.\n-    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> = FnvHashSet::new();\n-\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n-    for tr in traits::supertraits(tcx, object_trait_ref.clone()) {\n-        check_object_safety_inner(tcx, &tr, span);\n-\n-        let trait_def = ty::lookup_trait_def(tcx, object_trait_ref.def_id());\n-        for &associated_type_name in trait_def.associated_type_names.iter() {\n-            associated_types.insert((object_trait_ref.def_id(), associated_type_name));\n-        }\n-    }\n \n-    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n-        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n-                    projection_bound.0.projection_ty.item_name);\n-        associated_types.remove(&pair);\n+    if traits::is_object_safe(tcx, object_trait_ref.clone()) {\n+        return;\n     }\n \n-    for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n-    }\n-}\n-\n-fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                   object_trait: &ty::PolyTraitRef<'tcx>,\n-                                   span: Span) {\n-    let trait_items = ty::trait_items(tcx, object_trait.def_id());\n-\n-    let mut errors = Vec::new();\n-    for item in trait_items.iter() {\n-        match *item {\n-            ty::MethodTraitItem(ref m) => {\n-                errors.push(check_object_safety_of_method(tcx, object_trait, &**m))\n+    span_err!(tcx.sess, span, E0038,\n+              \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+              ty::item_path_str(tcx, object_trait_ref.def_id()));\n+\n+    let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n+    for violation in violations.into_iter() {\n+        match violation {\n+            ObjectSafetyViolation::SizedSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot require that `Self : Sized`\");\n             }\n-            ty::TypeTraitItem(_) => {}\n-        }\n-    }\n-\n-    let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n-    if errors.peek().is_some() {\n-        let trait_name = ty::item_path_str(tcx, object_trait.def_id());\n-        span_err!(tcx.sess, span, E0038,\n-            \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-            trait_name);\n-\n-        for msg in errors {\n-            tcx.sess.note(msg[]);\n-        }\n-    }\n \n-    /// Returns a vec of error messages. If the vec is empty - no errors!\n-    ///\n-    /// There are some limitations to calling functions through an object, because (a) the self\n-    /// type is not known (that's the whole point of a trait instance, after all, to obscure the\n-    /// self type), (b) the call must go through a vtable and hence cannot be monomorphized and\n-    /// (c) the trait contains static methods which can't be called because we don't know the\n-    /// concrete type.\n-    fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                           object_trait: &ty::PolyTraitRef<'tcx>,\n-                                           method: &ty::Method<'tcx>)\n-                                           -> Vec<String> {\n-        let mut msgs = Vec::new();\n-\n-        let method_name = method.name.repr(tcx);\n-\n-        match method.explicit_self {\n-            ty::ByValueExplicitSelfCategory => { // reason (a) above\n-                msgs.push(format!(\"cannot call a method (`{}`) with a by-value \\\n-                                   receiver through a trait object\", method_name))\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::ByValueSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has a receiver type of `Self`, \\\n+                             which cannot be used with a trait object\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n \n-            ty::StaticExplicitSelfCategory => {\n-                // Static methods are never object safe (reason (c)).\n-                msgs.push(format!(\"cannot call a static method (`{}`) \\\n-                                   through a trait object\",\n-                                  method_name));\n-                return msgs;\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has no receiver\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {}\n-        }\n \n-        // reason (a) above\n-        let check_for_self_ty = |&: ty| {\n-            if contains_illegal_self_type_reference(tcx, object_trait.def_id(), ty) {\n-                Some(format!(\n-                    \"cannot call a method (`{}`) whose type contains \\\n-                     a self-type (`{}`) through a trait object\",\n-                    method_name, ty.user_string(tcx)))\n-            } else {\n-                None\n-            }\n-        };\n-        let ref sig = method.fty.sig;\n-        for &input_ty in sig.0.inputs[1..].iter() {\n-            if let Some(msg) = check_for_self_ty(input_ty) {\n-                msgs.push(msg);\n-            }\n-        }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            if let Some(msg) = check_for_self_ty(result_type) {\n-                msgs.push(msg);\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::ReferencesSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` references the `Self` type \\\n+                             in its arguments or return type\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-        }\n-\n-        if method.generics.has_type_params(FnSpace) {\n-            // reason (b) above\n-            msgs.push(format!(\"cannot call a generic method (`{}`) through a trait object\",\n-                              method_name));\n-        }\n-\n-        msgs\n-    }\n \n-    fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                  trait_def_id: ast::DefId,\n-                                                  ty: Ty<'tcx>)\n-                                                  -> bool\n-    {\n-        // This is somewhat subtle. In general, we want to forbid\n-        // references to `Self` in the argument and return types,\n-        // since the value of `Self` is erased. However, there is one\n-        // exception: it is ok to reference `Self` in order to access\n-        // an associated type of the current trait, since we retain\n-        // the value of those associated types in the object type\n-        // itself.\n-        //\n-        // ```rust\n-        // trait SuperTrait {\n-        //     type X;\n-        // }\n-        //\n-        // trait Trait : SuperTrait {\n-        //     type Y;\n-        //     fn foo(&self, x: Self) // bad\n-        //     fn foo(&self) -> Self // bad\n-        //     fn foo(&self) -> Option<Self> // bad\n-        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as Trait>::Y // OK\n-        //     fn foo(&self) -> Self::X // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-        // }\n-        // ```\n-        //\n-        // However, it is not as simple as allowing `Self` in a projected\n-        // type, because there are illegal ways to use `Self` as well:\n-        //\n-        // ```rust\n-        // trait Trait : SuperTrait {\n-        //     ...\n-        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-        // }\n-        // ```\n-        //\n-        // Here we will not have the type of `X` recorded in the\n-        // object type, and we cannot resolve `Self as SomeOtherTrait`\n-        // without knowing what `Self` is.\n-\n-        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-        let mut error = false;\n-        ty::maybe_walk_ty(ty, |ty| {\n-            match ty.sty {\n-                ty::ty_param(ref param_ty) => {\n-                    if param_ty.space == SelfSpace {\n-                        error = true;\n-                    }\n-\n-                    false // no contained types to walk\n-                }\n-\n-                ty::ty_projection(ref data) => {\n-                    // This is a projected type `<Foo as SomeTrait>::X`.\n-\n-                    // Compute supertraits of current trait lazilly.\n-                    if supertraits.is_none() {\n-                        let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n-                        supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n-                    }\n-\n-                    // Determine whether the trait reference `Foo as\n-                    // SomeTrait` is in fact a supertrait of the\n-                    // current trait. In that case, this type is\n-                    // legal, because the type `X` will be specified\n-                    // in the object type.  Note that we can just use\n-                    // direct equality here because all of these types\n-                    // are part of the formal parameter listing, and\n-                    // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n-                    let is_supertrait_of_current_trait =\n-                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                    if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n-                    } else {\n-                        true // DO walk contained types, POSSIBLY reporting an error\n-                    }\n-                }\n-\n-                _ => true, // walk contained types, if any\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::Generic) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has generic type parameters\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-        });\n-\n-        error\n+        }\n     }\n }\n \n@@ -392,7 +231,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             cause.clone());\n     }\n \n-    // Finally, create obligations for the projection predicates.\n+    // Create obligations for the projection predicates.\n     let projection_bounds =\n         object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n     for projection_bound in projection_bounds.iter() {\n@@ -401,9 +240,47 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.register_predicate(projection_obligation);\n     }\n \n+    // Finally, check that there IS a projection predicate for every associated type.\n+    check_object_type_binds_all_associated_types(fcx.tcx(),\n+                                                 span,\n+                                                 object_trait);\n+\n     object_trait_ref\n }\n \n+fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                      span: Span,\n+                                                      object_trait: &ty::TyTrait<'tcx>)\n+{\n+    let object_trait_ref =\n+        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+\n+    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n+        traits::supertraits(tcx, object_trait_ref.clone())\n+        .flat_map(|tr| {\n+            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n+            trait_def.associated_type_names\n+                .clone()\n+                .into_iter()\n+                .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n+        })\n+        .collect();\n+\n+    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n+                    projection_bound.0.projection_ty.item_name);\n+        associated_types.remove(&pair);\n+    }\n+\n+    for (trait_def_id, name) in associated_types.into_iter() {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+                    name.user_string(tcx),\n+                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+    }\n+}\n+\n pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n "}, {"sha": "1a792eb6e76aedacc37ded3d389835d73f060221", "filename": "src/test/compile-fail/issue-18959.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -21,6 +21,6 @@ impl Foo for Thing {\n \n fn main() {\n     let mut thing = Thing;\n-    let test: &Bar = &mut thing; //~ ERROR cannot convert to a trait object because trait `Foo`\n+    let test: &Bar = &mut thing; //~ ERROR cannot convert to a trait object\n     foo(test);\n }"}, {"sha": "5ebcc8516ca0516610c34ab2d470b2674c8c7136", "filename": "src/test/compile-fail/object-safety-by-value-self.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits with a `fn(self)` method.\n+\n+trait Bar {\n+    fn bar(self);\n+}\n+\n+trait Baz {\n+    fn baz(self: Self);\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has a receiver type of `Self`\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has a receiver type of `Self`\n+}\n+\n+fn make_baz<T:Baz>(t: &T) -> &Baz {\n+    t\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `baz` has a receiver type of `Self`\n+}\n+\n+fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n+    t as &Baz\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `baz` has a receiver type of `Self`\n+}\n+\n+fn main() {\n+}"}, {"sha": "0ca706404c1f309028b36775d7d3d16daa237841", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "renamed", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -8,19 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that object-safe methods are identified as such.\n+// Check that we correctly prevent users from making trait objects\n+// from traits with generic methods.\n \n-trait Tr {\n-    fn foo(&self);\n+trait Bar {\n+    fn bar<T>(&self, t: T);\n }\n \n-struct St;\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has generic type parameters\n+}\n \n-impl Tr for St {\n-    fn foo(&self) {}\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has generic type parameters\n }\n \n fn main() {\n-    let s: &Tr = &St;\n-    s.foo();\n }", "previous_filename": "src/test/run-pass/trait-object-safety.rs"}, {"sha": "df0f44c1391580898084e7484bf3d06e75686225", "filename": "src/test/compile-fail/object-safety-mentions-Self.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// form traits that make use of `Self` in an argument or return position.\n+\n+trait Bar {\n+    fn bar(&self, x: &Self);\n+}\n+\n+trait Baz {\n+    fn bar(&self) -> Self;\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn make_baz<T:Baz>(t: &T) -> &Baz {\n+    t\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n+    t as &Baz\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn main() {\n+}"}, {"sha": "6a010d49692d26450a4d95225eb3695c4509b0cd", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits with static methods.\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+fn foo_implicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n+    b\n+        //~^ ERROR cannot convert to a trait object\n+        //~| NOTE method `foo` has no receiver\n+}\n+\n+fn foo_explicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n+    b as Box<Foo>\n+        //~^ ERROR cannot convert to a trait object\n+        //~| NOTE method `foo` has no receiver\n+}\n+\n+fn main() {\n+}"}, {"sha": "3a02461bbb223c177d43599f8d74abf380e1cb01", "filename": "src/test/compile-fail/object-safety-sized-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits where `Self : Sized`.\n+\n+trait Bar\n+    where Self : Sized\n+{\n+    fn bar<T>(&self, t: T);\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn main() {\n+}"}, {"sha": "bc214f6f3d9623ca30c1fcc8257b5cb68143c810", "filename": "src/test/compile-fail/object-safety-sized.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dcecb2258dcbc6f02be9beac105b57fd43472f/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs?ref=19dcecb2258dcbc6f02be9beac105b57fd43472f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits where `Self : Sized`.\n+\n+trait Bar : Sized {\n+    fn bar<T>(&self, t: T);\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn main() {\n+}"}, {"sha": "88b907a5cb965538e59ece6e7977b932861b1016", "filename": "src/test/compile-fail/trait-objects.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2c1d7a7caa279ae3dc284940eebf08cbac75df1e/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1d7a7caa279ae3dc284940eebf08cbac75df1e/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs?ref=2c1d7a7caa279ae3dc284940eebf08cbac75df1e", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Foo {\n-    fn foo(self);\n-}\n-\n-trait Bar {\n-    fn bar(&self, x: &Self);\n-}\n-\n-trait Baz {\n-    fn baz<T>(&self, x: &T);\n-}\n-\n-impl Foo for int {\n-    fn foo(self) {}\n-}\n-\n-impl Bar for int {\n-    fn bar(&self, _x: &int) {}\n-}\n-\n-impl Baz for int {\n-    fn baz<T>(&self, _x: &T) {}\n-}\n-\n-fn main() {\n-    let _: &Foo = &42i; //~ ERROR cannot convert to a trait object\n-    let _: &Bar = &42i; //~ ERROR cannot convert to a trait object\n-    let _: &Baz = &42i; //~ ERROR cannot convert to a trait object\n-\n-    let _ = &42i as &Foo; //~ ERROR cannot convert to a trait object\n-    let _ = &42i as &Bar; //~ ERROR cannot convert to a trait object\n-    let _ = &42i as &Baz; //~ ERROR cannot convert to a trait object\n-}"}, {"sha": "bd57a3956c76dab9c80ebe33f0a3891b7255121c", "filename": "src/test/run-pass/issue-7320.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c1d7a7caa279ae3dc284940eebf08cbac75df1e/src%2Ftest%2Frun-pass%2Fissue-7320.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1d7a7caa279ae3dc284940eebf08cbac75df1e/src%2Ftest%2Frun-pass%2Fissue-7320.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7320.rs?ref=2c1d7a7caa279ae3dc284940eebf08cbac75df1e", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-trait Foo : Sized {\n-    fn foo(self: Box<Self>) { bar(self as Box<Foo>); }\n-}\n-\n-fn bar(_b: Box<Foo>) { }\n-\n-fn main() {}"}]}