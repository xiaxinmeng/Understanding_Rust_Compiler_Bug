{"sha": "4c4a5f734d300a8e2dffe43c0c391e7317c47bc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNGE1ZjczNGQzMDBhOGUyZGZmZTQzYzBjMzkxZTczMTdjNDdiYzY=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-24T09:29:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-24T22:08:48Z"}, "message": "Reorganizing str.rs to group and document strings better (no functional changes, though FIXMEs added)", "tree": {"sha": "c449ee2abbb7b19d5ab00d98efb59dad3f963b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c449ee2abbb7b19d5ab00d98efb59dad3f963b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c4a5f734d300a8e2dffe43c0c391e7317c47bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4a5f734d300a8e2dffe43c0c391e7317c47bc6", "html_url": "https://github.com/rust-lang/rust/commit/4c4a5f734d300a8e2dffe43c0c391e7317c47bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c4a5f734d300a8e2dffe43c0c391e7317c47bc6/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19cd9686e767f7ad686b9f0a1fb05426f9adec99", "url": "https://api.github.com/repos/rust-lang/rust/commits/19cd9686e767f7ad686b9f0a1fb05426f9adec99", "html_url": "https://github.com/rust-lang/rust/commit/19cd9686e767f7ad686b9f0a1fb05426f9adec99"}], "stats": {"total": 1563, "additions": 862, "deletions": 701}, "files": [{"sha": "823f7cc78c6b2ca86f73b7d95b514126db9d5dec", "filename": "src/libcore/str.rs", "status": "modified", "additions": 862, "deletions": 701, "changes": 1563, "blob_url": "https://github.com/rust-lang/rust/blob/4c4a5f734d300a8e2dffe43c0c391e7317c47bc6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c4a5f734d300a8e2dffe43c0c391e7317c47bc6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4c4a5f734d300a8e2dffe43c0c391e7317c47bc6", "patch": "@@ -1,189 +1,139 @@\n /*\n Module: str\n \n-String manipulation.\n-*/\n-\n-export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n-       byte_len_range, index,\n-       rindex, find, starts_with, ends_with, substr, slice, split, splitn,\n-       split_str, split_func, split_char, lines, lines_any, words,\n-       concat, connect, to_lower, to_upper, replace, char_slice,\n-       trim_left, trim_right, trim, unshift_char, shift_char, pop_char,\n-       push_char, is_utf8, from_chars, to_chars, char_len, char_len_range,\n-       char_at, bytes, is_ascii, shift_byte, pop_byte,\n-       unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n-       from_bytes,\n-       from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n-       contains, iter_chars, chars_iter, bytes_iter, words_iter, lines_iter,\n-       loop_chars, loop_chars_sub, escape, any, all, map, windowed;\n+String manipulation\n+\n+Strings are a packed UTF-8 representation of text, stored as null terminated\n+buffers of u8 bytes.  Strings should be considered by character,\n+for correctness, but some UTF-8 unsafe functions are also provided.\n+For some heavy-duty uses, we recommend trying std::rope.\n+*/\n+\n+export\n+   // Creating a string\n+   from_bytes,\n+   unsafe_from_bytes,\n+   unsafe_from_byte,\n+   //push_utf8_bytes,\n+   from_char,\n+   from_chars,\n+   from_cstr,\n+   concat,\n+   connect,\n+\n+   // Adding things to and removing things from a string\n+   push_char,\n+   pop_char,\n+   shift_char,\n+   unshift_char,\n+   push_byte,\n+   //push_bytes,\n+   pop_byte,\n+   shift_byte,\n+   trim_left,\n+   trim_right,\n+   trim,\n+\n+   // Transforming strings\n+   bytes,\n+   to_chars,\n+   substr,\n+   char_slice,\n+   slice,\n+   safe_slice,\n+   split,\n+   splitn,\n+   split_str,\n+   split_func,\n+   split_char,\n+   lines,\n+   lines_any,\n+   words,\n+   windowed,\n+   to_lower,\n+   to_upper,\n+   replace,\n+   escape,\n+\n+   // Comparing strings\n+   eq,\n+   lteq,\n+   hash,\n+\n+   // Iterating through strings\n+   loop_chars,\n+   all,\n+   any,\n+   map,\n+   bytes_iter,\n+   iter_chars,\n+   chars_iter,\n+   words_iter,\n+   lines_iter,\n+\n+   // Searching\n+   index,\n+   rindex,\n+   find,\n+   contains,\n+   starts_with,\n+   ends_with,\n+\n+   // String properties\n+   is_ascii,\n+   is_empty,\n+   is_not_empty,\n+   is_whitespace,\n+   byte_len,\n+   char_len,\n+\n+   // Misc\n+   // FIXME: perhaps some more of this section shouldn't be exported?\n+   is_utf8,\n+   char_len_range,\n+   byte_len_range,\n+   utf8_char_width,\n+   char_range_at,\n+   char_at,\n+   loop_chars_sub,\n+   escape_char,\n+   as_buf,\n+   //buf,\n+   sbuf;\n+\n+\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn rust_str_push(&s: str, ch: u8);\n }\n \n-/*\n-Function: eq\n-\n-Bytewise string equality\n-*/\n-pure fn eq(&&a: str, &&b: str) -> bool { a == b }\n-\n-/*\n-Function: lteq\n-\n-Bytewise less than or equal\n-*/\n-pure fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n-\n-/*\n-Function: hash\n-\n-String hash function\n-*/\n-fn hash(&&s: str) -> uint {\n-    // djb hash.\n-    // FIXME: replace with murmur.\n-\n-    let u: uint = 5381u;\n-    for c: u8 in s { u *= 33u; u += c as uint; }\n-    ret u;\n-}\n-\n-// UTF-8 tags and ranges\n-const tag_cont_u8: u8 = 128u8;\n-const tag_cont: uint = 128u;\n-const max_one_b: uint = 128u;\n-const tag_two_b: uint = 192u;\n-const max_two_b: uint = 2048u;\n-const tag_three_b: uint = 224u;\n-const max_three_b: uint = 65536u;\n-const tag_four_b: uint = 240u;\n-const max_four_b: uint = 2097152u;\n-const tag_five_b: uint = 248u;\n-const max_five_b: uint = 67108864u;\n-const tag_six_b: uint = 252u;\n-\n-/*\n-Function: is_utf8\n-\n-Determines if a vector uf bytes contains valid UTF-8\n-*/\n-fn is_utf8(v: [u8]) -> bool {\n-    let i = 0u;\n-    let total = vec::len::<u8>(v);\n-    while i < total {\n-        let chsize = utf8_char_width(v[i]);\n-        if chsize == 0u { ret false; }\n-        if i + chsize > total { ret false; }\n-        i += 1u;\n-        while chsize > 1u {\n-            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n-            i += 1u;\n-            chsize -= 1u;\n-        }\n-    }\n-    ret true;\n-}\n-\n-/*\n-Function: is_ascii\n-\n-Determines if a string contains only ASCII characters\n-*/\n-fn is_ascii(s: str) -> bool {\n-    let i: uint = byte_len(s);\n-    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n-    ret true;\n-}\n-\n-/*\n-Predicate: is_empty\n-\n-Returns true if the string has length 0\n-*/\n-pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n-\n-/*\n-Predicate: is_not_empty\n-\n-Returns true if the string has length greater than 0\n-*/\n-pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n-\n-/*\n-Function: is_whitespace\n-\n-Returns true if the string contains only whitespace\n-*/\n-fn is_whitespace(s: str) -> bool {\n-    ret loop_chars(s, char::is_whitespace);\n-}\n-\n-/*\n-Function: byte_len\n-\n-Returns the length in bytes of a string\n-*/\n-pure fn byte_len(s: str) -> uint unsafe {\n-    let v: [u8] = unsafe::reinterpret_cast(s);\n-    let vlen = vec::len(v);\n-    unsafe::leak(v);\n-    // There should always be a null terminator\n-    assert (vlen > 0u);\n-    ret vlen - 1u;\n-}\n+// FIXME: add pure to a lot of functions\n \n /*\n-Function: byte_len_range\n-\n-As byte_len but for a substring\n-\n-Parameters:\n-s - A string\n-byte_offset - The byte offset at which to start in the string\n-char_len    - The number of chars (not bytes!) in the range\n-\n-Returns:\n-The number of bytes in the substring starting at `byte_offset` and\n-containing `char_len` chars.\n-\n-Safety note:\n-\n-This function fails if `byte_offset` or `char_len` do not represent\n-valid positions in `s`\n+Section: Creating a string\n */\n-fn byte_len_range(s: str, byte_offset: uint, char_len: uint) -> uint {\n-    let i = byte_offset;\n-    let chars = 0u;\n-    while chars < char_len {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n-        i += chsize;\n-        chars += 1u;\n-    }\n-    ret i - byte_offset;\n-}\n \n /*\n-Function: bytes\n+Function: from_bytes\n \n-Converts a string to a vector of bytes. The result vector is not\n-null-terminated.\n+Safely convert a vector of bytes to a UTF-8 string, or error\n */\n-fn bytes(s: str) -> [u8] unsafe {\n-    let v = unsafe::reinterpret_cast(s);\n-    let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n-    unsafe::leak(v);\n-    ret vcopy;\n+fn from_bytes(vv: [u8]) -> result::t<str, str> {\n+   if is_utf8(vv) {\n+      ret result::ok(unsafe_from_bytes(vv));\n+   } else {\n+      ret result::err(\"vector doesn't contain valid UTF-8\");\n+   }\n }\n \n /*\n Function: unsafe_from_bytes\n \n Converts a vector of bytes to a string. Does not verify that the\n vector contains valid UTF-8.\n+\n+// FIXME: remove?\n */\n fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n     let vcopy: [u8] = v + [0u8];\n@@ -192,24 +142,13 @@ fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n     ret scopy;\n }\n \n-/*\n-Function: from_bytes\n-\n-Safely convert a vector of bytes to a UTF-8 string, or error\n-*/\n-fn from_bytes(vv: [u8]) -> result::t<str, str> {\n-   if is_utf8(vv) {\n-      ret result::ok(unsafe_from_bytes(vv));\n-   } else {\n-      ret result::err(\"vector doesn't contain valid UTF-8\");\n-   }\n-}\n-\n /*\n Function: unsafe_from_byte\n \n Converts a byte to a string. Does not verify that the byte is\n valid UTF-8.\n+\n+FIXME: rename to 'from_byte'\n */\n fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n@@ -265,237 +204,219 @@ fn from_chars(chs: [char]) -> str {\n }\n \n /*\n-Function: utf8_char_width\n+Function: from_cstr\n \n-Given a first byte, determine how many bytes are in this UTF-8 character\n+Create a Rust string from a null-terminated C string\n */\n-pure fn utf8_char_width(b: u8) -> uint {\n-    let byte: uint = b as uint;\n-    if byte < 128u { ret 1u; }\n-    if byte < 192u {\n-        ret 0u; // Not a valid start byte\n-\n+unsafe fn from_cstr(cstr: sbuf) -> str {\n+    let res = \"\";\n+    let start = cstr;\n+    let curr = start;\n+    let i = 0u;\n+    while *curr != 0u8 {\n+        push_byte(res, *curr);\n+        i += 1u;\n+        curr = ptr::offset(start, i);\n     }\n-    if byte < 224u { ret 2u; }\n-    if byte < 240u { ret 3u; }\n-    if byte < 248u { ret 4u; }\n-    if byte < 252u { ret 5u; }\n-    ret 6u;\n+    ret res;\n }\n \n /*\n-Function: char_range_at\n+Function: concat\n \n-Pluck a character out of a string and return the index of the next character.\n-This function can be used to iterate over the unicode characters of a string.\n+Concatenate a vector of strings\n+*/\n+fn concat(v: [str]) -> str {\n+    let s: str = \"\";\n+    for ss: str in v { s += ss; }\n+    ret s;\n+}\n \n-Example:\n-> let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-> let i = 0u;\n-> while i < str::byte_len(s) {\n->    let {ch, next} = str::char_range_at(s, i);\n->    std::io::println(#fmt(\"%u: %c\",i,ch));\n->    i = next;\n-> }\n+/*\n+Function: connect\n \n-Example output:\n+Concatenate a vector of strings, placing a given separator between each\n+*/\n+fn connect(v: [str], sep: str) -> str {\n+    let s: str = \"\";\n+    let first: bool = true;\n+    for ss: str in v {\n+        if first { first = false; } else { s += sep; }\n+        s += ss;\n+    }\n+    ret s;\n+}\n \n-      0: \u4e2d\n-      3: \u534e\n-      6: V\n-      7: i\n-      8: \u1ec7\n-      11: t\n-      12:\n-      13: N\n-      14: a\n-      15: m\n+/*\n+Section: Adding to and removing from a string\n+*/\n \n-Parameters:\n+/*\n+Function: push_char\n \n-s - The string\n-i - The byte offset of the char to extract\n+Append a character to a string\n+*/\n+fn push_char(&s: str, ch: char) { s += from_char(ch); }\n \n-Returns:\n+/*\n+Function: pop_char\n \n-A record {ch: char, next: uint} containing the char value and the byte\n-index of the next unicode character.\n+Remove the final character from a string and return it.\n \n Failure:\n \n-If `i` is greater than or equal to the length of the string.\n-If `i` is not the index of the beginning of a valid UTF-8 character.\n+If the string does not contain any characters.\n */\n-fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n-    let b0 = s[i];\n-    let w = utf8_char_width(b0);\n-    assert (w != 0u);\n-    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n-    let val = 0u;\n-    let end = i + w;\n-    let i = i + 1u;\n-    while i < end {\n-        let byte = s[i];\n-        assert (byte & 192u8 == tag_cont_u8);\n-        val <<= 6u;\n-        val += byte & 63u8 as uint;\n-        i += 1u;\n-    }\n-    // Clunky way to get the right bits from the first byte. Uses two shifts,\n-    // the first to clip off the marker bits at the left of the byte, and then\n-    // a second (as uint) to get it to the right position.\n-    val += (b0 << (w + 1u as u8) as uint) << ((w - 1u) * 6u - w - 1u);\n-    ret {ch: val as char, next: i};\n+fn pop_char(&s: str) -> char {\n+    let end = byte_len(s);\n+    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n+    assert (end > 0u);\n+    let ch = char_at(s, end - 1u);\n+    s = substr(s, 0u, end - 1u);\n+    ret ch;\n }\n \n /*\n-Function: char_at\n+Function: shift_char\n \n-Pluck a character out of a string\n+Remove the first character from a string and return it.\n+\n+Failure:\n+\n+If the string does not contain any characters.\n */\n-fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+fn shift_char(&s: str) -> char {\n+    let r = char_range_at(s, 0u);\n+    s = substr(s, r.next, byte_len(s) - r.next);\n+    ret r.ch;\n+}\n \n /*\n-Function: iter_chars\n+Function: unshift_char\n \n-Iterate over the characters in a string\n+Prepend a char to a string\n */\n-fn iter_chars(s: str, it: fn(char)) {\n-    let pos = 0u, len = byte_len(s);\n-    while (pos < len) {\n-        let {ch, next} = char_range_at(s, pos);\n-        pos = next;\n-        it(ch);\n-    }\n-}\n+fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n /*\n-Function: chars_iter\n+Function: push_byte\n \n-Iterate over the characters in a string\n+Appends a byte to a string.\n \n-FIXME: A synonym to iter_chars\n+This function is not unicode-safe.\n */\n-fn chars_iter(ss: str, it: fn(char)) {\n-    iter_chars(ss, it)\n-}\n+fn push_byte(&s: str, b: u8) { rustrt::rust_str_push(s, b); }\n \n /*\n-Function: bytes_iter\n+Function: push_bytes\n \n-Iterate over the bytes in a string\n+Appends a vector of bytes to a string.\n \n-FIXME: Should it really include the last byte '\\0'?\n+This function is not unicode-safe.\n */\n-fn bytes_iter(ss: str, it: fn(u8)) {\n-    let pos = 0u;\n-    let len = byte_len(ss);\n-\n-    while (pos < len) {\n-        it(ss[pos]);\n-        pos += 1u;\n-    }\n+fn push_bytes(&s: str, bytes: [u8]) {\n+    for byte in bytes { rustrt::rust_str_push(s, byte); }\n }\n \n /*\n-Function: loop_chars\n-\n-Loop through a string, char by char\n-\n-Parameters:\n-s  - A string to traverse. It may be empty.\n-it - A block to execute with each consecutive character of `s`.\n-Return `true` to continue, `false` to stop.\n+Function: pop_byte\n \n-Returns:\n+Removes the last byte from a string and returns it.\n \n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n- */\n-fn loop_chars(s: str, it: fn(char) -> bool) -> bool{\n-    ret loop_chars_sub(s, 0u, byte_len(s), it);\n+This function is not unicode-safe.\n+*/\n+fn pop_byte(&s: str) -> u8 {\n+    let len = byte_len(s);\n+    assert (len > 0u);\n+    let b = s[len - 1u];\n+    s = substr(s, 0u, len - 1u);\n+    ret b;\n }\n \n /*\n-Function: loop_chars_sub\n-\n-Loop through a substring, char by char\n+Function: shift_byte\n \n-Parameters:\n-s           - A string to traverse. It may be empty.\n-byte_offset - The byte offset at which to start in the string.\n-byte_len    - The number of bytes to traverse in the string\n-it          - A block to execute with each consecutive character of `s`.\n-Return `true` to continue, `false` to stop.\n+Removes the first byte from a string and returns it.\n \n-Returns:\n+This function is not unicode-safe.\n+*/\n+fn shift_byte(&s: str) -> u8 {\n+    let len = byte_len(s);\n+    assert (len > 0u);\n+    let b = s[0];\n+    s = substr(s, 1u, len - 1u);\n+    ret b;\n+}\n \n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n+/*\n+Function: trim_left\n \n-Safety note:\n-- This function does not check whether the substring is valid.\n-- This function fails if `byte_offset` or `byte_len` do not\n- represent valid positions inside `s`\n- */\n-fn loop_chars_sub(s: str, byte_offset: uint, byte_len: uint,\n-              it: fn(char) -> bool) -> bool {\n-   let i = byte_offset;\n-   let result = true;\n-   while i < byte_len {\n-      let {ch, next} = char_range_at(s, i);\n-      if !it(ch) {result = false; break;}\n-      i = next;\n-   }\n-   ret result;\n+Returns a string with leading whitespace removed.\n+*/\n+fn trim_left(s: str) -> str {\n+    fn count_whities(s: [char]) -> uint {\n+        let i = 0u;\n+        while i < vec::len(s) {\n+            if !char::is_whitespace(s[i]) { break; }\n+            i += 1u;\n+        }\n+        ret i;\n+    }\n+    let chars = to_chars(s);\n+    let whities = count_whities(chars);\n+    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n }\n \n-\n /*\n-Function: char_len\n+Function: trim_right\n \n-Count the number of unicode characters in a string\n+Returns a string with trailing whitespace removed.\n */\n-fn char_len(s: str) -> uint {\n-    ret char_len_range(s, 0u, byte_len(s));\n+fn trim_right(s: str) -> str {\n+    fn count_whities(s: [char]) -> uint {\n+        let i = vec::len(s);\n+        while 0u < i {\n+            if !char::is_whitespace(s[i - 1u]) { break; }\n+            i -= 1u;\n+        }\n+        ret i;\n+    }\n+    let chars = to_chars(s);\n+    let whities = count_whities(chars);\n+    ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n /*\n-Function: char_len_range\n+Function: trim\n \n-As char_len but for a slice of a string\n+Returns a string with leading and trailing whitespace removed\n+*/\n+fn trim(s: str) -> str { trim_left(trim_right(s)) }\n \n-Parameters:\n- s           - A valid string\n- byte_start  - The position inside `s` where to start counting in bytes.\n- byte_len    - The number of bytes of `s` to take into account.\n \n-Returns:\n- The number of Unicode characters in `s` in\n-segment [byte_start, byte_start+len( .\n+/*\n+Section: Transforming strings\n+*/\n \n-Safety note:\n-- This function does not check whether the substring is valid.\n-- This function fails if `byte_offset` or `byte_len` do not\n- represent valid positions inside `s`\n+/*\n+Function: bytes\n+\n+Converts a string to a vector of bytes. The result vector is not\n+null-terminated.\n */\n-fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n-    let i     = byte_start;\n-    let len   = 0u;\n-    while i < byte_len {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n-        len += 1u;\n-        i += chsize;\n-    }\n-    assert (i == byte_len);\n-    ret len;\n+fn bytes(s: str) -> [u8] unsafe {\n+    let v = unsafe::reinterpret_cast(s);\n+    let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n+    unsafe::leak(v);\n+    ret vcopy;\n }\n \n /*\n Function: to_chars\n \n Convert a string to a vector of characters\n+\n+FIXME: rename to 'chars'\n */\n fn to_chars(s: str) -> [char] {\n     let buf: [char] = [];\n@@ -510,175 +431,37 @@ fn to_chars(s: str) -> [char] {\n }\n \n /*\n-Function: push_char\n-\n-Append a character to a string\n-*/\n-fn push_char(&s: str, ch: char) { s += from_char(ch); }\n+Function: substr\n \n-/*\n-Function: pop_char\n+Take a substring of another. Returns a string containing `len` bytes\n+starting at byte offset `begin`.\n \n-Remove the final character from a string and return it.\n+FIXME: This function is not unicode-safe.\n \n Failure:\n \n-If the string does not contain any characters.\n+If `begin` + `len` is is greater than the byte length of the string\n */\n-fn pop_char(&s: str) -> char {\n-    let end = byte_len(s);\n-    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n-    assert (end > 0u);\n-    let ch = char_at(s, end - 1u);\n-    s = substr(s, 0u, end - 1u);\n-    ret ch;\n+fn substr(s: str, begin: uint, len: uint) -> str {\n+    ret slice(s, begin, begin + len);\n }\n \n /*\n-Function: shift_char\n+Function: char_slice\n \n-Remove the first character from a string and return it.\n+Unicode-safe slice. Returns a slice of the given string containing\n+the characters in the range [`begin`..`end`). `begin` and `end` are\n+character indexes, not byte indexes.\n \n Failure:\n \n-If the string does not contain any characters.\n+- If begin is greater than end\n+- If end is greater than the character length of the string\n+\n+FIXME: rename to slice(), make faster by avoiding char conversion\n */\n-fn shift_char(&s: str) -> char {\n-    let r = char_range_at(s, 0u);\n-    s = substr(s, r.next, byte_len(s) - r.next);\n-    ret r.ch;\n-}\n-\n-/*\n-Function: unshift_char\n-\n-Prepend a char to a string\n-*/\n-fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n-\n-/*\n-Function: index\n-\n-Returns the index of the first matching byte. Returns -1 if\n-no match is found.\n-*/\n-fn index(s: str, c: u8) -> int {\n-    let i: int = 0;\n-    for k: u8 in s { if k == c { ret i; } i += 1; }\n-    ret -1;\n-}\n-\n-/*\n-Function: rindex\n-\n-Returns the index of the last matching byte. Returns -1\n-if no match is found.\n-*/\n-fn rindex(s: str, c: u8) -> int {\n-    let n: int = byte_len(s) as int;\n-    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n-    ret n;\n-}\n-\n-/*\n-Function: find\n-\n-Finds the index of the first matching substring.\n-Returns -1 if `haystack` does not contain `needle`.\n-\n-Parameters:\n-\n-haystack - The string to look in\n-needle - The string to look for\n-\n-Returns:\n-\n-The index of the first occurance of `needle`, or -1 if not found.\n-*/\n-fn find(haystack: str, needle: str) -> int {\n-    let haystack_len: int = byte_len(haystack) as int;\n-    let needle_len: int = byte_len(needle) as int;\n-    if needle_len == 0 { ret 0; }\n-    fn match_at(haystack: str, needle: str, i: int) -> bool {\n-        let j: int = i;\n-        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n-        ret true;\n-    }\n-    let i: int = 0;\n-    while i <= haystack_len - needle_len {\n-        if match_at(haystack, needle, i) { ret i; }\n-        i += 1;\n-    }\n-    ret -1;\n-}\n-\n-/*\n-Function: contains\n-\n-Returns true if one string contains another\n-\n-Parameters:\n-\n-haystack - The string to look in\n-needle - The string to look for\n-*/\n-fn contains(haystack: str, needle: str) -> bool {\n-    0 <= find(haystack, needle)\n-}\n-\n-/*\n-Function: starts_with\n-\n-Returns true if one string starts with another\n-\n-Parameters:\n-\n-haystack - The string to look in\n-needle - The string to look for\n-*/\n-fn starts_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n-    if needle_len == 0u { ret true; }\n-    if needle_len > haystack_len { ret false; }\n-    ret eq(substr(haystack, 0u, needle_len), needle);\n-}\n-\n-/*\n-Function: ends_with\n-\n-Returns true if one string ends with another\n-\n-haystack - The string to look in\n-needle - The string to look for\n-*/\n-fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n-    ret if needle_len == 0u {\n-            true\n-        } else if needle_len > haystack_len {\n-            false\n-        } else {\n-            eq(substr(haystack, haystack_len - needle_len, needle_len),\n-               needle)\n-        };\n-}\n-\n-/*\n-Function: substr\n-\n-Take a substring of another. Returns a string containing `len` bytes\n-starting at byte offset `begin`.\n-\n-This function is not unicode-safe.\n-\n-Failure:\n-\n-If `begin` + `len` is is greater than the byte length of the string\n-*/\n-fn substr(s: str, begin: uint, len: uint) -> str {\n-    ret slice(s, begin, begin + len);\n+fn char_slice(s: str, begin: uint, end: uint) -> str {\n+    from_chars(vec::slice(to_chars(s), begin, end))\n }\n \n /*\n@@ -693,6 +476,8 @@ Failure:\n \n - If begin is greater than end.\n - If end is greater than the length of the string.\n+\n+FIXME: rename to slice_byte or slice_byte_unsafe\n */\n fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n     // FIXME: Typestate precondition\n@@ -710,63 +495,17 @@ fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n \n /*\n Function: safe_slice\n+\n+FIXME: make sure char_slice / slice / byte_slice\n+       have these preconditions and assertions\n+FIXME: this shouldn't be mistaken for a UTF-8 safe slice\n */\n fn safe_slice(s: str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n     // would need some magic to make this a precondition\n     assert (end <= byte_len(s));\n     ret slice(s, begin, end);\n }\n \n-/*\n-Function: shift_byte\n-\n-Removes the first byte from a string and returns it.\n-\n-This function is not unicode-safe.\n-*/\n-fn shift_byte(&s: str) -> u8 {\n-    let len = byte_len(s);\n-    assert (len > 0u);\n-    let b = s[0];\n-    s = substr(s, 1u, len - 1u);\n-    ret b;\n-}\n-\n-/*\n-Function: pop_byte\n-\n-Removes the last byte from a string and returns it.\n-\n-This function is not unicode-safe.\n-*/\n-fn pop_byte(&s: str) -> u8 {\n-    let len = byte_len(s);\n-    assert (len > 0u);\n-    let b = s[len - 1u];\n-    s = substr(s, 0u, len - 1u);\n-    ret b;\n-}\n-\n-/*\n-Function: push_byte\n-\n-Appends a byte to a string.\n-\n-This function is not unicode-safe.\n-*/\n-fn push_byte(&s: str, b: u8) { rustrt::rust_str_push(s, b); }\n-\n-/*\n-Function: push_bytes\n-\n-Appends a vector of bytes to a string.\n-\n-This function is not unicode-safe.\n-*/\n-fn push_bytes(&s: str, bytes: [u8]) {\n-    for byte in bytes { rustrt::rust_str_push(s, byte); }\n-}\n-\n /*\n Function: split\n \n@@ -801,6 +540,8 @@ Split a string at each occurance of a given separator up to count times.\n Returns:\n \n A vector containing all the strings between each occurance of the separator\n+\n+FIXME: rename to 'splitn_char'\n */\n fn splitn(s: str, sep: u8, count: uint) -> [str] {\n     let v = [];\n@@ -864,7 +605,7 @@ Function: split_func\n Splits a string into substrings using a function\n (unicode safe)\n \n-FIXME: will be renamed to split.\n+FIXME: rename to 'split'\n */\n fn split_func(ss: str, sepfn: fn(cc: char)->bool) -> [str] {\n     let vv: [str] = [];\n@@ -929,53 +670,32 @@ fn words(ss: str) -> [str] {\n }\n \n /*\n-Function: words_iter\n-\n-Apply a function to each word\n-*/\n-fn words_iter(ss: str, ff: fn(&&str)) {\n-    vec::iter(words(ss), ff)\n-}\n-\n-/*\n-Function: lines_iter\n-\n-Apply a function to each lines (by '\\n')\n-*/\n-fn lines_iter(ss: str, ff: fn(&&str)) {\n-    vec::iter(lines(ss), ff)\n-}\n-\n-/*\n-Function: concat\n+Function: windowed\n \n-Concatenate a vector of strings\n+Create a vector of substrings of size `nn`\n */\n-fn concat(v: [str]) -> str {\n-    let s: str = \"\";\n-    for ss: str in v { s += ss; }\n-    ret s;\n-}\n+fn windowed(nn: uint, ss: str) -> [str] {\n+    let ww = [];\n+    let len = str::char_len(ss);\n \n-/*\n-Function: connect\n+    assert 1u <= nn;\n \n-Concatenate a vector of strings, placing a given separator between each\n-*/\n-fn connect(v: [str], sep: str) -> str {\n-    let s: str = \"\";\n-    let first: bool = true;\n-    for ss: str in v {\n-        if first { first = false; } else { s += sep; }\n-        s += ss;\n+    let ii = 0u;\n+    while ii+nn <= len {\n+        let w = char_slice( ss, ii, ii+nn );\n+        vec::push(ww,w);\n+        ii += 1u;\n     }\n-    ret s;\n+\n+    ret ww;\n }\n \n /*\n Function: to_lower\n \n Convert a string to lowercase\n+\n+FIXME: rewrite with map\n */\n fn to_lower(s: str) -> str {\n     let outstr = \"\";\n@@ -984,10 +704,13 @@ fn to_lower(s: str) -> str {\n     }\n     ret outstr;\n }\n+\n /*\n Function: to_upper\n \n Convert a string to uppercase\n+\n+FIXME: rewrite with map\n */\n fn to_upper(s: str) -> str {\n     let outstr = \"\";\n@@ -1031,145 +754,72 @@ fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n     }\n }\n \n-// FIXME: Also not efficient\n /*\n-Function: char_slice\n-\n-Unicode-safe slice. Returns a slice of the given string containing\n-the characters in the range [`begin`..`end`). `begin` and `end` are\n-character indexes, not byte indexes.\n-\n-Failure:\n+Function: escape\n \n-- If begin is greater than end\n-- If end is greater than the character length of the string\n+Escapes special characters inside the string, making it safe for transfer.\n */\n-fn char_slice(s: str, begin: uint, end: uint) -> str {\n-    from_chars(vec::slice(to_chars(s), begin, end))\n+fn escape(s: str) -> str {\n+    let r = \"\";\n+    loop_chars(s, { |c| r += escape_char(c); true });\n+    r\n }\n \n /*\n-Function: trim_left\n-\n-Returns a string with leading whitespace removed.\n+Section: Comparing strings\n */\n-fn trim_left(s: str) -> str {\n-    fn count_whities(s: [char]) -> uint {\n-        let i = 0u;\n-        while i < vec::len(s) {\n-            if !char::is_whitespace(s[i]) { break; }\n-            i += 1u;\n-        }\n-        ret i;\n-    }\n-    let chars = to_chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n-}\n \n /*\n-Function: trim_right\n+Function: eq\n \n-Returns a string with trailing whitespace removed.\n+Bytewise string equality\n */\n-fn trim_right(s: str) -> str {\n-    fn count_whities(s: [char]) -> uint {\n-        let i = vec::len(s);\n-        while 0u < i {\n-            if !char::is_whitespace(s[i - 1u]) { break; }\n-            i -= 1u;\n-        }\n-        ret i;\n-    }\n-    let chars = to_chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, 0u, whities));\n-}\n+pure fn eq(&&a: str, &&b: str) -> bool { a == b }\n \n /*\n-Function: trim\n+Function: lteq\n \n-Returns a string with leading and trailing whitespace removed\n+Bytewise less than or equal\n */\n-fn trim(s: str) -> str { trim_left(trim_right(s)) }\n+pure fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n \n /*\n-Type: sbuf\n+Function: hash\n \n-An unsafe buffer of bytes. Corresponds to a C char pointer.\n+String hash function\n */\n-type sbuf = *u8;\n+fn hash(&&s: str) -> uint {\n+    // djb hash.\n+    // FIXME: replace with murmur.\n \n-// NB: This is intentionally unexported because it's easy to misuse (there's\n-// no guarantee that the string is rooted). Instead, use as_buf below.\n-unsafe fn buf(s: str) -> sbuf {\n-    let saddr = ptr::addr_of(s);\n-    let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n-    let buf = vec::to_ptr(*vaddr);\n-    ret buf;\n+    let u: uint = 5381u;\n+    for c: u8 in s { u *= 33u; u += c as uint; }\n+    ret u;\n }\n \n /*\n-Function: as_buf\n-\n-Work with the byte buffer of a string. Allows for unsafe manipulation\n-of strings, which is useful for native interop.\n-\n-Example:\n-\n-> let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n-\n+Section: Iterating through strings\n */\n-fn as_buf<T>(s: str, f: fn(sbuf) -> T) -> T unsafe {\n-    let buf = buf(s); f(buf)\n-}\n \n /*\n-Function: from_cstr\n+Function: loop_chars\n \n-Create a Rust string from a null-terminated C string\n-*/\n-unsafe fn from_cstr(cstr: sbuf) -> str {\n-    let res = \"\";\n-    let start = cstr;\n-    let curr = start;\n-    let i = 0u;\n-    while *curr != 0u8 {\n-        push_byte(res, *curr);\n-        i += 1u;\n-        curr = ptr::offset(start, i);\n-    }\n-    ret res;\n-}\n+Loop through a string, char by char\n \n-/*\n-Function: escape_char\n+Parameters:\n+s  - A string to traverse. It may be empty.\n+it - A block to execute with each consecutive character of `s`.\n+Return `true` to continue, `false` to stop.\n \n-Escapes a single character.\n-*/\n-fn escape_char(c: char) -> str {\n-    alt c {\n-      '\"' { \"\\\\\\\"\" }\n-      '\\\\' { \"\\\\\\\\\" }\n-      '\\n' { \"\\\\n\" }\n-      '\\t' { \"\\\\t\" }\n-      '\\r' { \"\\\\r\" }\n-      // FIXME: uncomment this when extfmt is moved to core\n-      // in a snapshot.\n-      // '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n-      v { from_char(c) }\n-    }\n-}\n+Returns:\n \n-/*\n-Function: escape\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n \n-Escapes special characters inside the string, making it safe for transfer.\n-*/\n-fn escape(s: str) -> str {\n-    let r = \"\";\n-    loop_chars(s, { |c| r += escape_char(c); true });\n-    r\n+FIXME: rename to 'chars_loop' (change? currently a synonym to 'all')\n+ */\n+fn loop_chars(s: str, it: fn(char) -> bool) -> bool{\n+    ret loop_chars_sub(s, 0u, byte_len(s), it);\n }\n \n /*\n@@ -1210,26 +860,537 @@ fn map(ss: str, ff: fn(char) -> char) -> str {\n }\n \n /*\n-Function: windowed\n+Function: bytes_iter\n \n-Create a vector of substrings of size `nn`\n+Iterate over the bytes in a string\n+\n+FIXME: Should it really include the last byte '\\0'?\n */\n-fn windowed(nn: uint, ss: str) -> [str] {\n-    let ww = [];\n-    let len = str::char_len(ss);\n+fn bytes_iter(ss: str, it: fn(u8)) {\n+    let pos = 0u;\n+    let len = byte_len(ss);\n \n-    assert 1u <= nn;\n+    while (pos < len) {\n+        it(ss[pos]);\n+        pos += 1u;\n+    }\n+}\n \n-    let ii = 0u;\n-    while ii+nn <= len {\n-        let w = char_slice( ss, ii, ii+nn );\n-        vec::push(ww,w);\n-        ii += 1u;\n+/*\n+Function: iter_chars\n+\n+Iterate over the characters in a string\n+\n+FIXME: rename to 'chars_iter'\n+*/\n+fn iter_chars(s: str, it: fn(char)) {\n+    let pos = 0u, len = byte_len(s);\n+    while (pos < len) {\n+        let {ch, next} = char_range_at(s, pos);\n+        pos = next;\n+        it(ch);\n     }\n+}\n \n-    ret ww;\n+/*\n+Function: chars_iter\n+\n+Iterate over the characters in a string\n+\n+FIXME: A synonym to iter_chars\n+*/\n+fn chars_iter(ss: str, it: fn(char)) {\n+    iter_chars(ss, it)\n+}\n+\n+/*\n+Function: words_iter\n+\n+Apply a function to each word\n+*/\n+fn words_iter(ss: str, ff: fn(&&str)) {\n+    vec::iter(words(ss), ff)\n+}\n+\n+/*\n+Function: lines_iter\n+\n+Apply a function to each lines (by '\\n')\n+*/\n+fn lines_iter(ss: str, ff: fn(&&str)) {\n+    vec::iter(lines(ss), ff)\n+}\n+\n+// FIXME: ADD split_char_iter\n+// FIXME: ADD splitn_char_iter\n+\n+/*\n+Section: Searching\n+*/\n+\n+/*\n+Function: index\n+\n+Returns the index of the first matching byte. Returns -1 if\n+no match is found.\n+*/\n+fn index(s: str, c: u8) -> int {\n+    let i: int = 0;\n+    for k: u8 in s { if k == c { ret i; } i += 1; }\n+    ret -1;\n+}\n+\n+/*\n+Function: rindex\n+\n+Returns the index of the last matching byte. Returns -1\n+if no match is found.\n+*/\n+fn rindex(s: str, c: u8) -> int {\n+    let n: int = byte_len(s) as int;\n+    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n+    ret n;\n+}\n+\n+/*\n+Function: find\n+\n+Finds the index of the first matching substring.\n+Returns -1 if `haystack` does not contain `needle`.\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+\n+Returns:\n+\n+The index of the first occurance of `needle`, or -1 if not found.\n+*/\n+fn find(haystack: str, needle: str) -> int {\n+    let haystack_len: int = byte_len(haystack) as int;\n+    let needle_len: int = byte_len(needle) as int;\n+    if needle_len == 0 { ret 0; }\n+    fn match_at(haystack: str, needle: str, i: int) -> bool {\n+        let j: int = i;\n+        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n+        ret true;\n+    }\n+    let i: int = 0;\n+    while i <= haystack_len - needle_len {\n+        if match_at(haystack, needle, i) { ret i; }\n+        i += 1;\n+    }\n+    ret -1;\n }\n \n+/*\n+Function: contains\n+\n+Returns true if one string contains another\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n+fn contains(haystack: str, needle: str) -> bool {\n+    0 <= find(haystack, needle)\n+}\n+\n+/*\n+Function: starts_with\n+\n+Returns true if one string starts with another\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n+fn starts_with(haystack: str, needle: str) -> bool {\n+    let haystack_len: uint = byte_len(haystack);\n+    let needle_len: uint = byte_len(needle);\n+    if needle_len == 0u { ret true; }\n+    if needle_len > haystack_len { ret false; }\n+    ret eq(substr(haystack, 0u, needle_len), needle);\n+}\n+\n+/*\n+Function: ends_with\n+\n+Returns true if one string ends with another\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n+fn ends_with(haystack: str, needle: str) -> bool {\n+    let haystack_len: uint = byte_len(haystack);\n+    let needle_len: uint = byte_len(needle);\n+    ret if needle_len == 0u {\n+            true\n+        } else if needle_len > haystack_len {\n+            false\n+        } else {\n+            eq(substr(haystack, haystack_len - needle_len, needle_len),\n+               needle)\n+        };\n+}\n+\n+/*\n+Section: String properties\n+*/\n+\n+/*\n+Function: is_ascii\n+\n+Determines if a string contains only ASCII characters\n+\n+FIXME: possibly implement using char::is_ascii when it exists\n+*/\n+fn is_ascii(s: str) -> bool {\n+    let i: uint = byte_len(s);\n+    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n+    ret true;\n+}\n+\n+/*\n+Predicate: is_empty\n+\n+Returns true if the string has length 0\n+*/\n+pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n+\n+/*\n+Predicate: is_not_empty\n+\n+Returns true if the string has length greater than 0\n+*/\n+pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n+\n+/*\n+Function: is_whitespace\n+\n+Returns true if the string contains only whitespace\n+*/\n+fn is_whitespace(s: str) -> bool {\n+    ret loop_chars(s, char::is_whitespace);\n+}\n+\n+/*\n+Function: byte_len\n+\n+Returns the length in bytes of a string\n+\n+FIXME: rename to 'len_bytes'?\n+*/\n+pure fn byte_len(s: str) -> uint unsafe {\n+    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let vlen = vec::len(v);\n+    unsafe::leak(v);\n+    // There should always be a null terminator\n+    assert (vlen > 0u);\n+    ret vlen - 1u;\n+}\n+\n+/*\n+Function: char_len\n+\n+Count the number of unicode characters in a string\n+\n+FIXME: rename to 'len_chars'?\n+*/\n+fn char_len(s: str) -> uint {\n+    ret char_len_range(s, 0u, byte_len(s));\n+}\n+\n+/*\n+Section: Misc\n+*/\n+\n+/*\n+Function: is_utf8\n+\n+Determines if a vector of bytes contains valid UTF-8\n+*/\n+fn is_utf8(v: [u8]) -> bool {\n+    let i = 0u;\n+    let total = vec::len::<u8>(v);\n+    while i < total {\n+        let chsize = utf8_char_width(v[i]);\n+        if chsize == 0u { ret false; }\n+        if i + chsize > total { ret false; }\n+        i += 1u;\n+        while chsize > 1u {\n+            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n+            i += 1u;\n+            chsize -= 1u;\n+        }\n+    }\n+    ret true;\n+}\n+\n+/*\n+Function: char_len_range\n+\n+As char_len but for a slice of a string\n+\n+Parameters:\n+ s           - A valid string\n+ byte_start  - The position inside `s` where to start counting in bytes.\n+ byte_len    - The number of bytes of `s` to take into account.\n+\n+Returns:\n+ The number of Unicode characters in `s` in\n+segment [byte_start, byte_start+len( .\n+\n+Safety note:\n+- This function does not check whether the substring is valid.\n+- This function fails if `byte_offset` or `byte_len` do not\n+ represent valid positions inside `s`\n+\n+FIXME: rename to 'substr_len_chars'\n+*/\n+fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n+    let i     = byte_start;\n+    let len   = 0u;\n+    while i < byte_len {\n+        let chsize = utf8_char_width(s[i]);\n+        assert (chsize > 0u);\n+        len += 1u;\n+        i += chsize;\n+    }\n+    assert (i == byte_len);\n+    ret len;\n+}\n+\n+/*\n+Function: byte_len_range\n+\n+As byte_len but for a substring\n+\n+Parameters:\n+s - A string\n+byte_offset - The byte offset at which to start in the string\n+char_len    - The number of chars (not bytes!) in the range\n+\n+Returns:\n+The number of bytes in the substring starting at `byte_offset` and\n+containing `char_len` chars.\n+\n+Safety note:\n+\n+This function fails if `byte_offset` or `char_len` do not represent\n+valid positions in `s`\n+\n+FIXME: rename to 'substr_len_bytes'\n+*/\n+fn byte_len_range(s: str, byte_offset: uint, char_len: uint) -> uint {\n+    let i = byte_offset;\n+    let chars = 0u;\n+    while chars < char_len {\n+        let chsize = utf8_char_width(s[i]);\n+        assert (chsize > 0u);\n+        i += chsize;\n+        chars += 1u;\n+    }\n+    ret i - byte_offset;\n+}\n+\n+/*\n+Function: utf8_char_width\n+\n+Given a first byte, determine how many bytes are in this UTF-8 character\n+\n+*/\n+pure fn utf8_char_width(b: u8) -> uint {\n+    let byte: uint = b as uint;\n+    if byte < 128u { ret 1u; }\n+    if byte < 192u {\n+        ret 0u; // Not a valid start byte\n+\n+    }\n+    if byte < 224u { ret 2u; }\n+    if byte < 240u { ret 3u; }\n+    if byte < 248u { ret 4u; }\n+    if byte < 252u { ret 5u; }\n+    ret 6u;\n+}\n+\n+/*\n+Function: char_range_at\n+\n+Pluck a character out of a string and return the index of the next character.\n+This function can be used to iterate over the unicode characters of a string.\n+\n+Example:\n+> let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+> let i = 0u;\n+> while i < str::byte_len(s) {\n+>    let {ch, next} = str::char_range_at(s, i);\n+>    std::io::println(#fmt(\"%u: %c\",i,ch));\n+>    i = next;\n+> }\n+\n+Example output:\n+\n+      0: \u4e2d\n+      3: \u534e\n+      6: V\n+      7: i\n+      8: \u1ec7\n+      11: t\n+      12:\n+      13: N\n+      14: a\n+      15: m\n+\n+Parameters:\n+\n+s - The string\n+i - The byte offset of the char to extract\n+\n+Returns:\n+\n+A record {ch: char, next: uint} containing the char value and the byte\n+index of the next unicode character.\n+\n+Failure:\n+\n+If `i` is greater than or equal to the length of the string.\n+If `i` is not the index of the beginning of a valid UTF-8 character.\n+*/\n+fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n+    let b0 = s[i];\n+    let w = utf8_char_width(b0);\n+    assert (w != 0u);\n+    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n+    let val = 0u;\n+    let end = i + w;\n+    let i = i + 1u;\n+    while i < end {\n+        let byte = s[i];\n+        assert (byte & 192u8 == tag_cont_u8);\n+        val <<= 6u;\n+        val += byte & 63u8 as uint;\n+        i += 1u;\n+    }\n+    // Clunky way to get the right bits from the first byte. Uses two shifts,\n+    // the first to clip off the marker bits at the left of the byte, and then\n+    // a second (as uint) to get it to the right position.\n+    val += (b0 << (w + 1u as u8) as uint) << ((w - 1u) * 6u - w - 1u);\n+    ret {ch: val as char, next: i};\n+}\n+\n+/*\n+Function: char_at\n+\n+Pluck a character out of a string\n+*/\n+fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+\n+/*\n+Function: loop_chars_sub\n+\n+Loop through a substring, char by char\n+\n+Parameters:\n+s           - A string to traverse. It may be empty.\n+byte_offset - The byte offset at which to start in the string.\n+byte_len    - The number of bytes to traverse in the string\n+it          - A block to execute with each consecutive character of `s`.\n+Return `true` to continue, `false` to stop.\n+\n+Returns:\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+\n+Safety note:\n+- This function does not check whether the substring is valid.\n+- This function fails if `byte_offset` or `byte_len` do not\n+ represent valid positions inside `s`\n+\n+FIXME: rename to 'substr_all'\n+ */\n+fn loop_chars_sub(s: str, byte_offset: uint, byte_len: uint,\n+              it: fn(char) -> bool) -> bool {\n+   let i = byte_offset;\n+   let result = true;\n+   while i < byte_len {\n+      let {ch, next} = char_range_at(s, i);\n+      if !it(ch) {result = false; break;}\n+      i = next;\n+   }\n+   ret result;\n+}\n+\n+\n+/*\n+Function: escape_char\n+\n+Escapes a single character.\n+*/\n+fn escape_char(c: char) -> str {\n+    alt c {\n+      '\"' { \"\\\\\\\"\" }\n+      '\\\\' { \"\\\\\\\\\" }\n+      '\\n' { \"\\\\n\" }\n+      '\\t' { \"\\\\t\" }\n+      '\\r' { \"\\\\r\" }\n+      // FIXME: uncomment this when extfmt is moved to core\n+      // in a snapshot.\n+      // '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n+      v { from_char(c) }\n+    }\n+}\n+\n+// UTF-8 tags and ranges\n+const tag_cont_u8: u8 = 128u8;\n+const tag_cont: uint = 128u;\n+const max_one_b: uint = 128u;\n+const tag_two_b: uint = 192u;\n+const max_two_b: uint = 2048u;\n+const tag_three_b: uint = 224u;\n+const max_three_b: uint = 65536u;\n+const tag_four_b: uint = 240u;\n+const max_four_b: uint = 2097152u;\n+const tag_five_b: uint = 248u;\n+const max_five_b: uint = 67108864u;\n+const tag_six_b: uint = 252u;\n+\n+// NB: This is intentionally unexported because it's easy to misuse (there's\n+// no guarantee that the string is rooted). Instead, use as_buf below.\n+unsafe fn buf(s: str) -> sbuf {\n+    let saddr = ptr::addr_of(s);\n+    let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n+    let buf = vec::to_ptr(*vaddr);\n+    ret buf;\n+}\n+\n+/*\n+Function: as_buf\n+\n+Work with the byte buffer of a string. Allows for unsafe manipulation\n+of strings, which is useful for native interop.\n+\n+Example:\n+\n+> let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n+\n+*/\n+fn as_buf<T>(s: str, f: fn(sbuf) -> T) -> T unsafe {\n+    let buf = buf(s); f(buf)\n+}\n+\n+/*\n+Type: sbuf\n+\n+An unsafe buffer of bytes. Corresponds to a C char pointer.\n+*/\n+type sbuf = *u8;\n+\n+\n #[cfg(test)]\n mod tests {\n "}]}