{"sha": "c0221c8897db309a79990367476177b1230bb264", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMjIxYzg4OTdkYjMwOWE3OTk5MDM2NzQ3NjE3N2IxMjMwYmIyNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-11T20:20:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-11T20:20:56Z"}, "message": "Auto merge of #32882 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 9 pull requests\n\n- Successful merges: #32768, #32802, #32815, #32823, #32849, #32854, #32862, #32870, #32873\n- Failed merges:", "tree": {"sha": "2f4d930c57ca7921d12a61046a5852a3d21d73ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f4d930c57ca7921d12a61046a5852a3d21d73ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0221c8897db309a79990367476177b1230bb264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0221c8897db309a79990367476177b1230bb264", "html_url": "https://github.com/rust-lang/rust/commit/c0221c8897db309a79990367476177b1230bb264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0221c8897db309a79990367476177b1230bb264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b622c3e0856767d8e53cf141e2e0a7b6d72a198b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b622c3e0856767d8e53cf141e2e0a7b6d72a198b", "html_url": "https://github.com/rust-lang/rust/commit/b622c3e0856767d8e53cf141e2e0a7b6d72a198b"}, {"sha": "55e90bbd5eeaffb68f5d14b77c4a4a667d1f6877", "url": "https://api.github.com/repos/rust-lang/rust/commits/55e90bbd5eeaffb68f5d14b77c4a4a667d1f6877", "html_url": "https://github.com/rust-lang/rust/commit/55e90bbd5eeaffb68f5d14b77c4a4a667d1f6877"}], "stats": {"total": 298, "additions": 233, "deletions": 65}, "files": [{"sha": "c179629a79a720d724952e2ef0ef1b636b0ff0eb", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -162,7 +162,7 @@ The same [ownership system](ownership.html) that helps prevent using pointers\n incorrectly also helps rule out data races, one of the worst kinds of\n concurrency bugs.\n \n-As an example, here is a Rust program that could have a data race in many\n+As an example, here is a Rust program that would have a data race in many\n languages. It will not compile:\n \n ```ignore\n@@ -174,7 +174,7 @@ fn main() {\n \n     for i in 0..3 {\n         thread::spawn(move || {\n-            data[i] += 1;\n+            data[0] += i;\n         });\n     }\n \n@@ -186,7 +186,7 @@ This gives us an error:\n \n ```text\n 8:17 error: capture of moved value: `data`\n-        data[i] += 1;\n+        data[0] += i;\n         ^~~~\n ```\n \n@@ -195,11 +195,6 @@ thread, and the thread takes ownership of the reference, we'd have three owners!\n `data` gets moved out of `main` in the first call to `spawn()`, so subsequent\n calls in the loop cannot use this variable.\n \n-Note that this specific example will not cause a data race since different array\n-indices are being accessed. But this can't be determined at compile time, and in\n-a similar situation where `i` is a constant or is random, you would have a data\n-race.\n-\n So, we need some type that lets us have more than one owning reference to a\n value. Usually, we'd use `Rc<T>` for this, which is a reference counted type\n that provides shared ownership. It has some runtime bookkeeping that keeps track\n@@ -223,7 +218,7 @@ fn main() {\n \n         // use it in a thread\n         thread::spawn(move || {\n-            data_ref[i] += 1;\n+            data_ref[0] += i;\n         });\n     }\n \n@@ -266,7 +261,7 @@ fn main() {\n     for i in 0..3 {\n         let data = data.clone();\n         thread::spawn(move || {\n-            data[i] += 1;\n+            data[0] += i;\n         });\n     }\n \n@@ -281,7 +276,7 @@ And... still gives us an error.\n \n ```text\n <anon>:11:24 error: cannot borrow immutable borrowed content as mutable\n-<anon>:11                    data[i] += 1;\n+<anon>:11                    data[0] += i;\n                              ^~~~\n ```\n \n@@ -317,7 +312,7 @@ fn main() {\n         let data = data.clone();\n         thread::spawn(move || {\n             let mut data = data.lock().unwrap();\n-            data[i] += 1;\n+            data[0] += i;\n         });\n     }\n \n@@ -360,7 +355,7 @@ Let's examine the body of the thread more closely:\n #         let data = data.clone();\n thread::spawn(move || {\n     let mut data = data.lock().unwrap();\n-    data[i] += 1;\n+    data[0] += i;\n });\n #     }\n #     thread::sleep(Duration::from_millis(50));"}, {"sha": "9af8ef53851db986bc48556ebe74f3fa8c40eda7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -149,7 +149,7 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n+        /// assert_eq!(i32::from_str_radix(\"A\", 16), Ok(10));\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n@@ -163,9 +163,9 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0b01001100u8;\n+        /// let n = -0b1000_0000i8;\n         ///\n-        /// assert_eq!(n.count_ones(), 3);\n+        /// assert_eq!(n.count_ones(), 1);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -178,9 +178,9 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0b01001100u8;\n+        /// let n = -0b1000_0000i8;\n         ///\n-        /// assert_eq!(n.count_zeros(), 5);\n+        /// assert_eq!(n.count_zeros(), 7);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -196,9 +196,9 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0b0101000u16;\n+        /// let n = -1i16;\n         ///\n-        /// assert_eq!(n.leading_zeros(), 10);\n+        /// assert_eq!(n.leading_zeros(), 0);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -214,9 +214,9 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0b0101000u16;\n+        /// let n = -4i8;\n         ///\n-        /// assert_eq!(n.trailing_zeros(), 3);\n+        /// assert_eq!(n.trailing_zeros(), 2);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -232,10 +232,10 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        /// let m = 0x3456789ABCDEF012u64;\n+        /// let n = 0x0123456789ABCDEFi64;\n+        /// let m = -0x76543210FEDCBA99i64;\n         ///\n-        /// assert_eq!(n.rotate_left(12), m);\n+        /// assert_eq!(n.rotate_left(32), m);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -252,10 +252,10 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        /// let m = 0xDEF0123456789ABCu64;\n+        /// let n = 0x0123456789ABCDEFi64;\n+        /// let m = -0xFEDCBA987654322i64;\n         ///\n-        /// assert_eq!(n.rotate_right(12), m);\n+        /// assert_eq!(n.rotate_right(4), m);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -270,8 +270,8 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        /// let m = 0xEFCDAB8967452301u64;\n+        /// let n =  0x0123456789ABCDEFi64;\n+        /// let m = -0x1032547698BADCFFi64;\n         ///\n         /// assert_eq!(n.swap_bytes(), m);\n         /// ```\n@@ -291,12 +291,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n+        /// let n = 0x0123456789ABCDEFi64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(u64::from_be(n), n)\n+        ///     assert_eq!(i64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(i64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -315,12 +315,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n+        /// let n = 0x0123456789ABCDEFi64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(u64::from_le(n), n)\n+        ///     assert_eq!(i64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(i64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -339,7 +339,7 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n+        /// let n = 0x0123456789ABCDEFi64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n         ///     assert_eq!(n.to_be(), n)\n@@ -363,7 +363,7 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n+        /// let n = 0x0123456789ABCDEFi64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n         ///     assert_eq!(n.to_le(), n)\n@@ -385,8 +385,8 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-        /// assert_eq!(6u16.checked_add(65530), None);\n+        /// assert_eq!(7i16.checked_add(32760), Some(32767));\n+        /// assert_eq!(8i16.checked_add(32760), None);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -421,8 +421,8 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(5u8.checked_mul(51), Some(255));\n-        /// assert_eq!(5u8.checked_mul(52), None);\n+        /// assert_eq!(6i8.checked_mul(21), Some(126));\n+        /// assert_eq!(6i8.checked_mul(22), None);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -753,8 +753,8 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(1u8.wrapping_shl(7), 128);\n-        /// assert_eq!(1u8.wrapping_shl(8), 1);\n+        /// assert_eq!((-1i8).wrapping_shl(7), -128);\n+        /// assert_eq!((-1i8).wrapping_shl(8), -1);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n@@ -778,8 +778,8 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(128u8.wrapping_shr(7), 1);\n-        /// assert_eq!(128u8.wrapping_shr(8), 128);\n+        /// assert_eq!((-128i8).wrapping_shr(7), -1);\n+        /// assert_eq!((-128i8).wrapping_shr(8), -128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n@@ -1193,15 +1193,13 @@ macro_rules! uint_impl {\n         ///\n         /// Leading and trailing whitespace represent an error.\n         ///\n-        /// # Arguments\n-        ///\n-        /// * src - A string slice\n-        /// * radix - The base to use. Must lie in the range [2 .. 36]\n+        /// # Examples\n         ///\n-        /// # Return value\n+        /// Basic usage:\n         ///\n-        /// `Err(ParseIntError)` if the string did not represent a valid number.\n-        /// Otherwise, `Ok(n)` where `n` is the integer represented by `src`.\n+        /// ```\n+        /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n@@ -1745,7 +1743,7 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(100i8.wrapping_rem(10), 0);\n+        /// assert_eq!(100u8.wrapping_rem(10), 0);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n@@ -1783,6 +1781,13 @@ macro_rules! uint_impl {\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n         ///\n+        /// Note that this is *not* the same as a rotate-left; the\n+        /// RHS of a wrapping shift-left is restricted to the range\n+        /// of the type, rather than the bits shifted out of the LHS\n+        /// being returned to the other end. The primitive integer\n+        /// types all implement a `rotate_left` function, which may\n+        /// be what you want instead.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -1801,6 +1806,13 @@ macro_rules! uint_impl {\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n         ///\n+        /// Note that this is *not* the same as a rotate-right; the\n+        /// RHS of a wrapping shift-right is restricted to the range\n+        /// of the type, rather than the bits shifted out of the LHS\n+        /// being returned to the other end. The primitive integer\n+        /// types all implement a `rotate_right` function, which may\n+        /// be what you want instead.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:"}, {"sha": "4d9f042fddedc03db74c4647848032836efdae04", "filename": "src/libcore/result.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -19,7 +19,7 @@\n //! # #[allow(dead_code)]\n //! enum Result<T, E> {\n //!    Ok(T),\n-//!    Err(E)\n+//!    Err(E),\n //! }\n //! ```\n //!\n@@ -39,7 +39,7 @@\n //!         None => Err(\"invalid header length\"),\n //!         Some(&1) => Ok(Version::Version1),\n //!         Some(&2) => Ok(Version::Version2),\n-//!         Some(_) => Err(\"invalid version\")\n+//!         Some(_) => Err(\"invalid version\"),\n //!     }\n //! }\n //!\n@@ -254,7 +254,7 @@ pub enum Result<T, E> {\n \n     /// Contains the error value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E)\n+    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -270,6 +270,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_ok(), true);\n@@ -290,6 +292,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_err(), false);\n@@ -314,6 +318,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.ok(), Some(2));\n@@ -337,6 +343,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.err(), None);\n@@ -362,6 +370,10 @@ impl<T, E> Result<T, E> {\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n     ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.as_ref(), Ok(&2));\n@@ -380,6 +392,10 @@ impl<T, E> Result<T, E> {\n \n     /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`\n     ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// fn mutate(r: &mut Result<i32, i32>) {\n     ///     match r.as_mut() {\n@@ -445,6 +461,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// fn stringify(x: u32) -> String { format!(\"error code: {}\", x) }\n     ///\n@@ -471,6 +489,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(7);\n     /// assert_eq!(x.iter().next(), Some(&7));\n@@ -488,6 +508,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut x: Result<u32, &str> = Ok(7);\n     /// match x.iter_mut().next() {\n@@ -513,6 +535,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<&str, &str> = Err(\"late error\");\n@@ -545,6 +569,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n     /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n@@ -567,6 +593,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<u32, &str> = Err(\"late error\");\n@@ -599,6 +627,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n     /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n@@ -622,6 +652,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let optb = 2;\n     /// let x: Result<u32, &str> = Ok(9);\n@@ -644,6 +676,8 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// fn count(x: &str) -> usize { x.len() }\n     ///\n@@ -670,6 +704,8 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.unwrap(), 2);\n@@ -696,6 +732,9 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// passed message, and the content of the `Err`.\n     ///\n     /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n     /// ```{.should_panic}\n     /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n@@ -759,6 +798,8 @@ impl<T, E> IntoIterator for Result<T, E> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(5);\n     /// let v: Vec<u32> = x.into_iter().collect();"}, {"sha": "f21af7d917e20ef15a2eac06972c00a9bc069d2e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -871,6 +871,20 @@ macro_rules! make_mut_slice {\n }\n \n /// Immutable slice iterator\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // First, we declare a type which has `iter` method to get the `Iter` struct (&[usize here]):\n+/// let slice = &[1, 2, 3];\n+///\n+/// // Then, we iterate over it:\n+/// for element in slice.iter() {\n+///     println!(\"{}\", element);\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n@@ -897,6 +911,26 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // First, we declare a type which has the `iter` method to get the `Iter`\n+    /// // struct (&[usize here]):\n+    /// let slice = &[1, 2, 3];\n+    ///\n+    /// // Then, we get the iterator:\n+    /// let mut iter = slice.iter();\n+    /// // So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":\n+    /// println!(\"{:?}\", iter.as_slice());\n+    ///\n+    /// // Next, we move to the second element of the slice:\n+    /// iter.next();\n+    /// // Now `as_slice` returns \"[2, 3]\":\n+    /// println!(\"{:?}\", iter.as_slice());\n+    /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(self.ptr, self.end)\n@@ -928,6 +962,24 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n+/// // struct (&[usize here]):\n+/// let mut slice = &mut [1, 2, 3];\n+///\n+/// // Then, we iterate over it and increment each element value:\n+/// for element in slice.iter_mut() {\n+///     *element += 1;\n+/// }\n+///\n+/// // We now have \"[2, 3, 4]\":\n+/// println!(\"{:?}\", slice);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n@@ -956,6 +1008,35 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n+    /// // struct (&[usize here]):\n+    /// let mut slice = &mut [1, 2, 3];\n+    ///\n+    /// {\n+    ///     // Then, we get the iterator:\n+    ///     let mut iter = slice.iter_mut();\n+    ///     // We move to next element:\n+    ///     iter.next();\n+    ///     // So if we print what `into_slice` method returns here, we have \"[2, 3]\":\n+    ///     println!(\"{:?}\", iter.into_slice());\n+    /// }\n+    ///\n+    /// // Now let's modify a value of the slice:\n+    /// {\n+    ///     // First we get back the iterator:\n+    ///     let mut iter = slice.iter_mut();\n+    ///     // We change the value of the first element of the slice returned by the `next` method:\n+    ///     *iter.next().unwrap() += 1;\n+    /// }\n+    /// // Now slice is \"[2, 2, 3]\":\n+    /// println!(\"{:?}\", slice);\n+    /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_mut_slice!(self.ptr, self.end)"}, {"sha": "f1be10da872411e80e6ffead263c559e91e89696", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -1940,7 +1940,8 @@ impl StrExt for str {\n         if index == 0 || index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n-            Some(&b) => b < 128 || b >= 192,\n+            // This is bit magic equivalent to: b < 128 || b >= 192\n+            Some(&b) => (b as i8) >= -0x40,\n         }\n     }\n "}, {"sha": "bde88605e88cdc1daabed3d31e8616ba715b3009", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -436,6 +436,7 @@ impl Target {\n         key!(target_family, optional);\n         key!(is_like_osx, bool);\n         key!(is_like_windows, bool);\n+        key!(is_like_msvc, bool);\n         key!(linker_is_gnu, bool);\n         key!(has_rpath, bool);\n         key!(no_compiler_rt, bool);"}, {"sha": "f0e834d43032516b0888f8a5bacbc8b1963ae5e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -539,6 +539,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             (&Failed(_), &Failed(_)) => {\n                 let resolutions = target_module.resolutions.borrow();\n                 let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n+                    if *name == source { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n                         NameResolution { binding: Some(_), .. } => Some(name),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n@@ -549,9 +550,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                     None => \"\".to_owned(),\n                 };\n-                let msg = format!(\"There is no `{}` in `{}`{}\",\n-                                  source,\n-                                  module_to_string(target_module), lev_suggestion);\n+                let module_str = module_to_string(target_module);\n+                let msg = if &module_str == \"???\" {\n+                    format!(\"There is no `{}` in the crate root{}\", source, lev_suggestion)\n+                } else {\n+                    format!(\"There is no `{}` in `{}`{}\", source, module_str, lev_suggestion)\n+                };\n                 return Failed(Some((directive.span, msg)));\n             }\n             _ => (),"}, {"sha": "f413bed86a8534d3c67844d380629ea49cf756bc", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -466,7 +466,7 @@ enum State {\n     Done = 3,\n }\n \n-/// A Windows path prefix, e.g. `C:` or `\\server\\share`.\n+/// A Windows path prefix, e.g. `C:` or `\\\\server\\share`.\n ///\n /// Does not occur on Unix.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -528,7 +528,7 @@ impl<'a> Hash for PrefixComponent<'a> {\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Component<'a> {\n-    /// A Windows path prefix, e.g. `C:` or `\\server\\share`.\n+    /// A Windows path prefix, e.g. `C:` or `\\\\server\\share`.\n     ///\n     /// Does not occur on Unix.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "22261d98a128c98260eaaffaae6ab491ce2638d7", "filename": "src/test/compile-fail/issue-32833.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Ftest%2Fcompile-fail%2Fissue-32833.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Ftest%2Fcompile-fail%2Fissue-32833.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32833.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use bar::Foo; //~ ERROR There is no `Foo` in `bar` [E0432]\n+mod bar {\n+    use Foo; //~ ERROR There is no `Foo` in the crate root [E0432]\n+}\n+\n+fn main() {}"}, {"sha": "f2384912cdba31c924d5723f55a25a1a82d031dd", "filename": "src/test/compile-fail/use-mod-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Ftest%2Fcompile-fail%2Fuse-mod-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Ftest%2Fcompile-fail%2Fuse-mod-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-mod-2.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -10,10 +10,10 @@\n \n mod foo {\n     use self::{self};\n-    //~^ ERROR unresolved import `self`. There is no `self` in `???`\n+    //~^ ERROR unresolved import `self`. There is no `self` in the crate root\n \n     use super::{self};\n-    //~^ ERROR unresolved import `super`. There is no `super` in `???`\n+    //~^ ERROR unresolved import `super`. There is no `super` in the crate root\n }\n \n fn main() {}"}, {"sha": "e697e98bc06072bcf0400e244208cbc5f8cc40d5", "filename": "src/test/parse-fail/issue-32505.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0221c8897db309a79990367476177b1230bb264/src%2Ftest%2Fparse-fail%2Fissue-32505.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0221c8897db309a79990367476177b1230bb264/src%2Ftest%2Fparse-fail%2Fissue-32505.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-32505.rs?ref=c0221c8897db309a79990367476177b1230bb264", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+pub fn test() {\n+    foo(|_|) //~ ERROR unexpected token: `)`\n+}\n+\n+fn main() { }"}]}