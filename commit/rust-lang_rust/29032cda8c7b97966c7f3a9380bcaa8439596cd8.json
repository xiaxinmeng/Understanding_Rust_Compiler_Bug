{"sha": "29032cda8c7b97966c7f3a9380bcaa8439596cd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MDMyY2RhOGM3Yjk3OTY2YzdmM2E5MzgwYmNhYTg0Mzk1OTZjZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-15T18:55:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-15T18:55:49Z"}, "message": "auto merge of #9168 : michaelwoerister/rust/traits, r=jdm\n\nThis pull request finally adds support for recursive type definitions and provides a stub implementation for object pointers.", "tree": {"sha": "1b5f389275f16de2867d2a94386974174b058393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b5f389275f16de2867d2a94386974174b058393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29032cda8c7b97966c7f3a9380bcaa8439596cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29032cda8c7b97966c7f3a9380bcaa8439596cd8", "html_url": "https://github.com/rust-lang/rust/commit/29032cda8c7b97966c7f3a9380bcaa8439596cd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29032cda8c7b97966c7f3a9380bcaa8439596cd8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8c3c3bdd641411134c53117f4c0a449195d1e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c3c3bdd641411134c53117f4c0a449195d1e10", "html_url": "https://github.com/rust-lang/rust/commit/c8c3c3bdd641411134c53117f4c0a449195d1e10"}, {"sha": "2ffe0836317b896b62c72fe84786bcab1ae4c808", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ffe0836317b896b62c72fe84786bcab1ae4c808", "html_url": "https://github.com/rust-lang/rust/commit/2ffe0836317b896b62c72fe84786bcab1ae4c808"}], "stats": {"total": 1174, "additions": 891, "deletions": 283}, "files": [{"sha": "beadcf3a19df8282bb06091ddf4f56c730703dab", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -2117,6 +2117,9 @@ pub mod llvm {\n                                             LineNo: c_uint)\n                                             -> ValueRef;\n \n+        #[fast_ffi]\n+        pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n+\n         #[fast_ffi]\n         pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n "}, {"sha": "272ce49a3779afaf4be0d3bc7b3a81c65cbc2b00", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 522, "deletions": 282, "changes": 804, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -45,6 +45,46 @@ This file consists of three conceptual sections:\n 2. Module-internal metadata creation functions\n 3. Minor utility functions\n \n+\n+## Recursive Types\n+Some kinds of types, such as structs and enums can be recursive. That means that the type definition\n+of some type X refers to some other type which in turn (transitively) refers to X. This introduces\n+cycles into the type referral graph. A naive algorithm doing an on-demand, depth-first traversal of\n+this graph when describing types, can get trapped in an endless loop when it reaches such a cycle.\n+\n+For example, the following simple type for a singly-linked list...\n+\n+```\n+struct List {\n+    value: int,\n+    tail: Option<@List>,\n+}\n+```\n+\n+will generate the following callstack with a naive DFS algorithm:\n+\n+```\n+describe(t = List)\n+  describe(t = int)\n+  describe(t = Option<@List>)\n+    describe(t = @List)\n+      describe(t = List) // at the beginning again...\n+      ...\n+```\n+\n+To break cycles like these, we use \"forward declarations\". That is, when the algorithm encounters a\n+possibly recursive type (any struct or enum), it immediately creates a type description node and\n+inserts it into the cache *before* describing the members of the type. This type description is just\n+a stub (as type members are not described and added to it yet) but it allows the algorithm to\n+already refer to the type. After the stub is inserted into the cache, the algorithm continues as\n+before. If it now encounters a recursive reference, it will hit the cache and does not try to\n+describe the type anew.\n+\n+This behaviour is encapsulated in the 'RecursiveTypeDescription' enum, which represents a kind of\n+continuation, storing all state needed to continue traversal at the type members after the type has\n+been registered with the cache. (This implementation approach might be a tad over-engineered and\n+may change in the future)\n+\n */\n \n \n@@ -60,7 +100,7 @@ use middle::trans::adt;\n use middle::trans;\n use middle::ty;\n use middle::pat_util;\n-use util::ppaux::ty_to_str;\n+use util::ppaux;\n \n use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n@@ -84,9 +124,6 @@ static DW_ATE_signed_char: c_uint = 0x06;\n static DW_ATE_unsigned: c_uint = 0x07;\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n-\n-\n-\n //=-------------------------------------------------------------------------------------------------\n //  Public Interface of debuginfo module\n //=-------------------------------------------------------------------------------------------------\n@@ -513,7 +550,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n                 ast::item_fn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, fn_decl, generics, Some(top_level_block), item.span)\n+                    (item.ident, fn_decl, generics, top_level_block, item.span)\n                 }\n                 _ => {\n                     cx.sess.span_bug(item.span,\n@@ -532,7 +569,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, generics, Some(top_level_block), span)\n+            (ident, fn_decl, generics, top_level_block, span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n@@ -543,7 +580,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n                         &empty_generics,\n-                        Some(top_level_block),\n+                        top_level_block,\n                         expr.span)\n                 }\n                 _ => cx.sess.span_bug(expr.span,\n@@ -562,20 +599,10 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, generics, Some(top_level_block), span)\n+            (ident, fn_decl, generics, top_level_block, span)\n         }\n-        ast_map::node_foreign_item(@ast::foreign_item {\n-                ident: ident,\n-                node: ast::foreign_item_fn(ref fn_decl, ref generics),\n-                span: span,\n-                _\n-            },\n-            _,\n-            _,\n-            _) => {\n-            (ident, fn_decl, generics, None, span)\n-        }\n-        ast_map::node_variant(*)     |\n+        ast_map::node_foreign_item(@ast::foreign_item { _ }, _, _, _) |\n+        ast_map::node_variant(*) |\n         ast_map::node_struct_ctor(*) => {\n             return FunctionWithoutDebugInfo;\n         }\n@@ -591,17 +618,17 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs);\n+        let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs, span);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n     let mut function_name = token::ident_to_str(&ident).to_owned();\n-    let template_parameters = if cx.sess.opts.extra_debuginfo {\n-        get_template_parameters(cx, generics, param_substs, file_metadata, &mut function_name)\n-    } else {\n-        ptr::null()\n-    };\n+    let template_parameters = get_template_parameters(cx,\n+                                                      generics,\n+                                                      param_substs,\n+                                                      file_metadata,\n+                                                      &mut function_name);\n \n     let namespace_node = debug_context(cx).local_namespace_map.find_copy(&fn_ast_id);\n     let (linkage_name, containing_scope) = match namespace_node {\n@@ -610,10 +637,9 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         None => {\n             // This branch is only hit when there is a bug in the NamespaceVisitor.\n-            cx.sess.span_warn(span, \"debuginfo: Could not find namespace node for function. \\\n-                                     This is a bug! Try running with RUST_LOG=rustc=1 \\\n-                                     to get further details and report the results \\\n-                                     to github.com/mozilla/rust/issues\");\n+            cx.sess.span_warn(span, fmt!(\"debuginfo: Could not find namespace node for function\n+                                          with name %s. This is a bug! Please report this to\n+                                          github.com/mozilla/rust/issues\", function_name));\n             (function_name.clone(), file_metadata)\n         }\n     };\n@@ -653,24 +679,23 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    match top_level_block {\n-        Some(top_level_block) => {\n-            let mut namespace_visitor = NamespaceVisitor::new_function_visitor(cx,\n-                                                                               function_name,\n-                                                                               namespace_node,\n-                                                                               file_metadata,\n-                                                                               span);\n-            visit::walk_block(&mut namespace_visitor, top_level_block, ());\n-        }\n-        _ => { /*nothing to do*/ }\n+    // Create namespaces for the interior of this function\n+    {\n+        let mut namespace_visitor = NamespaceVisitor::new_function_visitor(cx,\n+                                                                           function_name,\n+                                                                           namespace_node,\n+                                                                           file_metadata,\n+                                                                           span);\n+        visit::walk_block(&mut namespace_visitor, top_level_block, ());\n     }\n \n     return FunctionDebugContext(fn_debug_context);\n \n     fn get_function_signature(cx: &mut CrateContext,\n                               fn_ast_id: ast::NodeId,\n                               fn_decl: &ast::fn_decl,\n-                              param_substs: Option<@param_substs>) -> DIArray {\n+                              param_substs: Option<@param_substs>,\n+                              error_span: Span) -> DIArray {\n         if !cx.sess.opts.extra_debuginfo {\n             return create_DIArray(DIB(cx), []);\n         }\n@@ -683,6 +708,8 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                 signature.push(ptr::null());\n             }\n             _ => {\n+                assert_type_for_node_id(cx, fn_ast_id, error_span);\n+\n                 let return_type = ty::node_id_to_type(cx.tcx, fn_ast_id);\n                 let return_type = match param_substs {\n                     None => return_type,\n@@ -697,6 +724,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n         // Arguments types\n         for arg in fn_decl.inputs.iter() {\n+            assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n             let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n             let arg_type = match param_substs {\n                 None => arg_type,\n@@ -726,7 +754,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         let has_self_type = self_type.is_some();\n \n         if !generics.is_type_parameterized() && !has_self_type {\n-            return ptr::null();\n+            return create_DIArray(DIB(cx), []);\n         }\n \n         name_to_append_suffix_to.push_char('<');\n@@ -737,33 +765,37 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         // Handle self type\n         if has_self_type {\n             let actual_self_type = self_type.unwrap();\n-            let actual_self_type_metadata = type_metadata(cx,\n-                                                          actual_self_type,\n-                                                          codemap::dummy_sp());\n-\n             // Add self type name to <...> clause of function name\n-            let actual_self_type_name = ty_to_str(cx.tcx, actual_self_type);\n+            let actual_self_type_name = ppaux::ty_to_str(cx.tcx, actual_self_type);\n             name_to_append_suffix_to.push_str(actual_self_type_name);\n+\n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let ident = special_idents::type_self;\n+            // Only create type information if extra_debuginfo is enabled\n+            if cx.sess.opts.extra_debuginfo {\n+                let actual_self_type_metadata = type_metadata(cx,\n+                                                              actual_self_type,\n+                                                              codemap::dummy_sp());\n \n-            let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        file_metadata,\n-                        name,\n-                        actual_self_type_metadata,\n-                        ptr::null(),\n-                        0,\n-                        0)\n-                }\n-            };\n+                let ident = special_idents::type_self;\n \n-            template_params.push(param_metadata);\n+                let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                            DIB(cx),\n+                            file_metadata,\n+                            name,\n+                            actual_self_type_metadata,\n+                            ptr::null(),\n+                            0,\n+                            0)\n+                    }\n+                };\n+\n+                template_params.push(param_metadata);\n+            }\n         }\n \n         // Handle other generic parameters\n@@ -776,30 +808,31 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n         for (index, &ast::TyParam{ ident: ident, _ }) in generics.ty_params.iter().enumerate() {\n             let actual_type = actual_types[index];\n-            let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n-\n             // Add actual type name to <...> clause of function name\n-            let actual_type_name = ty_to_str(cx.tcx, actual_type);\n+            let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n             name_to_append_suffix_to.push_str(actual_type_name);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        file_metadata,\n-                        name,\n-                        actual_type_metadata,\n-                        ptr::null(),\n-                        0,\n-                        0)\n-                }\n-            };\n-\n-            template_params.push(param_metadata);\n+            // Again, only create type information if extra_debuginfo is enabled\n+            if cx.sess.opts.extra_debuginfo {\n+                let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n+                let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                            DIB(cx),\n+                            file_metadata,\n+                            name,\n+                            actual_type_metadata,\n+                            ptr::null(),\n+                            0,\n+                            0)\n+                    }\n+                };\n+                template_params.push(param_metadata);\n+            }\n         }\n \n         name_to_append_suffix_to.push_char('>');\n@@ -808,14 +841,14 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     }\n \n     fn get_scope_line(cx: &CrateContext,\n-                      top_level_block: Option<&ast::Block>,\n+                      top_level_block: &ast::Block,\n                       default: uint)\n                    -> uint {\n-        match top_level_block {\n-            Some(&ast::Block { stmts: ref statements, _ }) if statements.len() > 0 => {\n+        match *top_level_block {\n+            ast::Block { stmts: ref statements, _ } if statements.len() > 0 => {\n                 span_start(cx, statements[0].span).line\n             }\n-            Some(&ast::Block { expr: Some(@ref expr), _ }) => {\n+            ast::Block { expr: Some(@ref expr), _ } => {\n                 span_start(cx, expr.span).line\n             }\n             _ => default\n@@ -1039,7 +1072,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n                       -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n-    let name = ty_to_str(cx.tcx, pointer_type);\n+    let name = ppaux::ty_to_str(cx.tcx, pointer_type);\n     let ptr_metadata = do name.with_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n@@ -1053,81 +1086,144 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     return ptr_metadata;\n }\n \n-fn struct_metadata(cx: &mut CrateContext,\n-                   struct_type: ty::t,\n-                   def_id: ast::DefId,\n-                   substs: &ty::substs,\n-                   span: Span)\n-                -> DICompositeType {\n-    let struct_name = ty_to_str(cx.tcx, struct_type);\n-    debug!(\"struct_metadata: %s\", struct_name);\n-\n+fn prepare_struct_metadata(cx: &mut CrateContext,\n+                           struct_type: ty::t,\n+                           def_id: ast::DefId,\n+                           substs: &ty::substs,\n+                           span: Span)\n+                        -> RecursiveTypeDescription {\n+    let struct_name = ppaux::ty_to_str(cx.tcx, struct_type);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n-    let fields = ty::struct_fields(cx.tcx, def_id, substs);\n-    let field_descriptions = do fields.map |field| {\n-        let name = if field.ident.name == special_idents::unnamed_field.name {\n-            @\"\"\n-        } else {\n-            token::ident_to_str(&field.ident)\n-        };\n-\n-        MemberDescription {\n-            name: name,\n-            llvm_type: type_of::type_of(cx, field.mt.ty),\n-            type_metadata: type_metadata(cx, field.mt.ty, span),\n-        }\n-    };\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n \n     let file_name = span_start(cx, definition_span).file.name;\n     let file_metadata = file_metadata(cx, file_name);\n \n-    return composite_type_metadata(\n-        cx,\n-        struct_llvm_type,\n-        struct_name,\n-        field_descriptions,\n-        containing_scope,\n-        file_metadata,\n-        definition_span);\n+    let struct_metadata_stub = create_struct_stub(cx,\n+                                                  struct_llvm_type,\n+                                                  struct_name,\n+                                                  containing_scope,\n+                                                  file_metadata,\n+                                                  definition_span);\n+\n+    let fields = ty::struct_fields(cx.tcx, def_id, substs);\n+\n+    UnfinishedMetadata {\n+        cache_id: cache_id_for_type(struct_type),\n+        metadata_stub: struct_metadata_stub,\n+        llvm_type: struct_llvm_type,\n+        file_metadata: file_metadata,\n+        member_description_factory: |cx| {\n+            do fields.map |field| {\n+                let name = if field.ident.name == special_idents::unnamed_field.name {\n+                    @\"\"\n+                } else {\n+                    token::ident_to_str(&field.ident)\n+                };\n+\n+                MemberDescription {\n+                    name: name,\n+                    llvm_type: type_of::type_of(cx, field.mt.ty),\n+                    type_metadata: type_metadata(cx, field.mt.ty, span),\n+                    offset: ComputedMemberOffset,\n+                }\n+            }\n+        }\n+    }\n }\n \n-fn tuple_metadata(cx: &mut CrateContext,\n-                  tuple_type: ty::t,\n-                  component_types: &[ty::t],\n-                  span: Span)\n-               -> DICompositeType {\n-    let tuple_name = ty_to_str(cx.tcx, tuple_type);\n-    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n+enum RecursiveTypeDescription {\n+    UnfinishedMetadata {\n+        cache_id: uint,\n+        metadata_stub: DICompositeType,\n+        llvm_type: Type,\n+        file_metadata: DIFile,\n+        member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription],\n+    },\n+    FinalMetadata(DICompositeType)\n+}\n \n-    let component_descriptions = do component_types.map |&component_type| {\n-        MemberDescription {\n-            name: @\"\",\n-            llvm_type: type_of::type_of(cx, component_type),\n-            type_metadata: type_metadata(cx, component_type, span),\n+impl RecursiveTypeDescription {\n+\n+    fn metadata(&self) -> DICompositeType {\n+        match *self {\n+            UnfinishedMetadata { metadata_stub, _ } => metadata_stub,\n+            FinalMetadata(metadata) => metadata\n         }\n-    };\n+    }\n+\n+    fn finalize(&self, cx: &mut CrateContext) -> DICompositeType {\n+        match *self {\n+            FinalMetadata(metadata) => metadata,\n+            UnfinishedMetadata {\n+                cache_id,\n+                metadata_stub,\n+                llvm_type,\n+                file_metadata,\n+                member_description_factory\n+            } => {\n+                // Insert the stub into the cache in order to allow recursive references ...\n+                debug_context(cx).created_types.insert(cache_id, metadata_stub);\n+\n+                // ... then create the member descriptions ...\n+                let member_descriptions = member_description_factory(cx);\n+\n+                // ... and attach them to the stub to complete it.\n+                set_members_of_composite_type(cx,\n+                                              metadata_stub,\n+                                              llvm_type,\n+                                              member_descriptions,\n+                                              file_metadata,\n+                                              codemap::dummy_sp());\n+                return metadata_stub;\n+            }\n+        }\n+    }\n+}\n+\n+fn prepare_tuple_metadata(cx: &mut CrateContext,\n+                          tuple_type: ty::t,\n+                          component_types: &[ty::t],\n+                          span: Span)\n+                       -> RecursiveTypeDescription {\n+    let tuple_name = ppaux::ty_to_str(cx.tcx, tuple_type);\n+    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n-\n-    return composite_type_metadata(\n-        cx,\n-        tuple_llvm_type,\n-        tuple_name,\n-        component_descriptions,\n-        file_metadata,\n-        file_metadata,\n-        span);\n+    // Needs to be copied for closure below :(\n+    let component_types = component_types.to_owned();\n+\n+    UnfinishedMetadata {\n+        cache_id: cache_id_for_type(tuple_type),\n+        metadata_stub: create_struct_stub(cx,\n+                                          tuple_llvm_type,\n+                                          tuple_name,\n+                                          file_metadata,\n+                                          file_metadata,\n+                                          span),\n+        llvm_type: tuple_llvm_type,\n+        file_metadata: file_metadata,\n+        member_description_factory: |cx| {\n+            do component_types.map |&component_type| {\n+                MemberDescription {\n+                    name: @\"\",\n+                    llvm_type: type_of::type_of(cx, component_type),\n+                    type_metadata: type_metadata(cx, component_type, span),\n+                    offset: ComputedMemberOffset,\n+                }\n+            }\n+        }\n+    }\n }\n \n-fn enum_metadata(cx: &mut CrateContext,\n-                 enum_type: ty::t,\n-                 enum_def_id: ast::DefId,\n-                 span: Span)\n-              -> DIType {\n-    let enum_name = ty_to_str(cx.tcx, enum_type);\n+fn prepare_enum_metadata(cx: &mut CrateContext,\n+                         enum_type: ty::t,\n+                         enum_def_id: ast::DefId,\n+                         span: Span)\n+                      -> RecursiveTypeDescription {\n+    let enum_name = ppaux::ty_to_str(cx.tcx, enum_type);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx,\n                                                                               enum_def_id,\n@@ -1138,24 +1234,26 @@ fn enum_metadata(cx: &mut CrateContext,\n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        return composite_type_metadata(cx,\n-                                       Type::nil(),\n-                                       enum_name,\n-                                       [],\n-                                       file_metadata,\n-                                       file_metadata,\n-                                       definition_span);\n+        let empty_type_metadata = composite_type_metadata(cx,\n+                                                          Type::nil(),\n+                                                          enum_name,\n+                                                          [],\n+                                                          containing_scope,\n+                                                          file_metadata,\n+                                                          definition_span);\n+\n+        return FinalMetadata(empty_type_metadata);\n     }\n \n-    // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n+    // Prepare some data (llvm type, size, align, etc) about the discriminant. This data will be\n     // needed in all of the following cases.\n     let discriminant_llvm_type = Type::enum_discrim(cx);\n     let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n \n     assert!(Type::enum_discrim(cx) == cx.int_type);\n     let discriminant_base_type_metadata = type_metadata(cx, ty::mk_int(), codemap::dummy_sp());\n \n-    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants = ty::enum_variants(cx.tcx, enum_def_id);\n \n     let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n@@ -1191,55 +1289,34 @@ fn enum_metadata(cx: &mut CrateContext,\n \n     let type_rep = adt::represent_type(cx, enum_type);\n \n-    match *type_rep {\n+    return match *type_rep {\n         adt::CEnum(*) => {\n-            return discriminant_type_metadata;\n+            FinalMetadata(discriminant_type_metadata)\n         }\n         adt::Univariant(ref struct_def, _) => {\n             assert!(variants.len() == 1);\n-            return adt_struct_metadata(cx,\n-                                       struct_def,\n-                                       variants[0],\n-                                       None,\n-                                       containing_scope,\n-                                       file_metadata,\n-                                       span);\n+            let (metadata_stub,\n+                 variant_llvm_type,\n+                 member_description_factory) = describe_variant(cx,\n+                                                                struct_def,\n+                                                                variants[0],\n+                                                                None,\n+                                                                containing_scope,\n+                                                                file_metadata,\n+                                                                span);\n+            UnfinishedMetadata {\n+                cache_id: cache_id_for_type(enum_type),\n+                metadata_stub: metadata_stub,\n+                llvm_type: variant_llvm_type,\n+                file_metadata: file_metadata,\n+                member_description_factory: member_description_factory\n+            }\n         }\n-        adt::General(ref struct_defs) => {\n-            let variants_member_metadata: ~[DIDescriptor] = do struct_defs\n-                .iter()\n-                .enumerate()\n-                .map |(i, struct_def)| {\n-                    let variant_type_metadata = adt_struct_metadata(\n-                        cx,\n-                        struct_def,\n-                        variants[i],\n-                        Some(discriminant_type_metadata),\n-                        containing_scope,\n-                        file_metadata,\n-                        span);\n-\n-                    do \"\".with_c_str |name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateMemberType(\n-                                DIB(cx),\n-                                containing_scope,\n-                                name,\n-                                file_metadata,\n-                                loc.line as c_uint,\n-                                bytes_to_bits(struct_def.size as uint),\n-                                bytes_to_bits(struct_def.align as uint),\n-                                bytes_to_bits(0),\n-                                0,\n-                                variant_type_metadata)\n-                        }\n-                    }\n-            }.collect();\n-\n+        adt::General(_) => {\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            return do enum_name.with_c_str |enum_name| {\n+            let enum_metadata = do enum_name.with_c_str |enum_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n@@ -1250,55 +1327,85 @@ fn enum_metadata(cx: &mut CrateContext,\n                     bytes_to_bits(enum_type_size),\n                     bytes_to_bits(enum_type_align),\n                     0, // Flags\n-                    create_DIArray(DIB(cx), variants_member_metadata),\n+                    ptr::null(),\n                     0) // RuntimeLang\n             }};\n+\n+            UnfinishedMetadata {\n+                cache_id: cache_id_for_type(enum_type),\n+                metadata_stub: enum_metadata,\n+                llvm_type: enum_llvm_type,\n+                file_metadata: file_metadata,\n+                member_description_factory: |cx| {\n+                    // Capture type_rep, so we don't have to copy the struct_defs array\n+                    let struct_defs = match *type_rep {\n+                        adt::General(ref struct_defs) => struct_defs,\n+                        _ => cx.sess.bug(\"unreachable\")\n+                    };\n+\n+                    do struct_defs\n+                        .iter()\n+                        .enumerate()\n+                        .map |(i, struct_def)| {\n+                            let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+                                describe_variant(cx,\n+                                                 struct_def,\n+                                                 variants[i],\n+                                                 Some(discriminant_type_metadata),\n+                                                 containing_scope,\n+                                                 file_metadata,\n+                                                 span);\n+\n+                            let member_descriptions = member_desc_factory(cx);\n+\n+                            set_members_of_composite_type(cx,\n+                                                          variant_type_metadata,\n+                                                          variant_llvm_type,\n+                                                          member_descriptions,\n+                                                          file_metadata,\n+                                                          codemap::dummy_sp());\n+                            MemberDescription {\n+                                name: @\"\",\n+                                llvm_type: variant_llvm_type,\n+                                type_metadata: variant_type_metadata,\n+                                offset: FixedMemberOffset { bytes: 0 },\n+                            }\n+                    }.collect()\n+                }\n+            }\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n-            return adt_struct_metadata(cx,\n-                                       struct_def,\n-                                       variants[nndiscr],\n-                                       None,\n-                                       containing_scope,\n-                                       file_metadata,\n-                                       span);\n-        }\n-    }\n-\n-    fn adt_struct_metadata(cx: &mut CrateContext,\n-                                  struct_def: &adt::Struct,\n-                                  variant_info: &ty::VariantInfo,\n-                                  discriminant_type_metadata: Option<DIType>,\n-                                  containing_scope: DIScope,\n-                                  file_metadata: DIFile,\n-                                  span: Span)\n-                               -> DICompositeType {\n-        // Get the argument names from the enum variant info\n-        let mut arg_names = match variant_info.arg_names {\n-            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n-            None => do variant_info.args.map |_| { @\"\" }\n-        };\n-\n-        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n-        if discriminant_type_metadata.is_some() {\n-            arg_names.insert(0, @\"\");\n+            let (metadata_stub,\n+                 variant_llvm_type,\n+                 member_description_factory) = describe_variant(cx,\n+                                                                struct_def,\n+                                                                variants[nndiscr],\n+                                                                None,\n+                                                                containing_scope,\n+                                                                file_metadata,\n+                                                                span);\n+            UnfinishedMetadata {\n+                cache_id: cache_id_for_type(enum_type),\n+                metadata_stub: metadata_stub,\n+                llvm_type: variant_llvm_type,\n+                file_metadata: file_metadata,\n+                member_description_factory: member_description_factory\n+            }\n         }\n+    };\n \n-        let arg_descriptions : ~[MemberDescription] =\n-            do struct_def.fields.iter().enumerate().map |(i, &ty)| {\n-                MemberDescription {\n-                    name: arg_names[i].clone(),\n-                    llvm_type: type_of::type_of(cx, ty),\n-                    type_metadata: match discriminant_type_metadata {\n-                        Some(metadata) if i == 0 => metadata,\n-                        _                        => type_metadata(cx, ty, span)\n-                    }\n-                }\n-            }.collect();\n-\n+    fn describe_variant(cx: &mut CrateContext,\n+                        struct_def: &adt::Struct,\n+                        variant_info: &ty::VariantInfo,\n+                        discriminant_type_metadata: Option<DIType>,\n+                        containing_scope: DIScope,\n+                        file_metadata: DIFile,\n+                        span: Span)\n+                     -> (DICompositeType, Type, @fn(&mut CrateContext) -> ~[MemberDescription]) {\n         let variant_name = token::ident_to_str(&variant_info.name);\n-        let variant_llvm_type = Type::struct_(arg_descriptions.map(|d| d.llvm_type),\n+        let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n                                               struct_def.packed);\n+        // Could some consistency checks here: size, align, field count, discr type\n \n         // Find the source code location of the variant's definition\n         let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n@@ -1316,21 +1423,59 @@ fn enum_metadata(cx: &mut CrateContext,\n             codemap::dummy_sp()\n         };\n \n-        return composite_type_metadata(\n-            cx,\n-            variant_llvm_type,\n-            variant_name,\n-            arg_descriptions,\n-            containing_scope,\n-            file_metadata,\n-            variant_definition_span);\n+        let metadata_stub = create_struct_stub(cx,\n+                                               variant_llvm_type,\n+                                               variant_name,\n+                                               containing_scope,\n+                                               file_metadata,\n+                                               variant_definition_span);\n+\n+        // Get the argument names from the enum variant info\n+        let mut arg_names = match variant_info.arg_names {\n+            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n+            None => do variant_info.args.map |_| { @\"\" }\n+        };\n+\n+        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n+        if discriminant_type_metadata.is_some() {\n+            arg_names.insert(0, @\"\");\n+        }\n+\n+        // Build an array of (field name, field type) pairs to be captured in the factory closure.\n+        let args: ~[(@str, ty::t)] = arg_names.iter()\n+            .zip(struct_def.fields.iter())\n+            .map(|(&s, &t)| (s, t))\n+            .collect();\n+\n+        let member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription] = |cx| {\n+            do args.iter().enumerate().map |(i, &(name, ty))| {\n+                MemberDescription {\n+                    name: name,\n+                    llvm_type: type_of::type_of(cx, ty),\n+                    type_metadata: match discriminant_type_metadata {\n+                        Some(metadata) if i == 0 => metadata,\n+                        _ => type_metadata(cx, ty, span)\n+                    },\n+                    offset: ComputedMemberOffset,\n+                }\n+            }.collect()\n+        };\n+\n+        (metadata_stub, variant_llvm_type, member_description_factory)\n     }\n }\n \n+enum MemberOffset {\n+    FixedMemberOffset { bytes: uint },\n+    // For ComputedMemberOffset, the offset is read from the llvm type definition\n+    ComputedMemberOffset\n+}\n+\n struct MemberDescription {\n     name: @str,\n     llvm_type: Type,\n     type_metadata: DIType,\n+    offset: MemberOffset,\n }\n \n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n@@ -1344,22 +1489,48 @@ fn composite_type_metadata(cx: &mut CrateContext,\n                            file_metadata: DIFile,\n                            definition_span: Span)\n                         -> DICompositeType {\n-    let loc = span_start(cx, definition_span);\n+    // Create the (empty) struct metadata node ...\n+    let composite_type_metadata = create_struct_stub(cx,\n+                                                     composite_llvm_type,\n+                                                     composite_type_name,\n+                                                     containing_scope,\n+                                                     file_metadata,\n+                                                     definition_span);\n+\n+    // ... and immediately create and add the member descriptions.\n+    set_members_of_composite_type(cx,\n+                                  composite_type_metadata,\n+                                  composite_llvm_type,\n+                                  member_descriptions,\n+                                  file_metadata,\n+                                  definition_span);\n+\n+    return composite_type_metadata;\n+}\n \n-    let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n+fn set_members_of_composite_type(cx: &mut CrateContext,\n+                                 composite_type_metadata: DICompositeType,\n+                                 composite_llvm_type: Type,\n+                                 member_descriptions: &[MemberDescription],\n+                                 file_metadata: DIFile,\n+                                 definition_span: Span) {\n+    let loc = span_start(cx, definition_span);\n \n     let member_metadata: ~[DIDescriptor] = member_descriptions\n         .iter()\n         .enumerate()\n         .map(|(i, member_description)| {\n             let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n-            let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n+            let member_offset = match member_description.offset {\n+                FixedMemberOffset { bytes } => bytes,\n+                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n+            };\n \n             do member_description.name.with_c_str |member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n-                        file_metadata,\n+                        composite_type_metadata,\n                         member_name,\n                         file_metadata,\n                         loc.line as c_uint,\n@@ -1373,19 +1544,41 @@ fn composite_type_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    return do composite_type_name.with_c_str |name| {\n+    unsafe {\n+        let type_array = create_DIArray(DIB(cx), member_metadata);\n+        llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n+    }\n+}\n+\n+// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any caching, does not\n+// add any fields to the struct. This can be done later with set_members_of_composite_type().\n+fn create_struct_stub(cx: &mut CrateContext,\n+                      struct_llvm_type: Type,\n+                      struct_type_name: &str,\n+                      containing_scope: DIScope,\n+                      file_metadata: DIFile,\n+                      definition_span: Span)\n+                   -> DICompositeType {\n+    let loc = span_start(cx, definition_span);\n+    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n+\n+    return do struct_type_name.with_c_str |name| {\n         unsafe {\n+            // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n+            // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n+            let empty_array = create_DIArray(DIB(cx), []);\n+\n             llvm::LLVMDIBuilderCreateStructType(\n                 DIB(cx),\n                 containing_scope,\n                 name,\n                 file_metadata,\n                 loc.line as c_uint,\n-                bytes_to_bits(composite_size),\n-                bytes_to_bits(composite_align),\n+                bytes_to_bits(struct_size),\n+                bytes_to_bits(struct_align),\n                 0,\n                 ptr::null(),\n-                create_DIArray(DIB(cx), member_metadata),\n+                empty_array,\n                 0,\n                 ptr::null())\n     }};\n@@ -1415,26 +1608,31 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n             name: @\"refcnt\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: type_metadata(cx, int_type, codemap::dummy_sp()),\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"tydesc\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: nil_pointer_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"prev\",\n             llvm_type: member_llvm_types[2],\n             type_metadata: nil_pointer_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"next\",\n             llvm_type: member_llvm_types[3],\n             type_metadata: nil_pointer_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"val\",\n             llvm_type: member_llvm_types[4],\n-            type_metadata: content_type_metadata\n+            type_metadata: content_type_metadata,\n+            offset: ComputedMemberOffset,\n         }\n     ];\n \n@@ -1502,7 +1700,7 @@ fn vec_metadata(cx: &mut CrateContext,\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = fmt!(\"[%s]\", ty_to_str(cx.tcx, element_type));\n+    let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n \n@@ -1521,16 +1719,19 @@ fn vec_metadata(cx: &mut CrateContext,\n             name: @\"fill\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: int_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"alloc\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: int_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"elements\",\n             llvm_type: member_llvm_types[2],\n             type_metadata: array_type_metadata,\n+            offset: ComputedMemberOffset,\n         }\n     ];\n \n@@ -1553,10 +1754,9 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n                       element_type: ty::t,\n                       span: Span)\n                    -> DICompositeType {\n-\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = fmt!(\"[%s]\", ty_to_str(cx.tcx, element_type));\n+    let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n     let vec_metadata = vec_metadata(cx, element_type, span);\n \n     return boxed_type_metadata(\n@@ -1576,7 +1776,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n     debug!(\"vec_slice_metadata: %?\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = ty_to_str(cx.tcx, vec_type);\n+    let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n@@ -1588,11 +1788,13 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n             name: @\"data_ptr\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"size_in_bytes\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n+            offset: ComputedMemberOffset,\n         },\n     ];\n \n@@ -1648,10 +1850,47 @@ fn subroutine_type_metadata(cx: &mut CrateContext,\n     };\n }\n \n+fn trait_metadata(cx: &mut CrateContext,\n+                  def_id: ast::DefId,\n+                  trait_type: ty::t,\n+                  substs: &ty::substs,\n+                  trait_store: ty::TraitStore,\n+                  mutability: ast::Mutability,\n+                  _: &ty::BuiltinBounds,\n+                  usage_site_span: Span)\n+               -> DIType {\n+    // The implementation provided here is a stub. It makes sure that the trait type is\n+    // assigned the correct name, size, namespace, and source location. But it does not describe\n+    // the trait's methods.\n+    let path = ty::item_path(cx.tcx, def_id);\n+    let ident = path.last().ident();\n+    let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n+               ppaux::mutability_to_str(mutability) +\n+               token::ident_to_str(&ident);\n+    // Add type and region parameters\n+    let name = ppaux::parameterized(cx.tcx, name, &substs.regions, substs.tps);\n+\n+    let (containing_scope, definition_span) =\n+        get_namespace_and_span_for_item(cx, def_id, usage_site_span);\n+\n+    let file_name = span_start(cx, definition_span).file.name;\n+    let file_metadata = file_metadata(cx, file_name);\n+\n+    let trait_llvm_type = type_of::type_of(cx, trait_type);\n+\n+    return composite_type_metadata(cx,\n+                                   trait_llvm_type,\n+                                   name,\n+                                   [],\n+                                   containing_scope,\n+                                   file_metadata,\n+                                   definition_span);\n+}\n+\n fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n \n-    let name = ty_to_str(cx.tcx, t);\n+    let name = ppaux::ty_to_str(cx.tcx, t);\n     let metadata = do fmt!(\"NYI<%s>\", name).with_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n@@ -1666,12 +1905,16 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     return metadata;\n }\n \n+fn cache_id_for_type(t: ty::t) -> uint {\n+    ty::type_id(t)\n+}\n+\n fn type_metadata(cx: &mut CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n-    let type_id = ty::type_id(t);\n-    match debug_context(cx).created_types.find(&type_id) {\n+    let cache_id = cache_id_for_type(t);\n+    match debug_context(cx).created_types.find(&cache_id) {\n         Some(type_metadata) => return *type_metadata,\n         None => ()\n     }\n@@ -1680,8 +1923,7 @@ fn type_metadata(cx: &mut CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n-\n-        let content_type_name: &str = ty_to_str(cx.tcx, type_in_box);\n+        let content_type_name: &str = ppaux::ty_to_str(cx.tcx, type_in_box);\n         let content_llvm_type = type_of::type_of(cx, type_in_box);\n         let content_type_metadata = type_metadata(\n             cx,\n@@ -1731,7 +1973,7 @@ fn type_metadata(cx: &mut CrateContext,\n             }\n         },\n         ty::ty_enum(def_id, _) => {\n-            enum_metadata(cx, t, def_id, usage_site_span)\n+            prepare_enum_metadata(cx, t, def_id, usage_site_span).finalize(cx)\n         },\n         ty::ty_box(ref mt) => {\n             create_pointer_to_box_metadata(cx, t, mt.ty)\n@@ -1773,24 +2015,22 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n         },\n-        ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n-            cx.sess.span_note(usage_site_span, \"debuginfo for trait NYI\");\n-            unimplemented_type_metadata(cx, t)\n+        ty::ty_trait(def_id, ref substs, trait_store, mutability, ref bounds) => {\n+            trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds, usage_site_span)\n         },\n         ty::ty_struct(def_id, ref substs) => {\n-            struct_metadata(cx, t, def_id, substs, usage_site_span)\n+            prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n         },\n         ty::ty_tup(ref elements) => {\n-            tuple_metadata(cx, t, *elements, usage_site_span)\n+            prepare_tuple_metadata(cx, t, *elements, usage_site_span).finalize(cx)\n         },\n         ty::ty_opaque_box => {\n-            cx.sess.span_note(usage_site_span, \"debuginfo for ty_opaque_box NYI\");\n-            unimplemented_type_metadata(cx, t)\n+            create_pointer_to_box_metadata(cx, t, ty::mk_nil())\n         }\n         _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n     };\n \n-    debug_context(cx).created_types.insert(type_id, type_metadata);\n+    debug_context(cx).created_types.insert(cache_id, type_metadata);\n     return type_metadata;\n }\n \n@@ -1872,21 +2112,19 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx.get_ref().builder\n }\n \n-fn assert_fcx_has_span(fcx: &FunctionContext) {\n-    if fcx.span.is_none() {\n-        fcx.ccx.sess.bug(fmt!(\"debuginfo: Encountered function %s with invalid source span. \\\n-            This function should have been ignored by debuginfo generation.\",\n-            ast_map::path_to_str(fcx.path, fcx.ccx.sess.intr())));\n-    }\n-}\n-\n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     match fcx.debug_context {\n         FunctionDebugContext(_) => false,\n         _ => true\n     }\n }\n \n+fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n+    if !cx.tcx.node_types.contains_key(&(node_id as uint)) {\n+        cx.sess.span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n+    }\n+}\n+\n fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n                                    def_id: ast::DefId,\n                                    warning_span: Span)\n@@ -1918,7 +2156,7 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n // shadowing.\n fn populate_scope_map(cx: &mut CrateContext,\n                       arg_pats: &[@ast::Pat],\n-                      fn_entry_block: Option<&ast::Block>,\n+                      fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n     let def_map = cx.tcx.def_map;\n@@ -1939,13 +2177,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    for &fn_entry_block in fn_entry_block.iter() {\n-        walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n-    }\n-\n+    walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n \n     // local helper functions for walking the AST.\n-\n     fn with_new_scope(cx: &mut CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],\n@@ -2582,6 +2816,12 @@ impl<'self> visit::Visitor<()> for NamespaceVisitor<'self> {\n         visit::walk_item(self, item, ());\n     }\n \n+    fn visit_foreign_item(&mut self, item: @ast::foreign_item, _: ()) {\n+        debug_context(self.crate_context)\n+            .local_namespace_map\n+            .insert(item.id, *self.scope_stack.last());\n+    }\n+\n     fn visit_fn(&mut self,\n                 _: &visit::fn_kind,\n                 _: &ast::fn_decl,"}, {"sha": "9350bf8d3d9ad87b5b6e1c05187e6417ac6feec3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -235,7 +235,7 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     }\n }\n \n-fn mutability_to_str(m: ast::Mutability) -> ~str {\n+pub fn mutability_to_str(m: ast::Mutability) -> ~str {\n     match m {\n         ast::MutMutable => ~\"mut \",\n         ast::MutImmutable => ~\"\","}, {"sha": "1323db7acba51505a3cb010fe35fae38ac62e06a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -38,6 +38,16 @@ pub enum path_elt {\n     path_pretty_name(Ident, u64),\n }\n \n+impl path_elt {\n+    pub fn ident(&self) -> Ident {\n+        match *self {\n+            path_mod(ident)            |\n+            path_name(ident)           |\n+            path_pretty_name(ident, _) => ident\n+        }\n+    }\n+}\n+\n pub type path = ~[path_elt];\n \n pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)"}, {"sha": "63d42816207cd79dae5cd0713cd6233e2d0d4882", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -789,3 +789,10 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateNameSpace(\n         unwrapDI<DIFile>(File),\n         LineNo));\n }\n+\n+extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n+    LLVMValueRef CompositeType,\n+    LLVMValueRef TypeArray)\n+{\n+    unwrapDI<DICompositeType>(CompositeType).setTypeArray(unwrapDI<DIArray>(TypeArray));\n+}"}, {"sha": "0162857e44e37f9b511e00bf09362e3f1e75522a", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -612,6 +612,7 @@ LLVMDIBuilderCreateOpDeref\n LLVMDIBuilderCreateOpPlus\n LLVMDIBuilderCreateComplexVariable\n LLVMDIBuilderCreateNameSpace\n+LLVMDICompositeTypeSetTypeArray\n LLVMSetUnnamedAddr\n LLVMRustAddPass\n LLVMRustAddAnalysisPasses"}, {"sha": "b8a43d6d16a40a82493afb40fbfc001b0e60e3ff", "filename": "src/test/debug-info/recursive-struct.rs", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -0,0 +1,314 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:rbreak zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print stack_unique.value\n+// check:$1 = 0\n+// debugger:print stack_unique.next.val->value\n+// check:$2 = 1\n+\n+// debugger:print unique_unique->value\n+// check:$3 = 2\n+// debugger:print unique_unique->next.val->value\n+// check:$4 = 3\n+\n+// debugger:print box_unique->val.value\n+// check:$5 = 4\n+// debugger:print box_unique->val.next.val->value\n+// check:$6 = 5\n+\n+// debugger:print vec_unique[0].value\n+// check:$7 = 6.5\n+// debugger:print vec_unique[0].next.val->value\n+// check:$8 = 7.5\n+\n+// debugger:print borrowed_unique->value\n+// check:$9 = 8.5\n+// debugger:print borrowed_unique->next.val->value\n+// check:$10 = 9.5\n+\n+// MANAGED\n+// debugger:print stack_managed.value\n+// check:$11 = 10\n+// debugger:print stack_managed.next.val->val.value\n+// check:$12 = 11\n+\n+// debugger:print unique_managed->val.value\n+// check:$13 = 12\n+// debugger:print unique_managed->val.next.val->val.value\n+// check:$14 = 13\n+\n+// debugger:print box_managed->val.value\n+// check:$15 = 14\n+// debugger:print box_managed->val.next.val->val.value\n+// check:$16 = 15\n+\n+// debugger:print vec_managed[0].value\n+// check:$17 = 16.5\n+// debugger:print vec_managed[0].next.val->val.value\n+// check:$18 = 17.5\n+\n+// debugger:print borrowed_managed->value\n+// check:$19 = 18.5\n+// debugger:print borrowed_managed->next.val->val.value\n+// check:$20 = 19.5\n+\n+// LONG CYCLE\n+// debugger:print long_cycle1.value\n+// check:$21 = 20\n+// debugger:print long_cycle1.next->value\n+// check:$22 = 21\n+// debugger:print long_cycle1.next->next->value\n+// check:$23 = 22\n+// debugger:print long_cycle1.next->next->next->value\n+// check:$24 = 23\n+\n+// debugger:print long_cycle2.value\n+// check:$25 = 24\n+// debugger:print long_cycle2.next->value\n+// check:$26 = 25\n+// debugger:print long_cycle2.next->next->value\n+// check:$27 = 26\n+\n+// debugger:print long_cycle3.value\n+// check:$28 = 27\n+// debugger:print long_cycle3.next->value\n+// check:$29 = 28\n+\n+// debugger:print long_cycle4.value\n+// check:$30 = 29.5\n+\n+// debugger:print (*****long_cycle_w_anonymous_types).value\n+// check:$31 = 30\n+\n+// debugger:print (*****((*****long_cycle_w_anonymous_types).next.val)).value\n+// check:$32 = 31\n+\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+enum Opt<T> {\n+    Empty,\n+    Val { val: T }\n+}\n+\n+struct UniqueNode<T> {\n+    next: Opt<~UniqueNode<T>>,\n+    value: T\n+}\n+\n+struct ManagedNode<T> {\n+    next: Opt<@ManagedNode<T>>,\n+    value: T\n+}\n+\n+struct LongCycle1<T> {\n+    next: ~LongCycle2<T>,\n+    value: T,\n+}\n+\n+struct LongCycle2<T> {\n+    next: ~LongCycle3<T>,\n+    value: T,\n+}\n+\n+struct LongCycle3<T> {\n+    next: ~LongCycle4<T>,\n+    value: T,\n+}\n+\n+struct LongCycle4<T> {\n+    next: Option<~LongCycle1<T>>,\n+    value: T,\n+}\n+\n+struct LongCycleWithAnonymousTypes {\n+    next: Opt<~~~~~LongCycleWithAnonymousTypes>,\n+    value: uint,\n+}\n+\n+// This test case makes sure that recursive structs are properly described. The Node structs are\n+// generic so that we can have a new type (that newly needs to be described) for the different\n+// cases. The potential problem with recursive types is that the DI generation algorithm gets\n+// trapped in an endless loop. To make sure, we actually test this in the different cases, we have\n+// to operate on a new type each time, otherwise we would just hit the DI cache for all but the\n+// first case.\n+\n+// The different cases below (stack_*, unique_*, box_*, etc) are set up so that the type description\n+// algorithm will enter the type reference cycle that is created by a recursive definition from a\n+// different context each time.\n+\n+// The \"long cycle\" cases are constructed to span a longer, indirect recursion cycle between types.\n+// The different locals will cause the DI algorithm to enter the type reference cycle at different\n+// points.\n+\n+fn main() {\n+    let stack_unique: UniqueNode<u16> = UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 1_u16,\n+            }\n+        },\n+        value: 0_u16,\n+    };\n+\n+    let unique_unique: ~UniqueNode<u32> = ~UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 3,\n+            }\n+        },\n+        value: 2,\n+    };\n+\n+    let box_unique: @UniqueNode<u64> = @UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 5,\n+            }\n+        },\n+        value: 4,\n+    };\n+\n+    let vec_unique: [UniqueNode<f32>, ..1] = [UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 7.5,\n+            }\n+        },\n+        value: 6.5,\n+    }];\n+\n+    let borrowed_unique: &UniqueNode<f64> = &UniqueNode {\n+        next: Val {\n+            val: ~UniqueNode {\n+                next: Empty,\n+                value: 9.5,\n+            }\n+        },\n+        value: 8.5,\n+    };\n+\n+    let stack_managed: ManagedNode<u16> = ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 11,\n+            }\n+        },\n+        value: 10,\n+    };\n+\n+    let unique_managed: ~ManagedNode<u32> = ~ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 13,\n+            }\n+        },\n+        value: 12,\n+    };\n+\n+    let box_managed: @ManagedNode<u64> = @ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 15,\n+            }\n+        },\n+        value: 14,\n+    };\n+\n+    let vec_managed: [ManagedNode<f32>, ..1] = [ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 17.5,\n+            }\n+        },\n+        value: 16.5,\n+    }];\n+\n+    let borrowed_managed: &ManagedNode<f64> = &ManagedNode {\n+        next: Val {\n+            val: @ManagedNode {\n+                next: Empty,\n+                value: 19.5,\n+            }\n+        },\n+        value: 18.5,\n+    };\n+\n+    // LONG CYCLE\n+    let long_cycle1: LongCycle1<u16> = LongCycle1 {\n+        next: ~LongCycle2 {\n+            next: ~LongCycle3 {\n+                next: ~LongCycle4 {\n+                    next: None,\n+                    value: 23,\n+                },\n+                value: 22,\n+            },\n+            value: 21\n+        },\n+        value: 20\n+    };\n+\n+    let long_cycle2: LongCycle2<u32> = LongCycle2 {\n+        next: ~LongCycle3 {\n+            next: ~LongCycle4 {\n+                next: None,\n+                value: 26,\n+            },\n+            value: 25,\n+        },\n+        value: 24\n+    };\n+\n+    let long_cycle3: LongCycle3<u64> = LongCycle3 {\n+        next: ~LongCycle4 {\n+            next: None,\n+            value: 28,\n+        },\n+        value: 27,\n+    };\n+\n+    let long_cycle4: LongCycle4<f32> = LongCycle4 {\n+        next: None,\n+        value: 29.5,\n+    };\n+\n+    // It's important that LongCycleWithAnonymousTypes is encountered only at the end of the\n+    // `~` chain.\n+    let long_cycle_w_anonymous_types = ~~~~~LongCycleWithAnonymousTypes {\n+        next: Val {\n+            val: ~~~~~LongCycleWithAnonymousTypes {\n+                next: Empty,\n+                value: 31,\n+            }\n+        },\n+        value: 30\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n+"}, {"sha": "db02e69cfb875001f2e48162f14af93326e84d19", "filename": "src/test/debug-info/trait-pointers.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29032cda8c7b97966c7f3a9380bcaa8439596cd8/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs?ref=29032cda8c7b97966c7f3a9380bcaa8439596cd8", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:run\n+\n+#[allow(unused_variable)];\n+\n+trait Trait {\n+    fn method(&self) -> int { 0 }\n+}\n+\n+struct Struct {\n+    a: int,\n+    b: float\n+}\n+\n+impl Trait for Struct {}\n+\n+// There is no real test here yet. Just make sure that it compiles without crashing.\n+fn main() {\n+    let stack_struct = Struct { a:0, b: 1.0 };\n+    let reference: &Trait = &stack_struct as &Trait;\n+    let managed: @Trait = @Struct { a:2, b: 3.0 } as @Trait;\n+    let unique: ~Trait = ~Struct { a:2, b: 3.0 } as ~Trait;\n+}"}]}