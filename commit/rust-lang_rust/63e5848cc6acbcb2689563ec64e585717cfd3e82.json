{"sha": "63e5848cc6acbcb2689563ec64e585717cfd3e82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTU4NDhjYzZhY2JjYjI2ODk1NjNlYzY0ZTU4NTcxN2NmZDNlODI=", "commit": {"author": {"name": "Abhishek Chanda", "email": "abhishek@cloudscaling.com", "date": "2015-04-15T20:48:42Z"}, "committer": {"name": "Abhishek Chanda", "email": "abhishek@cloudscaling.com", "date": "2015-04-15T20:53:10Z"}, "message": "Move IP related tests to ip.rs\n\n- Also move common functions to test.rs\n- Leaves out Socket address related tests in addr.rs", "tree": {"sha": "f5fbf48d5b1cb57d56bdd7dbb39255db5c6e8f34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5fbf48d5b1cb57d56bdd7dbb39255db5c6e8f34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e5848cc6acbcb2689563ec64e585717cfd3e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e5848cc6acbcb2689563ec64e585717cfd3e82", "html_url": "https://github.com/rust-lang/rust/commit/63e5848cc6acbcb2689563ec64e585717cfd3e82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e5848cc6acbcb2689563ec64e585717cfd3e82/comments", "author": null, "committer": null, "parents": [{"sha": "16e1fcead14628701e1b10b9d00c898d748db2ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e1fcead14628701e1b10b9d00c898d748db2ed", "html_url": "https://github.com/rust-lang/rust/commit/16e1fcead14628701e1b10b9d00c898d748db2ed"}], "stats": {"total": 529, "additions": 270, "deletions": 259}, "files": [{"sha": "2e34e46726fb27b84240ce2d3b10d983856137c2", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 258, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/63e5848cc6acbcb2689563ec64e585717cfd3e82/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e5848cc6acbcb2689563ec64e585717cfd3e82/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=63e5848cc6acbcb2689563ec64e585717cfd3e82", "patch": "@@ -461,264 +461,7 @@ mod tests {\n     use io;\n     use net::*;\n     use net::Ipv6MulticastScope::*;\n-\n-    #[test]\n-    fn test_from_str_ipv4() {\n-        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-        // out of range\n-        let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n-        assert_eq!(None, none);\n-        // no number between dots\n-        let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-                \"2a02:6b8::11:11\".parse());\n-\n-        // too long group\n-        let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-        assert_eq!(None, none);\n-        // triple colon\n-        let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n-        assert_eq!(None, none);\n-        // two double colons\n-        let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)),\n-                \"::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-                \"::FFFF:192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-                \"64:ff9b::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n-\n-        // colon after v4\n-        let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // not enough groups\n-        let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too many groups\n-        let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_socket_addr() {\n-        assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)),\n-                   \"77.88.21.11:80\".parse());\n-        assert_eq!(Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n-                   \"[2a02:6b8:0:1::1]:53\".parse());\n-        assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n-                   \"[::127.0.0.1]:22\".parse());\n-\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // wrong brackets around v4\n-        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-        assert_eq!(None, none);\n-        // port out of range\n-        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn ipv6_addr_to_string() {\n-        // ipv4-mapped address\n-        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n-\n-        // ipv4-compatible address\n-        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n-        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n-\n-        // v6 address with no zero segments\n-        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n-                   \"8:9:a:b:c:d:e:f\");\n-\n-        // reduce a single run of zeros\n-        assert_eq!(\"ae::ffff:102:304\",\n-                   Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string());\n-\n-        // don't reduce just a single zero segment\n-        assert_eq!(\"1:2:3:4:5:6:0:8\",\n-                   Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n-\n-        // 'any' address\n-        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-        // loopback address\n-        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n-\n-        // ends in zeros\n-        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-        // two runs of zeros, second one is longer\n-        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n-\n-        // two runs of zeros, equal length\n-        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n-    }\n-\n-    #[test]\n-    fn ipv4_to_ipv6() {\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n-                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped());\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n-                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible());\n-    }\n-\n-    #[test]\n-    fn ipv6_to_ipv4() {\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n-                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n-        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-                   None);\n-    }\n-\n-    #[test]\n-    fn ipv4_properties() {\n-        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n-                 private: bool, link_local: bool, global: bool,\n-                 multicast: bool, broadcast: bool, documentation: bool) {\n-            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n-            assert_eq!(octets, &ip.octets());\n-\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_private(), private);\n-            assert_eq!(ip.is_link_local(), link_local);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_multicast(), multicast);\n-            assert_eq!(ip.is_broadcast(), broadcast);\n-            assert_eq!(ip.is_documentation(), documentation);\n-        }\n-\n-        //    address                unspec loopbk privt  linloc global multicast brdcast doc\n-        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false,    false,  false);\n-        check(&[0, 0, 0, 1],         false, false, false, false, true,  false,    false,  false);\n-        check(&[1, 0, 0, 0],         false, false, false, false, true,  false,    false,  false);\n-        check(&[10, 9, 8, 7],        false, false, true,  false, false, false,    false,  false);\n-        check(&[127, 1, 2, 3],       false, true,  false, false, false, false,    false,  false);\n-        check(&[172, 31, 254, 253],  false, false, true,  false, false, false,    false,  false);\n-        check(&[169, 254, 253, 242], false, false, false, true,  false, false,    false,  false);\n-        check(&[192, 168, 254, 253], false, false, true,  false, false, false,    false,  false);\n-        check(&[224, 0, 0, 0],       false, false, false, false, true,  true,     false,  false);\n-        check(&[239, 255, 255, 255], false, false, false, false, true,  true,     false,  false);\n-        check(&[255, 255, 255, 255], false, false, false, false, false, false,    true,  false);\n-        check(&[198, 51, 100, 0],    false, false, false, false, false, false,    false,  true);\n-    }\n-\n-    #[test]\n-    fn ipv6_properties() {\n-        fn check(str_addr: &str, unspec: bool, loopback: bool,\n-                 unique_local: bool, global: bool,\n-                 u_link_local: bool, u_site_local: bool, u_global: bool,\n-                 m_scope: Option<Ipv6MulticastScope>) {\n-            let ip: Ipv6Addr = str_addr.parse().unwrap();\n-            assert_eq!(str_addr, ip.to_string());\n-\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_unique_local(), unique_local);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n-            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n-            assert_eq!(ip.is_unicast_global(), u_global);\n-            assert_eq!(ip.multicast_scope(), m_scope);\n-            assert_eq!(ip.is_multicast(), m_scope.is_some());\n-        }\n-\n-        //    unspec loopbk uniqlo global unill  unisl  uniglo mscope\n-        check(\"::\",\n-              true,  false, false, true,  false, false, true,  None);\n-        check(\"::1\",\n-              false, true,  false, false, false, false, false, None);\n-        check(\"::0.0.0.2\",\n-              false, false, false, true,  false, false, true,  None);\n-        check(\"1::\",\n-              false, false, false, true,  false, false, true,  None);\n-        check(\"fc00::\",\n-              false, false, true,  false, false, false, false, None);\n-        check(\"fdff:ffff::\",\n-              false, false, true,  false, false, false, false, None);\n-        check(\"fe80:ffff::\",\n-              false, false, false, false, true,  false, false, None);\n-        check(\"febf:ffff::\",\n-              false, false, false, false, true,  false, false, None);\n-        check(\"fec0::\",\n-              false, false, false, false, false, true,  false, None);\n-        check(\"ff01::\",\n-              false, false, false, false, false, false, false, Some(InterfaceLocal));\n-        check(\"ff02::\",\n-              false, false, false, false, false, false, false, Some(LinkLocal));\n-        check(\"ff03::\",\n-              false, false, false, false, false, false, false, Some(RealmLocal));\n-        check(\"ff04::\",\n-              false, false, false, false, false, false, false, Some(AdminLocal));\n-        check(\"ff05::\",\n-              false, false, false, false, false, false, false, Some(SiteLocal));\n-        check(\"ff08::\",\n-              false, false, false, false, false, false, false, Some(OrganizationLocal));\n-        check(\"ff0e::\",\n-              false, false, false, true,  false, false, false, Some(Global));\n-    }\n-\n-    fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n-        match a.to_socket_addrs() {\n-            Ok(a) => Ok(a.collect()),\n-            Err(e) => Err(e.to_string()),\n-        }\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_socketaddr() {\n-        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n-        assert_eq!(Ok(vec![a]), tsa(a));\n-    }\n-\n-    fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n-        SocketAddr::V4(SocketAddrV4::new(a, p))\n-    }\n-\n-    fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n-        SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n-    }\n+    use net::test::{tsa, sa6, sa4};\n \n     #[test]\n     fn to_socket_addr_ipaddr_u16() {"}, {"sha": "065126c6fdbb564ea0fa30d338f895d2917754f8", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/63e5848cc6acbcb2689563ec64e585717cfd3e82/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e5848cc6acbcb2689563ec64e585717cfd3e82/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=63e5848cc6acbcb2689563ec64e585717cfd3e82", "patch": "@@ -486,3 +486,256 @@ impl FromInner<libc::in6_addr> for Ipv6Addr {\n         Ipv6Addr { inner: addr }\n     }\n }\n+\n+// Tests for this module\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io;\n+    use net::*;\n+    use net::Ipv6MulticastScope::*;\n+    use net::test::{tsa, sa6, sa4};\n+\n+    #[test]\n+    fn test_from_str_ipv4() {\n+        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+        // out of range\n+        let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n+        assert_eq!(None, none);\n+        // no number between dots\n+        let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                \"2a02:6b8::11:11\".parse());\n+\n+        // too long group\n+        let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+        assert_eq!(None, none);\n+        // triple colon\n+        let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n+        assert_eq!(None, none);\n+        // two double colons\n+        let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv4_in_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                \"::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                \"::FFFF:192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                \"64:ff9b::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n+\n+        // colon after v4\n+        let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // not enough groups\n+        let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too many groups\n+        let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_socket_addr() {\n+        assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)),\n+                   \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+                   \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n+                   \"[::127.0.0.1]:22\".parse());\n+\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // wrong brackets around v4\n+        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+        assert_eq!(None, none);\n+        // port out of range\n+        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn ipv6_addr_to_string() {\n+        // ipv4-mapped address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+        // ipv4-compatible address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+        // v6 address with no zero segments\n+        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n+                   \"8:9:a:b:c:d:e:f\");\n+\n+        // reduce a single run of zeros\n+        assert_eq!(\"ae::ffff:102:304\",\n+                   Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string());\n+\n+        // don't reduce just a single zero segment\n+        assert_eq!(\"1:2:3:4:5:6:0:8\",\n+                   Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+        // 'any' address\n+        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // loopback address\n+        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+        // ends in zeros\n+        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // two runs of zeros, second one is longer\n+        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+        // two runs of zeros, equal length\n+        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+    }\n+\n+    #[test]\n+    fn ipv4_to_ipv6() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped());\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible());\n+    }\n+\n+    #[test]\n+    fn ipv6_to_ipv4() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   None);\n+    }\n+\n+    #[test]\n+    fn ipv4_properties() {\n+        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n+                 private: bool, link_local: bool, global: bool,\n+                 multicast: bool, broadcast: bool, documentation: bool) {\n+            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n+            assert_eq!(octets, &ip.octets());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_private(), private);\n+            assert_eq!(ip.is_link_local(), link_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_multicast(), multicast);\n+            assert_eq!(ip.is_broadcast(), broadcast);\n+            assert_eq!(ip.is_documentation(), documentation);\n+        }\n+\n+        //    address                unspec loopbk privt  linloc global multicast brdcast doc\n+        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false,    false,  false);\n+        check(&[0, 0, 0, 1],         false, false, false, false, true,  false,    false,  false);\n+        check(&[1, 0, 0, 0],         false, false, false, false, true,  false,    false,  false);\n+        check(&[10, 9, 8, 7],        false, false, true,  false, false, false,    false,  false);\n+        check(&[127, 1, 2, 3],       false, true,  false, false, false, false,    false,  false);\n+        check(&[172, 31, 254, 253],  false, false, true,  false, false, false,    false,  false);\n+        check(&[169, 254, 253, 242], false, false, false, true,  false, false,    false,  false);\n+        check(&[192, 168, 254, 253], false, false, true,  false, false, false,    false,  false);\n+        check(&[224, 0, 0, 0],       false, false, false, false, true,  true,     false,  false);\n+        check(&[239, 255, 255, 255], false, false, false, false, true,  true,     false,  false);\n+        check(&[255, 255, 255, 255], false, false, false, false, false, false,    true,  false);\n+        check(&[198, 51, 100, 0],    false, false, false, false, false, false,    false,  true);\n+    }\n+\n+    #[test]\n+    fn ipv6_properties() {\n+        fn check(str_addr: &str, unspec: bool, loopback: bool,\n+                 unique_local: bool, global: bool,\n+                 u_link_local: bool, u_site_local: bool, u_global: bool,\n+                 m_scope: Option<Ipv6MulticastScope>) {\n+            let ip: Ipv6Addr = str_addr.parse().unwrap();\n+            assert_eq!(str_addr, ip.to_string());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_unique_local(), unique_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n+            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n+            assert_eq!(ip.is_unicast_global(), u_global);\n+            assert_eq!(ip.multicast_scope(), m_scope);\n+            assert_eq!(ip.is_multicast(), m_scope.is_some());\n+        }\n+\n+        //    unspec loopbk uniqlo global unill  unisl  uniglo mscope\n+        check(\"::\",\n+              true,  false, false, true,  false, false, true,  None);\n+        check(\"::1\",\n+              false, true,  false, false, false, false, false, None);\n+        check(\"::0.0.0.2\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"1::\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"fc00::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fdff:ffff::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fe80:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"febf:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"fec0::\",\n+              false, false, false, false, false, true,  false, None);\n+        check(\"ff01::\",\n+              false, false, false, false, false, false, false, Some(InterfaceLocal));\n+        check(\"ff02::\",\n+              false, false, false, false, false, false, false, Some(LinkLocal));\n+        check(\"ff03::\",\n+              false, false, false, false, false, false, false, Some(RealmLocal));\n+        check(\"ff04::\",\n+              false, false, false, false, false, false, false, Some(AdminLocal));\n+        check(\"ff05::\",\n+              false, false, false, false, false, false, false, Some(SiteLocal));\n+        check(\"ff08::\",\n+              false, false, false, false, false, false, false, Some(OrganizationLocal));\n+        check(\"ff0e::\",\n+              false, false, false, true,  false, false, false, Some(Global));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_socketaddr() {\n+        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n+        assert_eq!(Ok(vec![a]), tsa(a));\n+    }\n+}"}, {"sha": "d77d6f1d6de1e2d3fdd177cdf02e62710096b7f9", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63e5848cc6acbcb2689563ec64e585717cfd3e82/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e5848cc6acbcb2689563ec64e585717cfd3e82/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=63e5848cc6acbcb2689563ec64e585717cfd3e82", "patch": "@@ -11,7 +11,7 @@\n use prelude::v1::*;\n \n use env;\n-use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr};\n+use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n@@ -27,6 +27,21 @@ pub fn next_test_ip6() -> SocketAddr {\n                                      port, 0, 0))\n }\n \n+pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V4(SocketAddrV4::new(a, p))\n+}\n+\n+pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n+}\n+\n+pub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n+    match a.to_socket_addrs() {\n+        Ok(a) => Ok(a.collect()),\n+        Err(e) => Err(e.to_string()),\n+    }\n+}\n+\n // The bots run multiple builds at the same time, and these builds\n // all want to use ports. This function figures out which workspace\n // it is running in and assigns a port range based on it."}]}