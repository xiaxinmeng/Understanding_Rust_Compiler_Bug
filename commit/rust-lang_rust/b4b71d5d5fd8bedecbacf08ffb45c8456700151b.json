{"sha": "b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YjcxZDVkNWZkOGJlZGVjYmFjZjA4ZmZiNDVjODQ1NjcwMDE1MWI=", "commit": {"author": {"name": "Nicolas Koch", "email": "nioko1337@gmail.com", "date": "2018-05-15T13:26:11Z"}, "committer": {"name": "Nicolas Koch", "email": "nioko1337@gmail.com", "date": "2018-05-15T13:26:11Z"}, "message": "Merge branch 'master' of https://github.com/nicokoch/rust", "tree": {"sha": "2ada477250001a23bc2d5329ca572e15b7bf23d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ada477250001a23bc2d5329ca572e15b7bf23d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "html_url": "https://github.com/rust-lang/rust/commit/b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/comments", "author": {"login": "nicokoch", "id": 3924281, "node_id": "MDQ6VXNlcjM5MjQyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/3924281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicokoch", "html_url": "https://github.com/nicokoch", "followers_url": "https://api.github.com/users/nicokoch/followers", "following_url": "https://api.github.com/users/nicokoch/following{/other_user}", "gists_url": "https://api.github.com/users/nicokoch/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicokoch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicokoch/subscriptions", "organizations_url": "https://api.github.com/users/nicokoch/orgs", "repos_url": "https://api.github.com/users/nicokoch/repos", "events_url": "https://api.github.com/users/nicokoch/events{/privacy}", "received_events_url": "https://api.github.com/users/nicokoch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nicokoch", "id": 3924281, "node_id": "MDQ6VXNlcjM5MjQyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/3924281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicokoch", "html_url": "https://github.com/nicokoch", "followers_url": "https://api.github.com/users/nicokoch/followers", "following_url": "https://api.github.com/users/nicokoch/following{/other_user}", "gists_url": "https://api.github.com/users/nicokoch/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicokoch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicokoch/subscriptions", "organizations_url": "https://api.github.com/users/nicokoch/orgs", "repos_url": "https://api.github.com/users/nicokoch/repos", "events_url": "https://api.github.com/users/nicokoch/events{/privacy}", "received_events_url": "https://api.github.com/users/nicokoch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "834ef9f08ae3429a05dead80237bb4bd04769895", "url": "https://api.github.com/repos/rust-lang/rust/commits/834ef9f08ae3429a05dead80237bb4bd04769895", "html_url": "https://github.com/rust-lang/rust/commit/834ef9f08ae3429a05dead80237bb4bd04769895"}, {"sha": "eca0da59850d4a9eef17c0e6c3795397102d88a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eca0da59850d4a9eef17c0e6c3795397102d88a3", "html_url": "https://github.com/rust-lang/rust/commit/eca0da59850d4a9eef17c0e6c3795397102d88a3"}], "stats": {"total": 809, "additions": 440, "deletions": 369}, "files": [{"sha": "2f52c88955885043e542ade9b7a88ac933cad340", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -288,12 +288,12 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.0.198\"\n+version = \"0.0.200\"\n dependencies = [\n  \"ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy-mini-macro-test 0.2.0\",\n- \"clippy_lints 0.0.198\",\n+ \"clippy_lints 0.0.200\",\n  \"compiletest_rs 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -331,7 +331,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.0.198\"\n+version = \"0.0.200\"\n dependencies = [\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"if_chain 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2178,6 +2178,7 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "5b585d7f041d25877b2bd339cb01e7100f9413c3", "filename": "src/doc/unstable-book/src/language-features/macro-lifetime-matcher.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/834ef9f08ae3429a05dead80237bb4bd04769895/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/834ef9f08ae3429a05dead80237bb4bd04769895/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md?ref=834ef9f08ae3429a05dead80237bb4bd04769895", "patch": "@@ -1,14 +0,0 @@\n-# `macro_lifetime_matcher`\n-\n-The tracking issue for this feature is: [#46895]\n-\n-With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n-\n-* `lifetime`: a lifetime. Examples: 'static, 'a.\n-\n-A `lifetime` variable may be followed by anything.\n-\n-[#46895]: https://github.com/rust-lang/rust/issues/46895\n-[frags]: ../book/first-edition/macros.html#syntactic-requirements\n-\n-------------------------"}, {"sha": "2e9169ce5b942920c16dc5426003888fd98ec8b7", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -122,7 +122,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 5),\n+                              ('PartialOrd', ['PartialEq'], 1),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "4cfd7101eb549169cdaeda5313f7c39415b9d736", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -1 +1 @@\n-Subproject commit 2a2f6d96c8dc578d2474742f14c9bab0b36b0408\n+Subproject commit 4cfd7101eb549169cdaeda5313f7c39415b9d736"}, {"sha": "2a288ae522aac16ddb25c0e0ac41154f93d718f4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -50,7 +50,7 @@\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n #![cfg_attr(windows, feature(libc))]\n-#![feature(macro_lifetime_matcher)]\n+#![cfg_attr(stage0, feature(macro_lifetime_matcher))]\n #![feature(macro_vis_matcher)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]"}, {"sha": "bbfc6d883e9ae7d0d989d98abc0eeaeffa37072c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -888,6 +888,11 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     if x < min { min = x; }\n                     if x > max { max = x; }\n                 }\n+                // We might have no inhabited variants, so pretend there's at least one.\n+                if (min, max) == (i128::max_value(), i128::min_value()) {\n+                    min = 0;\n+                    max = 0;\n+                }\n                 assert!(min <= max, \"discriminant range is {}...{}\", min, max);\n                 let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n "}, {"sha": "7ecf2eba43ddfe64232c90b93035df46e9772b53", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -15,9 +15,8 @@\n #![feature(box_patterns)]\n #![feature(fs_read_write)]\n #![feature(libc)]\n-#![feature(macro_lifetime_matcher)]\n+#![cfg_attr(stage0, feature(macro_lifetime_matcher))]\n #![feature(proc_macro_internals)]\n-#![feature(macro_lifetime_matcher)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]"}, {"sha": "e57a793ff426fbdd458c8ea1e7717a31b2e7ac21", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -12,7 +12,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(custom_attribute)]\n-#![feature(macro_lifetime_matcher)]\n+#![cfg_attr(stage0, feature(macro_lifetime_matcher))]\n #![allow(unused_attributes)]\n \n #[macro_use]"}, {"sha": "64d3a4f4d53be9c0bee5171b0a451d65f5cac42a", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -10,6 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+bitflags = \"1.0.1\"\n cc = \"1.0.1\"\n flate2 = \"1.0\"\n jobserver = \"0.1.5\""}, {"sha": "25c598c532c4897c66d4136c154fa77823ef43bc", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef, AttributePlace};\n use base;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use common::{ty_fn_sig, C_usize};\n use context::CodegenCx;\n use mir::place::PlaceRef;\n@@ -220,7 +220,8 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                                   bx.pointercast(dst.llval, Type::i8p(cx)),\n                                   bx.pointercast(llscratch, Type::i8p(cx)),\n                                   C_usize(cx, self.layout.size.bytes()),\n-                                  self.layout.align.min(scratch_align));\n+                                  self.layout.align.min(scratch_align),\n+                                  MemFlags::empty());\n \n                 bx.lifetime_end(llscratch, scratch_size);\n             }"}, {"sha": "feca36fa6c24355d8f80fee4aa5258ccd294be7a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -53,7 +53,7 @@ use rustc_incremental;\n use allocator;\n use mir::place::PlaceRef;\n use attributes;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n@@ -320,7 +320,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n                     memcpy_ty(bx, dst_f.llval, src_f.llval, src_f.layout,\n-                        src_f.align.min(dst_f.align));\n+                              src_f.align.min(dst_f.align), MemFlags::empty());\n                 } else {\n                     coerce_unsized_into(bx, src_f, dst_f);\n                 }\n@@ -408,7 +408,15 @@ pub fn call_memcpy(bx: &Builder,\n                    dst: ValueRef,\n                    src: ValueRef,\n                    n_bytes: ValueRef,\n-                   align: Align) {\n+                   align: Align,\n+                   flags: MemFlags) {\n+    if flags.contains(MemFlags::NONTEMPORAL) {\n+        // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+        let val = bx.load(src, align);\n+        let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n+        bx.store_with_flags(val, ptr, align, flags);\n+        return;\n+    }\n     let cx = bx.cx;\n     let ptr_width = &cx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n@@ -417,7 +425,7 @@ pub fn call_memcpy(bx: &Builder,\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n     let align = C_i32(cx, align.abi() as i32);\n-    let volatile = C_bool(cx, false);\n+    let volatile = C_bool(cx, flags.contains(MemFlags::VOLATILE));\n     bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n@@ -427,13 +435,14 @@ pub fn memcpy_ty<'a, 'tcx>(\n     src: ValueRef,\n     layout: TyLayout<'tcx>,\n     align: Align,\n+    flags: MemFlags,\n ) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align);\n+    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align, flags);\n }\n \n pub fn call_memset<'a, 'tcx>(bx: &Builder<'a, 'tcx>,"}, {"sha": "4153c61e5269a0af6421794ef958de83968b761f", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -50,6 +50,13 @@ fn noname() -> *const c_char {\n     &CNULL\n }\n \n+bitflags! {\n+    pub struct MemFlags: u8 {\n+        const VOLATILE = 1 << 0;\n+        const NONTEMPORAL = 1 << 1;\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn new_block<'b>(cx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n         let bx = Builder::with_cx(cx);\n@@ -579,29 +586,39 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Align) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n+        self.store_with_flags(val, ptr, align, MemFlags::empty())\n+    }\n+\n+    pub fn store_with_flags(\n+        &self,\n+        val: ValueRef,\n+        ptr: ValueRef,\n+        align: Align,\n+        flags: MemFlags,\n+    ) -> ValueRef {\n+        debug!(\"Store {:?} -> {:?} ({:?})\", Value(val), Value(ptr), flags);\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n             llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n+            if flags.contains(MemFlags::VOLATILE) {\n+                llvm::LLVMSetVolatile(store, llvm::True);\n+            }\n+            if flags.contains(MemFlags::NONTEMPORAL) {\n+                // According to LLVM [1] building a nontemporal store must\n+                // *always* point to a metadata value of the integer 1.\n+                //\n+                // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n+                let one = C_i32(self.cx, 1);\n+                let node = llvm::LLVMMDNodeInContext(self.cx.llcx, &one, 1);\n+                llvm::LLVMSetMetadata(store, llvm::MD_nontemporal as c_uint, node);\n+            }\n             store\n         }\n     }\n \n-    pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n-        assert!(!self.llbuilder.is_null());\n-        self.count_insn(\"store.volatile\");\n-        let ptr = self.check_store(val, ptr);\n-        unsafe {\n-            let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            llvm::LLVMSetVolatile(insn, llvm::True);\n-            insn\n-        }\n-    }\n-\n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef,\n                         order: AtomicOrdering, align: Align) {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n@@ -615,29 +632,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn nontemporal_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n-        assert!(!self.llbuilder.is_null());\n-        self.count_insn(\"store.nontemporal\");\n-        let ptr = self.check_store(val, ptr);\n-        unsafe {\n-            let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-\n-            // According to LLVM [1] building a nontemporal store must *always*\n-            // point to a metadata value of the integer 1. Who knew?\n-            //\n-            // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-            let one = C_i32(self.cx, 1);\n-            let node = llvm::LLVMMDNodeInContext(self.cx.llcx,\n-                                                 &one,\n-                                                 1);\n-            llvm::LLVMSetMetadata(insn,\n-                                  llvm::MD_nontemporal as c_uint,\n-                                  node);\n-            insn\n-        }\n-    }\n-\n     pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"gep\");\n         unsafe {"}, {"sha": "86aa48b6a9e4801085f055240956d31dae7160ad", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -247,26 +247,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             to_immediate(bx, load, cx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n-            let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bx.cx);\n-            if let OperandValue::Pair(a, b) = args[1].val {\n-                bx.volatile_store(a, dst.project_field(bx, 0).llval);\n-                bx.volatile_store(b, dst.project_field(bx, 1).llval);\n-            } else {\n-                let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                    bx.load(ptr, align)\n-                } else {\n-                    if dst.layout.is_zst() {\n-                        return;\n-                    }\n-                    from_immediate(bx, args[1].immediate())\n-                };\n-                let ptr = bx.pointercast(dst.llval, val_ty(val).ptr_to());\n-                let store = bx.volatile_store(val, ptr);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n-                }\n-            }\n+            args[1].val.volatile_store(bx, dst);\n             return;\n         },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n@@ -551,19 +533,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         }\n \n         \"nontemporal_store\" => {\n-            let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bx.cx);\n-            let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                bx.load(ptr, align)\n-            } else {\n-                from_immediate(bx, args[1].immediate())\n-            };\n-            let ptr = bx.pointercast(dst.llval, val_ty(val).ptr_to());\n-            let store = bx.nontemporal_store(val, ptr);\n-            unsafe {\n-                llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n-            }\n-            return\n+            args[1].val.nontemporal_store(bx, dst);\n+            return;\n         }\n \n         _ => {"}, {"sha": "6db95657ce058a95fca93d7d8ecbf6f508f241dc", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -34,6 +34,7 @@\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n+#[macro_use] extern crate bitflags;\n extern crate flate2;\n extern crate libc;\n #[macro_use] extern crate rustc;"}, {"sha": "e4989da36c02673c4bbaec777197eddb2adc671f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::interpret::EvalErrorKind;\n use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n use base;\n use callee;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_uint_big, C_undef};\n use consts;\n use meth;\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     // have scary latent bugs around.\n \n                     let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n-                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align);\n+                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n                 } else {\n                     (llval, align, true)"}, {"sha": "be14da1a195bf07b8c9a333e60061ba66b2d41d4", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n use common::{self, CodegenCx, C_null, C_undef, C_usize};\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -272,18 +272,32 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n impl<'a, 'tcx> OperandValue {\n     pub fn store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::empty());\n+    }\n+\n+    pub fn volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n+    }\n+\n+    pub fn nontemporal_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n+    }\n+\n+    fn store_with_flags(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>, flags: MemFlags) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n         if dest.layout.is_zst() {\n             return;\n         }\n         match self {\n-            OperandValue::Ref(r, source_align) =>\n+            OperandValue::Ref(r, source_align) => {\n                 base::memcpy_ty(bx, dest.llval, r, dest.layout,\n-                                source_align.min(dest.align)),\n+                                source_align.min(dest.align), flags)\n+            }\n             OperandValue::Immediate(s) => {\n-                bx.store(base::from_immediate(bx, s), dest.llval, dest.align);\n+                let val = base::from_immediate(bx, s);\n+                bx.store_with_flags(val, dest.llval, dest.align, flags);\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n@@ -292,7 +306,8 @@ impl<'a, 'tcx> OperandValue {\n                     if common::val_ty(x) == Type::i1(bx.cx) {\n                         llptr = bx.pointercast(llptr, Type::i8p(bx.cx));\n                     }\n-                    bx.store(base::from_immediate(bx, x), llptr, dest.align);\n+                    let val = base::from_immediate(bx, x);\n+                    bx.store_with_flags(val, llptr, dest.align, flags);\n                 }\n             }\n         }"}, {"sha": "35cc70b08384ccabcc3c20679deafae51b73fa3d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -688,7 +688,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     arm_span: arm.body.span,\n                     source: match_src\n                 });\n-                coercion.coerce(self, &cause, &arm.body, arm_ty, self.diverges.get());\n+                coercion.coerce(self, &cause, &arm.body, arm_ty);\n             }\n         }\n "}, {"sha": "324af7b62704dfabd3c9802ea7b353855dd579b5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{Diverges, FnCtxt, Needs};\n+use check::{FnCtxt, Needs};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -800,22 +800,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 exprs: &[E],\n                                 prev_ty: Ty<'tcx>,\n                                 new: &hir::Expr,\n-                                new_ty: Ty<'tcx>,\n-                                new_diverges: Diverges)\n+                                new_ty: Ty<'tcx>)\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n         where E: AsCoercionSite\n     {\n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n-        // Special-ish case: we can coerce any type `T` into the `!`\n-        // type, but only if the source expression diverges.\n-        if prev_ty.is_never() && new_diverges.always() {\n-            debug!(\"permit coercion to `!` because expr diverges\");\n-            return Ok(prev_ty);\n-        }\n-\n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n@@ -1054,14 +1046,12 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                       fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                       cause: &ObligationCause<'tcx>,\n                       expression: &'gcx hir::Expr,\n-                      expression_ty: Ty<'tcx>,\n-                      expression_diverges: Diverges)\n+                      expression_ty: Ty<'tcx>)\n     {\n         self.coerce_inner(fcx,\n                           cause,\n                           Some(expression),\n                           expression_ty,\n-                          expression_diverges,\n                           None, false)\n     }\n \n@@ -1087,7 +1077,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                           cause,\n                           None,\n                           fcx.tcx.mk_nil(),\n-                          Diverges::Maybe,\n                           Some(augment_error),\n                           label_unit_as_expected)\n     }\n@@ -1100,7 +1089,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         cause: &ObligationCause<'tcx>,\n                         expression: Option<&'gcx hir::Expr>,\n                         mut expression_ty: Ty<'tcx>,\n-                        expression_diverges: Diverges,\n                         augment_error: Option<&mut FnMut(&mut DiagnosticBuilder)>,\n                         label_expression_as_expected: bool)\n     {\n@@ -1134,15 +1122,13 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                                                   exprs,\n                                                   self.merged_ty(),\n                                                   expression,\n-                                                  expression_ty,\n-                                                  expression_diverges),\n+                                                  expression_ty),\n                     Expressions::UpFront(ref coercion_sites) =>\n                         fcx.try_find_coercion_lub(cause,\n                                                   &coercion_sites[0..self.pushed],\n                                                   self.merged_ty(),\n                                                   expression,\n-                                                  expression_ty,\n-                                                  expression_diverges),\n+                                                  expression_ty),\n                 }\n             }\n         } else {"}, {"sha": "b4a7de7b8443c11f96be9122d22cdcc292ac75f9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -542,7 +542,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// you get indicates whether any subexpression that was\n     /// evaluating up to and including `X` diverged.\n     ///\n-    /// We use this flag for two purposes:\n+    /// We currently use this flag only for diagnostic purposes:\n     ///\n     /// - To warn about unreachable code: if, after processing a\n     ///   sub-expression but before we have applied the effects of the\n@@ -556,16 +556,8 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`.\n     ///\n-    /// - To permit assignment into a local variable or other place\n-    ///   (including the \"return slot\") of type `!`.  This is allowed\n-    ///   if **either** the type of value being assigned is `!`, which\n-    ///   means the current code is dead, **or** the expression's\n-    ///   diverging flag is true, which means that a diverging value was\n-    ///   wrapped (e.g., `let x: ! = foo(return)`).\n-    ///\n-    /// To repeat the last point: an expression represents dead-code\n-    /// if, after checking it, **either** its type is `!` OR the\n-    /// diverges flag is set to something other than `Maybe`.\n+    /// An expression represents dead-code if, after checking it,\n+    /// the diverges flag is set to something other than `Maybe`.\n     diverges: Cell<Diverges>,\n \n     /// Whether any child nodes have any type errors.\n@@ -3002,8 +2994,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             &self.cause(return_expr.span,\n                                         ObligationCauseCode::ReturnType(return_expr.id)),\n                             return_expr,\n-                            return_expr_ty,\n-                            self.diverges.get());\n+                            return_expr_ty);\n     }\n \n \n@@ -3034,13 +3025,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n \n         let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n-        coerce.coerce(self, &if_cause, then_expr, then_ty, then_diverges);\n+        coerce.coerce(self, &if_cause, then_expr, then_ty);\n \n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n-            coerce.coerce(self, &if_cause, else_expr, else_ty, else_diverges);\n+            coerce.coerce(self, &if_cause, else_expr, else_ty);\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n@@ -3081,12 +3072,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(index) = fields.iter().position(|f| f.name.to_ident() == ident) {\n                         let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n+                        // Save the index of all fields regardless of their visibility in case\n+                        // of error recovery.\n+                        self.write_field_index(expr.id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             let adjustments = autoderef.adjust_steps(needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n-                            self.write_field_index(expr.id, index);\n                             self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n                             return field_ty;\n                         }\n@@ -3731,7 +3724,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprBreak(destination, ref expr_opt) => {\n               if let Some(target_id) = destination.target_id.opt_id() {\n-                  let (e_ty, e_diverges, cause);\n+                  let (e_ty, cause);\n                   if let Some(ref e) = *expr_opt {\n                       // If this is a break with a value, we need to type-check\n                       // the expression. Get an expected type from the loop context.\n@@ -3750,13 +3743,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                       // Recurse without `enclosing_breakables` borrowed.\n                       e_ty = self.check_expr_with_hint(e, coerce_to);\n-                      e_diverges = self.diverges.get();\n                       cause = self.misc(e.span);\n                   } else {\n                       // Otherwise, this is a break *without* a value. That's\n                       // always legal, and is equivalent to `break ()`.\n                       e_ty = tcx.mk_nil();\n-                      e_diverges = Diverges::Maybe;\n                       cause = self.misc(expr.span);\n                   }\n \n@@ -3767,7 +3758,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let ctxt = enclosing_breakables.find_breakable(target_id);\n                   if let Some(ref mut coerce) = ctxt.coerce {\n                       if let Some(ref e) = *expr_opt {\n-                          coerce.coerce(self, &cause, e, e_ty, e_diverges);\n+                          coerce.coerce(self, &cause, e, e_ty);\n                       } else {\n                           assert!(e_ty.is_nil());\n                           coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n@@ -3973,7 +3964,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   for e in args {\n                       let e_ty = self.check_expr_with_hint(e, coerce_to);\n                       let cause = self.misc(e.span);\n-                      coerce.coerce(self, &cause, e, e_ty, self.diverges.get());\n+                      coerce.coerce(self, &cause, e, e_ty);\n                   }\n                   coerce.complete(self)\n               } else {\n@@ -4384,8 +4375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 coerce.coerce(self,\n                               &cause,\n                               tail_expr,\n-                              tail_expr_ty,\n-                              self.diverges.get());\n+                              tail_expr_ty);\n             } else {\n                 // Subtle: if there is no explicit tail expression,\n                 // that is typically equivalent to a tail expression"}, {"sha": "32cfb05bbe49bb752414fdca7ac8336e451597b9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -413,9 +413,9 @@ impl ToJson for Type {\n         match self.name {\n             Some(ref name) => {\n                 let mut data = BTreeMap::new();\n-                data.insert(\"name\".to_owned(), name.to_json());\n+                data.insert(\"n\".to_owned(), name.to_json());\n                 if let Some(ref generics) = self.generics {\n-                    data.insert(\"generics\".to_owned(), generics.to_json());\n+                    data.insert(\"g\".to_owned(), generics.to_json());\n                 }\n                 Json::Object(data)\n             },\n@@ -438,8 +438,12 @@ impl ToJson for IndexItemFunctionType {\n             Json::Null\n         } else {\n             let mut data = BTreeMap::new();\n-            data.insert(\"inputs\".to_owned(), self.inputs.to_json());\n-            data.insert(\"output\".to_owned(), self.output.to_json());\n+            if !self.inputs.is_empty() {\n+                data.insert(\"i\".to_owned(), self.inputs.to_json());\n+            }\n+            if let Some(ref output) = self.output {\n+                data.insert(\"o\".to_owned(), output.to_json());\n+            }\n             Json::Object(data)\n         }\n     }\n@@ -789,7 +793,8 @@ fn write_shared(cx: &Context,\n           format!(\n r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n-themePicker.onclick = function() {{\n+\n+function switchThemeButtonState() {{\n     if (themes.style.display === \"block\") {{\n         themes.style.display = \"none\";\n         themePicker.style.borderBottomRightRadius = \"3px\";\n@@ -800,12 +805,29 @@ themePicker.onclick = function() {{\n         themePicker.style.borderBottomLeftRadius = \"0\";\n     }}\n }};\n+\n+function handleThemeButtonsBlur(e) {{\n+    var active = document.activeElement;\n+    var related = e.relatedTarget;\n+\n+    if (active.id !== \"themePicker\" &&\n+        (!active.parentNode || active.parentNode.id !== \"theme-choices\") &&\n+        (!related ||\n+         (related.id !== \"themePicker\" &&\n+          (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n+        switchThemeButtonState();\n+    }}\n+}}\n+\n+themePicker.onclick = switchThemeButtonState;\n+themePicker.onblur = handleThemeButtonsBlur;\n [{}].forEach(function(item) {{\n     var but = document.createElement('button');\n     but.innerHTML = item;\n     but.onclick = function(el) {{\n         switchTheme(currentTheme, mainTheme, item);\n     }};\n+    but.onblur = handleThemeButtonsBlur;\n     themes.appendChild(but);\n }});\"#,\n                  themes.iter()\n@@ -879,8 +901,8 @@ themePicker.onclick = function() {{\n     }\n \n     fn show_item(item: &IndexItem, krate: &str) -> String {\n-        format!(\"{{'crate':'{}','ty':{},'name':'{}','path':'{}'{}}}\",\n-                krate, item.ty as usize, item.name, item.path,\n+        format!(\"{{'crate':'{}','ty':{},'name':'{}','desc':'{}','p':'{}'{}}}\",\n+                krate, item.ty as usize, item.name, item.desc.replace(\"'\", \"\\\\'\"), item.path,\n                 if let Some(p) = item.parent_idx {\n                     format!(\",'parent':{}\", p)\n                 } else {\n@@ -1442,7 +1464,7 @@ impl<'a> Cache {\n                                 ty: item.type_(),\n                                 name: item_name.to_string(),\n                                 path: path.clone(),\n-                                desc: String::new(),\n+                                desc: plain_summary_line(item.doc_value()),\n                                 parent: None,\n                                 parent_idx: None,\n                                 search_type: get_index_search_type(&item),"}, {"sha": "9224bd1c5089037fb3788a6b123088a5c2f007d5", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 92, "deletions": 64, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -57,6 +57,12 @@\n             return this.indexOf(searchString, position) === position;\n         };\n     }\n+    if (!String.prototype.endsWith) {\n+        String.prototype.endsWith = function(suffix, length) {\n+            var l = length || this.length;\n+            return this.indexOf(suffix, l - suffix.length) !== -1;\n+        };\n+    }\n \n     function getPageId() {\n         var id = document.location.href.split('#')[1];\n@@ -454,12 +460,16 @@\n                         var obj = searchIndex[results[i].id];\n                         obj.lev = results[i].lev;\n                         if (isType !== true || obj.type) {\n+                            var res = buildHrefAndPath(obj);\n+                            obj.displayPath = pathSplitter(res[0]);\n+                            obj.fullPath = obj.displayPath + obj.name;\n+                            obj.href = res[1];\n                             out.push(obj);\n+                            if (out.length >= MAX_RESULTS) {\n+                                break;\n+                            }\n                         }\n                     }\n-                    if (out.length >= MAX_RESULTS) {\n-                        break;\n-                    }\n                 }\n                 return out;\n             }\n@@ -587,8 +597,8 @@\n                 // match as well.\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n                 if (val.generics.length > 0) {\n-                    if (obj.generics && obj.generics.length >= val.generics.length) {\n-                        var elems = obj.generics.slice(0);\n+                    if (obj.g && obj.g.length >= val.generics.length) {\n+                        var elems = obj.g.slice(0);\n                         var total = 0;\n                         var done = 0;\n                         // We need to find the type that matches the most to remove it in order\n@@ -620,11 +630,11 @@\n             // Check for type name and type generics (if any).\n             function checkType(obj, val, literalSearch) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n-                if (obj.name === val.name) {\n+                if (obj.n === val.name) {\n                     if (literalSearch === true) {\n                         if (val.generics && val.generics.length !== 0) {\n-                            if (obj.generics && obj.length >= val.generics.length) {\n-                                var elems = obj.generics.slice(0);\n+                            if (obj.g && obj.length >= val.generics.length) {\n+                                var elems = obj.g.slice(0);\n                                 var allFound = true;\n                                 var x;\n \n@@ -648,7 +658,7 @@\n                     }\n                     // If the type has generics but don't match, then it won't return at this point.\n                     // Otherwise, `checkGenerics` will return 0 and it'll return.\n-                    if (obj.generics && obj.generics.length !== 0) {\n+                    if (obj.g && obj.g.length !== 0) {\n                         var tmp_lev = checkGenerics(obj, val);\n                         if (tmp_lev <= MAX_LEV_DISTANCE) {\n                             return tmp_lev;\n@@ -659,22 +669,22 @@\n                 }\n                 // Names didn't match so let's check if one of the generic types could.\n                 if (literalSearch === true) {\n-                     if (obj.generics && obj.generics.length > 0) {\n-                        for (var x = 0; x < obj.generics.length; ++x) {\n-                            if (obj.generics[x] === val.name) {\n+                     if (obj.g && obj.g.length > 0) {\n+                        for (var x = 0; x < obj.g.length; ++x) {\n+                            if (obj.g[x] === val.name) {\n                                 return true;\n                             }\n                         }\n                     }\n                     return false;\n                 }\n-                var lev_distance = Math.min(levenshtein(obj.name, val.name), lev_distance);\n+                var lev_distance = Math.min(levenshtein(obj.n, val.name), lev_distance);\n                 if (lev_distance <= MAX_LEV_DISTANCE) {\n                     lev_distance = Math.min(checkGenerics(obj, val), lev_distance);\n-                } else if (obj.generics && obj.generics.length > 0) {\n+                } else if (obj.g && obj.g.length > 0) {\n                     // We can check if the type we're looking for is inside the generics!\n-                    for (var x = 0; x < obj.generics.length; ++x) {\n-                        lev_distance = Math.min(levenshtein(obj.generics[x], val.name),\n+                    for (var x = 0; x < obj.g.length; ++x) {\n+                        lev_distance = Math.min(levenshtein(obj.g[x], val.name),\n                                                 lev_distance);\n                     }\n                 }\n@@ -686,9 +696,9 @@\n             function findArg(obj, val, literalSearch) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n-                if (obj && obj.type && obj.type.inputs.length > 0) {\n-                    for (var i = 0; i < obj.type.inputs.length; i++) {\n-                        var tmp = checkType(obj.type.inputs[i], val, literalSearch);\n+                if (obj && obj.type && obj.type.i && obj.type.i.length > 0) {\n+                    for (var i = 0; i < obj.type.i.length; i++) {\n+                        var tmp = checkType(obj.type.i[i], val, literalSearch);\n                         if (literalSearch === true && tmp === true) {\n                             return true;\n                         }\n@@ -704,8 +714,8 @@\n             function checkReturned(obj, val, literalSearch) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n-                if (obj && obj.type && obj.type.output) {\n-                    var tmp = checkType(obj.type.output, val, literalSearch);\n+                if (obj && obj.type && obj.type.o) {\n+                    var tmp = checkType(obj.type.o, val, literalSearch);\n                     if (literalSearch === true && tmp === true) {\n                         return true;\n                     }\n@@ -850,7 +860,7 @@\n                     var fullId = generateId(ty);\n \n                     // allow searching for void (no output) functions as well\n-                    var typeOutput = type.output ? type.output.name : \"\";\n+                    var typeOutput = type.o ? type.o.name : \"\";\n                     var returned = checkReturned(ty, output, true);\n                     if (output.name === \"*\" || returned === true) {\n                         var in_args = false;\n@@ -1017,6 +1027,13 @@\n                     ALIASES[window.currentCrate][query.raw]) {\n                 var aliases = ALIASES[window.currentCrate][query.raw];\n                 for (var i = 0; i < aliases.length; ++i) {\n+                    aliases[i].is_alias = true;\n+                    aliases[i].alias = query.raw;\n+                    aliases[i].path = aliases[i].p;\n+                    var res = buildHrefAndPath(aliases[i]);\n+                    aliases[i].displayPath = pathSplitter(res[0]);\n+                    aliases[i].fullPath = aliases[i].displayPath + aliases[i].name;\n+                    aliases[i].href = res[1];\n                     ret['others'].unshift(aliases[i]);\n                     if (ret['others'].length > MAX_RESULTS) {\n                         ret['others'].pop();\n@@ -1179,16 +1196,6 @@\n             };\n         }\n \n-        function escape(content) {\n-            var h1 = document.createElement('h1');\n-            h1.textContent = content;\n-            return h1.innerHTML;\n-        }\n-\n-        function pathSplitter(path) {\n-            return '<span>' + path.replace(/::/g, '::</span><span>');\n-        }\n-\n         function buildHrefAndPath(item) {\n             var displayPath;\n             var href;\n@@ -1227,38 +1234,54 @@\n             return [displayPath, href];\n         }\n \n+        function escape(content) {\n+            var h1 = document.createElement('h1');\n+            h1.textContent = content;\n+            return h1.innerHTML;\n+        }\n+\n+        function pathSplitter(path) {\n+            var tmp = '<span>' + path.replace(/::/g, '::</span><span>');\n+            if (tmp.endsWith(\"<span>\")) {\n+                return tmp.slice(0, tmp.length - 6);\n+            }\n+            return tmp;\n+        }\n+\n         function addTab(array, query, display) {\n             var extraStyle = '';\n             if (display === false) {\n                 extraStyle = ' style=\"display: none;\"';\n             }\n \n             var output = '';\n+            var duplicates = {};\n+            var length = 0;\n             if (array.length > 0) {\n                 output = '<table class=\"search-results\"' + extraStyle + '>';\n-                var shown = [];\n \n                 array.forEach(function(item) {\n-                    var name, type, href, displayPath;\n-\n-                    var id_ty = item.ty + item.path + item.name;\n-                    if (shown.indexOf(id_ty) !== -1) {\n-                        return;\n-                    }\n+                    var name, type;\n \n-                    shown.push(id_ty);\n                     name = item.name;\n                     type = itemTypes[item.ty];\n \n-                    var res = buildHrefAndPath(item);\n-                    var href = res[1];\n-                    var displayPath = res[0];\n+                    if (item.is_alias !== true) {\n+                        if (duplicates[item.fullPath]) {\n+                            return;\n+                        }\n+                        duplicates[item.fullPath] = true;\n+                    }\n+                    length += 1;\n \n                     output += '<tr class=\"' + type + ' result\"><td>' +\n-                              '<a href=\"' + href + '\">' +\n-                              pathSplitter(displayPath) + '<span class=\"' + type + '\">' +\n+                              '<a href=\"' + item.href + '\">' +\n+                              (item.is_alias === true ?\n+                               ('<span class=\"alias\"><b>' + item.alias + ' </b></span><span ' +\n+                                  'class=\"grey\"><i>&nbsp;- see&nbsp;</i></span>') : '') +\n+                              item.displayPath + '<span class=\"' + type + '\">' +\n                               name + '</span></a></td><td>' +\n-                              '<a href=\"' + href + '\">' +\n+                              '<a href=\"' + item.href + '\">' +\n                               '<span class=\"desc\">' + escape(item.desc) +\n                               '&nbsp;</span></a></td></tr>';\n                 });\n@@ -1269,7 +1292,7 @@\n                     encodeURIComponent('rust ' + query.query) +\n                     '\">DuckDuckGo</a>?</div>';\n             }\n-            return output;\n+            return [output, length];\n         }\n \n         function makeTabHeader(tabNb, text, nbElems) {\n@@ -1284,28 +1307,28 @@\n             if (results['others'].length === 1 &&\n                 getCurrentValue('rustdoc-go-to-only-result') === \"true\") {\n                 var elem = document.createElement('a');\n-                var res = buildHrefAndPath(results['others'][0]);\n-                elem.href = res[1];\n+                elem.href = results['others'][0].href;\n                 elem.style.display = 'none';\n                 // For firefox, we need the element to be in the DOM so it can be clicked.\n                 document.body.appendChild(elem);\n                 elem.click();\n             }\n-            var output, query = getQuery(search_input.value);\n+            var query = getQuery(search_input.value);\n \n             currentResults = query.id;\n-            output = '<h1>Results for ' + escape(query.query) +\n+\n+            var ret_others = addTab(results['others'], query);\n+            var ret_in_args = addTab(results['in_args'], query, false);\n+            var ret_returned = addTab(results['returned'], query, false);\n+\n+            var output = '<h1>Results for ' + escape(query.query) +\n                 (query.type ? ' (type: ' + escape(query.type) + ')' : '') + '</h1>' +\n                 '<div id=\"titles\">' +\n-                makeTabHeader(0, \"In Names\", results['others'].length) +\n-                makeTabHeader(1, \"In Parameters\", results['in_args'].length) +\n-                makeTabHeader(2, \"In Return Types\", results['returned'].length) +\n-                '</div><div id=\"results\">';\n-\n-            output += addTab(results['others'], query);\n-            output += addTab(results['in_args'], query, false);\n-            output += addTab(results['returned'], query, false);\n-            output += '</div>';\n+                makeTabHeader(0, \"In Names\", ret_others[1]) +\n+                makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n+                makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n+                '</div><div id=\"results\">' +\n+                ret_others[0] + ret_in_args[0] + ret_returned[0] + '</div>';\n \n             addClass(document.getElementById('main'), 'hidden');\n             var search = document.getElementById('search');\n@@ -1347,12 +1370,13 @@\n                 }\n             }\n             if (queries.length > 1) {\n-                function getSmallest(arrays, positions) {\n+                function getSmallest(arrays, positions, notDuplicates) {\n                     var start = null;\n \n                     for (var it = 0; it < positions.length; ++it) {\n                         if (arrays[it].length > positions[it] &&\n-                            (start === null || start > arrays[it][positions[it]].lev)) {\n+                            (start === null || start > arrays[it][positions[it]].lev) &&\n+                            !notDuplicates[arrays[it][positions[it]].fullPath]) {\n                             start = arrays[it][positions[it]].lev;\n                         }\n                     }\n@@ -1362,19 +1386,23 @@\n                 function mergeArrays(arrays) {\n                     var ret = [];\n                     var positions = [];\n+                    var notDuplicates = {};\n \n                     for (var x = 0; x < arrays.length; ++x) {\n                         positions.push(0);\n                     }\n                     while (ret.length < MAX_RESULTS) {\n-                        var smallest = getSmallest(arrays, positions);\n+                        var smallest = getSmallest(arrays, positions, notDuplicates);\n+\n                         if (smallest === null) {\n                             break;\n                         }\n                         for (x = 0; x < arrays.length && ret.length < MAX_RESULTS; ++x) {\n                             if (arrays[x].length > positions[x] &&\n-                                    arrays[x][positions[x]].lev === smallest) {\n+                                    arrays[x][positions[x]].lev === smallest &&\n+                                    !notDuplicates[arrays[x][positions[x]].fullPath]) {\n                                 ret.push(arrays[x][positions[x]]);\n+                                notDuplicates[arrays[x][positions[x]].fullPath] = true;\n                                 positions[x] += 1;\n                             }\n                         }"}, {"sha": "493a75e25211df925b16ddbd700a3aadc3ff5e42", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -382,7 +382,7 @@ kbd {\n }\n \n #theme-choices > button:hover, #theme-choices > button:focus {\n-\tbackground-color: #444;\n+\tbackground-color: #4e4e4e;\n }\n \n @media (max-width: 700px) {\n@@ -397,3 +397,10 @@ kbd {\n #all-types:hover {\n \tbackground-color: #606060;\n }\n+\n+.search-results td span.alias {\n+\tcolor: #fff;\n+}\n+.search-results td span.grey {\n+\tcolor: #ccc;\n+}\n\\ No newline at end of file"}, {"sha": "22f4635fb02e13ac5f23554f505503a08e46728a", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -390,4 +390,11 @@ kbd {\n }\n #all-types:hover {\n \tbackground-color: #f9f9f9;\n+}\n+\n+.search-results td span.alias {\n+\tcolor: #000;\n+}\n+.search-results td span.grey {\n+\tcolor: #999;\n }\n\\ No newline at end of file"}, {"sha": "e96a0e838cfcd50a46429727a3b3180294d1e039", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -904,20 +904,8 @@ fn is_legal_fragment_specifier(sess: &ParseSess,\n                                frag_name: &str,\n                                frag_span: Span) -> bool {\n     match frag_name {\n-        \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n+        \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" | \"lifetime\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n-        \"lifetime\" => {\n-            if !features.macro_lifetime_matcher &&\n-               !attr::contains_name(attrs, \"allow_internal_unstable\") {\n-                let explain = feature_gate::EXPLAIN_LIFETIME_MATCHER;\n-                emit_feature_err(sess,\n-                                 \"macro_lifetime_matcher\",\n-                                 frag_span,\n-                                 GateIssue::Language,\n-                                 explain);\n-            }\n-            true\n-        },\n         \"literal\" => {\n             if !features.macro_literal_matcher &&\n                !attr::contains_name(attrs, \"allow_internal_unstable\") {"}, {"sha": "cb5125fe9ef5a25f9209cf09058e094f0f7d8d91", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -396,9 +396,6 @@ declare_features! (\n     // Termination trait in tests (RFC 1937)\n     (active, termination_trait_test, \"1.24.0\", Some(48854), Some(Edition::Edition2018)),\n \n-    // Allows use of the :lifetime macro fragment specifier\n-    (active, macro_lifetime_matcher, \"1.24.0\", Some(46895), None),\n-\n     // `extern` in paths\n     (active, extern_in_paths, \"1.23.0\", Some(44660), None),\n \n@@ -598,6 +595,8 @@ declare_features! (\n     (accepted, dyn_trait, \"1.27.0\", Some(44662), None),\n     // allow `#[must_use]` on functions; and, must-use operators (RFC 1940)\n     (accepted, fn_must_use, \"1.27.0\", Some(43302), None),\n+    // Allows use of the :lifetime macro fragment specifier\n+    (accepted, macro_lifetime_matcher, \"1.27.0\", Some(34303), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -1331,9 +1330,6 @@ pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n pub const EXPLAIN_VIS_MATCHER: &'static str =\n     \":vis fragment specifier is experimental and subject to change\";\n \n-pub const EXPLAIN_LIFETIME_MATCHER: &'static str =\n-    \":lifetime fragment specifier is experimental and subject to change\";\n-\n pub const EXPLAIN_LITERAL_MATCHER: &'static str =\n     \":literal fragment specifier is experimental and subject to change\";\n "}, {"sha": "2b3930063f369028e9c23122ff398e1885d61c0a", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 101, "deletions": 66, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -147,34 +147,37 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n             // as the outermost one, and the last as the innermost.\n             false,\n             |cx, span, old, self_f, other_fs| {\n-        // match new {\n-        //     Some(::std::cmp::Ordering::Equal) => old,\n-        //     cmp => cmp\n-        // }\n+                // match new {\n+                //     Some(::std::cmp::Ordering::Equal) => old,\n+                //     cmp => cmp\n+                // }\n \n-        let new = {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-            };\n+                let new = {\n+                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                        (1, Some(o_f)) => o_f,\n+                                _ => {\n+                                    cx.span_bug(span,\n+                                        \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                                }\n+                    };\n \n-            let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n+                    let args = vec![\n+                            cx.expr_addr_of(span, self_f),\n+                            cx.expr_addr_of(span, other_f.clone()),\n+                        ];\n \n-            cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-        };\n+                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                };\n \n-        let eq_arm = cx.arm(span,\n-                            vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n-                            old);\n-        let neq_arm = cx.arm(span,\n-                             vec![cx.pat_ident(span, test_id)],\n-                             cx.expr_ident(span, test_id));\n+                let eq_arm = cx.arm(span,\n+                                    vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n+                                    old);\n+                let neq_arm = cx.arm(span,\n+                                    vec![cx.pat_ident(span, test_id)],\n+                                    cx.expr_ident(span, test_id));\n \n-        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-    },\n+                cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+            },\n             equals_expr.clone(),\n             Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n         if self_args.len() != 2 {\n@@ -189,78 +192,99 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let strict_op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n-    cs_fold1(false, // need foldr,\n+fn cs_op(less: bool,\n+         inclusive: bool,\n+         cx: &mut ExtCtxt,\n+         span: Span,\n+         substr: &Substructure) -> P<Expr> {\n+    let ordering_path = |cx: &mut ExtCtxt, name: &str| {\n+        cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", name])))\n+    };\n+\n+    let par_cmp = |cx: &mut ExtCtxt, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n+        let other_f = match (other_fs.len(), other_fs.get(0)) {\n+            (1, Some(o_f)) => o_f,\n+            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+        };\n+\n+        // `PartialOrd::partial_cmp(self.fi, other.fi)`\n+        let cmp_path = cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\",\n+                                                                       \"PartialOrd\",\n+                                                                       \"partial_cmp\"])));\n+        let cmp = cx.expr_call(span,\n+                               cmp_path,\n+                               vec![cx.expr_addr_of(span, self_f),\n+                                    cx.expr_addr_of(span, other_f.clone())]);\n+\n+        let default = ordering_path(cx, default);\n+        // `Option::unwrap_or(_, Ordering::Equal)`\n+        let unwrap_path = cx.expr_path(cx.path_global(span, cx.std_path(&[\"option\",\n+                                                                          \"Option\",\n+                                                                          \"unwrap_or\"])));\n+        cx.expr_call(span, unwrap_path, vec![cmp, default])\n+    };\n+\n+    let fold = cs_fold1(false, // need foldr\n         |cx, span, subexpr, self_f, other_fs| {\n-            // build up a series of chain ||'s and &&'s from the inside\n+            // build up a series of `partial_cmp`s from the inside\n             // out (hence foldr) to get lexical ordering, i.e. for op ==\n             // `ast::lt`\n             //\n             // ```\n-            // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-            // self.f2 < other.f2\n+            // Ordering::then_with(\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n+            //    ),\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n+            //    )\n             // )\n+            // == Ordering::Less\n             // ```\n             //\n             // and for op ==\n             // `ast::le`\n             //\n             // ```\n-            // self.f1 < other.f1 || (self.f1 == other.f1 &&\n-            // self.f2 <= other.f2\n+            // Ordering::then_with(\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n+            //    ),\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n+            //    )\n             // )\n+            // != Ordering::Greater\n             // ```\n             //\n             // The optimiser should remove the redundancy. We explicitly\n             // get use the binops to avoid auto-deref dereferencing too many\n             // layers of pointers, if the type includes pointers.\n-            //\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-            };\n \n-            let strict_ineq = cx.expr_binary(span, strict_op, self_f.clone(), other_f.clone());\n+            // `Option::unwrap_or(PartialOrd::partial_cmp(self.fi, other.fi), Ordering::Equal)`\n+            let par_cmp = par_cmp(cx, span, self_f, other_fs, \"Equal\");\n \n-            let deleg_cmp = if !equal {\n-                cx.expr_unary(span,\n-                            ast::UnOp::Not,\n-                            cx.expr_binary(span, strict_op, other_f.clone(), self_f))\n-            } else {\n-                cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone())\n-            };\n-\n-            let and = cx.expr_binary(span, BinOpKind::And, deleg_cmp, subexpr);\n-            cx.expr_binary(span, BinOpKind::Or, strict_ineq, and)\n+            // `Ordering::then_with(Option::unwrap_or(..), ..)`\n+            let then_with_path = cx.expr_path(cx.path_global(span,\n+                                                             cx.std_path(&[\"cmp\",\n+                                                                           \"Ordering\",\n+                                                                           \"then_with\"])));\n+            cx.expr_call(span, then_with_path, vec![par_cmp, cx.lambda0(span, subexpr)])\n         },\n         |cx, args| {\n             match args {\n                 Some((span, self_f, other_fs)) => {\n-                    // Special-case the base case to generate cleaner code with\n-                    // fewer operations (e.g. `<=` instead of `<` and `==`).\n-                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                        (1, Some(o_f)) => o_f,\n-                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-                    };\n-\n-                    let op = match (less, equal) {\n-                        (false, false) => BinOpKind::Gt,\n-                        (false, true) => BinOpKind::Ge,\n-                        (true, false) => BinOpKind::Lt,\n-                        (true, true) => BinOpKind::Le,\n-                    };\n-\n-                    cx.expr_binary(span, op, self_f, other_f.clone())\n-                }\n-                None => cx.expr_bool(span, equal)\n+                    let opposite = if less { \"Greater\" } else { \"Less\" };\n+                    par_cmp(cx, span, self_f, other_fs, opposite)\n+                },\n+                None => cx.expr_bool(span, inclusive)\n             }\n         },\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             } else {\n-                let op = match (less, equal) {\n+                let op = match (less, inclusive) {\n                     (false, false) => GtOp,\n                     (false, true) => GeOp,\n                     (true, false) => LtOp,\n@@ -271,5 +295,16 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substru\n         }),\n         cx,\n         span,\n-        substr)\n+        substr);\n+\n+    match *substr.fields {\n+        EnumMatching(.., ref all_fields) |\n+        Struct(.., ref all_fields) if !all_fields.is_empty() => {\n+            let ordering = ordering_path(cx, if less ^ inclusive { \"Less\" } else { \"Greater\" });\n+            let comp_op = if inclusive { BinOpKind::Ne } else { BinOpKind::Eq };\n+\n+            cx.expr_binary(span, comp_op, fold, ordering)\n+        }\n+        _ => fold\n+    }\n }"}, {"sha": "a19ca1cd91cf97777af8268a6136bd2e4648e189", "filename": "src/stdsimd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdsimd?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -1 +1 @@\n-Subproject commit 2f86c75a2479cf051b92fc98273daaf7f151e7a1\n+Subproject commit a19ca1cd91cf97777af8268a6136bd2e4648e189"}, {"sha": "7d36517d9704b03b67aca67c1b173edfdc1b00d6", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/issue_50493.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_50493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_50493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_50493.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro, proc_macro_lib)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Derive)]\n+pub fn derive(_: TokenStream) -> TokenStream {\n+    let code = \"\n+        fn one(r: Restricted) {\n+            r.field;\n+        }\n+        fn two(r: Restricted) {\n+            r.field;\n+        }\n+    \";\n+\n+    code.parse().unwrap()\n+}"}, {"sha": "51112f202c8970fee02c728b89247125456983a4", "filename": "src/test/compile-fail-fulldeps/proc-macro/issue-50493.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-50493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-50493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-50493.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_50493.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate issue_50493;\n+\n+#[derive(Derive)] //~ ERROR field `field` of struct `Restricted` is private\n+struct Restricted {\n+    pub(in restricted) field: usize, //~ visibilities can only be restricted to ancestor modules\n+}\n+\n+mod restricted {}\n+\n+fn main() {}\n+"}, {"sha": "8b4e2c3c051e85c618c92d7c6b6a96b59717bd47", "filename": "src/test/compile-fail/coerce-to-bang.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -56,9 +56,8 @@ fn call_foo_f() {\n }\n \n fn array_a() {\n-    // Accepted: return is coerced to `!` just fine, and then `22` can be\n-    // because we already diverged.\n-    let x: [!; 2] = [return, 22];\n+    // Return is coerced to `!` just fine, but `22` cannot be.\n+    let x: [!; 2] = [return, 22]; //~ ERROR mismatched types\n }\n \n fn array_b() {"}, {"sha": "a5df717e06ba91401e86ed83f43d9ac2d04fc3f4", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum-struct-variant.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -17,10 +17,6 @@ struct Error;\n enum Enum {\n    A {\n      x: Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n    }\n }\n "}, {"sha": "3411d2f3119ec4af87418e9297bbd015bde6b29c", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -17,10 +17,6 @@ struct Error;\n enum Enum {\n    A(\n      Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n      )\n }\n "}, {"sha": "1feadc2fd83b5c2b4ef0472b413449dcc389f8d4", "filename": "src/test/compile-fail/derives-span-PartialOrd-struct.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -16,10 +16,6 @@ struct Error;\n #[derive(PartialOrd,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n }\n \n fn main() {}"}, {"sha": "9db0fed2d9e9d543dd4688ae5516e55afd55bf35", "filename": "src/test/compile-fail/derives-span-PartialOrd-tuple-struct.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -16,10 +16,6 @@ struct Error;\n #[derive(PartialOrd,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n );\n \n fn main() {}"}, {"sha": "32f9b83b6e2c77f556439d8e5cbf4851f1ecca11", "filename": "src/test/compile-fail/range_traits-1.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -15,35 +15,21 @@ struct AllTheRanges {\n     a: Range<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     b: RangeTo<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     c: RangeFrom<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     d: RangeFull,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     e: RangeInclusive<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     f: RangeToInclusive<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n-    //~^^^^^ ERROR binary operation `<=` cannot be applied to type\n-    //~^^^^^^ ERROR binary operation `>=` cannot be applied to type\n }\n \n fn main() {}"}, {"sha": "06df2b989af28c636d70190cd5eb97f36d6a6208", "filename": "src/test/run-pass/issue-50731.rs", "status": "renamed", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fissue-50731.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fissue-50731.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-50731.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that the :lifetime macro fragment cannot be used when macro_lifetime_matcher\n-// feature gate is not used.\n-\n-macro_rules! m { ($lt:lifetime) => {} }\n-//~^ ERROR :lifetime fragment specifier is experimental and subject to change\n-\n+enum Void {}\n+fn foo(_: Result<(Void, u32), (Void, String)>) {}\n fn main() {\n-    m!('a);\n+    let _: fn(_) = foo;\n }", "previous_filename": "src/test/ui/feature-gate-macro-lifetime-matcher.rs"}, {"sha": "b9e1fde6b1f3e10efb0ea203e6ad4ee7d52ca39d", "filename": "src/test/run-pass/macro-lifetime-used-with-bound.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-bound.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_lifetime_matcher)]\n-\n macro_rules! foo {\n     ($l:lifetime, $l2:lifetime) => {\n         fn f<$l: $l2, $l2>(arg: &$l str, arg2: &$l2 str) -> &$l str {"}, {"sha": "d003d7dcfb6206ba75ba87e51cfc12edac19a2ce", "filename": "src/test/run-pass/macro-lifetime-used-with-labels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-labels.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![allow(unreachable_code)]\n-#![feature(macro_lifetime_matcher)]\n \n macro_rules! x {\n     ($a:lifetime) => {"}, {"sha": "5c1f8683e00f600a6c165f660265a8f4931c57fe", "filename": "src/test/run-pass/macro-lifetime-used-with-static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-lifetime-used-with-static.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_lifetime_matcher)]\n-\n macro_rules! foo {\n     ($l:lifetime) => {\n         fn f(arg: &$l str) -> &$l str {"}, {"sha": "ff5798ff78d62837e9c475c21296a7577786775c", "filename": "src/test/run-pass/macro-lifetime.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frun-pass%2Fmacro-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-lifetime.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_lifetime_matcher)]\n-\n macro_rules! foo {\n     ($l:lifetime) => {\n         fn f<$l>(arg: &$l str) -> &$l str {"}, {"sha": "0f29607d5c993ba74f278aa04d3d2b111a3b3388", "filename": "src/test/rustdoc-js/deduplication.js", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frustdoc-js%2Fdeduplication.js", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Frustdoc-js%2Fdeduplication.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdeduplication.js?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-order\n+\n+const QUERY = 'is_nan';\n+\n+const EXPECTED = {\n+    'others': [\n+        { 'path': 'std::f32', 'name': 'is_nan' },\n+        { 'path': 'std::f64', 'name': 'is_nan' },\n+        { 'path': 'std::option::Option', 'name': 'is_none' },\n+    ],\n+};"}, {"sha": "b7805f6f5fbf581509d36f04cff3bb5c7a2ead69", "filename": "src/test/ui/feature-gate-macro-lifetime-matcher.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/834ef9f08ae3429a05dead80237bb4bd04769895/src%2Ftest%2Fui%2Ffeature-gate-macro-lifetime-matcher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/834ef9f08ae3429a05dead80237bb4bd04769895/src%2Ftest%2Fui%2Ffeature-gate-macro-lifetime-matcher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro-lifetime-matcher.stderr?ref=834ef9f08ae3429a05dead80237bb4bd04769895", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: :lifetime fragment specifier is experimental and subject to change (see issue #46895)\n-  --> $DIR/feature-gate-macro-lifetime-matcher.rs:14:19\n-   |\n-LL | macro_rules! m { ($lt:lifetime) => {} }\n-   |                   ^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(macro_lifetime_matcher)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "54d280a63e7984637b095d8b3aafe0b024d2040e", "filename": "src/test/ui/macros/nonterminal-matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.rs?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -11,7 +11,7 @@\n // Check that we are refusing to match on complex nonterminals for which tokens are\n // unavailable and we'd have to go through AST comparisons.\n \n-#![feature(decl_macro, macro_lifetime_matcher)]\n+#![feature(decl_macro)]\n \n macro simple_nonterminal($nt_ident: ident, $nt_lifetime: lifetime, $nt_tt: tt) {\n     macro n(a $nt_ident b $nt_lifetime c $nt_tt d) {"}, {"sha": "c658fc8cbcd1f199edd445a49cb43139ebdc5f02", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -1 +1 @@\n-Subproject commit 7a4c00c669b3bf0ffb24c7aa89a776cd48f1e2d0\n+Subproject commit c658fc8cbcd1f199edd445a49cb43139ebdc5f02"}, {"sha": "47667d93cb7f12b088a7e63840747c27075d058d", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/b4b71d5d5fd8bedecbacf08ffb45c8456700151b/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=b4b71d5d5fd8bedecbacf08ffb45c8456700151b", "patch": "@@ -160,10 +160,11 @@ function main(argv) {\n     // execQuery first parameter is built in getQuery (which takes in the search input).\n     // execQuery last parameter is built in buildIndex.\n     // buildIndex requires the hashmap from search-index.\n-    var functionsToLoad = [\"levenshtein\", \"validateResult\", \"getQuery\", \"buildIndex\", \"execQuery\",\n-                           \"execSearch\"];\n+    var functionsToLoad = [\"buildHrefAndPath\", \"pathSplitter\", \"levenshtein\", \"validateResult\",\n+                           \"getQuery\", \"buildIndex\", \"execQuery\", \"execSearch\"];\n \n     finalJS += 'window = { \"currentCrate\": \"std\" };\\n';\n+    finalJS += 'var rootPath = \"../\";\\n';\n     finalJS += ALIASES;\n     finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, mainJs);\n     finalJS += loadThings(variablesToLoad, 'variable', extractVariable, mainJs);"}]}