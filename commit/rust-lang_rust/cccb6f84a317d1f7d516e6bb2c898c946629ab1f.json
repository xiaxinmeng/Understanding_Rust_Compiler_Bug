{"sha": "cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjY2I2Zjg0YTMxN2QxZjdkNTE2ZTZiYjJjODk4Yzk0NjYyOWFiMWY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-05-17T22:13:20Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T00:39:35Z"}, "message": "syntax: ast: replace Gc<T> (previously @T) with P<T>.", "tree": {"sha": "0ae1e974fbed1c89e034c21ab3ce8f513562873a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ae1e974fbed1c89e034c21ab3ce8f513562873a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "html_url": "https://github.com/rust-lang/rust/commit/cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cccb6f84a317d1f7d516e6bb2c898c946629ab1f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1872c4c6b57a93c689c54e00d29d324ca1a10e95", "url": "https://api.github.com/repos/rust-lang/rust/commits/1872c4c6b57a93c689c54e00d29d324ca1a10e95", "html_url": "https://github.com/rust-lang/rust/commit/1872c4c6b57a93c689c54e00d29d324ca1a10e95"}], "stats": {"total": 153, "additions": 76, "deletions": 77}, "files": [{"sha": "d98bbe4dd3d4ff9ec156f1c1d409ab8aa372afe1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/cccb6f84a317d1f7d516e6bb2c898c946629ab1f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cccb6f84a317d1f7d516e6bb2c898c946629ab1f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "patch": "@@ -16,13 +16,12 @@ use ast_util;\n use owned_slice::OwnedSlice;\n use parse::token::{InternedString, str_to_ident};\n use parse::token;\n+use ptr::P;\n \n use std::fmt;\n use std::num::Zero;\n use std::fmt::Show;\n-use std::option::Option;\n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n@@ -267,23 +266,23 @@ pub struct WherePredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<Gc<MetaItem>>;\n+pub type CrateConfig = Vec<P<MetaItem>> ;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<Gc<Item>>\n+    pub exported_macros: Vec<P<Item>>\n }\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n-    MetaList(InternedString, Vec<Gc<MetaItem>>),\n+    MetaList(InternedString, Vec<P<MetaItem>>),\n     MetaNameValue(InternedString, Lit),\n }\n \n@@ -315,8 +314,8 @@ impl PartialEq for MetaItem_ {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n-    pub stmts: Vec<Gc<Stmt>>,\n-    pub expr: Option<Gc<Expr>>,\n+    pub stmts: Vec<P<Stmt>>,\n+    pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -332,7 +331,7 @@ pub struct Pat {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FieldPat {\n     pub ident: Ident,\n-    pub pat: Gc<Pat>,\n+    pub pat: P<Pat>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -362,20 +361,20 @@ pub enum Pat_ {\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, SpannedIdent, Option<Gc<Pat>>),\n+    PatIdent(BindingMode, SpannedIdent, Option<P<Pat>>),\n \n     /// \"None\" means a * pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<Vec<Gc<Pat>>>),\n+    PatEnum(Path, Option<Vec<P<Pat>>>),\n \n     PatStruct(Path, Vec<FieldPat>, bool),\n-    PatTup(Vec<Gc<Pat>>),\n-    PatBox(Gc<Pat>),\n-    PatRegion(Gc<Pat>), // reference pattern\n-    PatLit(Gc<Expr>),\n-    PatRange(Gc<Expr>, Gc<Expr>),\n+    PatTup(Vec<P<Pat>>),\n+    PatBox(P<Pat>),\n+    PatRegion(P<Pat>), // reference pattern\n+    PatLit(P<Expr>),\n+    PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n     ///     PatVec(~[a, b], Some(i), ~[y, z])\n-    PatVec(Vec<Gc<Pat>>, Option<Gc<Pat>>, Vec<Gc<Pat>>),\n+    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n     PatMac(Mac),\n }\n \n@@ -421,13 +420,13 @@ pub type Stmt = Spanned<Stmt_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n-    StmtDecl(Gc<Decl>, NodeId),\n+    StmtDecl(P<Decl>, NodeId),\n \n     /// Expr without trailing semi-colon (must have unit type):\n-    StmtExpr(Gc<Expr>, NodeId),\n+    StmtExpr(P<Expr>, NodeId),\n \n     /// Expr with trailing semi-colon (may have any type):\n-    StmtSemi(Gc<Expr>, NodeId),\n+    StmtSemi(P<Expr>, NodeId),\n \n     /// bool: is there a trailing sem-colon?\n     StmtMac(Mac, bool),\n@@ -447,8 +446,8 @@ pub enum LocalSource {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Local {\n     pub ty: P<Ty>,\n-    pub pat: Gc<Pat>,\n-    pub init: Option<Gc<Expr>>,\n+    pub pat: P<Pat>,\n+    pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n     pub source: LocalSource,\n@@ -459,24 +458,24 @@ pub type Decl = Spanned<Decl_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Decl_ {\n     /// A local (let) binding:\n-    DeclLocal(Gc<Local>),\n+    DeclLocal(P<Local>),\n     /// An item binding:\n-    DeclItem(Gc<Item>),\n+    DeclItem(P<Item>),\n }\n \n /// represents one arm of a 'match'\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n-    pub pats: Vec<Gc<Pat>>,\n-    pub guard: Option<Gc<Expr>>,\n-    pub body: Gc<Expr>,\n+    pub pats: Vec<P<Pat>>,\n+    pub guard: Option<P<Expr>>,\n+    pub body: P<Expr>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Field {\n     pub ident: SpannedIdent,\n-    pub expr: Gc<Expr>,\n+    pub expr: P<Expr>,\n     pub span: Span,\n }\n \n@@ -504,56 +503,56 @@ pub struct Expr {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n-    ExprBox(Gc<Expr>, Gc<Expr>),\n-    ExprVec(Vec<Gc<Expr>>),\n-    ExprCall(Gc<Expr>, Vec<Gc<Expr>>),\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<Gc<Expr>>),\n-    ExprTup(Vec<Gc<Expr>>),\n-    ExprBinary(BinOp, Gc<Expr>, Gc<Expr>),\n-    ExprUnary(UnOp, Gc<Expr>),\n-    ExprLit(Gc<Lit>),\n-    ExprCast(Gc<Expr>, P<Ty>),\n-    ExprIf(Gc<Expr>, P<Block>, Option<Gc<Expr>>),\n+    ExprBox(P<Expr>, P<Expr>),\n+    ExprVec(Vec<P<Expr>>),\n+    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprTup(Vec<P<Expr>>),\n+    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    ExprUnary(UnOp, P<Expr>),\n+    ExprLit(P<Lit>),\n+    ExprCast(P<Expr>, P<Ty>),\n+    ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n-    ExprWhile(Gc<Expr>, P<Block>, Option<Ident>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n-    ExprForLoop(Gc<Pat>, Gc<Expr>, P<Block>, Option<Ident>),\n+    ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(Gc<Expr>, Vec<Arm>),\n+    ExprMatch(P<Expr>, Vec<Arm>),\n     ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n-    ExprAssign(Gc<Expr>, Gc<Expr>),\n-    ExprAssignOp(BinOp, Gc<Expr>, Gc<Expr>),\n-    ExprField(Gc<Expr>, SpannedIdent, Vec<P<Ty>>),\n-    ExprTupField(Gc<Expr>, Spanned<uint>, Vec<P<Ty>>),\n-    ExprIndex(Gc<Expr>, Gc<Expr>),\n+    ExprAssign(P<Expr>, P<Expr>),\n+    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    ExprField(P<Expr>, SpannedIdent, Vec<P<Ty>>),\n+    ExprTupField(P<Expr>, Spanned<uint>, Vec<P<Ty>>),\n+    ExprIndex(P<Expr>, P<Expr>),\n \n     /// Variable reference, possibly containing `::` and/or\n     /// type parameters, e.g. foo::bar::<baz>\n     ExprPath(Path),\n \n-    ExprAddrOf(Mutability, Gc<Expr>),\n+    ExprAddrOf(Mutability, P<Expr>),\n     ExprBreak(Option<Ident>),\n     ExprAgain(Option<Ident>),\n-    ExprRet(Option<Gc<Expr>>),\n+    ExprRet(Option<P<Expr>>),\n \n     ExprInlineAsm(InlineAsm),\n \n     ExprMac(Mac),\n \n     /// A struct literal expression.\n-    ExprStruct(Path, Vec<Field> , Option<Gc<Expr>> /* base */),\n+    ExprStruct(Path, Vec<Field>, Option<P<Expr>> /* base */),\n \n     /// A vector literal constructed from one repeated element.\n-    ExprRepeat(Gc<Expr> /* element */, Gc<Expr> /* count */),\n+    ExprRepeat(P<Expr> /* element */, P<Expr> /* count */),\n \n     /// No-op: used solely so we can pretty-print faithfully\n-    ExprParen(Gc<Expr>)\n+    ExprParen(P<Expr>)\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -766,12 +765,12 @@ pub struct TypeMethod {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TraitItem {\n     RequiredMethod(TypeMethod),\n-    ProvidedMethod(Gc<Method>),\n+    ProvidedMethod(P<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ImplItem {\n-    MethodImplItem(Gc<Method>),\n+    MethodImplItem(P<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -879,7 +878,7 @@ impl fmt::Show for Onceness {\n }\n \n /// Represents the type of a closure\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<LifetimeDef>,\n     pub fn_style: FnStyle,\n@@ -888,7 +887,7 @@ pub struct ClosureTy {\n     pub bounds: TyParamBounds,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: FnStyle,\n     pub abi: Abi,\n@@ -909,18 +908,18 @@ pub enum Ty_ {\n     TyBox(P<Ty>),\n     TyUniq(P<Ty>),\n     TyVec(P<Ty>),\n-    TyFixedLengthVec(P<Ty>, Gc<Expr>),\n+    TyFixedLengthVec(P<Ty>, P<Expr>),\n     TyPtr(MutTy),\n     TyRptr(Option<Lifetime>, MutTy),\n-    TyClosure(Gc<ClosureTy>),\n-    TyProc(Gc<ClosureTy>),\n-    TyBareFn(Gc<BareFnTy>),\n-    TyUnboxedFn(Gc<UnboxedFnTy>),\n+    TyClosure(P<ClosureTy>),\n+    TyProc(P<ClosureTy>),\n+    TyBareFn(P<BareFnTy>),\n+    TyUnboxedFn(P<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n     /// No-op; kept solely so that we can pretty-print faithfully\n     TyParen(P<Ty>),\n-    TyTypeof(Gc<Expr>),\n+    TyTypeof(P<Expr>),\n     /// TyInfer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -936,8 +935,8 @@ pub enum AsmDialect {\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n-    pub outputs: Vec<(InternedString, Gc<Expr>, bool)>,\n-    pub inputs: Vec<(InternedString, Gc<Expr>)>,\n+    pub outputs: Vec<(InternedString, P<Expr>, bool)>,\n+    pub inputs: Vec<(InternedString, P<Expr>)>,\n     pub clobbers: InternedString,\n     pub volatile: bool,\n     pub alignstack: bool,\n@@ -948,7 +947,7 @@ pub struct InlineAsm {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arg {\n     pub ty: P<Ty>,\n-    pub pat: Gc<Pat>,\n+    pub pat: P<Pat>,\n     pub id: NodeId,\n }\n \n@@ -962,11 +961,11 @@ impl Arg {\n                 node: TyInfer,\n                 span: DUMMY_SP,\n             }),\n-            pat: box(GC) Pat {\n+            pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatIdent(BindByValue(mutability), path, None),\n                 span: span\n-            },\n+            }),\n             id: DUMMY_NODE_ID\n         }\n     }\n@@ -1052,14 +1051,14 @@ pub struct Mod {\n     /// to the last token in the external file.\n     pub inner: Span,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<Gc<Item>>,\n+    pub items: Vec<P<Item>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<Gc<ForeignItem>>,\n+    pub items: Vec<P<ForeignItem>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -1071,7 +1070,7 @@ pub struct VariantArg {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n-    StructVariantKind(Gc<StructDef>),\n+    StructVariantKind(P<StructDef>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -1085,7 +1084,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n-    pub disr_expr: Option<Gc<Expr>>,\n+    pub disr_expr: Option<P<Expr>>,\n     pub vis: Visibility,\n }\n \n@@ -1141,7 +1140,7 @@ pub enum ViewItem_ {\n     /// (containing arbitrary characters) from which to fetch the crate sources\n     /// For example, extern crate whatever = \"github.com/rust-lang/rust\"\n     ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(Gc<ViewPath>),\n+    ViewItemUse(P<ViewPath>),\n }\n \n /// Meta-data associated with an item\n@@ -1164,7 +1163,7 @@ pub struct AttrId(pub uint);\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: Gc<MetaItem>,\n+    pub value: P<MetaItem>,\n     pub is_sugared_doc: bool,\n }\n \n@@ -1259,13 +1258,13 @@ pub struct Item {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Item_ {\n-    ItemStatic(P<Ty>, Mutability, Gc<Expr>),\n+    ItemStatic(P<Ty>, Mutability, P<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n-    ItemStruct(Gc<StructDef>, Generics),\n+    ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Generics,\n               Option<TyParamBound>, // (optional) default bound not required for Self.\n@@ -1308,15 +1307,15 @@ pub enum UnboxedClosureKind {\n /// that we trans.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedItem {\n-    IIItem(Gc<Item>),\n+    IIItem(P<Item>),\n     IITraitItem(DefId /* impl id */, InlinedTraitItem),\n-    IIForeign(Gc<ForeignItem>),\n+    IIForeign(P<ForeignItem>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedTraitItem {\n-    ProvidedInlinedTraitItem(Gc<Method>),\n-    RequiredInlinedTraitItem(Gc<Method>),\n+    ProvidedInlinedTraitItem(P<Method>),\n+    RequiredInlinedTraitItem(P<Method>),\n }\n \n #[cfg(test)]"}]}