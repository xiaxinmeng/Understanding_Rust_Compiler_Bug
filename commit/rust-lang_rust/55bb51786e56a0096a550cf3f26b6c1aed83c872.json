{"sha": "55bb51786e56a0096a550cf3f26b6c1aed83c872", "node_id": "C_kwDOAAsO6NoAKDU1YmI1MTc4NmU1NmEwMDk2YTU1MGNmM2YyNmI2YzFhZWQ4M2M4NzI", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-08-26T21:43:12Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-10-07T02:44:50Z"}, "message": "Move highlighting logic from JS to Rust\n\nContinue migrating JS functionality\n\nCleanup\n\nFix compile error\n\nClean up the diff\n\nSet toggle font to sans-serif", "tree": {"sha": "763546579a8037bf10af7400c9c6e5e7ae6d658a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/763546579a8037bf10af7400c9c6e5e7ae6d658a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55bb51786e56a0096a550cf3f26b6c1aed83c872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55bb51786e56a0096a550cf3f26b6c1aed83c872", "html_url": "https://github.com/rust-lang/rust/commit/55bb51786e56a0096a550cf3f26b6c1aed83c872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55bb51786e56a0096a550cf3f26b6c1aed83c872/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea8f0a39a2423cc7a4acd31e3a7309853f22509", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea8f0a39a2423cc7a4acd31e3a7309853f22509", "html_url": "https://github.com/rust-lang/rust/commit/eea8f0a39a2423cc7a4acd31e3a7309853f22509"}], "stats": {"total": 376, "additions": 189, "deletions": 187}, "files": [{"sha": "43abcf095d858e140c264e6f0a9c6fa48fac45f6", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -45,7 +45,7 @@ crate struct TestOptions {\n     crate attrs: Vec<String>,\n }\n \n-crate fn make_rustc_config(options: &Options) -> interface::Config {\n+crate fn run(options: Options) -> Result<(), ErrorReported> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = crate::lint::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -87,7 +87,7 @@ crate fn make_rustc_config(options: &Options) -> interface::Config {\n     let mut cfgs = options.cfgs.clone();\n     cfgs.push(\"doc\".to_owned());\n     cfgs.push(\"doctest\".to_owned());\n-    interface::Config {\n+    let config = interface::Config {\n         opts: sessopts,\n         crate_cfg: interface::parse_cfgspecs(cfgs),\n         input,\n@@ -103,11 +103,7 @@ crate fn make_rustc_config(options: &Options) -> interface::Config {\n         override_queries: None,\n         make_codegen_backend: None,\n         registry: rustc_driver::diagnostics_registry(),\n-    }\n-}\n-\n-crate fn run(options: Options) -> Result<(), ErrorReported> {\n-    let config = make_rustc_config(&options);\n+    };\n \n     let test_args = options.test_args.clone();\n     let display_doctest_warnings = options.display_doctest_warnings;"}, {"sha": "b0e907cb0590d08e275ca6092425009920becc4d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -12,6 +12,7 @@ use crate::html::render::Context;\n use std::collections::VecDeque;\n use std::fmt::{Display, Write};\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n@@ -30,6 +31,8 @@ crate struct ContextInfo<'a, 'b, 'c> {\n     crate root_path: &'c str,\n }\n \n+crate type DecorationInfo = FxHashMap<&'static str, Vec<(u32, u32)>>;\n+\n /// Highlights `src`, returning the HTML output.\n crate fn render_with_highlighting(\n     src: &str,\n@@ -40,6 +43,7 @@ crate fn render_with_highlighting(\n     edition: Edition,\n     extra_content: Option<Buffer>,\n     context_info: Option<ContextInfo<'_, '_, '_>>,\n+    decoration_info: Option<DecorationInfo>,\n ) {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     if let Some((edition_info, class)) = tooltip {\n@@ -56,7 +60,7 @@ crate fn render_with_highlighting(\n     }\n \n     write_header(out, class, extra_content);\n-    write_code(out, &src, edition, context_info);\n+    write_code(out, &src, edition, context_info, decoration_info);\n     write_footer(out, playground_button);\n }\n \n@@ -89,17 +93,23 @@ fn write_code(\n     src: &str,\n     edition: Edition,\n     context_info: Option<ContextInfo<'_, '_, '_>>,\n+    decoration_info: Option<DecorationInfo>,\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    Classifier::new(&src, edition, context_info.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP))\n-        .highlight(&mut |highlight| {\n-            match highlight {\n-                Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n-                Highlight::EnterSpan { class } => enter_span(out, class),\n-                Highlight::ExitSpan => exit_span(out),\n-            };\n-        });\n+    Classifier::new(\n+        &src,\n+        edition,\n+        context_info.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n+        decoration_info,\n+    )\n+    .highlight(&mut |highlight| {\n+        match highlight {\n+            Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n+            Highlight::EnterSpan { class } => enter_span(out, class),\n+            Highlight::ExitSpan => exit_span(out),\n+        };\n+    });\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n@@ -127,6 +137,7 @@ enum Class {\n     PreludeTy,\n     PreludeVal,\n     QuestionMark,\n+    Decoration(&'static str),\n }\n \n impl Class {\n@@ -150,6 +161,7 @@ impl Class {\n             Class::PreludeTy => \"prelude-ty\",\n             Class::PreludeVal => \"prelude-val\",\n             Class::QuestionMark => \"question-mark\",\n+            Class::Decoration(kind) => kind,\n         }\n     }\n \n@@ -244,7 +256,28 @@ impl Iterator for PeekIter<'a> {\n     type Item = (TokenKind, &'a str);\n     fn next(&mut self) -> Option<Self::Item> {\n         self.peek_pos = 0;\n-        if let Some(first) = self.stored.pop_front() { Some(first) } else { self.iter.next() }\n+        if let Some(first) = self.stored.pop_front() {\n+            Some(first)\n+        } else {\n+            self.iter.next()\n+        }\n+    }\n+}\n+\n+/// Custom spans inserted into the source. Eg --scrape-examples uses this to highlight function calls\n+struct Decorations {\n+    starts: Vec<(u32, &'static str)>,\n+    ends: Vec<u32>,\n+}\n+\n+impl Decorations {\n+    fn new(info: DecorationInfo) -> Self {\n+        let (starts, ends) = info\n+            .into_iter()\n+            .map(|(kind, ranges)| ranges.into_iter().map(move |(lo, hi)| ((lo, kind), hi)))\n+            .flatten()\n+            .unzip();\n+        Decorations { starts, ends }\n     }\n }\n \n@@ -259,12 +292,18 @@ struct Classifier<'a> {\n     byte_pos: u32,\n     file_span: Span,\n     src: &'a str,\n+    decorations: Option<Decorations>,\n }\n \n impl<'a> Classifier<'a> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n     /// file span which will be used later on by the `span_correspondance_map`.\n-    fn new(src: &str, edition: Edition, file_span: Span) -> Classifier<'_> {\n+    fn new(\n+        src: &str,\n+        edition: Edition,\n+        file_span: Span,\n+        decoration_info: Option<DecorationInfo>,\n+    ) -> Classifier<'_> {\n         let tokens = PeekIter::new(TokenIter { src });\n         Classifier {\n             tokens,\n@@ -275,6 +314,7 @@ impl<'a> Classifier<'a> {\n             byte_pos: 0,\n             file_span,\n             src,\n+            decorations,\n         }\n     }\n \n@@ -356,6 +396,19 @@ impl<'a> Classifier<'a> {\n     /// token is used.\n     fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'a>)) {\n         loop {\n+            if let Some(decs) = self.decorations.as_mut() {\n+                let byte_pos = self.byte_pos;\n+                let n_starts = decs.starts.iter().filter(|(i, _)| byte_pos >= *i).count();\n+                for (_, kind) in decs.starts.drain(0..n_starts) {\n+                    sink(Highlight::EnterSpan { class: Class::Decoration(kind) });\n+                }\n+\n+                let n_ends = decs.ends.iter().filter(|i| byte_pos >= **i).count();\n+                for _ in decs.ends.drain(0..n_ends) {\n+                    sink(Highlight::ExitSpan);\n+                }\n+            }\n+\n             if self\n                 .tokens\n                 .peek()"}, {"sha": "405bdf0d8108e33820eaa12755833bd18e46d2c7", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -22,7 +22,7 @@ fn test_html_highlighting() {\n         let src = include_str!(\"fixtures/sample.rs\");\n         let html = {\n             let mut out = Buffer::new();\n-            write_code(&mut out, src, Edition::Edition2018, None);\n+            write_code(&mut out, src, Edition::Edition2018, None, None);\n             format!(\"{}<pre><code>{}</code></pre>\\n\", STYLE, out.into_inner())\n         };\n         expect_file![\"fixtures/sample.html\"].assert_eq(&html);\n@@ -36,7 +36,7 @@ fn test_dos_backline() {\n     println!(\\\"foo\\\");\\r\\n\\\n }\\r\\n\";\n         let mut html = Buffer::new();\n-        write_code(&mut html, src, Edition::Edition2018, None);\n+        write_code(&mut html, src, Edition::Edition2018, None, None);\n         expect_file![\"fixtures/dos_line.html\"].assert_eq(&html.into_inner());\n     });\n }\n@@ -50,7 +50,7 @@ let x = super::b::foo;\n let y = Self::whatever;\";\n \n         let mut html = Buffer::new();\n-        write_code(&mut html, src, Edition::Edition2018, None);\n+        write_code(&mut html, src, Edition::Edition2018, None, None);\n         expect_file![\"fixtures/highlight.html\"].assert_eq(&html.into_inner());\n     });\n }"}, {"sha": "a0f13dd71a5b644aff68563845540a25e24bd1a5", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -360,6 +360,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             edition,\n             None,\n             None,\n+            None,\n         );\n         Some(Event::Html(s.into_inner().into()))\n     }"}, {"sha": "24e50ef91ab91afcb8411ee114e379cbac06f12d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -46,7 +46,7 @@ use std::string::ToString;\n \n use rustc_ast_pretty::pprust;\n use rustc_attr::{ConstStability, Deprecation, StabilityLevel};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n@@ -2496,23 +2496,28 @@ fn render_call_locations(\n \n         // To reduce file sizes, we only want to embed the source code needed to understand the example, not\n         // the entire file. So we find the smallest byte range that covers all items enclosing examples.\n+        assert!(call_data.locations.len() > 0);\n         let min_loc =\n-            call_data.locations.iter().min_by_key(|loc| loc.enclosing_item_span.0).unwrap();\n-        let min_byte = min_loc.enclosing_item_span.0;\n-        let min_line = min_loc.enclosing_item_lines.0;\n+            call_data.locations.iter().min_by_key(|loc| loc.enclosing_item.byte_span.0).unwrap();\n+        let min_byte = min_loc.enclosing_item.byte_span.0;\n+        let min_line = min_loc.enclosing_item.line_span.0;\n         let max_byte =\n-            call_data.locations.iter().map(|loc| loc.enclosing_item_span.1).max().unwrap();\n+            call_data.locations.iter().map(|loc| loc.enclosing_item.byte_span.1).max().unwrap();\n \n         // The output code is limited to that byte range.\n-        let contents_subset = &contents[min_byte..max_byte];\n+        let contents_subset = &contents[(min_byte as usize)..(max_byte as usize)];\n \n         // The call locations need to be updated to reflect that the size of the program has changed.\n         // Specifically, the ranges are all subtracted by `min_byte` since that's the new zero point.\n-        let locations = call_data\n+        let (byte_ranges, line_ranges): (Vec<_>, Vec<_>) = call_data\n             .locations\n             .iter()\n-            .map(|loc| (loc.call_span.0 - min_byte, loc.call_span.1 - min_byte))\n-            .collect::<Vec<_>>();\n+            .map(|loc| {\n+                let (byte_lo, byte_hi) = loc.call_expr.byte_span;\n+                let (line_lo, line_hi) = loc.call_expr.line_span;\n+                ((byte_lo - min_byte, byte_hi - min_byte), (line_lo - min_line, line_hi - min_line))\n+            })\n+            .unzip();\n \n         let edition = cx.shared.edition();\n         write!(\n@@ -2524,15 +2529,26 @@ fn render_call_locations(\n             // The code and locations are encoded as data attributes, so they can be read\n             // later by the JS for interactions.\n             code = contents_subset.replace(\"\\\"\", \"&quot;\"),\n-            locations = serde_json::to_string(&locations).unwrap(),\n+            locations = serde_json::to_string(&line_ranges).unwrap(),\n         );\n         write!(w, r#\"<span class=\"prev\">&pr;</span> <span class=\"next\">&sc;</span>\"#);\n         write!(w, r#\"<span class=\"expand\">&varr;</span>\"#);\n \n         // FIXME(wcrichto): where should file_span and root_path come from?\n         let file_span = rustc_span::DUMMY_SP;\n         let root_path = \"\".to_string();\n-        sources::print_src(w, contents_subset, edition, file_span, cx, &root_path, Some(min_line));\n+        let mut decoration_info = FxHashMap::default();\n+        decoration_info.insert(\"highlight\", byte_ranges);\n+        sources::print_src(\n+            w,\n+            contents_subset,\n+            edition,\n+            file_span,\n+            cx,\n+            &root_path,\n+            Some(min_line),\n+            Some(decoration_info),\n+        );\n         write!(w, \"</div></div>\");\n     };\n \n@@ -2542,7 +2558,8 @@ fn render_call_locations(\n     // understand at a glance.\n     let ordered_locations = {\n         let sort_criterion = |(_, call_data): &(_, &CallData)| {\n-            let (lo, hi) = call_data.locations[0].enclosing_item_span;\n+            // Use the first location because that's what the user will see initially\n+            let (lo, hi) = call_data.locations[0].enclosing_item.byte_span;\n             hi - lo\n         };\n "}, {"sha": "a9dce1be0d817ed29469c7c50f03d97595191607", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -1117,6 +1117,7 @@ fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Mac\n             it.span(cx.tcx()).inner().edition(),\n             None,\n             None,\n+            None,\n         );\n     });\n     document(w, cx, it, None, HeadingOffset::H2)"}, {"sha": "c3441036d503b9cd3ebcd7ed12d9800edc6afd7e", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -212,6 +212,7 @@ impl SourceCollector<'_, 'tcx> {\n                     &self.cx,\n                     &root_path,\n                     None,\n+                    None,\n                 )\n             },\n             &self.cx.shared.style_files,\n@@ -259,6 +260,7 @@ crate fn print_src(\n     context: &Context<'_>,\n     root_path: &str,\n     offset: Option<usize>,\n+    decoration_info: Option<highlight::DecorationInfo>,\n ) {\n     let lines = s.lines().count();\n     let mut line_numbers = Buffer::empty_from(buf);\n@@ -283,5 +285,6 @@ crate fn print_src(\n         edition,\n         Some(line_numbers),\n         Some(highlight::ContextInfo { context, file_span, root_path }),\n+        decoration_info,\n     );\n }"}, {"sha": "ccb6bb798684906b5ffdc3a9ccb0fd49f01255fc", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -137,7 +137,7 @@ h1.fqn {\n \tmargin-top: 0;\n \n \t/* workaround to keep flex from breaking below 700 px width due to the float: right on the nav\n-\t\t above the h1 */\n+\t   above the h1 */\n \tpadding-left: 1px;\n }\n h1.fqn > .in-band > a:hover {\n@@ -974,7 +974,7 @@ body.blur > :not(#help) {\n \ttext-shadow:\n \t\t1px 0 0 black,\n \t\t-1px 0 0 black,\n-\t\t0\t 1px 0 black,\n+\t\t0  1px 0 black,\n \t\t0 -1px 0 black;\n }\n \n@@ -1214,8 +1214,8 @@ a.test-arrow:hover{\n \n .notable-traits-tooltip::after {\n \t/* The margin on the tooltip does not capture hover events,\n-\t\t this extends the area of hover enough so that mouse hover is not\n-\t\t lost when moving the mouse to the tooltip */\n+\t   this extends the area of hover enough so that mouse hover is not\n+\t   lost when moving the mouse to the tooltip */\n \tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n@@ -1715,7 +1715,7 @@ details.undocumented[open] > summary::before {\n \t}\n \n \t/* We do NOT hide this element so that alternative device readers still have this information\n-\t\t available. */\n+\t   available. */\n \t.sidebar-elems {\n \t\tposition: fixed;\n \t\tz-index: 1;\n@@ -1971,7 +1971,8 @@ details.undocumented[open] > summary::before {\n \t}\n }\n \n-/* This part is for the new \"examples\" components */\n+\n+/* Begin: styles for --scrape-examples feature */\n \n .scraped-example-title {\n \tfont-family: 'Fira Sans';\n@@ -2063,16 +2064,17 @@ details.undocumented[open] > summary::before {\n \toverflow-y: hidden;\n }\n \n-.scraped-example .line-numbers span.highlight {\n-\tbackground: #f6fdb0;\n+.scraped-example .example-wrap .rust span.highlight {\n+\tbackground: #fcffd6;\n }\n \n-.scraped-example .example-wrap .rust span.highlight {\n+.scraped-example .example-wrap .rust span.highlight.focus {\n \tbackground: #f6fdb0;\n }\n \n .more-examples-toggle summary {\n \tcolor: #999;\n+\tfont-family: 'Fira Sans';\n }\n \n .more-scraped-examples {\n@@ -2115,3 +2117,5 @@ h1 + .scraped-example {\n .example-links ul {\n \tmargin-bottom: 0;\n }\n+\n+/* End: styles for --scrape-examples feature */"}, {"sha": "1b924991139b4076fc45db1ebb0ea80be5699c9e", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 31, "deletions": 124, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -980,154 +980,55 @@ function hideThemeButtonState() {\n     window.addEventListener(\"hashchange\", onHashChange);\n     searchState.setup();\n \n-    /////// EXAMPLE ANALYZER\n-\n-    // Merge the full set of [from, to] offsets into a minimal set of non-overlapping\n-    // [from, to] offsets.\n-    // NB: This is such a archetypal software engineering interview question that\n-    // I can't believe I actually had to write it. Yes, it's O(N) in the input length --\n-    // but it does assume a sorted input!\n-    function distinctRegions(locs) {\n-        var start = -1;\n-        var end = -1;\n-        var output = [];\n-        for (var i = 0; i < locs.length; i++) {\n-            var loc = locs[i];\n-            if (loc[0] > end) {\n-                if (end > 0) {\n-                    output.push([start, end]);\n-                }\n-                start = loc[0];\n-                end = loc[1];\n-            } else {\n-                end = Math.max(end, loc[1]);\n-            }\n-        }\n-        if (end > 0) {\n-            output.push([start, end]);\n-        }\n-        return output;\n-    }\n-\n-    function convertLocsStartsToLineOffsets(code, locs) {\n-        locs = distinctRegions(locs.slice(0).sort(function (a, b) {\n-            return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n-        })); // sort by start; use end if start is equal.\n-        var codeLines = code.split(\"\\n\");\n-        var lineIndex = 0;\n-        var totalOffset = 0;\n-        var output = [];\n-\n-        while (locs.length > 0 && lineIndex < codeLines.length) {\n-            // +1 here and later is due to omitted \\n\n-            var lineLength = codeLines[lineIndex].length + 1;\n-            while (locs.length > 0 && totalOffset + lineLength > locs[0][0]) {\n-                var endIndex = lineIndex;\n-                var charsRemaining = locs[0][1] - totalOffset;\n-                while (endIndex < codeLines.length &&\n-                       charsRemaining > codeLines[endIndex].length + 1)\n-                {\n-                    charsRemaining -= codeLines[endIndex].length + 1;\n-                    endIndex += 1;\n-                }\n-                output.push({\n-                    from: [lineIndex, locs[0][0] - totalOffset],\n-                    to: [endIndex, charsRemaining]\n-                });\n-                locs.shift();\n-            }\n-            lineIndex++;\n-            totalOffset += lineLength;\n-        }\n-        return output;\n-    }\n-\n-    // inserts str into html, *but* calculates idx by eliding anything in html that's not in raw.\n-    // ideally this would work by walking the element tree...but this is good enough for now.\n-    function insertStrAtRawIndex(raw, html, idx, str) {\n-        if (idx > raw.length) {\n-            return html;\n-        }\n-        if (idx == raw.length) {\n-            return html + str;\n-        }\n-        var rawIdx = 0;\n-        var htmlIdx = 0;\n-        while (rawIdx < idx && rawIdx < raw.length) {\n-            while (raw[rawIdx] !== html[htmlIdx] && htmlIdx < html.length) {\n-                htmlIdx++;\n-            }\n-            rawIdx++;\n-            htmlIdx++;\n-        }\n-        return html.substring(0, htmlIdx) + str + html.substr(htmlIdx);\n-    }\n+    /////// --scrape-examples interactions\n \n     // Scroll code block to put the given code location in the middle of the viewer\n     function scrollToLoc(elt, loc) {\n         var wrapper = elt.querySelector(\".code-wrapper\");\n         var halfHeight = wrapper.offsetHeight / 2;\n         var lines = elt.querySelector('.line-numbers');\n-        var offsetMid = (lines.children[loc.from[0]].offsetTop\n-                         + lines.children[loc.to[0]].offsetTop) / 2;\n+        var offsetMid = (lines.children[loc[0]].offsetTop\n+                         + lines.children[loc[1]].offsetTop) / 2;\n         var scrollOffset = offsetMid - halfHeight;\n         lines.scrollTo(0, scrollOffset);\n         elt.querySelector(\".rust\").scrollTo(0, scrollOffset);\n     }\n \n     function updateScrapedExample(example) {\n-        var code = example.attributes.getNamedItem(\"data-code\").textContent;\n-        var codeLines = code.split(\"\\n\");\n         var locs = JSON.parse(example.attributes.getNamedItem(\"data-locs\").textContent);\n-        locs = convertLocsStartsToLineOffsets(code, locs);\n-\n-        // Add call-site highlights to code listings\n-        var litParent = example.querySelector('.example-wrap pre.rust');\n-        var litHtml = litParent.innerHTML.split(\"\\n\");\n-        onEach(locs, function (loc) {\n-            for (var i = loc.from[0]; i < loc.to[0] + 1; i++) {\n-                addClass(example.querySelector('.line-numbers').children[i], \"highlight\");\n-            }\n-            litHtml[loc.to[0]] = insertStrAtRawIndex(\n-                codeLines[loc.to[0]],\n-                litHtml[loc.to[0]],\n-                loc.to[1],\n-                \"</span>\");\n-            litHtml[loc.from[0]] = insertStrAtRawIndex(\n-                codeLines[loc.from[0]],\n-                litHtml[loc.from[0]],\n-                loc.from[1],\n-                '<span class=\"highlight\" data-loc=\"' +\n-                    JSON.stringify(loc).replace(/\"/g, \"&quot;\") +\n-                    '\">');\n-        }, true); // do this backwards to avoid shifting later offsets\n-        litParent.innerHTML = litHtml.join('\\n');\n-\n-        // Toggle through list of examples in a given file\n+\n         var locIndex = 0;\n+        var highlights = example.querySelectorAll('.highlight');\n+        addClass(highlights[0], 'focus');\n         if (locs.length > 1) {\n+            // Toggle through list of examples in a given file\n+            var onChangeLoc = function(f) {\n+                removeClass(highlights[locIndex], 'focus');\n+                f();\n+                scrollToLoc(example, locs[locIndex]);\n+                addClass(highlights[locIndex], 'focus');\n+            };\n             example.querySelector('.prev')\n-                .addEventListener('click', function () {\n-                    locIndex = (locIndex - 1 + locs.length) % locs.length;\n-                    scrollToLoc(example, locs[locIndex]);\n+                .addEventListener('click', function() {\n+                    onChangeLoc(function() {\n+                        locIndex = (locIndex - 1 + locs.length) % locs.length;\n+                    });\n                 });\n             example.querySelector('.next')\n-                .addEventListener('click', function () {\n-                    locIndex = (locIndex + 1) % locs.length;\n-                    scrollToLoc(example, locs[locIndex]);\n+                .addEventListener('click', function() {\n+                    onChangeLoc(function() { locIndex = (locIndex + 1) % locs.length; });\n                 });\n         } else {\n+            // Remove buttons if there's only one example in the file\n             example.querySelector('.prev').remove();\n             example.querySelector('.next').remove();\n         }\n \n-        let codeEl = example.querySelector('.rust');\n-        let expandButton = example.querySelector('.expand');\n-        if (codeEl.scrollHeight == codeEl.clientHeight) {\n-            addClass(example, 'expanded');\n-            expandButton.remove();\n-        } else {\n-            // Show full code on expansion\n+        var codeEl = example.querySelector('.rust');\n+        var codeOverflows = codeEl.scrollHeight > codeEl.clientHeight;\n+        var expandButton = example.querySelector('.expand');\n+        if (codeOverflows) {\n+            // If file is larger than default height, give option to expand the viewer\n             expandButton.addEventListener('click', function () {\n                 if (hasClass(example, \"expanded\")) {\n                     removeClass(example, \"expanded\");\n@@ -1136,6 +1037,10 @@ function hideThemeButtonState() {\n                     addClass(example, \"expanded\");\n                 }\n             });\n+        } else {\n+            // Otherwise remove expansion buttons\n+            addClass(example, 'expanded');\n+            expandButton.remove();\n         }\n \n         // Start with the first example in view\n@@ -1146,6 +1051,8 @@ function hideThemeButtonState() {\n         var firstExamples = document.querySelectorAll('.scraped-example-list > .scraped-example');\n         onEach(firstExamples, updateScrapedExample);\n         onEach(document.querySelectorAll('.more-examples-toggle'), function(toggle) {\n+            // Allow users to click the left border of the <details> section to close it,\n+            // since the section can be large and finding the [+] button is annoying.\n             toggle.querySelector('.toggle-line').addEventListener('click', function() {\n                 toggle.open = false;\n             });"}, {"sha": "3887647ca0a4c58616c437b8cd1bdc265e4e45b0", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb51786e56a0096a550cf3f26b6c1aed83c872/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=55bb51786e56a0096a550cf3f26b6c1aed83c872", "patch": "@@ -1,5 +1,4 @@\n-//! This module analyzes crates to find examples of uses for items in the\n-//! current crate being documented.\n+//! This module analyzes crates to find call sites that can serve as examples in the documentation.\n \n use crate::clean;\n use crate::config;\n@@ -11,20 +10,55 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n     self as hir,\n     intravisit::{self, Visitor},\n+    HirId,\n };\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::{def_id::DefId, FileName};\n+use rustc_span::{def_id::DefId, BytePos, FileName, SourceFile};\n use serde::{Deserialize, Serialize};\n use std::fs;\n use std::path::PathBuf;\n \n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+crate struct SyntaxRange {\n+    crate byte_span: (u32, u32),\n+    crate line_span: (usize, usize),\n+}\n+\n+impl SyntaxRange {\n+    fn new(span: rustc_span::Span, file: &SourceFile) -> Self {\n+        let get_pos = |bytepos: BytePos| file.original_relative_byte_pos(bytepos).0;\n+        let get_line = |bytepos: BytePos| file.lookup_line(bytepos).unwrap();\n+\n+        SyntaxRange {\n+            byte_span: (get_pos(span.lo()), get_pos(span.hi())),\n+            line_span: (get_line(span.lo()), get_line(span.hi())),\n+        }\n+    }\n+}\n+\n #[derive(Serialize, Deserialize, Debug, Clone)]\n crate struct CallLocation {\n-    crate call_span: (usize, usize),\n-    crate enclosing_item_span: (usize, usize),\n-    crate enclosing_item_lines: (usize, usize),\n+    crate call_expr: SyntaxRange,\n+    crate enclosing_item: SyntaxRange,\n+}\n+\n+impl CallLocation {\n+    fn new(\n+        tcx: TyCtxt<'_>,\n+        expr_span: rustc_span::Span,\n+        expr_id: HirId,\n+        source_file: &rustc_span::SourceFile,\n+    ) -> Self {\n+        let enclosing_item_span = tcx.hir().span_with_body(tcx.hir().get_parent_item(expr_id));\n+        assert!(enclosing_item_span.contains(expr_span));\n+\n+        CallLocation {\n+            call_expr: SyntaxRange::new(expr_span, source_file),\n+            enclosing_item: SyntaxRange::new(enclosing_item_span, source_file),\n+        }\n+    }\n }\n \n #[derive(Serialize, Deserialize, Debug, Clone)]\n@@ -96,24 +130,10 @@ where\n                 _ => None,\n             };\n \n-            let get_pos =\n-                |bytepos: rustc_span::BytePos| file.original_relative_byte_pos(bytepos).0 as usize;\n-            let get_range = |span: rustc_span::Span| (get_pos(span.lo()), get_pos(span.hi()));\n-            let get_line = |bytepos: rustc_span::BytePos| file.lookup_line(bytepos).unwrap();\n-            let get_lines = |span: rustc_span::Span| (get_line(span.lo()), get_line(span.hi()));\n-\n             if let Some(file_path) = file_path {\n                 let abs_path = fs::canonicalize(file_path.clone()).unwrap();\n                 let cx = &self.cx;\n-                let enclosing_item_span =\n-                    self.tcx.hir().span_with_body(self.tcx.hir().get_parent_item(ex.hir_id));\n-                assert!(enclosing_item_span.contains(span));\n-\n-                let location = CallLocation {\n-                    call_span: get_range(span),\n-                    enclosing_item_span: get_range(enclosing_item_span),\n-                    enclosing_item_lines: get_lines(enclosing_item_span),\n-                };\n+                let location = CallLocation::new(self.tcx, span, ex.hir_id, &file);\n \n                 entries\n                     .entry(abs_path)"}]}