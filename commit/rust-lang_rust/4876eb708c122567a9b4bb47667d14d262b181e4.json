{"sha": "4876eb708c122567a9b4bb47667d14d262b181e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NzZlYjcwOGMxMjI1NjdhOWI0YmI0NzY2N2QxNGQyNjJiMTgxZTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-01T23:47:24Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-02T19:01:38Z"}, "message": "Fix #1996 (pending snapshot)\n\nChange int to uint in some extfmt code. Remove the #[cfg(stage0)] code\nafter a snapshot.", "tree": {"sha": "33345da6ad3bf3bbe791f9cf6349a989d492ae60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33345da6ad3bf3bbe791f9cf6349a989d492ae60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4876eb708c122567a9b4bb47667d14d262b181e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4876eb708c122567a9b4bb47667d14d262b181e4", "html_url": "https://github.com/rust-lang/rust/commit/4876eb708c122567a9b4bb47667d14d262b181e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4876eb708c122567a9b4bb47667d14d262b181e4/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caf68038dd5bc129a3a9b6972a64c0752b73a004", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf68038dd5bc129a3a9b6972a64c0752b73a004", "html_url": "https://github.com/rust-lang/rust/commit/caf68038dd5bc129a3a9b6972a64c0752b73a004"}], "stats": {"total": 101, "additions": 82, "deletions": 19}, "files": [{"sha": "177178ecc6718dbe9720ae2cfbfb381c7ea36287", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4876eb708c122567a9b4bb47667d14d262b181e4/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876eb708c122567a9b4bb47667d14d262b181e4/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=4876eb708c122567a9b4bb47667d14d262b181e4", "patch": "@@ -65,20 +65,38 @@ pub mod ct {\n         FlagSignAlways,\n         FlagAlternate,\n     }\n+    #[cfg(stage0)]\n     pub enum Count {\n         CountIs(int),\n         CountIsParam(int),\n         CountIsNextParam,\n         CountImplied,\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub enum Count {\n+        CountIs(uint),\n+        CountIsParam(uint),\n+        CountIsNextParam,\n+        CountImplied,\n+    }\n \n-    // A formatted conversion from an expression to a string\n+    #[cfg(stage0)]\n     pub type Conv =\n         {param: Option<int>,\n          flags: ~[Flag],\n          width: Count,\n          precision: Count,\n          ty: Ty};\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    // A formatted conversion from an expression to a string\n+    pub type Conv =\n+        {param: Option<uint>,\n+         flags: ~[Flag],\n+         width: Count,\n+         precision: Count,\n+         ty: Ty};\n \n \n     // A fragment of the output sequence\n@@ -158,8 +176,26 @@ pub mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n+    #[cfg(stage0)]\n     pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: Option<int>, next: uint} {\n+        if i >= lim { return {param: None, next: i}; }\n+        let num = peek_num(s, i, lim);\n+        return match num {\n+              None => {param: None, next: i},\n+              Some(t) => {\n+                let n = t.num as int;\n+                let j = t.next;\n+                if j < lim && s[j] == '$' as u8 {\n+                    {param: Some(n), next: j + 1}\n+                } else { {param: None, next: i} }\n+              }\n+            };\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n+       {param: Option<uint>, next: uint} {\n         if i >= lim { return {param: None, next: i}; }\n         let num = peek_num(s, i, lim);\n         return match num {\n@@ -168,7 +204,7 @@ pub mod ct {\n                 let n = t.num;\n                 let j = t.next;\n                 if j < lim && s[j] == '$' as u8 {\n-                    {param: Some(n as int), next: j + 1u}\n+                    {param: Some(n), next: j + 1}\n                 } else { {param: None, next: i} }\n               }\n             };\n@@ -201,12 +237,13 @@ pub mod ct {\n                 more(FlagAlternate, s, i, lim)\n             } else { {flags: move noflags, next: i} };\n     }\n+    #[cfg(stage0)]\n     pub fn parse_count(s: &str, i: uint, lim: uint)\n         -> {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n             } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1u, lim);\n+                let param = parse_parameter(s, i + 1, lim);\n                 let j = param.next;\n                 match param.param {\n                   None => {count: CountIsNextParam, next: j},\n@@ -223,6 +260,30 @@ pub mod ct {\n                 }\n             };\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+        pub fn parse_count(s: &str, i: uint, lim: uint)\n+        -> {count: Count, next: uint} {\n+        return if i >= lim {\n+                {count: CountImplied, next: i}\n+            } else if s[i] == '*' as u8 {\n+                let param = parse_parameter(s, i + 1, lim);\n+                let j = param.next;\n+                match param.param {\n+                  None => {count: CountIsNextParam, next: j},\n+                  Some(n) => {count: CountIsParam(n), next: j}\n+                }\n+            } else {\n+                let num = peek_num(s, i, lim);\n+                match num {\n+                  None => {count: CountImplied, next: i},\n+                  Some(num) => {\n+                    count: CountIs(num.num),\n+                    next: num.next\n+                  }\n+                }\n+            };\n+    }\n     pub fn parse_precision(s: &str, i: uint, lim: uint) ->\n        {count: Count, next: uint} {\n         return if i >= lim {\n@@ -285,7 +346,12 @@ pub mod rt {\n     pub const flag_sign_always    : u32 = 0b00000000001000u32;\n     pub const flag_alternate      : u32 = 0b00000000010000u32;\n \n+    #[cfg(stage0)]\n     pub enum Count { CountIs(int), CountImplied, }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub enum Count { CountIs(uint), CountImplied, }\n+\n     pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n     pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n@@ -307,11 +373,11 @@ pub mod rt {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n-              TyDefault => uint_to_str_prec(u, 10u, prec),\n-              TyHexLower => uint_to_str_prec(u, 16u, prec),\n-              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n-              TyBits => uint_to_str_prec(u, 2u, prec),\n-              TyOctal => uint_to_str_prec(u, 8u, prec)\n+              TyDefault => uint_to_str_prec(u, 10, prec),\n+              TyHexLower => uint_to_str_prec(u, 16, prec),\n+              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16, prec)),\n+              TyBits => uint_to_str_prec(u, 2, prec),\n+              TyOctal => uint_to_str_prec(u, 8, prec)\n             };\n         return unsafe { pad(cv, move rs, PadUnsigned) };\n     }\n@@ -331,7 +397,7 @@ pub mod rt {\n         let mut unpadded = match cv.precision {\n           CountImplied => s.to_owned(),\n           CountIs(max) => if max as uint < str::char_len(s) {\n-            str::substr(s, 0u, max as uint)\n+            str::substr(s, 0, max as uint)\n           } else {\n             s.to_owned()\n           }\n@@ -412,10 +478,7 @@ pub mod rt {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n           CountImplied => return (move s),\n-          CountIs(width) => {\n-              // FIXME: width should probably be uint (see Issue #1996)\n-              width as uint\n-          }\n+          CountIs(width) => { width as uint }\n         };\n         let strlen = str::char_len(s);\n         if uwidth <= strlen { return (move s); }"}, {"sha": "71801a4d15743364ad71466e1cd09316c95406c8", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4876eb708c122567a9b4bb47667d14d262b181e4/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876eb708c122567a9b4bb47667d14d262b181e4/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=4876eb708c122567a9b4bb47667d14d262b181e4", "patch": "@@ -71,7 +71,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                 return make_rt_path_expr(cx, sp, @~\"CountImplied\");\n               }\n               CountIs(c) => {\n-                let count_lit = mk_int(cx, sp, c);\n+                let count_lit = mk_uint(cx, sp, c as uint);\n                 let count_is_path = make_path_vec(cx, @~\"CountIs\");\n                 let count_is_args = ~[count_lit];\n                 return mk_call(cx, sp, count_is_path, count_is_args);\n@@ -193,7 +193,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     }\n     fn log_conv(c: Conv) {\n         match c.param {\n-          Some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n+          Some(p) => { log(debug, ~\"param: \" + p.to_str()); }\n           _ => debug!(\"param: none\")\n         }\n         for c.flags.each |f| {\n@@ -207,17 +207,17 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n         match c.width {\n           CountIs(i) => log(\n-              debug, ~\"width: count is \" + int::to_str(i, 10u)),\n+              debug, ~\"width: count is \" + i.to_str()),\n           CountIsParam(i) => log(\n-              debug, ~\"width: count is param \" + int::to_str(i, 10u)),\n+              debug, ~\"width: count is param \" + i.to_str()),\n           CountIsNextParam => debug!(\"width: count is next param\"),\n           CountImplied => debug!(\"width: count is implied\")\n         }\n         match c.precision {\n           CountIs(i) => log(\n-              debug, ~\"prec: count is \" + int::to_str(i, 10u)),\n+              debug, ~\"prec: count is \" + i.to_str()),\n           CountIsParam(i) => log(\n-              debug, ~\"prec: count is param \" + int::to_str(i, 10u)),\n+              debug, ~\"prec: count is param \" + i.to_str()),\n           CountIsNextParam => debug!(\"prec: count is next param\"),\n           CountImplied => debug!(\"prec: count is implied\")\n         }"}]}