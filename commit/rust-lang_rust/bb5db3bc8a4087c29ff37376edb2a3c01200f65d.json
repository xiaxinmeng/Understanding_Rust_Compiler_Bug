{"sha": "bb5db3bc8a4087c29ff37376edb2a3c01200f65d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNWRiM2JjOGE0MDg3YzI5ZmYzNzM3NmVkYjJhM2MwMTIwMGY2NWQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-25T00:18:11Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-25T00:21:20Z"}, "message": "Add 2-degree familial relations linked failure tests & fix secondborn behaviour", "tree": {"sha": "e4714cc135ae9289b5edd9ffdce8b918fb39deee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4714cc135ae9289b5edd9ffdce8b918fb39deee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb5db3bc8a4087c29ff37376edb2a3c01200f65d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5db3bc8a4087c29ff37376edb2a3c01200f65d", "html_url": "https://github.com/rust-lang/rust/commit/bb5db3bc8a4087c29ff37376edb2a3c01200f65d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb5db3bc8a4087c29ff37376edb2a3c01200f65d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9c9a2f97e73513030916f646adaed21e0503a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c9a2f97e73513030916f646adaed21e0503a4a", "html_url": "https://github.com/rust-lang/rust/commit/d9c9a2f97e73513030916f646adaed21e0503a4a"}], "stats": {"total": 72, "additions": 62, "deletions": 10}, "files": [{"sha": "f09f2fa7f694b1287bf99a5b9a53f9bdb7d8e080", "filename": "src/libcore/task.rs", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bb5db3bc8a4087c29ff37376edb2a3c01200f65d/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5db3bc8a4087c29ff37376edb2a3c01200f65d/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=bb5db3bc8a4087c29ff37376edb2a3c01200f65d", "patch": "@@ -49,6 +49,7 @@ export run_with;\n \n export spawn;\n export spawn_unlinked;\n+export spawn_supervised;\n export spawn_with;\n export spawn_listener;\n export spawn_sched;\n@@ -728,12 +729,21 @@ unsafe fn taskgroup_key() -> local_data_key<taskgroup> {\n     unsafe::transmute((-2 as uint, 0u))\n }\n \n-fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n+// The 'linked' arg tells whether or not to also ref the unidirectionally-\n+// linked supervisors' group. False when the spawn is supervised, not linked.\n+fn share_spawner_taskgroup(linked: bool)\n+        -> (taskgroup_arc, option<taskgroup_arc>, bool) {\n     let me = rustrt::rust_get_task();\n     alt unsafe { local_get(me, taskgroup_key()) } {\n         some(group) {\n+            // If they are linked to us, they share our parent group.\n+            let parent_arc_opt = if linked {\n+                group.parents.map(|x| alt x { (pg,_) { pg.clone() } })\n+            } else {\n+                none\n+            };\n             // Clone the shared state for the child; propagate main-ness.\n-            (group.tasks.clone(), group.is_main)\n+            (group.tasks.clone(), parent_arc_opt, group.is_main)\n         }\n         none {\n             // Main task, doing first spawn ever.\n@@ -743,26 +753,30 @@ fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n             let group = @taskgroup(me, tasks.clone(), 0, none, true);\n             unsafe { local_set(me, taskgroup_key(), group); }\n             // Tell child task it's also in the main group.\n-            (tasks, true)\n+            // Whether or not it wanted our parent group, we haven't got one.\n+            (tasks, none, true)\n         }\n     }\n }\n \n fn spawn_raw(opts: task_opts, +f: fn~()) {\n     // Decide whether the child needs to be in a new linked failure group.\n-    let ((child_tg, is_main), parent_tg) = if opts.linked {\n+    // This whole conditional should be consolidated with share_spawner above.\n+    let (child_tg, parent_tg, is_main) = if opts.linked {\n         // It doesn't mean anything for a linked-spawned-task to have a parent\n         // group. The spawning task is already bidirectionally linked to it.\n-        (share_parent_taskgroup(), none)\n+        share_spawner_taskgroup(true)\n     } else {\n         // Detached from the parent group; create a new (non-main) one.\n-        ((arc::exclusive(some((dvec::dvec(),dvec::dvec()))), false),\n+        (arc::exclusive(some((dvec::dvec(),dvec::dvec()))),\n          // Allow the parent to unidirectionally fail the child?\n          if opts.parented {\n-             let (pg,_) = share_parent_taskgroup(); some(pg)\n+             // Use the spawner's own group as the child's parent group.\n+             let (pg,_,_) = share_spawner_taskgroup(false); some(pg)\n          } else {\n              none\n-         })\n+         },\n+         false)\n     };\n \n     unsafe {\n@@ -1256,12 +1270,38 @@ fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n     fail;\n }\n \n-// A bonus linked failure test\n+// A couple bonus linked failure tests - testing for failure propagation even\n+// when the middle task exits successfully early before kill signals are sent.\n \n #[test] #[should_fail] // #[ignore(cfg(windows))]\n #[ignore] // FIXME (#1868) (bblum) make this work\n-fn test_spawn_unlinked_sup_propagate_grandchild() {\n+fn test_spawn_failure_propagate_grandchild() {\n+    // Middle task exits; does grandparent's failure propagate across the gap?\n+    do spawn_supervised {\n+        do spawn_supervised {\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(8192) { task::yield(); }\n+    fail;\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_failure_propagate_secondborn() {\n+    // First-born child exits; does parent's failure propagate to sibling?\n     do spawn_supervised {\n+        do spawn { // linked\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(8192) { task::yield(); }\n+    fail;\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_failure_propagate_nephew_or_niece() {\n+    // Our sibling exits; does our failure propagate to sibling's child?\n+    do spawn { // linked\n         do spawn_supervised {\n             loop { task::yield(); }\n         }\n@@ -1270,6 +1310,18 @@ fn test_spawn_unlinked_sup_propagate_grandchild() {\n     fail;\n }\n \n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_sup_propagate_sibling() {\n+    // Middle sibling exits - does eldest's failure propagate to youngest?\n+    do spawn { // linked\n+        do spawn { // linked\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(8192) { task::yield(); }\n+    fail;\n+}\n+\n #[test]\n #[ignore(cfg(windows))]\n fn test_spawn_raw_notify() {"}]}