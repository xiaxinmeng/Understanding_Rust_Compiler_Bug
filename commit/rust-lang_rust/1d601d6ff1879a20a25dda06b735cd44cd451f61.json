{"sha": "1d601d6ff1879a20a25dda06b735cd44cd451f61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNjAxZDZmZjE4NzlhMjBhMjVkZGEwNmI3MzVjZDQ0Y2Q0NTFmNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-03T23:57:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-03T23:57:50Z"}, "message": "Auto merge of #74695 - alexcrichton:more-wasm-float-cast-fixes, r=nagisa\n\nrustc: Improving safe wasm float->int casts\n\nThis commit improves code generation for WebAssembly targets when\ntranslating floating to integer casts. This improvement is only relevant\nwhen the `nontrapping-fptoint` feature is not enabled, but the feature\nis not enabled by default right now. Additionally this improvement only\naffects safe casts since unchecked casts were improved in #74659.\n\nSome more background for this issue is present on #73591, but the\ngeneral gist of the issue is that in LLVM the `fptosi` and `fptoui`\ninstructions are defined to return an `undef` value if they execute on\nout-of-bounds values; they notably do not trap. To implement these\ninstructions for WebAssembly the LLVM backend must therefore generate\nquite a few instructions before executing `i32.trunc_f32_s` (for\nexample) because this WebAssembly instruction traps on out-of-bounds\nvalues. This codegen into wasm instructions happens very late in the\ncode generator, so what ends up happening is that rustc inserts its own\ncodegen to implement Rust's saturating semantics, and then LLVM also\ninserts its own codegen to make sure that the `fptosi` instruction\ndoesn't trap. Overall this means that a function like this:\n\n    #[no_mangle]\n    pub unsafe extern \"C\" fn cast(x: f64) -> u32 {\n        x as u32\n    }\n\nwill generate this WebAssembly today:\n\n    (func $cast (type 0) (param f64) (result i32)\n      (local i32 i32)\n      local.get 0\n      f64.const 0x1.fffffffep+31 (;=4.29497e+09;)\n      f64.gt\n      local.set 1\n      block  ;; label = @1\n        block  ;; label = @2\n          local.get 0\n          f64.const 0x0p+0 (;=0;)\n          local.get 0\n          f64.const 0x0p+0 (;=0;)\n          f64.gt\n          select\n          local.tee 0\n          f64.const 0x1p+32 (;=4.29497e+09;)\n          f64.lt\n          local.get 0\n          f64.const 0x0p+0 (;=0;)\n          f64.ge\n          i32.and\n          i32.eqz\n          br_if 0 (;@2;)\n          local.get 0\n          i32.trunc_f64_u\n          local.set 2\n          br 1 (;@1;)\n        end\n        i32.const 0\n        local.set 2\n      end\n      i32.const -1\n      local.get 2\n      local.get 1\n      select)\n\nThis PR improves the situation by updating the code generation for\nfloat-to-int conversions in rustc, specifically only for WebAssembly\ntargets and only for some situations (float-to-u8 still has not great\ncodegen). The fix here is to use basic blocks and control flow to avoid\nspeculatively executing `fptosi`, and instead LLVM's raw intrinsic for\nthe WebAssembly instruction is used instead. This effectively extends\nthe support added in #74659 to checked casts. After this commit the\ncodegen for the above Rust function looks like:\n\n    (func $cast (type 0) (param f64) (result i32)\n      (local i32)\n      block  ;; label = @1\n        local.get 0\n        f64.const 0x0p+0 (;=0;)\n        f64.ge\n        local.tee 1\n        i32.const 1\n        i32.xor\n        br_if 0 (;@1;)\n        local.get 0\n        f64.const 0x1.fffffffep+31 (;=4.29497e+09;)\n        f64.le\n        i32.eqz\n        br_if 0 (;@1;)\n        local.get 0\n        i32.trunc_f64_u\n        return\n      end\n      i32.const -1\n      i32.const 0\n      local.get 1\n      select)\n\nFor reference, in Rust 1.44, which did not have saturating\nfloat-to-integer casts, the codegen LLVM would emit is:\n\n    (func $cast (type 0) (param f64) (result i32)\n      block  ;; label = @1\n        local.get 0\n        f64.const 0x1p+32 (;=4.29497e+09;)\n        f64.lt\n        local.get 0\n        f64.const 0x0p+0 (;=0;)\n        f64.ge\n        i32.and\n        i32.eqz\n        br_if 0 (;@1;)\n        local.get 0\n        i32.trunc_f64_u\n        return\n      end\n      i32.const 0)\n\nSo we're relatively close to the original codegen, although it's\nslightly different because the semantics of the function changed where\nwe're emulating the `i32.trunc_sat_f32_s` instruction rather than always\nreplacing out-of-bounds values with zero.\n\nThere is still work that could be done to improve casts such as `f32` to\n`u8`. That form of cast still uses the `fptosi` instruction which\ngenerates lots of branch-y code. This seems less important to tackle now\nthough. In the meantime this should take care of most use cases of\nfloating-point conversion and as a result I'm going to speculate that\nthis...\n\nCloses #73591", "tree": {"sha": "3509c0c8b74d73860a050d97fa472c2c02e82391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3509c0c8b74d73860a050d97fa472c2c02e82391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d601d6ff1879a20a25dda06b735cd44cd451f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d601d6ff1879a20a25dda06b735cd44cd451f61", "html_url": "https://github.com/rust-lang/rust/commit/1d601d6ff1879a20a25dda06b735cd44cd451f61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d601d6ff1879a20a25dda06b735cd44cd451f61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8cbd9caca648ecdb66ff4c945c060762aa6297f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8cbd9caca648ecdb66ff4c945c060762aa6297f", "html_url": "https://github.com/rust-lang/rust/commit/d8cbd9caca648ecdb66ff4c945c060762aa6297f"}, {"sha": "2c1b0467e02a763a61335b8acb3c29524bcb9e6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1b0467e02a763a61335b8acb3c29524bcb9e6d", "html_url": "https://github.com/rust-lang/rust/commit/2c1b0467e02a763a61335b8acb3c29524bcb9e6d"}], "stats": {"total": 347, "additions": 235, "deletions": 112}, "files": [{"sha": "1124e91bf718547b07367640d3a95cfe273cba54", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=1d601d6ff1879a20a25dda06b735cd44cd451f61", "patch": "@@ -703,11 +703,67 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         None\n     }\n \n+    fn fptosui_may_trap(&self, val: &'ll Value, dest_ty: &'ll Type) -> bool {\n+        // Most of the time we'll be generating the `fptosi` or `fptoui`\n+        // instruction for floating-point-to-integer conversions. These\n+        // instructions by definition in LLVM do not trap. For the WebAssembly\n+        // target, however, we'll lower in some cases to intrinsic calls instead\n+        // which may trap. If we detect that this is a situation where we'll be\n+        // using the intrinsics then we report that the call map trap, which\n+        // callers might need to handle.\n+        if !self.wasm_and_missing_nontrapping_fptoint() {\n+            return false;\n+        }\n+        let src_ty = self.cx.val_ty(val);\n+        let float_width = self.cx.float_width(src_ty);\n+        let int_width = self.cx.int_width(dest_ty);\n+        match (int_width, float_width) {\n+            (32, 32) | (32, 64) | (64, 32) | (64, 64) => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        // When we can, use the native wasm intrinsics which have tighter\n+        // codegen. Note that this has a semantic difference in that the\n+        // intrinsic can trap whereas `fptoui` never traps. That difference,\n+        // however, is handled by `fptosui_may_trap` above.\n+        if self.wasm_and_missing_nontrapping_fptoint() {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return self.call(intrinsic, &[val], None);\n+            }\n+        }\n         unsafe { llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        if self.wasm_and_missing_nontrapping_fptoint() {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return self.call(intrinsic, &[val], None);\n+            }\n+        }\n         unsafe { llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n@@ -1349,4 +1405,9 @@ impl Builder<'a, 'll, 'tcx> {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n+\n+    fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n+        self.sess().target.target.arch == \"wasm32\"\n+            && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+    }\n }"}, {"sha": "e3a308181b684f0ce0ae1cea98bfb03eced26bcb", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 55, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1d601d6ff1879a20a25dda06b735cd44cd451f61", "patch": "@@ -634,22 +634,19 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n \n             sym::float_to_int_unchecked => {\n-                let float_width = match float_type_width(arg_tys[0]) {\n-                    Some(width) => width,\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `float_to_int_unchecked` \\\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        tcx.sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `float_to_int_unchecked` \\\n                                   intrinsic: expected basic float type, \\\n                                   found `{}`\",\n-                                arg_tys[0]\n-                            ),\n-                        );\n-                        return;\n-                    }\n-                };\n+                            arg_tys[0]\n+                        ),\n+                    );\n+                    return;\n+                }\n                 let (width, signed) = match int_type_width_signed(ret_ty, self.cx) {\n                     Some(pair) => pair,\n                     None => {\n@@ -666,48 +663,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         return;\n                     }\n                 };\n-\n-                // The LLVM backend can reorder and speculate `fptosi` and\n-                // `fptoui`, so on WebAssembly the codegen for this instruction\n-                // is quite heavyweight. To avoid this heavyweight codegen we\n-                // instead use the raw wasm intrinsics which will lower to one\n-                // instruction in WebAssembly (`iNN.trunc_fMM_{s,u}`). This one\n-                // instruction will trap if the operand is out of bounds, but\n-                // that's ok since this intrinsic is UB if the operands are out\n-                // of bounds, so the behavior can be different on WebAssembly\n-                // than other targets.\n-                //\n-                // Note, however, that when the `nontrapping-fptoint` feature is\n-                // enabled in LLVM then LLVM will lower `fptosi` to\n-                // `iNN.trunc_sat_fMM_{s,u}`, so if that's the case we don't\n-                // bother with intrinsics.\n-                let mut result = None;\n-                if self.sess().target.target.arch == \"wasm32\"\n-                    && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-                {\n-                    let name = match (width, float_width, signed) {\n-                        (32, 32, true) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n-                        (32, 64, true) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n-                        (64, 32, true) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n-                        (64, 64, true) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n-                        (32, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n-                        (32, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n-                        (64, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n-                        (64, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n-                        _ => None,\n-                    };\n-                    if let Some(name) = name {\n-                        let intrinsic = self.get_intrinsic(name);\n-                        result = Some(self.call(intrinsic, &[args[0].immediate()], None));\n-                    }\n+                if signed {\n+                    self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                } else {\n+                    self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n                 }\n-                result.unwrap_or_else(|| {\n-                    if signed {\n-                        self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n-                    } else {\n-                        self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n-                    }\n-                })\n             }\n \n             sym::discriminant_value => {"}, {"sha": "77e94fe3d0adc150d311e798a8da022a6d2268b1", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 134, "deletions": 33, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=1d601d6ff1879a20a25dda06b735cd44cd451f61", "patch": "@@ -11,7 +11,7 @@ use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_hir::lang_items::ExchangeMallocFnLangItem;\n use rustc_middle::mir;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n-use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::sym;\n@@ -369,10 +369,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out)\n+                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out, cast)\n                             }\n                             (CastTy::Float, CastTy::Int(_)) => {\n-                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out)\n+                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out, cast)\n                             }\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty),\n                         };\n@@ -772,6 +772,7 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     x: Bx::Value,\n     float_ty: Bx::Type,\n     int_ty: Bx::Type,\n+    int_layout: TyAndLayout<'tcx>,\n ) -> Bx::Value {\n     if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n         return if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n@@ -782,8 +783,6 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         return try_sat_result;\n     }\n \n-    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-\n     let int_width = bx.cx().int_width(int_ty);\n     let float_width = bx.cx().float_width(float_ty);\n     // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n@@ -870,36 +869,138 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n     // QED.\n \n-    // Step 1 was already performed above.\n-\n-    // Step 2: We use two comparisons and two selects, with %s1 being the result:\n-    //     %less_or_nan = fcmp ult %x, %f_min\n-    //     %greater = fcmp olt %x, %f_max\n-    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-    //     %s1 = select %greater, int_ty::MAX, %s0\n-    // Note that %less_or_nan uses an *unordered* comparison. This comparison is true if the\n-    // operands are not comparable (i.e., if x is NaN). The unordered comparison ensures that s1\n-    // becomes int_ty::MIN if x is NaN.\n-    // Performance note: Unordered comparison can be lowered to a \"flipped\" comparison and a\n-    // negation, and the negation can be merged into the select. Therefore, it not necessarily any\n-    // more expensive than a ordered (\"normal\") comparison. Whether these optimizations will be\n-    // performed is ultimately up to the backend, but at least x86 does perform them.\n-    let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n-    let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n     let int_max = bx.cx().const_uint_big(int_ty, int_max(signed, int_width));\n     let int_min = bx.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n-    let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n-    let s1 = bx.select(greater, int_max, s0);\n-\n-    // Step 3: NaN replacement.\n-    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-    // Therefore we only need to execute this step for signed integer types.\n-    if signed {\n-        // LLVM has no isNaN predicate, so we use (x == x) instead\n-        let zero = bx.cx().const_uint(int_ty, 0);\n-        let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n-        bx.select(cmp, s1, zero)\n+    let zero = bx.cx().const_uint(int_ty, 0);\n+\n+    // The codegen here differs quite a bit depending on whether our builder's\n+    // `fptosi` and `fptoui` instructions may trap for out-of-bounds values. If\n+    // they don't trap then we can start doing everything inline with a\n+    // `select` instruction because it's ok to execute `fptosi` and `fptoui`\n+    // even if we don't use the results.\n+    if !bx.fptosui_may_trap(x, int_ty) {\n+        // Step 1 ...\n+        let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n+        let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n+        let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %x, %f_min\n+        //     %greater = fcmp olt %x, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if x is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // x is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than a\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = bx.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (x == x) instead\n+            let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n+            bx.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n     } else {\n-        s1\n+        // In this case we cannot execute `fptosi` or `fptoui` and then later\n+        // discard the result. The builder is telling us that these instructions\n+        // will trap on out-of-bounds values, so we need to use basic blocks and\n+        // control flow to avoid executing the `fptosi` and `fptoui`\n+        // instructions.\n+        //\n+        // The general idea of what we're constructing here is, for f64 -> i32:\n+        //\n+        //      ;; block so far... %0 is the argument\n+        //      %result = alloca i32, align 4\n+        //      %inbound_lower = fcmp oge double %0, 0xC1E0000000000000\n+        //      %inbound_upper = fcmp ole double %0, 0x41DFFFFFFFC00000\n+        //      ;; match (inbound_lower, inbound_upper) {\n+        //      ;;     (true, true) => %0 can be converted without trapping\n+        //      ;;     (false, false) => %0 is a NaN\n+        //      ;;     (true, false) => %0 is too large\n+        //      ;;     (false, true) => %0 is too small\n+        //      ;; }\n+        //      ;;\n+        //      ;; The (true, true) check, go to %convert if so.\n+        //      %inbounds = and i1 %inbound_lower, %inbound_upper\n+        //      br i1 %inbounds, label %convert, label %specialcase\n+        //\n+        //  convert:\n+        //      %cvt = call i32 @llvm.wasm.trunc.signed.i32.f64(double %0)\n+        //      store i32 %cvt, i32* %result, align 4\n+        //      br label %done\n+        //\n+        //  specialcase:\n+        //      ;; Handle the cases where the number is NaN, too large or too small\n+        //\n+        //      ;; Either (true, false) or (false, true)\n+        //      %is_not_nan = or i1 %inbound_lower, %inbound_upper\n+        //      ;; Figure out which saturated value we are interested in if not `NaN`\n+        //      %saturated = select i1 %inbound_lower, i32 2147483647, i32 -2147483648\n+        //      ;; Figure out between saturated and NaN representations\n+        //      %result_nan = select i1 %is_not_nan, i32 %saturated, i32 0\n+        //      store i32 %result_nan, i32* %result, align 4\n+        //      br label %done\n+        //\n+        //  done:\n+        //      %r = load i32, i32* %result, align 4\n+        //      ;; ...\n+        let done = bx.build_sibling_block(\"float_cast_done\");\n+        let mut convert = bx.build_sibling_block(\"float_cast_convert\");\n+        let mut specialcase = bx.build_sibling_block(\"float_cast_specialcase\");\n+\n+        let result = PlaceRef::alloca(bx, int_layout);\n+        result.storage_live(bx);\n+\n+        // Use control flow to figure out whether we can execute `fptosi` in a\n+        // basic block, or whether we go to a different basic block to implement\n+        // the saturating logic.\n+        let inbound_lower = bx.fcmp(RealPredicate::RealOGE, x, f_min);\n+        let inbound_upper = bx.fcmp(RealPredicate::RealOLE, x, f_max);\n+        let inbounds = bx.and(inbound_lower, inbound_upper);\n+        bx.cond_br(inbounds, convert.llbb(), specialcase.llbb());\n+\n+        // Translation of the `convert` basic block\n+        let cvt = if signed { convert.fptosi(x, int_ty) } else { convert.fptoui(x, int_ty) };\n+        convert.store(cvt, result.llval, result.align);\n+        convert.br(done.llbb());\n+\n+        // Translation of the `specialcase` basic block. Note that like above\n+        // we try to be a bit clever here for unsigned conversions. In those\n+        // cases the `int_min` is zero so we don't need two select instructions,\n+        // just one to choose whether we need `int_max` or not. If\n+        // `inbound_lower` is true then we're guaranteed to not be `NaN` and\n+        // since we're greater than zero we must be saturating to `int_max`. If\n+        // `inbound_lower` is false then we're either NaN or less than zero, so\n+        // we saturate to zero.\n+        let result_nan = if signed {\n+            let is_not_nan = specialcase.or(inbound_lower, inbound_upper);\n+            let saturated = specialcase.select(inbound_lower, int_max, int_min);\n+            specialcase.select(is_not_nan, saturated, zero)\n+        } else {\n+            specialcase.select(inbound_lower, int_max, int_min)\n+        };\n+        specialcase.store(result_nan, result.llval, result.align);\n+        specialcase.br(done.llbb());\n+\n+        // Translation of the `done` basic block, positioning ourselves to\n+        // continue from that point as well.\n+        *bx = done;\n+        let ret = bx.load(result.llval, result.align);\n+        result.storage_dead(bx);\n+        ret\n     }\n }"}, {"sha": "4e11ef5fd6e829cf8d3e90b227b9aceb14d18a9f", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=1d601d6ff1879a20a25dda06b735cd44cd451f61", "patch": "@@ -160,6 +160,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n     fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n+    fn fptosui_may_trap(&self, val: Self::Value, dest_ty: Self::Type) -> bool;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;"}, {"sha": "ed51faa7be12f7978eb9246d53fdfdf9332144e9", "filename": "src/test/codegen/wasm_casts_trapping.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d601d6ff1879a20a25dda06b735cd44cd451f61/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs?ref=1d601d6ff1879a20a25dda06b735cd44cd451f61", "patch": "@@ -5,72 +5,72 @@\n // CHECK-LABEL: @cast_f64_i64\n #[no_mangle]\n pub fn cast_f64_i64(a: f64) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptosi double {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f64_i32\n #[no_mangle]\n pub fn cast_f64_i32(a: f64) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptosi double {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_i64\n #[no_mangle]\n pub fn cast_f32_i64(a: f32) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptosi float {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_i32\n #[no_mangle]\n pub fn cast_f32_i32(a: f32) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptosi float {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f64_u64\n #[no_mangle]\n pub fn cast_f64_u64(a: f64) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptoui double {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f64_u32\n #[no_mangle]\n pub fn cast_f64_u32(a: f64) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptoui double {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_u64\n #[no_mangle]\n pub fn cast_f32_u64(a: f32) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptoui float {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_u32\n #[no_mangle]\n pub fn cast_f32_u32(a: f32) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptoui float {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n "}]}